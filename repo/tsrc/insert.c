/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle INSERT statements in SQLite.
*/
#include "sqliteInt.h"

/*
** Generate code that will 
**
**   (1) acquire a lock for table pTab then
**   (2) open pTab as cursor iCur.
**
** If pTab is a WITHOUT ROWID table, then it is the PRIMARY KEY index
** for that table that is actually opened.
*/
void sqlite3OpenTable(
  Parse *pParse,  /* Generate code into this VDBE */
  int iCur,       /* The cursor number of the table */
  int iDb,        /* The database index in sqlite3.aDb[] */
  Table *pTab,    /* The table to be opened */
  int opcode      /* OP_OpenRead or OP_OpenWrite */
){
  Vdbe *v;
  assert( !IsVirtual(pTab) );
  assert( pParse->pVdbe!=0 );
  v = pParse->pVdbe;
  assert( opcode==OP_OpenWrite || opcode==OP_OpenRead );
  
// ABS Label 7
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ABS Label 8
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

// ABS Label 9
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
sqlite3TableLock(pParse, iDb, pTab->tnum, 
                   (opcode==OP_OpenWrite)?1:0, pTab->zName);
  
// MCC Label 10
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 10);
}
// MCC Label 11
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 11);
}
if( HasRowid(pTab) ){
    
// ABS Label 12
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ABS Label 13
if(opcode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// ABS Label 14
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ABS Label 15
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nNVCol);
    VdbeComment((v, "%s", pTab->zName));
  }else{
    Index *pPk = sqlite3PrimaryKeyIndex(pTab);
    assert( pPk!=0 );
    assert( pPk->tnum==pTab->tnum );
    
// ABS Label 16
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ABS Label 17
if(opcode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// ABS Label 18
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ABS Label 19
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3VdbeAddOp3(v, opcode, iCur, pPk->tnum, iDb);
    
// ABS Label 20
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}

// ABS Label 21
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    VdbeComment((v, "%s", pTab->zName));
  }
}

/*
** Return a pointer to the column affinity string associated with index
** pIdx. A column affinity string has one character for each column in 
** the table, according to the affinity of the column:
**
**  Character      Column affinity
**  ------------------------------
**  'A'            BLOB
**  'B'            TEXT
**  'C'            NUMERIC
**  'D'            INTEGER
**  'F'            REAL
**
** An extra 'D' is appended to the end of the string to cover the
** rowid that appears as the last column in every index.
**
** Memory for the buffer containing the column index affinity string
** is managed along with the rest of the Index structure. It will be
** released when sqlite3DeleteIndex() is called.
*/
const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){
  if( !pIdx->zColAff ){
    /* The first time a column affinity string for a particular index is
    ** required, it is allocated and populated here. It is then stored as
    ** a member of the Index structure for subsequent use.
    **
    ** The column affinity string will eventually be deleted by
    ** sqliteDeleteIndex() when the Index structure itself is cleaned
    ** up.
    */
    int n;
    
// ABS Label 22
if(pIdx->pTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
Table *pTab = pIdx->pTable;
    pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);
    if( !pIdx->zColAff ){
      
// ABS Label 23
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3OomFault(db);
      return 0;
    }
    n = 0;

// ABS Label 24
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// ROR Label 25
if((n <= pIdx->nColumn) != (n < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
// ROR Label 26
if((n > pIdx->nColumn) != (n < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
// ROR Label 27
if((n >= pIdx->nColumn) != (n < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
for(; n<pIdx->nColumn; n++){
      
// ABS Label 32
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
// ABS Label 33
if(pIdx->aiColumn[n] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
i16 x = pIdx->aiColumn[n];
      char aff;
      
// ROR Label 34
if((x < 0) != (x >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
// ROR Label 35
if((x > 0) != (x >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
// ROR Label 36
if((x <= 0) != (x >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
if( x>=0 ){
        aff = pTab->aCol[x].affinity;
      }else { 
// ROR Label 37
if((x != (-1)) != (x == (-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
if( x==XN_ROWID ){
        aff = SQLITE_AFF_INTEGER;
      }else{
        assert( x==XN_EXPR );
        assert( pIdx->aColExpr!=0 );
        aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
      };}

      
// ROR Label 38
if((aff <= 65) != (aff < 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((aff > 65) != (aff < 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
// ROR Label 40
if((aff >= 65) != (aff < 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
if( aff<SQLITE_AFF_BLOB ) { aff = SQLITE_AFF_BLOB;
}
      
// ROR Label 41
if((aff <= 67) != (aff > 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
// ROR Label 42
if((aff < 67) != (aff > 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((aff >= 67) != (aff > 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
if( aff>SQLITE_AFF_NUMERIC) { aff = SQLITE_AFF_NUMERIC;
}
      pIdx->zColAff[n] = aff;
    };
// ABS Label 28
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ROR Label 29
if((n <= pIdx->nColumn) != (n < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((n > pIdx->nColumn) != (n < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
// ROR Label 31
if((n >= pIdx->nColumn) != (n < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}

    pIdx->zColAff[n] = 0;
  }
 
  return pIdx->zColAff;
}

/*
** Compute the affinity string for table pTab, if it has not already been
** computed.  As an optimization, omit trailing SQLITE_AFF_BLOB affinities.
**
** If the affinity exists (if it is not entirely SQLITE_AFF_BLOB values) and
** if iReg>0 then code an OP_Affinity opcode that will set the affinities
** for register iReg and following.  Or if affinities exists and iReg==0,
** then just set the P4 operand of the previous opcode (which should  be
** an OP_MakeRecord) to the affinity string.
**
** A column affinity string has one character per column:
**
**  Character      Column affinity
**  ------------------------------
**  'A'            BLOB
**  'B'            TEXT
**  'C'            NUMERIC
**  'D'            INTEGER
**  'E'            REAL
*/
void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){
  int i, j;
  
// ABS Label 44
if(pTab->zColAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}
char *zColAff = pTab->zColAff;
  
// ABS Label 45
if(zColAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// ROR Label 46
if((zColAff != 0) != (zColAff == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
if( zColAff==0 ){
    sqlite3 *db = sqlite3VdbeDb(v);
    zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol+1);
    if( !zColAff ){
      
// ABS Label 47
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}
sqlite3OomFault(db);
      return;
    }

    i = j = 0;

// ABS Label 48
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// ROR Label 49
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
// ROR Label 50
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
// ROR Label 51
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
for(; i<pTab->nCol; i++){
      assert( pTab->aCol[i].affinity!=0 );
      
// ROR Label 56
if(((pTab->aCol[i].colFlags & 32) != 0) != ((pTab->aCol[i].colFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){
        zColAff[j++] = pTab->aCol[i].affinity;
      }
    };
// ABS Label 52
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}

// ROR Label 53
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}
// ROR Label 54
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
// ROR Label 55
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}

    
// ABS Label 57
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}

// COR Label 58
if((j >= 0 || zColAff[j] <= 65) != (j >= 0 && zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 58);
}

// ROR Label 59
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
// ROR Label 60
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
// ROR Label 61
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
// ROR Label 62
if((zColAff[j] < 65) != (zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}
// ROR Label 63
if((zColAff[j] > 65) != (zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((zColAff[j] >= 65) != (zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}

// MCC Label 65
if(j >= 0 && zColAff[j] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 65);
}
// MCC Label 66
if(j >= 0 && !(zColAff[j] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
// MCC Label 67
if(!(j >= 0) && zColAff[j] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 67);
}
// MCC Label 68
if(!(j >= 0) && !(zColAff[j] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 68);
}
do{
      zColAff[j--] = 0;
    }while( j>=0 && zColAff[j]<=SQLITE_AFF_BLOB );
// ABS Label 69
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}

// COR Label 70
if((j >= 0 || zColAff[j] <= 65) != (j >= 0 && zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 70);
}

// ROR Label 71
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
// ROR Label 72
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}
// ROR Label 73
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
// ROR Label 74
if((zColAff[j] < 65) != (zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
// ROR Label 75
if((zColAff[j] > 65) != (zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
// ROR Label 76
if((zColAff[j] >= 65) != (zColAff[j] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}

// MCC Label 77
if(j >= 0 && zColAff[j] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 77);
}
// MCC Label 78
if(j >= 0 && !(zColAff[j] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 78);
}
// MCC Label 79
if(!(j >= 0) && zColAff[j] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 79);
}
// MCC Label 80
if(!(j >= 0) && !(zColAff[j] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 80);
}
;
    pTab->zColAff = zColAff;
  }
  assert( zColAff!=0 );
  i = sqlite3Strlen30NN(zColAff);
  
// ABS Label 81
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
if( i ){
    
// ABS Label 82
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
if( iReg ){
      
// ABS Label 83
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}

// ABS Label 84
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ABS Label 85
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}

// ABS Label 86
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
sqlite3VdbeAddOp4(v, OP_Affinity, iReg, i, 0, zColAff, i);
    }else{
      
// ABS Label 87
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// ABS Label 88
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
sqlite3VdbeChangeP4(v, -1, zColAff, i);
    }
  }
}

/*
** Return non-zero if the table pTab in database iDb or any of its indices
** have been opened at any point in the VDBE program. This is used to see if 
** a statement of the form  "INSERT INTO <iDb, pTab> SELECT ..." can 
** run without using a temporary table for the results of the SELECT. 
*/
static int readsTable(Parse *p, int iDb, Table *pTab){
  Vdbe *v = sqlite3GetVdbe(p);
  int i;
  int iEnd = sqlite3VdbeCurrentAddr(v);
#ifndef SQLITE_OMIT_VIRTUALTABLE
  VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;
#endif

  i = 1;

// ABS Label 89
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
// ABS Label 90
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ROR Label 91
if((i <= iEnd) != (i < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((i > iEnd) != (i < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((i >= iEnd) != (i < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
for(; i<iEnd; i++){
    VdbeOp *pOp = sqlite3VdbeGetOp(v, i);
    assert( pOp!=0 );
    
// ABS Label 99
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
// ABS Label 100
if(pOp->p3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}

// COR Label 101
if((pOp->opcode == 98 || pOp->p3 == iDb) != (pOp->opcode == 98 && pOp->p3 == iDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 101);
}

// ROR Label 102
if((pOp->opcode != 98) != (pOp->opcode == 98))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 102);
}
// ROR Label 103
if((pOp->p3 != iDb) != (pOp->p3 == iDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 103);
}

// MCC Label 104
if(pOp->opcode == 98 && pOp->p3 == iDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 104);
}
// MCC Label 105
if(pOp->opcode == 98 && !(pOp->p3 == iDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 105);
}
// MCC Label 106
if(!(pOp->opcode == 98) && pOp->p3 == iDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 106);
}
// MCC Label 107
if(!(pOp->opcode == 98) && !(pOp->p3 == iDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 107);
}
if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){
      Index *pIndex;
      Pgno tnum = pOp->p2;
      
// ABS Label 108
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
// ABS Label 109
if(tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}

// ROR Label 110
if((tnum != pTab->tnum) != (tnum == pTab->tnum))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
if( tnum==pTab->tnum ){
        return 1;
      }
      pIndex = pTab->pIndex;

// ABS Label 111
if(pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}
for(; pIndex; pIndex=pIndex->pNext){
        
// ABS Label 113
if(pIndex->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
// ABS Label 114
if(tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// ROR Label 115
if((tnum != pIndex->tnum) != (tnum == pIndex->tnum))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
if( tnum==pIndex->tnum ){
          return 1;
        }
      };
// ABS Label 112
if(pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

    }
#ifndef SQLITE_OMIT_VIRTUALTABLE
    
// ABS Label 116
if(pOp->p4.pVtab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
// ABS Label 117
if(pVTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// COR Label 118
if((pOp->opcode == 169 || pOp->p4.pVtab == pVTab) != (pOp->opcode == 169 && pOp->p4.pVtab == pVTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 118);
}

// ROR Label 119
if((pOp->opcode != 169) != (pOp->opcode == 169))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((pOp->p4.pVtab != pVTab) != (pOp->p4.pVtab == pVTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}

// MCC Label 121
if(pOp->opcode == 169 && pOp->p4.pVtab == pVTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 121);
}
// MCC Label 122
if(pOp->opcode == 169 && !(pOp->p4.pVtab == pVTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(!(pOp->opcode == 169) && pOp->p4.pVtab == pVTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
// MCC Label 124
if(!(pOp->opcode == 169) && !(pOp->p4.pVtab == pVTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 124);
}
if( pOp->opcode==OP_VOpen && pOp->p4.pVtab==pVTab ){
      assert( pOp->p4.pVtab!=0 );
      assert( pOp->p4type==P4_VTAB );
      return 1;
    }
#endif
  };
// ABS Label 94
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}
// ABS Label 95
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}

// ROR Label 96
if((i <= iEnd) != (i < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
// ROR Label 97
if((i > iEnd) != (i < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
// ROR Label 98
if((i >= iEnd) != (i < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}

  return 0;
}

/* This walker callback will compute the union of colFlags flags for all
** referenced columns in a CHECK constraint or generated column expression.
*/
static int exprColumnFlagUnion(Walker *pWalker, Expr *pExpr){
  
// COR Label 125
if((pExpr->op == 166 || pExpr->iColumn >= 0) != (pExpr->op == 166 && pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 125);
}

// ROR Label 126
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
// ROR Label 127
if((pExpr->iColumn < 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 127);
}
// ROR Label 128
if((pExpr->iColumn > 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}
// ROR Label 129
if((pExpr->iColumn <= 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 129);
}

// MCC Label 130
if(pExpr->op == 166 && pExpr->iColumn >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
// MCC Label 131
if(pExpr->op == 166 && !(pExpr->iColumn >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 131);
}
// MCC Label 132
if(!(pExpr->op == 166) && pExpr->iColumn >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
// MCC Label 133
if(!(pExpr->op == 166) && !(pExpr->iColumn >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 133);
}
if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 ){
    assert( pExpr->iColumn < pWalker->u.pTab->nCol );
    pWalker->eCode |= pWalker->u.pTab->aCol[pExpr->iColumn].colFlags;
  }
  return WRC_Continue;
}

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
/*
** All regular columns for table pTab have been puts into registers
** starting with iRegStore.  The registers that correspond to STORED
** or VIRTUAL columns have not yet been initialized.  This routine goes
** back and computes the values for those columns based on the previously
** computed normal columns.
*/
void sqlite3ComputeGeneratedColumns(
  Parse *pParse,    /* Parsing context */
  int iRegStore,    /* Register holding the first column */
  Table *pTab       /* The table */
){
  int i;
  Walker w;
  Column *pRedo;
  int eProgress;
  VdbeOp *pOp;

  assert( pTab->tabFlags & TF_HasGenerated );
  testcase( pTab->tabFlags & TF_HasVirtual );
  testcase( pTab->tabFlags & TF_HasStored );

  /* Before computing generated columns, first go through and make sure
  ** that appropriate affinity has been applied to the regular columns
  */
  
// ABS Label 134
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}

// ABS Label 135
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}

// ABS Label 136
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
sqlite3TableAffinity(pParse->pVdbe, pTab, iRegStore);
  if( (pTab->tabFlags & TF_HasStored)!=0
   && (pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1))->opcode==OP_Affinity
  ){
    /* Change the OP_Affinity argument to '@' (NONE) for all stored
    ** columns.  '@' is the no-op affinity and those columns have not
    ** yet been computed. */
    int ii, jj;
    
// ABS Label 137
if(pOp->p4.z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
char *zP4 = pOp->p4.z;
    assert( zP4!=0 );
    assert( pOp->p4type==P4_DYNAMIC );
    ii = jj = 0;

// ABS Label 138
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}
// ABS Label 139
if(zP4[jj] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
for(; zP4[jj]; ii++){
      
// AOR Label 142
if(pTab->aCol[ii].colFlags | 32 != pTab->aCol[ii].colFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 142);
}
// AOR Label 143
if(pTab->aCol[ii].colFlags ^ 32 != pTab->aCol[ii].colFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 143);
}
if( pTab->aCol[ii].colFlags & COLFLAG_VIRTUAL ){
        continue;
      }
      
// AOR Label 144
if(pTab->aCol[ii].colFlags | 64 != pTab->aCol[ii].colFlags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 144);
}
// AOR Label 145
if(pTab->aCol[ii].colFlags ^ 64 != pTab->aCol[ii].colFlags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 145);
}
if( pTab->aCol[ii].colFlags & COLFLAG_STORED ){
        zP4[jj] = SQLITE_AFF_NONE;
      }
      jj++;
    };
// ABS Label 140
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
// ABS Label 141
if(zP4[jj] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

  }

  /* Because there can be multiple generated columns that refer to one another,
  ** this is a two-pass algorithm.  On the first pass, mark all generated
  ** columns as "not available".
  */
  i = 0;

// ABS Label 146
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ROR Label 147
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 147);
}
// ROR Label 148
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 148);
}
// ROR Label 149
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
for(; i<pTab->nCol; i++){
    
// AOR Label 154
if(pTab->aCol[i].colFlags | 96 != pTab->aCol[i].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 154);
}
// AOR Label 155
if(pTab->aCol[i].colFlags ^ 96 != pTab->aCol[i].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 155);
}
if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){
      testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );
      testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );
      pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;
    }
  };
// ABS Label 150
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ROR Label 151
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
// ROR Label 153
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 153);
}


  w.u.pTab = pTab;
  w.xExprCallback = exprColumnFlagUnion;
  w.xSelectCallback = 0;
  w.xSelectCallback2 = 0;

  /* On the second pass, compute the value of each NOT-AVAILABLE column.
  ** Companion code in the TK_COLUMN case of sqlite3ExprCodeTarget() will
  ** compute dependencies and mark remove the COLSPAN_NOTAVAIL mark, as
  ** they are needed.
  */
  pParse->iSelfTab = -iRegStore;
  
// ABS Label 156
if(eProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
// ABS Label 157
if(pRedo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// COR Label 158
if((pRedo || eProgress) != (pRedo && eProgress))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 158);
}

// MCC Label 159
if(pRedo && eProgress ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 159);
}
// MCC Label 160
if(pRedo && !(eProgress) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 160);
}
// MCC Label 161
if(!(pRedo) && eProgress ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 161);
}
// MCC Label 162
if(!(pRedo) && !(eProgress) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 162);
}
do{
    eProgress = 0;
    pRedo = 0;
    i = 0;

// ABS Label 170
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// ROR Label 171
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 171);
}
// ROR Label 172
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 172);
}
// ROR Label 173
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
for(; i<pTab->nCol; i++){
      
// ABS Label 178
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}
// ABS Label 179
if(pTab->aCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}

// AOR Label 180
if(pTab->aCol - i != pTab->aCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 180);
}
// AOR Label 181
if(pTab->aCol / i != pTab->aCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 181);
}
// AOR Label 182
if(pTab->aCol * i != pTab->aCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 182);
}
Column *pCol = pTab->aCol + i;
      
// ROR Label 183
if(((pCol->colFlags & 128) == 0) != ((pCol->colFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
if( (pCol->colFlags & COLFLAG_NOTAVAIL)!=0 ){
        int x;
        pCol->colFlags |= COLFLAG_BUSY;
        w.eCode = 0;
        
// ABS Label 184
if(pCol->pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}
sqlite3WalkExpr(&w, pCol->pDflt);
        pCol->colFlags &= ~COLFLAG_BUSY;
        
// AOR Label 188
if(w.eCode | 128 != w.eCode & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 188);
}
// AOR Label 189
if(w.eCode ^ 128 != w.eCode & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 189);
}
if( w.eCode & COLFLAG_NOTAVAIL ){
          pRedo = pCol;
          continue;
        }
        eProgress = 1;
        assert( pCol->colFlags & COLFLAG_GENERATED );
        x = sqlite3TableColumnToStorage(pTab, i) + iRegStore;
        
// ABS Label 185
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}

// ABS Label 186
if(pCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ABS Label 187
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
sqlite3ExprCodeGeneratedColumn(pParse, pCol, x);
        pCol->colFlags &= ~COLFLAG_NOTAVAIL;
      }
    };
// ABS Label 174
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ROR Label 175
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
// ROR Label 176
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
// ROR Label 177
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 177);
}

  }while( pRedo && eProgress );
// ABS Label 163
if(eProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}
// ABS Label 164
if(pRedo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}

// COR Label 165
if((pRedo || eProgress) != (pRedo && eProgress))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 165);
}

// MCC Label 166
if(pRedo && eProgress ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(pRedo && !(eProgress) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
// MCC Label 168
if(!(pRedo) && eProgress ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
// MCC Label 169
if(!(pRedo) && !(eProgress) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
;
  
// ABS Label 190
if(pRedo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
if( pRedo ){
    
// ABS Label 191
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// ABS Label 192
if(pRedo->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pRedo->zName);
  }
  pParse->iSelfTab = 0;
}
#endif /* SQLITE_OMIT_GENERATED_COLUMNS */


#ifndef SQLITE_OMIT_AUTOINCREMENT
/*
** Locate or create an AutoincInfo structure associated with table pTab
** which is in database iDb.  Return the register number for the register
** that holds the maximum rowid.  Return zero if pTab is not an AUTOINCREMENT
** table.  (Also return zero when doing a VACUUM since we do not want to
** update the AUTOINCREMENT counters during a VACUUM.)
**
** There is at most one AutoincInfo structure per table even if the
** same table is autoincremented multiple times due to inserts within
** triggers.  A new AutoincInfo structure is created if this is the
** first use of table pTab.  On 2nd and subsequent uses, the original
** AutoincInfo structure is used.
**
** Four consecutive registers are allocated:
**
**   (1)  The name of the pTab table.
**   (2)  The maximum ROWID of pTab.
**   (3)  The rowid in sqlite_sequence of pTab
**   (4)  The original value of the max ROWID in pTab, or NULL if none
**
** The 2nd register is the one that is returned.  That is all the
** insert routine needs to know about.
*/
static int autoIncBegin(
  Parse *pParse,      /* Parsing context */
  int iDb,            /* Index of the database holding pTab */
  Table *pTab         /* The table we are writing to */
){
  int memId = 0;      /* Register holding maximum rowid */
  assert( pParse->db->aDb[iDb].pSchema!=0 );
  
// COR Label 193
if(((pTab->tabFlags & 8) != 0 || (pParse->db->mDbFlags & 4) == 0) != ((pTab->tabFlags & 8) != 0 && (pParse->db->mDbFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 193);
}

// ROR Label 194
if(((pTab->tabFlags & 8) == 0) != ((pTab->tabFlags & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
// ROR Label 195
if(((pParse->db->mDbFlags & 4) != 0) != ((pParse->db->mDbFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}

// MCC Label 196
if((pTab->tabFlags & 8) != 0 && (pParse->db->mDbFlags & 4) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if((pTab->tabFlags & 8) != 0 && !((pParse->db->mDbFlags & 4) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
// MCC Label 198
if(!((pTab->tabFlags & 8) != 0) && (pParse->db->mDbFlags & 4) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 198);
}
// MCC Label 199
if(!((pTab->tabFlags & 8) != 0) && !((pParse->db->mDbFlags & 4) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 199);
}
if( (pTab->tabFlags & TF_Autoincrement)!=0
   && (pParse->db->mDbFlags & DBFLAG_Vacuum)==0
  ){
    Parse *pToplevel = sqlite3ParseToplevel(pParse);
    AutoincInfo *pInfo;
    
// ABS Label 200
if(pParse->db->aDb[iDb].pSchema->pSeqTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
Table *pSeqTab = pParse->db->aDb[iDb].pSchema->pSeqTab;

    /* Verify that the sqlite_sequence table exists and is an ordinary
    ** rowid table with exactly two columns.
    ** Ticket d8dc2b3a58cd5dc2918a1d4acb 2018-05-23 */
    
// ABS Label 201
if((((pSeqTab)->nModuleArg)) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}
// ABS Label 202
if(pSeqTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}

// COR Label 203
if((pSeqTab == 0 || !(((pSeqTab)->tabFlags & 128) == 0) || (((pSeqTab)->nModuleArg)) && pSeqTab->nCol != 2) != (pSeqTab == 0 || !(((pSeqTab)->tabFlags & 128) == 0) || (((pSeqTab)->nModuleArg)) || pSeqTab->nCol != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 203);
}
// COR Label 204
if((pSeqTab == 0 || !(((pSeqTab)->tabFlags & 128) == 0) && (((pSeqTab)->nModuleArg))) != (pSeqTab == 0 || !(((pSeqTab)->tabFlags & 128) == 0) || (((pSeqTab)->nModuleArg))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 204);
}
// COR Label 205
if((pSeqTab == 0 && !(((pSeqTab)->tabFlags & 128) == 0)) != (pSeqTab == 0 || !(((pSeqTab)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 205);
}

// ROR Label 206
if((pSeqTab != 0) != (pSeqTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((pSeqTab->nCol == 2) != (pSeqTab->nCol != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}

// MCC Label 208
if(pSeqTab == 0 && !(((pSeqTab)->tabFlags & 128) == 0) && (((pSeqTab)->nModuleArg)) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(pSeqTab == 0 && !(((pSeqTab)->tabFlags & 128) == 0) && (((pSeqTab)->nModuleArg)) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(pSeqTab == 0 && !(((pSeqTab)->tabFlags & 128) == 0) && !((((pSeqTab)->nModuleArg))) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(pSeqTab == 0 && !(((pSeqTab)->tabFlags & 128) == 0) && !((((pSeqTab)->nModuleArg))) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if(pSeqTab == 0 && !(!(((pSeqTab)->tabFlags & 128) == 0)) && (((pSeqTab)->nModuleArg)) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(pSeqTab == 0 && !(!(((pSeqTab)->tabFlags & 128) == 0)) && (((pSeqTab)->nModuleArg)) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(pSeqTab == 0 && !(!(((pSeqTab)->tabFlags & 128) == 0)) && !((((pSeqTab)->nModuleArg))) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(pSeqTab == 0 && !(!(((pSeqTab)->tabFlags & 128) == 0)) && !((((pSeqTab)->nModuleArg))) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(!(pSeqTab == 0) && !(((pSeqTab)->tabFlags & 128) == 0) && (((pSeqTab)->nModuleArg)) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(!(pSeqTab == 0) && !(((pSeqTab)->tabFlags & 128) == 0) && (((pSeqTab)->nModuleArg)) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(!(pSeqTab == 0) && !(((pSeqTab)->tabFlags & 128) == 0) && !((((pSeqTab)->nModuleArg))) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
// MCC Label 219
if(!(pSeqTab == 0) && !(((pSeqTab)->tabFlags & 128) == 0) && !((((pSeqTab)->nModuleArg))) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(!(pSeqTab == 0) && !(!(((pSeqTab)->tabFlags & 128) == 0)) && (((pSeqTab)->nModuleArg)) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(!(pSeqTab == 0) && !(!(((pSeqTab)->tabFlags & 128) == 0)) && (((pSeqTab)->nModuleArg)) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
// MCC Label 222
if(!(pSeqTab == 0) && !(!(((pSeqTab)->tabFlags & 128) == 0)) && !((((pSeqTab)->nModuleArg))) && pSeqTab->nCol != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
// MCC Label 223
if(!(pSeqTab == 0) && !(!(((pSeqTab)->tabFlags & 128) == 0)) && !((((pSeqTab)->nModuleArg))) && !(pSeqTab->nCol != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
if( pSeqTab==0
     || !HasRowid(pSeqTab)
     || NEVER(IsVirtual(pSeqTab))
     || pSeqTab->nCol!=2
    ){
      pParse->nErr++;
      pParse->rc = SQLITE_CORRUPT_SEQUENCE;
      return 0;
    }

    pInfo = pToplevel->pAinc;
    
// ABS Label 224
if(pInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
// ABS Label 225
if(pInfo->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}
// ABS Label 226
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}

// COR Label 227
if((pInfo || pInfo->pTab != pTab) != (pInfo && pInfo->pTab != pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 227);
}

// ROR Label 228
if((pInfo->pTab == pTab) != (pInfo->pTab != pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 228);
}

// MCC Label 229
if(pInfo && pInfo->pTab != pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(pInfo && !(pInfo->pTab != pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(!(pInfo) && pInfo->pTab != pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(!(pInfo) && !(pInfo->pTab != pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; };
// ABS Label 233
if(pInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}
// ABS Label 234
if(pInfo->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}
// ABS Label 235
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}

// COR Label 236
if((pInfo || pInfo->pTab != pTab) != (pInfo && pInfo->pTab != pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 236);
}

// ROR Label 237
if((pInfo->pTab == pTab) != (pInfo->pTab != pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}

// MCC Label 238
if(pInfo && pInfo->pTab != pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 238);
}
// MCC Label 239
if(pInfo && !(pInfo->pTab != pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 239);
}
// MCC Label 240
if(!(pInfo) && pInfo->pTab != pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(!(pInfo) && !(pInfo->pTab != pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}

    
// ABS Label 242
if(pInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}

// ROR Label 243
if((pInfo != 0) != (pInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
if( pInfo==0 ){
      pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));
      
// ABS Label 244
if(pToplevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}
sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);
      testcase( pParse->earlyCleanup );
      
// ABS Label 245
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}
if( pParse->db->mallocFailed ) { return 0;
}
      pInfo->pNext = pToplevel->pAinc;
      pToplevel->pAinc = pInfo;
      pInfo->pTab = pTab;
      pInfo->iDb = iDb;
      pToplevel->nMem++;                  /* Register to hold name of table */
      pInfo->regCtr = ++pToplevel->nMem;  /* Max rowid register */
      pToplevel->nMem +=2;       /* Rowid in sqlite_sequence + orig max val */
    }
    memId = pInfo->regCtr;
  }
  
// ABS Label 246
if(memId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}
return memId;
}

/*
** This routine generates code that will initialize all of the
** register used by the autoincrement tracker.  
*/
void sqlite3AutoincrementBegin(Parse *pParse){
  AutoincInfo *p;            /* Information about an AUTOINCREMENT */
  
// ABS Label 247
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
sqlite3 *db = pParse->db;  /* The database connection */
  Db *pDb;                   /* Database only autoinc table */
  int memId;                 /* Register holding max rowid */
  
// ABS Label 248
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
Vdbe *v = pParse->pVdbe;   /* VDBE under construction */

  /* This routine is never called during trigger-generation.  It is
  ** only called from the top-level */
  assert( pParse->pTriggerTab==0 );
  assert( sqlite3IsToplevel(pParse) );

  assert( v );   /* We failed long ago if this is not so */
  p = pParse->pAinc;

// ABS Label 249
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
for(; p; p = p->pNext){
    static const int iLn = VDBE_OFFSET_LINENO(2);
    static const VdbeOpList autoInc[] = {
      /* 0  */ {OP_Null,    0,  0, 0},
      /* 1  */ {OP_Rewind,  0, 10, 0},
      /* 2  */ {OP_Column,  0,  0, 0},
      /* 3  */ {OP_Ne,      0,  9, 0},
      /* 4  */ {OP_Rowid,   0,  0, 0},
      /* 5  */ {OP_Column,  0,  1, 0},
      /* 6  */ {OP_AddImm,  0,  0, 0},
      /* 7  */ {OP_Copy,    0,  0, 0},
      /* 8  */ {OP_Goto,    0, 11, 0},
      /* 9  */ {OP_Next,    0,  2, 0},
      /* 10 */ {OP_Integer, 0,  0, 0},
      /* 11 */ {OP_Close,   0,  0, 0} 
    };
    VdbeOp *aOp;
    pDb = &db->aDb[p->iDb];
    memId = p->regCtr;
    assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );
    
// ABS Label 251
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ABS Label 252
if(p->iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}

// ABS Label 253
if(pDb->pSchema->pSeqTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}
sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenRead);
    
// ABS Label 254
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}

// ABS Label 255
if(memId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}

// AOR Label 256
if(memId / 1 != memId - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 256);
}
// AOR Label 257
if(memId + 1 != memId - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 257);
}
// AOR Label 258
if(memId * 1 != memId - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 258);
}
sqlite3VdbeLoadString(v, memId-1, p->pTab->zName);
    aOp = sqlite3VdbeAddOpList(v, ArraySize(autoInc), autoInc, iLn);
    
// ABS Label 259
if(aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}

// ROR Label 260
if((aOp != 0) != (aOp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 260);
}
if( aOp==0 ) { break;
}
    aOp[0].p2 = memId;
    aOp[0].p3 = memId+2;
    aOp[2].p3 = memId;
    aOp[3].p1 = memId-1;
    aOp[3].p3 = memId;
    aOp[3].p5 = SQLITE_JUMPIFNULL;
    aOp[4].p2 = memId+1;
    aOp[5].p3 = memId;
    aOp[6].p1 = memId;
    aOp[7].p2 = memId+2;
    aOp[7].p1 = memId;
    aOp[10].p2 = memId;
    
// ABS Label 261
if(pParse->nTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}

// ROR Label 262
if((pParse->nTab != 0) != (pParse->nTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
if( pParse->nTab==0 ) { pParse->nTab = 1;
}
  };
// ABS Label 250
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

}

/*
** Update the maximum rowid for an autoincrement calculation.
**
** This routine should be called when the regRowid register holds a
** new rowid that is about to be inserted.  If that new rowid is
** larger than the maximum rowid in the memId memory cell, then the
** memory cell is updated.
*/
static void autoIncStep(Parse *pParse, int memId, int regRowid){
  
// ABS Label 263
if(memId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}

// ROR Label 264
if((memId <= 0) != (memId > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}
// ROR Label 265
if((memId < 0) != (memId > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
// ROR Label 266
if((memId >= 0) != (memId > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}
if( memId>0 ){
    
// ABS Label 267
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 267);
}

// ABS Label 268
if(memId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}

// ABS Label 269
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
sqlite3VdbeAddOp2(pParse->pVdbe, OP_MemMax, memId, regRowid);
  }
}

/*
** This routine generates the code needed to write autoincrement
** maximum rowid values back into the sqlite_sequence register.
** Every statement that might do an INSERT into an autoincrement
** table (either directly or through triggers) needs to call this
** routine just before the "exit" code.
*/
static SQLITE_NOINLINE void autoIncrementEnd(Parse *pParse){
  AutoincInfo *p;
  
// ABS Label 270
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
Vdbe *v = pParse->pVdbe;
  
// ABS Label 271
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
sqlite3 *db = pParse->db;

  assert( v );
  p = pParse->pAinc;

// ABS Label 272
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
for(; p; p = p->pNext){
    static const int iLn = VDBE_OFFSET_LINENO(2);
    static const VdbeOpList autoIncEnd[] = {
      /* 0 */ {OP_NotNull,     0, 2, 0},
      /* 1 */ {OP_NewRowid,    0, 0, 0},
      /* 2 */ {OP_MakeRecord,  0, 2, 0},
      /* 3 */ {OP_Insert,      0, 0, 0},
      /* 4 */ {OP_Close,       0, 0, 0}
    };
    VdbeOp *aOp;
    Db *pDb = &db->aDb[p->iDb];
    int iRec;
    
// ABS Label 274
if(p->regCtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
int memId = p->regCtr;

    iRec = sqlite3GetTempReg(pParse);
    assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );
    
// ABS Label 275
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}

// ABS Label 276
if(memId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}

// AOR Label 277
if(memId - 2 != memId + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 277);
}
// AOR Label 278
if(memId / 2 != memId + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 278);
}
// AOR Label 279
if(memId * 2 != memId + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 279);
}

// ABS Label 280
if(memId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
sqlite3VdbeAddOp3(v, OP_Le, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId);
    VdbeCoverage(v);
    
// ABS Label 281
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// ABS Label 282
if(p->iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}

// ABS Label 283
if(pDb->pSchema->pSeqTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}
sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);
    aOp = sqlite3VdbeAddOpList(v, ArraySize(autoIncEnd), autoIncEnd, iLn);
    
// ABS Label 286
if(aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ROR Label 287
if((aOp != 0) != (aOp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
if( aOp==0 ) { break;
}
    aOp[0].p1 = memId+1;
    aOp[1].p2 = memId+1;
    aOp[2].p1 = memId-1;
    aOp[2].p3 = iRec;
    aOp[3].p2 = iRec;
    aOp[3].p3 = memId+1;
    aOp[3].p5 = OPFLAG_APPEND;
    
// ABS Label 284
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}

// ABS Label 285
if(iRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
sqlite3ReleaseTempReg(pParse, iRec);
  };
// ABS Label 273
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

}
void sqlite3AutoincrementEnd(Parse *pParse){
  
// ABS Label 288
if(pParse->pAinc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}
if( pParse->pAinc ) { 
// ABS Label 289
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}
autoIncrementEnd(pParse);
}
}
#else
/*
** If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines
** above are all no-ops
*/
# define autoIncBegin(A,B,C) (0)
# define autoIncStep(A,B,C)
#endif /* SQLITE_OMIT_AUTOINCREMENT */


/* Forward declaration */
static int xferOptimization(
  Parse *pParse,        /* Parser context */
  Table *pDest,         /* The table we are inserting into */
  Select *pSelect,      /* A SELECT statement to use as the data source */
  int onError,          /* How to handle constraint errors */
  int iDbDest           /* The database of pDest */
);

/*
** This routine is called to handle SQL of the following forms:
**
**    insert into TABLE (IDLIST) values(EXPRLIST),(EXPRLIST),...
**    insert into TABLE (IDLIST) select
**    insert into TABLE (IDLIST) default values
**
** The IDLIST following the table name is always optional.  If omitted,
** then a list of all (non-hidden) columns for the table is substituted.
** The IDLIST appears in the pColumn parameter.  pColumn is NULL if IDLIST
** is omitted.
**
** For the pSelect parameter holds the values to be inserted for the
** first two forms shown above.  A VALUES clause is really just short-hand
** for a SELECT statement that omits the FROM clause and everything else
** that follows.  If the pSelect parameter is NULL, that means that the
** DEFAULT VALUES form of the INSERT statement is intended.
**
** The code generated follows one of four templates.  For a simple
** insert with data coming from a single-row VALUES clause, the code executes
** once straight down through.  Pseudo-code follows (we call this
** the "1st template"):
**
**         open write cursor to <table> and its indices
**         put VALUES clause expressions into registers
**         write the resulting record into <table>
**         cleanup
**
** The three remaining templates assume the statement is of the form
**
**   INSERT INTO <table> SELECT ...
**
** If the SELECT clause is of the restricted form "SELECT * FROM <table2>" -
** in other words if the SELECT pulls all columns from a single table
** and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and
** if <table2> and <table1> are distinct tables but have identical
** schemas, including all the same indices, then a special optimization
** is invoked that copies raw records from <table2> over to <table1>.
** See the xferOptimization() function for the implementation of this
** template.  This is the 2nd template.
**
**         open a write cursor to <table>
**         open read cursor on <table2>
**         transfer all records in <table2> over to <table>
**         close cursors
**         foreach index on <table>
**           open a write cursor on the <table> index
**           open a read cursor on the corresponding <table2> index
**           transfer all records from the read to the write cursors
**           close cursors
**         end foreach
**
** The 3rd template is for when the second template does not apply
** and the SELECT clause does not read from <table> at any time.
** The generated code follows this template:
**
**         X <- A
**         goto B
**      A: setup for the SELECT
**         loop over the rows in the SELECT
**           load values into registers R..R+n
**           yield X
**         end loop
**         cleanup after the SELECT
**         end-coroutine X
**      B: open write cursor to <table> and its indices
**      C: yield X, at EOF goto D
**         insert the select result into <table> from R..R+n
**         goto C
**      D: cleanup
**
** The 4th template is used if the insert statement takes its
** values from a SELECT but the data is being inserted into a table
** that is also read as part of the SELECT.  In the third form,
** we have to use an intermediate table to store the results of
** the select.  The template is like this:
**
**         X <- A
**         goto B
**      A: setup for the SELECT
**         loop over the tables in the SELECT
**           load value into register R..R+n
**           yield X
**         end loop
**         cleanup after the SELECT
**         end co-routine R
**      B: open temp table
**      L: yield X, at EOF goto M
**         insert row from R..R+n into temp table
**         goto L
**      M: open write cursor to <table> and its indices
**         rewind temp table
**      C: loop over rows of intermediate table
**           transfer values form intermediate table into <table>
**         end loop
**      D: cleanup
*/
void sqlite3Insert(
  Parse *pParse,        /* Parser context */
  SrcList *pTabList,    /* Name of table into which we are inserting */
  Select *pSelect,      /* A SELECT statement to use as the data source */
  IdList *pColumn,      /* Column names corresponding to IDLIST, or NULL. */
  int onError,          /* How to handle constraint errors */
  Upsert *pUpsert       /* ON CONFLICT clauses for upsert, or NULL */
){
  sqlite3 *db;          /* The main database structure */
  Table *pTab;          /* The table to insert into.  aka TABLE */
  int i, j;             /* Loop counters */
  Vdbe *v;              /* Generate code into this virtual machine */
  Index *pIdx;          /* For looping over indices of the table */
  int nColumn;          /* Number of columns in the data */
  int nHidden = 0;      /* Number of hidden columns if TABLE is virtual */
  int iDataCur = 0;     /* VDBE cursor that is the main data repository */
  int iIdxCur = 0;      /* First index cursor */
  int ipkColumn = -1;   /* Column that is the INTEGER PRIMARY KEY */
  int endOfLoop;        /* Label for the end of the insertion loop */
  int srcTab = 0;       /* Data comes from this temporary cursor if >=0 */
  int addrInsTop = 0;   /* Jump to label "D" */
  int addrCont = 0;     /* Top of insert loop. Label "C" in templates 3 and 4 */
  SelectDest dest;      /* Destination for SELECT on rhs of INSERT */
  int iDb;              /* Index of database holding TABLE */
  u8 useTempTable = 0;  /* Store SELECT results in intermediate table */
  u8 appendFlag = 0;    /* True if the insert is likely to be an append */
  u8 withoutRowid;      /* 0 for normal table.  1 for WITHOUT ROWID table */
  u8 bIdListInOrder;    /* True if IDLIST is in table order */
  ExprList *pList = 0;  /* List of VALUES() to be inserted  */
  int iRegStore;        /* Register in which to store next column */

  /* Register allocations */
  int regFromSelect = 0;/* Base register for data coming from SELECT */
  int regAutoinc = 0;   /* Register holding the AUTOINCREMENT counter */
  int regRowCount = 0;  /* Memory cell used for the row counter */
  int regIns;           /* Block of regs holding rowid+data being inserted */
  int regRowid;         /* registers holding insert rowid */
  int regData;          /* register holding first column to insert */
  int *aRegIdx = 0;     /* One register allocated to each index */

#ifndef SQLITE_OMIT_TRIGGER
  int isView;                 /* True if attempting to insert into a view */
  Trigger *pTrigger;          /* List of triggers on pTab, if required */
  int tmask;                  /* Mask of trigger times */
#endif

  db = pParse->db;
  
// ABS Label 306
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}

// COR Label 307
if((pParse->nErr && db->mallocFailed) != (pParse->nErr || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 307);
}

// MCC Label 308
if(pParse->nErr && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 308);
}
// MCC Label 309
if(pParse->nErr && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 309);
}
// MCC Label 310
if(!(pParse->nErr) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 310);
}
// MCC Label 311
if(!(pParse->nErr) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 311);
}
if( pParse->nErr || db->mallocFailed ){
    goto insert_cleanup;
  }
  dest.iSDParm = 0;  /* Suppress a harmless compiler warning */

  /* If the Select object is really just a simple VALUES() list with a
  ** single row (the common case) then keep that one row of values
  ** and discard the other (unused) parts of the pSelect object
  */
  
// ABS Label 312
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
// ABS Label 313
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}

// COR Label 314
if((pSelect && (pSelect->selFlags & 512) != 0 || pSelect->pPrior == 0) != (pSelect && (pSelect->selFlags & 512) != 0 && pSelect->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 314);
}
// COR Label 315
if((pSelect || (pSelect->selFlags & 512) != 0) != (pSelect && (pSelect->selFlags & 512) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 315);
}

// ROR Label 316
if(((pSelect->selFlags & 512) == 0) != ((pSelect->selFlags & 512) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
// ROR Label 317
if((pSelect->pPrior != 0) != (pSelect->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}

// MCC Label 318
if(pSelect && (pSelect->selFlags & 512) != 0 && pSelect->pPrior == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 318);
}
// MCC Label 319
if(pSelect && (pSelect->selFlags & 512) != 0 && !(pSelect->pPrior == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 319);
}
// MCC Label 320
if(pSelect && !((pSelect->selFlags & 512) != 0) && pSelect->pPrior == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 320);
}
// MCC Label 321
if(pSelect && !((pSelect->selFlags & 512) != 0) && !(pSelect->pPrior == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 321);
}
// MCC Label 322
if(!(pSelect) && (pSelect->selFlags & 512) != 0 && pSelect->pPrior == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
// MCC Label 323
if(!(pSelect) && (pSelect->selFlags & 512) != 0 && !(pSelect->pPrior == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
// MCC Label 324
if(!(pSelect) && !((pSelect->selFlags & 512) != 0) && pSelect->pPrior == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 324);
}
// MCC Label 325
if(!(pSelect) && !((pSelect->selFlags & 512) != 0) && !(pSelect->pPrior == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 325);
}
if( pSelect && (pSelect->selFlags & SF_Values)!=0 && pSelect->pPrior==0 ){
    pList = pSelect->pEList;
    pSelect->pEList = 0;
    
// ABS Label 326
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ABS Label 327
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
sqlite3SelectDelete(db, pSelect);
    pSelect = 0;
  }

  /* Locate the table into which we will be inserting new information.
  */
  assert( pTabList->nSrc==1 );
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  
// ABS Label 328
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ROR Label 329
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 329);
}
if( pTab==0 ){
    goto insert_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  assert( iDb<db->nDb );
  if( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab->zName, 0,
                       db->aDb[iDb].zDbSName) ){
    goto insert_cleanup;
  }
  withoutRowid = !HasRowid(pTab);

  /* Figure out if we have any triggers and if the table being
  ** inserted into is a view
  */
#ifndef SQLITE_OMIT_TRIGGER
  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_INSERT, 0, &tmask);
  isView = pTab->pSelect!=0;
#else
# define pTrigger 0
# define tmask 0
# define isView 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif
  assert( (pTrigger && tmask) || (pTrigger==0 && tmask==0) );

  /* If pTab is really a view, make sure it has been initialized.
  ** ViewGetColumnNames() is a no-op if pTab is not a view.
  */
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto insert_cleanup;
  }

  /* Cannot insert into a read-only table.
  */
  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){
    goto insert_cleanup;
  }

  /* Allocate a VDBE
  */
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 330
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ROR Label 331
if((v != 0) != (v == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 331);
}
if( v==0 ) { goto insert_cleanup;
}
  
// ROR Label 332
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 332);
}
if( pParse->nested==0 ) { 
// ABS Label 333
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
sqlite3VdbeCountChanges(v);
}
  
// ABS Label 290
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ABS Label 291
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}
// ABS Label 292
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}

// COR Label 293
if((pSelect && pTrigger) != (pSelect || pTrigger))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 293);
}

// ABS Label 294
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);

#ifndef SQLITE_OMIT_XFER_OPT
  /* If the statement is of the form
  **
  **       INSERT INTO <table1> SELECT * FROM <table2>;
  **
  ** Then special optimizations can be applied that make the transfer
  ** very fast and which reduce fragmentation of indices.
  **
  ** This is the 2nd template.
  */
  if( pColumn==0 && xferOptimization(pParse, pTab, pSelect, onError, iDb) ){
    assert( !pTrigger );
    assert( pList==0 );
    goto insert_end;
  }
#endif /* SQLITE_OMIT_XFER_OPT */

  /* If this is an AUTOINCREMENT table, look up the sequence number in the
  ** sqlite_sequence table and store it in memory cell regAutoinc.
  */
  regAutoinc = autoIncBegin(pParse, iDb, pTab);

  /* Allocate a block registers to hold the rowid and the values
  ** for all columns of the new row.
  */
  regRowid = regIns = pParse->nMem+1;
  pParse->nMem += pTab->nCol + 1;
  
// ABS Label 334
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
if( IsVirtual(pTab) ){
    regRowid++;
    pParse->nMem++;
  }
  regData = regRowid+1;

  /* If the INSERT statement included an IDLIST term, then make sure
  ** all elements of the IDLIST really are columns of the table and 
  ** remember the column indices.
  **
  ** If the table has an INTEGER PRIMARY KEY column and that column
  ** is named in the IDLIST, then record in the ipkColumn variable
  ** the index into IDLIST of the primary key column.  ipkColumn is
  ** the index of the primary key as it appears in IDLIST, not as
  ** is appears in the original table.  (The index of the INTEGER
  ** PRIMARY KEY in the original table is pTab->iPKey.)  After this
  ** loop, if ipkColumn==(-1), that means that integer primary key
  ** is unspecified, and hence the table is either WITHOUT ROWID or
  ** it will automatically generated an integer primary key.
  **
  ** bIdListInOrder is true if the columns in IDLIST are in storage
  ** order.  This enables an optimization that avoids shuffling the
  ** columns into storage order.  False negatives are harmless,
  ** but false positives will cause database corruption.
  */
  bIdListInOrder = (pTab->tabFlags & (TF_OOOHidden|TF_HasStored))==0;
  
// ABS Label 335
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
if( pColumn ){
    i = 0;

// ABS Label 336
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}
// ABS Label 337
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}

// ROR Label 338
if((i <= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}
// ROR Label 339
if((i > pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
// ROR Label 340
if((i >= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 340);
}
for(; i<pColumn->nId; i++){
      pColumn->a[i].idx = -1;
    };
// ABS Label 341
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
// ABS Label 342
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// ROR Label 343
if((i <= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 343);
}
// ROR Label 344
if((i > pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
// ROR Label 345
if((i >= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 345);
}

    i = 0;

// ABS Label 346
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}
// ABS Label 347
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}

// ROR Label 348
if((i <= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 348);
}
// ROR Label 349
if((i > pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 349);
}
// ROR Label 350
if((i >= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 350);
}
for(; i<pColumn->nId; i++){
      j = 0;

// ABS Label 356
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ROR Label 357
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
// ROR Label 358
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}
// ROR Label 359
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}
for(; j<pTab->nCol; j++){
        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName)==0 ){
          pColumn->a[i].idx = j;
          
// ABS Label 364
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
// ABS Label 365
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}

// ROR Label 366
if((i == j) != (i != j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 366);
}
if( i!=j ) { bIdListInOrder = 0;
}
          
// ABS Label 367
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}

// ROR Label 368
if((j != pTab->iPKey) != (j == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}
if( j==pTab->iPKey ){
            ipkColumn = i;  assert( !withoutRowid );
          }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
          
// AOR Label 369
if(pTab->aCol[j].colFlags | (64 | 32) != pTab->aCol[j].colFlags & (64 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 369);
}
// AOR Label 370
if(pTab->aCol[j].colFlags ^ (64 | 32) != pTab->aCol[j].colFlags & (64 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 370);
}
if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){
            
// ABS Label 371
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}

// ABS Label 372
if(pTab->aCol[j].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
sqlite3ErrorMsg(pParse, 
               "cannot INSERT into generated column \"%s\"",
               pTab->aCol[j].zName);
            goto insert_cleanup;
          }
#endif
          break;
        }
      };
// ABS Label 360
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}

// ROR Label 361
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 361);
}
// ROR Label 362
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}
// ROR Label 363
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}

      
// ABS Label 373
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// ROR Label 374
if((j < pTab->nCol) != (j >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 374);
}
// ROR Label 375
if((j > pTab->nCol) != (j >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
// ROR Label 376
if((j <= pTab->nCol) != (j >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
if( j>=pTab->nCol ){
        if( sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid ){
          ipkColumn = i;
          bIdListInOrder = 0;
        }else{
          
// ABS Label 377
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}

// ABS Label 378
if(pColumn->a[i].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 378);
}
sqlite3ErrorMsg(pParse, "table %S has no column named %s",
              pTabList->a, pColumn->a[i].zName);
          pParse->checkSchema = 1;
          goto insert_cleanup;
        }
      }
    };
// ABS Label 351
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
// ABS Label 352
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}

// ROR Label 353
if((i <= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 353);
}
// ROR Label 354
if((i > pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}
// ROR Label 355
if((i >= pColumn->nId) != (i < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}

  }

  /* Figure out how many columns of data are supplied.  If the data
  ** is coming from a SELECT statement, then generate a co-routine that
  ** produces a single row of the SELECT on each invocation.  The
  ** co-routine is the common header to the 3rd and 4th templates.
  */
  
// ABS Label 379
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}
if( pSelect ){
    /* Data is coming from a SELECT or from a multi-row VALUES clause.
    ** Generate a co-routine to run the SELECT. */
    int regYield;       /* Register holding co-routine entry-point */
    int addrTop;        /* Top of the co-routine */
    int rc;             /* Result code */

    regYield = ++pParse->nMem;
    addrTop = sqlite3VdbeCurrentAddr(v) + 1;
    
// ABS Label 380
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}

// ABS Label 381
if(regYield < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 381);
}

// ABS Label 382
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}
sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
    
// ABS Label 383
if(regYield < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}
sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);
    dest.iSdst = bIdListInOrder ? regData : 0;
    dest.nSdst = pTab->nCol;
    rc = sqlite3Select(pParse, pSelect, &dest);
    regFromSelect = dest.iSdst;
    
// ABS Label 391
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}
// ABS Label 392
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

// COR Label 393
if((rc || db->mallocFailed && pParse->nErr) != (rc || db->mallocFailed || pParse->nErr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 393);
}
// COR Label 394
if((rc && db->mallocFailed) != (rc || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 394);
}

// MCC Label 395
if(rc && db->mallocFailed && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(rc && db->mallocFailed && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
// MCC Label 397
if(rc && !(db->mallocFailed) && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 397);
}
// MCC Label 398
if(rc && !(db->mallocFailed) && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 398);
}
// MCC Label 399
if(!(rc) && db->mallocFailed && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 399);
}
// MCC Label 400
if(!(rc) && db->mallocFailed && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 400);
}
// MCC Label 401
if(!(rc) && !(db->mallocFailed) && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 401);
}
// MCC Label 402
if(!(rc) && !(db->mallocFailed) && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 402);
}
if( rc || db->mallocFailed || pParse->nErr ) { goto insert_cleanup;
}
    
// ABS Label 384
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}

// ABS Label 385
if(regYield < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
sqlite3VdbeEndCoroutine(v, regYield);
    
// ABS Label 386
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}

// ABS Label 387
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// AOR Label 388
if(addrTop / 1 != addrTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 388);
}
// AOR Label 389
if(addrTop + 1 != addrTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 389);
}
// AOR Label 390
if(addrTop * 1 != addrTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 390);
}
sqlite3VdbeJumpHere(v, addrTop - 1);                       /* label B: */
    assert( pSelect->pEList );
    nColumn = pSelect->pEList->nExpr;

    /* Set useTempTable to TRUE if the result of the SELECT statement
    ** should be written into a temporary table (template 4).  Set to
    ** FALSE if each output row of the SELECT can be written directly into
    ** the destination table (template 3).
    **
    ** A temp table must be used if the table being updated is also one
    ** of the tables being read by the SELECT statement.  Also use a 
    ** temp table in the case of row triggers.
    */
    if( pTrigger || readsTable(pParse, iDb, pTab) ){
      useTempTable = 1;
    }

    
// ABS Label 403
if(useTempTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}
if( useTempTable ){
      /* Invoke the coroutine to extract information from the SELECT
      ** and add it to a transient table srcTab.  The code generated
      ** here is from the 4th template:
      **
      **      B: open temp table
      **      L: yield X, goto M at EOF
      **         insert row from R..R+n into temp table
      **         goto L
      **      M: ...
      */
      int regRec;          /* Register to hold packed record */
      int regTempRowid;    /* Register to hold temp table ROWID */
      int addrL;           /* Label "L" */

      srcTab = pParse->nTab++;
      regRec = sqlite3GetTempReg(pParse);
      regTempRowid = sqlite3GetTempReg(pParse);
      
// ABS Label 404
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}

// ABS Label 405
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}

// ABS Label 406
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, srcTab, nColumn);
      addrL = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm); VdbeCoverage(v);
      
// ABS Label 407
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// ABS Label 408
if(regFromSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}

// ABS Label 409
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}

// ABS Label 410
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regFromSelect, nColumn, regRec);
      
// ABS Label 411
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}

// ABS Label 412
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}

// ABS Label 413
if(regTempRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
sqlite3VdbeAddOp2(v, OP_NewRowid, srcTab, regTempRowid);
      
// ABS Label 414
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// ABS Label 415
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}

// ABS Label 416
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}

// ABS Label 417
if(regTempRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
sqlite3VdbeAddOp3(v, OP_Insert, srcTab, regRec, regTempRowid);
      
// ABS Label 418
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}

// ABS Label 419
if(addrL < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}
sqlite3VdbeGoto(v, addrL);
      
// ABS Label 420
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 420);
}

// ABS Label 421
if(addrL < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}
sqlite3VdbeJumpHere(v, addrL);
      
// ABS Label 422
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}

// ABS Label 423
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}
sqlite3ReleaseTempReg(pParse, regRec);
      
// ABS Label 424
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}

// ABS Label 425
if(regTempRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}
sqlite3ReleaseTempReg(pParse, regTempRowid);
    }
  }else{
    /* This is the case if the data for the INSERT is coming from a 
    ** single-row VALUES clause
    */
    NameContext sNC;
    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    srcTab = -1;
    assert( useTempTable==0 );
    
// ABS Label 426
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}
if( pList ){
      nColumn = pList->nExpr;
      if( sqlite3ResolveExprListNames(&sNC, pList) ){
        goto insert_cleanup;
      }
    }else{
      nColumn = 0;
    }
  }

  /* If there is no IDLIST term but the table has an integer primary
  ** key, the set the ipkColumn variable to the integer primary key 
  ** column index in the original table definition.
  */
  
// ABS Label 427
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}
// ABS Label 428
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// COR Label 429
if((pColumn == 0 || nColumn > 0) != (pColumn == 0 && nColumn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 429);
}

// ROR Label 430
if((pColumn != 0) != (pColumn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}
// ROR Label 431
if((nColumn <= 0) != (nColumn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 431);
}
// ROR Label 432
if((nColumn < 0) != (nColumn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 432);
}
// ROR Label 433
if((nColumn >= 0) != (nColumn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 433);
}

// MCC Label 434
if(pColumn == 0 && nColumn > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 434);
}
// MCC Label 435
if(pColumn == 0 && !(nColumn > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 435);
}
// MCC Label 436
if(!(pColumn == 0) && nColumn > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 436);
}
// MCC Label 437
if(!(pColumn == 0) && !(nColumn > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 437);
}
if( pColumn==0 && nColumn>0 ){
    ipkColumn = pTab->iPKey;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
    
// ABS Label 438
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}

// COR Label 439
if((ipkColumn >= 0 || (pTab->tabFlags & 96) != 0) != (ipkColumn >= 0 && (pTab->tabFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 439);
}

// ROR Label 440
if((ipkColumn < 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 440);
}
// ROR Label 441
if((ipkColumn > 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 441);
}
// ROR Label 442
if((ipkColumn <= 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 442);
}
// ROR Label 443
if(((pTab->tabFlags & 96) == 0) != ((pTab->tabFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 443);
}

// MCC Label 444
if(ipkColumn >= 0 && (pTab->tabFlags & 96) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 444);
}
// MCC Label 445
if(ipkColumn >= 0 && !((pTab->tabFlags & 96) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 445);
}
// MCC Label 446
if(!(ipkColumn >= 0) && (pTab->tabFlags & 96) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 446);
}
// MCC Label 447
if(!(ipkColumn >= 0) && !((pTab->tabFlags & 96) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 447);
}
if( ipkColumn>=0 && (pTab->tabFlags & TF_HasGenerated)!=0 ){
      testcase( pTab->tabFlags & TF_HasVirtual );
      testcase( pTab->tabFlags & TF_HasStored );
      i = ipkColumn - 1;

// ABS Label 448
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 448);
}

// ROR Label 449
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 449);
}
// ROR Label 450
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 450);
}
// ROR Label 451
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
for(; i>=0; i--){
        
// AOR Label 456
if(pTab->aCol[i].colFlags | 96 != pTab->aCol[i].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 456);
}
// AOR Label 457
if(pTab->aCol[i].colFlags ^ 96 != pTab->aCol[i].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 457);
}
if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){
          testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );
          testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );
          ipkColumn--;
        }
      };
// ABS Label 452
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}

// ROR Label 453
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}
// ROR Label 454
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 454);
}
// ROR Label 455
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}

    }
#endif

    /* Make sure the number of columns in the source data matches the number
    ** of columns to be inserted into the table.
    */
    assert( TF_HasHidden==COLFLAG_HIDDEN );
    assert( TF_HasGenerated==COLFLAG_GENERATED );
    assert( COLFLAG_NOINSERT==(COLFLAG_GENERATED|COLFLAG_HIDDEN) );
    
// ROR Label 458
if(((pTab->tabFlags & (96 | 2)) == 0) != ((pTab->tabFlags & (96 | 2)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 458);
}
if( (pTab->tabFlags & (TF_HasGenerated|TF_HasHidden))!=0 ){
      i = 0;

// ABS Label 459
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// ROR Label 460
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}
// ROR Label 461
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}
// ROR Label 462
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
for(; i<pTab->nCol; i++){
        
// AOR Label 467
if(pTab->aCol[i].colFlags | 98 != pTab->aCol[i].colFlags & 98)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 467);
}
// AOR Label 468
if(pTab->aCol[i].colFlags ^ 98 != pTab->aCol[i].colFlags & 98)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 468);
}
if( pTab->aCol[i].colFlags & COLFLAG_NOINSERT ) { nHidden++;
}
      };
// ABS Label 463
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}

// ROR Label 464
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 464);
}
// ROR Label 465
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
// ROR Label 466
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 466);
}

    }
    
// ABS Label 469
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 469);
}

// ROR Label 470
if((nColumn == (pTab->nCol - nHidden)) != (nColumn != (pTab->nCol - nHidden)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 470);
}
if( nColumn!=(pTab->nCol-nHidden) ){
      
// ABS Label 471
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}

// ABS Label 472
if(nHidden < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}

// AOR Label 473
if(pTab->nCol / nHidden != pTab->nCol - nHidden)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 473);
}
// AOR Label 474
if(pTab->nCol + nHidden != pTab->nCol - nHidden)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 474);
}
// AOR Label 475
if(pTab->nCol * nHidden != pTab->nCol - nHidden)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 475);
}

// ABS Label 476
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}
sqlite3ErrorMsg(pParse, 
         "table %S has %d columns but %d values were supplied",
         pTabList->a, pTab->nCol-nHidden, nColumn);
     goto insert_cleanup;
    }
  }
  
// ABS Label 477
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}
// ABS Label 478
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}
// ABS Label 479
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// COR Label 480
if((pColumn != 0 || nColumn != pColumn->nId) != (pColumn != 0 && nColumn != pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 480);
}

// ROR Label 481
if((pColumn == 0) != (pColumn != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 481);
}
// ROR Label 482
if((nColumn == pColumn->nId) != (nColumn != pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 482);
}

// MCC Label 483
if(pColumn != 0 && nColumn != pColumn->nId ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 483);
}
// MCC Label 484
if(pColumn != 0 && !(nColumn != pColumn->nId) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 484);
}
// MCC Label 485
if(!(pColumn != 0) && nColumn != pColumn->nId ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 485);
}
// MCC Label 486
if(!(pColumn != 0) && !(nColumn != pColumn->nId) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 486);
}
if( pColumn!=0 && nColumn!=pColumn->nId ){
    
// ABS Label 487
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}

// ABS Label 488
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}

// ABS Label 489
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}
sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
    goto insert_cleanup;
  }
    
  /* Initialize the count of rows to be inserted
  */
  
// COR Label 490
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab || !pParse->bReturning) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 490);
}
// COR Label 491
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested || !pParse->pTriggerTab) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 491);
}
// COR Label 492
if(((db->flags & ((u64)(1) << 32)) != 0 || !pParse->nested) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 492);
}

// ROR Label 493
if(((db->flags & ((u64)(1) << 32)) == 0) != ((db->flags & ((u64)(1) << 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}

// MCC Label 494
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
// MCC Label 495
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 495);
}
// MCC Label 496
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 496);
}
// MCC Label 497
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
// MCC Label 498
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 498);
}
// MCC Label 499
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
// MCC Label 500
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
// MCC Label 504
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
// MCC Label 505
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}
if( (db->flags & SQLITE_CountRows)!=0
   && !pParse->nested
   && !pParse->pTriggerTab
   && !pParse->bReturning
  ){
    regRowCount = ++pParse->nMem;
    
// ABS Label 510
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}

// ABS Label 511
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);
  }

  /* If this is not a view, open the table and and all indices */
  if( !isView ){
    int nIdx;
    nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,
                                      &iDataCur, &iIdxCur);
    aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));
    
// ABS Label 512
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}

// ROR Label 513
if((aRegIdx != 0) != (aRegIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}
if( aRegIdx==0 ){
      goto insert_cleanup;
    }
    i = 0 , pIdx = pTab->pIndex;

// ABS Label 514
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}
// ABS Label 515
if(nIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}

// ROR Label 516
if((i <= nIdx) != (i < nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 516);
}
// ROR Label 517
if((i > nIdx) != (i < nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 517);
}
// ROR Label 518
if((i >= nIdx) != (i < nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 518);
}
for(; i<nIdx; pIdx=pIdx->pNext, i++){
      assert( pIdx );
      aRegIdx[i] = ++pParse->nMem;
      pParse->nMem += pIdx->nColumn;
    };
// ABS Label 519
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}
// ABS Label 520
if(nIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 520);
}

// ROR Label 521
if((i <= nIdx) != (i < nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 521);
}
// ROR Label 522
if((i > nIdx) != (i < nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 522);
}
// ROR Label 523
if((i >= nIdx) != (i < nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 523);
}

    aRegIdx[i] = ++pParse->nMem;  /* Register to store the table record */
  }
#ifndef SQLITE_OMIT_UPSERT
  
// ABS Label 524
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}
if( pUpsert ){
    Upsert *pNx;
    
// ABS Label 525
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}
if( IsVirtual(pTab) ){
      
// ABS Label 526
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// ABS Label 527
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}
sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"",
              pTab->zName);
      goto insert_cleanup;
    }
    
// ABS Label 528
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}
if( pTab->pSelect ){
      
// ABS Label 529
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}
sqlite3ErrorMsg(pParse, "cannot UPSERT a view");
      goto insert_cleanup;
    }
    if( sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget) ){
      goto insert_cleanup;
    }
    pTabList->a[0].iCursor = iDataCur;
    pNx = pUpsert;
    
// ABS Label 530
if(pNx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}

// ROR Label 531
if((pNx == 0) != (pNx != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 531);
}
do{
      pNx->pUpsertSrc = pTabList;
      pNx->regData = regData;
      pNx->iDataCur = iDataCur;
      pNx->iIdxCur = iIdxCur;
      
// ABS Label 534
if(pNx->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}
if( pNx->pUpsertTarget ){
        if( sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx) ){
          goto insert_cleanup;
        }
      }
      pNx = pNx->pNextUpsert;
    }while( pNx!=0 );
// ABS Label 532
if(pNx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 532);
}

// ROR Label 533
if((pNx == 0) != (pNx != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 533);
}
;
  }
#endif


  /* This is the top of the main insertion loop */
  
// ABS Label 535
if(useTempTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}
if( useTempTable ){
    /* This block codes the top of loop only.  The complete loop is the
    ** following pseudocode (template 4):
    **
    **         rewind temp table, if empty goto D
    **      C: loop over rows of intermediate table
    **           transfer values form intermediate table into <table>
    **         end loop
    **      D: ...
    */
    addrInsTop = sqlite3VdbeAddOp1(v, OP_Rewind, srcTab); VdbeCoverage(v);
    addrCont = sqlite3VdbeCurrentAddr(v);
  }else { 
// ABS Label 536
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}
if( pSelect ){
    /* This block codes the top of loop only.  The complete loop is the
    ** following pseudocode (template 3):
    **
    **      C: yield X, at EOF goto D
    **         insert the select result into <table> from R..R+n
    **         goto C
    **      D: ...
    */
    sqlite3VdbeReleaseRegisters(pParse, regData, pTab->nCol, 0, 0);
    addrInsTop = addrCont = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);
    VdbeCoverage(v);
    
// ABS Label 537
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}

// ROR Label 538
if((ipkColumn < 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 538);
}
// ROR Label 539
if((ipkColumn > 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 539);
}
// ROR Label 540
if((ipkColumn <= 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 540);
}
if( ipkColumn>=0 ){
      /* tag-20191021-001: If the INTEGER PRIMARY KEY is being generated by the
      ** SELECT, go ahead and copy the value into the rowid slot now, so that
      ** the value does not get overwritten by a NULL at tag-20191021-002. */
      
// ABS Label 541
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}

// ABS Label 542
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
// ABS Label 543
if(regFromSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}

// AOR Label 544
if(regFromSelect - ipkColumn != regFromSelect + ipkColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 544);
}
// AOR Label 545
if(regFromSelect / ipkColumn != regFromSelect + ipkColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 545);
}
// AOR Label 546
if(regFromSelect * ipkColumn != regFromSelect + ipkColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 546);
}

// ABS Label 547
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}
sqlite3VdbeAddOp2(v, OP_Copy, regFromSelect+ipkColumn, regRowid);
    }
  };}


  /* Compute data for ordinary columns of the new entry.  Values
  ** are written in storage order into registers starting with regData.
  ** Only ordinary columns are computed in this loop. The rowid
  ** (if there is one) is computed later and generated columns are
  ** computed after the rowid since they might depend on the value
  ** of the rowid.
  */
  nHidden = 0;
  iRegStore = regData;  assert( regData==regRowid+1 );
  i = 0;

// ABS Label 548
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}

// ROR Label 549
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 549);
}
// ROR Label 550
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 550);
}
// ROR Label 551
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 551);
}
for(; i<pTab->nCol; i++, iRegStore++){
    int k;
    u32 colFlags;
    assert( i>=nHidden );
    
// ABS Label 556
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}

// ROR Label 557
if((i != pTab->iPKey) != (i == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 557);
}
if( i==pTab->iPKey ){
      /* tag-20191021-002: References to the INTEGER PRIMARY KEY are filled
      ** using the rowid. So put a NULL in the IPK slot of the record to avoid
      ** using excess space.  The file format definition requires this extra
      ** NULL - we cannot optimize further by skipping the column completely */
      
// ABS Label 558
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// ABS Label 559
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 559);
}
sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);
      continue;
    }
    if( ((colFlags = pTab->aCol[i].colFlags) & COLFLAG_NOINSERT)!=0 ){
      nHidden++;
      
// ROR Label 560
if(((colFlags & 32) == 0) != ((colFlags & 32) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 560);
}
if( (colFlags & COLFLAG_VIRTUAL)!=0 ){
        /* Virtual columns do not participate in OP_MakeRecord.  So back up
        ** iRegStore by one slot to compensate for the iRegStore++ in the
        ** outer for() loop */
        iRegStore--;
        continue;
      }else { 
// ROR Label 561
if(((colFlags & 64) == 0) != ((colFlags & 64) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 561);
}
if( (colFlags & COLFLAG_STORED)!=0 ){
        /* Stored columns are computed later.  But if there are BEFORE
        ** triggers, the slots used for stored columns will be OP_Copy-ed
        ** to a second block of registers, so the register needs to be
        ** initialized to NULL to avoid an uninitialized register read */
        
// ABS Label 562
if(tmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}

// AOR Label 563
if(tmask | 1 != tmask & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 563);
}
// AOR Label 564
if(tmask ^ 1 != tmask & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 564);
}
if( tmask & TRIGGER_BEFORE ){
          
// ABS Label 565
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 565);
}

// ABS Label 566
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 566);
}
sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);
        }
        continue;
      }else { 
// ABS Label 567
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}

// ROR Label 568
if((pColumn != 0) != (pColumn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 568);
}
if( pColumn==0 ){
        /* Hidden columns that are not explicitly named in the INSERT
        ** get there default value */
        
// ABS Label 569
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 569);
}

// ABS Label 570
if(pTab->aCol[i].pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 570);
}

// ABS Label 571
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 571);
}
sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);
        continue;
      };}
;}

    }
    
// ABS Label 572
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 572);
}
if( pColumn ){
      j = 0;

// ABS Label 573
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}
// ABS Label 574
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}
// ABS Label 575
if(pColumn->a[j].idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 575);
}
// ABS Label 576
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 576);
}

// COR Label 577
if((j < pColumn->nId || pColumn->a[j].idx != i) != (j < pColumn->nId && pColumn->a[j].idx != i))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 577);
}

// ROR Label 578
if((j <= pColumn->nId) != (j < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 578);
}
// ROR Label 579
if((j > pColumn->nId) != (j < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 579);
}
// ROR Label 580
if((j >= pColumn->nId) != (j < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 580);
}
// ROR Label 581
if((pColumn->a[j].idx == i) != (pColumn->a[j].idx != i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 581);
}

// MCC Label 582
if(j < pColumn->nId && pColumn->a[j].idx != i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(j < pColumn->nId && !(pColumn->a[j].idx != i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(!(j < pColumn->nId) && pColumn->a[j].idx != i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(!(j < pColumn->nId) && !(pColumn->a[j].idx != i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
for(; j<pColumn->nId && pColumn->a[j].idx!=i; j++){};
// ABS Label 586
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 586);
}
// ABS Label 587
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 587);
}
// ABS Label 588
if(pColumn->a[j].idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 588);
}
// ABS Label 589
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}

// COR Label 590
if((j < pColumn->nId || pColumn->a[j].idx != i) != (j < pColumn->nId && pColumn->a[j].idx != i))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 590);
}

// ROR Label 591
if((j <= pColumn->nId) != (j < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 591);
}
// ROR Label 592
if((j > pColumn->nId) != (j < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}
// ROR Label 593
if((j >= pColumn->nId) != (j < pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((pColumn->a[j].idx == i) != (pColumn->a[j].idx != i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}

// MCC Label 595
if(j < pColumn->nId && pColumn->a[j].idx != i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(j < pColumn->nId && !(pColumn->a[j].idx != i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
// MCC Label 597
if(!(j < pColumn->nId) && pColumn->a[j].idx != i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(!(j < pColumn->nId) && !(pColumn->a[j].idx != i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}

      
// ABS Label 599
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}
// ABS Label 600
if(pColumn->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 600);
}

// ROR Label 601
if((j < pColumn->nId) != (j >= pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 601);
}
// ROR Label 602
if((j > pColumn->nId) != (j >= pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 602);
}
// ROR Label 603
if((j <= pColumn->nId) != (j >= pColumn->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 603);
}
if( j>=pColumn->nId ){
        /* A column not named in the insert column list gets its
        ** default value */
        
// ABS Label 604
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}

// ABS Label 605
if(pTab->aCol[i].pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}

// ABS Label 606
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}
sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);
        continue;
      }
      k = j;
    }else { 
// ABS Label 607
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}

// ROR Label 608
if((nColumn != 0) != (nColumn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 608);
}
if( nColumn==0 ){
      /* This is INSERT INTO ... DEFAULT VALUES.  Load the default value. */
      
// ABS Label 609
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}

// ABS Label 610
if(pTab->aCol[i].pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}

// ABS Label 611
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}
sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);
      continue;
    }else{
      k = i - nHidden;
    };}


    
// ABS Label 612
if(useTempTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}
if( useTempTable ){
      
// ABS Label 613
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}

// ABS Label 614
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 614);
}

// ABS Label 615
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 615);
}

// ABS Label 616
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 616);
}
sqlite3VdbeAddOp3(v, OP_Column, srcTab, k, iRegStore); 
    }else { 
// ABS Label 617
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}
if( pSelect ){
      
// ABS Label 618
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}
// ABS Label 619
if(regFromSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// ROR Label 620
if((regFromSelect == regData) != (regFromSelect != regData))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
if( regFromSelect!=regData ){
        
// ABS Label 621
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 621);
}

// ABS Label 622
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 622);
}
// ABS Label 623
if(regFromSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}

// AOR Label 624
if(regFromSelect - k != regFromSelect + k)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 624);
}
// AOR Label 625
if(regFromSelect / k != regFromSelect + k)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 625);
}
// AOR Label 626
if(regFromSelect * k != regFromSelect + k)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 626);
}

// ABS Label 627
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 627);
}
sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+k, iRegStore);
      }
    }else{
      
// ABS Label 628
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}

// ABS Label 629
if(pList->a[k].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}

// ABS Label 630
if(iRegStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}
sqlite3ExprCode(pParse, pList->a[k].pExpr, iRegStore);
    };}

  };
// ABS Label 552
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}

// ROR Label 553
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 553);
}
// ROR Label 554
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 554);
}
// ROR Label 555
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}



  /* Run the BEFORE and INSTEAD OF triggers, if there are any
  */
  endOfLoop = sqlite3VdbeMakeLabel(pParse);
  
// ABS Label 631
if(tmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 631);
}

// AOR Label 632
if(tmask | 1 != tmask & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 632);
}
// AOR Label 633
if(tmask ^ 1 != tmask & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 633);
}
if( tmask & TRIGGER_BEFORE ){
    int regCols = sqlite3GetTempRange(pParse, pTab->nCol+1);

    /* build the NEW.* reference row.  Note that if there is an INTEGER
    ** PRIMARY KEY into which a NULL is being inserted, that NULL will be
    ** translated into a unique ID for the row.  But on a BEFORE trigger,
    ** we do not know what the unique ID will be (because the insert has
    ** not happened yet) so we substitute a rowid of -1
    */
    
// ABS Label 663
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}

// ROR Label 664
if((ipkColumn <= 0) != (ipkColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 664);
}
// ROR Label 665
if((ipkColumn > 0) != (ipkColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 665);
}
// ROR Label 666
if((ipkColumn >= 0) != (ipkColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 666);
}
if( ipkColumn<0 ){
      
// ABS Label 667
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}

// ABS Label 668
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}
sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
    }else{
      int addr1;
      assert( !withoutRowid );
      
// ABS Label 675
if(useTempTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}
if( useTempTable ){
        
// ABS Label 676
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}

// ABS Label 677
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}

// ABS Label 678
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}

// ABS Label 679
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}
sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regCols);
      }else{
        assert( pSelect==0 );  /* Otherwise useTempTable is true */
        
// ABS Label 680
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}

// ABS Label 681
if(pList->a[ipkColumn].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}

// ABS Label 682
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 682);
}
sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);
      }
      addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regCols); VdbeCoverage(v);
      
// ABS Label 669
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}

// ABS Label 670
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}
sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);
      
// ABS Label 671
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ABS Label 672
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}
sqlite3VdbeJumpHere(v, addr1);
      
// ABS Label 673
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}

// ABS Label 674
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}
sqlite3VdbeAddOp1(v, OP_MustBeInt, regCols); VdbeCoverage(v);
    }

    /* Copy the new data already generated. */
    assert( pTab->nNVCol>0 );
    
// ABS Label 634
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}

// ABS Label 635
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}

// AOR Label 636
if(regRowid - 1 != regRowid + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 636);
}
// AOR Label 637
if(regRowid / 1 != regRowid + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 637);
}
// AOR Label 638
if(regRowid * 1 != regRowid + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 638);
}

// ABS Label 639
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// AOR Label 640
if(regCols - 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 640);
}
// AOR Label 641
if(regCols / 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 641);
}
// AOR Label 642
if(regCols * 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 642);
}

// AOR Label 643
if(pTab->nNVCol / 1 != pTab->nNVCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 643);
}
// AOR Label 644
if(pTab->nNVCol + 1 != pTab->nNVCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 644);
}
// AOR Label 645
if(pTab->nNVCol * 1 != pTab->nNVCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 645);
}
sqlite3VdbeAddOp3(v, OP_Copy, regRowid+1, regCols+1, pTab->nNVCol-1);

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
    /* Compute the new value for generated columns after all other
    ** columns have already been computed.  This must be done after
    ** computing the ROWID in case one of the generated columns
    ** refers to the ROWID. */
    
// ABS Label 683
if(pTab->tabFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}

// AOR Label 684
if(pTab->tabFlags | 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 684);
}
// AOR Label 685
if(pTab->tabFlags ^ 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 685);
}
if( pTab->tabFlags & TF_HasGenerated ){
      testcase( pTab->tabFlags & TF_HasVirtual );
      testcase( pTab->tabFlags & TF_HasStored );
      
// ABS Label 686
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}

// ABS Label 687
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}

// AOR Label 688
if(regCols - 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 688);
}
// AOR Label 689
if(regCols / 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 689);
}
// AOR Label 690
if(regCols * 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 690);
}

// ABS Label 691
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}
sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);
    }
#endif

    /* If this is an INSERT on a view with an INSTEAD OF INSERT trigger,
    ** do not attempt any conversions before assembling the record.
    ** If this is a real table, attempt conversions as required by the
    ** table column affinities.
    */
    if( !isView ){
      
// ABS Label 692
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}

// ABS Label 693
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 693);
}

// ABS Label 694
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}

// AOR Label 695
if(regCols - 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 695);
}
// AOR Label 696
if(regCols / 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 696);
}
// AOR Label 697
if(regCols * 1 != regCols + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 697);
}
sqlite3TableAffinity(v, pTab, regCols+1);
    }

    /* Fire BEFORE or INSTEAD OF triggers */
    
// ABS Label 646
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}

// ABS Label 647
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}

// ABS Label 648
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}

// ABS Label 649
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}

// AOR Label 650
if(regCols - pTab->nCol / 1 != regCols - pTab->nCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 650);
}
// AOR Label 651
if(regCols - pTab->nCol + 1 != regCols - pTab->nCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 651);
}
// AOR Label 652
if(regCols - pTab->nCol * 1 != regCols - pTab->nCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 652);
}
// AOR Label 653
if(regCols / pTab->nCol != regCols - pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 653);
}
// AOR Label 654
if(regCols + pTab->nCol != regCols - pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 654);
}
// AOR Label 655
if(regCols * pTab->nCol != regCols - pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 655);
}

// ABS Label 656
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}

// ABS Label 657
if(endOfLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}
sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_BEFORE, 
        pTab, regCols-pTab->nCol-1, onError, endOfLoop);

    
// ABS Label 658
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}

// ABS Label 659
if(regCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}

// AOR Label 660
if(pTab->nCol - 1 != pTab->nCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 660);
}
// AOR Label 661
if(pTab->nCol / 1 != pTab->nCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 661);
}
// AOR Label 662
if(pTab->nCol * 1 != pTab->nCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 662);
}
sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);
  }

  if( !isView ){
    
// ABS Label 701
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}
if( IsVirtual(pTab) ){
      /* The row that the VUpdate opcode will delete: none */
      
// ABS Label 702
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}

// ABS Label 703
if(regIns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 703);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regIns);
    }
    
// ABS Label 704
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 704);
}

// ROR Label 705
if((ipkColumn < 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 705);
}
// ROR Label 706
if((ipkColumn > 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 706);
}
// ROR Label 707
if((ipkColumn <= 0) != (ipkColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 707);
}
if( ipkColumn>=0 ){
      /* Compute the new rowid */
      
// ABS Label 708
if(useTempTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 708);
}
if( useTempTable ){
        
// ABS Label 709
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}

// ABS Label 710
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}

// ABS Label 711
if(ipkColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 711);
}

// ABS Label 712
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}
sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regRowid);
      }else { 
// ABS Label 713
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 713);
}
if( pSelect ){
        /* Rowid already initialized at tag-20191021-001 */
      }else{
        
// ABS Label 714
if(pList->a[ipkColumn].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}
Expr *pIpk = pList->a[ipkColumn].pExpr;
        
// COR Label 715
if((pIpk->op == 120 || !((pTab)->nModuleArg)) != (pIpk->op == 120 && !((pTab)->nModuleArg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 715);
}

// ROR Label 716
if((pIpk->op != 120) != (pIpk->op == 120))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 716);
}

// MCC Label 717
if(pIpk->op == 120 && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 717);
}
// MCC Label 718
if(pIpk->op == 120 && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 718);
}
// MCC Label 719
if(!(pIpk->op == 120) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 719);
}
// MCC Label 720
if(!(pIpk->op == 120) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 720);
}
if( pIpk->op==TK_NULL && !IsVirtual(pTab) ){
          
// ABS Label 721
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}

// ABS Label 722
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 722);
}

// ABS Label 723
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 723);
}

// ABS Label 724
if(regAutoinc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 724);
}
sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
          appendFlag = 1;
        }else{
          
// ABS Label 725
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 725);
}

// ABS Label 726
if(pList->a[ipkColumn].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}

// ABS Label 727
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}
sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);
        }
      };}

      /* If the PRIMARY KEY expression is NULL, then use OP_NewRowid
      ** to generate a unique primary key value.
      */
      if( !appendFlag ){
        int addr1;
        if( !IsVirtual(pTab) ){
          addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); VdbeCoverage(v);
          
// ABS Label 730
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}

// ABS Label 731
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

// ABS Label 732
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}

// ABS Label 733
if(regAutoinc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 733);
}
sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
          
// ABS Label 734
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 734);
}

// ABS Label 735
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 735);
}
sqlite3VdbeJumpHere(v, addr1);
        }else{
          addr1 = sqlite3VdbeCurrentAddr(v);
          
// ABS Label 736
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// ABS Label 737
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 737);
}

// ABS Label 738
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 738);
}

// AOR Label 739
if(addr1 - 2 != addr1 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 739);
}
// AOR Label 740
if(addr1 / 2 != addr1 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 740);
}
// AOR Label 741
if(addr1 * 2 != addr1 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 741);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, addr1+2); VdbeCoverage(v);
        }
        
// ABS Label 728
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}

// ABS Label 729
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}
sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); VdbeCoverage(v);
      }
    }else { 
// ABS Label 742
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}

// COR Label 743
if((((pTab)->nModuleArg) && withoutRowid) != (((pTab)->nModuleArg) || withoutRowid))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 743);
}

// MCC Label 744
if(((pTab)->nModuleArg) && withoutRowid ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 744);
}
// MCC Label 745
if(((pTab)->nModuleArg) && !(withoutRowid) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 745);
}
// MCC Label 746
if(!(((pTab)->nModuleArg)) && withoutRowid ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 746);
}
// MCC Label 747
if(!(((pTab)->nModuleArg)) && !(withoutRowid) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 747);
}
if( IsVirtual(pTab) || withoutRowid ){
      
// ABS Label 748
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// ABS Label 749
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regRowid);
    }else{
      
// ABS Label 750
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 750);
}

// ABS Label 751
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 751);
}

// ABS Label 752
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 752);
}

// ABS Label 753
if(regAutoinc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 753);
}
sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);
      appendFlag = 1;
    };}

    
// ABS Label 698
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 698);
}

// ABS Label 699
if(regAutoinc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 699);
}

// ABS Label 700
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}
autoIncStep(pParse, regAutoinc, regRowid);

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
    /* Compute the new value for generated columns after all other
    ** columns have already been computed.  This must be done after
    ** computing the ROWID in case one of the generated columns
    ** is derived from the INTEGER PRIMARY KEY. */
    
// ABS Label 754
if(pTab->tabFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 754);
}

// AOR Label 755
if(pTab->tabFlags | 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 755);
}
// AOR Label 756
if(pTab->tabFlags ^ 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 756);
}
if( pTab->tabFlags & TF_HasGenerated ){
      
// ABS Label 757
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}

// ABS Label 758
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}

// AOR Label 759
if(regRowid - 1 != regRowid + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 759);
}
// AOR Label 760
if(regRowid / 1 != regRowid + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 760);
}
// AOR Label 761
if(regRowid * 1 != regRowid + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 761);
}

// ABS Label 762
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}
sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);
    }
#endif

    /* Generate code to check constraints and generate index keys and
    ** do the insertion.
    */
#ifndef SQLITE_OMIT_VIRTUALTABLE
    
// ABS Label 763
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 763);
}
if( IsVirtual(pTab) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      
// ABS Label 764
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// ABS Label 765
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}
sqlite3VtabMakeWritable(pParse, pTab);
      
// ABS Label 766
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 766);
}

// AOR Label 767
if(pTab->nCol - 2 != pTab->nCol + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 767);
}
// AOR Label 768
if(pTab->nCol / 2 != pTab->nCol + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 768);
}
// AOR Label 769
if(pTab->nCol * 2 != pTab->nCol + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 769);
}

// ABS Label 770
if(regIns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 770);
}

// ABS Label 771
if(pVTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 771);
}
sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol+2, regIns, pVTab, P4_VTAB);
      
// ABS Label 772
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 772);
}
sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);
      
// ABS Label 773
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}
sqlite3MayAbort(pParse);
    }else
#endif
    {
      int isReplace = 0;/* Set to true if constraints may cause a replace */
      int bUseSeek;     /* True to use OPFLAG_SEEKRESULT */
      
// ABS Label 774
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}

// ABS Label 775
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// ABS Label 776
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}

// ABS Label 777
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ABS Label 778
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}

// ABS Label 779
if(regIns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 779);
}

// ABS Label 780
if(endOfLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}

// ABS Label 781
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}
sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
          regIns, 0, ipkColumn>=0, onError, endOfLoop, &isReplace, 0, pUpsert
      );
      
// ABS Label 782
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}

// ABS Label 783
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}

// ABS Label 784
if(regIns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}
sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);

      /* Set the OPFLAG_USESEEKRESULT flag if either (a) there are no REPLACE
      ** constraints or (b) there are no triggers and this table is not a
      ** parent table in a foreign key constraint. It is safe to set the
      ** flag in the second case as if any REPLACE constraint is hit, an
      ** OP_Delete or OP_IdxDelete instruction will be executed on each 
      ** cursor that is disturbed. And these instructions both clear the
      ** VdbeCursor.seekResult variable, disabling the OPFLAG_USESEEKRESULT
      ** functionality.  */
      bUseSeek = (isReplace==0 || !sqlite3VdbeHasSubProgram(v));
      
// ABS Label 785
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// ABS Label 786
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}

// ABS Label 787
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}

// ABS Label 788
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}

// ABS Label 789
if(regIns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}

// ABS Label 790
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}

// ABS Label 791
if(bUseSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}
sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,
          regIns, aRegIdx, 0, appendFlag, bUseSeek
      );
    }
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
  }else if( pParse->bReturning ){
    /* If there is a RETURNING clause, populate the rowid register with
    ** constant value -1, in case one or more of the returned expressions
    ** refer to the "rowid" of the view.  */
    sqlite3VdbeAddOp2(v, OP_Integer, -1, regRowid);
#endif
  }

  /* Update the count of rows that are inserted
  */
  
// ABS Label 792
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}
if( regRowCount ){
    
// ABS Label 793
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}

// ABS Label 794
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}
sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);
  }

  
// ABS Label 795
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}
if( pTrigger ){
    /* Code AFTER triggers */
    
// ABS Label 796
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}

// ABS Label 797
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}

// ABS Label 798
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}

// ABS Label 799
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}

// AOR Label 800
if(regData - 2 / pTab->nCol != regData - 2 - pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 800);
}
// AOR Label 801
if(regData - 2 + pTab->nCol != regData - 2 - pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 801);
}
// AOR Label 802
if(regData - 2 * pTab->nCol != regData - 2 - pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 802);
}
// AOR Label 803
if(regData / 2 != regData - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 803);
}
// AOR Label 804
if(regData + 2 != regData - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 804);
}
// AOR Label 805
if(regData * 2 != regData - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 805);
}

// ABS Label 806
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}

// ABS Label 807
if(endOfLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}
sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_AFTER, 
        pTab, regData-2-pTab->nCol, onError, endOfLoop);
  }

  /* The bottom of the main insertion loop, if the data source
  ** is a SELECT statement.
  */
  
// ABS Label 295
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if(endOfLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
sqlite3VdbeResolveLabel(v, endOfLoop);
  
// ABS Label 808
if(useTempTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}
if( useTempTable ){
    
// ABS Label 809
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}

// ABS Label 810
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}

// ABS Label 811
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
sqlite3VdbeAddOp2(v, OP_Next, srcTab, addrCont); VdbeCoverage(v);
    
// ABS Label 812
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}

// ABS Label 813
if(addrInsTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}
sqlite3VdbeJumpHere(v, addrInsTop);
    
// ABS Label 814
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ABS Label 815
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}
sqlite3VdbeAddOp1(v, OP_Close, srcTab);
  }else { 
// ABS Label 816
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}
if( pSelect ){
    
// ABS Label 817
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}

// ABS Label 818
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}
sqlite3VdbeGoto(v, addrCont);
#ifdef SQLITE_DEBUG
    /* If we are jumping back to an OP_Yield that is preceded by an
    ** OP_ReleaseReg, set the p5 flag on the OP_Goto so that the
    ** OP_ReleaseReg will be included in the loop. */
    if( sqlite3VdbeGetOp(v, addrCont-1)->opcode==OP_ReleaseReg ){
      assert( sqlite3VdbeGetOp(v, addrCont)->opcode==OP_Yield );
      sqlite3VdbeChangeP5(v, 1);
    }
#endif
    
// ABS Label 819
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}

// ABS Label 820
if(addrInsTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
sqlite3VdbeJumpHere(v, addrInsTop);
  };}


#ifndef SQLITE_OMIT_XFER_OPT
insert_end:
#endif /* SQLITE_OMIT_XFER_OPT */
  /* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */
  
// ABS Label 821
if(pParse->pTriggerTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}

// COR Label 822
if((pParse->nested == 0 || pParse->pTriggerTab == 0) != (pParse->nested == 0 && pParse->pTriggerTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 822);
}

// ROR Label 823
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 823);
}
// ROR Label 824
if((pParse->pTriggerTab != 0) != (pParse->pTriggerTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 824);
}

// MCC Label 825
if(pParse->nested == 0 && pParse->pTriggerTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 825);
}
// MCC Label 826
if(pParse->nested == 0 && !(pParse->pTriggerTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 826);
}
// MCC Label 827
if(!(pParse->nested == 0) && pParse->pTriggerTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 827);
}
// MCC Label 828
if(!(pParse->nested == 0) && !(pParse->pTriggerTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 828);
}
if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    
// ABS Label 829
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}
sqlite3AutoincrementEnd(pParse);
  }

  /*
  ** Return the number of rows inserted. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */
  
// ABS Label 830
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}
if( regRowCount ){
    
// ABS Label 831
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 831);
}

// ABS Label 832
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 832);
}
sqlite3VdbeAddOp2(v, OP_ChngCntRow, regRowCount, 1);
    
// ABS Label 833
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}
sqlite3VdbeSetNumCols(v, 1);
    
// ABS Label 834
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 834);
}
sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows inserted", SQLITE_STATIC);
  }

insert_cleanup:
  sqlite3SrcListDelete(db, pTabList);
  
// ABS Label 297
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ABS Label 298
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
sqlite3ExprListDelete(db, pList);
  
// ABS Label 299
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}

// ABS Label 300
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
sqlite3UpsertDelete(db, pUpsert);
  
// ABS Label 301
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ABS Label 302
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
sqlite3SelectDelete(db, pSelect);
  
// ABS Label 303
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ABS Label 304
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
sqlite3IdListDelete(db, pColumn);
  
// ABS Label 305
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
sqlite3DbFree(db, aRegIdx);
}

/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */
#ifdef isView
 #undef isView
#endif
#ifdef pTrigger
 #undef pTrigger
#endif
#ifdef tmask
 #undef tmask
#endif

/*
** Meanings of bits in of pWalker->eCode for 
** sqlite3ExprReferencesUpdatedColumn()
*/
#define CKCNSTRNT_COLUMN   0x01    /* CHECK constraint uses a changing column */
#define CKCNSTRNT_ROWID    0x02    /* CHECK constraint references the ROWID */

/* This is the Walker callback from sqlite3ExprReferencesUpdatedColumn().
*  Set bit 0x01 of pWalker->eCode if pWalker->eCode to 0 and if this
** expression node references any of the
** columns that are being modifed by an UPDATE statement.
*/
static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr){
  
// ROR Label 835
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 835);
}
if( pExpr->op==TK_COLUMN ){
    assert( pExpr->iColumn>=0 || pExpr->iColumn==-1 );
    
// ROR Label 836
if((pExpr->iColumn < 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 836);
}
// ROR Label 837
if((pExpr->iColumn > 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 837);
}
// ROR Label 838
if((pExpr->iColumn <= 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 838);
}
if( pExpr->iColumn>=0 ){
      
// ABS Label 839
if(pExpr->iColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}
// ABS Label 840
if(pWalker->u.aiCol[pExpr->iColumn] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 840);
}

// ROR Label 841
if((pWalker->u.aiCol[pExpr->iColumn] < 0) != (pWalker->u.aiCol[pExpr->iColumn] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 841);
}
// ROR Label 842
if((pWalker->u.aiCol[pExpr->iColumn] > 0) != (pWalker->u.aiCol[pExpr->iColumn] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 842);
}
// ROR Label 843
if((pWalker->u.aiCol[pExpr->iColumn] <= 0) != (pWalker->u.aiCol[pExpr->iColumn] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 843);
}
if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){
        pWalker->eCode |= CKCNSTRNT_COLUMN;
      }
    }else{
      pWalker->eCode |= CKCNSTRNT_ROWID;
    }
  }
  return WRC_Continue;
}

/*
** pExpr is a CHECK constraint on a row that is being UPDATE-ed.  The
** only columns that are modified by the UPDATE are those for which
** aiChng[i]>=0, and also the ROWID is modified if chngRowid is true.
**
** Return true if CHECK constraint pExpr uses any of the
** changing columns (or the rowid if it is changing).  In other words,
** return true if this CHECK constraint must be validated for
** the new row in the UPDATE statement.
**
** 2018-09-15: pExpr might also be an expression for an index-on-expressions.
** The operation of this routine is the same - return true if an only if
** the expression uses one or more of columns identified by the second and
** third arguments.
*/
int sqlite3ExprReferencesUpdatedColumn(
  Expr *pExpr,    /* The expression to be checked */
  int *aiChng,    /* aiChng[x]>=0 if column x changed by the UPDATE */
  int chngRowid   /* True if UPDATE changes the rowid */
){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.eCode = 0;
  w.xExprCallback = checkConstraintExprNode;
  w.u.aiCol = aiChng;
  
// ABS Label 844
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 844);
}
sqlite3WalkExpr(&w, pExpr);
  if( !chngRowid ){
    testcase( (w.eCode & CKCNSTRNT_ROWID)!=0 );
    w.eCode &= ~CKCNSTRNT_ROWID;
  }
  testcase( w.eCode==0 );
  testcase( w.eCode==CKCNSTRNT_COLUMN );
  testcase( w.eCode==CKCNSTRNT_ROWID );
  testcase( w.eCode==(CKCNSTRNT_ROWID|CKCNSTRNT_COLUMN) );
  
// ROR Label 845
if((w.eCode == 0) != (w.eCode != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 845);
}
return w.eCode!=0;
}

/*
** The sqlite3GenerateConstraintChecks() routine usually wants to visit
** the indexes of a table in the order provided in the Table->pIndex list.
** However, sometimes (rarely - when there is an upsert) it wants to visit
** the indexes in a different order.  The following data structures accomplish
** this.
**
** The IndexIterator object is used to walk through all of the indexes
** of a table in either Index.pNext order, or in some other order established
** by an array of IndexListTerm objects.
*/
typedef struct IndexListTerm IndexListTerm;
typedef struct IndexIterator IndexIterator;
struct IndexIterator {
  int eType;    /* 0 for Index.pNext list.  1 for an array of IndexListTerm */
  int i;        /* Index of the current item from the list */
  union {
    struct {    /* Use this object for eType==0: A Index.pNext list */
      Index *pIdx;   /* The current Index */
    } lx;      
    struct {    /* Use this object for eType==1; Array of IndexListTerm */
      int nIdx;               /* Size of the array */
      IndexListTerm *aIdx;    /* Array of IndexListTerms */
    } ax;
  } u;
};

/* When IndexIterator.eType==1, then each index is an array of instances
** of the following object
*/
struct IndexListTerm {
  Index *p;  /* The index */
  int ix;    /* Which entry in the original Table.pIndex list is this index*/
};

/* Return the first index on the list */
static Index *indexIteratorFirst(IndexIterator *pIter, int *pIx){
  assert( pIter->i==0 );
  
// ABS Label 846
if(pIter->eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}
if( pIter->eType ){
    *pIx = pIter->u.ax.aIdx[0].ix;
    
// ABS Label 847
if(pIter->u.ax.aIdx[0].p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}
return pIter->u.ax.aIdx[0].p;
  }else{
    *pIx = 0;
    
// ABS Label 848
if(pIter->u.lx.pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}
return pIter->u.lx.pIdx;
  }
}

/* Return the next index from the list.  Return NULL when out of indexes */
static Index *indexIteratorNext(IndexIterator *pIter, int *pIx){
  
// ABS Label 849
if(pIter->eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}
if( pIter->eType ){
    int i = ++pIter->i;
    
// ABS Label 850
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}
// ABS Label 851
if(pIter->u.ax.nIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}

// ROR Label 852
if((i < pIter->u.ax.nIdx) != (i >= pIter->u.ax.nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 852);
}
// ROR Label 853
if((i > pIter->u.ax.nIdx) != (i >= pIter->u.ax.nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
// ROR Label 854
if((i <= pIter->u.ax.nIdx) != (i >= pIter->u.ax.nIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 854);
}
if( i>=pIter->u.ax.nIdx ){
      *pIx = i;
      return 0;
    }
    *pIx = pIter->u.ax.aIdx[i].ix;
    
// ABS Label 855
if(pIter->u.ax.aIdx[i].p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}
return pIter->u.ax.aIdx[i].p;
  }else{
    ++(*pIx);
    pIter->u.lx.pIdx = pIter->u.lx.pIdx->pNext;
    
// ABS Label 856
if(pIter->u.lx.pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}
return pIter->u.lx.pIdx;
  }
}
  
/*
** Generate code to do constraint checks prior to an INSERT or an UPDATE
** on table pTab.
**
** The regNewData parameter is the first register in a range that contains
** the data to be inserted or the data after the update.  There will be
** pTab->nCol+1 registers in this range.  The first register (the one
** that regNewData points to) will contain the new rowid, or NULL in the
** case of a WITHOUT ROWID table.  The second register in the range will
** contain the content of the first table column.  The third register will
** contain the content of the second table column.  And so forth.
**
** The regOldData parameter is similar to regNewData except that it contains
** the data prior to an UPDATE rather than afterwards.  regOldData is zero
** for an INSERT.  This routine can distinguish between UPDATE and INSERT by
** checking regOldData for zero.
**
** For an UPDATE, the pkChng boolean is true if the true primary key (the
** rowid for a normal table or the PRIMARY KEY for a WITHOUT ROWID table)
** might be modified by the UPDATE.  If pkChng is false, then the key of
** the iDataCur content table is guaranteed to be unchanged by the UPDATE.
**
** For an INSERT, the pkChng boolean indicates whether or not the rowid
** was explicitly specified as part of the INSERT statement.  If pkChng
** is zero, it means that the either rowid is computed automatically or
** that the table is a WITHOUT ROWID table and has no rowid.  On an INSERT,
** pkChng will only be true if the INSERT statement provides an integer
** value for either the rowid column or its INTEGER PRIMARY KEY alias.
**
** The code generated by this routine will store new index entries into
** registers identified by aRegIdx[].  No index entry is created for
** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is
** the same as the order of indices on the linked list of indices
** at pTab->pIndex.
**
** (2019-05-07) The generated code also creates a new record for the
** main table, if pTab is a rowid table, and stores that record in the
** register identified by aRegIdx[nIdx] - in other words in the first
** entry of aRegIdx[] past the last index.  It is important that the
** record be generated during constraint checks to avoid affinity changes
** to the register content that occur after constraint checks but before
** the new record is inserted.
**
** The caller must have already opened writeable cursors on the main
** table and all applicable indices (that is to say, all indices for which
** aRegIdx[] is not zero).  iDataCur is the cursor for the main table when
** inserting or updating a rowid table, or the cursor for the PRIMARY KEY
** index when operating on a WITHOUT ROWID table.  iIdxCur is the cursor
** for the first index in the pTab->pIndex list.  Cursors for other indices
** are at iIdxCur+N for the N-th element of the pTab->pIndex list.
**
** This routine also generates code to check constraints.  NOT NULL,
** CHECK, and UNIQUE constraints are all checked.  If a constraint fails,
** then the appropriate action is performed.  There are five possible
** actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE.
**
**  Constraint type  Action       What Happens
**  ---------------  ----------   ----------------------------------------
**  any              ROLLBACK     The current transaction is rolled back and
**                                sqlite3_step() returns immediately with a
**                                return code of SQLITE_CONSTRAINT.
**
**  any              ABORT        Back out changes from the current command
**                                only (do not do a complete rollback) then
**                                cause sqlite3_step() to return immediately
**                                with SQLITE_CONSTRAINT.
**
**  any              FAIL         Sqlite3_step() returns immediately with a
**                                return code of SQLITE_CONSTRAINT.  The
**                                transaction is not rolled back and any
**                                changes to prior rows are retained.
**
**  any              IGNORE       The attempt in insert or update the current
**                                row is skipped, without throwing an error.
**                                Processing continues with the next row.
**                                (There is an immediate jump to ignoreDest.)
**
**  NOT NULL         REPLACE      The NULL value is replace by the default
**                                value for that column.  If the default value
**                                is NULL, the action is the same as ABORT.
**
**  UNIQUE           REPLACE      The other row that conflicts with the row
**                                being inserted is removed.
**
**  CHECK            REPLACE      Illegal.  The results in an exception.
**
** Which action to take is determined by the overrideError parameter.
** Or if overrideError==OE_Default, then the pParse->onError parameter
** is used.  Or if pParse->onError==OE_Default then the onError value
** for the constraint is used.
*/
void sqlite3GenerateConstraintChecks(
  Parse *pParse,       /* The parser context */
  Table *pTab,         /* The table being inserted or updated */
  int *aRegIdx,        /* Use register aRegIdx[i] for index i.  0 for unused */
  int iDataCur,        /* Canonical data cursor (main table or PK index) */
  int iIdxCur,         /* First index cursor */
  int regNewData,      /* First register in a range holding values to insert */
  int regOldData,      /* Previous content.  0 for INSERTs */
  u8 pkChng,           /* Non-zero if the rowid or PRIMARY KEY changed */
  u8 overrideError,    /* Override onError to this if not OE_Default */
  int ignoreDest,      /* Jump to this label on an OE_Ignore resolution */
  int *pbMayReplace,   /* OUT: Set to true if constraint may cause a replace */
  int *aiChng,         /* column i is unchanged if aiChng[i]<0 */
  Upsert *pUpsert      /* ON CONFLICT clauses, if any.  NULL otherwise */
){
  Vdbe *v;             /* VDBE under constrution */
  Index *pIdx;         /* Pointer to one of the indices */
  Index *pPk = 0;      /* The PRIMARY KEY index for WITHOUT ROWID tables */
  sqlite3 *db;         /* Database connection */
  int i;               /* loop counter */
  int ix;              /* Index loop counter */
  int nCol;            /* Number of columns */
  int onError;         /* Conflict resolution strategy */
  int seenReplace = 0; /* True if REPLACE is used to resolve INT PK conflict */
  int nPkField;        /* Number of fields in PRIMARY KEY. 1 for ROWID tables */
  Upsert *pUpsertClause = 0;  /* The specific ON CONFLICT clause for pIdx */
  u8 isUpdate;           /* True if this is an UPDATE operation */
  u8 bAffinityDone = 0;  /* True if the OP_Affinity operation has been run */
  int upsertIpkReturn = 0; /* Address of Goto at end of IPK uniqueness check */
  int upsertIpkDelay = 0;  /* Address of Goto to bypass initial IPK check */
  int ipkTop = 0;        /* Top of the IPK uniqueness check */
  int ipkBottom = 0;     /* OP_Goto at the end of the IPK uniqueness check */
  /* Variables associated with retesting uniqueness constraints after
  ** replace triggers fire have run */
  int regTrigCnt;       /* Register used to count replace trigger invocations */
  int addrRecheck = 0;  /* Jump here to recheck all uniqueness constraints */
  int lblRecheckOk = 0; /* Each recheck jumps to this label if it passes */
  Trigger *pTrigger;    /* List of DELETE triggers on the table pTab */
  int nReplaceTrig = 0; /* Number of replace triggers coded */
  IndexIterator sIdxIter;  /* Index iterator */

  isUpdate = regOldData!=0;
  db = pParse->db;
  v = pParse->pVdbe;
  assert( v!=0 );
  assert( pTab->pSelect==0 );  /* This table is not a VIEW */
  nCol = pTab->nCol;
  
  /* pPk is the PRIMARY KEY index for WITHOUT ROWID tables and NULL for
  ** normal rowid tables.  nPkField is the number of key fields in the 
  ** pPk index or 1 for a rowid table.  In other words, nPkField is the
  ** number of fields in the true primary key of the table. */
  
// MCC Label 857
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 857);
}
// MCC Label 858
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 858);
}
if( HasRowid(pTab) ){
    pPk = 0;
    nPkField = 1;
  }else{
    pPk = sqlite3PrimaryKeyIndex(pTab);
    nPkField = pPk->nKeyCol;
  }

  /* Record that this module has started */
  VdbeModuleComment((v, "BEGIN: GenCnstCks(%d,%d,%d,%d,%d)",
                     iDataCur, iIdxCur, regNewData, regOldData, pkChng));

  /* Test all NOT NULL constraints.
  */
  
// ABS Label 859
if(pTab->tabFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}

// AOR Label 860
if(pTab->tabFlags | 2048 != pTab->tabFlags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 860);
}
// AOR Label 861
if(pTab->tabFlags ^ 2048 != pTab->tabFlags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 861);
}
if( pTab->tabFlags & TF_HasNotNull ){
    int b2ndPass = 0;         /* True if currently running 2nd pass */
    int nSeenReplace = 0;     /* Number of ON CONFLICT REPLACE operations */
    int nGenerated = 0;       /* Number of generated columns with NOT NULL */
    while(1){  /* Make 2 passes over columns. Exit loop via "break" */
      i = 0;

// ABS Label 862
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 862);
}
// ABS Label 863
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}

// ROR Label 864
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}
// ROR Label 865
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 865);
}
// ROR Label 866
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}
for(; i<nCol; i++){
        int iReg;                        /* Register holding column value */
        Column *pCol = &pTab->aCol[i];   /* The column to check for NOT NULL */
        int isGenerated;                 /* non-zero if column is generated */
        onError = pCol->notNull;
        
// ABS Label 872
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}

// ROR Label 873
if((onError != 0) != (onError == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 873);
}
if( onError==OE_None ) { continue; /* No NOT NULL on this column */
}
        
// ABS Label 874
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 874);
}

// ROR Label 875
if((i != pTab->iPKey) != (i == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}
if( i==pTab->iPKey ){
          continue;        /* ROWID is never NULL */
        }
        isGenerated = pCol->colFlags & COLFLAG_GENERATED;
        
// ABS Label 876
if(isGenerated < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}

// COR Label 877
if((isGenerated || !b2ndPass) != (isGenerated && !b2ndPass))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 877);
}

// MCC Label 878
if(isGenerated && !b2ndPass ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 878);
}
// MCC Label 879
if(isGenerated && !(!b2ndPass) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 879);
}
// MCC Label 880
if(!(isGenerated) && !b2ndPass ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 880);
}
// MCC Label 881
if(!(isGenerated) && !(!b2ndPass) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 881);
}
if( isGenerated && !b2ndPass ){
          nGenerated++;
          continue;        /* Generated columns processed on 2nd pass */
        }
        
// ABS Label 882
if(aiChng < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}
// ABS Label 883
if(aiChng[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}
// ABS Label 884
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 884);
}

// COR Label 885
if((aiChng && aiChng[i] < 0 || !isGenerated) != (aiChng && aiChng[i] < 0 && !isGenerated))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 885);
}
// COR Label 886
if((aiChng || aiChng[i] < 0) != (aiChng && aiChng[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 886);
}

// ROR Label 887
if((aiChng[i] <= 0) != (aiChng[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}
// ROR Label 888
if((aiChng[i] > 0) != (aiChng[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
// ROR Label 889
if((aiChng[i] >= 0) != (aiChng[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 889);
}

// MCC Label 890
if(aiChng && aiChng[i] < 0 && !isGenerated ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 890);
}
// MCC Label 891
if(aiChng && aiChng[i] < 0 && !(!isGenerated) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 891);
}
// MCC Label 892
if(aiChng && !(aiChng[i] < 0) && !isGenerated ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 892);
}
// MCC Label 893
if(aiChng && !(aiChng[i] < 0) && !(!isGenerated) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 893);
}
// MCC Label 894
if(!(aiChng) && aiChng[i] < 0 && !isGenerated ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 894);
}
// MCC Label 895
if(!(aiChng) && aiChng[i] < 0 && !(!isGenerated) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 895);
}
// MCC Label 896
if(!(aiChng) && !(aiChng[i] < 0) && !isGenerated ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 896);
}
// MCC Label 897
if(!(aiChng) && !(aiChng[i] < 0) && !(!isGenerated) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 897);
}
if( aiChng && aiChng[i]<0 && !isGenerated ){
          /* Do not check NOT NULL on columns that do not change */
          continue;
        }
        
// ROR Label 898
if((overrideError == 11) != (overrideError != 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 898);
}
if( overrideError!=OE_Default ){
          onError = overrideError;
        }else { 
// ABS Label 899
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 899);
}

// ROR Label 900
if((onError != 11) != (onError == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 900);
}
if( onError==OE_Default ){
          onError = OE_Abort;
        };}

        
// ABS Label 901
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 901);
}

// ROR Label 902
if((onError != 5) != (onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 902);
}
if( onError==OE_Replace ){
          
// ABS Label 903
if(b2ndPass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 903);
}
// ABS Label 904
if(pCol->pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 904);
}

// COR Label 905
if((b2ndPass && pCol->pDflt == 0) != (b2ndPass || pCol->pDflt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 905);
}

// ROR Label 906
if((pCol->pDflt != 0) != (pCol->pDflt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 906);
}

// MCC Label 907
if(b2ndPass && pCol->pDflt == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(b2ndPass && !(pCol->pDflt == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
// MCC Label 909
if(!(b2ndPass) && pCol->pDflt == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 909);
}
// MCC Label 910
if(!(b2ndPass) && !(pCol->pDflt == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 910);
}
if( b2ndPass        /* REPLACE becomes ABORT on the 2nd pass */
           || pCol->pDflt==0  /* REPLACE is ABORT if no DEFAULT value */
          ){
            testcase( pCol->colFlags & COLFLAG_VIRTUAL );
            testcase( pCol->colFlags & COLFLAG_STORED );
            testcase( pCol->colFlags & COLFLAG_GENERATED );
            onError = OE_Abort;
          }else{
            assert( !isGenerated );
          }
        }else { 
// ABS Label 911
if(b2ndPass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}

// COR Label 912
if((b2ndPass || !isGenerated) != (b2ndPass && !isGenerated))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 912);
}

// MCC Label 913
if(b2ndPass && !isGenerated ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 913);
}
// MCC Label 914
if(b2ndPass && !(!isGenerated) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(!(b2ndPass) && !isGenerated ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(!(b2ndPass) && !(!isGenerated) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}
if( b2ndPass && !isGenerated ){
          continue;
        };}

        assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail
            || onError==OE_Ignore || onError==OE_Replace );
        testcase( i!=sqlite3TableColumnToStorage(pTab, i) );
        iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;
        switch( onError ){
          case OE_Replace: {
            int addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, iReg);
            VdbeCoverage(v);
            assert( (pCol->colFlags & COLFLAG_GENERATED)==0 );
            nSeenReplace++;
            
// ABS Label 917
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ABS Label 918
if(pCol->pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 918);
}

// ABS Label 919
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}
sqlite3ExprCodeCopy(pParse, pCol->pDflt, iReg);
            
// ABS Label 920
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}

// ABS Label 921
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}
sqlite3VdbeJumpHere(v, addr1);
            break;
          }
          case OE_Abort:
            sqlite3MayAbort(pParse);
            /* no break */ deliberate_fall_through
          case OE_Rollback:
          case OE_Fail: {
            char *zMsg = sqlite3MPrintf(db, "%s.%s", pTab->zName,
                                        pCol->zName);
            
// ABS Label 922
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}

// ABS Label 923
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}

// ABS Label 924
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 924);
}
sqlite3VdbeAddOp3(v, OP_HaltIfNull, SQLITE_CONSTRAINT_NOTNULL,
                              onError, iReg);
            
// ABS Label 925
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 925);
}
sqlite3VdbeAppendP4(v, zMsg, P4_DYNAMIC);
            
// ABS Label 926
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 926);
}
sqlite3VdbeChangeP5(v, P5_ConstraintNotNull);
            VdbeCoverage(v);
            break;
          }
          default: {
            assert( onError==OE_Ignore );
            
// ABS Label 927
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 927);
}

// ABS Label 928
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 928);
}

// ABS Label 929
if(ignoreDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 929);
}
sqlite3VdbeAddOp2(v, OP_IsNull, iReg, ignoreDest);
            VdbeCoverage(v);
            break;
          }
        } /* end switch(onError) */
      };
// ABS Label 867
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 867);
}
// ABS Label 868
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 868);
}

// ROR Label 869
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 869);
}
// ROR Label 870
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 870);
}
// ROR Label 871
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 871);
}
 /* end loop i over columns */
      
// ABS Label 930
if(nGenerated < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
// ABS Label 931
if(nSeenReplace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 931);
}

// COR Label 932
if((nGenerated == 0 || nSeenReplace == 0) != (nGenerated == 0 && nSeenReplace == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 932);
}

// ROR Label 933
if((nGenerated != 0) != (nGenerated == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 933);
}
// ROR Label 934
if((nSeenReplace != 0) != (nSeenReplace == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 934);
}

// MCC Label 935
if(nGenerated == 0 && nSeenReplace == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 935);
}
// MCC Label 936
if(nGenerated == 0 && !(nSeenReplace == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 936);
}
// MCC Label 937
if(!(nGenerated == 0) && nSeenReplace == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 937);
}
// MCC Label 938
if(!(nGenerated == 0) && !(nSeenReplace == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 938);
}
if( nGenerated==0 && nSeenReplace==0 ){
        /* If there are no generated columns with NOT NULL constraints
        ** and no NOT NULL ON CONFLICT REPLACE constraints, then a single
        ** pass is sufficient */
        break;
      }
      
// ABS Label 939
if(b2ndPass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}
if( b2ndPass ) { break;  /* Never need more than 2 passes */
}
      b2ndPass = 1;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
      
// ABS Label 940
if(nSeenReplace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}

// COR Label 941
if((nSeenReplace > 0 || (pTab->tabFlags & 96) != 0) != (nSeenReplace > 0 && (pTab->tabFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 941);
}

// ROR Label 942
if((nSeenReplace <= 0) != (nSeenReplace > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 942);
}
// ROR Label 943
if((nSeenReplace < 0) != (nSeenReplace > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 943);
}
// ROR Label 944
if((nSeenReplace >= 0) != (nSeenReplace > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 944);
}
// ROR Label 945
if(((pTab->tabFlags & 96) == 0) != ((pTab->tabFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 945);
}

// MCC Label 946
if(nSeenReplace > 0 && (pTab->tabFlags & 96) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 946);
}
// MCC Label 947
if(nSeenReplace > 0 && !((pTab->tabFlags & 96) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 947);
}
// MCC Label 948
if(!(nSeenReplace > 0) && (pTab->tabFlags & 96) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 948);
}
// MCC Label 949
if(!(nSeenReplace > 0) && !((pTab->tabFlags & 96) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 949);
}
if( nSeenReplace>0 && (pTab->tabFlags & TF_HasGenerated)!=0 ){
        /* If any NOT NULL ON CONFLICT REPLACE constraints fired on the
        ** first pass, recomputed values for all generated columns, as
        ** those values might depend on columns affected by the REPLACE.
        */
        
// ABS Label 950
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 950);
}

// ABS Label 951
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 951);
}

// AOR Label 952
if(regNewData - 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 952);
}
// AOR Label 953
if(regNewData / 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 953);
}
// AOR Label 954
if(regNewData * 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 954);
}

// ABS Label 955
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 955);
}
sqlite3ComputeGeneratedColumns(pParse, regNewData+1, pTab);
      }
#endif
    }; /* end of 2-pass loop */
  } /* end if( has-not-null-constraints ) */

  /* Test all CHECK constraints
  */
#ifndef SQLITE_OMIT_CHECK
  
// ABS Label 956
if(pTab->pCheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 956);
}

// COR Label 957
if((pTab->pCheck || (db->flags & 512) == 0) != (pTab->pCheck && (db->flags & 512) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 957);
}

// ROR Label 958
if(((db->flags & 512) != 0) != ((db->flags & 512) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 958);
}

// MCC Label 959
if(pTab->pCheck && (db->flags & 512) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 959);
}
// MCC Label 960
if(pTab->pCheck && !((db->flags & 512) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 960);
}
// MCC Label 961
if(!(pTab->pCheck) && (db->flags & 512) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 961);
}
// MCC Label 962
if(!(pTab->pCheck) && !((db->flags & 512) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 962);
}
if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){
    
// ABS Label 963
if(pTab->pCheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}
ExprList *pCheck = pTab->pCheck;
    pParse->iSelfTab = -(regNewData+1);
    onError = overrideError!=OE_Default ? overrideError : OE_Abort;
    i = 0;

// ABS Label 964
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 964);
}
// ABS Label 965
if(pCheck->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// ROR Label 966
if((i <= pCheck->nExpr) != (i < pCheck->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 966);
}
// ROR Label 967
if((i > pCheck->nExpr) != (i < pCheck->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 967);
}
// ROR Label 968
if((i >= pCheck->nExpr) != (i < pCheck->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 968);
}
for(; i<pCheck->nExpr; i++){
      int allOk;
      Expr *pCopy;
      
// ABS Label 974
if(pCheck->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 974);
}
Expr *pExpr = pCheck->a[i].pExpr;
      if( aiChng
       && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)
      ){
        /* The check constraints do not reference any of the columns being
        ** updated so there is no point it verifying the check constraint */
        continue;
      }
      
// ROR Label 979
if((bAffinityDone != 0) != (bAffinityDone == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 979);
}
if( bAffinityDone==0 ){
        
// ABS Label 980
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}

// ABS Label 981
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 981);
}

// ABS Label 982
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}

// AOR Label 983
if(regNewData - 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 983);
}
// AOR Label 984
if(regNewData / 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 984);
}
// AOR Label 985
if(regNewData * 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 985);
}
sqlite3TableAffinity(v, pTab, regNewData+1);
        bAffinityDone = 1;
      }
      allOk = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeVerifyAbortable(v, onError);
      pCopy = sqlite3ExprDup(db, pExpr, 0);
      if( !db->mallocFailed ){
        
// ABS Label 986
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}

// ABS Label 987
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 987);
}

// ABS Label 988
if(allOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 988);
}
sqlite3ExprIfTrue(pParse, pCopy, allOk, SQLITE_JUMPIFNULL);
      }
      
// ABS Label 975
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 975);
}

// ABS Label 976
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}
sqlite3ExprDelete(db, pCopy);
      
// ABS Label 989
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 989);
}

// ROR Label 990
if((onError != 4) != (onError == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 990);
}
if( onError==OE_Ignore ){
        
// ABS Label 991
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 991);
}

// ABS Label 992
if(ignoreDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 992);
}
sqlite3VdbeGoto(v, ignoreDest);
      }else{
        
// ABS Label 993
if(pCheck->a[i].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 993);
}
char *zName = pCheck->a[i].zEName;
        assert( zName!=0 || pParse->db->mallocFailed );
        
// ABS Label 997
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}

// ROR Label 998
if((onError != 5) != (onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 998);
}
if( onError==OE_Replace ) { onError = OE_Abort; /* IMP: R-26383-51744 */
}
        
// ABS Label 994
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 994);
}

// ABS Label 995
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 995);
}

// ABS Label 996
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 996);
}
sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_CHECK,
                              onError, zName, P4_TRANSIENT,
                              P5_ConstraintCheck);
      }
      
// ABS Label 977
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 977);
}

// ABS Label 978
if(allOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}
sqlite3VdbeResolveLabel(v, allOk);
    };
// ABS Label 969
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 969);
}
// ABS Label 970
if(pCheck->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}

// ROR Label 971
if((i <= pCheck->nExpr) != (i < pCheck->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 971);
}
// ROR Label 972
if((i > pCheck->nExpr) != (i < pCheck->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 972);
}
// ROR Label 973
if((i >= pCheck->nExpr) != (i < pCheck->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 973);
}

    pParse->iSelfTab = 0;
  }
#endif /* !defined(SQLITE_OMIT_CHECK) */

  /* UNIQUE and PRIMARY KEY constraints should be handled in the following
  ** order:
  **
  **   (1)  OE_Update
  **   (2)  OE_Abort, OE_Fail, OE_Rollback, OE_Ignore
  **   (3)  OE_Replace
  **
  ** OE_Fail and OE_Ignore must happen before any changes are made.
  ** OE_Update guarantees that only a single row will change, so it
  ** must happen before OE_Replace.  Technically, OE_Abort and OE_Rollback
  ** could happen in any order, but they are grouped up front for
  ** convenience.
  **
  ** 2018-08-14: Ticket https://www.sqlite.org/src/info/908f001483982c43
  ** The order of constraints used to have OE_Update as (2) and OE_Abort
  ** and so forth as (1). But apparently PostgreSQL checks the OE_Update
  ** constraint before any others, so it had to be moved.
  **
  ** Constraint checking code is generated in this order:
  **   (A)  The rowid constraint
  **   (B)  Unique index constraints that do not have OE_Replace as their
  **        default conflict resolution strategy
  **   (C)  Unique index that do use OE_Replace by default.
  **
  ** The ordering of (2) and (3) is accomplished by making sure the linked
  ** list of indexes attached to a table puts all OE_Replace indexes last
  ** in the list.  See sqlite3CreateIndex() for where that happens.
  */
  sIdxIter.eType = 0;
  sIdxIter.i = 0;
  sIdxIter.u.ax.aIdx = 0;  /* Silence harmless compiler warning */
  sIdxIter.u.lx.pIdx = pTab->pIndex;
  
// ABS Label 999
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}
if( pUpsert ){
    
// ABS Label 1000
if(pUpsert->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}

// ROR Label 1001
if((pUpsert->pUpsertTarget != 0) != (pUpsert->pUpsertTarget == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1001);
}
if( pUpsert->pUpsertTarget==0 ){
      /* There is just on ON CONFLICT clause and it has no constraint-target */
      assert( pUpsert->pNextUpsert==0 );
      
// ROR Label 1002
if((pUpsert->isDoUpdate != 0) != (pUpsert->isDoUpdate == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1002);
}
if( pUpsert->isDoUpdate==0 ){
        /* A single ON CONFLICT DO NOTHING clause, without a constraint-target.
        ** Make all unique constraint resolution be OE_Ignore */
        overrideError = OE_Ignore;
        pUpsert = 0;
      }else{
        /* A single ON CONFLICT DO UPDATE.  Make all resolutions OE_Update */
        overrideError = OE_Update;
      }
    }else { 
// ABS Label 1003
if(pTab->pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// ROR Label 1004
if((pTab->pIndex == 0) != (pTab->pIndex != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1004);
}
if( pTab->pIndex!=0 ){
      /* Otherwise, we'll need to run the IndexListTerm array version of the
      ** iterator to ensure that all of the ON CONFLICT conditions are
      ** checked first and in order. */
      int nIdx, jj;
      u64 nByte;
      Upsert *pTerm;
      u8 *bUsed;
      nIdx = 0 , pIdx = pTab->pIndex;

// ABS Label 1005
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1005);
}
for(; pIdx; pIdx=pIdx->pNext, nIdx++){
         assert( aRegIdx[nIdx]>0 );
      };
// ABS Label 1006
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}

      sIdxIter.eType = 1;
      sIdxIter.u.ax.nIdx = nIdx;
      nByte = (sizeof(IndexListTerm)+1)*nIdx + nIdx;
      sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, nByte);
      
// ABS Label 1007
if(sIdxIter.u.ax.aIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1007);
}

// ROR Label 1008
if((sIdxIter.u.ax.aIdx != 0) != (sIdxIter.u.ax.aIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1008);
}
if( sIdxIter.u.ax.aIdx==0 ) { return; /* OOM */
}
      bUsed = (u8*)&sIdxIter.u.ax.aIdx[nIdx];
      pUpsert->pToFree = sIdxIter.u.ax.aIdx;
      i = 0 , pTerm = pUpsert;

// ABS Label 1009
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1009);
}
for(; pTerm; pTerm=pTerm->pNextUpsert){
        
// ABS Label 1011
if(pTerm->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1011);
}

// ROR Label 1012
if((pTerm->pUpsertTarget != 0) != (pTerm->pUpsertTarget == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1012);
}
if( pTerm->pUpsertTarget==0 ) { break;
}
        
// ABS Label 1013
if(pTerm->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1013);
}

// ROR Label 1014
if((pTerm->pUpsertIdx != 0) != (pTerm->pUpsertIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1014);
}
if( pTerm->pUpsertIdx==0 ) { continue;  /* Skip ON CONFLICT for the IPK */
}
        jj = 0;
        pIdx = pTab->pIndex;
        
// ABS Label 1015
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}
// ABS Label 1016
if(pTerm->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}

// COR Label 1017
if(((pIdx != 0) || pIdx != pTerm->pUpsertIdx) != ((pIdx != 0) && pIdx != pTerm->pUpsertIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1017);
}

// ROR Label 1018
if((pIdx == pTerm->pUpsertIdx) != (pIdx != pTerm->pUpsertIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1018);
}

// MCC Label 1019
if(( pIdx != 0 ) && pIdx != pTerm->pUpsertIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1019);
}
// MCC Label 1020
if(( pIdx != 0 ) && !(pIdx != pTerm->pUpsertIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1020);
}
// MCC Label 1021
if(( !(pIdx != 0) ) && pIdx != pTerm->pUpsertIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1021);
}
// MCC Label 1022
if(( !(pIdx != 0) ) && !(pIdx != pTerm->pUpsertIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1022);
}
while( ALWAYS(pIdx!=0) && pIdx!=pTerm->pUpsertIdx ){
           pIdx = pIdx->pNext;
           jj++;
        };
// ABS Label 1023
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}
// ABS Label 1024
if(pTerm->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1024);
}

// COR Label 1025
if(((pIdx != 0) || pIdx != pTerm->pUpsertIdx) != ((pIdx != 0) && pIdx != pTerm->pUpsertIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1025);
}

// ROR Label 1026
if((pIdx == pTerm->pUpsertIdx) != (pIdx != pTerm->pUpsertIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1026);
}

// MCC Label 1027
if(( pIdx != 0 ) && pIdx != pTerm->pUpsertIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1027);
}
// MCC Label 1028
if(( pIdx != 0 ) && !(pIdx != pTerm->pUpsertIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1028);
}
// MCC Label 1029
if(( !(pIdx != 0) ) && pIdx != pTerm->pUpsertIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1029);
}
// MCC Label 1030
if(( !(pIdx != 0) ) && !(pIdx != pTerm->pUpsertIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1030);
}

        
// ABS Label 1031
if(bUsed[jj] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}
// ABS Label 1032
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}
if( bUsed[jj] ) { continue; /* Duplicate ON CONFLICT clause ignored */
}
        bUsed[jj] = 1;
        sIdxIter.u.ax.aIdx[i].p = pIdx;
        sIdxIter.u.ax.aIdx[i].ix = jj;
        i++;
      };
// ABS Label 1010
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1010);
}

      jj = 0 , pIdx = pTab->pIndex;

// ABS Label 1033
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}
for(; pIdx; pIdx=pIdx->pNext, jj++){
        
// ABS Label 1035
if(bUsed[jj] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1035);
}
// ABS Label 1036
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1036);
}
if( bUsed[jj] ) { continue;
}
        sIdxIter.u.ax.aIdx[i].p = pIdx;
        sIdxIter.u.ax.aIdx[i].ix = jj;
        i++;
      };
// ABS Label 1034
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1034);
}

      assert( i==nIdx );
    };}

  }

  /* Determine if it is possible that triggers (either explicitly coded
  ** triggers or FK resolution actions) might run as a result of deletes
  ** that happen when OE_Replace conflict resolution occurs. (Call these
  ** "replace triggers".)  If any replace triggers run, we will need to
  ** recheck all of the uniqueness constraints after they have all run.
  ** But on the recheck, the resolution is OE_Abort instead of OE_Replace.
  **
  ** If replace triggers are a possibility, then
  **
  **   (1) Allocate register regTrigCnt and initialize it to zero.
  **       That register will count the number of replace triggers that
  **       fire.  Constraint recheck only occurs if the number is positive.
  **   (2) Initialize pTrigger to the list of all DELETE triggers on pTab.
  **   (3) Initialize addrRecheck and lblRecheckOk
  **
  ** The uniqueness rechecking code will create a series of tests to run
  ** in a second pass.  The addrRecheck and lblRecheckOk variables are
  ** used to link together these tests which are separated from each other
  ** in the generate bytecode.
  */
  
// ROR Label 1037
if(((db->flags & (8192 | 16384)) != 0) != ((db->flags & (8192 | 16384)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1037);
}
if( (db->flags & (SQLITE_RecTriggers|SQLITE_ForeignKeys))==0 ){
    /* There are not DELETE triggers nor FK constraints.  No constraint
    ** rechecks are needed. */
    pTrigger = 0;
    regTrigCnt = 0;
  }else{
    
// ABS Label 1038
if(db->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1038);
}

// AOR Label 1039
if(db->flags | 8192 != db->flags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1039);
}
// AOR Label 1040
if(db->flags ^ 8192 != db->flags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1040);
}
if( db->flags&SQLITE_RecTriggers ){
      pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
      regTrigCnt = pTrigger!=0 || sqlite3FkRequired(pParse, pTab, 0, 0);
    }else{
      pTrigger = 0;
      regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);
    }
    
// ABS Label 1041
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}
if( regTrigCnt ){
      /* Replace triggers might exist.  Allocate the counter and
      ** initialize it to zero. */
      regTrigCnt = ++pParse->nMem;
      
// ABS Label 1042
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}

// ABS Label 1043
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regTrigCnt);
      VdbeComment((v, "trigger count"));
      lblRecheckOk = sqlite3VdbeMakeLabel(pParse);
      addrRecheck = lblRecheckOk;
    }
  }

  /* If rowid is changing, make sure the new rowid does not previously
  ** exist in the table.
  */
  
// ABS Label 1044
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// COR Label 1045
if((pkChng || pPk == 0) != (pkChng && pPk == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1045);
}

// ROR Label 1046
if((pPk != 0) != (pPk == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1046);
}

// MCC Label 1047
if(pkChng && pPk == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1047);
}
// MCC Label 1048
if(pkChng && !(pPk == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1048);
}
// MCC Label 1049
if(!(pkChng) && pPk == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1049);
}
// MCC Label 1050
if(!(pkChng) && !(pPk == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1050);
}
if( pkChng && pPk==0 ){
    int addrRowidOk = sqlite3VdbeMakeLabel(pParse);

    /* Figure out what action to take in case of a rowid collision */
    onError = pTab->keyConf;
    
// ROR Label 1057
if((overrideError == 11) != (overrideError != 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1057);
}
if( overrideError!=OE_Default ){
      onError = overrideError;
    }else { 
// ABS Label 1058
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}

// ROR Label 1059
if((onError != 11) != (onError == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1059);
}
if( onError==OE_Default ){
      onError = OE_Abort;
    };}


    /* figure out whether or not upsert applies in this case */
    
// ABS Label 1060
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}
if( pUpsert ){
      pUpsertClause = sqlite3UpsertOfIndex(pUpsert,0);
      
// ABS Label 1061
if(pUpsertClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1061);
}

// ROR Label 1062
if((pUpsertClause == 0) != (pUpsertClause != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1062);
}
if( pUpsertClause!=0 ){
        
// ROR Label 1063
if((pUpsertClause->isDoUpdate != 0) != (pUpsertClause->isDoUpdate == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1063);
}
if( pUpsertClause->isDoUpdate==0 ){
          onError = OE_Ignore;  /* DO NOTHING is the same as INSERT OR IGNORE */
        }else{
          onError = OE_Update;  /* DO UPDATE */
        }
      }
      
// ABS Label 1064
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1064);
}
// ABS Label 1065
if(pUpsertClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1065);
}

// ROR Label 1066
if((pUpsertClause == pUpsert) != (pUpsertClause != pUpsert))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1066);
}
if( pUpsertClause!=pUpsert ){
        /* The first ON CONFLICT clause has a conflict target other than
        ** the IPK.  We have to jump ahead to that first ON CONFLICT clause
        ** and then come back here and deal with the IPK afterwards */
        upsertIpkDelay = sqlite3VdbeAddOp0(v, OP_Goto);
      }
    }

    /* If the response to a rowid conflict is REPLACE but the response
    ** to some other UNIQUE constraint is FAIL or IGNORE, then we need
    ** to defer the running of the rowid conflict checking until after
    ** the UNIQUE constraints have run.
    */
    
// ABS Label 1067
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}
// ABS Label 1068
if(pTab->pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1068);
}

// COR Label 1069
if((onError == 5 && onError != overrideError || pTab->pIndex) != (onError == 5 && onError != overrideError && pTab->pIndex))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1069);
}
// COR Label 1070
if((onError == 5 || onError != overrideError) != (onError == 5 && onError != overrideError))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1070);
}

// ROR Label 1071
if((onError != 5) != (onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1071);
}
// ROR Label 1072
if((onError == overrideError) != (onError != overrideError))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1072);
}

// MCC Label 1073
if(onError == 5 && onError != overrideError && pTab->pIndex ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1073);
}
// MCC Label 1074
if(onError == 5 && onError != overrideError && !(pTab->pIndex) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1074);
}
// MCC Label 1075
if(onError == 5 && !(onError != overrideError) && pTab->pIndex ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1075);
}
// MCC Label 1076
if(onError == 5 && !(onError != overrideError) && !(pTab->pIndex) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1076);
}
// MCC Label 1077
if(!(onError == 5) && onError != overrideError && pTab->pIndex ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1077);
}
// MCC Label 1078
if(!(onError == 5) && onError != overrideError && !(pTab->pIndex) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1078);
}
// MCC Label 1079
if(!(onError == 5) && !(onError != overrideError) && pTab->pIndex ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1079);
}
// MCC Label 1080
if(!(onError == 5) && !(onError != overrideError) && !(pTab->pIndex) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1080);
}
if( onError==OE_Replace      /* IPK rule is REPLACE */
     && onError!=overrideError   /* Rules for other constraints are different */
     && pTab->pIndex             /* There exist other constraints */
    ){
      ipkTop = sqlite3VdbeAddOp0(v, OP_Goto)+1;
      VdbeComment((v, "defer IPK REPLACE until last"));
    }

    
// ABS Label 1081
if(isUpdate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1081);
}
if( isUpdate ){
      /* pkChng!=0 does not mean that the rowid has changed, only that
      ** it might have changed.  Skip the conflict logic below if the rowid
      ** is unchanged. */
      
// ABS Label 1082
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1082);
}

// ABS Label 1083
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1083);
}

// ABS Label 1084
if(addrRowidOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1084);
}

// ABS Label 1085
if(regOldData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1085);
}
sqlite3VdbeAddOp3(v, OP_Eq, regNewData, addrRowidOk, regOldData);
      
// ABS Label 1086
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1086);
}
sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
      VdbeCoverage(v);
    }

    /* Check to see if the new rowid already exists in the table.  Skip
    ** the following conflict logic if it does not. */
    VdbeNoopComment((v, "uniqueness check for ROWID"));
    sqlite3VdbeVerifyAbortable(v, onError);
    
// ABS Label 1051
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}

// ABS Label 1052
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}

// ABS Label 1053
if(addrRowidOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}

// ABS Label 1054
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}
sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, addrRowidOk, regNewData);
    VdbeCoverage(v);

    switch( onError ){
      default: {
        onError = OE_Abort;
        /* no break */ deliberate_fall_through
      }
      case OE_Rollback:
      case OE_Abort:
      case OE_Fail: {
        testcase( onError==OE_Rollback );
        testcase( onError==OE_Abort );
        testcase( onError==OE_Fail );
        
// ABS Label 1087
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1087);
}

// ABS Label 1088
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}

// ABS Label 1089
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}
sqlite3RowidConstraint(pParse, onError, pTab);
        break;
      }
      case OE_Replace: {
        /* If there are DELETE triggers on this table and the
        ** recursive-triggers flag is set, call GenerateRowDelete() to
        ** remove the conflicting row from the table. This will fire
        ** the triggers and remove both the table and index b-tree entries.
        **
        ** Otherwise, if there are no triggers or the recursive-triggers
        ** flag is not set, but the table has one or more indexes, call 
        ** GenerateRowIndexDelete(). This removes the index b-tree entries 
        ** only. The table b-tree entry will be replaced by the new entry 
        ** when it is inserted.  
        **
        ** If either GenerateRowDelete() or GenerateRowIndexDelete() is called,
        ** also invoke MultiWrite() to indicate that this VDBE may require
        ** statement rollback (if the statement is aborted after the delete
        ** takes place). Earlier versions called sqlite3MultiWrite() regardless,
        ** but being more selective here allows statements like:
        **
        **   REPLACE INTO t(rowid) VALUES($newrowid)
        **
        ** to run without a statement journal if there are no indexes on the
        ** table.
        */
        
// ABS Label 1090
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}
if( regTrigCnt ){
          
// ABS Label 1091
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}
sqlite3MultiWrite(pParse);
          
// ABS Label 1092
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// ABS Label 1093
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1093);
}

// ABS Label 1094
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1094);
}

// ABS Label 1095
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}

// ABS Label 1096
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1096);
}

// ABS Label 1097
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1097);
}
sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
                                   regNewData, 1, 0, OE_Replace, 1, -1);
          
// ABS Label 1098
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1098);
}

// ABS Label 1099
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}
sqlite3VdbeAddOp2(v, OP_AddImm, regTrigCnt, 1); /* incr trigger cnt */
          nReplaceTrig++;
        }else{
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
          assert( HasRowid(pTab) );
          /* This OP_Delete opcode fires the pre-update-hook only. It does
          ** not modify the b-tree. It is more efficient to let the coming
          ** OP_Insert replace the existing entry than it is to delete the
          ** existing entry and then insert a new one. */
          sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, OPFLAG_ISNOOP);
          sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */
          
// ABS Label 1100
if(pTab->pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}
if( pTab->pIndex ){
            
// ABS Label 1101
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}
sqlite3MultiWrite(pParse);
            
// ABS Label 1102
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1102);
}

// ABS Label 1103
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1103);
}

// ABS Label 1104
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}

// ABS Label 1105
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1105);
}
sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,-1);
          }
        }
        seenReplace = 1;
        break;
      }
#ifndef SQLITE_OMIT_UPSERT
      case OE_Update: {
        
// ABS Label 1106
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1106);
}

// ABS Label 1107
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1107);
}

// ABS Label 1108
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1108);
}

// ABS Label 1109
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1109);
}
sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, 0, iDataCur);
        /* no break */ deliberate_fall_through
      }
#endif
      case OE_Ignore: {
        testcase( onError==OE_Ignore );
        
// ABS Label 1110
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1110);
}

// ABS Label 1111
if(ignoreDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1111);
}
sqlite3VdbeGoto(v, ignoreDest);
        break;
      }
    }
    
// ABS Label 1055
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}

// ABS Label 1056
if(addrRowidOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1056);
}
sqlite3VdbeResolveLabel(v, addrRowidOk);
    
// ABS Label 1112
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1112);
}
// ABS Label 1113
if(pUpsertClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1113);
}

// COR Label 1114
if((pUpsert || pUpsertClause != pUpsert) != (pUpsert && pUpsertClause != pUpsert))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1114);
}

// ROR Label 1115
if((pUpsertClause == pUpsert) != (pUpsertClause != pUpsert))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1115);
}

// MCC Label 1116
if(pUpsert && pUpsertClause != pUpsert ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1116);
}
// MCC Label 1117
if(pUpsert && !(pUpsertClause != pUpsert) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1117);
}
// MCC Label 1118
if(!(pUpsert) && pUpsertClause != pUpsert ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1118);
}
// MCC Label 1119
if(!(pUpsert) && !(pUpsertClause != pUpsert) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1119);
}
if( pUpsert && pUpsertClause!=pUpsert ){
      upsertIpkReturn = sqlite3VdbeAddOp0(v, OP_Goto);
    }else { 
// ABS Label 1120
if(ipkTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1120);
}
if( ipkTop ){
      ipkBottom = sqlite3VdbeAddOp0(v, OP_Goto);
      
// ABS Label 1121
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1121);
}

// ABS Label 1122
if(ipkTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1122);
}

// AOR Label 1123
if(ipkTop / 1 != ipkTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1123);
}
// AOR Label 1124
if(ipkTop + 1 != ipkTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1124);
}
// AOR Label 1125
if(ipkTop * 1 != ipkTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1125);
}
sqlite3VdbeJumpHere(v, ipkTop-1);
    };}

  }

  /* Test all UNIQUE constraints by creating entries for each UNIQUE
  ** index and making sure that duplicate entries do not already exist.
  ** Compute the revised record entries for indices as we go.
  **
  ** This loop also handles the case of the PRIMARY KEY index for a
  ** WITHOUT ROWID table.
  */
  pIdx = indexIteratorFirst(&sIdxIter, &ix);

// ABS Label 1126
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1126);
}
for(;
      pIdx;
      pIdx = indexIteratorNext(&sIdxIter, &ix)
  ){
    int regIdx;          /* Range of registers hold conent for pIdx */
    int regR;            /* Range of registers holding conflicting PK */
    int iThisCur;        /* Cursor for this UNIQUE index */
    int addrUniqueOk;    /* Jump here if the UNIQUE constraint is satisfied */
    int addrConflictCk;  /* First opcode in the conflict check logic */

    
// ABS Label 1134
if(aRegIdx[ix] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}
// ABS Label 1135
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1135);
}

// ROR Label 1136
if((aRegIdx[ix] != 0) != (aRegIdx[ix] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1136);
}
if( aRegIdx[ix]==0 ) { continue;  /* Skip indices that do not change */
}
    
// ABS Label 1137
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1137);
}
if( pUpsert ){
      pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);
      
// ABS Label 1138
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1138);
}
// ABS Label 1139
if(pUpsertClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1139);
}
// ABS Label 1140
if(upsertIpkDelay < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1140);
}

// COR Label 1141
if((upsertIpkDelay || pUpsertClause == pUpsert) != (upsertIpkDelay && pUpsertClause == pUpsert))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1141);
}

// ROR Label 1142
if((pUpsertClause != pUpsert) != (pUpsertClause == pUpsert))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1142);
}

// MCC Label 1143
if(upsertIpkDelay && pUpsertClause == pUpsert ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1143);
}
// MCC Label 1144
if(upsertIpkDelay && !(pUpsertClause == pUpsert) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1144);
}
// MCC Label 1145
if(!(upsertIpkDelay) && pUpsertClause == pUpsert ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1145);
}
// MCC Label 1146
if(!(upsertIpkDelay) && !(pUpsertClause == pUpsert) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1146);
}
if( upsertIpkDelay && pUpsertClause==pUpsert ){
        
// ABS Label 1147
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1147);
}

// ABS Label 1148
if(upsertIpkDelay < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1148);
}
sqlite3VdbeJumpHere(v, upsertIpkDelay);
      }
    }
    addrUniqueOk = sqlite3VdbeMakeLabel(pParse);
    
// ROR Label 1149
if((bAffinityDone != 0) != (bAffinityDone == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1149);
}
if( bAffinityDone==0 ){
      
// ABS Label 1150
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1150);
}

// ABS Label 1151
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1151);
}

// ABS Label 1152
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}

// AOR Label 1153
if(regNewData - 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1153);
}
// AOR Label 1154
if(regNewData / 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1154);
}
// AOR Label 1155
if(regNewData * 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1155);
}
sqlite3TableAffinity(v, pTab, regNewData+1);
      bAffinityDone = 1;
    }
    VdbeNoopComment((v, "prep index %s", pIdx->zName));
    iThisCur = iIdxCur+ix;


    /* Skip partial indices for which the WHERE clause is not true */
    
// ABS Label 1156
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}
if( pIdx->pPartIdxWhere ){
      
// ABS Label 1157
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}

// ABS Label 1158
if(aRegIdx[ix] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1158);
}
// ABS Label 1159
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1159);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, aRegIdx[ix]);
      pParse->iSelfTab = -(regNewData+1);
      
// ABS Label 1160
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1160);
}

// ABS Label 1161
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1161);
}

// ABS Label 1162
if(addrUniqueOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1162);
}
sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk,
                            SQLITE_JUMPIFNULL);
      pParse->iSelfTab = 0;
    }

    /* Create a record for this index entry as it should appear after
    ** the insert or update.  Store that record in the aRegIdx[ix] register
    */
    regIdx = aRegIdx[ix]+1;
    i = 0;

// ABS Label 1163
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}

// ROR Label 1164
if((i <= pIdx->nColumn) != (i < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1164);
}
// ROR Label 1165
if((i > pIdx->nColumn) != (i < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1165);
}
// ROR Label 1166
if((i >= pIdx->nColumn) != (i < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1166);
}
for(; i<pIdx->nColumn; i++){
      int iField = pIdx->aiColumn[i];
      int x;
      
// ABS Label 1171
if(iField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1171);
}

// ROR Label 1172
if((iField != (-2)) != (iField == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1172);
}
if( iField==XN_EXPR ){
        pParse->iSelfTab = -(regNewData+1);
        
// ABS Label 1173
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1173);
}

// ABS Label 1174
if(pIdx->aColExpr->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1174);
}

// ABS Label 1175
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}
// ABS Label 1176
if(regIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1176);
}

// AOR Label 1177
if(regIdx - i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1177);
}
// AOR Label 1178
if(regIdx / i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1178);
}
// AOR Label 1179
if(regIdx * i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1179);
}
sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
        pParse->iSelfTab = 0;
        VdbeComment((v, "%s column %d", pIdx->zName, i));
      }else { 
// ABS Label 1180
if(iField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1180);
}

// COR Label 1181
if((iField == (-1) && iField == pTab->iPKey) != (iField == (-1) || iField == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1181);
}

// ROR Label 1182
if((iField != (-1)) != (iField == (-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1182);
}
// ROR Label 1183
if((iField != pTab->iPKey) != (iField == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1183);
}

// MCC Label 1184
if(iField == (-1) && iField == pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1184);
}
// MCC Label 1185
if(iField == (-1) && !(iField == pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1185);
}
// MCC Label 1186
if(!(iField == (-1)) && iField == pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1186);
}
// MCC Label 1187
if(!(iField == (-1)) && !(iField == pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1187);
}
if( iField==XN_ROWID || iField==pTab->iPKey ){
        x = regNewData;
        
// ABS Label 1188
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1188);
}

// ABS Label 1189
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1189);
}

// ABS Label 1190
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}
// ABS Label 1191
if(regIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}

// AOR Label 1192
if(regIdx - i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1192);
}
// AOR Label 1193
if(regIdx / i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1193);
}
// AOR Label 1194
if(regIdx * i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1194);
}
sqlite3VdbeAddOp2(v, OP_IntCopy, x, regIdx+i);
        VdbeComment((v, "rowid"));
      }else{
        testcase( sqlite3TableColumnToStorage(pTab, iField)!=iField );
        x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;
        
// ABS Label 1195
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1195);
}

// ABS Label 1196
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1196);
}

// ABS Label 1197
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1197);
}
// ABS Label 1198
if(regIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1198);
}

// AOR Label 1199
if(regIdx - i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1199);
}
// AOR Label 1200
if(regIdx / i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1200);
}
// AOR Label 1201
if(regIdx * i != regIdx + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1201);
}
sqlite3VdbeAddOp2(v, OP_SCopy, x, regIdx+i);
        VdbeComment((v, "%s", pTab->aCol[iField].zName));
      };}

    };
// ABS Label 1167
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1167);
}

// ROR Label 1168
if((i <= pIdx->nColumn) != (i < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1168);
}
// ROR Label 1169
if((i > pIdx->nColumn) != (i < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1169);
}
// ROR Label 1170
if((i >= pIdx->nColumn) != (i < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1170);
}

    
// ABS Label 1128
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1128);
}

// ABS Label 1129
if(regIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1129);
}

// ABS Label 1130
if(aRegIdx[ix] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1130);
}
// ABS Label 1131
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1131);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn, aRegIdx[ix]);
    VdbeComment((v, "for %s", pIdx->zName));
#ifdef SQLITE_ENABLE_NULL_TRIM
    if( pIdx->idxType==SQLITE_IDXTYPE_PRIMARYKEY ){
      sqlite3SetMakeRecordP5(v, pIdx->pTable);
    }
#endif
    sqlite3VdbeReleaseRegisters(pParse, regIdx, pIdx->nColumn, 0, 0);

    /* In an UPDATE operation, if this index is the PRIMARY KEY index 
    ** of a WITHOUT ROWID table and there has been no change the
    ** primary key, then no collision is possible.  The collision detection
    ** logic below can all be skipped. */
    
// ABS Label 1202
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1202);
}
// ABS Label 1203
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1203);
}

// COR Label 1204
if((isUpdate && pPk == pIdx || pkChng == 0) != (isUpdate && pPk == pIdx && pkChng == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1204);
}
// COR Label 1205
if((isUpdate || pPk == pIdx) != (isUpdate && pPk == pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1205);
}

// ROR Label 1206
if((pPk != pIdx) != (pPk == pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1206);
}
// ROR Label 1207
if((pkChng != 0) != (pkChng == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1207);
}

// MCC Label 1208
if(isUpdate && pPk == pIdx && pkChng == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1208);
}
// MCC Label 1209
if(isUpdate && pPk == pIdx && !(pkChng == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1209);
}
// MCC Label 1210
if(isUpdate && !(pPk == pIdx) && pkChng == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1210);
}
// MCC Label 1211
if(isUpdate && !(pPk == pIdx) && !(pkChng == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1211);
}
// MCC Label 1212
if(!(isUpdate) && pPk == pIdx && pkChng == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1212);
}
// MCC Label 1213
if(!(isUpdate) && pPk == pIdx && !(pkChng == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1213);
}
// MCC Label 1214
if(!(isUpdate) && !(pPk == pIdx) && pkChng == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1214);
}
// MCC Label 1215
if(!(isUpdate) && !(pPk == pIdx) && !(pkChng == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1215);
}
if( isUpdate && pPk==pIdx && pkChng==0 ){
      
// ABS Label 1216
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1216);
}

// ABS Label 1217
if(addrUniqueOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1217);
}
sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }

    /* Find out what action to take in case there is a uniqueness conflict */
    onError = pIdx->onError;
    
// ABS Label 1218
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1218);
}

// ROR Label 1219
if((onError != 0) != (onError == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1219);
}
if( onError==OE_None ){ 
      
// ABS Label 1220
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1220);
}

// ABS Label 1221
if(addrUniqueOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1221);
}
sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;  /* pIdx is not a UNIQUE index */
    }
    
// ROR Label 1222
if((overrideError == 11) != (overrideError != 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1222);
}
if( overrideError!=OE_Default ){
      onError = overrideError;
    }else { 
// ABS Label 1223
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1223);
}

// ROR Label 1224
if((onError != 11) != (onError == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1224);
}
if( onError==OE_Default ){
      onError = OE_Abort;
    };}


    /* Figure out if the upsert clause applies to this index */
    
// ABS Label 1225
if(pUpsertClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1225);
}
if( pUpsertClause ){
      
// ROR Label 1226
if((pUpsertClause->isDoUpdate != 0) != (pUpsertClause->isDoUpdate == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1226);
}
if( pUpsertClause->isDoUpdate==0 ){
        onError = OE_Ignore;  /* DO NOTHING is the same as INSERT OR IGNORE */
      }else{
        onError = OE_Update;  /* DO UPDATE */
      }
    }

    /* Collision detection may be omitted if all of the following are true:
    **   (1) The conflict resolution algorithm is REPLACE
    **   (2) The table is a WITHOUT ROWID table
    **   (3) There are no secondary indexes on the table
    **   (4) No delete triggers need to be fired if there is a conflict
    **   (5) No FK constraint counters need to be updated if a conflict occurs.
    **
    ** This is not possible for ENABLE_PREUPDATE_HOOK builds, as the row
    ** must be explicitly deleted in order to ensure any pre-update hook
    ** is invoked.  */ 
#ifndef SQLITE_ENABLE_PREUPDATE_HOOK
    if( (ix==0 && pIdx->pNext==0)                   /* Condition 3 */
     && pPk==pIdx                                   /* Condition 2 */
     && onError==OE_Replace                         /* Condition 1 */
     && ( 0==(db->flags&SQLITE_RecTriggers) ||      /* Condition 4 */
          0==sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0))
     && ( 0==(db->flags&SQLITE_ForeignKeys) ||      /* Condition 5 */
         (0==pTab->pFKey && 0==sqlite3FkReferences(pTab)))
    ){
      
// ABS Label 1227
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1227);
}

// ABS Label 1228
if(addrUniqueOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1228);
}
sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }
#endif /* ifndef SQLITE_ENABLE_PREUPDATE_HOOK */

    /* Check to see if the new index entry will be unique */
    sqlite3VdbeVerifyAbortable(v, onError);
    addrConflictCk = 
      sqlite3VdbeAddOp4Int(v, OP_NoConflict, iThisCur, addrUniqueOk,
                           regIdx, pIdx->nKeyCol); VdbeCoverage(v);

    /* Generate code to handle collisions */
    regR = pIdx==pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);
    
// ABS Label 1229
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1229);
}

// COR Label 1230
if((isUpdate && onError == 5) != (isUpdate || onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1230);
}

// ROR Label 1231
if((onError != 5) != (onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1231);
}

// MCC Label 1232
if(isUpdate && onError == 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1232);
}
// MCC Label 1233
if(isUpdate && !(onError == 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1233);
}
// MCC Label 1234
if(!(isUpdate) && onError == 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1234);
}
// MCC Label 1235
if(!(isUpdate) && !(onError == 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1235);
}
if( isUpdate || onError==OE_Replace ){
      
// MCC Label 1236
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1236);
}
// MCC Label 1237
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1237);
}
if( HasRowid(pTab) ){
        
// ABS Label 1238
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1238);
}

// ABS Label 1239
if(iThisCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1239);
}

// ABS Label 1240
if(regR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1240);
}
sqlite3VdbeAddOp2(v, OP_IdxRowid, iThisCur, regR);
        /* Conflict only if the rowid of the existing index entry
        ** is different from old-rowid */
        
// ABS Label 1241
if(isUpdate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1241);
}
if( isUpdate ){
          
// ABS Label 1242
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1242);
}

// ABS Label 1243
if(regR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1243);
}

// ABS Label 1244
if(addrUniqueOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1244);
}

// ABS Label 1245
if(regOldData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1245);
}
sqlite3VdbeAddOp3(v, OP_Eq, regR, addrUniqueOk, regOldData);
          
// ABS Label 1246
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1246);
}
sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
          VdbeCoverage(v);
        }
      }else{
        int x;
        /* Extract the PRIMARY KEY from the end of the index entry and
        ** store it in registers regR..regR+nPk-1 */
        
// ABS Label 1247
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1247);
}
// ABS Label 1248
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1248);
}

// ROR Label 1249
if((pIdx == pPk) != (pIdx != pPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1249);
}
if( pIdx!=pPk ){
          i = 0;

// ABS Label 1250
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1250);
}

// ROR Label 1251
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1251);
}
// ROR Label 1252
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1252);
}
// ROR Label 1253
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1253);
}
for(; i<pPk->nKeyCol; i++){
            assert( pPk->aiColumn[i]>=0 );
            x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);
            
// ABS Label 1258
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1258);
}

// ABS Label 1259
if(iThisCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1259);
}

// ABS Label 1260
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1260);
}

// ABS Label 1261
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1261);
}
// ABS Label 1262
if(regR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1262);
}

// AOR Label 1263
if(regR - i != regR + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1263);
}
// AOR Label 1264
if(regR / i != regR + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1264);
}
// AOR Label 1265
if(regR * i != regR + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1265);
}
sqlite3VdbeAddOp3(v, OP_Column, iThisCur, x, regR+i);
            VdbeComment((v, "%s.%s", pTab->zName,
                         pTab->aCol[pPk->aiColumn[i]].zName));
          };
// ABS Label 1254
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1254);
}

// ROR Label 1255
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1255);
}
// ROR Label 1256
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1256);
}
// ROR Label 1257
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1257);
}

        }
        
// ABS Label 1266
if(isUpdate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1266);
}
if( isUpdate ){
          /* If currently processing the PRIMARY KEY of a WITHOUT ROWID 
          ** table, only conflict if the new PRIMARY KEY values are actually
          ** different from the old.
          **
          ** For a UNIQUE index, only conflict if the PRIMARY KEY values
          ** of the matched index row are different from the original PRIMARY
          ** KEY values of this row before the update.  */
          int addrJump = sqlite3VdbeCurrentAddr(v)+pPk->nKeyCol;
          int op = OP_Ne;
          int regCmp = (IsPrimaryKeyIndex(pIdx) ? regIdx : regR);
  
          i = 0;

// ABS Label 1267
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1267);
}

// ROR Label 1268
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1268);
}
// ROR Label 1269
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1269);
}
// ROR Label 1270
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1270);
}
for(; i<pPk->nKeyCol; i++){
            char *p4 = (char*)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);
            x = pPk->aiColumn[i];
            assert( x>=0 );
            
// ABS Label 1292
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1292);
}

// ROR Label 1293
if((i != (pPk->nKeyCol - 1)) != (i == (pPk->nKeyCol - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1293);
}
if( i==(pPk->nKeyCol-1) ){
              addrJump = addrUniqueOk;
              op = OP_Eq;
            }
            x = sqlite3TableColumnToStorage(pTab, x);
            
// ABS Label 1275
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1275);
}

// ABS Label 1276
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1276);
}

// ABS Label 1277
if(regOldData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1277);
}
// ABS Label 1278
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1278);
}

// AOR Label 1279
if(regOldData + 1 - x != regOldData + 1 + x)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1279);
}
// AOR Label 1280
if(regOldData + 1 / x != regOldData + 1 + x)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1280);
}
// AOR Label 1281
if(regOldData + 1 * x != regOldData + 1 + x)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1281);
}
// AOR Label 1282
if(regOldData - 1 != regOldData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1282);
}
// AOR Label 1283
if(regOldData / 1 != regOldData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1283);
}
// AOR Label 1284
if(regOldData * 1 != regOldData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1284);
}

// ABS Label 1285
if(addrJump < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1285);
}

// ABS Label 1286
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1286);
}
// ABS Label 1287
if(regCmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1287);
}

// AOR Label 1288
if(regCmp - i != regCmp + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1288);
}
// AOR Label 1289
if(regCmp / i != regCmp + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1289);
}
// AOR Label 1290
if(regCmp * i != regCmp + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1290);
}
sqlite3VdbeAddOp4(v, op, 
                regOldData+1+x, addrJump, regCmp+i, p4, P4_COLLSEQ
            );
            
// ABS Label 1291
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1291);
}
sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
            VdbeCoverageIf(v, op==OP_Eq);
            VdbeCoverageIf(v, op==OP_Ne);
          };
// ABS Label 1271
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1271);
}

// ROR Label 1272
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1272);
}
// ROR Label 1273
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1273);
}
// ROR Label 1274
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1274);
}

        }
      }
    }

    /* Generate code that executes if the new index entry is not unique */
    assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail
        || onError==OE_Ignore || onError==OE_Replace || onError==OE_Update );
    switch( onError ){
      case OE_Rollback:
      case OE_Abort:
      case OE_Fail: {
        testcase( onError==OE_Rollback );
        testcase( onError==OE_Abort );
        testcase( onError==OE_Fail );
        
// ABS Label 1294
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1294);
}

// ABS Label 1295
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1295);
}

// ABS Label 1296
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1296);
}
sqlite3UniqueConstraint(pParse, onError, pIdx);
        break;
      }
#ifndef SQLITE_OMIT_UPSERT
      case OE_Update: {
        
// ABS Label 1297
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1297);
}

// ABS Label 1298
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1298);
}

// ABS Label 1299
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1299);
}

// ABS Label 1300
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1300);
}

// ABS Label 1301
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1301);
}
// ABS Label 1302
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1302);
}

// AOR Label 1303
if(iIdxCur - ix != iIdxCur + ix)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1303);
}
// AOR Label 1304
if(iIdxCur / ix != iIdxCur + ix)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1304);
}
// AOR Label 1305
if(iIdxCur * ix != iIdxCur + ix)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1305);
}
sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix);
        /* no break */ deliberate_fall_through
      }
#endif
      case OE_Ignore: {
        testcase( onError==OE_Ignore );
        
// ABS Label 1306
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1306);
}

// ABS Label 1307
if(ignoreDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1307);
}
sqlite3VdbeGoto(v, ignoreDest);
        break;
      }
      default: {
        int nConflictCk;   /* Number of opcodes in conflict check logic */

        assert( onError==OE_Replace );
        nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk;
        assert( nConflictCk>0 );
        testcase( nConflictCk>1 );
        
// ABS Label 1315
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1315);
}
if( regTrigCnt ){
          
// ABS Label 1316
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1316);
}
sqlite3MultiWrite(pParse);
          nReplaceTrig++;
        }
        
// ABS Label 1317
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1317);
}

// COR Label 1318
if((pTrigger || isUpdate) != (pTrigger && isUpdate))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1318);
}

// MCC Label 1319
if(pTrigger && isUpdate ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1319);
}
// MCC Label 1320
if(pTrigger && !(isUpdate) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1320);
}
// MCC Label 1321
if(!(pTrigger) && isUpdate ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1321);
}
// MCC Label 1322
if(!(pTrigger) && !(isUpdate) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1322);
}
if( pTrigger && isUpdate ){
          
// ABS Label 1323
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1323);
}

// ABS Label 1324
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1324);
}
sqlite3VdbeAddOp1(v, OP_CursorLock, iDataCur);
        }
        
// ABS Label 1308
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1308);
}

// ABS Label 1309
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1309);
}

// ABS Label 1310
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1310);
}

// ABS Label 1311
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1311);
}

// ABS Label 1312
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1312);
}

// ABS Label 1313
if(regR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1313);
}

// ABS Label 1314
if(iThisCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1314);
}
sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
            regR, nPkField, 0, OE_Replace,
            (pIdx==pPk ? ONEPASS_SINGLE : ONEPASS_OFF), iThisCur);
        
// ABS Label 1325
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1325);
}

// COR Label 1326
if((pTrigger || isUpdate) != (pTrigger && isUpdate))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1326);
}

// MCC Label 1327
if(pTrigger && isUpdate ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1327);
}
// MCC Label 1328
if(pTrigger && !(isUpdate) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1328);
}
// MCC Label 1329
if(!(pTrigger) && isUpdate ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1329);
}
// MCC Label 1330
if(!(pTrigger) && !(isUpdate) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1330);
}
if( pTrigger && isUpdate ){
          
// ABS Label 1331
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1331);
}

// ABS Label 1332
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1332);
}
sqlite3VdbeAddOp1(v, OP_CursorUnlock, iDataCur);
        }
        
// ABS Label 1333
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1333);
}
if( regTrigCnt ){
          int addrBypass;  /* Jump destination to bypass recheck logic */

          
// ABS Label 1334
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1334);
}

// ABS Label 1335
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1335);
}
sqlite3VdbeAddOp2(v, OP_AddImm, regTrigCnt, 1); /* incr trigger cnt */
          addrBypass = sqlite3VdbeAddOp0(v, OP_Goto);  /* Bypass recheck */
          VdbeComment((v, "bypass recheck"));

          /* Here we insert code that will be invoked after all constraint
          ** checks have run, if and only if one or more replace triggers
          ** fired. */
          
// ABS Label 1336
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1336);
}

// ABS Label 1337
if(lblRecheckOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1337);
}
sqlite3VdbeResolveLabel(v, lblRecheckOk);
          lblRecheckOk = sqlite3VdbeMakeLabel(pParse);
          
// ABS Label 1342
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1342);
}
if( pIdx->pPartIdxWhere ){
            /* Bypass the recheck if this partial index is not defined
            ** for the current row */
            
// ABS Label 1343
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1343);
}

// ABS Label 1344
if(regIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1344);
}

// AOR Label 1345
if(regIdx / 1 != regIdx - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1345);
}
// AOR Label 1346
if(regIdx + 1 != regIdx - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1346);
}
// AOR Label 1347
if(regIdx * 1 != regIdx - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1347);
}

// ABS Label 1348
if(lblRecheckOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1348);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regIdx-1, lblRecheckOk);
            VdbeCoverage(v);
          }
          /* Copy the constraint check code from above, except change
          ** the constraint-ok jump destination to be the address of
          ** the next retest block */
          
// ABS Label 1349
if(nConflictCk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1349);
}

// ROR Label 1350
if((nConflictCk <= 0) != (nConflictCk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1350);
}
// ROR Label 1351
if((nConflictCk < 0) != (nConflictCk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1351);
}
// ROR Label 1352
if((nConflictCk >= 0) != (nConflictCk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1352);
}
while( nConflictCk>0 ){
            VdbeOp x;    /* Conflict check opcode to copy */
            /* The sqlite3VdbeAddOp4() call might reallocate the opcode array.
            ** Hence, make a complete copy of the opcode, rather than using
            ** a pointer to the opcode. */
            x = *sqlite3VdbeGetOp(v, addrConflictCk);
            
// ROR Label 1357
if((x.opcode == 138) != (x.opcode != 138))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1357);
}
if( x.opcode!=OP_IdxRowid ){
              int p2;      /* New P2 value for copied conflict check opcode */
              const char *zP4;
              
// AOR Label 1365
if(sqlite3OpcodeProperty[x.opcode] | 1 != sqlite3OpcodeProperty[x.opcode] & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1365);
}
// AOR Label 1366
if(sqlite3OpcodeProperty[x.opcode] ^ 1 != sqlite3OpcodeProperty[x.opcode] & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1366);
}
if( sqlite3OpcodeProperty[x.opcode]&OPFLG_JUMP ){
                p2 = lblRecheckOk;
              }else{
                p2 = x.p2;
              }
              zP4 = x.p4type==P4_INT32 ? SQLITE_INT_TO_PTR(x.p4.i) : x.p4.z;
              
// ABS Label 1358
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1358);
}

// ABS Label 1359
if(x.p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1359);
}

// ABS Label 1360
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1360);
}

// ABS Label 1361
if(x.p3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1361);
}

// ABS Label 1362
if(zP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1362);
}
sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, zP4, x.p4type);
              
// ABS Label 1363
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1363);
}

// ABS Label 1364
if(x.p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1364);
}
sqlite3VdbeChangeP5(v, x.p5);
              VdbeCoverageIf(v, p2!=x.p2);
            }
            nConflictCk--;
            addrConflictCk++;
          };
// ABS Label 1353
if(nConflictCk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1353);
}

// ROR Label 1354
if((nConflictCk <= 0) != (nConflictCk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1354);
}
// ROR Label 1355
if((nConflictCk < 0) != (nConflictCk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1355);
}
// ROR Label 1356
if((nConflictCk >= 0) != (nConflictCk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1356);
}

          /* If the retest fails, issue an abort */
          
// ABS Label 1338
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1338);
}

// ABS Label 1339
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1339);
}
sqlite3UniqueConstraint(pParse, OE_Abort, pIdx);

          
// ABS Label 1340
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1340);
}

// ABS Label 1341
if(addrBypass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1341);
}
sqlite3VdbeJumpHere(v, addrBypass); /* Terminate the recheck bypass */
        }
        seenReplace = 1;
        break;
      }
    }
    
// ABS Label 1132
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1132);
}

// ABS Label 1133
if(addrUniqueOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1133);
}
sqlite3VdbeResolveLabel(v, addrUniqueOk);
    
// ABS Label 1367
if(regIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1367);
}
// ABS Label 1368
if(regR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1368);
}

// ROR Label 1369
if((regR == regIdx) != (regR != regIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1369);
}
if( regR!=regIdx ) { 
// ABS Label 1370
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1370);
}

// ABS Label 1371
if(regR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1371);
}

// ABS Label 1372
if(nPkField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1372);
}
sqlite3ReleaseTempRange(pParse, regR, nPkField);
}
    if( pUpsertClause 
     && upsertIpkReturn
     && sqlite3UpsertNextIsIPK(pUpsertClause)
    ){
      
// ABS Label 1373
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1373);
}

// ABS Label 1374
if(upsertIpkDelay < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1374);
}

// AOR Label 1375
if(upsertIpkDelay - 1 != upsertIpkDelay + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1375);
}
// AOR Label 1376
if(upsertIpkDelay / 1 != upsertIpkDelay + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1376);
}
// AOR Label 1377
if(upsertIpkDelay * 1 != upsertIpkDelay + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1377);
}
sqlite3VdbeGoto(v, upsertIpkDelay+1);
      
// ABS Label 1378
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1378);
}

// ABS Label 1379
if(upsertIpkReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1379);
}
sqlite3VdbeJumpHere(v, upsertIpkReturn);
      upsertIpkReturn = 0;
    }
  };
// ABS Label 1127
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}


  /* If the IPK constraint is a REPLACE, run it last */
  
// ABS Label 1380
if(ipkTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1380);
}
if( ipkTop ){
    
// ABS Label 1381
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1381);
}

// ABS Label 1382
if(ipkTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1382);
}
sqlite3VdbeGoto(v, ipkTop);
    VdbeComment((v, "Do IPK REPLACE"));
    
// ABS Label 1383
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1383);
}

// ABS Label 1384
if(ipkBottom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1384);
}
sqlite3VdbeJumpHere(v, ipkBottom);
  }

  /* Recheck all uniqueness constraints after replace triggers have run */
  testcase( regTrigCnt!=0 && nReplaceTrig==0 );
  assert( regTrigCnt!=0 || nReplaceTrig==0 );
  
// ABS Label 1385
if(nReplaceTrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1385);
}
if( nReplaceTrig ){
    
// ABS Label 1386
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1386);
}

// ABS Label 1387
if(regTrigCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1387);
}

// ABS Label 1388
if(lblRecheckOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1388);
}
sqlite3VdbeAddOp2(v, OP_IfNot, regTrigCnt, lblRecheckOk);VdbeCoverage(v);
    if( !pPk ){
      
// ABS Label 1397
if(isUpdate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1397);
}
if( isUpdate ){
        
// ABS Label 1398
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1398);
}

// ABS Label 1399
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1399);
}

// ABS Label 1400
if(addrRecheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1400);
}

// ABS Label 1401
if(regOldData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1401);
}
sqlite3VdbeAddOp3(v, OP_Eq, regNewData, addrRecheck, regOldData);
        
// ABS Label 1402
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1402);
}
sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
        VdbeCoverage(v);
      }
      
// ABS Label 1391
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1391);
}

// ABS Label 1392
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1392);
}

// ABS Label 1393
if(addrRecheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1393);
}

// ABS Label 1394
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1394);
}
sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, addrRecheck, regNewData);
      VdbeCoverage(v);
      
// ABS Label 1395
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1395);
}

// ABS Label 1396
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1396);
}
sqlite3RowidConstraint(pParse, OE_Abort, pTab);
    }else{
      
// ABS Label 1403
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1403);
}

// ABS Label 1404
if(addrRecheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1404);
}
sqlite3VdbeGoto(v, addrRecheck);
    }
    
// ABS Label 1389
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1389);
}

// ABS Label 1390
if(lblRecheckOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1390);
}
sqlite3VdbeResolveLabel(v, lblRecheckOk);
  }

  /* Generate the table record */
  
// MCC Label 1405
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1405);
}
// MCC Label 1406
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1406);
}
if( HasRowid(pTab) ){
    
// ABS Label 1407
if(aRegIdx[ix] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1407);
}
// ABS Label 1408
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1408);
}
int regRec = aRegIdx[ix];
    
// ABS Label 1409
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1409);
}

// ABS Label 1410
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1410);
}

// AOR Label 1411
if(regNewData - 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1411);
}
// AOR Label 1412
if(regNewData / 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1412);
}
// AOR Label 1413
if(regNewData * 1 != regNewData + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1413);
}

// ABS Label 1414
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1414);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nNVCol, regRec);
    sqlite3SetMakeRecordP5(v, pTab);
    if( !bAffinityDone ){
      
// ABS Label 1415
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1415);
}

// ABS Label 1416
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1416);
}
sqlite3TableAffinity(v, pTab, 0);
    }
  }

  *pbMayReplace = seenReplace;
  VdbeModuleComment((v, "END: GenCnstCks(%d)", seenReplace));
}

#ifdef SQLITE_ENABLE_NULL_TRIM
/*
** Change the P5 operand on the last opcode (which should be an OP_MakeRecord)
** to be the number of columns in table pTab that must not be NULL-trimmed.
**
** Or if no columns of pTab may be NULL-trimmed, leave P5 at zero.
*/
void sqlite3SetMakeRecordP5(Vdbe *v, Table *pTab){
  u16 i;

  /* Records with omitted columns are only allowed for schema format
  ** version 2 and later (SQLite version 3.1.4, 2005-02-20). */
  if( pTab->pSchema->file_format<2 ) return;

  for(i=pTab->nCol-1; i>0; i--){
    if( pTab->aCol[i].pDflt!=0 ) break;
    if( pTab->aCol[i].colFlags & COLFLAG_PRIMKEY ) break;
  }
  sqlite3VdbeChangeP5(v, i+1);
}
#endif

/*
** Table pTab is a WITHOUT ROWID table that is being written to. The cursor
** number is iCur, and register regData contains the new record for the
** PK index. This function adds code to invoke the pre-update hook,
** if one is registered.
*/
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
static void codeWithoutRowidPreupdate(
  Parse *pParse,                  /* Parse context */
  Table *pTab,                    /* Table being updated */
  int iCur,                       /* Cursor number for table */
  int regData                     /* Data containing new record */
){
  Vdbe *v = pParse->pVdbe;
  int r = sqlite3GetTempReg(pParse);
  assert( !HasRowid(pTab) );
  assert( 0==(pParse->db->mDbFlags & DBFLAG_Vacuum) || CORRUPT_DB );
  sqlite3VdbeAddOp2(v, OP_Integer, 0, r);
  sqlite3VdbeAddOp4(v, OP_Insert, iCur, regData, r, (char*)pTab, P4_TABLE);
  sqlite3VdbeChangeP5(v, OPFLAG_ISNOOP);
  sqlite3ReleaseTempReg(pParse, r);
}
#else
# define codeWithoutRowidPreupdate(a,b,c,d)
#endif

/*
** This routine generates code to finish the INSERT or UPDATE operation
** that was started by a prior call to sqlite3GenerateConstraintChecks.
** A consecutive range of registers starting at regNewData contains the
** rowid and the content to be inserted.
**
** The arguments to this routine should be the same as the first six
** arguments to sqlite3GenerateConstraintChecks.
*/
void sqlite3CompleteInsertion(
  Parse *pParse,      /* The parser context */
  Table *pTab,        /* the table into which we are inserting */
  int iDataCur,       /* Cursor of the canonical data source */
  int iIdxCur,        /* First index cursor */
  int regNewData,     /* Range of content */
  int *aRegIdx,       /* Register used by each index.  0 for unused indices */
  int update_flags,   /* True for UPDATE, False for INSERT */
  int appendBias,     /* True if this is likely to be an append */
  int useSeekResult   /* True to set the USESEEKRESULT flag on OP_[Idx]Insert */
){
  Vdbe *v;            /* Prepared statements under construction */
  Index *pIdx;        /* An index being inserted or updated */
  u8 pik_flags;       /* flag values passed to the btree insert */
  int i;              /* Loop counter */

  assert( update_flags==0
       || update_flags==OPFLAG_ISUPDATE
       || update_flags==(OPFLAG_ISUPDATE|OPFLAG_SAVEPOSITION)
  );

  v = pParse->pVdbe;
  assert( v!=0 );
  assert( pTab->pSelect==0 );  /* This table is not a VIEW */
  i = 0 , pIdx = pTab->pIndex;

// ABS Label 1423
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1423);
}
for(; pIdx; pIdx=pIdx->pNext, i++){
    /* All REPLACE indexes are at the end of the list */
    assert( pIdx->onError!=OE_Replace
         || pIdx->pNext==0
         || pIdx->pNext->onError==OE_Replace );
    
// ABS Label 1439
if(aRegIdx[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1439);
}
// ABS Label 1440
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1440);
}

// ROR Label 1441
if((aRegIdx[i] != 0) != (aRegIdx[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1441);
}
if( aRegIdx[i]==0 ) { continue;
}
    
// ABS Label 1442
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1442);
}
if( pIdx->pPartIdxWhere ){
      
// ABS Label 1443
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1443);
}

// ABS Label 1444
if(aRegIdx[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1444);
}
// ABS Label 1445
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1445);
}
sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);
      VdbeCoverage(v);
    }
    pik_flags = (useSeekResult ? OPFLAG_USESEEKRESULT : 0);
    
// COR Label 1446
if((((pIdx)->idxType == 2) || !(((pTab)->tabFlags & 128) == 0)) != (((pIdx)->idxType == 2) && !(((pTab)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1446);
}

// MCC Label 1447
if(( (pIdx)->idxType == 2 ) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1447);
}
// MCC Label 1448
if(( (pIdx)->idxType == 2 ) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1448);
}
// MCC Label 1449
if(( !((pIdx)->idxType == 2) ) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1449);
}
// MCC Label 1450
if(( !((pIdx)->idxType == 2) ) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1450);
}
if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){
      assert( pParse->nested==0 );
      pik_flags |= OPFLAG_NCHANGE;
      pik_flags |= (update_flags & OPFLAG_SAVEPOSITION);
      
// ABS Label 1451
if(update_flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1451);
}

// ROR Label 1452
if((update_flags != 0) != (update_flags == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1452);
}
if( update_flags==0 ){
        codeWithoutRowidPreupdate(pParse, pTab, iIdxCur+i, aRegIdx[i]);
      }
    }
    
// ABS Label 1425
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1425);
}

// ABS Label 1426
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1426);
}
// ABS Label 1427
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1427);
}

// AOR Label 1428
if(iIdxCur - i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1428);
}
// AOR Label 1429
if(iIdxCur / i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1429);
}
// AOR Label 1430
if(iIdxCur * i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1430);
}

// ABS Label 1431
if(aRegIdx[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1431);
}
// ABS Label 1432
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1432);
}

// ABS Label 1433
if(aRegIdx[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1433);
}
// ABS Label 1434
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1434);
}

// AOR Label 1435
if(aRegIdx[i] - 1 != aRegIdx[i] + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1435);
}
// AOR Label 1436
if(aRegIdx[i] / 1 != aRegIdx[i] + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1436);
}
// AOR Label 1437
if(aRegIdx[i] * 1 != aRegIdx[i] + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1437);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iIdxCur+i, aRegIdx[i],
                         aRegIdx[i]+1,
                         pIdx->uniqNotNull ? pIdx->nKeyCol: pIdx->nColumn);
    
// ABS Label 1438
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1438);
}
sqlite3VdbeChangeP5(v, pik_flags);
  };
// ABS Label 1424
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1424);
}

  if( !HasRowid(pTab) ) { return;
}
  
// ABS Label 1453
if(pParse->nested < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1453);
}
if( pParse->nested ){
    pik_flags = 0;
  }else{
    pik_flags = OPFLAG_NCHANGE;
    pik_flags |= (update_flags?update_flags:OPFLAG_LASTROWID);
  }
  
// ABS Label 1454
if(appendBias < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1454);
}
if( appendBias ){
    pik_flags |= OPFLAG_APPEND;
  }
  
// ABS Label 1455
if(useSeekResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1455);
}
if( useSeekResult ){
    pik_flags |= OPFLAG_USESEEKRESULT;
  }
  
// ABS Label 1417
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1417);
}

// ABS Label 1418
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1418);
}

// ABS Label 1419
if(aRegIdx[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1419);
}
// ABS Label 1420
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1420);
}

// ABS Label 1421
if(regNewData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1421);
}
sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);
  if( !pParse->nested ){
    
// ABS Label 1456
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1456);
}
sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
  }
  
// ABS Label 1422
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1422);
}
sqlite3VdbeChangeP5(v, pik_flags);
}

/*
** Allocate cursors for the pTab table and all its indices and generate
** code to open and initialized those cursors.
**
** The cursor for the object that contains the complete data (normally
** the table itself, but the PRIMARY KEY index in the case of a WITHOUT
** ROWID table) is returned in *piDataCur.  The first index cursor is
** returned in *piIdxCur.  The number of indices is returned.
**
** Use iBase as the first cursor (either the *piDataCur for rowid tables
** or the first index for WITHOUT ROWID tables) if it is non-negative.
** If iBase is negative, then allocate the next available cursor.
**
** For a rowid table, *piDataCur will be exactly one less than *piIdxCur.
** For a WITHOUT ROWID table, *piDataCur will be somewhere in the range
** of *piIdxCurs, depending on where the PRIMARY KEY index appears on the
** pTab->pIndex list.
**
** If pTab is a virtual table, then this routine is a no-op and the
** *piDataCur and *piIdxCur values are left uninitialized.
*/
int sqlite3OpenTableAndIndices(
  Parse *pParse,   /* Parsing context */
  Table *pTab,     /* Table to be opened */
  int op,          /* OP_OpenRead or OP_OpenWrite */
  u8 p5,           /* P5 value for OP_Open* opcodes (except on WITHOUT ROWID) */
  int iBase,       /* Use this for the table cursor, if there is one */
  u8 *aToOpen,     /* If not NULL: boolean for each table and index */
  int *piDataCur,  /* Write the database source cursor number here */
  int *piIdxCur    /* Write the first index cursor number here */
){
  int i;
  int iDb;
  int iDataCur;
  Index *pIdx;
  Vdbe *v;

  assert( op==OP_OpenRead || op==OP_OpenWrite );
  assert( op==OP_OpenWrite || p5==0 );
  
// ABS Label 1457
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1457);
}
if( IsVirtual(pTab) ){
    /* This routine is a no-op for virtual tables. Leave the output
    ** variables *piDataCur and *piIdxCur uninitialized so that valgrind
    ** can detect if they are used by mistake in the caller. */
    return 0;
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  v = pParse->pVdbe;
  assert( v!=0 );
  
// ABS Label 1458
if(iBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1458);
}

// ROR Label 1459
if((iBase <= 0) != (iBase < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1459);
}
// ROR Label 1460
if((iBase > 0) != (iBase < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1460);
}
// ROR Label 1461
if((iBase >= 0) != (iBase < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1461);
}
if( iBase<0 ) { iBase = pParse->nTab;
}
  iDataCur = iBase++;
  
// ABS Label 1462
if(piDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1462);
}
if( piDataCur ) { *piDataCur = iDataCur;
}
  
// COR Label 1463
if(((((pTab)->tabFlags & 128) == 0) || (aToOpen == 0 || aToOpen[0])) != ((((pTab)->tabFlags & 128) == 0) && (aToOpen == 0 || aToOpen[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1463);
}

// MCC Label 1464
if(( ((pTab)->tabFlags & 128) == 0 ) && ( aToOpen == 0 && aToOpen[0] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1464);
}
// MCC Label 1465
if(( ((pTab)->tabFlags & 128) == 0 ) && ( aToOpen == 0 && !(aToOpen[0]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1465);
}
// MCC Label 1466
if(( ((pTab)->tabFlags & 128) == 0 ) && ( !(aToOpen == 0) && aToOpen[0] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1466);
}
// MCC Label 1467
if(( ((pTab)->tabFlags & 128) == 0 ) && ( !(aToOpen == 0) && !(aToOpen[0]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1467);
}
// MCC Label 1468
if(( !(((pTab)->tabFlags & 128) == 0) ) && ( aToOpen == 0 && aToOpen[0] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1468);
}
// MCC Label 1469
if(( !(((pTab)->tabFlags & 128) == 0) ) && ( aToOpen == 0 && !(aToOpen[0]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1469);
}
// MCC Label 1470
if(( !(((pTab)->tabFlags & 128) == 0) ) && ( !(aToOpen == 0) && aToOpen[0] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1470);
}
// MCC Label 1471
if(( !(((pTab)->tabFlags & 128) == 0) ) && ( !(aToOpen == 0) && !(aToOpen[0]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1471);
}
if( HasRowid(pTab) && (aToOpen==0 || aToOpen[0]) ){
    
// ABS Label 1472
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1472);
}

// ABS Label 1473
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1473);
}

// ABS Label 1474
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1474);
}

// ABS Label 1475
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1475);
}

// ABS Label 1476
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1476);
}
sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);
  }else{
    
// ABS Label 1477
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1477);
}

// ABS Label 1478
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1478);
}

// ABS Label 1479
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1479);
}
sqlite3TableLock(pParse, iDb, pTab->tnum, op==OP_OpenWrite, pTab->zName);
  }
  
// ABS Label 1480
if(piIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1480);
}
if( piIdxCur ) { *piIdxCur = iBase;
}
  i = 0 , pIdx = pTab->pIndex;

// ABS Label 1481
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1481);
}
for(; pIdx; pIdx=pIdx->pNext, i++){
    int iIdxCur = iBase++;
    assert( pIdx->pSchema==pTab->pSchema );
    
// COR Label 1483
if((((pIdx)->idxType == 2) || !(((pTab)->tabFlags & 128) == 0)) != (((pIdx)->idxType == 2) && !(((pTab)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1483);
}

// MCC Label 1484
if(( (pIdx)->idxType == 2 ) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1484);
}
// MCC Label 1485
if(( (pIdx)->idxType == 2 ) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1485);
}
// MCC Label 1486
if(( !((pIdx)->idxType == 2) ) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1486);
}
// MCC Label 1487
if(( !((pIdx)->idxType == 2) ) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1487);
}
if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){
      
// ABS Label 1488
if(piDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1488);
}
if( piDataCur ) { *piDataCur = iIdxCur;
}
      p5 = 0;
    }
    
// ABS Label 1489
if(aToOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1489);
}

// COR Label 1490
if((aToOpen == 0 && aToOpen[i + 1]) != (aToOpen == 0 || aToOpen[i + 1]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1490);
}

// ROR Label 1491
if((aToOpen != 0) != (aToOpen == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1491);
}

// MCC Label 1492
if(aToOpen == 0 && aToOpen[i + 1] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1492);
}
// MCC Label 1493
if(aToOpen == 0 && !(aToOpen[i + 1]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1493);
}
// MCC Label 1494
if(!(aToOpen == 0) && aToOpen[i + 1] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1494);
}
// MCC Label 1495
if(!(aToOpen == 0) && !(aToOpen[i + 1]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1495);
}
if( aToOpen==0 || aToOpen[i+1] ){
      
// ABS Label 1496
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1496);
}

// ABS Label 1497
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1497);
}

// ABS Label 1498
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1498);
}

// ABS Label 1499
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1499);
}
sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);
      
// ABS Label 1500
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1500);
}

// ABS Label 1501
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1501);
}
sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      
// ABS Label 1502
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1502);
}
sqlite3VdbeChangeP5(v, p5);
      VdbeComment((v, "%s", pIdx->zName));
    }
  };
// ABS Label 1482
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1482);
}

  
// ABS Label 1503
if(iBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1503);
}
// ABS Label 1504
if(pParse->nTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1504);
}

// ROR Label 1505
if((iBase <= pParse->nTab) != (iBase > pParse->nTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1505);
}
// ROR Label 1506
if((iBase < pParse->nTab) != (iBase > pParse->nTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1506);
}
// ROR Label 1507
if((iBase >= pParse->nTab) != (iBase > pParse->nTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1507);
}
if( iBase>pParse->nTab ) { pParse->nTab = iBase;
}
  
// ABS Label 1508
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1508);
}
return i;
}


#ifdef SQLITE_TEST
/*
** The following global variable is incremented whenever the
** transfer optimization is used.  This is used for testing
** purposes only - to make sure the transfer optimization really
** is happening when it is supposed to.
*/
int sqlite3_xferopt_count;
#endif /* SQLITE_TEST */


#ifndef SQLITE_OMIT_XFER_OPT
/*
** Check to see if index pSrc is compatible as a source of data
** for index pDest in an insert transfer optimization.  The rules
** for a compatible index:
**
**    *   The index is over the same set of columns
**    *   The same DESC and ASC markings occurs on all columns
**    *   The same onError processing (OE_Abort, OE_Ignore, etc)
**    *   The same collating sequence on each column
**    *   The index has the exact same WHERE clause
*/
static int xferCompatibleIndex(Index *pDest, Index *pSrc){
  int i;
  assert( pDest && pSrc );
  assert( pDest->pTable!=pSrc->pTable );
  
// COR Label 1509
if((pDest->nKeyCol != pSrc->nKeyCol && pDest->nColumn != pSrc->nColumn) != (pDest->nKeyCol != pSrc->nKeyCol || pDest->nColumn != pSrc->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1509);
}

// ROR Label 1510
if((pDest->nKeyCol == pSrc->nKeyCol) != (pDest->nKeyCol != pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1510);
}
// ROR Label 1511
if((pDest->nColumn == pSrc->nColumn) != (pDest->nColumn != pSrc->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1511);
}

// MCC Label 1512
if(pDest->nKeyCol != pSrc->nKeyCol && pDest->nColumn != pSrc->nColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1512);
}
// MCC Label 1513
if(pDest->nKeyCol != pSrc->nKeyCol && !(pDest->nColumn != pSrc->nColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1513);
}
// MCC Label 1514
if(!(pDest->nKeyCol != pSrc->nKeyCol) && pDest->nColumn != pSrc->nColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1514);
}
// MCC Label 1515
if(!(pDest->nKeyCol != pSrc->nKeyCol) && !(pDest->nColumn != pSrc->nColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1515);
}
if( pDest->nKeyCol!=pSrc->nKeyCol || pDest->nColumn!=pSrc->nColumn ){
    return 0;   /* Different number of columns */
  }
  
// ROR Label 1516
if((pDest->onError == pSrc->onError) != (pDest->onError != pSrc->onError))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1516);
}
if( pDest->onError!=pSrc->onError ){
    return 0;   /* Different conflict resolution strategies */
  }
  i = 0;

// ABS Label 1517
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1517);
}

// ROR Label 1518
if((i <= pSrc->nKeyCol) != (i < pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1518);
}
// ROR Label 1519
if((i > pSrc->nKeyCol) != (i < pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1519);
}
// ROR Label 1520
if((i >= pSrc->nKeyCol) != (i < pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1520);
}
for(; i<pSrc->nKeyCol; i++){
    
// ROR Label 1525
if((pSrc->aiColumn[i] == pDest->aiColumn[i]) != (pSrc->aiColumn[i] != pDest->aiColumn[i]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1525);
}
if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){
      return 0;   /* Different columns indexed */
    }
    
// ROR Label 1526
if((pSrc->aiColumn[i] != (-2)) != (pSrc->aiColumn[i] == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1526);
}
if( pSrc->aiColumn[i]==XN_EXPR ){
      assert( pSrc->aColExpr!=0 && pDest->aColExpr!=0 );
      if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,
                             pDest->aColExpr->a[i].pExpr, -1)!=0 ){
        return 0;   /* Different expressions in the index */
      }
    }
    
// ROR Label 1527
if((pSrc->aSortOrder[i] == pDest->aSortOrder[i]) != (pSrc->aSortOrder[i] != pDest->aSortOrder[i]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1527);
}
if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){
      return 0;   /* Different sort orders */
    }
    if( sqlite3_stricmp(pSrc->azColl[i],pDest->azColl[i])!=0 ){
      return 0;   /* Different collating sequences */
    }
  };
// ABS Label 1521
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1521);
}

// ROR Label 1522
if((i <= pSrc->nKeyCol) != (i < pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1522);
}
// ROR Label 1523
if((i > pSrc->nKeyCol) != (i < pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1523);
}
// ROR Label 1524
if((i >= pSrc->nKeyCol) != (i < pSrc->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1524);
}

  if( sqlite3ExprCompare(0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){
    return 0;     /* Different WHERE clauses */
  }

  /* If no test above fails then the indices must be compatible */
  return 1;
}

/*
** Attempt the transfer optimization on INSERTs of the form
**
**     INSERT INTO tab1 SELECT * FROM tab2;
**
** The xfer optimization transfers raw records from tab2 over to tab1.  
** Columns are not decoded and reassembled, which greatly improves
** performance.  Raw index records are transferred in the same way.
**
** The xfer optimization is only attempted if tab1 and tab2 are compatible.
** There are lots of rules for determining compatibility - see comments
** embedded in the code for details.
**
** This routine returns TRUE if the optimization is guaranteed to be used.
** Sometimes the xfer optimization will only work if the destination table
** is empty - a factor that can only be determined at run-time.  In that
** case, this routine generates code for the xfer optimization but also
** does a test to see if the destination table is empty and jumps over the
** xfer optimization code if the test fails.  In that case, this routine
** returns FALSE so that the caller will know to go ahead and generate
** an unoptimized transfer.  This routine also returns FALSE if there
** is no chance that the xfer optimization can be applied.
**
** This optimization is particularly useful at making VACUUM run faster.
*/
static int xferOptimization(
  Parse *pParse,        /* Parser context */
  Table *pDest,         /* The table we are inserting into */
  Select *pSelect,      /* A SELECT statement to use as the data source */
  int onError,          /* How to handle constraint errors */
  int iDbDest           /* The database of pDest */
){
  
// ABS Label 1528
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1528);
}
sqlite3 *db = pParse->db;
  ExprList *pEList;                /* The result set of the SELECT */
  Table *pSrc;                     /* The table in the FROM clause of SELECT */
  Index *pSrcIdx, *pDestIdx;       /* Source and destination indices */
  SrcItem *pItem;                  /* An element of pSelect->pSrc */
  int i;                           /* Loop counter */
  int iDbSrc;                      /* The database of pSrc */
  int iSrc, iDest;                 /* Cursors from source and destination */
  int addr1, addr2;                /* Loop addresses */
  int emptyDestTest = 0;           /* Address of test for empty pDest */
  int emptySrcTest = 0;            /* Address of test for empty pSrc */
  Vdbe *v;                         /* The VDBE we are building */
  int regAutoinc;                  /* Memory register used by AUTOINC */
  int destHasUniqueIdx = 0;        /* True if pDest has a UNIQUE index */
  int regData, regRowid;           /* Registers holding data and rowid */

  
// ABS Label 1541
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1541);
}

// ROR Label 1542
if((pSelect != 0) != (pSelect == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1542);
}
if( pSelect==0 ){
    return 0;   /* Must be of the form  INSERT INTO ... SELECT ... */
  }
  
// ABS Label 1543
if(pParse->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1543);
}
// ABS Label 1544
if(pSelect->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1544);
}

// COR Label 1545
if((pParse->pWith && pSelect->pWith) != (pParse->pWith || pSelect->pWith))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1545);
}

// MCC Label 1546
if(pParse->pWith && pSelect->pWith ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1546);
}
// MCC Label 1547
if(pParse->pWith && !(pSelect->pWith) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1547);
}
// MCC Label 1548
if(!(pParse->pWith) && pSelect->pWith ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1548);
}
// MCC Label 1549
if(!(pParse->pWith) && !(pSelect->pWith) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1549);
}
if( pParse->pWith || pSelect->pWith ){
    /* Do not attempt to process this query if there are an WITH clauses
    ** attached to it. Proceeding may generate a false "no such table: xxx"
    ** error if pSelect reads from a CTE named "xxx".  */
    return 0;
  }
  if( sqlite3TriggerList(pParse, pDest) ){
    return 0;   /* tab1 must not have triggers */
  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
  
// ABS Label 1550
if(((pDest)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1550);
}
if( IsVirtual(pDest) ){
    return 0;   /* tab1 must not be a virtual table */
  }
#endif
  
// ABS Label 1551
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1551);
}

// ROR Label 1552
if((onError != 11) != (onError == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1552);
}
if( onError==OE_Default ){
    
// ROR Label 1553
if((pDest->iPKey < 0) != (pDest->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1553);
}
// ROR Label 1554
if((pDest->iPKey > 0) != (pDest->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1554);
}
// ROR Label 1555
if((pDest->iPKey <= 0) != (pDest->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1555);
}
if( pDest->iPKey>=0 ) { onError = pDest->keyConf;
}
    
// ABS Label 1556
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1556);
}

// ROR Label 1557
if((onError != 11) != (onError == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1557);
}
if( onError==OE_Default ) { onError = OE_Abort;
}
  }
  assert(pSelect->pSrc);   /* allocated even if there is no FROM clause */
  
// ABS Label 1558
if(pSelect->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1558);
}

// ROR Label 1559
if((pSelect->pSrc->nSrc == 1) != (pSelect->pSrc->nSrc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1559);
}
if( pSelect->pSrc->nSrc!=1 ){
    return 0;   /* FROM clause must have exactly one term */
  }
  
// ABS Label 1560
if(pSelect->pSrc->a[0].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1560);
}
if( pSelect->pSrc->a[0].pSelect ){
    return 0;   /* FROM clause cannot contain a subquery */
  }
  
// ABS Label 1561
if(pSelect->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1561);
}
if( pSelect->pWhere ){
    return 0;   /* SELECT may not have a WHERE clause */
  }
  
// ABS Label 1562
if(pSelect->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1562);
}
if( pSelect->pOrderBy ){
    return 0;   /* SELECT may not have an ORDER BY clause */
  }
  /* Do not need to test for a HAVING clause.  If HAVING is present but
  ** there is no ORDER BY, we will get an error. */
  
// ABS Label 1563
if(pSelect->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1563);
}
if( pSelect->pGroupBy ){
    return 0;   /* SELECT may not have a GROUP BY clause */
  }
  
// ABS Label 1564
if(pSelect->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1564);
}
if( pSelect->pLimit ){
    return 0;   /* SELECT may not have a LIMIT clause */
  }
  
// ABS Label 1565
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1565);
}
if( pSelect->pPrior ){
    return 0;   /* SELECT may not be a compound query */
  }
  
// ABS Label 1566
if(pSelect->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1566);
}

// AOR Label 1567
if(pSelect->selFlags | 1 != pSelect->selFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1567);
}
// AOR Label 1568
if(pSelect->selFlags ^ 1 != pSelect->selFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1568);
}
if( pSelect->selFlags & SF_Distinct ){
    return 0;   /* SELECT may not be DISTINCT */
  }
  pEList = pSelect->pEList;
  assert( pEList!=0 );
  
// ABS Label 1569
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1569);
}

// ROR Label 1570
if((pEList->nExpr == 1) != (pEList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1570);
}
if( pEList->nExpr!=1 ){
    return 0;   /* The result set must have exactly one column */
  }
  assert( pEList->a[0].pExpr );
  
// ROR Label 1571
if((pEList->a[0].pExpr->op == 179) != (pEList->a[0].pExpr->op != 179))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1571);
}
if( pEList->a[0].pExpr->op!=TK_ASTERISK ){
    return 0;   /* The result set must be the special operator "*" */
  }

  /* At this point we have established that the statement is of the
  ** correct syntactic form to participate in this optimization.  Now
  ** we have to check the semantics.
  */
  pItem = pSelect->pSrc->a;
  pSrc = sqlite3LocateTableItem(pParse, 0, pItem);
  
// ABS Label 1572
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1572);
}

// ROR Label 1573
if((pSrc != 0) != (pSrc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1573);
}
if( pSrc==0 ){
    return 0;   /* FROM clause does not contain a real table */
  }
  
// ABS Label 1574
if(pDest->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1574);
}
// ABS Label 1575
if(pDest->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1575);
}
// ABS Label 1576
if(pSrc->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1576);
}
// ABS Label 1577
if(pSrc->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1577);
}

// COR Label 1578
if((pSrc->tnum == pDest->tnum || pSrc->pSchema == pDest->pSchema) != (pSrc->tnum == pDest->tnum && pSrc->pSchema == pDest->pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1578);
}

// ROR Label 1579
if((pSrc->tnum != pDest->tnum) != (pSrc->tnum == pDest->tnum))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1579);
}
// ROR Label 1580
if((pSrc->pSchema != pDest->pSchema) != (pSrc->pSchema == pDest->pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1580);
}

// MCC Label 1581
if(pSrc->tnum == pDest->tnum && pSrc->pSchema == pDest->pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1581);
}
// MCC Label 1582
if(pSrc->tnum == pDest->tnum && !(pSrc->pSchema == pDest->pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1582);
}
// MCC Label 1583
if(!(pSrc->tnum == pDest->tnum) && pSrc->pSchema == pDest->pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1583);
}
// MCC Label 1584
if(!(pSrc->tnum == pDest->tnum) && !(pSrc->pSchema == pDest->pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1584);
}
if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){
    testcase( pSrc!=pDest ); /* Possible due to bad sqlite_schema.rootpage */
    return 0;   /* tab1 and tab2 may not be the same table */
  }
  
// ROR Label 1585
if(((((pDest)->tabFlags & 128) == 0) == (((pSrc)->tabFlags & 128) == 0)) != ((((pDest)->tabFlags & 128) == 0) != (((pSrc)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1585);
}
if( HasRowid(pDest)!=HasRowid(pSrc) ){
    return 0;   /* source and destination must both be WITHOUT ROWID or not */
  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
  
// ABS Label 1586
if(((pSrc)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1586);
}
if( IsVirtual(pSrc) ){
    return 0;   /* tab2 must not be a virtual table */
  }
#endif
  
// ABS Label 1587
if(pSrc->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1587);
}
if( pSrc->pSelect ){
    return 0;   /* tab2 may not be a view */
  }
  
// ROR Label 1588
if((pDest->nCol == pSrc->nCol) != (pDest->nCol != pSrc->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1588);
}
if( pDest->nCol!=pSrc->nCol ){
    return 0;   /* Number of columns must be the same in tab1 and tab2 */
  }
  
// ROR Label 1589
if((pDest->iPKey == pSrc->iPKey) != (pDest->iPKey != pSrc->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1589);
}
if( pDest->iPKey!=pSrc->iPKey ){
    return 0;   /* Both tables must have the same INTEGER PRIMARY KEY */
  }
  i = 0;

// ABS Label 1590
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1590);
}

// ROR Label 1591
if((i <= pDest->nCol) != (i < pDest->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1591);
}
// ROR Label 1592
if((i > pDest->nCol) != (i < pDest->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1592);
}
// ROR Label 1593
if((i >= pDest->nCol) != (i < pDest->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1593);
}
for(; i<pDest->nCol; i++){
    Column *pDestCol = &pDest->aCol[i];
    Column *pSrcCol = &pSrc->aCol[i];
#ifdef SQLITE_ENABLE_HIDDEN_COLUMNS
    if( (db->mDbFlags & DBFLAG_Vacuum)==0 
     && (pDestCol->colFlags | pSrcCol->colFlags) & COLFLAG_HIDDEN 
    ){
      return 0;    /* Neither table may have __hidden__ columns */
    }
#endif
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
    /* Even if tables t1 and t2 have identical schemas, if they contain
    ** generated columns, then this statement is semantically incorrect:
    **
    **     INSERT INTO t2 SELECT * FROM t1;
    **
    ** The reason is that generated column values are returned by the
    ** the SELECT statement on the right but the INSERT statement on the
    ** left wants them to be omitted.
    **
    ** Nevertheless, this is a useful notational shorthand to tell SQLite
    ** to do a bulk transfer all of the content from t1 over to t2.
    ** 
    ** We could, in theory, disable this (except for internal use by the
    ** VACUUM command where it is actually needed).  But why do that?  It
    ** seems harmless enough, and provides a useful service.
    */
    
// ROR Label 1598
if(((pDestCol->colFlags & 96) == (pSrcCol->colFlags & 96)) != ((pDestCol->colFlags & 96) != (pSrcCol->colFlags & 96)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1598);
}
if( (pDestCol->colFlags & COLFLAG_GENERATED) !=
        (pSrcCol->colFlags & COLFLAG_GENERATED) ){
      return 0;    /* Both columns have the same generated-column type */
    }
    /* But the transfer is only allowed if both the source and destination
    ** tables have the exact same expressions for generated columns.
    ** This requirement could be relaxed for VIRTUAL columns, I suppose.
    */
    
// ROR Label 1599
if(((pDestCol->colFlags & 96) == 0) != ((pDestCol->colFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1599);
}
if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){
      if( sqlite3ExprCompare(0, pSrcCol->pDflt, pDestCol->pDflt, -1)!=0 ){
        testcase( pDestCol->colFlags & COLFLAG_VIRTUAL );
        testcase( pDestCol->colFlags & COLFLAG_STORED );
        return 0;  /* Different generator expressions */
      }
    }
#endif
    
// ROR Label 1600
if((pDestCol->affinity == pSrcCol->affinity) != (pDestCol->affinity != pSrcCol->affinity))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1600);
}
if( pDestCol->affinity!=pSrcCol->affinity ){
      return 0;    /* Affinity must be the same on all columns */
    }
    if( sqlite3_stricmp(pDestCol->zColl, pSrcCol->zColl)!=0 ){
      return 0;    /* Collating sequence must be the same on all columns */
    }
    
// COR Label 1601
if((pDestCol->notNull || !pSrcCol->notNull) != (pDestCol->notNull && !pSrcCol->notNull))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1601);
}

// MCC Label 1602
if(pDestCol->notNull && !pSrcCol->notNull ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1602);
}
// MCC Label 1603
if(pDestCol->notNull && !(!pSrcCol->notNull) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1603);
}
// MCC Label 1604
if(!(pDestCol->notNull) && !pSrcCol->notNull ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1604);
}
// MCC Label 1605
if(!(pDestCol->notNull) && !(!pSrcCol->notNull) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1605);
}
if( pDestCol->notNull && !pSrcCol->notNull ){
      return 0;    /* tab2 must be NOT NULL if tab1 is */
    }
    /* Default values for second and subsequent columns need to match. */
    
// ABS Label 1606
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1606);
}

// COR Label 1607
if(((pDestCol->colFlags & 96) == 0 || i > 0) != ((pDestCol->colFlags & 96) == 0 && i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1607);
}

// ROR Label 1608
if(((pDestCol->colFlags & 96) != 0) != ((pDestCol->colFlags & 96) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1608);
}
// ROR Label 1609
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1609);
}
// ROR Label 1610
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1610);
}
// ROR Label 1611
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1611);
}

// MCC Label 1612
if((pDestCol->colFlags & 96) == 0 && i > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1612);
}
// MCC Label 1613
if((pDestCol->colFlags & 96) == 0 && !(i > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1613);
}
// MCC Label 1614
if(!((pDestCol->colFlags & 96) == 0) && i > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1614);
}
// MCC Label 1615
if(!((pDestCol->colFlags & 96) == 0) && !(i > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1615);
}
if( (pDestCol->colFlags & COLFLAG_GENERATED)==0 && i>0 ){
      assert( pDestCol->pDflt==0 || pDestCol->pDflt->op==TK_SPAN );
      assert( pSrcCol->pDflt==0 || pSrcCol->pDflt->op==TK_SPAN );
      
// COR Label 1616
if(((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0) && (pDestCol->pDflt && strcmp(pDestCol->pDflt->u.zToken, pSrcCol->pDflt->u.zToken) != 0)) != ((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0) || (pDestCol->pDflt && strcmp(pDestCol->pDflt->u.zToken, pSrcCol->pDflt->u.zToken) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1616);
}

// ROR Label 1617
if(((pDestCol->pDflt == 0) == (pSrcCol->pDflt == 0)) != ((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1617);
}

// MCC Label 1618
if((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0) && ( pDestCol->pDflt && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1618);
}
// MCC Label 1619
if((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0) && ( !(pDestCol->pDflt) && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1619);
}
// MCC Label 1620
if(!((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0)) && ( pDestCol->pDflt && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1620);
}
// MCC Label 1621
if(!((pDestCol->pDflt == 0) != (pSrcCol->pDflt == 0)) && ( !(pDestCol->pDflt) && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1621);
}
if( (pDestCol->pDflt==0)!=(pSrcCol->pDflt==0) 
       || (pDestCol->pDflt && strcmp(pDestCol->pDflt->u.zToken,
                                       pSrcCol->pDflt->u.zToken)!=0)
      ){
        return 0;    /* Default values must be the same for all columns */
      }
    }
  };
// ABS Label 1594
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1594);
}

// ROR Label 1595
if((i <= pDest->nCol) != (i < pDest->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1595);
}
// ROR Label 1596
if((i > pDest->nCol) != (i < pDest->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1596);
}
// ROR Label 1597
if((i >= pDest->nCol) != (i < pDest->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1597);
}

  pDestIdx = pDest->pIndex;

// ABS Label 1622
if(pDestIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1622);
}
for(; pDestIdx; pDestIdx=pDestIdx->pNext){
    
// MCC Label 1624
if(( (pDestIdx)->onError != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1624);
}
// MCC Label 1625
if(( !((pDestIdx)->onError != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1625);
}
if( IsUniqueIndex(pDestIdx) ){
      destHasUniqueIdx = 1;
    }
    pSrcIdx = pSrc->pIndex;

// ABS Label 1626
if(pSrcIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1626);
}
for(; pSrcIdx; pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) { break;
}
    };
// ABS Label 1627
if(pSrcIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1627);
}

    
// ABS Label 1628
if(pSrcIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1628);
}

// ROR Label 1629
if((pSrcIdx != 0) != (pSrcIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1629);
}
if( pSrcIdx==0 ){
      return 0;    /* pDestIdx has no corresponding index in pSrc */
    }
    if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema
         && sqlite3FaultSim(411)==SQLITE_OK ){
      /* The sqlite3FaultSim() call allows this corruption test to be
      ** bypassed during testing, in order to exercise other corruption tests
      ** further downstream. */
      return 0;   /* Corrupt schema - two indexes on the same btree */
    }
  };
// ABS Label 1623
if(pDestIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1623);
}

#ifndef SQLITE_OMIT_CHECK
  if( pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1) ){
    return 0;   /* Tables have different CHECK constraints.  Ticket #2252 */
  }
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
  /* Disallow the transfer optimization if the destination table constains
  ** any foreign key constraints.  This is more restrictive than necessary.
  ** But the main beneficiary of the transfer optimization is the VACUUM 
  ** command, and the VACUUM command disables foreign key constraints.  So
  ** the extra complication to make this rule less restrictive is probably
  ** not worth the effort.  Ticket [6284df89debdfa61db8073e062908af0c9b6118e]
  */
  
// ABS Label 1630
if(pDest->pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1630);
}

// COR Label 1631
if(((db->flags & 16384) != 0 || pDest->pFKey != 0) != ((db->flags & 16384) != 0 && pDest->pFKey != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1631);
}

// ROR Label 1632
if(((db->flags & 16384) == 0) != ((db->flags & 16384) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1632);
}
// ROR Label 1633
if((pDest->pFKey == 0) != (pDest->pFKey != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1633);
}

// MCC Label 1634
if((db->flags & 16384) != 0 && pDest->pFKey != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1634);
}
// MCC Label 1635
if((db->flags & 16384) != 0 && !(pDest->pFKey != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1635);
}
// MCC Label 1636
if(!((db->flags & 16384) != 0) && pDest->pFKey != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1636);
}
// MCC Label 1637
if(!((db->flags & 16384) != 0) && !(pDest->pFKey != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1637);
}
if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->pFKey!=0 ){
    return 0;
  }
#endif
  
// ROR Label 1638
if(((db->flags & ((u64)(1) << 32)) == 0) != ((db->flags & ((u64)(1) << 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1638);
}
if( (db->flags & SQLITE_CountRows)!=0 ){
    return 0;  /* xfer opt does not play well with PRAGMA count_changes */
  }

  /* If we get this far, it means that the xfer optimization is at
  ** least a possibility, though it might only work if the destination
  ** table (tab1) is initially empty.
  */
#ifdef SQLITE_TEST
  sqlite3_xferopt_count++;
#endif
  iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 1529
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1529);
}

// ABS Label 1530
if(iDbSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1530);
}
sqlite3CodeVerifySchema(pParse, iDbSrc);
  iSrc = pParse->nTab++;
  iDest = pParse->nTab++;
  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);
  regData = sqlite3GetTempReg(pParse);
  
// ABS Label 1531
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1531);
}

// ABS Label 1532
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1532);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regData);
  regRowid = sqlite3GetTempReg(pParse);
  
// ABS Label 1533
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1533);
}

// ABS Label 1534
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1534);
}

// ABS Label 1535
if(iDbDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1535);
}

// ABS Label 1536
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1536);
}
sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);
  assert( HasRowid(pDest) || destHasUniqueIdx );
  
// COR Label 1639
if(((db->mDbFlags & 4) == 0 || ((pDest->iPKey < 0 && pDest->pIndex != 0) || destHasUniqueIdx || (onError != 2 && onError != 1))) != ((db->mDbFlags & 4) == 0 && ((pDest->iPKey < 0 && pDest->pIndex != 0) || destHasUniqueIdx || (onError != 2 && onError != 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1639);
}

// ROR Label 1640
if(((db->mDbFlags & 4) != 0) != ((db->mDbFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1640);
}

// MCC Label 1641
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1641);
}
// MCC Label 1642
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1642);
}
// MCC Label 1643
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1643);
}
// MCC Label 1644
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1644);
}
// MCC Label 1645
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1645);
}
// MCC Label 1646
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1646);
}
// MCC Label 1647
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1647);
}
// MCC Label 1648
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1648);
}
// MCC Label 1649
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1649);
}
// MCC Label 1650
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1650);
}
// MCC Label 1651
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1651);
}
// MCC Label 1652
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1652);
}
// MCC Label 1653
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1653);
}
// MCC Label 1654
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1654);
}
// MCC Label 1655
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1655);
}
// MCC Label 1656
if((db->mDbFlags & 4) == 0 && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1656);
}
// MCC Label 1657
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1657);
}
// MCC Label 1658
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1658);
}
// MCC Label 1659
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1659);
}
// MCC Label 1660
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1660);
}
// MCC Label 1661
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1661);
}
// MCC Label 1662
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1662);
}
// MCC Label 1663
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1663);
}
// MCC Label 1664
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1664);
}
// MCC Label 1665
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1665);
}
// MCC Label 1666
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1666);
}
// MCC Label 1667
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1667);
}
// MCC Label 1668
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1668);
}
// MCC Label 1669
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1669);
}
// MCC Label 1670
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1670);
}
// MCC Label 1671
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1671);
}
// MCC Label 1672
if((db->mDbFlags & 4) == 0 && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1672);
}
// MCC Label 1673
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1673);
}
// MCC Label 1674
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1674);
}
// MCC Label 1675
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1675);
}
// MCC Label 1676
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1676);
}
// MCC Label 1677
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1677);
}
// MCC Label 1678
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1678);
}
// MCC Label 1679
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1679);
}
// MCC Label 1680
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1680);
}
// MCC Label 1681
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1681);
}
// MCC Label 1682
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1682);
}
// MCC Label 1683
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1683);
}
// MCC Label 1684
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1684);
}
// MCC Label 1685
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1685);
}
// MCC Label 1686
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1686);
}
// MCC Label 1687
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1687);
}
// MCC Label 1688
if(!((db->mDbFlags & 4) == 0) && ( ( pDest->iPKey < 0 && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1688);
}
// MCC Label 1689
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1689);
}
// MCC Label 1690
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1690);
}
// MCC Label 1691
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1691);
}
// MCC Label 1692
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1692);
}
// MCC Label 1693
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1693);
}
// MCC Label 1694
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1694);
}
// MCC Label 1695
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1695);
}
// MCC Label 1696
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && pDest->pIndex != 0 ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1696);
}
// MCC Label 1697
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1697);
}
// MCC Label 1698
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1698);
}
// MCC Label 1699
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1699);
}
// MCC Label 1700
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && destHasUniqueIdx && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1700);
}
// MCC Label 1701
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1701);
}
// MCC Label 1702
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( onError != 2 && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1702);
}
// MCC Label 1703
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && onError != 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1703);
}
// MCC Label 1704
if(!((db->mDbFlags & 4) == 0) && ( ( !(pDest->iPKey < 0) && !(pDest->pIndex != 0) ) && !(destHasUniqueIdx) && ( !(onError != 2) && !(onError != 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1704);
}
if( (db->mDbFlags & DBFLAG_Vacuum)==0 && (
      (pDest->iPKey<0 && pDest->pIndex!=0)          /* (1) */
   || destHasUniqueIdx                              /* (2) */
   || (onError!=OE_Abort && onError!=OE_Rollback)   /* (3) */
  )){
    /* In some circumstances, we are able to run the xfer optimization
    ** only if the destination table is initially empty. Unless the
    ** DBFLAG_Vacuum flag is set, this block generates code to make
    ** that determination. If DBFLAG_Vacuum is set, then the destination
    ** table is always empty.
    **
    ** Conditions under which the destination must be empty:
    **
    ** (1) There is no INTEGER PRIMARY KEY but there are indices.
    **     (If the destination is not initially empty, the rowid fields
    **     of index entries might need to change.)
    **
    ** (2) The destination has a unique index.  (The xfer optimization 
    **     is unable to test uniqueness.)
    **
    ** (3) onError is something other than OE_Abort and OE_Rollback.
    */
    addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0); VdbeCoverage(v);
    emptyDestTest = sqlite3VdbeAddOp0(v, OP_Goto);
    
// ABS Label 1705
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1705);
}

// ABS Label 1706
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1706);
}
sqlite3VdbeJumpHere(v, addr1);
  }
  
// MCC Label 1707
if(( ((pSrc)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1707);
}
// MCC Label 1708
if(( !(((pSrc)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1708);
}
if( HasRowid(pSrc) ){
    u8 insFlags;
    
// ABS Label 1709
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1709);
}

// ABS Label 1710
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1710);
}

// ABS Label 1711
if(iDbSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1711);
}

// ABS Label 1712
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1712);
}
sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead);
    emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
    
// ROR Label 1725
if((pDest->iPKey < 0) != (pDest->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1725);
}
// ROR Label 1726
if((pDest->iPKey > 0) != (pDest->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1726);
}
// ROR Label 1727
if((pDest->iPKey <= 0) != (pDest->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1727);
}
if( pDest->iPKey>=0 ){
      addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);
      
// ROR Label 1731
if(((db->mDbFlags & 4) != 0) != ((db->mDbFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1731);
}
if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){
        sqlite3VdbeVerifyAbortable(v, onError);
        addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);
        VdbeCoverage(v);
        
// ABS Label 1732
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1732);
}

// ABS Label 1733
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1733);
}

// ABS Label 1734
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1734);
}
sqlite3RowidConstraint(pParse, onError, pDest);
        
// ABS Label 1735
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1735);
}

// ABS Label 1736
if(addr2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1736);
}
sqlite3VdbeJumpHere(v, addr2);
      }
      
// ABS Label 1728
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1728);
}

// ABS Label 1729
if(regAutoinc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1729);
}

// ABS Label 1730
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1730);
}
autoIncStep(pParse, regAutoinc, regRowid);
    }else { 
// ABS Label 1737
if(pDest->pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1737);
}

// COR Label 1738
if((pDest->pIndex == 0 || !(db->mDbFlags & 8)) != (pDest->pIndex == 0 && !(db->mDbFlags & 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1738);
}

// ROR Label 1739
if((pDest->pIndex != 0) != (pDest->pIndex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1739);
}

// MCC Label 1740
if(pDest->pIndex == 0 && !(db->mDbFlags & 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1740);
}
// MCC Label 1741
if(pDest->pIndex == 0 && !(!(db->mDbFlags & 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1741);
}
// MCC Label 1742
if(!(pDest->pIndex == 0) && !(db->mDbFlags & 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1742);
}
// MCC Label 1743
if(!(pDest->pIndex == 0) && !(!(db->mDbFlags & 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1743);
}
if( pDest->pIndex==0 && !(db->mDbFlags & DBFLAG_VacuumInto) ){
      addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid);
    }else{
      addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);
      assert( (pDest->tabFlags & TF_Autoincrement)==0 );
    };}


    
// ABS Label 1744
if(db->mDbFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1744);
}

// AOR Label 1745
if(db->mDbFlags | 4 != db->mDbFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1745);
}
// AOR Label 1746
if(db->mDbFlags ^ 4 != db->mDbFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1746);
}
if( db->mDbFlags & DBFLAG_Vacuum ){
      
// ABS Label 1747
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1747);
}

// ABS Label 1748
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1748);
}
sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);
      insFlags = OPFLAG_APPEND|OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;
    }else{
      insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND|OPFLAG_PREFORMAT;
    }
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
    if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){
      sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);
      insFlags &= ~OPFLAG_PREFORMAT;
    }else
#endif
    {
      
// ABS Label 1749
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1749);
}

// ABS Label 1750
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1750);
}

// ABS Label 1751
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1751);
}

// ABS Label 1752
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1752);
}
sqlite3VdbeAddOp3(v, OP_RowCell, iDest, iSrc, regRowid);
    }
    
// ABS Label 1713
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1713);
}

// ABS Label 1714
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1714);
}

// ABS Label 1715
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1715);
}

// ABS Label 1716
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1716);
}
sqlite3VdbeAddOp3(v, OP_Insert, iDest, regData, regRowid);
    
// ROR Label 1753
if(((db->mDbFlags & 4) != 0) != ((db->mDbFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1753);
}
if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){
      
// ABS Label 1754
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1754);
}
sqlite3VdbeChangeP4(v, -1, (char*)pDest, P4_TABLE);
    }
    
// ABS Label 1717
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1717);
}
sqlite3VdbeChangeP5(v, insFlags);

    
// ABS Label 1718
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1718);
}

// ABS Label 1719
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1719);
}

// ABS Label 1720
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1720);
}
sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1); VdbeCoverage(v);
    
// ABS Label 1721
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1721);
}

// ABS Label 1722
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1722);
}
sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
    
// ABS Label 1723
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1723);
}

// ABS Label 1724
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1724);
}
sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);
  }else{
    
// ABS Label 1755
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1755);
}

// ABS Label 1756
if(iDbDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1756);
}

// ABS Label 1757
if(pDest->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1757);
}
sqlite3TableLock(pParse, iDbDest, pDest->tnum, 1, pDest->zName);
    
// ABS Label 1758
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1758);
}

// ABS Label 1759
if(iDbSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1759);
}

// ABS Label 1760
if(pSrc->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1760);
}
sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);
  }
  pDestIdx = pDest->pIndex;

// ABS Label 1761
if(pDestIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1761);
}
for(; pDestIdx; pDestIdx=pDestIdx->pNext){
    u8 idxInsFlags = 0;
    pSrcIdx = pSrc->pIndex;

// ABS Label 1790
if((pSrcIdx) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1790);
}
for(; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) { break;
}
    };
// ABS Label 1791
if((pSrcIdx) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1791);
}

    assert( pSrcIdx );
    
// ABS Label 1763
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1763);
}

// ABS Label 1764
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1764);
}

// ABS Label 1765
if(iDbSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1765);
}
sqlite3VdbeAddOp3(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc);
    
// ABS Label 1766
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1766);
}

// ABS Label 1767
if(pSrcIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1767);
}
sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
    VdbeComment((v, "%s", pSrcIdx->zName));
    
// ABS Label 1768
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1768);
}

// ABS Label 1769
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1769);
}

// ABS Label 1770
if(iDbDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1770);
}
sqlite3VdbeAddOp3(v, OP_OpenWrite, iDest, pDestIdx->tnum, iDbDest);
    
// ABS Label 1771
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1771);
}

// ABS Label 1772
if(pDestIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1772);
}
sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
    
// ABS Label 1773
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1773);
}
sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR);
    VdbeComment((v, "%s", pDestIdx->zName));
    addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);
    
// ABS Label 1792
if(db->mDbFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1792);
}

// AOR Label 1793
if(db->mDbFlags | 4 != db->mDbFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1793);
}
// AOR Label 1794
if(db->mDbFlags ^ 4 != db->mDbFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1794);
}
if( db->mDbFlags & DBFLAG_Vacuum ){
      /* This INSERT command is part of a VACUUM operation, which guarantees
      ** that the destination table is empty. If all indexed columns use
      ** collation sequence BINARY, then it can also be assumed that the
      ** index will be populated by inserting keys in strictly sorted 
      ** order. In this case, instead of seeking within the b-tree as part
      ** of every OP_IdxInsert opcode, an OP_SeekEnd is added before the
      ** OP_IdxInsert to seek to the point within the b-tree where each key 
      ** should be inserted. This is faster.
      **
      ** If any of the indexed columns use a collation sequence other than
      ** BINARY, this optimization is disabled. This is because the user 
      ** might change the definition of a collation sequence and then run
      ** a VACUUM command. In that case keys may not be written in strictly
      ** sorted order.  */
      i = 0;

// ABS Label 1795
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1795);
}

// ROR Label 1796
if((i <= pSrcIdx->nColumn) != (i < pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1796);
}
// ROR Label 1797
if((i > pSrcIdx->nColumn) != (i < pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1797);
}
// ROR Label 1798
if((i >= pSrcIdx->nColumn) != (i < pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1798);
}
for(; i<pSrcIdx->nColumn; i++){
        
// ABS Label 1803
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1803);
}
// ABS Label 1804
if(pSrcIdx->azColl[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1804);
}
const char *zColl = pSrcIdx->azColl[i];
        if( sqlite3_stricmp(sqlite3StrBINARY, zColl) ) { break;
}
      };
// ABS Label 1799
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1799);
}

// ROR Label 1800
if((i <= pSrcIdx->nColumn) != (i < pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1800);
}
// ROR Label 1801
if((i > pSrcIdx->nColumn) != (i < pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1801);
}
// ROR Label 1802
if((i >= pSrcIdx->nColumn) != (i < pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1802);
}

      
// ABS Label 1805
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1805);
}

// ROR Label 1806
if((i != pSrcIdx->nColumn) != (i == pSrcIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1806);
}
if( i==pSrcIdx->nColumn ){
        idxInsFlags = OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;
        
// ABS Label 1807
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1807);
}

// ABS Label 1808
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1808);
}
sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);
        
// ABS Label 1809
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1809);
}

// ABS Label 1810
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1810);
}

// ABS Label 1811
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1811);
}
sqlite3VdbeAddOp2(v, OP_RowCell, iDest, iSrc);
      }
    }else { 
// COR Label 1812
if((!(((pSrc)->tabFlags & 128) == 0) || pDestIdx->idxType == 2) != (!(((pSrc)->tabFlags & 128) == 0) && pDestIdx->idxType == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1812);
}

// ROR Label 1813
if((pDestIdx->idxType != 2) != (pDestIdx->idxType == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1813);
}

// MCC Label 1814
if(!(((pSrc)->tabFlags & 128) == 0) && pDestIdx->idxType == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1814);
}
// MCC Label 1815
if(!(((pSrc)->tabFlags & 128) == 0) && !(pDestIdx->idxType == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1815);
}
// MCC Label 1816
if(!(!(((pSrc)->tabFlags & 128) == 0)) && pDestIdx->idxType == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1816);
}
// MCC Label 1817
if(!(!(((pSrc)->tabFlags & 128) == 0)) && !(pDestIdx->idxType == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1817);
}
if( !HasRowid(pSrc) && pDestIdx->idxType==SQLITE_IDXTYPE_PRIMARYKEY ){
      idxInsFlags |= OPFLAG_NCHANGE;
    };}

    
// ROR Label 1818
if((idxInsFlags == (16 | 128)) != (idxInsFlags != (16 | 128)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1818);
}
if( idxInsFlags!=(OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT) ){
      
// ABS Label 1819
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1819);
}

// ABS Label 1820
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1820);
}

// ABS Label 1821
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1821);
}
sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);
      
// COR Label 1822
if(((db->mDbFlags & 4) == 0 && !(((pDest)->tabFlags & 128) == 0) || ((pDestIdx)->idxType == 2)) != ((db->mDbFlags & 4) == 0 && !(((pDest)->tabFlags & 128) == 0) && ((pDestIdx)->idxType == 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1822);
}
// COR Label 1823
if(((db->mDbFlags & 4) == 0 || !(((pDest)->tabFlags & 128) == 0)) != ((db->mDbFlags & 4) == 0 && !(((pDest)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1823);
}

// ROR Label 1824
if(((db->mDbFlags & 4) != 0) != ((db->mDbFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1824);
}

// MCC Label 1825
if((db->mDbFlags & 4) == 0 && !(((pDest)->tabFlags & 128) == 0) && ( (pDestIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1825);
}
// MCC Label 1826
if((db->mDbFlags & 4) == 0 && !(((pDest)->tabFlags & 128) == 0) && ( !((pDestIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1826);
}
// MCC Label 1827
if((db->mDbFlags & 4) == 0 && !(!(((pDest)->tabFlags & 128) == 0)) && ( (pDestIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1827);
}
// MCC Label 1828
if((db->mDbFlags & 4) == 0 && !(!(((pDest)->tabFlags & 128) == 0)) && ( !((pDestIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1828);
}
// MCC Label 1829
if(!((db->mDbFlags & 4) == 0) && !(((pDest)->tabFlags & 128) == 0) && ( (pDestIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1829);
}
// MCC Label 1830
if(!((db->mDbFlags & 4) == 0) && !(((pDest)->tabFlags & 128) == 0) && ( !((pDestIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1830);
}
// MCC Label 1831
if(!((db->mDbFlags & 4) == 0) && !(!(((pDest)->tabFlags & 128) == 0)) && ( (pDestIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1831);
}
// MCC Label 1832
if(!((db->mDbFlags & 4) == 0) && !(!(((pDest)->tabFlags & 128) == 0)) && ( !((pDestIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1832);
}
if( (db->mDbFlags & DBFLAG_Vacuum)==0 
       && !HasRowid(pDest) 
       && IsPrimaryKeyIndex(pDestIdx) 
      ){
        codeWithoutRowidPreupdate(pParse, pDest, iDest, regData);
      }
    }
    
// ABS Label 1774
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1774);
}

// ABS Label 1775
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1775);
}

// ABS Label 1776
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1776);
}
sqlite3VdbeAddOp2(v, OP_IdxInsert, iDest, regData);
    
// ABS Label 1777
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1777);
}
sqlite3VdbeChangeP5(v, idxInsFlags|OPFLAG_APPEND);
    
// ABS Label 1778
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1778);
}

// ABS Label 1779
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1779);
}

// ABS Label 1780
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1780);
}

// AOR Label 1781
if(addr1 - 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1781);
}
// AOR Label 1782
if(addr1 / 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1782);
}
// AOR Label 1783
if(addr1 * 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1783);
}
sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1); VdbeCoverage(v);
    
// ABS Label 1784
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1784);
}

// ABS Label 1785
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1785);
}
sqlite3VdbeJumpHere(v, addr1);
    
// ABS Label 1786
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1786);
}

// ABS Label 1787
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1787);
}
sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);
    
// ABS Label 1788
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1788);
}

// ABS Label 1789
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1789);
}
sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);
  };
// ABS Label 1762
if(pDestIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1762);
}

  
// ABS Label 1833
if(emptySrcTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1833);
}
if( emptySrcTest ) { 
// ABS Label 1834
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1834);
}

// ABS Label 1835
if(emptySrcTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1835);
}
sqlite3VdbeJumpHere(v, emptySrcTest);
}
  
// ABS Label 1537
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1537);
}

// ABS Label 1538
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1538);
}
sqlite3ReleaseTempReg(pParse, regRowid);
  
// ABS Label 1539
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1539);
}

// ABS Label 1540
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1540);
}
sqlite3ReleaseTempReg(pParse, regData);
  
// ABS Label 1836
if(emptyDestTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1836);
}
if( emptyDestTest ){
    
// ABS Label 1837
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1837);
}
sqlite3AutoincrementEnd(pParse);
    
// ABS Label 1838
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1838);
}
sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, 0);
    
// ABS Label 1839
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1839);
}

// ABS Label 1840
if(emptyDestTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1840);
}
sqlite3VdbeJumpHere(v, emptyDestTest);
    
// ABS Label 1841
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1841);
}

// ABS Label 1842
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1842);
}
sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);
    return 0;
  }else{
    return 1;
  }
}
#endif /* SQLITE_OMIT_XFER_OPT */
