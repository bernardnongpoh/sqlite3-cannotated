/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2018 May 08
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/
#include "sqliteInt.h"

#ifndef SQLITE_OMIT_WINDOWFUNC

/*
** SELECT REWRITING
**
**   Any SELECT statement that contains one or more window functions in
**   either the select list or ORDER BY clause (the only two places window
**   functions may be used) is transformed by function sqlite3WindowRewrite()
**   in order to support window function processing. For example, with the
**   schema:
**
**     CREATE TABLE t1(a, b, c, d, e, f, g);
**
**   the statement:
**
**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM t1 ORDER BY e;
**
**   is transformed to:
**
**     SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM (
**         SELECT a, e, c, d, b FROM t1 ORDER BY c, d
**     ) ORDER BY e;
**
**   The flattening optimization is disabled when processing this transformed
**   SELECT statement. This allows the implementation of the window function
**   (in this case max()) to process rows sorted in order of (c, d), which
**   makes things easier for obvious reasons. More generally:
**
**     * FROM, WHERE, GROUP BY and HAVING clauses are all moved to 
**       the sub-query.
**
**     * ORDER BY, LIMIT and OFFSET remain part of the parent query.
**
**     * Terminals from each of the expression trees that make up the 
**       select-list and ORDER BY expressions in the parent query are
**       selected by the sub-query. For the purposes of the transformation,
**       terminals are column references and aggregate functions.
**
**   If there is more than one window function in the SELECT that uses
**   the same window declaration (the OVER bit), then a single scan may
**   be used to process more than one window function. For example:
**
**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), 
**            min(e) OVER (PARTITION BY c ORDER BY d) 
**     FROM t1;
**
**   is transformed in the same way as the example above. However:
**
**     SELECT max(b) OVER (PARTITION BY c ORDER BY d), 
**            min(e) OVER (PARTITION BY a ORDER BY b) 
**     FROM t1;
**
**   Must be transformed to:
**
**     SELECT max(b) OVER (PARTITION BY c ORDER BY d) FROM (
**         SELECT e, min(e) OVER (PARTITION BY a ORDER BY b), c, d, b FROM
**           SELECT a, e, c, d, b FROM t1 ORDER BY a, b
**         ) ORDER BY c, d
**     ) ORDER BY e;
**
**   so that both min() and max() may process rows in the order defined by
**   their respective window declarations.
**
** INTERFACE WITH SELECT.C
**
**   When processing the rewritten SELECT statement, code in select.c calls
**   sqlite3WhereBegin() to begin iterating through the results of the
**   sub-query, which is always implemented as a co-routine. It then calls
**   sqlite3WindowCodeStep() to process rows and finish the scan by calling
**   sqlite3WhereEnd().
**
**   sqlite3WindowCodeStep() generates VM code so that, for each row returned
**   by the sub-query a sub-routine (OP_Gosub) coded by select.c is invoked.
**   When the sub-routine is invoked:
**
**     * The results of all window-functions for the row are stored
**       in the associated Window.regResult registers.
**
**     * The required terminal values are stored in the current row of
**       temp table Window.iEphCsr.
**
**   In some cases, depending on the window frame and the specific window
**   functions invoked, sqlite3WindowCodeStep() caches each entire partition
**   in a temp table before returning any rows. In other cases it does not.
**   This detail is encapsulated within this file, the code generated by
**   select.c is the same in either case.
**
** BUILT-IN WINDOW FUNCTIONS
**
**   This implementation features the following built-in window functions:
**
**     row_number()
**     rank()
**     dense_rank()
**     percent_rank()
**     cume_dist()
**     ntile(N)
**     lead(expr [, offset [, default]])
**     lag(expr [, offset [, default]])
**     first_value(expr)
**     last_value(expr)
**     nth_value(expr, N)
**   
**   These are the same built-in window functions supported by Postgres. 
**   Although the behaviour of aggregate window functions (functions that
**   can be used as either aggregates or window funtions) allows them to
**   be implemented using an API, built-in window functions are much more
**   esoteric. Additionally, some window functions (e.g. nth_value()) 
**   may only be implemented by caching the entire partition in memory.
**   As such, some built-in window functions use the same API as aggregate
**   window functions and some are implemented directly using VDBE 
**   instructions. Additionally, for those functions that use the API, the
**   window frame is sometimes modified before the SELECT statement is
**   rewritten. For example, regardless of the specified window frame, the
**   row_number() function always uses:
**
**     ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
**
**   See sqlite3WindowUpdate() for details.
**
**   As well as some of the built-in window functions, aggregate window
**   functions min() and max() are implemented using VDBE instructions if
**   the start of the window frame is declared as anything other than 
**   UNBOUNDED PRECEDING.
*/

/*
** Implementation of built-in window function row_number(). Assumes that the
** window frame has been coerced to:
**
**   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
*/
static void row_numberStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 7
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
if( p ) { (*p)++;
}
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}
static void row_numberValueFunc(sqlite3_context *pCtx){
  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 8
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3_result_int64(pCtx, (p ? *p : 0));
}

/*
** Context object type used by rank(), dense_rank(), percent_rank() and
** cume_dist().
*/
struct CallCount {
  i64 nValue;
  i64 nStep;
  i64 nTotal;
};

/*
** Implementation of built-in window function dense_rank(). Assumes that
** the window frame has been set to:
**
**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 
*/
static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 9
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
if( p ) { p->nStep = 1;
}
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}
static void dense_rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 10
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
if( p ){
    
// ABS Label 13
if(p->nStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
if( p->nStep ){
      p->nValue++;
      p->nStep = 0;
    }
    
// ABS Label 11
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ABS Label 12
if(p->nValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3_result_int64(pCtx, p->nValue);
  }
}

/*
** Implementation of built-in window function nth_value(). This
** implementation is used in "slow mode" only - when the EXCLUDE clause
** is not set to the default value "NO OTHERS".
*/
struct NthValueCtx {
  i64 nStep;
  sqlite3_value *pValue;
};
static void nth_valueStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 14
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
if( p ){
    i64 iVal;
    switch( sqlite3_value_numeric_type(apArg[1]) ){
      case SQLITE_INTEGER:
        iVal = sqlite3_value_int64(apArg[1]);
        break;
      case SQLITE_FLOAT: {
        double fVal = sqlite3_value_double(apArg[1]);
        
// ABS Label 15
if(fVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}

// ROR Label 16
if((((i64)fVal) == fVal) != (((i64)fVal) != fVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
if( ((i64)fVal)!=fVal ) { goto error_out;
}
        iVal = (i64)fVal;
        break;
      }
      default:
        goto error_out;
    }
    
// ABS Label 17
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// ROR Label 18
if((iVal < 0) != (iVal <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
// ROR Label 19
if((iVal > 0) != (iVal <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if((iVal >= 0) != (iVal <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}
if( iVal<=0 ) { goto error_out;
}

    p->nStep++;
    
// ABS Label 21
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
// ABS Label 22
if(p->nStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ROR Label 23
if((iVal != p->nStep) != (iVal == p->nStep))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
if( iVal==p->nStep ){
      p->pValue = sqlite3_value_dup(apArg[0]);
      if( !p->pValue ){
        
// ABS Label 24
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
sqlite3_result_error_nomem(pCtx);
      }
    }
  }
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
  return;

 error_out:
  sqlite3_result_error(
      pCtx, "second argument to nth_value must be a positive integer", -1
  );
}
static void nth_valueFinalizeFunc(sqlite3_context *pCtx){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);
  
// ABS Label 25
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
// ABS Label 26
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// COR Label 27
if((p || p->pValue) != (p && p->pValue))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 27);
}

// MCC Label 28
if(p && p->pValue ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
// MCC Label 29
if(p && !(p->pValue) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 29);
}
// MCC Label 30
if(!(p) && p->pValue ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 30);
}
// MCC Label 31
if(!(p) && !(p->pValue) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 31);
}
if( p && p->pValue ){
    
// ABS Label 32
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}

// ABS Label 33
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3_result_value(pCtx, p->pValue);
    
// ABS Label 34
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
sqlite3_value_free(p->pValue);
    p->pValue = 0;
  }
}
#define nth_valueInvFunc noopStepFunc
#define nth_valueValueFunc noopValueFunc

static void first_valueStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 35
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
// ABS Label 36
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// COR Label 37
if((p || p->pValue == 0) != (p && p->pValue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 37);
}

// ROR Label 38
if((p->pValue != 0) != (p->pValue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}

// MCC Label 39
if(p && p->pValue == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 39);
}
// MCC Label 40
if(p && !(p->pValue == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(!(p) && p->pValue == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(!(p) && !(p->pValue == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
if( p && p->pValue==0 ){
    p->pValue = sqlite3_value_dup(apArg[0]);
    if( !p->pValue ){
      
// ABS Label 43
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}
sqlite3_result_error_nomem(pCtx);
    }
  }
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}
static void first_valueFinalizeFunc(sqlite3_context *pCtx){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 44
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}
// ABS Label 45
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// COR Label 46
if((p || p->pValue) != (p && p->pValue))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 46);
}

// MCC Label 47
if(p && p->pValue ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if(p && !(p->pValue) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
// MCC Label 49
if(!(p) && p->pValue ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 49);
}
// MCC Label 50
if(!(p) && !(p->pValue) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 50);
}
if( p && p->pValue ){
    
// ABS Label 51
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// ABS Label 52
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
sqlite3_result_value(pCtx, p->pValue);
    
// ABS Label 53
if(p->pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
sqlite3_value_free(p->pValue);
    p->pValue = 0;
  }
}
#define first_valueInvFunc noopStepFunc
#define first_valueValueFunc noopValueFunc

/*
** Implementation of built-in window function rank(). Assumes that
** the window frame has been set to:
**
**   RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 
*/
static void rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 54
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}
if( p ){
    p->nStep++;
    
// ABS Label 55
if(p->nValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}

// ROR Label 56
if((p->nValue != 0) != (p->nValue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
if( p->nValue==0 ){
      p->nValue = p->nStep;
    }
  }
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}
static void rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 57
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
if( p ){
    
// ABS Label 58
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}

// ABS Label 59
if(p->nValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
sqlite3_result_int64(pCtx, p->nValue);
    p->nValue = 0;
  }
}

/*
** Implementation of built-in window function percent_rank(). Assumes that
** the window frame has been set to:
**
**   GROUPS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
*/
static void percent_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  UNUSED_PARAMETER(nArg); assert( nArg==0 );
  UNUSED_PARAMETER(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 60
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
if( p ){
    p->nTotal++;
  }
}
static void percent_rankInvFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  UNUSED_PARAMETER(nArg); assert( nArg==0 );
  UNUSED_PARAMETER(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->nStep++;
}
static void percent_rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 61
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
if( p ){
    p->nValue = p->nStep;
    
// ABS Label 62
if(p->nTotal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// ROR Label 63
if((p->nTotal <= 1) != (p->nTotal > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((p->nTotal < 1) != (p->nTotal > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((p->nTotal >= 1) != (p->nTotal > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
if( p->nTotal>1 ){
      
// AOR Label 66
if((double)p->nValue - (double)(p->nTotal - 1) != (double)p->nValue / (double)(p->nTotal - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 66);
}
// AOR Label 67
if((double)p->nValue + (double)(p->nTotal - 1) != (double)p->nValue / (double)(p->nTotal - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 67);
}
// AOR Label 68
if((double)p->nValue * (double)(p->nTotal - 1) != (double)p->nValue / (double)(p->nTotal - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 68);
}
double r = (double)p->nValue / (double)(p->nTotal-1);
      
// ABS Label 69
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}

// ABS Label 70
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}
sqlite3_result_double(pCtx, r);
    }else{
      
// ABS Label 71
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}
sqlite3_result_double(pCtx, 0.0);
    }
  }
}
#define percent_rankFinalizeFunc percent_rankValueFunc

/*
** Implementation of built-in window function cume_dist(). Assumes that
** the window frame has been set to:
**
**   GROUPS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING
*/
static void cume_distStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  UNUSED_PARAMETER(nArg); assert( nArg==0 );
  UNUSED_PARAMETER(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 72
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
if( p ){
    p->nTotal++;
  }
}
static void cume_distInvFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  UNUSED_PARAMETER(nArg); assert( nArg==0 );
  UNUSED_PARAMETER(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->nStep++;
}
static void cume_distValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);
  
// ABS Label 73
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
if( p ){
    
// AOR Label 74
if((double)(p->nStep) - (double)(p->nTotal) != (double)(p->nStep) / (double)(p->nTotal))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 74);
}
// AOR Label 75
if((double)(p->nStep) + (double)(p->nTotal) != (double)(p->nStep) / (double)(p->nTotal))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 75);
}
// AOR Label 76
if((double)(p->nStep) * (double)(p->nTotal) != (double)(p->nStep) / (double)(p->nTotal))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 76);
}
double r = (double)(p->nStep) / (double)(p->nTotal);
    
// ABS Label 77
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ABS Label 78
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
sqlite3_result_double(pCtx, r);
  }
}
#define cume_distFinalizeFunc cume_distValueFunc

/*
** Context object for ntile() window function.
*/
struct NtileCtx {
  i64 nTotal;                     /* Total rows in partition */
  i64 nParam;                     /* Parameter passed to ntile(N) */
  i64 iRow;                       /* Current row */
};

/*
** Implementation of ntile(). This assumes that the window frame has
** been coerced to:
**
**   ROWS CURRENT ROW AND UNBOUNDED FOLLOWING
*/
static void ntileStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct NtileCtx *p;
  assert( nArg==1 ); UNUSED_PARAMETER(nArg);
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 79
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}
if( p ){
    
// ABS Label 80
if(p->nTotal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}

// ROR Label 81
if((p->nTotal != 0) != (p->nTotal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
if( p->nTotal==0 ){
      p->nParam = sqlite3_value_int64(apArg[0]);
      
// ABS Label 82
if(p->nParam < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}

// ROR Label 83
if((p->nParam < 0) != (p->nParam <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
// ROR Label 84
if((p->nParam > 0) != (p->nParam <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 84);
}
// ROR Label 85
if((p->nParam >= 0) != (p->nParam <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}
if( p->nParam<=0 ){
        
// ABS Label 86
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
sqlite3_result_error(
            pCtx, "argument of ntile must be a positive integer", -1
        );
      }
    }
    p->nTotal++;
  }
}
static void ntileInvFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct NtileCtx *p;
  assert( nArg==1 ); UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->iRow++;
}
static void ntileValueFunc(sqlite3_context *pCtx){
  struct NtileCtx *p;
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 87
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
// ABS Label 88
if(p->nParam < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// COR Label 89
if((p || p->nParam > 0) != (p && p->nParam > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 89);
}

// ROR Label 90
if((p->nParam <= 0) != (p->nParam > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
// ROR Label 91
if((p->nParam < 0) != (p->nParam > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((p->nParam >= 0) != (p->nParam > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}

// MCC Label 93
if(p && p->nParam > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 93);
}
// MCC Label 94
if(p && !(p->nParam > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(!(p) && p->nParam > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(!(p) && !(p->nParam > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
if( p && p->nParam>0 ){
    int nSize = (p->nTotal / p->nParam);
    
// ABS Label 97
if(nSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// ROR Label 98
if((nSize != 0) != (nSize == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
if( nSize==0 ){
      
// ABS Label 99
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}

// ABS Label 100
if(p->iRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}

// AOR Label 101
if(p->iRow - 1 != p->iRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 101);
}
// AOR Label 102
if(p->iRow / 1 != p->iRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 102);
}
// AOR Label 103
if(p->iRow * 1 != p->iRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 103);
}
sqlite3_result_int64(pCtx, p->iRow+1);
    }else{
      
// ABS Label 104
if(p->nParam < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
// ABS Label 105
if(p->nTotal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// AOR Label 106
if(p->nTotal / p->nParam * nSize != p->nTotal - p->nParam * nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 106);
}
// AOR Label 107
if(p->nTotal + p->nParam * nSize != p->nTotal - p->nParam * nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 107);
}
// AOR Label 108
if(p->nTotal * p->nParam * nSize != p->nTotal - p->nParam * nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 108);
}
// AOR Label 109
if(p->nParam - nSize != p->nParam * nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 109);
}
// AOR Label 110
if(p->nParam + nSize != p->nParam * nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 110);
}
// AOR Label 111
if(p->nParam / nSize != p->nParam * nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 111);
}
i64 nLarge = p->nTotal - p->nParam*nSize;
      
// ABS Label 112
if(nLarge < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// AOR Label 113
if(nLarge - (nSize + 1) != nLarge * (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 113);
}
// AOR Label 114
if(nLarge + (nSize + 1) != nLarge * (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 114);
}
// AOR Label 115
if(nLarge / (nSize + 1) != nLarge * (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 115);
}
i64 iSmall = nLarge*(nSize+1);
      
// ABS Label 116
if(p->iRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
i64 iRow = p->iRow;

      assert( (nLarge*(nSize+1) + (p->nParam-nLarge)*nSize)==p->nTotal );

      
// ABS Label 117
if(iRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
// ABS Label 118
if(iSmall < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// ROR Label 119
if((iRow <= iSmall) != (iRow < iSmall))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((iRow > iSmall) != (iRow < iSmall))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
// ROR Label 121
if((iRow >= iSmall) != (iRow < iSmall))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
if( iRow<iSmall ){
        
// ABS Label 122
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// ABS Label 123
if(iRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}

// AOR Label 124
if(1 - iRow / (nSize + 1) != 1 + iRow / (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 124);
}
// AOR Label 125
if(1 / iRow / (nSize + 1) != 1 + iRow / (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 125);
}
// AOR Label 126
if(1 * iRow / (nSize + 1) != 1 + iRow / (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 126);
}
// AOR Label 127
if(iRow - (nSize + 1) != iRow / (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 127);
}
// AOR Label 128
if(iRow + (nSize + 1) != iRow / (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 128);
}
// AOR Label 129
if(iRow * (nSize + 1) != iRow / (nSize + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 129);
}
sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));
      }else{
        
// ABS Label 130
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}

// ABS Label 131
if(nLarge < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}

// AOR Label 132
if(1 + nLarge - (iRow - iSmall) / nSize != 1 + nLarge + (iRow - iSmall) / nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 132);
}
// AOR Label 133
if(1 + nLarge / (iRow - iSmall) / nSize != 1 + nLarge + (iRow - iSmall) / nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 133);
}
// AOR Label 134
if(1 + nLarge * (iRow - iSmall) / nSize != 1 + nLarge + (iRow - iSmall) / nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 134);
}
// AOR Label 135
if(1 - nLarge != 1 + nLarge)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 135);
}
// AOR Label 136
if(1 / nLarge != 1 + nLarge)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 136);
}
// AOR Label 137
if(1 * nLarge != 1 + nLarge)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 137);
}
// AOR Label 138
if((iRow - iSmall) - nSize != (iRow - iSmall) / nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 138);
}
// AOR Label 139
if((iRow - iSmall) + nSize != (iRow - iSmall) / nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 139);
}
// AOR Label 140
if((iRow - iSmall) * nSize != (iRow - iSmall) / nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 140);
}
sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);
      }
    }
  }
}
#define ntileFinalizeFunc ntileValueFunc

/*
** Context object for last_value() window function.
*/
struct LastValueCtx {
  sqlite3_value *pVal;
  int nVal;
};

/*
** Implementation of last_value().
*/
static void last_valueStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct LastValueCtx *p;
  UNUSED_PARAMETER(nArg);
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 141
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
if( p ){
    
// ABS Label 142
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
sqlite3_value_free(p->pVal);
    p->pVal = sqlite3_value_dup(apArg[0]);
    
// ABS Label 143
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}

// ROR Label 144
if((p->pVal != 0) != (p->pVal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( p->pVal==0 ){
      
// ABS Label 145
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}
sqlite3_result_error_nomem(pCtx);
    }else{
      p->nVal++;
    }
  }
}
static void last_valueInvFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct LastValueCtx *p;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 146
if((p) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
if( ALWAYS(p) ){
    p->nVal--;
    
// ABS Label 147
if(p->nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}

// ROR Label 148
if((p->nVal != 0) != (p->nVal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 148);
}
if( p->nVal==0 ){
      
// ABS Label 149
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3_value_free(p->pVal);
      p->pVal = 0;
    }
  }
}
static void last_valueValueFunc(sqlite3_context *pCtx){
  struct LastValueCtx *p;
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);
  
// ABS Label 150
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
// ABS Label 151
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// COR Label 152
if((p || p->pVal) != (p && p->pVal))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 152);
}

// MCC Label 153
if(p && p->pVal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 153);
}
// MCC Label 154
if(p && !(p->pVal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 154);
}
// MCC Label 155
if(!(p) && p->pVal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 155);
}
// MCC Label 156
if(!(p) && !(p->pVal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 156);
}
if( p && p->pVal ){
    
// ABS Label 157
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ABS Label 158
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}
sqlite3_result_value(pCtx, p->pVal);
  }
}
static void last_valueFinalizeFunc(sqlite3_context *pCtx){
  struct LastValueCtx *p;
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  
// ABS Label 159
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
// ABS Label 160
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}

// COR Label 161
if((p || p->pVal) != (p && p->pVal))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 161);
}

// MCC Label 162
if(p && p->pVal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 162);
}
// MCC Label 163
if(p && !(p->pVal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 163);
}
// MCC Label 164
if(!(p) && p->pVal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(!(p) && !(p->pVal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
if( p && p->pVal ){
    
// ABS Label 166
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}

// ABS Label 167
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}
sqlite3_result_value(pCtx, p->pVal);
    
// ABS Label 168
if(p->pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}
sqlite3_value_free(p->pVal);
    p->pVal = 0;
  }
}

/*
** Static names for the built-in window function names.  These static
** names are used, rather than string literals, so that FuncDef objects
** can be associated with a particular window function by direct
** comparison of the zName pointer.  Example:
**
**       if( pFuncDef->zName==row_valueName ){ ... }
*/
static const char row_numberName[] =   "row_number";
static const char dense_rankName[] =   "dense_rank";
static const char rankName[] =         "rank";
static const char percent_rankName[] = "percent_rank";
static const char cume_distName[] =    "cume_dist";
static const char ntileName[] =        "ntile";
static const char last_valueName[] =   "last_value";
static const char nth_valueName[] =    "nth_value";
static const char first_valueName[] =  "first_value";
static const char leadName[] =         "lead";
static const char lagName[] =          "lag";

/*
** No-op implementations of xStep() and xFinalize().  Used as place-holders
** for built-in window functions that never call those interfaces.
**
** The noopValueFunc() is called but is expected to do nothing.  The
** noopStepFunc() is never called, and so it is marked with NO_TEST to
** let the test coverage routine know not to expect this function to be
** invoked.
*/
static void noopStepFunc(    /*NO_TEST*/
  sqlite3_context *p,        /*NO_TEST*/
  int n,                     /*NO_TEST*/
  sqlite3_value **a          /*NO_TEST*/
){                           /*NO_TEST*/
  UNUSED_PARAMETER(p);       /*NO_TEST*/
  UNUSED_PARAMETER(n);       /*NO_TEST*/
  UNUSED_PARAMETER(a);       /*NO_TEST*/
  assert(0);                 /*NO_TEST*/
}                            /*NO_TEST*/
static void noopValueFunc(sqlite3_context *p){ UNUSED_PARAMETER(p); /*no-op*/ }

/* Window functions that use all window interfaces: xStep, xFinal,
** xValue, and xInverse */
#define WINDOWFUNCALL(name,nArg,extra) {                                   \
  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \
  name ## StepFunc, name ## FinalizeFunc, name ## ValueFunc,               \
  name ## InvFunc, name ## Name, {0}                                       \
}

/* Window functions that are implemented using bytecode and thus have
** no-op routines for their methods */
#define WINDOWFUNCNOOP(name,nArg,extra) {                                  \
  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \
  noopStepFunc, noopValueFunc, noopValueFunc,                              \
  noopStepFunc, name ## Name, {0}                                          \
}

/* Window functions that use all window interfaces: xStep, the
** same routine for xFinalize and xValue and which never call
** xInverse. */
#define WINDOWFUNCX(name,nArg,extra) {                                     \
  nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,                      \
  name ## StepFunc, name ## ValueFunc, name ## ValueFunc,                  \
  noopStepFunc, name ## Name, {0}                                          \
}


/*
** Register those built-in window functions that are not also aggregates.
*/
void sqlite3WindowFunctions(void){
  static FuncDef aWindowFuncs[] = {
    WINDOWFUNCX(row_number, 0, 0),
    WINDOWFUNCX(dense_rank, 0, 0),
    WINDOWFUNCX(rank, 0, 0),
    WINDOWFUNCALL(percent_rank, 0, 0),
    WINDOWFUNCALL(cume_dist, 0, 0),
    WINDOWFUNCALL(ntile, 1, 0),
    WINDOWFUNCALL(last_value, 1, 0),
    WINDOWFUNCALL(nth_value, 2, 0),
    WINDOWFUNCALL(first_value, 1, 0),
    WINDOWFUNCNOOP(lead, 1, 0),
    WINDOWFUNCNOOP(lead, 2, 0),
    WINDOWFUNCNOOP(lead, 3, 0),
    WINDOWFUNCNOOP(lag, 1, 0),
    WINDOWFUNCNOOP(lag, 2, 0),
    WINDOWFUNCNOOP(lag, 3, 0),
  };
  sqlite3InsertBuiltinFuncs(aWindowFuncs, ArraySize(aWindowFuncs));
}

static Window *windowFind(Parse *pParse, Window *pList, const char *zName){
  Window *p;
  p = pList;

// ABS Label 169
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
for(; p; p=p->pNextWin){
    if( sqlite3StrICmp(p->zName, zName)==0 ) { break;
}
  };
// ABS Label 170
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

  
// ABS Label 171
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

// ROR Label 172
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 172);
}
if( p==0 ){
    
// ABS Label 173
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}

// ABS Label 174
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}
sqlite3ErrorMsg(pParse, "no such window: %s", zName);
  }
  
// ABS Label 175
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}
return p;
}

/*
** This function is called immediately after resolving the function name
** for a window function within a SELECT statement. Argument pList is a
** linked list of WINDOW definitions for the current SELECT statement.
** Argument pFunc is the function definition just resolved and pWin
** is the Window object representing the associated OVER clause. This
** function updates the contents of pWin as follows:
**
**   * If the OVER clause refered to a named window (as in "max(x) OVER win"),
**     search list pList for a matching WINDOW definition, and update pWin
**     accordingly. If no such WINDOW clause can be found, leave an error
**     in pParse.
**
**   * If the function is a built-in window function that requires the
**     window to be coerced (see "BUILT-IN WINDOW FUNCTIONS" at the top
**     of this file), pWin is updated here.
*/
void sqlite3WindowUpdate(
  Parse *pParse, 
  Window *pList,                  /* List of named windows for this SELECT */
  Window *pWin,                   /* Window frame to update */
  FuncDef *pFunc                  /* Window function definition */
){
  
// ABS Label 176
if(pWin->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// COR Label 177
if((pWin->zName || pWin->eFrmType == 0) != (pWin->zName && pWin->eFrmType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 177);
}

// ROR Label 178
if((pWin->eFrmType != 0) != (pWin->eFrmType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}

// MCC Label 179
if(pWin->zName && pWin->eFrmType == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(pWin->zName && !(pWin->eFrmType == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(!(pWin->zName) && pWin->eFrmType == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(!(pWin->zName) && !(pWin->eFrmType == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
if( pWin->zName && pWin->eFrmType==0 ){
    Window *p = windowFind(pParse, pList, pWin->zName);
    
// ABS Label 183
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}

// ROR Label 184
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
if( p==0 ) { return;
}
    pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);
    pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);
    pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);
    pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);
    pWin->eStart = p->eStart;
    pWin->eEnd = p->eEnd;
    pWin->eFrmType = p->eFrmType;
    pWin->eExclude = p->eExclude;
  }else{
    
// ABS Label 185
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}

// ABS Label 186
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ABS Label 187
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
sqlite3WindowChain(pParse, pWin, pList);
  }
  
// COR Label 188
if(((pWin->eFrmType == 89) && (pWin->pStart || pWin->pEnd) || (pWin->pOrderBy == 0 || pWin->pOrderBy->nExpr != 1)) != ((pWin->eFrmType == 89) && (pWin->pStart || pWin->pEnd) && (pWin->pOrderBy == 0 || pWin->pOrderBy->nExpr != 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 188);
}
// COR Label 189
if(((pWin->eFrmType == 89) || (pWin->pStart || pWin->pEnd)) != ((pWin->eFrmType == 89) && (pWin->pStart || pWin->pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 189);
}

// MCC Label 190
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && pWin->pEnd ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 190);
}
// MCC Label 191
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && pWin->pEnd ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 191);
}
// MCC Label 192
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 192);
}
// MCC Label 193
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 193);
}
// MCC Label 194
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(( pWin->eFrmType == 89 ) && ( pWin->pStart && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
// MCC Label 198
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && pWin->pEnd ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 198);
}
// MCC Label 199
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && pWin->pEnd ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 199);
}
// MCC Label 200
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 200);
}
// MCC Label 201
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 201);
}
// MCC Label 202
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}
// MCC Label 203
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 203);
}
// MCC Label 204
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 204);
}
// MCC Label 205
if(( pWin->eFrmType == 89 ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 205);
}
// MCC Label 206
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && pWin->pEnd ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 206);
}
// MCC Label 207
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && pWin->pEnd ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 207);
}
// MCC Label 208
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(( !(pWin->eFrmType == 89) ) && ( pWin->pStart && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && pWin->pEnd ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && pWin->pEnd ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && pWin->pEnd ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
// MCC Label 219
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( pWin->pOrderBy == 0 && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && pWin->pOrderBy->nExpr != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(( !(pWin->eFrmType == 89) ) && ( !(pWin->pStart) && !(pWin->pEnd) ) && ( !(pWin->pOrderBy == 0) && !(pWin->pOrderBy->nExpr != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
if( (pWin->eFrmType==TK_RANGE)
   && (pWin->pStart || pWin->pEnd) 
   && (pWin->pOrderBy==0 || pWin->pOrderBy->nExpr!=1)
  ){
    
// ABS Label 222
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}
sqlite3ErrorMsg(pParse, 
      "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression"
    );
  }else {
  
// ABS Label 223
if(pFunc->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}

// AOR Label 224
if(pFunc->funcFlags | 65536 != pFunc->funcFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 224);
}
// AOR Label 225
if(pFunc->funcFlags ^ 65536 != pFunc->funcFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 225);
}
if( pFunc->funcFlags & SQLITE_FUNC_WINDOW ){
    
// ABS Label 226
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
sqlite3 *db = pParse->db;
    
// ABS Label 227
if(pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
if( pWin->pFilter ){
      
// ABS Label 228
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}
sqlite3ErrorMsg(pParse, 
          "FILTER clause may only be used with aggregate window functions"
      );
    }else{
      struct WindowUpdate {
        const char *zFunc;
        int eFrmType;
        int eStart;
        int eEnd;
      } aUp[] = {
        { row_numberName,   TK_ROWS,   TK_UNBOUNDED, TK_CURRENT }, 
        { dense_rankName,   TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, 
        { rankName,         TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, 
        { percent_rankName, TK_GROUPS, TK_CURRENT,   TK_UNBOUNDED }, 
        { cume_distName,    TK_GROUPS, TK_FOLLOWING, TK_UNBOUNDED }, 
        { ntileName,        TK_ROWS,   TK_CURRENT,   TK_UNBOUNDED }, 
        { leadName,         TK_ROWS,   TK_UNBOUNDED, TK_UNBOUNDED }, 
        { lagName,          TK_ROWS,   TK_UNBOUNDED, TK_CURRENT }, 
      };
      int i;
      i = 0;

// ABS Label 229
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}

// ROR Label 230
if((i <= ((int)(sizeof (aUp) / sizeof (aUp[0])))) != (i < ((int)(sizeof (aUp) / sizeof (aUp[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 230);
}
// ROR Label 231
if((i > ((int)(sizeof (aUp) / sizeof (aUp[0])))) != (i < ((int)(sizeof (aUp) / sizeof (aUp[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 231);
}
// ROR Label 232
if((i >= ((int)(sizeof (aUp) / sizeof (aUp[0])))) != (i < ((int)(sizeof (aUp) / sizeof (aUp[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
for(; i<ArraySize(aUp); i++){
        
// ABS Label 237
if(aUp[i].zFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}
// ABS Label 238
if(pFunc->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ROR Label 239
if((pFunc->zName != aUp[i].zFunc) != (pFunc->zName == aUp[i].zFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 239);
}
if( pFunc->zName==aUp[i].zFunc ){
          
// ABS Label 240
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ABS Label 241
if(pWin->pStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}
sqlite3ExprDelete(db, pWin->pStart);
          
// ABS Label 242
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}

// ABS Label 243
if(pWin->pEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}
sqlite3ExprDelete(db, pWin->pEnd);
          pWin->pEnd = pWin->pStart = 0;
          pWin->eFrmType = aUp[i].eFrmType;
          pWin->eStart = aUp[i].eStart;
          pWin->eEnd = aUp[i].eEnd;
          pWin->eExclude = 0;
          
// ROR Label 244
if((pWin->eStart != 86) != (pWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}
if( pWin->eStart==TK_FOLLOWING ){
            pWin->pStart = sqlite3Expr(db, TK_INTEGER, "1");
          }
          break;
        }
      };
// ABS Label 233
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}

// ROR Label 234
if((i <= ((int)(sizeof (aUp) / sizeof (aUp[0])))) != (i < ((int)(sizeof (aUp) / sizeof (aUp[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}
// ROR Label 235
if((i > ((int)(sizeof (aUp) / sizeof (aUp[0])))) != (i < ((int)(sizeof (aUp) / sizeof (aUp[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
// ROR Label 236
if((i >= ((int)(sizeof (aUp) / sizeof (aUp[0])))) != (i < ((int)(sizeof (aUp) / sizeof (aUp[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}

    }
  };}

  pWin->pFunc = pFunc;
}

/*
** Context object passed through sqlite3WalkExprList() to
** selectWindowRewriteExprCb() by selectWindowRewriteEList().
*/
typedef struct WindowRewrite WindowRewrite;
struct WindowRewrite {
  Window *pWin;
  SrcList *pSrc;
  ExprList *pSub;
  Table *pTab;
  Select *pSubSelect;             /* Current sub-select, if any */
};

/*
** Callback function used by selectWindowRewriteEList(). If necessary,
** this function appends to the output expression-list and updates 
** expression (*ppExpr) in place.
*/
static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 245
if(pWalker->u.pRewrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}
struct WindowRewrite *p = pWalker->u.pRewrite;
  
// ABS Label 246
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}
Parse *pParse = pWalker->pParse;
  assert( p!=0 );
  assert( p->pWin!=0 );

  /* If this function is being called from within a scalar sub-select
  ** that used by the SELECT statement being processed, only process
  ** TK_COLUMN expressions that refer to it (the outer SELECT). Do
  ** not process aggregates or window functions at all, as they belong
  ** to the scalar sub-select.  */
  
// ABS Label 247
if(p->pSubSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
if( p->pSubSelect ){
    
// ROR Label 248
if((pExpr->op == 166) != (pExpr->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 248);
}
if( pExpr->op!=TK_COLUMN ){
      return WRC_Continue;
    }else{
      
// ABS Label 249
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
int nSrc = p->pSrc->nSrc;
      int i;
      i = 0;

// ABS Label 250
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}
// ABS Label 251
if(nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ROR Label 252
if((i <= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((i > nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
// ROR Label 254
if((i >= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
for(; i<nSrc; i++){
        
// ABS Label 260
if(p->pSrc->a[i].iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
// ABS Label 261
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}

// ROR Label 262
if((pExpr->iTable != p->pSrc->a[i].iCursor) != (pExpr->iTable == p->pSrc->a[i].iCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
if( pExpr->iTable==p->pSrc->a[i].iCursor ) { break;
}
      };
// ABS Label 255
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}
// ABS Label 256
if(nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ROR Label 257
if((i <= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
// ROR Label 258
if((i > nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}
// ROR Label 259
if((i >= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}

      
// ABS Label 263
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}
// ABS Label 264
if(nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}

// ROR Label 265
if((i != nSrc) != (i == nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
if( i==nSrc ) { return WRC_Continue;
}
    }
  }

  switch( pExpr->op ){

    case TK_FUNCTION:
      if( !ExprHasProperty(pExpr, EP_WinFunc) ){
        break;
      }else{
        Window *pWin;
        pWin = p->pWin;

// ABS Label 266
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}
for(; pWin; pWin=pWin->pNextWin){
          
// ABS Label 268
if(pExpr->y.pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}
// ABS Label 269
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}

// ROR Label 270
if((pExpr->y.pWin != pWin) != (pExpr->y.pWin == pWin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 270);
}
if( pExpr->y.pWin==pWin ){
            assert( pWin->pOwner==pExpr );
            return WRC_Prune;
          }
        };
// ABS Label 267
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 267);
}

      }
      /* no break */ deliberate_fall_through

    case TK_AGG_FUNCTION:
    case TK_COLUMN: {
      int iCol = -1;
      
// ABS Label 271
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
if( pParse->db->mallocFailed ) { return WRC_Abort;
}
      
// ABS Label 272
if(p->pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
if( p->pSub ){
        int i;
        i = 0;

// ABS Label 273
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}
// ABS Label 274
if(p->pSub->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}

// ROR Label 275
if((i <= p->pSub->nExpr) != (i < p->pSub->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 275);
}
// ROR Label 276
if((i > p->pSub->nExpr) != (i < p->pSub->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 276);
}
// ROR Label 277
if((i >= p->pSub->nExpr) != (i < p->pSub->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 277);
}
for(; i<p->pSub->nExpr; i++){
          if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){
            iCol = i;
            break;
          }
        };
// ABS Label 278
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}
// ABS Label 279
if(p->pSub->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}

// ROR Label 280
if((i <= p->pSub->nExpr) != (i < p->pSub->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((i > p->pSub->nExpr) != (i < p->pSub->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}
// ROR Label 282
if((i >= p->pSub->nExpr) != (i < p->pSub->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}

      }
      
// ABS Label 283
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
// ROR Label 285
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 285);
}
// ROR Label 286
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
if( iCol<0 ){
        Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);
        
// ABS Label 287
if(pDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}

// COR Label 288
if((pDup || pDup->op == 167) != (pDup && pDup->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 288);
}

// ROR Label 289
if((pDup->op != 167) != (pDup->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}

// MCC Label 290
if(pDup && pDup->op == 167 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 290);
}
// MCC Label 291
if(pDup && !(pDup->op == 167) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 291);
}
// MCC Label 292
if(!(pDup) && pDup->op == 167 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 292);
}
// MCC Label 293
if(!(pDup) && !(pDup->op == 167) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 293);
}
if( pDup && pDup->op==TK_AGG_FUNCTION ) { pDup->op = TK_FUNCTION;
}
        p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);
      }
      
// ABS Label 294
if(p->pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
if( p->pSub ){
        int f = pExpr->flags & EP_Collate;
        assert( ExprHasProperty(pExpr, EP_Static)==0 );
        ExprSetProperty(pExpr, EP_Static);
        
// ABS Label 295
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
sqlite3ExprDelete(pParse->db, pExpr);
        ExprClearProperty(pExpr, EP_Static);
        memset(pExpr, 0, sizeof(Expr));

        pExpr->op = TK_COLUMN;
        pExpr->iColumn = (iCol<0 ? p->pSub->nExpr-1: iCol);
        pExpr->iTable = p->pWin->iEphCsr;
        pExpr->y.pTab = p->pTab;
        pExpr->flags = f;
      }
      
// ABS Label 297
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
if( pParse->db->mallocFailed ) { return WRC_Abort;
}
      break;
    }

    default: /* no-op */
      break;
  }

  return WRC_Continue;
}
static int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){
  
// ABS Label 298
if(pWalker->u.pRewrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
struct WindowRewrite *p = pWalker->u.pRewrite;
  
// ABS Label 299
if(p->pSubSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
Select *pSave = p->pSubSelect;
  
// ABS Label 300
if(pSave < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
// ABS Label 301
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ROR Label 302
if((pSave != pSelect) != (pSave == pSelect))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}
if( pSave==pSelect ){
    return WRC_Continue;
  }else{
    p->pSubSelect = pSelect;
    
// ABS Label 303
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ABS Label 304
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
sqlite3WalkSelect(pWalker, pSelect);
    p->pSubSelect = pSave;
  }
  return WRC_Prune;
}


/*
** Iterate through each expression in expression-list pEList. For each:
**
**   * TK_COLUMN,
**   * aggregate function, or
**   * window function with a Window object that is not a member of the 
**     Window list passed as the second argument (pWin).
**
** Append the node to output expression-list (*ppSub). And replace it
** with a TK_COLUMN that reads the (N-1)th element of table 
** pWin->iEphCsr, where N is the number of elements in (*ppSub) after
** appending the new one.
*/
static void selectWindowRewriteEList(
  Parse *pParse, 
  Window *pWin,
  SrcList *pSrc,
  ExprList *pEList,               /* Rewrite expressions in this list */
  Table *pTab,
  ExprList **ppSub                /* IN/OUT: Sub-select expression-list */
){
  Walker sWalker;
  WindowRewrite sRewrite;

  assert( pWin!=0 );
  memset(&sWalker, 0, sizeof(Walker));
  memset(&sRewrite, 0, sizeof(WindowRewrite));

  sRewrite.pSub = *ppSub;
  sRewrite.pWin = pWin;
  sRewrite.pSrc = pSrc;
  sRewrite.pTab = pTab;

  sWalker.pParse = pParse;
  sWalker.xExprCallback = selectWindowRewriteExprCb;
  sWalker.xSelectCallback = selectWindowRewriteSelectCb;
  sWalker.u.pRewrite = &sRewrite;

  (void)sqlite3WalkExprList(&sWalker, pEList);

  *ppSub = sRewrite.pSub;
}

/*
** Append a copy of each expression in expression-list pAppend to
** expression list pList. Return a pointer to the result list.
*/
static ExprList *exprListAppendList(
  Parse *pParse,          /* Parsing context */
  ExprList *pList,        /* List to which to append. Might be NULL */
  ExprList *pAppend,      /* List of values to append. Might be NULL */
  int bIntToNull
){
  
// ABS Label 305
if(pAppend < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
if( pAppend ){
    int i;
    int nInit = pList ? pList->nExpr : 0;
    i = 0;

// ABS Label 306
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
// ABS Label 307
if(pAppend->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}

// ROR Label 308
if((i <= pAppend->nExpr) != (i < pAppend->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 308);
}
// ROR Label 309
if((i > pAppend->nExpr) != (i < pAppend->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
// ROR Label 310
if((i >= pAppend->nExpr) != (i < pAppend->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
for(; i<pAppend->nExpr; i++){
      
// ABS Label 316
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
sqlite3 *db = pParse->db;
      Expr *pDup = sqlite3ExprDup(db, pAppend->a[i].pExpr, 0);
      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );
      
// ABS Label 317
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
if( db->mallocFailed ){
        
// ABS Label 318
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}

// ABS Label 319
if(pDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
sqlite3ExprDelete(db, pDup);
        break;
      }
      
// ABS Label 320
if(bIntToNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
if( bIntToNull ){
        int iDummy;
        Expr *pSub;
        pSub = sqlite3ExprSkipCollateAndLikely(pDup);
        if( sqlite3ExprIsInteger(pSub, &iDummy) ){
          pSub->op = TK_NULL;
          pSub->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);
#ifdef MAGMA_ENABLE_FIXES
          pSub->u.zToken = 0;
#endif
#ifdef MAGMA_ENABLE_CANARIES
          MAGMA_LOG("SQL020", pDup->u.zToken !=0);
#endif
        }
      }
      pList = sqlite3ExprListAppend(pParse, pList, pDup);
      
// ABS Label 321
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
if( pList ) { pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;
}
    };
// ABS Label 311
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
// ABS Label 312
if(pAppend->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}

// ROR Label 313
if((i <= pAppend->nExpr) != (i < pAppend->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 313);
}
// ROR Label 314
if((i > pAppend->nExpr) != (i < pAppend->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
// ROR Label 315
if((i >= pAppend->nExpr) != (i < pAppend->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}

  }
  
// ABS Label 322
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
return pList;
}

/*
** When rewriting a query, if the new subquery in the FROM clause
** contains TK_AGG_FUNCTION nodes that refer to an outer query,
** then we have to increase the Expr->op2 values of those nodes
** due to the extra subquery layer that was added.
**
** See also the incrAggDepth() routine in resolve.c
*/
static int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){
  
// ABS Label 323
if(pWalker->walkerDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}

// COR Label 324
if((pExpr->op == 167 || pExpr->op2 >= pWalker->walkerDepth) != (pExpr->op == 167 && pExpr->op2 >= pWalker->walkerDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 324);
}

// ROR Label 325
if((pExpr->op != 167) != (pExpr->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}
// ROR Label 326
if((pExpr->op2 < pWalker->walkerDepth) != (pExpr->op2 >= pWalker->walkerDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 326);
}
// ROR Label 327
if((pExpr->op2 > pWalker->walkerDepth) != (pExpr->op2 >= pWalker->walkerDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
// ROR Label 328
if((pExpr->op2 <= pWalker->walkerDepth) != (pExpr->op2 >= pWalker->walkerDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 328);
}

// MCC Label 329
if(pExpr->op == 167 && pExpr->op2 >= pWalker->walkerDepth ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 329);
}
// MCC Label 330
if(pExpr->op == 167 && !(pExpr->op2 >= pWalker->walkerDepth) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 330);
}
// MCC Label 331
if(!(pExpr->op == 167) && pExpr->op2 >= pWalker->walkerDepth ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 331);
}
// MCC Label 332
if(!(pExpr->op == 167) && !(pExpr->op2 >= pWalker->walkerDepth) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 332);
}
if( pExpr->op==TK_AGG_FUNCTION
   && pExpr->op2>=pWalker->walkerDepth
  ){
    pExpr->op2++;
  }
  return WRC_Continue;
}

static int disallowAggregatesInOrderByCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 333
if(pExpr->pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}

// COR Label 334
if((pExpr->op == 167 || pExpr->pAggInfo == 0) != (pExpr->op == 167 && pExpr->pAggInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 334);
}

// ROR Label 335
if((pExpr->op != 167) != (pExpr->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 335);
}
// ROR Label 336
if((pExpr->pAggInfo != 0) != (pExpr->pAggInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}

// MCC Label 337
if(pExpr->op == 167 && pExpr->pAggInfo == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 337);
}
// MCC Label 338
if(pExpr->op == 167 && !(pExpr->pAggInfo == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 338);
}
// MCC Label 339
if(!(pExpr->op == 167) && pExpr->pAggInfo == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 339);
}
// MCC Label 340
if(!(pExpr->op == 167) && !(pExpr->pAggInfo == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 340);
}
if( pExpr->op==TK_AGG_FUNCTION && pExpr->pAggInfo==0 ){
    
// ABS Label 341
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}

// ABS Label 342
if(pExpr->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}
sqlite3ErrorMsg(pWalker->pParse,
         "misuse of aggregate: %s()", pExpr->u.zToken);
  }
  return WRC_Continue;
}

/*
** If the SELECT statement passed as the second argument does not invoke
** any SQL window functions, this function is a no-op. Otherwise, it 
** rewrites the SELECT statement so that window function xStep functions
** are invoked in the correct order as described under "SELECT REWRITING"
** at the top of this file.
*/
int sqlite3WindowRewrite(Parse *pParse, Select *p){
  int rc = SQLITE_OK;
  
// ABS Label 343
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}
// ABS Label 344
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}

// COR Label 345
if((p->pWin && p->pPrior == 0 || ((p->selFlags & 1048576) == 0)) != (p->pWin && p->pPrior == 0 && ((p->selFlags & 1048576) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 345);
}
// COR Label 346
if((p->pWin || p->pPrior == 0) != (p->pWin && p->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 346);
}

// ROR Label 347
if((p->pPrior != 0) != (p->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 347);
}

// MCC Label 348
if(p->pWin && p->pPrior == 0 && ( (p->selFlags & 1048576) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 348);
}
// MCC Label 349
if(p->pWin && p->pPrior == 0 && ( !((p->selFlags & 1048576) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
// MCC Label 350
if(p->pWin && !(p->pPrior == 0) && ( (p->selFlags & 1048576) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
// MCC Label 351
if(p->pWin && !(p->pPrior == 0) && ( !((p->selFlags & 1048576) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
// MCC Label 352
if(!(p->pWin) && p->pPrior == 0 && ( (p->selFlags & 1048576) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 352);
}
// MCC Label 353
if(!(p->pWin) && p->pPrior == 0 && ( !((p->selFlags & 1048576) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 353);
}
// MCC Label 354
if(!(p->pWin) && !(p->pPrior == 0) && ( (p->selFlags & 1048576) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 354);
}
// MCC Label 355
if(!(p->pWin) && !(p->pPrior == 0) && ( !((p->selFlags & 1048576) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 355);
}
if( p->pWin && p->pPrior==0 && ALWAYS((p->selFlags & SF_WinRewrite)==0) ){
    Vdbe *v = sqlite3GetVdbe(pParse);
    
// ABS Label 356
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}
sqlite3 *db = pParse->db;
    Select *pSub = 0;             /* The subquery */
    
// ABS Label 357
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}
SrcList *pSrc = p->pSrc;
    
// ABS Label 358
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}
Expr *pWhere = p->pWhere;
    
// ABS Label 359
if(p->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}
ExprList *pGroupBy = p->pGroupBy;
    
// ABS Label 360
if(p->pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}
Expr *pHaving = p->pHaving;
    ExprList *pSort = 0;

    ExprList *pSublist = 0;       /* Expression list for sub-query */
    
// ABS Label 361
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}
Window *pMWin = p->pWin;      /* Main window object */
    Window *pWin;                 /* Window object iterator */
    Table *pTab;
    Walker w;

    
// ABS Label 362
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}
u32 selFlags = p->selFlags;

    pTab = sqlite3DbMallocZero(db, sizeof(Table));
    
// ABS Label 376
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 376);
}

// ROR Label 377
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
if( pTab==0 ){
      return sqlite3ErrorToParser(db, SQLITE_NOMEM);
    }
    
// ABS Label 363
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 363);
}
sqlite3AggInfoPersistWalkerInit(&w, pParse);
    
// ABS Label 364
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
sqlite3WalkSelect(&w, p);
    
// ROR Label 378
if(((p->selFlags & 8) != 0) != ((p->selFlags & 8) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
if( (p->selFlags & SF_Aggregate)==0 ){
      w.xExprCallback = disallowAggregatesInOrderByCb;
      w.xSelectCallback = 0;
      
// ABS Label 379
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}
sqlite3WalkExprList(&w, p->pOrderBy);
    }

    p->pSrc = 0;
    p->pWhere = 0;
    p->pGroupBy = 0;
    p->pHaving = 0;
    p->selFlags &= ~SF_Aggregate;
    p->selFlags |= SF_WinRewrite;

    /* Create the ORDER BY clause for the sub-select. This is the concatenation
    ** of the window PARTITION and ORDER BY clauses. Then, if this makes it
    ** redundant, remove the ORDER BY from the parent SELECT.  */
    pSort = exprListAppendList(pParse, 0, pMWin->pPartition, 1);
    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
    
// ABS Label 380
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}
// ABS Label 381
if(p->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 381);
}
// ABS Label 382
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}
// ABS Label 383
if(pSort->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}

// COR Label 384
if((pSort && p->pOrderBy || p->pOrderBy->nExpr <= pSort->nExpr) != (pSort && p->pOrderBy && p->pOrderBy->nExpr <= pSort->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 384);
}
// COR Label 385
if((pSort || p->pOrderBy) != (pSort && p->pOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 385);
}

// ROR Label 386
if((p->pOrderBy->nExpr < pSort->nExpr) != (p->pOrderBy->nExpr <= pSort->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
// ROR Label 387
if((p->pOrderBy->nExpr > pSort->nExpr) != (p->pOrderBy->nExpr <= pSort->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 387);
}
// ROR Label 388
if((p->pOrderBy->nExpr >= pSort->nExpr) != (p->pOrderBy->nExpr <= pSort->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 388);
}

// MCC Label 389
if(pSort && p->pOrderBy && p->pOrderBy->nExpr <= pSort->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 389);
}
// MCC Label 390
if(pSort && p->pOrderBy && !(p->pOrderBy->nExpr <= pSort->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 390);
}
// MCC Label 391
if(pSort && !(p->pOrderBy) && p->pOrderBy->nExpr <= pSort->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 391);
}
// MCC Label 392
if(pSort && !(p->pOrderBy) && !(p->pOrderBy->nExpr <= pSort->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
// MCC Label 393
if(!(pSort) && p->pOrderBy && p->pOrderBy->nExpr <= pSort->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(!(pSort) && p->pOrderBy && !(p->pOrderBy->nExpr <= pSort->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(!(pSort) && !(p->pOrderBy) && p->pOrderBy->nExpr <= pSort->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(!(pSort) && !(p->pOrderBy) && !(p->pOrderBy->nExpr <= pSort->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
      
// ABS Label 397
if(pSort->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
int nSave = pSort->nExpr;
      pSort->nExpr = p->pOrderBy->nExpr;
      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
        
// ABS Label 398
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}

// ABS Label 399
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}
sqlite3ExprListDelete(db, p->pOrderBy);
        p->pOrderBy = 0;
      }
      pSort->nExpr = nSave;
    }

    /* Assign a cursor number for the ephemeral table used to buffer rows.
    ** The OpenEphemeral instruction is coded later, after it is known how
    ** many columns the table will have.  */
    pMWin->iEphCsr = pParse->nTab++;
    pParse->nTab += 3;

    
// ABS Label 365
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}

// ABS Label 366
if(pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}

// ABS Label 367
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}

// ABS Label 368
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}

// ABS Label 369
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
    
// ABS Label 370
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}

// ABS Label 371
if(pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}

// ABS Label 372
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}

// ABS Label 373
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// ABS Label 374
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);

    /* Append the PARTITION BY and ORDER BY expressions to the to the 
    ** sub-select expression list. They are required to figure out where 
    ** boundaries for partitions and sets of peer rows lie.  */
    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);

    /* Append the arguments passed to each window function to the
    ** sub-select expression list. Also allocate two registers for each
    ** window function - one for the accumulator, another for interim
    ** results.  */
    pWin = pMWin;

// ABS Label 400
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
for(; pWin; pWin=pWin->pNextWin){
      
// ABS Label 402
if(pWin->pOwner->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}
ExprList *pArgs = pWin->pOwner->x.pList;
      
// ABS Label 405
if(pWin->pFunc->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}

// AOR Label 406
if(pWin->pFunc->funcFlags | 1048576 != pWin->pFunc->funcFlags & 1048576)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 406);
}
// AOR Label 407
if(pWin->pFunc->funcFlags ^ 1048576 != pWin->pFunc->funcFlags & 1048576)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 407);
}
if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){
        
// ABS Label 408
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}

// ABS Label 409
if(pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}

// ABS Label 410
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ABS Label 411
if(pArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}

// ABS Label 412
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}
selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pWin->bExprArgs = 1;
      }else{
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
      }
      
// ABS Label 413
if(pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
if( pWin->pFilter ){
        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
      }
      pWin->regAccum = ++pParse->nMem;
      pWin->regResult = ++pParse->nMem;
      
// ABS Label 403
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}

// ABS Label 404
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
    };
// ABS Label 401
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}


    /* If there is no ORDER BY or PARTITION BY clause, and the window
    ** function accepts zero arguments, and there are no other columns
    ** selected (e.g. "SELECT row_number() OVER () FROM t1"), it is possible
    ** that pSublist is still NULL here. Add a constant expression here to 
    ** keep everything legal in this case. 
    */
    
// ABS Label 414
if(pSublist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// ROR Label 415
if((pSublist != 0) != (pSublist == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 415);
}
if( pSublist==0 ){
      pSublist = sqlite3ExprListAppend(pParse, 0, 
        sqlite3Expr(db, TK_INTEGER, "0")
      );
    }

    pSub = sqlite3SelectNew(
        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
    );
    SELECTTRACE(1,pParse,pSub,
       ("New window-function subquery in FROM clause of (%u/%p)\n",
       p->selId, p));
    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    
// ABS Label 416
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
if( p->pSrc ){
      Table *pTab2;
      p->pSrc->a[0].pSelect = pSub;
      
// ABS Label 417
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}

// ABS Label 418
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
sqlite3SrcListAssignCursors(pParse, p->pSrc);
      pSub->selFlags |= SF_Expanded;
      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);
      pSub->selFlags |= (selFlags & SF_Aggregate);
      
// ABS Label 419
if(pTab2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}

// ROR Label 420
if((pTab2 != 0) != (pTab2 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
if( pTab2==0 ){
        /* Might actually be some other kind of error, but in that case
        ** pParse->nErr will be set, so if SQLITE_NOMEM is set, we will get
        ** the correct error message regardless. */
        rc = SQLITE_NOMEM;
      }else{
        memcpy(pTab, pTab2, sizeof(Table));
        pTab->tabFlags |= TF_Ephemeral;
        p->pSrc->a[0].pTab = pTab;
        pTab = pTab2;
        memset(&w, 0, sizeof(w));
        w.xExprCallback = sqlite3WindowExtraAggFuncDepth;
        w.xSelectCallback = sqlite3WalkerDepthIncrease;
        w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
        
// ABS Label 421
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}
sqlite3WalkSelect(&w, pSub);
      }
    }else{
      
// ABS Label 422
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}

// ABS Label 423
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}
sqlite3SelectDelete(db, pSub);
    }
    
// ABS Label 424
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}
if( db->mallocFailed ) { rc = SQLITE_NOMEM;
}
    
// ABS Label 375
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}
sqlite3DbFree(db, pTab);
  }

  
// ABS Label 425
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}
if( rc ){
    
// ABS Label 426
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}

// ROR Label 427
if((pParse->nErr != 0) != (pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
if( pParse->nErr==0 ){
      assert( pParse->db->mallocFailed );
      
// ABS Label 428
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}
sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);
    }
  }
  
// ABS Label 429
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}
return rc;
}

/*
** Unlink the Window object from the Select to which it is attached,
** if it is attached.
*/
void sqlite3WindowUnlinkFromSelect(Window *p){
  
// ABS Label 430
if(p->ppThis < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}
if( p->ppThis ){
    *p->ppThis = p->pNextWin;
    
// ABS Label 431
if(p->pNextWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
if( p->pNextWin ) { p->pNextWin->ppThis = p->ppThis;
}
    p->ppThis = 0;
  }
}

/*
** Free the Window object passed as the second argument.
*/
void sqlite3WindowDelete(sqlite3 *db, Window *p){
  
// ABS Label 432
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}
if( p ){
    
// ABS Label 433
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 433);
}
sqlite3WindowUnlinkFromSelect(p);
    
// ABS Label 434
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}

// ABS Label 435
if(p->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}
sqlite3ExprDelete(db, p->pFilter);
    
// ABS Label 436
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 436);
}

// ABS Label 437
if(p->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 437);
}
sqlite3ExprListDelete(db, p->pPartition);
    
// ABS Label 438
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}

// ABS Label 439
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 439);
}
sqlite3ExprListDelete(db, p->pOrderBy);
    
// ABS Label 440
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 440);
}

// ABS Label 441
if(p->pEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 441);
}
sqlite3ExprDelete(db, p->pEnd);
    
// ABS Label 442
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}

// ABS Label 443
if(p->pStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}
sqlite3ExprDelete(db, p->pStart);
    
// ABS Label 444
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
sqlite3DbFree(db, p->zName);
    
// ABS Label 445
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}
sqlite3DbFree(db, p->zBase);
    
// ABS Label 446
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 446);
}
sqlite3DbFree(db, p);
  }
}

/*
** Free the linked list of Window objects starting at the second argument.
*/
void sqlite3WindowListDelete(sqlite3 *db, Window *p){
  
// ABS Label 447
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 447);
}
while( p ){
    
// ABS Label 449
if(p->pNextWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}
Window *pNext = p->pNextWin;
    
// ABS Label 450
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}

// ABS Label 451
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 451);
}
sqlite3WindowDelete(db, p);
    p = pNext;
  };
// ABS Label 448
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 448);
}

}

/*
** The argument expression is an PRECEDING or FOLLOWING offset.  The
** value should be a non-negative integer.  If the value is not a
** constant, change it to NULL.  The fact that it is then a non-negative
** integer will be caught later.  But it is important not to leave
** variable values in the expression tree.
*/
static Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){
  if( 0==sqlite3ExprIsConstant(pExpr) ){
    
// MCC Label 454
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 454);
}
// MCC Label 455
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 455);
}
if( IN_RENAME_OBJECT ) { 
// ABS Label 456
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}

// ABS Label 457
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
sqlite3RenameExprUnmap(pParse, pExpr);
}
    
// ABS Label 452
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}

// ABS Label 453
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
sqlite3ExprDelete(pParse->db, pExpr);
    pExpr = sqlite3ExprAlloc(pParse->db, TK_NULL, 0, 0);
  }
  
// ABS Label 458
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
return pExpr;
}

/*
** Allocate and return a new Window object describing a Window Definition.
*/
Window *sqlite3WindowAlloc(
  Parse *pParse,    /* Parsing context */
  int eType,        /* Frame type. TK_RANGE, TK_ROWS, TK_GROUPS, or 0 */
  int eStart,       /* Start type: CURRENT, PRECEDING, FOLLOWING, UNBOUNDED */
  Expr *pStart,     /* Start window size if TK_PRECEDING or FOLLOWING */
  int eEnd,         /* End type: CURRENT, FOLLOWING, TK_UNBOUNDED, PRECEDING */
  Expr *pEnd,       /* End window size if TK_FOLLOWING or PRECEDING */
  u8 eExclude       /* EXCLUDE clause */
){
  Window *pWin = 0;
  int bImplicitFrame = 0;

  /* Parser assures the following: */
  assert( eType==0 || eType==TK_RANGE || eType==TK_ROWS || eType==TK_GROUPS );
  assert( eStart==TK_CURRENT || eStart==TK_PRECEDING
           || eStart==TK_UNBOUNDED || eStart==TK_FOLLOWING );
  assert( eEnd==TK_CURRENT || eEnd==TK_FOLLOWING
           || eEnd==TK_UNBOUNDED || eEnd==TK_PRECEDING );
  assert( (eStart==TK_PRECEDING || eStart==TK_FOLLOWING)==(pStart!=0) );
  assert( (eEnd==TK_FOLLOWING || eEnd==TK_PRECEDING)==(pEnd!=0) );

  
// ABS Label 461
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 461);
}

// ROR Label 462
if((eType != 0) != (eType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
if( eType==0 ){
    bImplicitFrame = 1;
    eType = TK_RANGE;
  }

  /* Additionally, the
  ** starting boundary type may not occur earlier in the following list than
  ** the ending boundary type:
  **
  **   UNBOUNDED PRECEDING
  **   <expr> PRECEDING
  **   CURRENT ROW
  **   <expr> FOLLOWING
  **   UNBOUNDED FOLLOWING
  **
  ** The parser ensures that "UNBOUNDED PRECEDING" cannot be used as an ending
  ** boundary, and than "UNBOUNDED FOLLOWING" cannot be used as a starting
  ** frame boundary.
  */
  
// COR Label 463
if(((eStart == 85 && eEnd == 88) && (eStart == 86 && (eEnd == 88 || eEnd == 85))) != ((eStart == 85 && eEnd == 88) || (eStart == 86 && (eEnd == 88 || eEnd == 85))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 463);
}

// MCC Label 464
if(( eStart == 85 && eEnd == 88 ) && ( eStart == 86 && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
// MCC Label 465
if(( eStart == 85 && eEnd == 88 ) && ( eStart == 86 && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 465);
}
// MCC Label 466
if(( eStart == 85 && eEnd == 88 ) && ( eStart == 86 && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 466);
}
// MCC Label 467
if(( eStart == 85 && eEnd == 88 ) && ( eStart == 86 && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 467);
}
// MCC Label 468
if(( eStart == 85 && eEnd == 88 ) && ( !(eStart == 86) && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 468);
}
// MCC Label 469
if(( eStart == 85 && eEnd == 88 ) && ( !(eStart == 86) && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 469);
}
// MCC Label 470
if(( eStart == 85 && eEnd == 88 ) && ( !(eStart == 86) && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 470);
}
// MCC Label 471
if(( eStart == 85 && eEnd == 88 ) && ( !(eStart == 86) && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 471);
}
// MCC Label 472
if(( eStart == 85 && !(eEnd == 88) ) && ( eStart == 86 && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 472);
}
// MCC Label 473
if(( eStart == 85 && !(eEnd == 88) ) && ( eStart == 86 && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 473);
}
// MCC Label 474
if(( eStart == 85 && !(eEnd == 88) ) && ( eStart == 86 && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 474);
}
// MCC Label 475
if(( eStart == 85 && !(eEnd == 88) ) && ( eStart == 86 && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 475);
}
// MCC Label 476
if(( eStart == 85 && !(eEnd == 88) ) && ( !(eStart == 86) && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 476);
}
// MCC Label 477
if(( eStart == 85 && !(eEnd == 88) ) && ( !(eStart == 86) && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 477);
}
// MCC Label 478
if(( eStart == 85 && !(eEnd == 88) ) && ( !(eStart == 86) && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 478);
}
// MCC Label 479
if(( eStart == 85 && !(eEnd == 88) ) && ( !(eStart == 86) && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 479);
}
// MCC Label 480
if(( !(eStart == 85) && eEnd == 88 ) && ( eStart == 86 && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 480);
}
// MCC Label 481
if(( !(eStart == 85) && eEnd == 88 ) && ( eStart == 86 && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 481);
}
// MCC Label 482
if(( !(eStart == 85) && eEnd == 88 ) && ( eStart == 86 && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 482);
}
// MCC Label 483
if(( !(eStart == 85) && eEnd == 88 ) && ( eStart == 86 && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 483);
}
// MCC Label 484
if(( !(eStart == 85) && eEnd == 88 ) && ( !(eStart == 86) && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 484);
}
// MCC Label 485
if(( !(eStart == 85) && eEnd == 88 ) && ( !(eStart == 86) && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 485);
}
// MCC Label 486
if(( !(eStart == 85) && eEnd == 88 ) && ( !(eStart == 86) && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 486);
}
// MCC Label 487
if(( !(eStart == 85) && eEnd == 88 ) && ( !(eStart == 86) && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 487);
}
// MCC Label 488
if(( !(eStart == 85) && !(eEnd == 88) ) && ( eStart == 86 && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 488);
}
// MCC Label 489
if(( !(eStart == 85) && !(eEnd == 88) ) && ( eStart == 86 && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 489);
}
// MCC Label 490
if(( !(eStart == 85) && !(eEnd == 88) ) && ( eStart == 86 && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 490);
}
// MCC Label 491
if(( !(eStart == 85) && !(eEnd == 88) ) && ( eStart == 86 && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 491);
}
// MCC Label 492
if(( !(eStart == 85) && !(eEnd == 88) ) && ( !(eStart == 86) && ( eEnd == 88 && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 492);
}
// MCC Label 493
if(( !(eStart == 85) && !(eEnd == 88) ) && ( !(eStart == 86) && ( eEnd == 88 && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 493);
}
// MCC Label 494
if(( !(eStart == 85) && !(eEnd == 88) ) && ( !(eStart == 86) && ( !(eEnd == 88) && eEnd == 85 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
// MCC Label 495
if(( !(eStart == 85) && !(eEnd == 88) ) && ( !(eStart == 86) && ( !(eEnd == 88) && !(eEnd == 85) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 495);
}
if( (eStart==TK_CURRENT && eEnd==TK_PRECEDING)
   || (eStart==TK_FOLLOWING && (eEnd==TK_PRECEDING || eEnd==TK_CURRENT))
  ){
    
// ABS Label 496
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 496);
}
sqlite3ErrorMsg(pParse, "unsupported frame specification");
    goto windowAllocErr;
  }

  pWin = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  
// ABS Label 497
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// ROR Label 498
if((pWin != 0) != (pWin == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}
if( pWin==0 ) { goto windowAllocErr;
}
  pWin->eFrmType = eType;
  pWin->eStart = eStart;
  pWin->eEnd = eEnd;
  
// COR Label 499
if((eExclude == 0 || (((pParse->db)->dbOptFlags & (2)) != 0)) != (eExclude == 0 && (((pParse->db)->dbOptFlags & (2)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 499);
}

// ROR Label 500
if((eExclude != 0) != (eExclude == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 500);
}

// MCC Label 501
if(eExclude == 0 && ( ((pParse->db)->dbOptFlags & (2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(eExclude == 0 && ( !(((pParse->db)->dbOptFlags & (2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(!(eExclude == 0) && ( ((pParse->db)->dbOptFlags & (2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
// MCC Label 504
if(!(eExclude == 0) && ( !(((pParse->db)->dbOptFlags & (2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
if( eExclude==0 && OptimizationDisabled(pParse->db, SQLITE_WindowFunc) ){
    eExclude = TK_NO;
  }
  pWin->eExclude = eExclude;
  pWin->bImplicitFrame = bImplicitFrame;
  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);
  
// ABS Label 505
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 505);
}
return pWin;

windowAllocErr:
  sqlite3ExprDelete(pParse->db, pEnd);
  
// ABS Label 459
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// ABS Label 460
if(pStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 460);
}
sqlite3ExprDelete(pParse->db, pStart);
  return 0;
}

/*
** Attach PARTITION and ORDER BY clauses pPartition and pOrderBy to window
** pWin. Also, if parameter pBase is not NULL, set pWin->zBase to the
** equivalent nul-terminated string.
*/
Window *sqlite3WindowAssemble(
  Parse *pParse, 
  Window *pWin, 
  ExprList *pPartition, 
  ExprList *pOrderBy, 
  Token *pBase
){
  
// ABS Label 506
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 506);
}
if( pWin ){
    pWin->pPartition = pPartition;
    pWin->pOrderBy = pOrderBy;
    
// ABS Label 507
if(pBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 507);
}
if( pBase ){
      pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, pBase->n);
    }
  }else{
    
// ABS Label 508
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}

// ABS Label 509
if(pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}
sqlite3ExprListDelete(pParse->db, pPartition);
    
// ABS Label 510
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}

// ABS Label 511
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}
sqlite3ExprListDelete(pParse->db, pOrderBy);
  }
  
// ABS Label 512
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}
return pWin;
}

/*
** Window *pWin has just been created from a WINDOW clause. Tokne pBase
** is the base window. Earlier windows from the same WINDOW clause are
** stored in the linked list starting at pWin->pNextWin. This function
** either updates *pWin according to the base specification, or else
** leaves an error in pParse.
*/
void sqlite3WindowChain(Parse *pParse, Window *pWin, Window *pList){
  
// ABS Label 513
if(pWin->zBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}
if( pWin->zBase ){
    
// ABS Label 514
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}
sqlite3 *db = pParse->db;
    Window *pExist = windowFind(pParse, pList, pWin->zBase);
    
// ABS Label 515
if(pExist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}
if( pExist ){
      const char *zErr = 0;
      /* Check for errors */
      
// ABS Label 516
if(pWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}
if( pWin->pPartition ){
        zErr = "PARTITION clause";
      }else { 
// ABS Label 517
if(pExist->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}
// ABS Label 518
if(pWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}

// COR Label 519
if((pExist->pOrderBy || pWin->pOrderBy) != (pExist->pOrderBy && pWin->pOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 519);
}

// MCC Label 520
if(pExist->pOrderBy && pWin->pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 520);
}
// MCC Label 521
if(pExist->pOrderBy && !(pWin->pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 521);
}
// MCC Label 522
if(!(pExist->pOrderBy) && pWin->pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 522);
}
// MCC Label 523
if(!(pExist->pOrderBy) && !(pWin->pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 523);
}
if( pExist->pOrderBy && pWin->pOrderBy ){
        zErr = "ORDER BY clause";
      }else { 
// ROR Label 524
if((pExist->bImplicitFrame != 0) != (pExist->bImplicitFrame == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
if( pExist->bImplicitFrame==0 ){
        zErr = "frame specification";
      };}
;}

      
// ABS Label 525
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}
if( zErr ){
        
// ABS Label 526
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// ABS Label 527
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}

// ABS Label 528
if(pWin->zBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}
sqlite3ErrorMsg(pParse, 
            "cannot override %s of window: %s", zErr, pWin->zBase
        );
      }else{
        pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);
        
// ABS Label 530
if(pExist->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}
if( pExist->pOrderBy ){
          assert( pWin->pOrderBy==0 );
          pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);
        }
        
// ABS Label 529
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}
sqlite3DbFree(db, pWin->zBase);
        pWin->zBase = 0;
      }
    }
  }
}

/*
** Attach window object pWin to expression p.
*/
void sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){
  
// ABS Label 531
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 531);
}
if( p ){
    assert( p->op==TK_FUNCTION );
    assert( pWin );
    p->y.pWin = pWin;
    ExprSetProperty(p, EP_WinFunc);
    pWin->pOwner = p;
    
// COR Label 532
if(((p->flags & 2) || pWin->eFrmType != 165) != ((p->flags & 2) && pWin->eFrmType != 165))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 532);
}

// ROR Label 533
if((pWin->eFrmType == 165) != (pWin->eFrmType != 165))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 533);
}

// MCC Label 534
if(( p->flags & 2 ) && pWin->eFrmType != 165 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 534);
}
// MCC Label 535
if(( p->flags & 2 ) && !(pWin->eFrmType != 165) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 535);
}
// MCC Label 536
if(( !(p->flags & 2) ) && pWin->eFrmType != 165 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 536);
}
// MCC Label 537
if(( !(p->flags & 2) ) && !(pWin->eFrmType != 165) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 537);
}
if( (p->flags & EP_Distinct) && pWin->eFrmType!=TK_FILTER ){
      
// ABS Label 538
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 538);
}
sqlite3ErrorMsg(pParse,
          "DISTINCT is not supported for window functions"
      );
    }
  }else{
    
// ABS Label 539
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}

// ABS Label 540
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}
sqlite3WindowDelete(pParse->db, pWin);
  }
}

/*
** Possibly link window pWin into the list at pSel->pWin (window functions
** to be processed as part of SELECT statement pSel). The window is linked
** in if either (a) there are no other windows already linked to this
** SELECT, or (b) the windows already linked use a compatible window frame.
*/
void sqlite3WindowLink(Select *pSel, Window *pWin){
  
// ABS Label 541
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}
if( pSel ){
    if( 0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0) ){
      pWin->pNextWin = pSel->pWin;
      
// ABS Label 542
if(pSel->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
if( pSel->pWin ){
        pSel->pWin->ppThis = &pWin->pNextWin;
      }
      pSel->pWin = pWin;
      pWin->ppThis = &pSel->pWin;
    }else{
      if( sqlite3ExprListCompare(pWin->pPartition, pSel->pWin->pPartition,-1) ){
        pSel->selFlags |= SF_MultiPart;
      }
    }
  }
}

/*
** Return 0 if the two window objects are identical, 1 if they are
** different, or 2 if it cannot be determined if the objects are identical
** or not. Identical window objects can be processed in a single scan.
*/
int sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2, int bFilter){
  int res;
  
// COR Label 543
if(((p1 == 0) && (p2 == 0)) != ((p1 == 0) || (p2 == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 543);
}

// MCC Label 544
if(( p1 == 0 ) && ( p2 == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 544);
}
// MCC Label 545
if(( p1 == 0 ) && ( !(p2 == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 545);
}
// MCC Label 546
if(( !(p1 == 0) ) && ( p2 == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 546);
}
// MCC Label 547
if(( !(p1 == 0) ) && ( !(p2 == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 547);
}
if( NEVER(p1==0) || NEVER(p2==0) ) { return 1;
}
  
// ROR Label 548
if((p1->eFrmType == p2->eFrmType) != (p1->eFrmType != p2->eFrmType))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 548);
}
if( p1->eFrmType!=p2->eFrmType ) { return 1;
}
  
// ROR Label 549
if((p1->eStart == p2->eStart) != (p1->eStart != p2->eStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 549);
}
if( p1->eStart!=p2->eStart ) { return 1;
}
  
// ROR Label 550
if((p1->eEnd == p2->eEnd) != (p1->eEnd != p2->eEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 550);
}
if( p1->eEnd!=p2->eEnd ) { return 1;
}
  
// ROR Label 551
if((p1->eExclude == p2->eExclude) != (p1->eExclude != p2->eExclude))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 551);
}
if( p1->eExclude!=p2->eExclude ) { return 1;
}
  if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) { return 1;
}
  if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) { return 1;
}
  if( (res = sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1)) ){
    
// ABS Label 552
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}
return res;
  }
  if( (res = sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1)) ){
    
// ABS Label 553
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}
return res;
  }
  
// ABS Label 554
if(bFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}
if( bFilter ){
    if( (res = sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1)) ){
      
// ABS Label 555
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 555);
}
return res;
    }
  }
  return 0;
}


/*
** This is called by code in select.c before it calls sqlite3WhereBegin()
** to begin iterating through the sub-query results. It is used to allocate
** and initialize registers and cursors used by sqlite3WindowCodeStep().
*/
void sqlite3WindowCodeInit(Parse *pParse, Select *pSelect){
  
// ABS Label 556
if(pSelect->pSrc->a[0].pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}
int nEphExpr = pSelect->pSrc->a[0].pSelect->pEList->nExpr;
  
// ABS Label 557
if(pSelect->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}
Window *pMWin = pSelect->pWin;
  Window *pWin;
  Vdbe *v = sqlite3GetVdbe(pParse);

  
// ABS Label 558
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// ABS Label 559
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 559);
}

// ABS Label 560
if(nEphExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 560);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, nEphExpr);
  
// ABS Label 561
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}

// ABS Label 562
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}

// AOR Label 563
if(pMWin->iEphCsr - 1 != pMWin->iEphCsr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 563);
}
// AOR Label 564
if(pMWin->iEphCsr / 1 != pMWin->iEphCsr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 564);
}
// AOR Label 565
if(pMWin->iEphCsr * 1 != pMWin->iEphCsr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 565);
}

// ABS Label 566
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 566);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);
  
// ABS Label 567
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}

// ABS Label 568
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 568);
}

// AOR Label 569
if(pMWin->iEphCsr - 2 != pMWin->iEphCsr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 569);
}
// AOR Label 570
if(pMWin->iEphCsr / 2 != pMWin->iEphCsr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 570);
}
// AOR Label 571
if(pMWin->iEphCsr * 2 != pMWin->iEphCsr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 571);
}

// ABS Label 572
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 572);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);
  
// ABS Label 573
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}

// ABS Label 574
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}

// AOR Label 575
if(pMWin->iEphCsr - 3 != pMWin->iEphCsr + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 575);
}
// AOR Label 576
if(pMWin->iEphCsr / 3 != pMWin->iEphCsr + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 576);
}
// AOR Label 577
if(pMWin->iEphCsr * 3 != pMWin->iEphCsr + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 577);
}

// ABS Label 578
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 578);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);

  /* Allocate registers to use for PARTITION BY values, if any. Initialize
  ** said registers to NULL.  */
  
// ABS Label 581
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 581);
}
if( pMWin->pPartition ){
    
// ABS Label 582
if(pMWin->pPartition->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 582);
}
int nExpr = pMWin->pPartition->nExpr;
    pMWin->regPart = pParse->nMem+1;
    pParse->nMem += nExpr;
    
// ABS Label 583
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 583);
}

// ABS Label 584
if(pMWin->regPart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 584);
}

// ABS Label 585
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 585);
}
// ABS Label 586
if(pMWin->regPart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 586);
}

// AOR Label 587
if(pMWin->regPart + nExpr / 1 != pMWin->regPart + nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 587);
}
// AOR Label 588
if(pMWin->regPart + nExpr + 1 != pMWin->regPart + nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 588);
}
// AOR Label 589
if(pMWin->regPart + nExpr * 1 != pMWin->regPart + nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 589);
}
// AOR Label 590
if(pMWin->regPart - nExpr != pMWin->regPart + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 590);
}
// AOR Label 591
if(pMWin->regPart / nExpr != pMWin->regPart + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 591);
}
// AOR Label 592
if(pMWin->regPart * nExpr != pMWin->regPart + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 592);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, pMWin->regPart, pMWin->regPart+nExpr-1);
  }

  pMWin->regOne = ++pParse->nMem;
  
// ABS Label 579
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}

// ABS Label 580
if(pMWin->regOne < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 580);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regOne);

  
// ABS Label 593
if(pMWin->eExclude < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 593);
}
if( pMWin->eExclude ){
    pMWin->regStartRowid = ++pParse->nMem;
    pMWin->regEndRowid = ++pParse->nMem;
    pMWin->csrApp = pParse->nTab++;
    
// ABS Label 594
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 594);
}

// ABS Label 595
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 595);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);
    
// ABS Label 596
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}

// ABS Label 597
if(pMWin->regEndRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 597);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);
    
// ABS Label 598
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}

// ABS Label 599
if(pMWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}

// ABS Label 600
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 600);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->csrApp, pMWin->iEphCsr);
    return;
  }

  pWin = pMWin;

// ABS Label 601
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 601);
}
for(; pWin; pWin=pWin->pNextWin){
    
// ABS Label 603
if(pWin->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}
FuncDef *p = pWin->pFunc;
    
// COR Label 604
if(((p->funcFlags & 4096) || pWin->eStart != 90) != ((p->funcFlags & 4096) && pWin->eStart != 90))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 604);
}

// ROR Label 605
if((pWin->eStart == 90) != (pWin->eStart != 90))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 605);
}

// MCC Label 606
if(( p->funcFlags & 4096 ) && pWin->eStart != 90 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 606);
}
// MCC Label 607
if(( p->funcFlags & 4096 ) && !(pWin->eStart != 90) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 607);
}
// MCC Label 608
if(( !(p->funcFlags & 4096) ) && pWin->eStart != 90 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 608);
}
// MCC Label 609
if(( !(p->funcFlags & 4096) ) && !(pWin->eStart != 90) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 609);
}
if( (p->funcFlags & SQLITE_FUNC_MINMAX) && pWin->eStart!=TK_UNBOUNDED ){
      /* The inline versions of min() and max() require a single ephemeral
      ** table and 3 registers. The registers are used as follows:
      **
      **   regApp+0: slot to copy min()/max() argument to for MakeRecord
      **   regApp+1: integer value used to ensure keys are unique
      **   regApp+2: output of MakeRecord
      */
      
// ABS Label 610
if(pWin->pOwner->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}
ExprList *pList = pWin->pOwner->x.pList;
      KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);
      pWin->csrApp = pParse->nTab++;
      pWin->regApp = pParse->nMem+1;
      pParse->nMem += 3;
      
// ABS Label 619
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// COR Label 620
if((pKeyInfo || pWin->pFunc->zName[1] == 'i') != (pKeyInfo && pWin->pFunc->zName[1] == 'i'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 620);
}

// ROR Label 621
if((pWin->pFunc->zName[1] != 'i') != (pWin->pFunc->zName[1] == 'i'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}

// MCC Label 622
if(pKeyInfo && pWin->pFunc->zName[1] == 'i' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 622);
}
// MCC Label 623
if(pKeyInfo && !(pWin->pFunc->zName[1] == 'i') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 623);
}
// MCC Label 624
if(!(pKeyInfo) && pWin->pFunc->zName[1] == 'i' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(!(pKeyInfo) && !(pWin->pFunc->zName[1] == 'i') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
if( pKeyInfo && pWin->pFunc->zName[1]=='i' ){
        assert( pKeyInfo->aSortFlags[0]==0 );
        pKeyInfo->aSortFlags[0] = KEYINFO_ORDER_DESC;
      }
      
// ABS Label 611
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}

// ABS Label 612
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pWin->csrApp, 2);
      
// ABS Label 613
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}
sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);
      
// ABS Label 614
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 614);
}

// ABS Label 615
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 615);
}

// AOR Label 616
if(pWin->regApp - 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 616);
}
// AOR Label 617
if(pWin->regApp / 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 617);
}
// AOR Label 618
if(pWin->regApp * 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 618);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);
    }
    else { 
// ABS Label 626
if(p->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 626);
}

// COR Label 627
if((p->zName == nth_valueName && p->zName == first_valueName) != (p->zName == nth_valueName || p->zName == first_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 627);
}

// ROR Label 628
if((p->zName != nth_valueName) != (p->zName == nth_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 628);
}
// ROR Label 629
if((p->zName != first_valueName) != (p->zName == first_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 629);
}

// MCC Label 630
if(p->zName == nth_valueName && p->zName == first_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 630);
}
// MCC Label 631
if(p->zName == nth_valueName && !(p->zName == first_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 631);
}
// MCC Label 632
if(!(p->zName == nth_valueName) && p->zName == first_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 632);
}
// MCC Label 633
if(!(p->zName == nth_valueName) && !(p->zName == first_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 633);
}
if( p->zName==nth_valueName || p->zName==first_valueName ){
      /* Allocate two registers at pWin->regApp. These will be used to
      ** store the start and end index of the current frame.  */
      pWin->regApp = pParse->nMem+1;
      pWin->csrApp = pParse->nTab++;
      pParse->nMem += 2;
      
// ABS Label 634
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}

// ABS Label 635
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}

// ABS Label 636
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 636);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);
    }
    else { 
// ABS Label 637
if(p->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}

// COR Label 638
if((p->zName == leadName && p->zName == lagName) != (p->zName == leadName || p->zName == lagName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 638);
}

// ROR Label 639
if((p->zName != leadName) != (p->zName == leadName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 639);
}
// ROR Label 640
if((p->zName != lagName) != (p->zName == lagName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 640);
}

// MCC Label 641
if(p->zName == leadName && p->zName == lagName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 641);
}
// MCC Label 642
if(p->zName == leadName && !(p->zName == lagName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 642);
}
// MCC Label 643
if(!(p->zName == leadName) && p->zName == lagName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 643);
}
// MCC Label 644
if(!(p->zName == leadName) && !(p->zName == lagName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 644);
}
if( p->zName==leadName || p->zName==lagName ){
      pWin->csrApp = pParse->nTab++;
      
// ABS Label 645
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}

// ABS Label 646
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}

// ABS Label 647
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);
    };}
;}

  };
// ABS Label 602
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}

}

#define WINDOW_STARTING_INT  0
#define WINDOW_ENDING_INT    1
#define WINDOW_NTH_VALUE_INT 2
#define WINDOW_STARTING_NUM  3
#define WINDOW_ENDING_NUM    4

/*
** A "PRECEDING <expr>" (eCond==0) or "FOLLOWING <expr>" (eCond==1) or the
** value of the second argument to nth_value() (eCond==2) has just been
** evaluated and the result left in register reg. This function generates VM
** code to check that the value is a non-negative integer and throws an
** exception if it is not.
*/
static void windowCheckValue(Parse *pParse, int reg, int eCond){
  static const char *azErr[] = {
    "frame starting offset must be a non-negative integer",
    "frame ending offset must be a non-negative integer",
    "second argument to nth_value must be a positive integer",
    "frame starting offset must be a non-negative number",
    "frame ending offset must be a non-negative number",
  };
  static int aOp[] = { OP_Ge, OP_Ge, OP_Gt, OP_Ge, OP_Ge };
  Vdbe *v = sqlite3GetVdbe(pParse);
  int regZero = sqlite3GetTempReg(pParse);
  assert( eCond>=0 && eCond<ArraySize(azErr) );
  
// ABS Label 648
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}

// ABS Label 649
if(regZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regZero);
  
// ABS Label 661
if(eCond < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}

// ROR Label 662
if((eCond < 3) != (eCond >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
// ROR Label 663
if((eCond > 3) != (eCond >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 663);
}
// ROR Label 664
if((eCond <= 3) != (eCond >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 664);
}
if( eCond>=WINDOW_STARTING_NUM ){
    int regString = sqlite3GetTempReg(pParse);
    
// ABS Label 665
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 665);
}

// ABS Label 666
if(regString < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}
sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);
    
// ABS Label 667
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}

// ABS Label 668
if(regString < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}

// ABS Label 669
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}
sqlite3VdbeAddOp3(v, OP_Ge, regString, sqlite3VdbeCurrentAddr(v)+2, reg);
    
// ABS Label 670
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}
sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC|SQLITE_JUMPIFNULL);
    VdbeCoverage(v);
    assert( eCond==3 || eCond==4 );
    VdbeCoverageIf(v, eCond==3);
    VdbeCoverageIf(v, eCond==4);
  }else{
    
// ABS Label 671
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ABS Label 672
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}
sqlite3VdbeAddOp2(v, OP_MustBeInt, reg, sqlite3VdbeCurrentAddr(v)+2);
    VdbeCoverage(v);
    assert( eCond==0 || eCond==1 || eCond==2 );
    VdbeCoverageIf(v, eCond==0);
    VdbeCoverageIf(v, eCond==1);
    VdbeCoverageIf(v, eCond==2);
  }
  
// ABS Label 650
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}

// ABS Label 651
if(aOp[eCond] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}
// ABS Label 652
if(eCond < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}

// ABS Label 653
if(regZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}

// ABS Label 654
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}
sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);
  
// ABS Label 655
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 655);
}
sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC);
  VdbeCoverageNeverNullIf(v, eCond==0); /* NULL case captured by */
  VdbeCoverageNeverNullIf(v, eCond==1); /*   the OP_MustBeInt */
  VdbeCoverageNeverNullIf(v, eCond==2);
  VdbeCoverageNeverNullIf(v, eCond==3); /* NULL case caught by */
  VdbeCoverageNeverNullIf(v, eCond==4); /*   the OP_Ge */
  
// ABS Label 656
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}
sqlite3MayAbort(pParse);
  
// ABS Label 657
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}
sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_ERROR, OE_Abort);
  
// ABS Label 658
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
sqlite3VdbeAppendP4(v, (void*)azErr[eCond], P4_STATIC);
  
// ABS Label 659
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}

// ABS Label 660
if(regZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}
sqlite3ReleaseTempReg(pParse, regZero);
}

/*
** Return the number of arguments passed to the window-function associated
** with the object passed as the only argument to this function.
*/
static int windowArgCount(Window *pWin){
  
// ABS Label 673
if(pWin->pOwner->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}
ExprList *pList = pWin->pOwner->x.pList;
  
// MCC Label 674
if(( ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 674);
}
return (pList ? pList->nExpr : 0);
}

typedef struct WindowCodeArg WindowCodeArg;
typedef struct WindowCsrAndReg WindowCsrAndReg;

/*
** See comments above struct WindowCodeArg.
*/
struct WindowCsrAndReg {
  int csr;                        /* Cursor number */
  int reg;                        /* First in array of peer values */
};

/*
** A single instance of this structure is allocated on the stack by 
** sqlite3WindowCodeStep() and a pointer to it passed to the various helper
** routines. This is to reduce the number of arguments required by each
** helper function.
**
** regArg:
**   Each window function requires an accumulator register (just as an
**   ordinary aggregate function does). This variable is set to the first
**   in an array of accumulator registers - one for each window function
**   in the WindowCodeArg.pMWin list.
**
** eDelete:
**   The window functions implementation sometimes caches the input rows
**   that it processes in a temporary table. If it is not zero, this
**   variable indicates when rows may be removed from the temp table (in
**   order to reduce memory requirements - it would always be safe just
**   to leave them there). Possible values for eDelete are:
**
**      WINDOW_RETURN_ROW:
**        An input row can be discarded after it is returned to the caller.
**
**      WINDOW_AGGINVERSE:
**        An input row can be discarded after the window functions xInverse()
**        callbacks have been invoked in it.
**
**      WINDOW_AGGSTEP:
**        An input row can be discarded after the window functions xStep()
**        callbacks have been invoked in it.
**
** start,current,end
**   Consider a window-frame similar to the following:
**
**     (ORDER BY a, b GROUPS BETWEEN 2 PRECEDING AND 2 FOLLOWING)
**
**   The windows functions implmentation caches the input rows in a temp
**   table, sorted by "a, b" (it actually populates the cache lazily, and
**   aggressively removes rows once they are no longer required, but that's
**   a mere detail). It keeps three cursors open on the temp table. One
**   (current) that points to the next row to return to the query engine
**   once its window function values have been calculated. Another (end)
**   points to the next row to call the xStep() method of each window function
**   on (so that it is 2 groups ahead of current). And a third (start) that
**   points to the next row to call the xInverse() method of each window
**   function on.
**
**   Each cursor (start, current and end) consists of a VDBE cursor
**   (WindowCsrAndReg.csr) and an array of registers (starting at
**   WindowCodeArg.reg) that always contains a copy of the peer values 
**   read from the corresponding cursor.
**
**   Depending on the window-frame in question, all three cursors may not
**   be required. In this case both WindowCodeArg.csr and reg are set to
**   0.
*/
struct WindowCodeArg {
  Parse *pParse;             /* Parse context */
  Window *pMWin;             /* First in list of functions being processed */
  Vdbe *pVdbe;               /* VDBE object */
  int addrGosub;             /* OP_Gosub to this address to return one row */
  int regGosub;              /* Register used with OP_Gosub(addrGosub) */
  int regArg;                /* First in array of accumulator registers */
  int eDelete;               /* See above */
  int regRowid;

  WindowCsrAndReg start;
  WindowCsrAndReg current;
  WindowCsrAndReg end;
};

/*
** Generate VM code to read the window frames peer values from cursor csr into
** an array of registers starting at reg.
*/
static void windowReadPeerValues(
  WindowCodeArg *p,
  int csr,
  int reg
){
  
// ABS Label 675
if(p->pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}
Window *pMWin = p->pMWin;
  
// ABS Label 676
if(pMWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}
ExprList *pOrderBy = pMWin->pOrderBy;
  
// ABS Label 677
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}
if( pOrderBy ){
    Vdbe *v = sqlite3GetVdbe(p->pParse);
    
// ABS Label 678
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
ExprList *pPart = pMWin->pPartition;
    
// ABS Label 679
if(pMWin->nBufferCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}

// AOR Label 680
if(pMWin->nBufferCol - (pPart ? pPart->nExpr : 0) != pMWin->nBufferCol + (pPart ? pPart->nExpr : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 680);
}
// AOR Label 681
if(pMWin->nBufferCol / (pPart ? pPart->nExpr : 0) != pMWin->nBufferCol + (pPart ? pPart->nExpr : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 681);
}
// AOR Label 682
if(pMWin->nBufferCol * (pPart ? pPart->nExpr : 0) != pMWin->nBufferCol + (pPart ? pPart->nExpr : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 682);
}
int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
    int i;
    i = 0;

// ABS Label 683
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}
// ABS Label 684
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 684);
}

// ROR Label 685
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 685);
}
// ROR Label 686
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 686);
}
// ROR Label 687
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 687);
}
for(; i<pOrderBy->nExpr; i++){
      
// ABS Label 693
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 693);
}

// ABS Label 694
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}

// ABS Label 695
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}
// ABS Label 696
if(iColOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}

// AOR Label 697
if(iColOff - i != iColOff + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 697);
}
// AOR Label 698
if(iColOff / i != iColOff + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 698);
}
// AOR Label 699
if(iColOff * i != iColOff + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 699);
}

// ABS Label 700
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}
// ABS Label 701
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}

// AOR Label 702
if(reg - i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 702);
}
// AOR Label 703
if(reg / i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 703);
}
// AOR Label 704
if(reg * i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 704);
}
sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);
    };
// ABS Label 688
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}
// ABS Label 689
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}

// ROR Label 690
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 690);
}
// ROR Label 691
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 691);
}
// ROR Label 692
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 692);
}

  }
}

/*
** Generate VM code to invoke either xStep() (if bInverse is 0) or 
** xInverse (if bInverse is non-zero) for each window function in the 
** linked list starting at pMWin. Or, for built-in window functions
** that do not use the standard function API, generate the required
** inline VM code.
**
** If argument csr is greater than or equal to 0, then argument reg is
** the first register in an array of registers guaranteed to be large
** enough to hold the array of arguments for each function. In this case
** the arguments are extracted from the current row of csr into the
** array of registers before invoking OP_AggStep or OP_AggInverse
**
** Or, if csr is less than zero, then the array of registers at reg is
** already populated with all columns from the current row of the sub-query.
**
** If argument regPartSize is non-zero, then it is a register containing the
** number of rows in the current partition.
*/
static void windowAggStep(
  WindowCodeArg *p,
  Window *pMWin,                  /* Linked list of window functions */
  int csr,                        /* Read arguments from this cursor */
  int bInverse,                   /* True to invoke xInverse instead of xStep */
  int reg                         /* Array of registers */
){
  
// ABS Label 705
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}
Parse *pParse = p->pParse;
  Vdbe *v = sqlite3GetVdbe(pParse);
  Window *pWin;
  pWin = pMWin;

// ABS Label 706
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}
for(; pWin; pWin=pWin->pNextWin){
    
// ABS Label 708
if(pWin->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 708);
}
FuncDef *pFunc = pWin->pFunc;
    int regArg;
    int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);
    int i;

    assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );

    /* All OVER clauses in the same window function aggregate step must
    ** be the same. */
    assert( pWin==pMWin || sqlite3WindowCompare(pParse,pWin,pMWin,0)!=1 );

    i = 0;

// ABS Label 709
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}
// ABS Label 710
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}

// ROR Label 711
if((i <= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 711);
}
// ROR Label 712
if((i > nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 712);
}
// ROR Label 713
if((i >= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 713);
}
for(; i<nArg; i++){
      
// ABS Label 719
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}
// ABS Label 720
if(pFunc->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 720);
}

// COR Label 721
if((i != 1 && pFunc->zName != nth_valueName) != (i != 1 || pFunc->zName != nth_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 721);
}

// ROR Label 722
if((i == 1) != (i != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 722);
}
// ROR Label 723
if((pFunc->zName == nth_valueName) != (pFunc->zName != nth_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}

// MCC Label 724
if(i != 1 && pFunc->zName != nth_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 724);
}
// MCC Label 725
if(i != 1 && !(pFunc->zName != nth_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 725);
}
// MCC Label 726
if(!(i != 1) && pFunc->zName != nth_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 726);
}
// MCC Label 727
if(!(i != 1) && !(pFunc->zName != nth_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 727);
}
if( i!=1 || pFunc->zName!=nth_valueName ){
        
// ABS Label 728
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}

// ABS Label 729
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}

// ABS Label 730
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
// ABS Label 731
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

// AOR Label 732
if(pWin->iArgCol - i != pWin->iArgCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 732);
}
// AOR Label 733
if(pWin->iArgCol / i != pWin->iArgCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 733);
}
// AOR Label 734
if(pWin->iArgCol * i != pWin->iArgCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 734);
}

// ABS Label 735
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 735);
}
// ABS Label 736
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// AOR Label 737
if(reg - i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 737);
}
// AOR Label 738
if(reg / i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 738);
}
// AOR Label 739
if(reg * i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 739);
}
sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+i, reg+i);
      }else{
        
// ABS Label 740
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}

// ABS Label 741
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}

// ABS Label 742
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}
// ABS Label 743
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}

// AOR Label 744
if(pWin->iArgCol - i != pWin->iArgCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 744);
}
// AOR Label 745
if(pWin->iArgCol / i != pWin->iArgCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 745);
}
// AOR Label 746
if(pWin->iArgCol * i != pWin->iArgCol + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 746);
}

// ABS Label 747
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}
// ABS Label 748
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// AOR Label 749
if(reg - i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 749);
}
// AOR Label 750
if(reg / i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 750);
}
// AOR Label 751
if(reg * i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 751);
}
sqlite3VdbeAddOp3(v, OP_Column, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);
      }
    };
// ABS Label 714
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}
// ABS Label 715
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 715);
}

// ROR Label 716
if((i <= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 716);
}
// ROR Label 717
if((i > nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 717);
}
// ROR Label 718
if((i >= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 718);
}

    regArg = reg;

    
// ABS Label 752
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 752);
}

// COR Label 753
if((pMWin->regStartRowid == 0 && (pFunc->funcFlags & 4096) || (pWin->eStart != 90)) != (pMWin->regStartRowid == 0 && (pFunc->funcFlags & 4096) && (pWin->eStart != 90)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 753);
}
// COR Label 754
if((pMWin->regStartRowid == 0 || (pFunc->funcFlags & 4096)) != (pMWin->regStartRowid == 0 && (pFunc->funcFlags & 4096)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 754);
}

// ROR Label 755
if((pMWin->regStartRowid != 0) != (pMWin->regStartRowid == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 755);
}

// MCC Label 756
if(pMWin->regStartRowid == 0 && ( pFunc->funcFlags & 4096 ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 756);
}
// MCC Label 757
if(pMWin->regStartRowid == 0 && ( pFunc->funcFlags & 4096 ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 757);
}
// MCC Label 758
if(pMWin->regStartRowid == 0 && ( !(pFunc->funcFlags & 4096) ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 758);
}
// MCC Label 759
if(pMWin->regStartRowid == 0 && ( !(pFunc->funcFlags & 4096) ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 759);
}
// MCC Label 760
if(!(pMWin->regStartRowid == 0) && ( pFunc->funcFlags & 4096 ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 760);
}
// MCC Label 761
if(!(pMWin->regStartRowid == 0) && ( pFunc->funcFlags & 4096 ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 761);
}
// MCC Label 762
if(!(pMWin->regStartRowid == 0) && ( !(pFunc->funcFlags & 4096) ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 762);
}
// MCC Label 763
if(!(pMWin->regStartRowid == 0) && ( !(pFunc->funcFlags & 4096) ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 763);
}
if( pMWin->regStartRowid==0
     && (pFunc->funcFlags & SQLITE_FUNC_MINMAX) 
     && (pWin->eStart!=TK_UNBOUNDED)
    ){
      int addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regArg);
      VdbeCoverage(v);
      
// ABS Label 766
if(bInverse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 766);
}

// ROR Label 767
if((bInverse != 0) != (bInverse == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 767);
}
if( bInverse==0 ){
        
// ABS Label 768
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}

// ABS Label 769
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 769);
}

// AOR Label 770
if(pWin->regApp - 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 770);
}
// AOR Label 771
if(pWin->regApp / 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 771);
}
// AOR Label 772
if(pWin->regApp * 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 772);
}
sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1, 1);
        
// ABS Label 773
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}

// ABS Label 774
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}

// ABS Label 775
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}
sqlite3VdbeAddOp2(v, OP_SCopy, regArg, pWin->regApp);
        
// ABS Label 776
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}

// ABS Label 777
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ABS Label 778
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}

// AOR Label 779
if(pWin->regApp - 2 != pWin->regApp + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 779);
}
// AOR Label 780
if(pWin->regApp / 2 != pWin->regApp + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 780);
}
// AOR Label 781
if(pWin->regApp * 2 != pWin->regApp + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 781);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2, pWin->regApp+2);
        
// ABS Label 782
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}

// ABS Label 783
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}

// ABS Label 784
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}

// AOR Label 785
if(pWin->regApp - 2 != pWin->regApp + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 785);
}
// AOR Label 786
if(pWin->regApp / 2 != pWin->regApp + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 786);
}
// AOR Label 787
if(pWin->regApp * 2 != pWin->regApp + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 787);
}
sqlite3VdbeAddOp2(v, OP_IdxInsert, pWin->csrApp, pWin->regApp+2);
      }else{
        
// ABS Label 788
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}

// ABS Label 789
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}

// ABS Label 790
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}
sqlite3VdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0, regArg, 1);
        VdbeCoverageNeverTaken(v);
        
// ABS Label 791
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}

// ABS Label 792
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}
sqlite3VdbeAddOp1(v, OP_Delete, pWin->csrApp);
        
// ABS Label 793
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}
sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      }
      
// ABS Label 764
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// ABS Label 765
if(addrIsNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}
sqlite3VdbeJumpHere(v, addrIsNull);
    }else { 
// ABS Label 794
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}
if( pWin->regApp ){
      assert( pFunc->zName==nth_valueName
           || pFunc->zName==first_valueName
      );
      assert( bInverse==0 || bInverse==1 );
      
// ABS Label 795
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}

// ABS Label 796
if(bInverse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}
// ABS Label 797
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}

// AOR Label 798
if(pWin->regApp + 1 / bInverse != pWin->regApp + 1 - bInverse)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 798);
}
// AOR Label 799
if(pWin->regApp + 1 + bInverse != pWin->regApp + 1 - bInverse)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 799);
}
// AOR Label 800
if(pWin->regApp + 1 * bInverse != pWin->regApp + 1 - bInverse)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 800);
}
// AOR Label 801
if(pWin->regApp - 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 801);
}
// AOR Label 802
if(pWin->regApp / 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 802);
}
// AOR Label 803
if(pWin->regApp * 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 803);
}
sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1-bInverse, 1);
    }else { 
// ABS Label 804
if(pFunc->xSFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}

// ROR Label 805
if((pFunc->xSFunc == noopStepFunc) != (pFunc->xSFunc != noopStepFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 805);
}
if( pFunc->xSFunc!=noopStepFunc ){
      int addrIf = 0;
      
// ABS Label 812
if(pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}
if( pWin->pFilter ){
        int regTmp;
        assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );
        assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );
        regTmp = sqlite3GetTempReg(pParse);
        
// ABS Label 813
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}

// ABS Label 814
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ABS Label 815
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}
// ABS Label 816
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// AOR Label 817
if(pWin->iArgCol - nArg != pWin->iArgCol + nArg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 817);
}
// AOR Label 818
if(pWin->iArgCol / nArg != pWin->iArgCol + nArg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 818);
}
// AOR Label 819
if(pWin->iArgCol * nArg != pWin->iArgCol + nArg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 819);
}

// ABS Label 820
if(regTmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);
        addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);
        VdbeCoverage(v);
        
// ABS Label 821
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}

// ABS Label 822
if(regTmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}
sqlite3ReleaseTempReg(pParse, regTmp);
      }
      
      
// ABS Label 823
if(pWin->bExprArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}
if( pWin->bExprArgs ){
        int iOp = sqlite3VdbeCurrentAddr(v);
        int iEnd;

        nArg = pWin->pOwner->x.pList->nExpr;
        regArg = sqlite3GetTempRange(pParse, nArg);
        
// ABS Label 824
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ABS Label 825
if(pWin->pOwner->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}

// ABS Label 826
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}
sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);

        iEnd = sqlite3VdbeCurrentAddr(v);

// ABS Label 827
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
// ABS Label 828
if(iOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// ROR Label 829
if((iOp <= iEnd) != (iOp < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 829);
}
// ROR Label 830
if((iOp > iEnd) != (iOp < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}
// ROR Label 831
if((iOp >= iEnd) != (iOp < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 831);
}
for(; iOp<iEnd; iOp++){
          VdbeOp *pOp = sqlite3VdbeGetOp(v, iOp);
          
// ABS Label 837
if(pOp->p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 837);
}
// ABS Label 838
if(pWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}

// COR Label 839
if((pOp->opcode == 91 || pOp->p1 == pWin->iEphCsr) != (pOp->opcode == 91 && pOp->p1 == pWin->iEphCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 839);
}

// ROR Label 840
if((pOp->opcode != 91) != (pOp->opcode == 91))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 840);
}
// ROR Label 841
if((pOp->p1 != pWin->iEphCsr) != (pOp->p1 == pWin->iEphCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 841);
}

// MCC Label 842
if(pOp->opcode == 91 && pOp->p1 == pWin->iEphCsr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 842);
}
// MCC Label 843
if(pOp->opcode == 91 && !(pOp->p1 == pWin->iEphCsr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 843);
}
// MCC Label 844
if(!(pOp->opcode == 91) && pOp->p1 == pWin->iEphCsr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 844);
}
// MCC Label 845
if(!(pOp->opcode == 91) && !(pOp->p1 == pWin->iEphCsr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 845);
}
if( pOp->opcode==OP_Column && pOp->p1==pWin->iEphCsr ){
            pOp->p1 = csr;
          }
        };
// ABS Label 832
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 832);
}
// ABS Label 833
if(iOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}

// ROR Label 834
if((iOp <= iEnd) != (iOp < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 834);
}
// ROR Label 835
if((iOp > iEnd) != (iOp < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 835);
}
// ROR Label 836
if((iOp >= iEnd) != (iOp < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 836);
}

      }
      
// ABS Label 846
if(pFunc->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}

// AOR Label 847
if(pFunc->funcFlags | 32 != pFunc->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 847);
}
// AOR Label 848
if(pFunc->funcFlags ^ 32 != pFunc->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 848);
}
if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
        CollSeq *pColl;
        assert( nArg>0 );
        pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);
        
// ABS Label 849
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}
sqlite3VdbeAddOp4(v, OP_CollSeq, 0,0,0, (const char*)pColl, P4_COLLSEQ);
      }
      
// ABS Label 806
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}

// ABS Label 807
if(bInverse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}

// ABS Label 808
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}

// ABS Label 809
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}
sqlite3VdbeAddOp3(v, bInverse? OP_AggInverse : OP_AggStep, 
                        bInverse, regArg, pWin->regAccum);
      
// ABS Label 810
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}
sqlite3VdbeAppendP4(v, pFunc, P4_FUNCDEF);
      
// ABS Label 811
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
sqlite3VdbeChangeP5(v, (u8)nArg);
      
// ABS Label 850
if(pWin->bExprArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}
if( pWin->bExprArgs ){
        
// ABS Label 851
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}

// ABS Label 852
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}

// ABS Label 853
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 853);
}
sqlite3ReleaseTempRange(pParse, regArg, nArg);
      }
      
// ABS Label 854
if(addrIf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}
if( addrIf ) { 
// ABS Label 855
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}

// ABS Label 856
if(addrIf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}
sqlite3VdbeJumpHere(v, addrIf);
}
    };}
;}

  };
// ABS Label 707
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}

}

/*
** Values that may be passed as the second argument to windowCodeOp().
*/
#define WINDOW_RETURN_ROW 1
#define WINDOW_AGGINVERSE 2
#define WINDOW_AGGSTEP    3

/*
** Generate VM code to invoke either xValue() (bFin==0) or xFinalize()
** (bFin==1) for each window function in the linked list starting at
** pMWin. Or, for built-in window-functions that do not use the standard
** API, generate the equivalent VM code.
*/
static void windowAggFinal(WindowCodeArg *p, int bFin){
  
// ABS Label 857
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 857);
}
Parse *pParse = p->pParse;
  
// ABS Label 858
if(p->pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
Window *pMWin = p->pMWin;
  Vdbe *v = sqlite3GetVdbe(pParse);
  Window *pWin;

  pWin = pMWin;

// ABS Label 859
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}
for(; pWin; pWin=pWin->pNextWin){
    
// ABS Label 861
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 861);
}

// COR Label 862
if((pMWin->regStartRowid == 0 && (pWin->pFunc->funcFlags & 4096) || (pWin->eStart != 90)) != (pMWin->regStartRowid == 0 && (pWin->pFunc->funcFlags & 4096) && (pWin->eStart != 90)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 862);
}
// COR Label 863
if((pMWin->regStartRowid == 0 || (pWin->pFunc->funcFlags & 4096)) != (pMWin->regStartRowid == 0 && (pWin->pFunc->funcFlags & 4096)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 863);
}

// ROR Label 864
if((pMWin->regStartRowid != 0) != (pMWin->regStartRowid == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}

// MCC Label 865
if(pMWin->regStartRowid == 0 && ( pWin->pFunc->funcFlags & 4096 ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 865);
}
// MCC Label 866
if(pMWin->regStartRowid == 0 && ( pWin->pFunc->funcFlags & 4096 ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 866);
}
// MCC Label 867
if(pMWin->regStartRowid == 0 && ( !(pWin->pFunc->funcFlags & 4096) ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 867);
}
// MCC Label 868
if(pMWin->regStartRowid == 0 && ( !(pWin->pFunc->funcFlags & 4096) ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 868);
}
// MCC Label 869
if(!(pMWin->regStartRowid == 0) && ( pWin->pFunc->funcFlags & 4096 ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 869);
}
// MCC Label 870
if(!(pMWin->regStartRowid == 0) && ( pWin->pFunc->funcFlags & 4096 ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 870);
}
// MCC Label 871
if(!(pMWin->regStartRowid == 0) && ( !(pWin->pFunc->funcFlags & 4096) ) && ( pWin->eStart != 90 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 871);
}
// MCC Label 872
if(!(pMWin->regStartRowid == 0) && ( !(pWin->pFunc->funcFlags & 4096) ) && ( !(pWin->eStart != 90) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 872);
}
if( pMWin->regStartRowid==0
     && (pWin->pFunc->funcFlags & SQLITE_FUNC_MINMAX) 
     && (pWin->eStart!=TK_UNBOUNDED)
    ){
      
// ABS Label 873
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// ABS Label 874
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 874);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);
      
// ABS Label 875
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 875);
}

// ABS Label 876
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}
sqlite3VdbeAddOp1(v, OP_Last, pWin->csrApp);
      VdbeCoverage(v);
      
// ABS Label 877
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}

// ABS Label 878
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 878);
}

// ABS Label 879
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 879);
}
sqlite3VdbeAddOp3(v, OP_Column, pWin->csrApp, 0, pWin->regResult);
      
// ABS Label 880
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 880);
}
sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
    }else { 
// ABS Label 881
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 881);
}
if( pWin->regApp ){
      assert( pMWin->regStartRowid==0 );
    }else{
      int nArg = windowArgCount(pWin);
      
// ABS Label 882
if(bFin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}
if( bFin ){
        
// ABS Label 883
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}

// ABS Label 884
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 884);
}

// ABS Label 885
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 885);
}
sqlite3VdbeAddOp2(v, OP_AggFinal, pWin->regAccum, nArg);
        
// ABS Label 886
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 886);
}
sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);
        
// ABS Label 887
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 887);
}

// ABS Label 888
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 888);
}

// ABS Label 889
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 889);
}
sqlite3VdbeAddOp2(v, OP_Copy, pWin->regAccum, pWin->regResult);
        
// ABS Label 890
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 890);
}

// ABS Label 891
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
      }else{
        
// ABS Label 892
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 892);
}

// ABS Label 893
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}

// ABS Label 894
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}

// ABS Label 895
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}
sqlite3VdbeAddOp3(v, OP_AggValue,pWin->regAccum,nArg,pWin->regResult);
        
// ABS Label 896
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}
sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);
      }
    };}

  };
// ABS Label 860
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}

}

/*
** Generate code to calculate the current values of all window functions in the
** p->pMWin list by doing a full scan of the current window frame. Store the
** results in the Window.regResult registers, ready to return the upper
** layer.
*/
static void windowFullScan(WindowCodeArg *p){
  Window *pWin;
  
// ABS Label 897
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}
Parse *pParse = p->pParse;
  
// ABS Label 898
if(p->pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 898);
}
Window *pMWin = p->pMWin;
  
// ABS Label 899
if(p->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 899);
}
Vdbe *v = p->pVdbe;

  int regCRowid = 0;              /* Current rowid value */
  int regCPeer = 0;               /* Current peer values */
  int regRowid = 0;               /* AggStep rowid value */
  int regPeer = 0;                /* AggStep peer values */

  int nPeer;
  int lblNext;
  int lblBrk;
  int addrNext;
  int csr;

  VdbeModuleComment((v, "windowFullScan begin"));

  assert( pMWin!=0 );
  csr = pMWin->csrApp;
  nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);

  lblNext = sqlite3VdbeMakeLabel(pParse);
  lblBrk = sqlite3VdbeMakeLabel(pParse);

  regCRowid = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  
// ABS Label 941
if(nPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 941);
}
if( nPeer ){
    regCPeer = sqlite3GetTempRange(pParse, nPeer);
    regPeer = sqlite3GetTempRange(pParse, nPeer);
  }

  
// ABS Label 900
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 900);
}

// ABS Label 901
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 901);
}

// ABS Label 902
if(regCRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 902);
}
sqlite3VdbeAddOp2(v, OP_Rowid, pMWin->iEphCsr, regCRowid);
  
// ABS Label 903
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 903);
}

// ABS Label 904
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 904);
}

// ABS Label 905
if(regCPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}
windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);

  pWin = pMWin;

// ABS Label 942
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 942);
}
for(; pWin; pWin=pWin->pNextWin){
    
// ABS Label 944
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}

// ABS Label 945
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
  };
// ABS Label 943
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}


  
// ABS Label 906
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 906);
}

// ABS Label 907
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 907);
}

// ABS Label 908
if(lblBrk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 908);
}

// ABS Label 909
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 909);
}
sqlite3VdbeAddOp3(v, OP_SeekGE, csr, lblBrk, pMWin->regStartRowid);
  VdbeCoverage(v);
  addrNext = sqlite3VdbeCurrentAddr(v);
  
// ABS Label 910
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}

// ABS Label 911
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}

// ABS Label 912
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 912);
}
sqlite3VdbeAddOp2(v, OP_Rowid, csr, regRowid);
  
// ABS Label 913
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 913);
}

// ABS Label 914
if(pMWin->regEndRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 914);
}

// ABS Label 915
if(lblBrk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 915);
}

// ABS Label 916
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 916);
}
sqlite3VdbeAddOp3(v, OP_Gt, pMWin->regEndRowid, lblBrk, regRowid);
  VdbeCoverageNeverNull(v);

  
// ROR Label 946
if((pMWin->eExclude != 85) != (pMWin->eExclude == 85))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 946);
}
if( pMWin->eExclude==TK_CURRENT ){
    
// ABS Label 947
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}

// ABS Label 948
if(regCRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 948);
}

// ABS Label 949
if(lblNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 949);
}

// ABS Label 950
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 950);
}
sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, lblNext, regRowid);
    VdbeCoverageNeverNull(v);
  }else { 
// ROR Label 951
if((pMWin->eExclude == 66) != (pMWin->eExclude != 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 951);
}
if( pMWin->eExclude!=TK_NO ){
    int addr;
    int addrEq = 0;
    KeyInfo *pKeyInfo = 0;

    
// ABS Label 952
if(pMWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 952);
}
if( pMWin->pOrderBy ){
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);
    }
    
// ROR Label 953
if((pMWin->eExclude != 94) != (pMWin->eExclude == 94))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 953);
}
if( pMWin->eExclude==TK_TIES ){
      addrEq = sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, 0, regRowid);
      VdbeCoverageNeverNull(v);
    }
    
// ABS Label 954
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 954);
}
if( pKeyInfo ){
      
// ABS Label 955
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 955);
}

// ABS Label 956
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 956);
}

// ABS Label 957
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 957);
}
windowReadPeerValues(p, csr, regPeer);
      
// ABS Label 958
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 958);
}

// ABS Label 959
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 959);
}

// ABS Label 960
if(regCPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 960);
}

// ABS Label 961
if(nPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 961);
}
sqlite3VdbeAddOp3(v, OP_Compare, regPeer, regCPeer, nPeer);
      
// ABS Label 962
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 962);
}
sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);
      addr = sqlite3VdbeCurrentAddr(v)+1;
      
// ABS Label 963
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}

// ABS Label 964
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 964);
}

// ABS Label 965
if(lblNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// ABS Label 966
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 966);
}
sqlite3VdbeAddOp3(v, OP_Jump, addr, lblNext, addr);
      VdbeCoverageEqNe(v);
    }else{
      
// ABS Label 967
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 967);
}

// ABS Label 968
if(lblNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 968);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, lblNext);
    }
    
// ABS Label 969
if(addrEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 969);
}
if( addrEq ) { 
// ABS Label 970
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}

// ABS Label 971
if(addrEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 971);
}
sqlite3VdbeJumpHere(v, addrEq);
}
  };}


  
// ABS Label 917
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ABS Label 918
if(pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 918);
}

// ABS Label 919
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}

// ABS Label 920
if(p->regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}
windowAggStep(p, pMWin, csr, 0, p->regArg);

  
// ABS Label 921
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}

// ABS Label 922
if(lblNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}
sqlite3VdbeResolveLabel(v, lblNext);
  
// ABS Label 923
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}

// ABS Label 924
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 924);
}

// ABS Label 925
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 925);
}
sqlite3VdbeAddOp2(v, OP_Next, csr, addrNext);
  VdbeCoverage(v);
  
// ABS Label 926
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 926);
}

// ABS Label 927
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 927);
}

// AOR Label 928
if(addrNext / 1 != addrNext - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 928);
}
// AOR Label 929
if(addrNext + 1 != addrNext - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 929);
}
// AOR Label 930
if(addrNext * 1 != addrNext - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 930);
}
sqlite3VdbeJumpHere(v, addrNext-1);
  
// ABS Label 931
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 931);
}

// ABS Label 932
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 932);
}

// AOR Label 933
if(addrNext - 1 != addrNext + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 933);
}
// AOR Label 934
if(addrNext / 1 != addrNext + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 934);
}
// AOR Label 935
if(addrNext * 1 != addrNext + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 935);
}
sqlite3VdbeJumpHere(v, addrNext+1);
  
// ABS Label 936
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 936);
}

// ABS Label 937
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}
sqlite3ReleaseTempReg(pParse, regRowid);
  
// ABS Label 938
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}

// ABS Label 939
if(regCRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}
sqlite3ReleaseTempReg(pParse, regCRowid);
  
// ABS Label 972
if(nPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 972);
}
if( nPeer ){
    
// ABS Label 973
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 973);
}

// ABS Label 974
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 974);
}

// ABS Label 975
if(nPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 975);
}
sqlite3ReleaseTempRange(pParse, regPeer, nPeer);
    
// ABS Label 976
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}

// ABS Label 977
if(regCPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 977);
}

// ABS Label 978
if(nPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}
sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);
  }

  
// ABS Label 940
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}
windowAggFinal(p, 1);
  VdbeModuleComment((v, "windowFullScan end"));
}

/*
** Invoke the sub-routine at regGosub (generated by code in select.c) to
** return the current row of Window.iEphCsr. If all window functions are
** aggregate window functions that use the standard API, a single
** OP_Gosub instruction is all that this routine generates. Extra VM code
** for per-row processing is only generated for the following built-in window
** functions:
**
**   nth_value()
**   first_value()
**   lag()
**   lead()
*/
static void windowReturnOneRow(WindowCodeArg *p){
  
// ABS Label 979
if(p->pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 979);
}
Window *pMWin = p->pMWin;
  
// ABS Label 980
if(p->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}
Vdbe *v = p->pVdbe;

  
// ABS Label 984
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 984);
}
if( pMWin->regStartRowid ){
    
// ABS Label 985
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}
windowFullScan(p);
  }else{
    
// ABS Label 986
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}
Parse *pParse = p->pParse;
    Window *pWin;

    pWin = pMWin;

// ABS Label 987
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 987);
}
for(; pWin; pWin=pWin->pNextWin){
      
// ABS Label 989
if(pWin->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 989);
}
FuncDef *pFunc = pWin->pFunc;
      
// ABS Label 990
if(pFunc->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 990);
}

// COR Label 991
if((pFunc->zName == nth_valueName && pFunc->zName == first_valueName) != (pFunc->zName == nth_valueName || pFunc->zName == first_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 991);
}

// ROR Label 992
if((pFunc->zName != nth_valueName) != (pFunc->zName == nth_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 992);
}
// ROR Label 993
if((pFunc->zName != first_valueName) != (pFunc->zName == first_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 993);
}

// MCC Label 994
if(pFunc->zName == nth_valueName && pFunc->zName == first_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 994);
}
// MCC Label 995
if(pFunc->zName == nth_valueName && !(pFunc->zName == first_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 995);
}
// MCC Label 996
if(!(pFunc->zName == nth_valueName) && pFunc->zName == first_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 996);
}
// MCC Label 997
if(!(pFunc->zName == nth_valueName) && !(pFunc->zName == first_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 997);
}
if( pFunc->zName==nth_valueName
       || pFunc->zName==first_valueName
      ){
        
// ABS Label 998
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}
int csr = pWin->csrApp;
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int tmpReg = sqlite3GetTempReg(pParse);
        
// ABS Label 999
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}

// ABS Label 1000
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);
  
        
// ABS Label 1023
if(pFunc->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}

// ROR Label 1024
if((pFunc->zName != nth_valueName) != (pFunc->zName == nth_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1024);
}
if( pFunc->zName==nth_valueName ){
          
// ABS Label 1025
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1025);
}

// ABS Label 1026
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1026);
}

// ABS Label 1027
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1027);
}

// AOR Label 1028
if(pWin->iArgCol - 1 != pWin->iArgCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1028);
}
// AOR Label 1029
if(pWin->iArgCol / 1 != pWin->iArgCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1029);
}
// AOR Label 1030
if(pWin->iArgCol * 1 != pWin->iArgCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1030);
}

// ABS Label 1031
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}
sqlite3VdbeAddOp3(v, OP_Column,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);
          
// ABS Label 1032
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}

// ABS Label 1033
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}
windowCheckValue(pParse, tmpReg, 2);
        }else{
          
// ABS Label 1034
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1034);
}

// ABS Label 1035
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1035);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, tmpReg);
        }
        
// ABS Label 1001
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1001);
}

// ABS Label 1002
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}

// ABS Label 1003
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// ABS Label 1004
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1004);
}
sqlite3VdbeAddOp3(v, OP_Add, tmpReg, pWin->regApp, tmpReg);
        
// ABS Label 1005
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1005);
}

// ABS Label 1006
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}

// AOR Label 1007
if(pWin->regApp - 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1007);
}
// AOR Label 1008
if(pWin->regApp / 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1008);
}
// AOR Label 1009
if(pWin->regApp * 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1009);
}

// ABS Label 1010
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1010);
}

// ABS Label 1011
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1011);
}
sqlite3VdbeAddOp3(v, OP_Gt, pWin->regApp+1, lbl, tmpReg);
        VdbeCoverageNeverNull(v);
        
// ABS Label 1012
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1012);
}

// ABS Label 1013
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1013);
}

// ABS Label 1014
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1014);
}
sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, 0, tmpReg);
        VdbeCoverageNeverTaken(v);
        
// ABS Label 1015
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}

// ABS Label 1016
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}

// ABS Label 1017
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}

// ABS Label 1018
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1018);
}
sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);
        
// ABS Label 1019
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}

// ABS Label 1020
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1020);
}
sqlite3VdbeResolveLabel(v, lbl);
        
// ABS Label 1021
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1021);
}

// ABS Label 1022
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1022);
}
sqlite3ReleaseTempReg(pParse, tmpReg);
      }
      else { 
// ABS Label 1036
if(pFunc->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1036);
}

// COR Label 1037
if((pFunc->zName == leadName && pFunc->zName == lagName) != (pFunc->zName == leadName || pFunc->zName == lagName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1037);
}

// ROR Label 1038
if((pFunc->zName != leadName) != (pFunc->zName == leadName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1038);
}
// ROR Label 1039
if((pFunc->zName != lagName) != (pFunc->zName == lagName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1039);
}

// MCC Label 1040
if(pFunc->zName == leadName && pFunc->zName == lagName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1040);
}
// MCC Label 1041
if(pFunc->zName == leadName && !(pFunc->zName == lagName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1041);
}
// MCC Label 1042
if(!(pFunc->zName == leadName) && pFunc->zName == lagName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1042);
}
// MCC Label 1043
if(!(pFunc->zName == leadName) && !(pFunc->zName == lagName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1043);
}
if( pFunc->zName==leadName || pFunc->zName==lagName ){
        
// ABS Label 1044
if(pWin->pOwner->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}
int nArg = pWin->pOwner->x.pList->nExpr;
        
// ABS Label 1045
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1045);
}
int csr = pWin->csrApp;
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int tmpReg = sqlite3GetTempReg(pParse);
        
// ABS Label 1046
if(pMWin->iEphCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1046);
}
int iEph = pMWin->iEphCsr;
  
        
// ABS Label 1062
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1062);
}

// ROR Label 1063
if((nArg <= 3) != (nArg < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1063);
}
// ROR Label 1064
if((nArg > 3) != (nArg < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1064);
}
// ROR Label 1065
if((nArg >= 3) != (nArg < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1065);
}
if( nArg<3 ){
          
// ABS Label 1066
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1066);
}

// ABS Label 1067
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);
        }else{
          
// ABS Label 1068
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1068);
}

// ABS Label 1069
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1069);
}

// ABS Label 1070
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1070);
}

// AOR Label 1071
if(pWin->iArgCol - 2 != pWin->iArgCol + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1071);
}
// AOR Label 1072
if(pWin->iArgCol / 2 != pWin->iArgCol + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1072);
}
// AOR Label 1073
if(pWin->iArgCol * 2 != pWin->iArgCol + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1073);
}

// ABS Label 1074
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1074);
}
sqlite3VdbeAddOp3(v, OP_Column, iEph,pWin->iArgCol+2,pWin->regResult);
        }
        
// ABS Label 1047
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1047);
}

// ABS Label 1048
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}

// ABS Label 1049
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iEph, tmpReg);
        
// ABS Label 1075
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1075);
}

// ROR Label 1076
if((nArg <= 2) != (nArg < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1076);
}
// ROR Label 1077
if((nArg > 2) != (nArg < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1077);
}
// ROR Label 1078
if((nArg >= 2) != (nArg < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1078);
}
if( nArg<2 ){
          int val = (pFunc->zName==leadName ? 1 : -1);
          
// ABS Label 1079
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1079);
}

// ABS Label 1080
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}

// ABS Label 1081
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1081);
}
sqlite3VdbeAddOp2(v, OP_AddImm, tmpReg, val);
        }else{
          int op = (pFunc->zName==leadName ? OP_Add : OP_Subtract);
          int tmpReg2 = sqlite3GetTempReg(pParse);
          
// ABS Label 1082
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1082);
}

// ABS Label 1083
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1083);
}

// ABS Label 1084
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1084);
}

// AOR Label 1085
if(pWin->iArgCol - 1 != pWin->iArgCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1085);
}
// AOR Label 1086
if(pWin->iArgCol / 1 != pWin->iArgCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1086);
}
// AOR Label 1087
if(pWin->iArgCol * 1 != pWin->iArgCol + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1087);
}

// ABS Label 1088
if(tmpReg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}
sqlite3VdbeAddOp3(v, OP_Column, iEph, pWin->iArgCol+1, tmpReg2);
          
// ABS Label 1089
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}

// ABS Label 1090
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}

// ABS Label 1091
if(tmpReg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}

// ABS Label 1092
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// ABS Label 1093
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1093);
}
sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);
          
// ABS Label 1094
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1094);
}

// ABS Label 1095
if(tmpReg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}
sqlite3ReleaseTempReg(pParse, tmpReg2);
        }
  
        
// ABS Label 1050
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1050);
}

// ABS Label 1051
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}

// ABS Label 1052
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}

// ABS Label 1053
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, lbl, tmpReg);
        VdbeCoverage(v);
        
// ABS Label 1054
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}

// ABS Label 1055
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}

// ABS Label 1056
if(pWin->iArgCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1056);
}

// ABS Label 1057
if(pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}
sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);
        
// ABS Label 1058
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}

// ABS Label 1059
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}
sqlite3VdbeResolveLabel(v, lbl);
        
// ABS Label 1060
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}

// ABS Label 1061
if(tmpReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1061);
}
sqlite3ReleaseTempReg(pParse, tmpReg);
      };}

    };
// ABS Label 988
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 988);
}

  }
  
// ABS Label 981
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 981);
}

// ABS Label 982
if(p->regGosub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}

// ABS Label 983
if(p->addrGosub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 983);
}
sqlite3VdbeAddOp2(v, OP_Gosub, p->regGosub, p->addrGosub);
}

/*
** Generate code to set the accumulator register for each window function
** in the linked list passed as the second argument to NULL. And perform
** any equivalent initialization required by any built-in window functions
** in the list.
*/
static int windowInitAccum(Parse *pParse, Window *pMWin){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int regArg;
  int nArg = 0;
  Window *pWin;
  pWin = pMWin;

// ABS Label 1096
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1096);
}
for(; pWin; pWin=pWin->pNextWin){
    
// ABS Label 1098
if(pWin->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1098);
}
FuncDef *pFunc = pWin->pFunc;
    assert( pWin->regAccum );
    
// ABS Label 1099
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}

// ABS Label 1100
if(pWin->regAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
    nArg = MAX(nArg, windowArgCount(pWin));
    
// ABS Label 1101
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}

// ROR Label 1102
if((pMWin->regStartRowid != 0) != (pMWin->regStartRowid == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1102);
}
if( pMWin->regStartRowid==0 ){
      
// ABS Label 1103
if(pFunc->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1103);
}

// COR Label 1104
if((pFunc->zName == nth_valueName && pFunc->zName == first_valueName) != (pFunc->zName == nth_valueName || pFunc->zName == first_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1104);
}

// ROR Label 1105
if((pFunc->zName != nth_valueName) != (pFunc->zName == nth_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1105);
}
// ROR Label 1106
if((pFunc->zName != first_valueName) != (pFunc->zName == first_valueName))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1106);
}

// MCC Label 1107
if(pFunc->zName == nth_valueName && pFunc->zName == first_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1107);
}
// MCC Label 1108
if(pFunc->zName == nth_valueName && !(pFunc->zName == first_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1108);
}
// MCC Label 1109
if(!(pFunc->zName == nth_valueName) && pFunc->zName == first_valueName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1109);
}
// MCC Label 1110
if(!(pFunc->zName == nth_valueName) && !(pFunc->zName == first_valueName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1110);
}
if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){
        
// ABS Label 1111
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1111);
}

// ABS Label 1112
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1112);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp);
        
// ABS Label 1113
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1113);
}

// ABS Label 1114
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1114);
}

// AOR Label 1115
if(pWin->regApp - 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1115);
}
// AOR Label 1116
if(pWin->regApp / 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1116);
}
// AOR Label 1117
if(pWin->regApp * 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1117);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);
      }

      
// ABS Label 1118
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1118);
}

// COR Label 1119
if(((pFunc->funcFlags & 4096) || pWin->csrApp) != ((pFunc->funcFlags & 4096) && pWin->csrApp))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1119);
}

// MCC Label 1120
if(( pFunc->funcFlags & 4096 ) && pWin->csrApp ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1120);
}
// MCC Label 1121
if(( pFunc->funcFlags & 4096 ) && !(pWin->csrApp) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1121);
}
// MCC Label 1122
if(( !(pFunc->funcFlags & 4096) ) && pWin->csrApp ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1122);
}
// MCC Label 1123
if(( !(pFunc->funcFlags & 4096) ) && !(pWin->csrApp) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1123);
}
if( (pFunc->funcFlags & SQLITE_FUNC_MINMAX) && pWin->csrApp ){
        assert( pWin->eStart!=TK_UNBOUNDED );
        
// ABS Label 1124
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1124);
}

// ABS Label 1125
if(pWin->csrApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1125);
}
sqlite3VdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);
        
// ABS Label 1126
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1126);
}

// ABS Label 1127
if(pWin->regApp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}

// AOR Label 1128
if(pWin->regApp - 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1128);
}
// AOR Label 1129
if(pWin->regApp / 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1129);
}
// AOR Label 1130
if(pWin->regApp * 1 != pWin->regApp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1130);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);
      }
    }
  };
// ABS Label 1097
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1097);
}

  regArg = pParse->nMem+1;
  pParse->nMem += nArg;
  
// ABS Label 1131
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1131);
}
return regArg;
}

/* 
** Return true if the current frame should be cached in the ephemeral table,
** even if there are no xInverse() calls required.
*/
static int windowCacheFrame(Window *pMWin){
  Window *pWin;
  
// ABS Label 1132
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1132);
}
if( pMWin->regStartRowid ) { return 1;
}
  pWin = pMWin;

// ABS Label 1133
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1133);
}
for(; pWin; pWin=pWin->pNextWin){
    
// ABS Label 1135
if(pWin->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1135);
}
FuncDef *pFunc = pWin->pFunc;
    
// COR Label 1136
if(((pFunc->zName == nth_valueName) || (pFunc->zName == first_valueName) || (pFunc->zName == leadName) && (pFunc->zName == lagName)) != ((pFunc->zName == nth_valueName) || (pFunc->zName == first_valueName) || (pFunc->zName == leadName) || (pFunc->zName == lagName)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1136);
}
// COR Label 1137
if(((pFunc->zName == nth_valueName) || (pFunc->zName == first_valueName) && (pFunc->zName == leadName)) != ((pFunc->zName == nth_valueName) || (pFunc->zName == first_valueName) || (pFunc->zName == leadName)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1137);
}
// COR Label 1138
if(((pFunc->zName == nth_valueName) && (pFunc->zName == first_valueName)) != ((pFunc->zName == nth_valueName) || (pFunc->zName == first_valueName)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1138);
}

// MCC Label 1139
if(( pFunc->zName == nth_valueName ) && ( pFunc->zName == first_valueName ) && ( pFunc->zName == leadName ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1139);
}
// MCC Label 1140
if(( pFunc->zName == nth_valueName ) && ( pFunc->zName == first_valueName ) && ( pFunc->zName == leadName ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1140);
}
// MCC Label 1141
if(( pFunc->zName == nth_valueName ) && ( pFunc->zName == first_valueName ) && ( !(pFunc->zName == leadName) ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1141);
}
// MCC Label 1142
if(( pFunc->zName == nth_valueName ) && ( pFunc->zName == first_valueName ) && ( !(pFunc->zName == leadName) ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1142);
}
// MCC Label 1143
if(( pFunc->zName == nth_valueName ) && ( !(pFunc->zName == first_valueName) ) && ( pFunc->zName == leadName ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1143);
}
// MCC Label 1144
if(( pFunc->zName == nth_valueName ) && ( !(pFunc->zName == first_valueName) ) && ( pFunc->zName == leadName ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1144);
}
// MCC Label 1145
if(( pFunc->zName == nth_valueName ) && ( !(pFunc->zName == first_valueName) ) && ( !(pFunc->zName == leadName) ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1145);
}
// MCC Label 1146
if(( pFunc->zName == nth_valueName ) && ( !(pFunc->zName == first_valueName) ) && ( !(pFunc->zName == leadName) ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1146);
}
// MCC Label 1147
if(( !(pFunc->zName == nth_valueName) ) && ( pFunc->zName == first_valueName ) && ( pFunc->zName == leadName ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1147);
}
// MCC Label 1148
if(( !(pFunc->zName == nth_valueName) ) && ( pFunc->zName == first_valueName ) && ( pFunc->zName == leadName ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1148);
}
// MCC Label 1149
if(( !(pFunc->zName == nth_valueName) ) && ( pFunc->zName == first_valueName ) && ( !(pFunc->zName == leadName) ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1149);
}
// MCC Label 1150
if(( !(pFunc->zName == nth_valueName) ) && ( pFunc->zName == first_valueName ) && ( !(pFunc->zName == leadName) ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1150);
}
// MCC Label 1151
if(( !(pFunc->zName == nth_valueName) ) && ( !(pFunc->zName == first_valueName) ) && ( pFunc->zName == leadName ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1151);
}
// MCC Label 1152
if(( !(pFunc->zName == nth_valueName) ) && ( !(pFunc->zName == first_valueName) ) && ( pFunc->zName == leadName ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1152);
}
// MCC Label 1153
if(( !(pFunc->zName == nth_valueName) ) && ( !(pFunc->zName == first_valueName) ) && ( !(pFunc->zName == leadName) ) && ( pFunc->zName == lagName ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1153);
}
// MCC Label 1154
if(( !(pFunc->zName == nth_valueName) ) && ( !(pFunc->zName == first_valueName) ) && ( !(pFunc->zName == leadName) ) && ( !(pFunc->zName == lagName) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1154);
}
if( (pFunc->zName==nth_valueName)
     || (pFunc->zName==first_valueName)
     || (pFunc->zName==leadName)
     || (pFunc->zName==lagName)
    ){
      return 1;
    }
  };
// ABS Label 1134
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}

  return 0;
}

/*
** regOld and regNew are each the first register in an array of size
** pOrderBy->nExpr. This function generates code to compare the two
** arrays of registers using the collation sequences and other comparison
** parameters specified by pOrderBy. 
**
** If the two arrays are not equal, the contents of regNew is copied to 
** regOld and control falls through. Otherwise, if the contents of the arrays
** are equal, an OP_Goto is executed. The address of the OP_Goto is returned.
*/
static void windowIfNewPeer(
  Parse *pParse,
  ExprList *pOrderBy,
  int regNew,                     /* First in array of new values */
  int regOld,                     /* First in array of old values */
  int addr                        /* Jump here */
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  
// ABS Label 1155
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1155);
}
if( pOrderBy ){
    
// ABS Label 1156
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}
int nVal = pOrderBy->nExpr;
    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);
    
// ABS Label 1157
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}

// ABS Label 1158
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1158);
}

// ABS Label 1159
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1159);
}

// ABS Label 1160
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1160);
}
sqlite3VdbeAddOp3(v, OP_Compare, regOld, regNew, nVal);
    
// ABS Label 1161
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1161);
}
sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);
    
// ABS Label 1162
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1162);
}

// ABS Label 1163
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}
sqlite3VdbeAddOp3(v, OP_Jump, 
      sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1
    );
    VdbeCoverageEqNe(v);
    
// ABS Label 1164
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1164);
}

// ABS Label 1165
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1165);
}

// ABS Label 1166
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1166);
}

// ABS Label 1167
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1167);
}

// AOR Label 1168
if(nVal / 1 != nVal - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1168);
}
// AOR Label 1169
if(nVal + 1 != nVal - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1169);
}
// AOR Label 1170
if(nVal * 1 != nVal - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1170);
}
sqlite3VdbeAddOp3(v, OP_Copy, regNew, regOld, nVal-1);
  }else{
    
// ABS Label 1171
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1171);
}

// ABS Label 1172
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1172);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);
  }
}

/*
** This function is called as part of generating VM programs for RANGE
** offset PRECEDING/FOLLOWING frame boundaries. Assuming "ASC" order for
** the ORDER BY term in the window, and that argument op is OP_Ge, it generates
** code equivalent to:
**
**   if( csr1.peerVal + regVal >= csr2.peerVal ) goto lbl;
**
** The value of parameter op may also be OP_Gt or OP_Le. In these cases the
** operator in the above pseudo-code is replaced with ">" or "<=", respectively.
**
** If the sort-order for the ORDER BY term in the window is DESC, then the
** comparison is reversed. Instead of adding regVal to csr1.peerVal, it is
** subtracted. And the comparison operator is inverted to - ">=" becomes "<=",
** ">" becomes "<", and so on. So, with DESC sort order, if the argument op
** is OP_Ge, the generated code is equivalent to:
**
**   if( csr1.peerVal - regVal <= csr2.peerVal ) goto lbl;
**
** A special type of arithmetic is used such that if csr1.peerVal is not
** a numeric type (real or integer), then the result of the addition
** or subtraction is a a copy of csr1.peerVal.
*/
static void windowCodeRangeTest(
  WindowCodeArg *p, 
  int op,                         /* OP_Ge, OP_Gt, or OP_Le */
  int csr1,                       /* Cursor number for cursor 1 */
  int regVal,                     /* Register containing non-negative number */
  int csr2,                       /* Cursor number for cursor 2 */
  int lbl                         /* Jump destination if condition is true */
){
  
// ABS Label 1173
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1173);
}
Parse *pParse = p->pParse;
  Vdbe *v = sqlite3GetVdbe(pParse);
  
// ABS Label 1174
if(p->pMWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1174);
}
ExprList *pOrderBy = p->pMWin->pOrderBy;  /* ORDER BY clause for window */
  int reg1 = sqlite3GetTempReg(pParse);     /* Reg. for csr1.peerVal+regVal */
  int reg2 = sqlite3GetTempReg(pParse);     /* Reg. for csr2.peerVal */
  int regString = ++pParse->nMem;           /* Reg. for constant value '' */
  int arith = OP_Add;                       /* OP_Add or OP_Subtract */
  int addrGe;                               /* Jump destination */
  int addrDone = sqlite3VdbeMakeLabel(pParse);   /* Address past OP_Ge */
  CollSeq *pColl;

  /* Read the peer-value from each cursor into a register */
  
// ABS Label 1175
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}

// ABS Label 1176
if(csr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1176);
}

// ABS Label 1177
if(reg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1177);
}
windowReadPeerValues(p, csr1, reg1);
  
// ABS Label 1178
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1178);
}

// ABS Label 1179
if(csr2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1179);
}

// ABS Label 1180
if(reg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1180);
}
windowReadPeerValues(p, csr2, reg2);

  assert( op==OP_Ge || op==OP_Gt || op==OP_Le );
  assert( pOrderBy && pOrderBy->nExpr==1 );
  
// AOR Label 1203
if(pOrderBy->a[0].sortFlags | 1 != pOrderBy->a[0].sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1203);
}
// AOR Label 1204
if(pOrderBy->a[0].sortFlags ^ 1 != pOrderBy->a[0].sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1204);
}
if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_DESC ){
    switch( op ){
      case OP_Ge: op = OP_Le; break;
      case OP_Gt: op = OP_Lt; break;
      default: assert( op==OP_Le ); op = OP_Ge; break;
    }
    arith = OP_Subtract;
  }

  VdbeModuleComment((v, "CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl",
      reg1, (arith==OP_Add ? "+" : "-"), regVal,
      ((op==OP_Ge) ? ">=" : (op==OP_Le) ? "<=" : (op==OP_Gt) ? ">" : "<"), reg2
  ));

  /* If the BIGNULL flag is set for the ORDER BY, then it is required to 
  ** consider NULL values to be larger than all other values, instead of 
  ** the usual smaller. The VDBE opcodes OP_Ge and so on do not handle this
  ** (and adding that capability causes a performance regression), so
  ** instead if the BIGNULL flag is set then cases where either reg1 or
  ** reg2 are NULL are handled separately in the following block. The code
  ** generated is equivalent to:
  **
  **   if( reg1 IS NULL ){
  **     if( op==OP_Ge ) goto lbl;
  **     if( op==OP_Gt && reg2 IS NOT NULL ) goto lbl;
  **     if( op==OP_Le && reg2 IS NULL ) goto lbl;
  **   }else if( reg2 IS NULL ){
  **     if( op==OP_Le ) goto lbl;
  **   }
  **
  ** Additionally, if either reg1 or reg2 are NULL but the jump to lbl is 
  ** not taken, control jumps over the comparison operator coded below this
  ** block.  */
  
// AOR Label 1205
if(pOrderBy->a[0].sortFlags | 2 != pOrderBy->a[0].sortFlags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1205);
}
// AOR Label 1206
if(pOrderBy->a[0].sortFlags ^ 2 != pOrderBy->a[0].sortFlags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1206);
}
if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_BIGNULL ){
    /* This block runs if reg1 contains a NULL. */
    int addr = sqlite3VdbeAddOp1(v, OP_NotNull, reg1); VdbeCoverage(v);
    switch( op ){
      case OP_Ge: 
        sqlite3VdbeAddOp2(v, OP_Goto, 0, lbl); 
        break;
      case OP_Gt: 
        sqlite3VdbeAddOp2(v, OP_NotNull, reg2, lbl); 
        VdbeCoverage(v); 
        break;
      case OP_Le: 
        sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); 
        VdbeCoverage(v); 
        break;
      default: assert( op==OP_Lt ); /* no-op */ break;
    }
    
// ABS Label 1207
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1207);
}

// ABS Label 1208
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1208);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);

    /* This block runs if reg1 is not NULL, but reg2 is. */
    
// ABS Label 1209
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1209);
}

// ABS Label 1210
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1210);
}
sqlite3VdbeJumpHere(v, addr);
    
// ABS Label 1211
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1211);
}

// ABS Label 1212
if(reg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1212);
}

// ABS Label 1213
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1213);
}
sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); VdbeCoverage(v);
    
// ABS Label 1214
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1214);
}

// COR Label 1215
if((op == 54 && op == 57) != (op == 54 || op == 57))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1215);
}

// ROR Label 1216
if((op != 54) != (op == 54))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1216);
}
// ROR Label 1217
if((op != 57) != (op == 57))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1217);
}

// MCC Label 1218
if(op == 54 && op == 57 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1218);
}
// MCC Label 1219
if(op == 54 && !(op == 57) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1219);
}
// MCC Label 1220
if(!(op == 54) && op == 57 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1220);
}
// MCC Label 1221
if(!(op == 54) && !(op == 57) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1221);
}
if( op==OP_Gt || op==OP_Ge ){
      
// ABS Label 1222
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1222);
}

// ABS Label 1223
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1223);
}
sqlite3VdbeChangeP2(v, -1, addrDone);
    }
  }

  /* Register reg1 currently contains csr1.peerVal (the peer-value from csr1).
  ** This block adds (or subtracts for DESC) the numeric value in regVal
  ** from it. Or, if reg1 is not numeric (it is a NULL, a text value or a blob),
  ** then leave reg1 as it is. In pseudo-code, this is implemented as:
  **
  **   if( reg1>='' ) goto addrGe;
  **   reg1 = reg1 +/- regVal
  **   addrGe:
  **
  ** Since all strings and blobs are greater-than-or-equal-to an empty string,
  ** the add/subtract is skipped for these, as required. If reg1 is a NULL,
  ** then the arithmetic is performed, but since adding or subtracting from
  ** NULL is always NULL anyway, this case is handled as required too.  */
  
// ABS Label 1181
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1181);
}

// ABS Label 1182
if(regString < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1182);
}
sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);
  addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);
  VdbeCoverage(v);
  
// COR Label 1224
if(((op == 57 && arith == 106) && (op == 55 && arith == 107)) != ((op == 57 && arith == 106) || (op == 55 && arith == 107)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1224);
}

// MCC Label 1225
if(( op == 57 && arith == 106 ) && ( op == 55 && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1225);
}
// MCC Label 1226
if(( op == 57 && arith == 106 ) && ( op == 55 && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1226);
}
// MCC Label 1227
if(( op == 57 && arith == 106 ) && ( !(op == 55) && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1227);
}
// MCC Label 1228
if(( op == 57 && arith == 106 ) && ( !(op == 55) && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1228);
}
// MCC Label 1229
if(( op == 57 && !(arith == 106) ) && ( op == 55 && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1229);
}
// MCC Label 1230
if(( op == 57 && !(arith == 106) ) && ( op == 55 && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1230);
}
// MCC Label 1231
if(( op == 57 && !(arith == 106) ) && ( !(op == 55) && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1231);
}
// MCC Label 1232
if(( op == 57 && !(arith == 106) ) && ( !(op == 55) && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1232);
}
// MCC Label 1233
if(( !(op == 57) && arith == 106 ) && ( op == 55 && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1233);
}
// MCC Label 1234
if(( !(op == 57) && arith == 106 ) && ( op == 55 && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1234);
}
// MCC Label 1235
if(( !(op == 57) && arith == 106 ) && ( !(op == 55) && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1235);
}
// MCC Label 1236
if(( !(op == 57) && arith == 106 ) && ( !(op == 55) && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1236);
}
// MCC Label 1237
if(( !(op == 57) && !(arith == 106) ) && ( op == 55 && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1237);
}
// MCC Label 1238
if(( !(op == 57) && !(arith == 106) ) && ( op == 55 && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1238);
}
// MCC Label 1239
if(( !(op == 57) && !(arith == 106) ) && ( !(op == 55) && arith == 107 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1239);
}
// MCC Label 1240
if(( !(op == 57) && !(arith == 106) ) && ( !(op == 55) && !(arith == 107) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1240);
}
if( (op==OP_Ge && arith==OP_Add) || (op==OP_Le && arith==OP_Subtract) ){
    
// ABS Label 1241
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1241);
}

// ABS Label 1242
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1242);
}

// ABS Label 1243
if(reg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1243);
}

// ABS Label 1244
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1244);
}

// ABS Label 1245
if(reg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1245);
}
sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);
  }
  
// ABS Label 1183
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1183);
}

// ABS Label 1184
if(arith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1184);
}

// ABS Label 1185
if(regVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}

// ABS Label 1186
if(reg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1186);
}

// ABS Label 1187
if(reg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}
sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);
  
// ABS Label 1188
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1188);
}

// ABS Label 1189
if(addrGe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1189);
}
sqlite3VdbeJumpHere(v, addrGe);

  /* Compare registers reg2 and reg1, taking the jump if required. Note that
  ** control skips over this test if the BIGNULL flag is set and either
  ** reg1 or reg2 contain a NULL value.  */
  
// ABS Label 1190
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}

// ABS Label 1191
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}

// ABS Label 1192
if(reg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1192);
}

// ABS Label 1193
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1193);
}

// ABS Label 1194
if(reg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1194);
}
sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);
  pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[0].pExpr);
  
// ABS Label 1195
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1195);
}
sqlite3VdbeAppendP4(v, (void*)pColl, P4_COLLSEQ);
  
// ABS Label 1196
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1196);
}
sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
  
// ABS Label 1197
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1197);
}

// ABS Label 1198
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1198);
}
sqlite3VdbeResolveLabel(v, addrDone);

  assert( op==OP_Ge || op==OP_Gt || op==OP_Lt || op==OP_Le );
  testcase(op==OP_Ge); VdbeCoverageIf(v, op==OP_Ge);
  testcase(op==OP_Lt); VdbeCoverageIf(v, op==OP_Lt);
  testcase(op==OP_Le); VdbeCoverageIf(v, op==OP_Le);
  testcase(op==OP_Gt); VdbeCoverageIf(v, op==OP_Gt);
  
// ABS Label 1199
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}

// ABS Label 1200
if(reg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1200);
}
sqlite3ReleaseTempReg(pParse, reg1);
  
// ABS Label 1201
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1201);
}

// ABS Label 1202
if(reg2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1202);
}
sqlite3ReleaseTempReg(pParse, reg2);

  VdbeModuleComment((v, "CodeRangeTest: end"));
}

/*
** Helper function for sqlite3WindowCodeStep(). Each call to this function
** generates VM code for a single RETURN_ROW, AGGSTEP or AGGINVERSE 
** operation. Refer to the header comment for sqlite3WindowCodeStep() for
** details.
*/
static int windowCodeOp(
 WindowCodeArg *p,                /* Context object */
 int op,                          /* WINDOW_RETURN_ROW, AGGSTEP or AGGINVERSE */
 int regCountdown,                /* Register for OP_IfPos countdown */
 int jumpOnEof                    /* Jump here if stepped cursor reaches EOF */
){
  int csr, reg;
  
// ABS Label 1246
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1246);
}
Parse *pParse = p->pParse;
  
// ABS Label 1247
if(p->pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1247);
}
Window *pMWin = p->pMWin;
  int ret = 0;
  
// ABS Label 1248
if(p->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1248);
}
Vdbe *v = p->pVdbe;
  int addrContinue = 0;
  int bPeer = (pMWin->eFrmType!=TK_ROWS);

  int lblDone = sqlite3VdbeMakeLabel(pParse);
  int addrNextRange = 0;

  /* Special case - WINDOW_AGGINVERSE is always a no-op if the frame
  ** starts with UNBOUNDED PRECEDING. */
  
// ABS Label 1251
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1251);
}

// COR Label 1252
if((op == 2 || pMWin->eStart == 90) != (op == 2 && pMWin->eStart == 90))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1252);
}

// ROR Label 1253
if((op != 2) != (op == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1253);
}
// ROR Label 1254
if((pMWin->eStart != 90) != (pMWin->eStart == 90))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1254);
}

// MCC Label 1255
if(op == 2 && pMWin->eStart == 90 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1255);
}
// MCC Label 1256
if(op == 2 && !(pMWin->eStart == 90) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1256);
}
// MCC Label 1257
if(!(op == 2) && pMWin->eStart == 90 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1257);
}
// MCC Label 1258
if(!(op == 2) && !(pMWin->eStart == 90) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1258);
}
if( op==WINDOW_AGGINVERSE && pMWin->eStart==TK_UNBOUNDED ){
    assert( regCountdown==0 && jumpOnEof==0 );
    return 0;
  }

  
// ABS Label 1259
if(regCountdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1259);
}

// ROR Label 1260
if((regCountdown <= 0) != (regCountdown > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1260);
}
// ROR Label 1261
if((regCountdown < 0) != (regCountdown > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1261);
}
// ROR Label 1262
if((regCountdown >= 0) != (regCountdown > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1262);
}
if( regCountdown>0 ){
    
// ROR Label 1263
if((pMWin->eFrmType != 89) != (pMWin->eFrmType == 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1263);
}
if( pMWin->eFrmType==TK_RANGE ){
      addrNextRange = sqlite3VdbeCurrentAddr(v);
      assert( op==WINDOW_AGGINVERSE || op==WINDOW_AGGSTEP );
      
// ABS Label 1264
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1264);
}

// ROR Label 1265
if((op != 2) != (op == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1265);
}
if( op==WINDOW_AGGINVERSE ){
        
// ROR Label 1266
if((pMWin->eStart != 86) != (pMWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1266);
}
if( pMWin->eStart==TK_FOLLOWING ){
          
// ABS Label 1267
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1267);
}

// ABS Label 1268
if(p->current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1268);
}

// ABS Label 1269
if(regCountdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1269);
}

// ABS Label 1270
if(p->start.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1270);
}

// ABS Label 1271
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1271);
}
windowCodeRangeTest(
              p, OP_Le, p->current.csr, regCountdown, p->start.csr, lblDone
          );
        }else{
          
// ABS Label 1272
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1272);
}

// ABS Label 1273
if(p->start.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1273);
}

// ABS Label 1274
if(regCountdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1274);
}

// ABS Label 1275
if(p->current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1275);
}

// ABS Label 1276
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1276);
}
windowCodeRangeTest(
              p, OP_Ge, p->start.csr, regCountdown, p->current.csr, lblDone
          );
        }
      }else{
        
// ABS Label 1277
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1277);
}

// ABS Label 1278
if(p->end.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1278);
}

// ABS Label 1279
if(regCountdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1279);
}

// ABS Label 1280
if(p->current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1280);
}

// ABS Label 1281
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1281);
}
windowCodeRangeTest(
            p, OP_Gt, p->end.csr, regCountdown, p->current.csr, lblDone
        );
      }
    }else{
      
// ABS Label 1282
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1282);
}

// ABS Label 1283
if(regCountdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1283);
}

// ABS Label 1284
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1284);
}
sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, lblDone, 1);
      VdbeCoverage(v);
    }
  }

  
// ABS Label 1285
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1285);
}
// ABS Label 1286
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1286);
}

// COR Label 1287
if((op == 1 || pMWin->regStartRowid == 0) != (op == 1 && pMWin->regStartRowid == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1287);
}

// ROR Label 1288
if((op != 1) != (op == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1288);
}
// ROR Label 1289
if((pMWin->regStartRowid != 0) != (pMWin->regStartRowid == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1289);
}

// MCC Label 1290
if(op == 1 && pMWin->regStartRowid == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1290);
}
// MCC Label 1291
if(op == 1 && !(pMWin->regStartRowid == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1291);
}
// MCC Label 1292
if(!(op == 1) && pMWin->regStartRowid == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1292);
}
// MCC Label 1293
if(!(op == 1) && !(pMWin->regStartRowid == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1293);
}
if( op==WINDOW_RETURN_ROW && pMWin->regStartRowid==0 ){
    
// ABS Label 1294
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1294);
}
windowAggFinal(p, 0);
  }
  addrContinue = sqlite3VdbeCurrentAddr(v);

  /* If this is a (RANGE BETWEEN a FOLLOWING AND b FOLLOWING) or
  ** (RANGE BETWEEN b PRECEDING AND a PRECEDING) frame, ensure the 
  ** start cursor does not advance past the end cursor within the 
  ** temporary table. It otherwise might, if (a>b). Also ensure that,
  ** if the input cursor is still finding new rows, that the end
  ** cursor does not go past it to EOF. */
  
// ABS Label 1295
if(regCountdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1295);
}

// COR Label 1296
if((pMWin->eStart == pMWin->eEnd && regCountdown || pMWin->eFrmType == 89) != (pMWin->eStart == pMWin->eEnd && regCountdown && pMWin->eFrmType == 89))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1296);
}
// COR Label 1297
if((pMWin->eStart == pMWin->eEnd || regCountdown) != (pMWin->eStart == pMWin->eEnd && regCountdown))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1297);
}

// ROR Label 1298
if((pMWin->eStart != pMWin->eEnd) != (pMWin->eStart == pMWin->eEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1298);
}
// ROR Label 1299
if((pMWin->eFrmType != 89) != (pMWin->eFrmType == 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1299);
}

// MCC Label 1300
if(pMWin->eStart == pMWin->eEnd && regCountdown && pMWin->eFrmType == 89 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1300);
}
// MCC Label 1301
if(pMWin->eStart == pMWin->eEnd && regCountdown && !(pMWin->eFrmType == 89) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1301);
}
// MCC Label 1302
if(pMWin->eStart == pMWin->eEnd && !(regCountdown) && pMWin->eFrmType == 89 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1302);
}
// MCC Label 1303
if(pMWin->eStart == pMWin->eEnd && !(regCountdown) && !(pMWin->eFrmType == 89) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1303);
}
// MCC Label 1304
if(!(pMWin->eStart == pMWin->eEnd) && regCountdown && pMWin->eFrmType == 89 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1304);
}
// MCC Label 1305
if(!(pMWin->eStart == pMWin->eEnd) && regCountdown && !(pMWin->eFrmType == 89) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1305);
}
// MCC Label 1306
if(!(pMWin->eStart == pMWin->eEnd) && !(regCountdown) && pMWin->eFrmType == 89 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1306);
}
// MCC Label 1307
if(!(pMWin->eStart == pMWin->eEnd) && !(regCountdown) && !(pMWin->eFrmType == 89) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1307);
}
if( pMWin->eStart==pMWin->eEnd && regCountdown
   && pMWin->eFrmType==TK_RANGE
  ){
    int regRowid1 = sqlite3GetTempReg(pParse);
    int regRowid2 = sqlite3GetTempReg(pParse);
    
// ABS Label 1312
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1312);
}

// ROR Label 1313
if((op != 2) != (op == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1313);
}
if( op==WINDOW_AGGINVERSE ){
      
// ABS Label 1314
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1314);
}

// ABS Label 1315
if(p->start.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1315);
}

// ABS Label 1316
if(regRowid1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1316);
}
sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);
      
// ABS Label 1317
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1317);
}

// ABS Label 1318
if(p->end.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1318);
}

// ABS Label 1319
if(regRowid2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1319);
}
sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);
      
// ABS Label 1320
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1320);
}

// ABS Label 1321
if(regRowid2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1321);
}

// ABS Label 1322
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1322);
}

// ABS Label 1323
if(regRowid1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1323);
}
sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);
      VdbeCoverage(v);
    }else { 
// ABS Label 1324
if(p->regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1324);
}
if( p->regRowid ){
      
// ABS Label 1325
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1325);
}

// ABS Label 1326
if(p->end.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1326);
}

// ABS Label 1327
if(regRowid1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1327);
}
sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid1);
      
// ABS Label 1328
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1328);
}

// ABS Label 1329
if(p->regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1329);
}

// ABS Label 1330
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1330);
}

// ABS Label 1331
if(regRowid1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1331);
}
sqlite3VdbeAddOp3(v, OP_Ge, p->regRowid, lblDone, regRowid1);
      VdbeCoverageNeverNull(v);
    };}

    
// ABS Label 1308
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1308);
}

// ABS Label 1309
if(regRowid1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1309);
}
sqlite3ReleaseTempReg(pParse, regRowid1);
    
// ABS Label 1310
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1310);
}

// ABS Label 1311
if(regRowid2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1311);
}
sqlite3ReleaseTempReg(pParse, regRowid2);
    assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING );
  }

  switch( op ){
    case WINDOW_RETURN_ROW:
      csr = p->current.csr;
      reg = p->current.reg;
      
// ABS Label 1332
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1332);
}
windowReturnOneRow(p);
      break;

    case WINDOW_AGGINVERSE:
      csr = p->start.csr;
      reg = p->start.reg;
      
// ABS Label 1333
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1333);
}
if( pMWin->regStartRowid ){
        assert( pMWin->regEndRowid );
        
// ABS Label 1334
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1334);
}

// ABS Label 1335
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1335);
}
sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regStartRowid, 1);
      }else{
        
// ABS Label 1336
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1336);
}

// ABS Label 1337
if(pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1337);
}

// ABS Label 1338
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1338);
}

// ABS Label 1339
if(p->regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1339);
}
windowAggStep(p, pMWin, csr, 1, p->regArg);
      }
      break;

    default:
      assert( op==WINDOW_AGGSTEP );
      csr = p->end.csr;
      reg = p->end.reg;
      
// ABS Label 1340
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1340);
}
if( pMWin->regStartRowid ){
        assert( pMWin->regEndRowid );
        
// ABS Label 1341
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1341);
}

// ABS Label 1342
if(pMWin->regEndRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1342);
}
sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);
      }else{
        
// ABS Label 1343
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1343);
}

// ABS Label 1344
if(pMWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1344);
}

// ABS Label 1345
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1345);
}

// ABS Label 1346
if(p->regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1346);
}
windowAggStep(p, pMWin, csr, 0, p->regArg);
      }
      break;
  }

  
// ABS Label 1347
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1347);
}
// ABS Label 1348
if(p->eDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1348);
}

// ROR Label 1349
if((op != p->eDelete) != (op == p->eDelete))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1349);
}
if( op==p->eDelete ){
    
// ABS Label 1350
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1350);
}

// ABS Label 1351
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1351);
}
sqlite3VdbeAddOp1(v, OP_Delete, csr);
    
// ABS Label 1352
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}
sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);
  }

  
// ABS Label 1353
if(jumpOnEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1353);
}
if( jumpOnEof ){
    
// ABS Label 1354
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1354);
}

// ABS Label 1355
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1355);
}
sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+2);
    VdbeCoverage(v);
    ret = sqlite3VdbeAddOp0(v, OP_Goto);
  }else{
    
// ABS Label 1356
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1356);
}

// ABS Label 1357
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1357);
}
sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);
    VdbeCoverage(v);
    
// ABS Label 1358
if(bPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1358);
}
if( bPeer ){
      
// ABS Label 1359
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1359);
}

// ABS Label 1360
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1360);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, lblDone);
    }
  }

  
// ABS Label 1361
if(bPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1361);
}
if( bPeer ){
    int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
    int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);
    
// ABS Label 1362
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1362);
}

// ABS Label 1363
if(csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1363);
}

// ABS Label 1364
if(regTmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1364);
}
windowReadPeerValues(p, csr, regTmp);
    
// ABS Label 1365
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1365);
}

// ABS Label 1366
if(pMWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1366);
}

// ABS Label 1367
if(regTmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1367);
}

// ABS Label 1368
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1368);
}

// ABS Label 1369
if(addrContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1369);
}
windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);
    
// ABS Label 1370
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1370);
}

// ABS Label 1371
if(regTmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1371);
}

// ABS Label 1372
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1372);
}
sqlite3ReleaseTempRange(pParse, regTmp, nReg);
  }

  
// ABS Label 1373
if(addrNextRange < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1373);
}
if( addrNextRange ){
    
// ABS Label 1374
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1374);
}

// ABS Label 1375
if(addrNextRange < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1375);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNextRange);
  }
  
// ABS Label 1249
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1249);
}

// ABS Label 1250
if(lblDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1250);
}
sqlite3VdbeResolveLabel(v, lblDone);
  
// ABS Label 1376
if(ret < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1376);
}
return ret;
}


/*
** Allocate and return a duplicate of the Window object indicated by the
** third argument. Set the Window.pOwner field of the new object to
** pOwner.
*/
Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){
  Window *pNew = 0;
  
// ABS Label 1377
if((p) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1377);
}
if( ALWAYS(p) ){
    pNew = sqlite3DbMallocZero(db, sizeof(Window));
    
// ABS Label 1378
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1378);
}
if( pNew ){
      pNew->zName = sqlite3DbStrDup(db, p->zName);
      pNew->zBase = sqlite3DbStrDup(db, p->zBase);
      pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);
      pNew->pFunc = p->pFunc;
      pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);
      pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);
      pNew->eFrmType = p->eFrmType;
      pNew->eEnd = p->eEnd;
      pNew->eStart = p->eStart;
      pNew->eExclude = p->eExclude;
      pNew->regResult = p->regResult;
      pNew->regAccum = p->regAccum;
      pNew->iArgCol = p->iArgCol;
      pNew->iEphCsr = p->iEphCsr;
      pNew->bExprArgs = p->bExprArgs;
      pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);
      pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);
      pNew->pOwner = pOwner;
      pNew->bImplicitFrame = p->bImplicitFrame;
    }
  }
  
// ABS Label 1379
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1379);
}
return pNew;
}

/*
** Return a copy of the linked list of Window objects passed as the
** second argument.
*/
Window *sqlite3WindowListDup(sqlite3 *db, Window *p){
  Window *pWin;
  Window *pRet = 0;
  Window **pp = &pRet;

  pWin = p;

// ABS Label 1380
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1380);
}
for(; pWin; pWin=pWin->pNextWin){
    *pp = sqlite3WindowDup(db, 0, pWin);
    
// ABS Label 1382
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1382);
}

// ROR Label 1383
if((*pp != 0) != (*pp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1383);
}
if( *pp==0 ) { break;
}
    pp = &((*pp)->pNextWin);
  };
// ABS Label 1381
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1381);
}


  
// ABS Label 1384
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1384);
}
return pRet;
}

/*
** Return true if it can be determined at compile time that expression 
** pExpr evaluates to a value that, when cast to an integer, is greater 
** than zero. False otherwise.
**
** If an OOM error occurs, this function sets the Parse.db.mallocFailed 
** flag and returns zero.
*/
static int windowExprGtZero(Parse *pParse, Expr *pExpr){
  int ret = 0;
  
// ABS Label 1385
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1385);
}
sqlite3 *db = pParse->db;
  sqlite3_value *pVal = 0;
  
// ABS Label 1386
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1386);
}

// ABS Label 1387
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1387);
}

// ABS Label 1388
if(db->enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1388);
}
sqlite3ValueFromExpr(db, pExpr, db->enc, SQLITE_AFF_NUMERIC, &pVal);
  if( pVal && sqlite3_value_int(pVal)>0 ){
    ret = 1;
  }
  
// ABS Label 1389
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1389);
}
sqlite3ValueFree(pVal);
  
// ABS Label 1390
if(ret < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1390);
}
return ret;
}

/*
** sqlite3WhereBegin() has already been called for the SELECT statement 
** passed as the second argument when this function is invoked. It generates
** code to populate the Window.regResult register for each window function 
** and invoke the sub-routine at instruction addrGosub once for each row.
** sqlite3WhereEnd() is always called before returning. 
**
** This function handles several different types of window frames, which
** require slightly different processing. The following pseudo code is
** used to implement window frames of the form:
**
**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING
**
** Other window frame types use variants of the following:
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       
**       if( first row of partition ){
**         // Rewind three cursors, all open on the eph table.
**         Rewind(csrEnd);
**         Rewind(csrStart);
**         Rewind(csrCurrent);
**       
**         regEnd = <expr2>          // FOLLOWING expression
**         regStart = <expr1>        // PRECEDING expression
**       }else{
**         // First time this branch is taken, the eph table contains two 
**         // rows. The first row in the partition, which all three cursors
**         // currently point to, and the following row.
**         AGGSTEP
**         if( (regEnd--)<=0 ){
**           RETURN_ROW
**           if( (regStart--)<=0 ){
**             AGGINVERSE
**           }
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         RETURN ROW
**         if( csrCurrent is EOF ) break;
**         if( (regStart--)<=0 ){
**           AggInverse(csrStart)
**           Next(csrStart)
**         }
**       }
**
** The pseudo-code above uses the following shorthand:
**
**   AGGSTEP:    invoke the aggregate xStep() function for each window function
**               with arguments read from the current row of cursor csrEnd, then
**               step cursor csrEnd forward one row (i.e. sqlite3BtreeNext()).
**
**   RETURN_ROW: return a row to the caller based on the contents of the 
**               current row of csrCurrent and the current state of all 
**               aggregates. Then step cursor csrCurrent forward one row.
**
**   AGGINVERSE: invoke the aggregate xInverse() function for each window 
**               functions with arguments read from the current row of cursor
**               csrStart. Then step csrStart forward one row.
**
** There are two other ROWS window frames that are handled significantly
** differently from the above - "BETWEEN <expr> PRECEDING AND <expr> PRECEDING"
** and "BETWEEN <expr> FOLLOWING AND <expr> FOLLOWING". These are special 
** cases because they change the order in which the three cursors (csrStart,
** csrCurrent and csrEnd) iterate through the ephemeral table. Cases that
** use UNBOUNDED or CURRENT ROW are much simpler variations on one of these
** three.
**
**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = <expr2>
**         regStart = <expr1>
**       }else{
**         if( (regEnd--)<=0 ){
**           AGGSTEP
**         }
**         RETURN_ROW
**         if( (regStart--)<=0 ){
**           AGGINVERSE
**         }
**       }
**     }
**     flush:
**       if( (regEnd--)<=0 ){
**         AGGSTEP
**       }
**       RETURN_ROW
**
**
**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**       regEnd = <expr2>
**       regStart = regEnd - <expr1>
**     }else{
**       AGGSTEP
**       if( (regEnd--)<=0 ){
**         RETURN_ROW
**       }
**       if( (regStart--)<=0 ){
**         AGGINVERSE
**       }
**     }
**   }
**   flush:
**     AGGSTEP
**     while( 1 ){
**       if( (regEnd--)<=0 ){
**         RETURN_ROW
**         if( eof ) break;
**       }
**       if( (regStart--)<=0 ){
**         AGGINVERSE
**         if( eof ) break
**       }
**     }
**     while( !eof csrCurrent ){
**       RETURN_ROW
**     }
**
** For the most part, the patterns above are adapted to support UNBOUNDED by
** assuming that it is equivalent to "infinity PRECEDING/FOLLOWING" and
** CURRENT ROW by assuming that it is equivilent to "0 PRECEDING/FOLLOWING".
** This is optimized of course - branches that will never be taken and
** conditions that are always true are omitted from the VM code. The only
** exceptional case is:
**
**   ROWS BETWEEN <expr1> FOLLOWING AND UNBOUNDED FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**       regStart = <expr1>
**     }else{
**       AGGSTEP
**     }
**   }
**   flush:
**     AGGSTEP
**     while( 1 ){
**       if( (regStart--)<=0 ){
**         AGGINVERSE
**         if( eof ) break
**       }
**       RETURN_ROW
**     }
**     while( !eof csrCurrent ){
**       RETURN_ROW
**     }
**
** Also requiring special handling are the cases:
**
**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING
**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING
**
** when (expr1 < expr2). This is detected at runtime, not by this function.
** To handle this case, the pseudo-code programs depicted above are modified
** slightly to be:
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**       regEnd = <expr2>
**       regStart = <expr1>
**       if( regEnd < regStart ){
**         RETURN_ROW
**         delete eph table contents
**         continue
**       }
**     ...
**
** The new "continue" statement in the above jumps to the next iteration
** of the outer loop - the one started by sqlite3WhereBegin().
**
** The various GROUPS cases are implemented using the same patterns as
** ROWS. The VM code is modified slightly so that:
**
**   1. The else branch in the main loop is only taken if the row just
**      added to the ephemeral table is the start of a new group. In
**      other words, it becomes:
**
**         ... loop started by sqlite3WhereBegin() ...
**         if( new partition ){
**           Gosub flush
**         }
**         Insert new row into eph table.
**         if( first row of partition ){
**           Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**           regEnd = <expr2>
**           regStart = <expr1>
**         }else if( new group ){
**           ... 
**         }
**       }
**
**   2. Instead of processing a single row, each RETURN_ROW, AGGSTEP or 
**      AGGINVERSE step processes the current row of the relevant cursor and
**      all subsequent rows belonging to the same group.
**
** RANGE window frames are a little different again. As for GROUPS, the 
** main loop runs once per group only. And RETURN_ROW, AGGSTEP and AGGINVERSE
** deal in groups instead of rows. As for ROWS and GROUPS, there are three
** basic cases:
**
**   RANGE BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = <expr2>
**         regStart = <expr1>
**       }else{
**         AGGSTEP
**         while( (csrCurrent.key + regEnd) < csrEnd.key ){
**           RETURN_ROW
**           while( csrStart.key + regStart) < csrCurrent.key ){
**             AGGINVERSE
**           }
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         RETURN ROW
**         if( csrCurrent is EOF ) break;
**           while( csrStart.key + regStart) < csrCurrent.key ){
**             AGGINVERSE
**           }
**         }
**       }
**
** In the above notation, "csr.key" means the current value of the ORDER BY 
** expression (there is only ever 1 for a RANGE that uses an <expr> FOLLOWING
** or <expr PRECEDING) read from cursor csr.
**
**   RANGE BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = <expr2>
**         regStart = <expr1>
**       }else{
**         while( (csrEnd.key + regEnd) <= csrCurrent.key ){
**           AGGSTEP
**         }
**         while( (csrStart.key + regStart) < csrCurrent.key ){
**           AGGINVERSE
**         }
**         RETURN_ROW
**       }
**     }
**     flush:
**       while( (csrEnd.key + regEnd) <= csrCurrent.key ){
**         AGGSTEP
**       }
**       while( (csrStart.key + regStart) < csrCurrent.key ){
**         AGGINVERSE
**       }
**       RETURN_ROW
**
**   RANGE BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd) ; Rewind(csrStart) ; Rewind(csrCurrent)
**         regEnd = <expr2>
**         regStart = <expr1>
**       }else{
**         AGGSTEP
**         while( (csrCurrent.key + regEnd) < csrEnd.key ){
**           while( (csrCurrent.key + regStart) > csrStart.key ){
**             AGGINVERSE
**           }
**           RETURN_ROW
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         while( (csrCurrent.key + regStart) > csrStart.key ){
**           AGGINVERSE
**           if( eof ) break "while( 1 )" loop.
**         }
**         RETURN_ROW
**       }
**       while( !eof csrCurrent ){
**         RETURN_ROW
**       }
**
** The text above leaves out many details. Refer to the code and comments
** below for a more complete picture.
*/
void sqlite3WindowCodeStep(
  Parse *pParse,                  /* Parse context */
  Select *p,                      /* Rewritten SELECT statement */
  WhereInfo *pWInfo,              /* Context returned by sqlite3WhereBegin() */
  int regGosub,                   /* Register for OP_Gosub */
  int addrGosub                   /* OP_Gosub here to return each row */
){
  
// ABS Label 1391
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1391);
}
Window *pMWin = p->pWin;
  
// ABS Label 1392
if(pMWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1392);
}
ExprList *pOrderBy = pMWin->pOrderBy;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int csrWrite;                   /* Cursor used to write to eph. table */
  
// ABS Label 1393
if(p->pSrc->a[0].iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1393);
}
int csrInput = p->pSrc->a[0].iCursor;     /* Cursor of sub-select */
  int nInput = p->pSrc->a[0].pTab->nCol;    /* Number of cols returned by sub */
  int iInput;                               /* To iterate through sub cols */
  int addrNe;                     /* Address of OP_Ne */
  int addrGosubFlush = 0;         /* Address of OP_Gosub to flush: */
  int addrInteger = 0;            /* Address of OP_Integer */
  int addrEmpty;                  /* Address of OP_Rewind in flush: */
  int regNew;                     /* Array of registers holding new input row */
  int regRecord;                  /* regNew array in record form */
  int regNewPeer = 0;             /* Peer values for new row (part of regNew) */
  int regPeer = 0;                /* Peer values for current row */
  int regFlushPart = 0;           /* Register for "Gosub flush_partition" */
  WindowCodeArg s;                /* Context object for sub-routines */
  int lblWhereEnd;                /* Label just before sqlite3WhereEnd() code */
  int regStart = 0;               /* Value of <expr> PRECEDING */
  int regEnd = 0;                 /* Value of <expr> FOLLOWING */

  assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT 
       || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED 
  );
  assert( pMWin->eEnd==TK_FOLLOWING || pMWin->eEnd==TK_CURRENT 
       || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING 
  );
  assert( pMWin->eExclude==0 || pMWin->eExclude==TK_CURRENT
       || pMWin->eExclude==TK_GROUP || pMWin->eExclude==TK_TIES
       || pMWin->eExclude==TK_NO
  );

  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);

  /* Fill in the context object */
  memset(&s, 0, sizeof(WindowCodeArg));
  s.pParse = pParse;
  s.pMWin = pMWin;
  s.pVdbe = v;
  s.regGosub = regGosub;
  s.addrGosub = addrGosub;
  s.current.csr = pMWin->iEphCsr;
  csrWrite = s.current.csr+1;
  s.start.csr = s.current.csr+2;
  s.end.csr = s.current.csr+3;

  /* Figure out when rows may be deleted from the ephemeral table. There
  ** are four options - they may never be deleted (eDelete==0), they may 
  ** be deleted as soon as they are no longer part of the window frame
  ** (eDelete==WINDOW_AGGINVERSE), they may be deleted as after the row 
  ** has been returned to the caller (WINDOW_RETURN_ROW), or they may
  ** be deleted after they enter the frame (WINDOW_AGGSTEP). */
  switch( pMWin->eStart ){
    case TK_FOLLOWING:
      if( pMWin->eFrmType!=TK_RANGE
       && windowExprGtZero(pParse, pMWin->pStart)
      ){
        s.eDelete = WINDOW_RETURN_ROW;
      }
      break;
    case TK_UNBOUNDED:
      if( windowCacheFrame(pMWin)==0 ){
        
// ROR Label 1420
if((pMWin->eEnd != 88) != (pMWin->eEnd == 88))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1420);
}
if( pMWin->eEnd==TK_PRECEDING ){
          if( pMWin->eFrmType!=TK_RANGE
           && windowExprGtZero(pParse, pMWin->pEnd)
          ){
            s.eDelete = WINDOW_AGGSTEP;
          }
        }else{
          s.eDelete = WINDOW_RETURN_ROW;
        }
      }
      break;
    default:
      s.eDelete = WINDOW_AGGINVERSE;
      break;
  }

  /* Allocate registers for the array of values from the sub-query, the
  ** samve values in record form, and the rowid used to insert said record
  ** into the ephemeral table.  */
  regNew = pParse->nMem+1;
  pParse->nMem += nInput;
  regRecord = ++pParse->nMem;
  s.regRowid = ++pParse->nMem;

  /* If the window frame contains an "<expr> PRECEDING" or "<expr> FOLLOWING"
  ** clause, allocate registers to store the results of evaluating each
  ** <expr>.  */
  
// COR Label 1421
if((pMWin->eStart == 88 && pMWin->eStart == 86) != (pMWin->eStart == 88 || pMWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1421);
}

// ROR Label 1422
if((pMWin->eStart != 88) != (pMWin->eStart == 88))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1422);
}
// ROR Label 1423
if((pMWin->eStart != 86) != (pMWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1423);
}

// MCC Label 1424
if(pMWin->eStart == 88 && pMWin->eStart == 86 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1424);
}
// MCC Label 1425
if(pMWin->eStart == 88 && !(pMWin->eStart == 86) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1425);
}
// MCC Label 1426
if(!(pMWin->eStart == 88) && pMWin->eStart == 86 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1426);
}
// MCC Label 1427
if(!(pMWin->eStart == 88) && !(pMWin->eStart == 86) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1427);
}
if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){
    regStart = ++pParse->nMem;
  }
  
// COR Label 1428
if((pMWin->eEnd == 88 && pMWin->eEnd == 86) != (pMWin->eEnd == 88 || pMWin->eEnd == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1428);
}

// ROR Label 1429
if((pMWin->eEnd != 88) != (pMWin->eEnd == 88))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1429);
}
// ROR Label 1430
if((pMWin->eEnd != 86) != (pMWin->eEnd == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1430);
}

// MCC Label 1431
if(pMWin->eEnd == 88 && pMWin->eEnd == 86 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1431);
}
// MCC Label 1432
if(pMWin->eEnd == 88 && !(pMWin->eEnd == 86) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1432);
}
// MCC Label 1433
if(!(pMWin->eEnd == 88) && pMWin->eEnd == 86 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1433);
}
// MCC Label 1434
if(!(pMWin->eEnd == 88) && !(pMWin->eEnd == 86) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1434);
}
if( pMWin->eEnd==TK_PRECEDING || pMWin->eEnd==TK_FOLLOWING ){
    regEnd = ++pParse->nMem;
  }

  /* If this is not a "ROWS BETWEEN ..." frame, then allocate arrays of
  ** registers to store copies of the ORDER BY expressions (peer values) 
  ** for the main loop, and for each cursor (start, current and end). */
  
// ROR Label 1435
if((pMWin->eFrmType == 76) != (pMWin->eFrmType != 76))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1435);
}
if( pMWin->eFrmType!=TK_ROWS ){
    int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);
    regNewPeer = regNew + pMWin->nBufferCol;
    
// ABS Label 1436
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1436);
}
if( pMWin->pPartition ) { regNewPeer += pMWin->pPartition->nExpr;
}
    regPeer = pParse->nMem+1;       pParse->nMem += nPeer;
    s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;
    s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;
    s.end.reg = pParse->nMem+1;     pParse->nMem += nPeer;
  }

  /* Load the column values for the row returned by the sub-select
  ** into an array of registers starting at regNew. Assemble them into
  ** a record in register regRecord. */
  iInput = 0;

// ABS Label 1437
if(iInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1437);
}
// ABS Label 1438
if(nInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1438);
}

// ROR Label 1439
if((iInput <= nInput) != (iInput < nInput))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1439);
}
// ROR Label 1440
if((iInput > nInput) != (iInput < nInput))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1440);
}
// ROR Label 1441
if((iInput >= nInput) != (iInput < nInput))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1441);
}
for(; iInput<nInput; iInput++){
    
// ABS Label 1447
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1447);
}

// ABS Label 1448
if(csrInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1448);
}

// ABS Label 1449
if(iInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1449);
}

// ABS Label 1450
if(iInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1450);
}
// ABS Label 1451
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1451);
}

// AOR Label 1452
if(regNew - iInput != regNew + iInput)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1452);
}
// AOR Label 1453
if(regNew / iInput != regNew + iInput)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1453);
}
// AOR Label 1454
if(regNew * iInput != regNew + iInput)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1454);
}
sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);
  };
// ABS Label 1442
if(iInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1442);
}
// ABS Label 1443
if(nInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1443);
}

// ROR Label 1444
if((iInput <= nInput) != (iInput < nInput))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1444);
}
// ROR Label 1445
if((iInput > nInput) != (iInput < nInput))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1445);
}
// ROR Label 1446
if((iInput >= nInput) != (iInput < nInput))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1446);
}

  
// ABS Label 1394
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1394);
}

// ABS Label 1395
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1395);
}

// ABS Label 1396
if(nInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1396);
}

// ABS Label 1397
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1397);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);

  /* An input row has just been read into an array of registers starting
  ** at regNew. If the window has a PARTITION clause, this block generates 
  ** VM code to check if the input row is the start of a new partition.
  ** If so, it does an OP_Gosub to an address to be filled in later. The
  ** address of the OP_Gosub is stored in local variable addrGosubFlush. */
  
// ABS Label 1455
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1455);
}
if( pMWin->pPartition ){
    int addr;
    
// ABS Label 1456
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1456);
}
ExprList *pPart = pMWin->pPartition;
    
// ABS Label 1457
if(pPart->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1457);
}
int nPart = pPart->nExpr;
    
// ABS Label 1458
if(pMWin->nBufferCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1458);
}
// ABS Label 1459
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1459);
}

// AOR Label 1460
if(regNew - pMWin->nBufferCol != regNew + pMWin->nBufferCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1460);
}
// AOR Label 1461
if(regNew / pMWin->nBufferCol != regNew + pMWin->nBufferCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1461);
}
// AOR Label 1462
if(regNew * pMWin->nBufferCol != regNew + pMWin->nBufferCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1462);
}
int regNewPart = regNew + pMWin->nBufferCol;
    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);

    regFlushPart = ++pParse->nMem;
    addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);
    
// ABS Label 1463
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1463);
}
sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);
    
// ABS Label 1464
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1464);
}

// ABS Label 1465
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1465);
}

// AOR Label 1466
if(addr - 2 != addr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1466);
}
// AOR Label 1467
if(addr / 2 != addr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1467);
}
// AOR Label 1468
if(addr * 2 != addr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1468);
}

// ABS Label 1469
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1469);
}

// AOR Label 1470
if(addr - 4 != addr + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1470);
}
// AOR Label 1471
if(addr / 4 != addr + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1471);
}
// AOR Label 1472
if(addr * 4 != addr + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1472);
}

// ABS Label 1473
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1473);
}

// AOR Label 1474
if(addr - 2 != addr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1474);
}
// AOR Label 1475
if(addr / 2 != addr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1475);
}
// AOR Label 1476
if(addr * 2 != addr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1476);
}
sqlite3VdbeAddOp3(v, OP_Jump, addr+2, addr+4, addr+2);
    VdbeCoverageEqNe(v);
    addrGosubFlush = sqlite3VdbeAddOp1(v, OP_Gosub, regFlushPart);
    VdbeComment((v, "call flush_partition"));
    
// ABS Label 1477
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1477);
}

// ABS Label 1478
if(regNewPart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1478);
}

// ABS Label 1479
if(pMWin->regPart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1479);
}

// ABS Label 1480
if(nPart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1480);
}

// AOR Label 1481
if(nPart / 1 != nPart - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1481);
}
// AOR Label 1482
if(nPart + 1 != nPart - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1482);
}
// AOR Label 1483
if(nPart * 1 != nPart - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1483);
}
sqlite3VdbeAddOp3(v, OP_Copy, regNewPart, pMWin->regPart, nPart-1);
  }

  /* Insert the new row into the ephemeral table */
  
// ABS Label 1398
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1398);
}

// ABS Label 1399
if(csrWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1399);
}

// ABS Label 1400
if(s.regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1400);
}
sqlite3VdbeAddOp2(v, OP_NewRowid, csrWrite, s.regRowid);
  
// ABS Label 1401
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1401);
}

// ABS Label 1402
if(csrWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1402);
}

// ABS Label 1403
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1403);
}

// ABS Label 1404
if(s.regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1404);
}
sqlite3VdbeAddOp3(v, OP_Insert, csrWrite, regRecord, s.regRowid);
  addrNe = sqlite3VdbeAddOp3(v, OP_Ne, pMWin->regOne, 0, s.regRowid);
  VdbeCoverageNeverNull(v);

  /* This block is run for the first row of each partition */
  s.regArg = windowInitAccum(pParse, pMWin);

  
// ABS Label 1484
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1484);
}
if( regStart ){
    
// ABS Label 1485
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1485);
}

// ABS Label 1486
if(pMWin->pStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1486);
}

// ABS Label 1487
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1487);
}
sqlite3ExprCode(pParse, pMWin->pStart, regStart);
    
// ABS Label 1488
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1488);
}

// ABS Label 1489
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1489);
}

// AOR Label 1490
if(0 - (pMWin->eFrmType == 89 ? 3 : 0) != 0 + (pMWin->eFrmType == 89 ? 3 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1490);
}
// AOR Label 1491
if(0 / (pMWin->eFrmType == 89 ? 3 : 0) != 0 + (pMWin->eFrmType == 89 ? 3 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1491);
}
// AOR Label 1492
if(0 * (pMWin->eFrmType == 89 ? 3 : 0) != 0 + (pMWin->eFrmType == 89 ? 3 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1492);
}
windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==TK_RANGE?3:0));
  }
  
// ABS Label 1493
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1493);
}
if( regEnd ){
    
// ABS Label 1494
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1494);
}

// ABS Label 1495
if(pMWin->pEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1495);
}

// ABS Label 1496
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1496);
}
sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);
    
// ABS Label 1497
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1497);
}

// ABS Label 1498
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1498);
}

// AOR Label 1499
if(1 - (pMWin->eFrmType == 89 ? 3 : 0) != 1 + (pMWin->eFrmType == 89 ? 3 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1499);
}
// AOR Label 1500
if(1 / (pMWin->eFrmType == 89 ? 3 : 0) != 1 + (pMWin->eFrmType == 89 ? 3 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1500);
}
// AOR Label 1501
if(1 * (pMWin->eFrmType == 89 ? 3 : 0) != 1 + (pMWin->eFrmType == 89 ? 3 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1501);
}
windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==TK_RANGE?3:0));
  }

  
// ABS Label 1502
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1502);
}

// COR Label 1503
if((pMWin->eFrmType != 89 && pMWin->eStart == pMWin->eEnd || regStart) != (pMWin->eFrmType != 89 && pMWin->eStart == pMWin->eEnd && regStart))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1503);
}
// COR Label 1504
if((pMWin->eFrmType != 89 || pMWin->eStart == pMWin->eEnd) != (pMWin->eFrmType != 89 && pMWin->eStart == pMWin->eEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1504);
}

// ROR Label 1505
if((pMWin->eFrmType == 89) != (pMWin->eFrmType != 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1505);
}
// ROR Label 1506
if((pMWin->eStart != pMWin->eEnd) != (pMWin->eStart == pMWin->eEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1506);
}

// MCC Label 1507
if(pMWin->eFrmType != 89 && pMWin->eStart == pMWin->eEnd && regStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1507);
}
// MCC Label 1508
if(pMWin->eFrmType != 89 && pMWin->eStart == pMWin->eEnd && !(regStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1508);
}
// MCC Label 1509
if(pMWin->eFrmType != 89 && !(pMWin->eStart == pMWin->eEnd) && regStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1509);
}
// MCC Label 1510
if(pMWin->eFrmType != 89 && !(pMWin->eStart == pMWin->eEnd) && !(regStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1510);
}
// MCC Label 1511
if(!(pMWin->eFrmType != 89) && pMWin->eStart == pMWin->eEnd && regStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1511);
}
// MCC Label 1512
if(!(pMWin->eFrmType != 89) && pMWin->eStart == pMWin->eEnd && !(regStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1512);
}
// MCC Label 1513
if(!(pMWin->eFrmType != 89) && !(pMWin->eStart == pMWin->eEnd) && regStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1513);
}
// MCC Label 1514
if(!(pMWin->eFrmType != 89) && !(pMWin->eStart == pMWin->eEnd) && !(regStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1514);
}
if( pMWin->eFrmType!=TK_RANGE && pMWin->eStart==pMWin->eEnd && regStart ){
    int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);
    int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);
    VdbeCoverageNeverNullIf(v, op==OP_Ge); /* NeverNull because bound <expr> */
    VdbeCoverageNeverNullIf(v, op==OP_Le); /*   values previously checked */
    windowAggFinal(&s, 0);
    
// ABS Label 1515
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1515);
}

// ABS Label 1516
if(s.current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1516);
}
sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);
    VdbeCoverageNeverTaken(v);
    windowReturnOneRow(&s);
    
// ABS Label 1517
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1517);
}

// ABS Label 1518
if(s.current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1518);
}
sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);
    
// ABS Label 1519
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1519);
}

// ABS Label 1520
if(lblWhereEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1520);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);
    
// ABS Label 1521
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1521);
}

// ABS Label 1522
if(addrGe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1522);
}
sqlite3VdbeJumpHere(v, addrGe);
  }
  
// ABS Label 1523
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1523);
}

// COR Label 1524
if((pMWin->eStart == 86 && pMWin->eFrmType != 89 || regEnd) != (pMWin->eStart == 86 && pMWin->eFrmType != 89 && regEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1524);
}
// COR Label 1525
if((pMWin->eStart == 86 || pMWin->eFrmType != 89) != (pMWin->eStart == 86 && pMWin->eFrmType != 89))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1525);
}

// ROR Label 1526
if((pMWin->eStart != 86) != (pMWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1526);
}
// ROR Label 1527
if((pMWin->eFrmType == 89) != (pMWin->eFrmType != 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1527);
}

// MCC Label 1528
if(pMWin->eStart == 86 && pMWin->eFrmType != 89 && regEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1528);
}
// MCC Label 1529
if(pMWin->eStart == 86 && pMWin->eFrmType != 89 && !(regEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1529);
}
// MCC Label 1530
if(pMWin->eStart == 86 && !(pMWin->eFrmType != 89) && regEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1530);
}
// MCC Label 1531
if(pMWin->eStart == 86 && !(pMWin->eFrmType != 89) && !(regEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1531);
}
// MCC Label 1532
if(!(pMWin->eStart == 86) && pMWin->eFrmType != 89 && regEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1532);
}
// MCC Label 1533
if(!(pMWin->eStart == 86) && pMWin->eFrmType != 89 && !(regEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1533);
}
// MCC Label 1534
if(!(pMWin->eStart == 86) && !(pMWin->eFrmType != 89) && regEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1534);
}
// MCC Label 1535
if(!(pMWin->eStart == 86) && !(pMWin->eFrmType != 89) && !(regEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1535);
}
if( pMWin->eStart==TK_FOLLOWING && pMWin->eFrmType!=TK_RANGE && regEnd ){
    assert( pMWin->eEnd==TK_FOLLOWING );
    
// ABS Label 1536
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1536);
}

// ABS Label 1537
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1537);
}

// ABS Label 1538
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1538);
}

// ABS Label 1539
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1539);
}
sqlite3VdbeAddOp3(v, OP_Subtract, regStart, regEnd, regStart);
  }

  
// ROR Label 1540
if((pMWin->eStart == 90) != (pMWin->eStart != 90))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1540);
}
if( pMWin->eStart!=TK_UNBOUNDED ){
    
// ABS Label 1541
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1541);
}

// ABS Label 1542
if(s.start.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1542);
}
sqlite3VdbeAddOp2(v, OP_Rewind, s.start.csr, 1);
    VdbeCoverageNeverTaken(v);
  }
  
// ABS Label 1405
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1405);
}

// ABS Label 1406
if(s.current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1406);
}
sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);
  VdbeCoverageNeverTaken(v);
  
// ABS Label 1407
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1407);
}

// ABS Label 1408
if(s.end.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1408);
}
sqlite3VdbeAddOp2(v, OP_Rewind, s.end.csr, 1);
  VdbeCoverageNeverTaken(v);
  
// ABS Label 1543
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1543);
}
// ABS Label 1544
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1544);
}

// COR Label 1545
if((regPeer || pOrderBy) != (regPeer && pOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1545);
}

// MCC Label 1546
if(regPeer && pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1546);
}
// MCC Label 1547
if(regPeer && !(pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1547);
}
// MCC Label 1548
if(!(regPeer) && pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1548);
}
// MCC Label 1549
if(!(regPeer) && !(pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1549);
}
if( regPeer && pOrderBy ){
    
// ABS Label 1550
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1550);
}

// ABS Label 1551
if(regNewPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1551);
}

// ABS Label 1552
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1552);
}

// ABS Label 1553
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1553);
}

// AOR Label 1554
if(pOrderBy->nExpr / 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1554);
}
// AOR Label 1555
if(pOrderBy->nExpr + 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1555);
}
// AOR Label 1556
if(pOrderBy->nExpr * 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1556);
}
sqlite3VdbeAddOp3(v, OP_Copy, regNewPeer, regPeer, pOrderBy->nExpr-1);
    
// ABS Label 1557
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1557);
}

// ABS Label 1558
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1558);
}

// ABS Label 1559
if(s.start.reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1559);
}

// ABS Label 1560
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1560);
}

// AOR Label 1561
if(pOrderBy->nExpr / 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1561);
}
// AOR Label 1562
if(pOrderBy->nExpr + 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1562);
}
// AOR Label 1563
if(pOrderBy->nExpr * 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1563);
}
sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.start.reg, pOrderBy->nExpr-1);
    
// ABS Label 1564
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1564);
}

// ABS Label 1565
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1565);
}

// ABS Label 1566
if(s.current.reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1566);
}

// ABS Label 1567
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1567);
}

// AOR Label 1568
if(pOrderBy->nExpr / 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1568);
}
// AOR Label 1569
if(pOrderBy->nExpr + 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1569);
}
// AOR Label 1570
if(pOrderBy->nExpr * 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1570);
}
sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.current.reg, pOrderBy->nExpr-1);
    
// ABS Label 1571
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1571);
}

// ABS Label 1572
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1572);
}

// ABS Label 1573
if(s.end.reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1573);
}

// ABS Label 1574
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1574);
}

// AOR Label 1575
if(pOrderBy->nExpr / 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1575);
}
// AOR Label 1576
if(pOrderBy->nExpr + 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1576);
}
// AOR Label 1577
if(pOrderBy->nExpr * 1 != pOrderBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1577);
}
sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.end.reg, pOrderBy->nExpr-1);
  }

  
// ABS Label 1409
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1409);
}

// ABS Label 1410
if(lblWhereEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1410);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);

  
// ABS Label 1411
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1411);
}

// ABS Label 1412
if(addrNe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1412);
}
sqlite3VdbeJumpHere(v, addrNe);

  /* Beginning of the block executed for the second and subsequent rows. */
  
// ABS Label 1578
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1578);
}
if( regPeer ){
    
// ABS Label 1579
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1579);
}

// ABS Label 1580
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1580);
}

// ABS Label 1581
if(regNewPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1581);
}

// ABS Label 1582
if(regPeer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1582);
}

// ABS Label 1583
if(lblWhereEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1583);
}
windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);
  }
  
// ROR Label 1584
if((pMWin->eStart != 86) != (pMWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1584);
}
if( pMWin->eStart==TK_FOLLOWING ){
    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
    
// ROR Label 1585
if((pMWin->eEnd == 90) != (pMWin->eEnd != 90))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1585);
}
if( pMWin->eEnd!=TK_UNBOUNDED ){
      
// ROR Label 1586
if((pMWin->eFrmType != 89) != (pMWin->eFrmType == 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1586);
}
if( pMWin->eFrmType==TK_RANGE ){
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int addrNext = sqlite3VdbeCurrentAddr(v);
        
// ABS Label 1587
if(s.current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1587);
}

// ABS Label 1588
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1588);
}

// ABS Label 1589
if(s.end.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1589);
}

// ABS Label 1590
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1590);
}
windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);
        
// ABS Label 1591
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1591);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
        
// ABS Label 1592
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1592);
}

// ABS Label 1593
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1593);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNext);
        
// ABS Label 1594
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1594);
}

// ABS Label 1595
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1595);
}
sqlite3VdbeResolveLabel(v, lbl);
      }else{
        
// ABS Label 1596
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1596);
}
windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 0);
        
// ABS Label 1597
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1597);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
      }
    }
  }else {
  
// ROR Label 1598
if((pMWin->eEnd != 88) != (pMWin->eEnd == 88))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1598);
}
if( pMWin->eEnd==TK_PRECEDING ){
    int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);
    
// ABS Label 1599
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1599);
}
windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);
    
// ABS Label 1600
if(bRPS < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1600);
}
if( bRPS ) { 
// ABS Label 1601
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1601);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
}
    windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
    if( !bRPS ) { 
// ABS Label 1602
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1602);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
}
  }else{
    int addr = 0;
    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
    
// ROR Label 1603
if((pMWin->eEnd == 90) != (pMWin->eEnd != 90))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1603);
}
if( pMWin->eEnd!=TK_UNBOUNDED ){
      
// ROR Label 1604
if((pMWin->eFrmType != 89) != (pMWin->eFrmType == 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1604);
}
if( pMWin->eFrmType==TK_RANGE ){
        int lbl = 0;
        addr = sqlite3VdbeCurrentAddr(v);
        
// ABS Label 1606
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1606);
}
if( regEnd ){
          lbl = sqlite3VdbeMakeLabel(pParse);
          
// ABS Label 1607
if(s.current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1607);
}

// ABS Label 1608
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1608);
}

// ABS Label 1609
if(s.end.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1609);
}

// ABS Label 1610
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1610);
}
windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);
        }
        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
        
// ABS Label 1605
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1605);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
        
// ABS Label 1611
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1611);
}
if( regEnd ){
          
// ABS Label 1612
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1612);
}

// ABS Label 1613
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1613);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);
          
// ABS Label 1614
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1614);
}

// ABS Label 1615
if(lbl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1615);
}
sqlite3VdbeResolveLabel(v, lbl);
        }
      }else{
        
// ABS Label 1617
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1617);
}
if( regEnd ){
          addr = sqlite3VdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);
          VdbeCoverage(v);
        }
        windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
        
// ABS Label 1616
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1616);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
        
// ABS Label 1618
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1618);
}
if( regEnd ) { 
// ABS Label 1619
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1619);
}

// ABS Label 1620
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1620);
}
sqlite3VdbeJumpHere(v, addr);
}
      }
    }
  };}


  /* End of the main input loop */
  
// ABS Label 1413
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1413);
}

// ABS Label 1414
if(lblWhereEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1414);
}
sqlite3VdbeResolveLabel(v, lblWhereEnd);
  
// ABS Label 1415
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1415);
}
sqlite3WhereEnd(pWInfo);

  /* Fall through */
  
// ABS Label 1621
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1621);
}
if( pMWin->pPartition ){
    addrInteger = sqlite3VdbeAddOp2(v, OP_Integer, 0, regFlushPart);
    
// ABS Label 1622
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1622);
}

// ABS Label 1623
if(addrGosubFlush < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1623);
}
sqlite3VdbeJumpHere(v, addrGosubFlush);
  }

  s.regRowid = 0;
  addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);
  VdbeCoverage(v);
  
// ROR Label 1624
if((pMWin->eEnd != 88) != (pMWin->eEnd == 88))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1624);
}
if( pMWin->eEnd==TK_PRECEDING ){
    int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);
    
// ABS Label 1625
if(regEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1625);
}
windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);
    
// ABS Label 1626
if(bRPS < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1626);
}
if( bRPS ) { 
// ABS Label 1627
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1627);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
}
    windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
  }else { 
// ROR Label 1628
if((pMWin->eStart != 86) != (pMWin->eStart == 86))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1628);
}
if( pMWin->eStart==TK_FOLLOWING ){
    int addrStart;
    int addrBreak1;
    int addrBreak2;
    int addrBreak3;
    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
    
// ROR Label 1639
if((pMWin->eFrmType != 89) != (pMWin->eFrmType == 89))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1639);
}
if( pMWin->eFrmType==TK_RANGE ){
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);
      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);
    }else {
    
// ROR Label 1640
if((pMWin->eEnd != 90) != (pMWin->eEnd == 90))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1640);
}
if( pMWin->eEnd==TK_UNBOUNDED ){
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regStart, 1);
      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, 0, 1);
    }else{
      assert( pMWin->eEnd==TK_FOLLOWING );
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 1);
      addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);
    };}

    
// ABS Label 1629
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1629);
}

// ABS Label 1630
if(addrStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1630);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);
    
// ABS Label 1631
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1631);
}

// ABS Label 1632
if(addrBreak2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1632);
}
sqlite3VdbeJumpHere(v, addrBreak2);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak3 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);
    
// ABS Label 1633
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1633);
}

// ABS Label 1634
if(addrStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1634);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);
    
// ABS Label 1635
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1635);
}

// ABS Label 1636
if(addrBreak1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1636);
}
sqlite3VdbeJumpHere(v, addrBreak1);
    
// ABS Label 1637
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1637);
}

// ABS Label 1638
if(addrBreak3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1638);
}
sqlite3VdbeJumpHere(v, addrBreak3);
  }else{
    int addrBreak;
    int addrStart;
    windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);
    
// ABS Label 1641
if(regStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1641);
}
windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
    
// ABS Label 1642
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1642);
}

// ABS Label 1643
if(addrStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1643);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);
    
// ABS Label 1644
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1644);
}

// ABS Label 1645
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1645);
}
sqlite3VdbeJumpHere(v, addrBreak);
  };}

  
// ABS Label 1416
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1416);
}

// ABS Label 1417
if(addrEmpty < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1417);
}
sqlite3VdbeJumpHere(v, addrEmpty);

  
// ABS Label 1418
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1418);
}

// ABS Label 1419
if(s.current.csr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1419);
}
sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);
  
// ABS Label 1646
if(pMWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1646);
}
if( pMWin->pPartition ){
    
// ABS Label 1651
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1651);
}
if( pMWin->regStartRowid ){
      
// ABS Label 1652
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1652);
}

// ABS Label 1653
if(pMWin->regStartRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1653);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);
      
// ABS Label 1654
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1654);
}

// ABS Label 1655
if(pMWin->regEndRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1655);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);
    }
    
// ABS Label 1647
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1647);
}

// ABS Label 1648
if(addrInteger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1648);
}
sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));
    
// ABS Label 1649
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1649);
}

// ABS Label 1650
if(regFlushPart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1650);
}
sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);
  }
}

#endif /* SQLITE_OMIT_WINDOWFUNC */
