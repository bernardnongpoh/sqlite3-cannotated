/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2018-04-12
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement various aspects of UPSERT
** processing and handling of the Upsert object.
*/
#include "sqliteInt.h"

#ifndef SQLITE_OMIT_UPSERT
/*
** Free a list of Upsert objects
*/
static void SQLITE_NOINLINE upsertDelete(sqlite3 *db, Upsert *p){
  
// ABS Label 7
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
do{
    
// ABS Label 9
if(p->pNextUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
Upsert *pNext = p->pNextUpsert;
    
// ABS Label 10
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}

// ABS Label 11
if(p->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
sqlite3ExprListDelete(db, p->pUpsertTarget);
    
// ABS Label 12
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ABS Label 13
if(p->pUpsertTargetWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
sqlite3ExprDelete(db, p->pUpsertTargetWhere);
    
// ABS Label 14
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ABS Label 15
if(p->pUpsertSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
sqlite3ExprListDelete(db, p->pUpsertSet);
    
// ABS Label 16
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ABS Label 17
if(p->pUpsertWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
sqlite3ExprDelete(db, p->pUpsertWhere);
    
// ABS Label 18
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ABS Label 19
if(p->pToFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3DbFree(db, p->pToFree);
    
// ABS Label 20
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
sqlite3DbFree(db, p);
    p = pNext;
  }while( p );
// ABS Label 8
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
;
}
void sqlite3UpsertDelete(sqlite3 *db, Upsert *p){
  
// ABS Label 21
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
if( p ) { 
// ABS Label 22
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ABS Label 23
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
upsertDelete(db, p);
}
}


/*
** Duplicate an Upsert object.
*/
Upsert *sqlite3UpsertDup(sqlite3 *db, Upsert *p){
  
// ABS Label 24
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// ROR Label 25
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
if( p==0 ) { return 0;
}
  return sqlite3UpsertNew(db,
           sqlite3ExprListDup(db, p->pUpsertTarget, 0),
           sqlite3ExprDup(db, p->pUpsertTargetWhere, 0),
           sqlite3ExprListDup(db, p->pUpsertSet, 0),
           sqlite3ExprDup(db, p->pUpsertWhere, 0),
           sqlite3UpsertDup(db, p->pNextUpsert)
         );
}

/*
** Create a new Upsert object.
*/
Upsert *sqlite3UpsertNew(
  sqlite3 *db,           /* Determines which memory allocator to use */
  ExprList *pTarget,     /* Target argument to ON CONFLICT, or NULL */
  Expr *pTargetWhere,    /* Optional WHERE clause on the target */
  ExprList *pSet,        /* UPDATE columns, or NULL for a DO NOTHING */
  Expr *pWhere,          /* WHERE clause for the ON CONFLICT UPDATE */
  Upsert *pNext          /* Next ON CONFLICT clause in the list */
){
  Upsert *pNew;
  pNew = sqlite3DbMallocZero(db, sizeof(Upsert));
  
// ABS Label 26
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// ROR Label 27
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
if( pNew==0 ){
    
// ABS Label 28
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ABS Label 29
if(pTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
sqlite3ExprListDelete(db, pTarget);
    
// ABS Label 30
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// ABS Label 31
if(pTargetWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
sqlite3ExprDelete(db, pTargetWhere);
    
// ABS Label 32
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}

// ABS Label 33
if(pSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3ExprListDelete(db, pSet);
    
// ABS Label 34
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ABS Label 35
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
sqlite3ExprDelete(db, pWhere);
    
// ABS Label 36
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ABS Label 37
if(pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
sqlite3UpsertDelete(db, pNext);
    return 0;
  }else{
    pNew->pUpsertTarget = pTarget;
    pNew->pUpsertTargetWhere = pTargetWhere;
    pNew->pUpsertSet = pSet;
    pNew->pUpsertWhere = pWhere;
    pNew->isDoUpdate = pSet!=0;
    pNew->pNextUpsert = pNext;
  }
  
// ABS Label 38
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
return pNew;
}

/*
** Analyze the ON CONFLICT clause described by pUpsert.  Resolve all
** symbols in the conflict-target.
**
** Return SQLITE_OK if everything works, or an error code is something
** is wrong.
*/
int sqlite3UpsertAnalyzeTarget(
  Parse *pParse,     /* The parsing context */
  SrcList *pTabList, /* Table into which we are inserting */
  Upsert *pUpsert    /* The ON CONFLICT clauses */
){
  Table *pTab;            /* That table into which we are inserting */
  int rc;                 /* Result code */
  int iCursor;            /* Cursor used by pTab */
  Index *pIdx;            /* One of the indexes of pTab */
  ExprList *pTarget;      /* The conflict-target clause */
  Expr *pTerm;            /* One term of the conflict-target clause */
  NameContext sNC;        /* Context for resolving symbolic names */
  Expr sCol[2];           /* Index column converted into an Expr */
  int nClause = 0;        /* Counter of ON CONFLICT clauses */

  assert( pTabList->nSrc==1 );
  assert( pTabList->a[0].pTab!=0 );
  assert( pUpsert!=0 );
  assert( pUpsert->pUpsertTarget!=0 );

  /* Resolve all symbolic names in the conflict-target clause, which
  ** includes both the list of columns and the optional partial-index
  ** WHERE clause.
  */
  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  
// ABS Label 39
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
// ABS Label 40
if(pUpsert->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}

// COR Label 41
if((pUpsert || pUpsert->pUpsertTarget) != (pUpsert && pUpsert->pUpsertTarget))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 41);
}

// MCC Label 42
if(pUpsert && pUpsert->pUpsertTarget ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
// MCC Label 43
if(pUpsert && !(pUpsert->pUpsertTarget) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 43);
}
// MCC Label 44
if(!(pUpsert) && pUpsert->pUpsertTarget ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 44);
}
// MCC Label 45
if(!(pUpsert) && !(pUpsert->pUpsertTarget) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 45);
}
for(; pUpsert && pUpsert->pUpsertTarget;
        pUpsert=pUpsert->pNextUpsert, nClause++){
    rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);
    
// ABS Label 53
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
if( rc ) { 
// ABS Label 54
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}
return rc;
}
    rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);
    
// ABS Label 55
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}
if( rc ) { 
// ABS Label 56
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}
return rc;
}
  
    /* Check to see if the conflict target matches the rowid. */  
    pTab = pTabList->a[0].pTab;
    pTarget = pUpsert->pUpsertTarget;
    iCursor = pTabList->a[0].iCursor;
    if( HasRowid(pTab) 
     && pTarget->nExpr==1
     && (pTerm = pTarget->a[0].pExpr)->op==TK_COLUMN
     && pTerm->iColumn==XN_ROWID
    ){
      /* The conflict-target is the rowid of the primary table */
      assert( pUpsert->pUpsertIdx==0 );
      continue;
    }
  
    /* Initialize sCol[0..1] to be an expression parse tree for a
    ** single column of an index.  The sCol[0] node will be the TK_COLLATE
    ** operator and sCol[1] will be the TK_COLUMN operator.  Code below
    ** will populate the specific collation and column number values
    ** prior to comparing against the conflict-target expression.
    */
    memset(sCol, 0, sizeof(sCol));
    sCol[0].op = TK_COLLATE;
    sCol[0].pLeft = &sCol[1];
    sCol[1].op = TK_COLUMN;
    sCol[1].iTable = pTabList->a[0].iCursor;
  
    /* Check for matches against other indexes */
    pIdx = pTab->pIndex;

// ABS Label 57
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
for(; pIdx; pIdx=pIdx->pNext){
      int ii, jj, nn;
      if( !IsUniqueIndex(pIdx) ) { continue;
}
      
// ABS Label 59
if(pTarget->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}

// ROR Label 60
if((pTarget->nExpr == pIdx->nKeyCol) != (pTarget->nExpr != pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
if( pTarget->nExpr!=pIdx->nKeyCol ) { continue;
}
      
// ABS Label 61
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
if( pIdx->pPartIdxWhere ){
        
// ABS Label 62
if(pUpsert->pUpsertTargetWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// ROR Label 63
if((pUpsert->pUpsertTargetWhere != 0) != (pUpsert->pUpsertTargetWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
if( pUpsert->pUpsertTargetWhere==0 ) { continue;
}
        if( sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere,
                               pIdx->pPartIdxWhere, iCursor)!=0 ){
          continue;
        }
      }
      nn = pIdx->nKeyCol;
      ii = 0;

// ABS Label 64
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}
// ABS Label 65
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}

// ROR Label 66
if((ii <= nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
// ROR Label 67
if((ii > nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
// ROR Label 68
if((ii >= nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
for(; ii<nn; ii++){
        Expr *pExpr;
        sCol[0].u.zToken = (char*)pIdx->azColl[ii];
        
// ROR Label 74
if((pIdx->aiColumn[ii] != (-2)) != (pIdx->aiColumn[ii] == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
if( pIdx->aiColumn[ii]==XN_EXPR ){
          assert( pIdx->aColExpr!=0 );
          assert( pIdx->aColExpr->nExpr>ii );
          pExpr = pIdx->aColExpr->a[ii].pExpr;
          
// ROR Label 75
if((pExpr->op == 112) != (pExpr->op != 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
if( pExpr->op!=TK_COLLATE ){
            sCol[0].pLeft = pExpr;
            pExpr = &sCol[0];
          }
        }else{
          sCol[0].pLeft = &sCol[1];
          sCol[1].iColumn = pIdx->aiColumn[ii];
          pExpr = &sCol[0];
        }
        jj = 0;

// ABS Label 76
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
// ABS Label 77
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((jj <= nn) != (jj < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
// ROR Label 79
if((jj > nn) != (jj < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
// ROR Label 80
if((jj >= nn) != (jj < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
for(; jj<nn; jj++){
          if( sqlite3ExprCompare(pParse,pTarget->a[jj].pExpr,pExpr,iCursor)<2 ){
            break;  /* Column ii of the index matches column jj of target */
          }
        };
// ABS Label 81
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
// ABS Label 82
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}

// ROR Label 83
if((jj <= nn) != (jj < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
// ROR Label 84
if((jj > nn) != (jj < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 84);
}
// ROR Label 85
if((jj >= nn) != (jj < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}

        
// ABS Label 86
if(jj < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
// ABS Label 87
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// ROR Label 88
if((jj < nn) != (jj >= nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 88);
}
// ROR Label 89
if((jj > nn) != (jj >= nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 89);
}
// ROR Label 90
if((jj <= nn) != (jj >= nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( jj>=nn ){
          /* The target contains no match for column jj of the index */
          break;
        }
      };
// ABS Label 69
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}
// ABS Label 70
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((ii <= nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
// ROR Label 72
if((ii > nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}
// ROR Label 73
if((ii >= nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}

      
// ABS Label 91
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
// ABS Label 92
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// ROR Label 93
if((ii <= nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
// ROR Label 94
if((ii > nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 94);
}
// ROR Label 95
if((ii >= nn) != (ii < nn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
if( ii<nn ){
        /* Column ii of the index did not match any term of the conflict target.
        ** Continue the search with the next index. */
        continue;
      }
      pUpsert->pUpsertIdx = pIdx;
      break;
    };
// ABS Label 58
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}

    
// ABS Label 96
if(pUpsert->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}

// ROR Label 97
if((pUpsert->pUpsertIdx != 0) != (pUpsert->pUpsertIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
if( pUpsert->pUpsertIdx==0 ){
      char zWhich[16];
      
// ABS Label 99
if(nClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
// ABS Label 100
if(pUpsert->pNextUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}

// COR Label 101
if((nClause == 0 || pUpsert->pNextUpsert == 0) != (nClause == 0 && pUpsert->pNextUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 101);
}

// ROR Label 102
if((nClause != 0) != (nClause == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 102);
}
// ROR Label 103
if((pUpsert->pNextUpsert != 0) != (pUpsert->pNextUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 103);
}

// MCC Label 104
if(nClause == 0 && pUpsert->pNextUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 104);
}
// MCC Label 105
if(nClause == 0 && !(pUpsert->pNextUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 105);
}
// MCC Label 106
if(!(nClause == 0) && pUpsert->pNextUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 106);
}
// MCC Label 107
if(!(nClause == 0) && !(pUpsert->pNextUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 107);
}
if( nClause==0 && pUpsert->pNextUpsert==0 ){
        zWhich[0] = 0;
      }else{
        
// ABS Label 108
if(nClause < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}

// AOR Label 109
if(nClause - 1 != nClause + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 109);
}
// AOR Label 110
if(nClause / 1 != nClause + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 110);
}
// AOR Label 111
if(nClause * 1 != nClause + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 111);
}
sqlite3_snprintf(sizeof(zWhich),zWhich,"%r ", nClause+1);
      }
      
// ABS Label 98
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
sqlite3ErrorMsg(pParse, "%sON CONFLICT clause does not match any "
                              "PRIMARY KEY or UNIQUE constraint", zWhich);
      return SQLITE_ERROR;
    }
  };
// ABS Label 46
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
// ABS Label 47
if(pUpsert->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// COR Label 48
if((pUpsert || pUpsert->pUpsertTarget) != (pUpsert && pUpsert->pUpsertTarget))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 48);
}

// MCC Label 49
if(pUpsert && pUpsert->pUpsertTarget ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 49);
}
// MCC Label 50
if(pUpsert && !(pUpsert->pUpsertTarget) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 50);
}
// MCC Label 51
if(!(pUpsert) && pUpsert->pUpsertTarget ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 51);
}
// MCC Label 52
if(!(pUpsert) && !(pUpsert->pUpsertTarget) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 52);
}

  return SQLITE_OK;
}

/*
** Return true if pUpsert is the last ON CONFLICT clause with a
** conflict target, or if pUpsert is followed by another ON CONFLICT
** clause that targets the INTEGER PRIMARY KEY.
*/
int sqlite3UpsertNextIsIPK(Upsert *pUpsert){
  Upsert *pNext;
  
// MCC Label 112
if(( pUpsert == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(( !(pUpsert == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
if( NEVER(pUpsert==0) ) { return 0;
}
  pNext = pUpsert->pNextUpsert;
  
// ABS Label 114
if(pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// ROR Label 115
if((pNext != 0) != (pNext == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
if( pNext==0 ) { return 1;
}
  
// ABS Label 116
if(pNext->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ROR Label 117
if((pNext->pUpsertTarget != 0) != (pNext->pUpsertTarget == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
if( pNext->pUpsertTarget==0 ) { return 1;
}
  
// ABS Label 118
if(pNext->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// ROR Label 119
if((pNext->pUpsertIdx != 0) != (pNext->pUpsertIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
if( pNext->pUpsertIdx==0 ) { return 1;
}
  return 0;
}

/*
** Given the list of ON CONFLICT clauses described by pUpsert, and
** a particular index pIdx, return a pointer to the particular ON CONFLICT
** clause that applies to the index.  Or, if the index is not subject to
** any ON CONFLICT clause, return NULL.
*/
Upsert *sqlite3UpsertOfIndex(Upsert *pUpsert, Index *pIdx){
  
// ABS Label 120
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}
// ABS Label 121
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}
// ABS Label 122
if(pUpsert->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}
// ABS Label 123
if(pUpsert->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}

// COR Label 124
if((pUpsert && pUpsert->pUpsertTarget != 0 || pUpsert->pUpsertIdx != pIdx) != (pUpsert && pUpsert->pUpsertTarget != 0 && pUpsert->pUpsertIdx != pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 124);
}
// COR Label 125
if((pUpsert || pUpsert->pUpsertTarget != 0) != (pUpsert && pUpsert->pUpsertTarget != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 125);
}

// ROR Label 126
if((pUpsert->pUpsertTarget == 0) != (pUpsert->pUpsertTarget != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
// ROR Label 127
if((pUpsert->pUpsertIdx == pIdx) != (pUpsert->pUpsertIdx != pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 127);
}

// MCC Label 128
if(pUpsert && pUpsert->pUpsertTarget != 0 && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 128);
}
// MCC Label 129
if(pUpsert && pUpsert->pUpsertTarget != 0 && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
// MCC Label 130
if(pUpsert && !(pUpsert->pUpsertTarget != 0) && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
// MCC Label 131
if(pUpsert && !(pUpsert->pUpsertTarget != 0) && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 131);
}
// MCC Label 132
if(!(pUpsert) && pUpsert->pUpsertTarget != 0 && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
// MCC Label 133
if(!(pUpsert) && pUpsert->pUpsertTarget != 0 && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 133);
}
// MCC Label 134
if(!(pUpsert) && !(pUpsert->pUpsertTarget != 0) && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 134);
}
// MCC Label 135
if(!(pUpsert) && !(pUpsert->pUpsertTarget != 0) && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
while(
      pUpsert
   && pUpsert->pUpsertTarget!=0
   && pUpsert->pUpsertIdx!=pIdx
  ){
     pUpsert = pUpsert->pNextUpsert;
  };
// ABS Label 136
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
// ABS Label 137
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
// ABS Label 138
if(pUpsert->pUpsertIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}
// ABS Label 139
if(pUpsert->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}

// COR Label 140
if((pUpsert && pUpsert->pUpsertTarget != 0 || pUpsert->pUpsertIdx != pIdx) != (pUpsert && pUpsert->pUpsertTarget != 0 && pUpsert->pUpsertIdx != pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 140);
}
// COR Label 141
if((pUpsert || pUpsert->pUpsertTarget != 0) != (pUpsert && pUpsert->pUpsertTarget != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 141);
}

// ROR Label 142
if((pUpsert->pUpsertTarget == 0) != (pUpsert->pUpsertTarget != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((pUpsert->pUpsertIdx == pIdx) != (pUpsert->pUpsertIdx != pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}

// MCC Label 144
if(pUpsert && pUpsert->pUpsertTarget != 0 && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 144);
}
// MCC Label 145
if(pUpsert && pUpsert->pUpsertTarget != 0 && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 145);
}
// MCC Label 146
if(pUpsert && !(pUpsert->pUpsertTarget != 0) && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 146);
}
// MCC Label 147
if(pUpsert && !(pUpsert->pUpsertTarget != 0) && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(!(pUpsert) && pUpsert->pUpsertTarget != 0 && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
// MCC Label 149
if(!(pUpsert) && pUpsert->pUpsertTarget != 0 && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 149);
}
// MCC Label 150
if(!(pUpsert) && !(pUpsert->pUpsertTarget != 0) && pUpsert->pUpsertIdx != pIdx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 150);
}
// MCC Label 151
if(!(pUpsert) && !(pUpsert->pUpsertTarget != 0) && !(pUpsert->pUpsertIdx != pIdx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 151);
}

  
// ABS Label 152
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}
return pUpsert;
}

/*
** Generate bytecode that does an UPDATE as part of an upsert.
**
** If pIdx is NULL, then the UNIQUE constraint that failed was the IPK.
** In this case parameter iCur is a cursor open on the table b-tree that
** currently points to the conflicting table row. Otherwise, if pIdx
** is not NULL, then pIdx is the constraint that failed and iCur is a
** cursor points to the conflicting row.
*/
void sqlite3UpsertDoUpdate(
  Parse *pParse,        /* The parsing and code-generating context */
  Upsert *pUpsert,      /* The ON CONFLICT clause for the upsert */
  Table *pTab,          /* The table being updated */
  Index *pIdx,          /* The UNIQUE constraint that failed */
  int iCur              /* Cursor for pIdx (or pTab if pIdx==NULL) */
){
  
// ABS Label 153
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}
Vdbe *v = pParse->pVdbe;
  
// ABS Label 154
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}
sqlite3 *db = pParse->db;
  SrcList *pSrc;            /* FROM clause for the UPDATE */
  int iDataCur;
  int i;
  
// ABS Label 155
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}
Upsert *pTop = pUpsert;

  assert( v!=0 );
  assert( pUpsert!=0 );
  iDataCur = pUpsert->iDataCur;
  pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);
  VdbeNoopComment((v, "Begin DO UPDATE of UPSERT"));
  
// ABS Label 159
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
// ABS Label 160
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
// ABS Label 161
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}

// COR Label 162
if((pIdx || iCur != iDataCur) != (pIdx && iCur != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 162);
}

// ROR Label 163
if((iCur == iDataCur) != (iCur != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}

// MCC Label 164
if(pIdx && iCur != iDataCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(pIdx && !(iCur != iDataCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
// MCC Label 166
if(!(pIdx) && iCur != iDataCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(!(pIdx) && !(iCur != iDataCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
if( pIdx && iCur!=iDataCur ){
    
// MCC Label 168
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
// MCC Label 169
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
if( HasRowid(pTab) ){
      int regRowid = sqlite3GetTempReg(pParse);
      
// ABS Label 170
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// ABS Label 171
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

// ABS Label 172
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}
sqlite3VdbeAddOp2(v, OP_IdxRowid, iCur, regRowid);
      
// ABS Label 173
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}

// ABS Label 174
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ABS Label 175
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}
sqlite3VdbeAddOp3(v, OP_SeekRowid, iDataCur, 0, regRowid);
      VdbeCoverage(v);
      
// ABS Label 176
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// ABS Label 177
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}
sqlite3ReleaseTempReg(pParse, regRowid);
    }else{
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      int nPk = pPk->nKeyCol;
      
// ABS Label 178
if(pParse->nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}

// AOR Label 179
if(pParse->nMem - 1 != pParse->nMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 179);
}
// AOR Label 180
if(pParse->nMem / 1 != pParse->nMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 180);
}
// AOR Label 181
if(pParse->nMem * 1 != pParse->nMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 181);
}
int iPk = pParse->nMem+1;
      pParse->nMem += nPk;
      i = 0;

// ABS Label 186
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
// ABS Label 187
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}

// ROR Label 188
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
// ROR Label 189
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
// ROR Label 190
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}
for(; i<nPk; i++){
        int k;
        assert( pPk->aiColumn[i]>=0 );
        k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);
        
// ABS Label 196
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}

// ABS Label 197
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}

// ABS Label 198
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}

// ABS Label 199
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}
// ABS Label 200
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}

// AOR Label 201
if(iPk - i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 201);
}
// AOR Label 202
if(iPk / i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 202);
}
// AOR Label 203
if(iPk * i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 203);
}
sqlite3VdbeAddOp3(v, OP_Column, iCur, k, iPk+i);
        VdbeComment((v, "%s.%s", pIdx->zName,
                    pTab->aCol[pPk->aiColumn[i]].zName));
      };
// ABS Label 191
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
// ABS Label 192
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}

// ROR Label 193
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
// ROR Label 194
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
// ROR Label 195
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}

      sqlite3VdbeVerifyAbortable(v, OE_Abort);
      i = sqlite3VdbeAddOp4Int(v, OP_Found, iDataCur, 0, iPk, nPk);
      VdbeCoverage(v);
      
// ABS Label 182
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CORRUPT, OE_Abort, 0, 
            "corrupt database", P4_STATIC);
      
// ABS Label 183
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
sqlite3MayAbort(pParse);
      
// ABS Label 184
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}

// ABS Label 185
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
sqlite3VdbeJumpHere(v, i);
    }
  }
  /* pUpsert does not own pTop->pUpsertSrc - the outer INSERT statement does.
  ** So we have to make a copy before passing it down into sqlite3Update() */
  pSrc = sqlite3SrcListDup(db, pTop->pUpsertSrc, 0);
  /* excluded.* columns of type REAL need to be converted to a hard real */
  i = 0;

// ABS Label 204
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}

// ROR Label 205
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
for(; i<pTab->nCol; i++){
    
// ROR Label 212
if((pTab->aCol[i].affinity != 69) != (pTab->aCol[i].affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 212);
}
if( pTab->aCol[i].affinity==SQLITE_AFF_REAL ){
      
// ABS Label 213
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}

// ABS Label 214
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}
// ABS Label 215
if(pTop->regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}

// AOR Label 216
if(pTop->regData - i != pTop->regData + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 216);
}
// AOR Label 217
if(pTop->regData / i != pTop->regData + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 217);
}
// AOR Label 218
if(pTop->regData * i != pTop->regData + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 218);
}
sqlite3VdbeAddOp1(v, OP_RealAffinity, pTop->regData+i);
    }
  };
// ABS Label 208
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 208);
}

// ROR Label 209
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
// ROR Label 211
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}

  
// ABS Label 156
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}

// ABS Label 157
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ABS Label 158
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}
sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db,pUpsert->pUpsertSet,0),
      sqlite3ExprDup(db,pUpsert->pUpsertWhere,0), OE_Abort, 0, 0, pUpsert);
  VdbeNoopComment((v, "End DO UPDATE of UPSERT"));
}

#endif /* SQLITE_OMIT_UPSERT */
