/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Utility functions used throughout sqlite.
**
** This file contains functions for allocating memory, comparing
** strings, and stuff like that.
**
*/
#include "sqliteInt.h"
#include <stdarg.h>
#ifndef SQLITE_OMIT_FLOATING_POINT
#include <math.h>
#endif

/*
** Routine needed to support the testcase() macro.
*/
#ifdef SQLITE_COVERAGE_TEST
void sqlite3Coverage(int x){
  static unsigned dummy = 0;
  dummy += (unsigned)x;
}
#endif

/*
** Calls to sqlite3FaultSim() are used to simulate a failure during testing,
** or to bypass normal error detection during testing in order to let 
** execute proceed futher downstream.
**
** In deployment, sqlite3FaultSim() *always* return SQLITE_OK (0).  The
** sqlite3FaultSim() function only returns non-zero during testing.
**
** During testing, if the test harness has set a fault-sim callback using
** a call to sqlite3_test_control(SQLITE_TESTCTRL_FAULT_INSTALL), then
** each call to sqlite3FaultSim() is relayed to that application-supplied
** callback and the integer return value form the application-supplied
** callback is returned by sqlite3FaultSim().
**
** The integer argument to sqlite3FaultSim() is a code to identify which
** sqlite3FaultSim() instance is being invoked. Each call to sqlite3FaultSim()
** should have a unique code.  To prevent legacy testing applications from
** breaking, the codes should not be changed or reused.
*/
#ifndef SQLITE_UNTESTABLE
int sqlite3FaultSim(int iTest){
  
// ABS Label 7
if(sqlite3Config.xTestCallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
int (*xCallback)(int) = sqlite3GlobalConfig.xTestCallback;
  return xCallback ? xCallback(iTest) : SQLITE_OK;
}
#endif

#ifndef SQLITE_OMIT_FLOATING_POINT
/*
** Return true if the floating point value is Not a Number (NaN).
*/
int sqlite3IsNaN(double x){
  u64 y;
  memcpy(&y,&x,sizeof(y));
  
// MCC Label 8
if(( ((y) & (((u64)2047) << 52)) == (((u64)2047) << 52) && ((y) & ((((u64)1) << 52) - 1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 8);
}
// MCC Label 9
if(( ((y) & (((u64)2047) << 52)) == (((u64)2047) << 52) && !(((y) & ((((u64)1) << 52) - 1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 9);
}
// MCC Label 10
if(( !(((y) & (((u64)2047) << 52)) == (((u64)2047) << 52)) && ((y) & ((((u64)1) << 52) - 1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 10);
}
// MCC Label 11
if(( !(((y) & (((u64)2047) << 52)) == (((u64)2047) << 52)) && !(((y) & ((((u64)1) << 52) - 1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 11);
}
return IsNaN(y);
}
#endif /* SQLITE_OMIT_FLOATING_POINT */

/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
**
** The value returned will never be negative.  Nor will it ever be greater
** than the actual length of the string.  For very long strings (greater
** than 1GiB) the value returned might be less than the true string length.
*/
int sqlite3Strlen30(const char *z){
  
// ABS Label 12
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ROR Label 13
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
if( z==0 ) { return 0;
}
  
// AOR Label 14
if(1073741823 | (int)strlen(z) != 1073741823 & (int)strlen(z))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 14);
}
// AOR Label 15
if(1073741823 ^ (int)strlen(z) != 1073741823 & (int)strlen(z))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 15);
}
return 0x3fffffff & (int)strlen(z);
}

/*
** Return the declared type of a column.  Or return zDflt if the column 
** has no declared type.
**
** The column type is an extra string stored after the zero-terminator on
** the column name if and only if the COLFLAG_HASTYPE flag is set.
*/
char *sqlite3ColumnType(Column *pCol, char *zDflt){
  
// ROR Label 16
if(((pCol->colFlags & 4) != 0) != ((pCol->colFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
if( (pCol->colFlags & COLFLAG_HASTYPE)==0 ) { 
// ABS Label 17
if(zDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
return zDflt;
}
  
// ABS Label 18
if(pCol->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
return pCol->zName + strlen(pCol->zName) + 1;
}

/*
** Helper function for sqlite3Error() - called rarely.  Broken out into
** a separate routine to avoid unnecessary register saves on entry to
** sqlite3Error().
*/
static SQLITE_NOINLINE void  sqlite3ErrorFinish(sqlite3 *db, int err_code){
  
// ABS Label 21
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
if( db->pErr ) { 
// ABS Label 22
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
sqlite3ValueSetNull(db->pErr);
}
  
// ABS Label 19
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}

// ABS Label 20
if(err_code < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
sqlite3SystemError(db, err_code);
}

/*
** Set the current error code to err_code and clear any prior error message.
** Also set iSysErrno (by calling sqlite3System) if the err_code indicates
** that would be appropriate.
*/
void sqlite3Error(sqlite3 *db, int err_code){
  assert( db!=0 );
  db->errCode = err_code;
  
// ABS Label 23
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
// ABS Label 24
if(err_code < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// COR Label 25
if((err_code && db->pErr) != (err_code || db->pErr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 25);
}

// MCC Label 26
if(err_code && db->pErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}
// MCC Label 27
if(err_code && !(db->pErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 27);
}
// MCC Label 28
if(!(err_code) && db->pErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
// MCC Label 29
if(!(err_code) && !(db->pErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 29);
}
if( err_code || db->pErr ) { 
// ABS Label 30
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// ABS Label 31
if(err_code < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
sqlite3ErrorFinish(db, err_code);
}
}

/*
** The equivalent of sqlite3Error(db, SQLITE_OK).  Clear the error state
** and error message.
*/
void sqlite3ErrorClear(sqlite3 *db){
  assert( db!=0 );
  db->errCode = SQLITE_OK;
  
// ABS Label 32
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
if( db->pErr ) { 
// ABS Label 33
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3ValueSetNull(db->pErr);
}
}

/*
** Load the sqlite3.iSysErrno field if that is an appropriate thing
** to do based on the SQLite error code in rc.
*/
void sqlite3SystemError(sqlite3 *db, int rc){
  
// ABS Label 34
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ROR Label 35
if((rc != (10 | (12 << 8))) != (rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
if( rc==SQLITE_IOERR_NOMEM ) { return;
}
  rc &= 0xff;
  
// ABS Label 36
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// COR Label 37
if((rc == 14 && rc == 10) != (rc == 14 || rc == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 37);
}

// ROR Label 38
if((rc != 14) != (rc == 14))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((rc != 10) != (rc == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}

// MCC Label 40
if(rc == 14 && rc == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(rc == 14 && !(rc == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(!(rc == 14) && rc == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
// MCC Label 43
if(!(rc == 14) && !(rc == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 43);
}
if( rc==SQLITE_CANTOPEN || rc==SQLITE_IOERR ){
    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);
  }
}

/*
** Set the most recent error code and error string for the sqlite
** handle "db". The error code is set to "err_code".
**
** If it is not NULL, string zFormat specifies the format of the
** error string in the style of the printf functions: The following
** format characters are allowed:
**
**      %s      Insert a string
**      %z      A string that should be freed after use
**      %d      Insert an integer
**      %T      Insert a token
**      %S      Insert the first element of a SrcList
**
** zFormat and any string tokens that follow it are assumed to be
** encoded in UTF-8.
**
** To clear the most recent error for sqlite handle "db", sqlite3Error
** should be called with err_code set to SQLITE_OK and zFormat set
** to NULL.
*/
void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){
  assert( db!=0 );
  db->errCode = err_code;
  
// ABS Label 44
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// ABS Label 45
if(err_code < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
sqlite3SystemError(db, err_code);
  
// ABS Label 46
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}

// ROR Label 47
if((zFormat != 0) != (zFormat == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
if( zFormat==0 ){
    
// ABS Label 48
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// ABS Label 49
if(err_code < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
sqlite3Error(db, err_code);
  }else { if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){
    char *z;
    va_list ap;
    va_start(ap, zFormat);
    z = sqlite3VMPrintf(db, zFormat, ap);
    va_end(ap);
    
// ABS Label 50
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC);
  };}

}

/*
** Add an error message to pParse->zErrMsg and increment pParse->nErr.
** The following formatting characters are allowed:
**
**      %s      Insert a string
**      %z      A string that should be freed after use
**      %d      Insert an integer
**      %T      Insert a token
**      %S      Insert the first element of a SrcList
**
** This function should be used to report any error that occurs while
** compiling an SQL statement (i.e. within sqlite3_prepare()). The
** last thing the sqlite3_prepare() function does is copy the error
** stored by this function into the database handle using sqlite3Error().
** Functions sqlite3Error() or sqlite3ErrorWithMsg() should be used
** during statement execution (sqlite3_step() etc.).
*/
void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){
  char *zMsg;
  va_list ap;
  
// ABS Label 51
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
sqlite3 *db = pParse->db;
  va_start(ap, zFormat);
  zMsg = sqlite3VMPrintf(db, zFormat, ap);
  va_end(ap);
  
// ABS Label 52
if(db->suppressErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
if( db->suppressErr ){
    
// ABS Label 53
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
sqlite3DbFree(db, zMsg);
  }else{
    pParse->nErr++;
    
// ABS Label 54
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}
sqlite3DbFree(db, pParse->zErrMsg);
    pParse->zErrMsg = zMsg;
    pParse->rc = SQLITE_ERROR;
    pParse->pWith = 0;
  }
}

/*
** If database connection db is currently parsing SQL, then transfer
** error code errCode to that parser if the parser has not already
** encountered some other kind of error.
*/
int sqlite3ErrorToParser(sqlite3 *db, int errCode){
  Parse *pParse;
  if( db==0 || (pParse = db->pParse)==0 ) { 
// ABS Label 55
if(errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}
return errCode;
}
  pParse->rc = errCode;
  pParse->nErr++;
  
// ABS Label 56
if(errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}
return errCode;
}

/*
** Convert an SQL-style quoted string into a normal string by removing
** the quote characters.  The conversion is done in-place.  If the
** input does not begin with a quote character, then this routine
** is a no-op.
**
** The input string must be zero-terminated.  A new zero-terminator
** is added to the dequoted string.
**
** The return value is -1 if no dequoting occurs or the length of the
** dequoted string, exclusive of the zero terminator, if dequoting does
** occur.
**
** 2002-02-14: This routine is extended to remove MS-Access style
** brackets from around identifiers.  For example:  "[a-b-c]" becomes
** "a-b-c".
*/
void sqlite3Dequote(char *z){
  char quote;
  int i, j;
  
// ABS Label 57
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}

// ROR Label 58
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
if( z==0 ) { return;
}
  quote = z[0];
  if( !sqlite3Isquote(quote) ) { return;
}
  
// ROR Label 59
if((quote != '[') != (quote == '['))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
if( quote=='[' ) { quote = ']';
}
  i = 1 , j = 0;
for(;; i++){
    assert( z[i] );
    
// ROR Label 60
if((z[i] != quote) != (z[i] == quote))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
if( z[i]==quote ){
      
// ROR Label 61
if((z[i + 1] != quote) != (z[i + 1] == quote))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
if( z[i+1]==quote ){
        z[j++] = quote;
        i++;
      }else{
        break;
      }
    }else{
      z[j++] = z[i];
    }
  };
  z[j] = 0;
}
void sqlite3DequoteExpr(Expr *p){
  assert( sqlite3Isquote(p->u.zToken[0]) );
  p->flags |= p->u.zToken[0]=='"' ? EP_Quoted|EP_DblQuoted : EP_Quoted;
  
// ABS Label 62
if(p->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}
sqlite3Dequote(p->u.zToken);
}

/*
** Generate a Token object from a string
*/
void sqlite3TokenInit(Token *p, char *z){
  p->z = z;
  p->n = sqlite3Strlen30(z);
}

/* Convenient short-hand */
#define UpperToLower sqlite3UpperToLower

/*
** Some systems have stricmp().  Others have strcasecmp().  Because
** there is no consistency, we will define our own.
**
** IMPLEMENTATION-OF: R-30243-02494 The sqlite3_stricmp() and
** sqlite3_strnicmp() APIs allow applications and extensions to compare
** the contents of two buffers containing UTF-8 strings in a
** case-independent fashion, using the same definition of "case
** independence" that SQLite uses internally when comparing identifiers.
*/
int sqlite3_stricmp(const char *zLeft, const char *zRight){
  
// ABS Label 63
if(zLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}

// ROR Label 64
if((zLeft != 0) != (zLeft == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else { 
// ABS Label 65
if(zRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}

// ROR Label 66
if((zRight != 0) != (zRight == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
if( zRight==0 ){
    return 1;
  };}

  return sqlite3StrICmp(zLeft, zRight);
}
int sqlite3StrICmp(const char *zLeft, const char *zRight){
  unsigned char *a, *b;
  int c, x;
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  for(;;){
    c = *a;
    x = *b;
    
// ABS Label 67
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
// ABS Label 68
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}

// ROR Label 69
if((c != x) != (c == x))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
if( c==x ){
      
// ABS Label 70
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
if( c==0 ) { break;
}
    }else{
      c = (int)UpperToLower[c] - (int)UpperToLower[x];
      
// ABS Label 72
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
if( c ) { break;
}
    }
    a++;
    b++;
  };
  
// ABS Label 73
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
return c;
}
int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
  register unsigned char *a, *b;
  
// ABS Label 74
if(zLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}

// ROR Label 75
if((zLeft != 0) != (zLeft == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else { 
// ABS Label 76
if(zRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// ROR Label 77
if((zRight != 0) != (zRight == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
if( zRight==0 ){
    return 1;
  };}

  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; };
  return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];
}

/*
** Compute an 8-bit hash on a string that is insensitive to case differences
*/
u8 sqlite3StrIHash(const char *z){
  u8 h = 0;
  
// ABS Label 78
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}

// ROR Label 79
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
if( z==0 ) { return 0;
}
  
// ABS Label 80
if(z[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}
while( z[0] ){
    h += UpperToLower[(unsigned char)z[0]];
    z++;
  };
// ABS Label 81
if(z[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

  
// ABS Label 82
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
return h;
}

/*
** Compute 10 to the E-th power.  Examples:  E==1 results in 10.
** E==2 results in 100.  E==50 results in 1.0e50.
**
** This routine only works for values of E between 1 and 341.
*/
static LONGDOUBLE_TYPE sqlite3Pow10(int E){
#if defined(_MSC_VER)
  static const LONGDOUBLE_TYPE x[] = {
    1.0e+001L,
    1.0e+002L,
    1.0e+004L,
    1.0e+008L,
    1.0e+016L,
    1.0e+032L,
    1.0e+064L,
    1.0e+128L,
    1.0e+256L
  };
  LONGDOUBLE_TYPE r = 1.0;
  int i;
  assert( E>=0 && E<=307 );
  for(i=0; E!=0; i++, E >>=1){
    if( E & 1 ) r *= x[i];
  }
  return r;
#else
  LONGDOUBLE_TYPE x = 10.0;
  LONGDOUBLE_TYPE r = 1.0;
  while(1){
    
// ABS Label 83
if(E < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}

// AOR Label 84
if(E | 1 != E & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 84);
}
// AOR Label 85
if(E ^ 1 != E & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 85);
}
if( E & 1 ) { r *= x;
}
    E >>= 1;
    
// ABS Label 86
if(E < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// ROR Label 87
if((E != 0) != (E == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}
if( E==0 ) { break;
}
    x *= x;
  };
  
// ABS Label 88
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
return r; 
#endif
}

/*
** The string z[] is an text representation of a real number.
** Convert this string to a double and write it into *pResult.
**
** The string z[] is length bytes in length (bytes, not characters) and
** uses the encoding enc.  The string is not necessarily zero-terminated.
**
** Return TRUE if the result is a valid real number (or integer) and FALSE
** if the string is empty or contains extraneous text.  More specifically
** return
**      1          =>  The input string is a pure integer
**      2 or more  =>  The input has a decimal point or eNNN clause
**      0 or less  =>  The input string is not a valid number
**     -1          =>  Not a valid number, but has a valid prefix which 
**                     includes a decimal point and/or an eNNN clause
**
** Valid numbers are in one of these formats:
**
**    [+-]digits[E[+-]digits]
**    [+-]digits.[digits][E[+-]digits]
**    [+-].digits[E[+-]digits]
**
** Leading and trailing whitespace is ignored for the purpose of determining
** validity.
**
** If some prefix of the input string is a valid number, this routine
** returns FALSE but it still converts the prefix and writes the result
** into *pResult.
*/
#if defined(_MSC_VER)
#pragma warning(disable : 4756)
#endif
int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){
#ifndef SQLITE_OMIT_FLOATING_POINT
  int incr;
  const char *zEnd;
  /* sign * significand * (10 ^ (esign * exponent)) */
  int sign = 1;    /* sign of significand */
  i64 s = 0;       /* significand */
  int d = 0;       /* adjust exponent for shifting decimal point */
  int esign = 1;   /* sign of exponent */
  int e = 0;       /* exponent */
  int eValid = 1;  /* True exponent is either not used or is well-formed */
  double result;
  int nDigit = 0;  /* Number of digits processed */
  int eType = 1;   /* 1: pure integer,  2+: fractional  -1 or less: bad UTF16 */

  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );
  *pResult = 0.0;   /* Default return value, in case of an error */
  
// ABS Label 89
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}

// ROR Label 90
if((length != 0) != (length == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( length==0 ) { return 0;
}

  
// ROR Label 91
if((enc != 1) != (enc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
if( enc==SQLITE_UTF8 ){
    incr = 1;
    zEnd = z + length;
  }else{
    int i;
    incr = 2;
    length &= ~1;
    assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );
    testcase( enc==SQLITE_UTF16LE );
    testcase( enc==SQLITE_UTF16BE );
    i = 3 - enc;

// ABS Label 92
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}
// ABS Label 93
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}

// COR Label 94
if((i < length || z[i] == 0) != (i < length && z[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 94);
}

// ROR Label 95
if((i <= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
// ROR Label 96
if((i > length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
// ROR Label 97
if((i >= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
// ROR Label 98
if((z[i] != 0) != (z[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}

// MCC Label 99
if(i < length && z[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 99);
}
// MCC Label 100
if(i < length && !(z[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 100);
}
// MCC Label 101
if(!(i < length) && z[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(!(i < length) && !(z[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
for(; i<length && z[i]==0; i+=2){};
// ABS Label 103
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
// ABS Label 104
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}

// COR Label 105
if((i < length || z[i] == 0) != (i < length && z[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 105);
}

// ROR Label 106
if((i <= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
// ROR Label 107
if((i > length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
// ROR Label 108
if((i >= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 108);
}
// ROR Label 109
if((z[i] != 0) != (z[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}

// MCC Label 110
if(i < length && z[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(i < length && !(z[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
// MCC Label 112
if(!(i < length) && z[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(!(i < length) && !(z[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}

    
// ABS Label 114
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
// ABS Label 115
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// ROR Label 116
if((i <= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
// ROR Label 117
if((i > length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
// ROR Label 118
if((i >= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
if( i<length ) { eType = -100;
}
    zEnd = &z[i^1];
    z += (enc&1);
  }

  /* skip leading spaces */
  
// ABS Label 119
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}
// ABS Label 120
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// COR Label 121
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 1)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 121);
}

// ROR Label 122
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
// ROR Label 123
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
// ROR Label 124
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}

// MCC Label 125
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 125);
}
// MCC Label 126
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 126);
}
// MCC Label 127
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 127);
}
// MCC Label 128
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 128);
}
while( z<zEnd && sqlite3Isspace(*z) ) { z+=incr;
};
// ABS Label 129
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}
// ABS Label 130
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}

// COR Label 131
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 1)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 131);
}

// ROR Label 132
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
// ROR Label 133
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
// ROR Label 134
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}

// MCC Label 135
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
// MCC Label 136
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 136);
}
// MCC Label 137
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
// MCC Label 138
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}

  
// ABS Label 139
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
// ABS Label 140
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ROR Label 141
if((z < zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 141);
}
// ROR Label 142
if((z > zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((z <= zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}
if( z>=zEnd ) { return 0;
}

  /* get sign of significand */
  
// ROR Label 144
if((*z != '-') != (*z == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( *z=='-' ){
    sign = -1;
    z+=incr;
  }else { 
// ROR Label 145
if((*z != '+') != (*z == '+'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
if( *z=='+' ){
    z+=incr;
  };}


  /* copy max significant digits to significand */
  
// ABS Label 146
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
// ABS Label 147
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}

// COR Label 148
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 148);
}

// ROR Label 149
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
// ROR Label 150
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}

// MCC Label 152
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 152);
}
// MCC Label 153
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 153);
}
// MCC Label 154
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 154);
}
// MCC Label 155
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 155);
}
while( z<zEnd && sqlite3Isdigit(*z) ){
    s = s*10 + (*z - '0');
    z+=incr; nDigit++;
    
// ABS Label 166
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}

// ROR Label 167
if((s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) != (s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((s > (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) != (s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
// ROR Label 169
if((s <= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) != (s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}
if( s>=((LARGEST_INT64-9)/10) ){
      /* skip non-significant significand digits
      ** (increase exponent by d to shift decimal left) */
      
// ABS Label 170
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}
// ABS Label 171
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

// COR Label 172
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 172);
}

// ROR Label 173
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
// ROR Label 174
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}

// MCC Label 176
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
while( z<zEnd && sqlite3Isdigit(*z) ){ z+=incr; d++; };
// ABS Label 180
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
// ABS Label 181
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}

// COR Label 182
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 182);
}

// ROR Label 183
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
// ROR Label 185
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}

// MCC Label 186
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 186);
}
// MCC Label 187
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}
// MCC Label 188
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 188);
}
// MCC Label 189
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 189);
}

    }
  };
// ABS Label 156
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
// ABS Label 157
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// COR Label 158
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 158);
}

// ROR Label 159
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 159);
}
// ROR Label 160
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}

// MCC Label 162
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 162);
}
// MCC Label 163
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 163);
}
// MCC Label 164
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}

  
// ABS Label 190
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
// ABS Label 191
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// ROR Label 192
if((z < zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((z > zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
// ROR Label 194
if((z <= zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
if( z>=zEnd ) { goto do_atof_calc;
}

  /* if decimal point is present */
  
// ROR Label 195
if((*z != '.') != (*z == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}
if( *z=='.' ){
    z+=incr;
    eType++;
    /* copy digits from after decimal to significand
    ** (decrease exponent by d to shift decimal right) */
    
// ABS Label 196
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}
// ABS Label 197
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}

// COR Label 198
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 198);
}

// ROR Label 199
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
// ROR Label 200
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
// ROR Label 201
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}

// MCC Label 202
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}
// MCC Label 203
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 203);
}
// MCC Label 204
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 204);
}
// MCC Label 205
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 205);
}
while( z<zEnd && sqlite3Isdigit(*z) ){
      
// ABS Label 216
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// ROR Label 217
if((s <= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) != (s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
// ROR Label 218
if((s > (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) != (s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
// ROR Label 219
if((s >= (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)) != (s < (((4294967295U | (((i64)2147483647) << 32)) - 9) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
if( s<((LARGEST_INT64-9)/10) ){
        s = s*10 + (*z - '0');
        d--;
        nDigit++;
      }
      z+=incr;
    };
// ABS Label 206
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
// ABS Label 207
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// COR Label 208
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 208);
}

// ROR Label 209
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
// ROR Label 211
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}

// MCC Label 212
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}

  }
  
// ABS Label 220
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
// ABS Label 221
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}

// ROR Label 222
if((z < zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
// ROR Label 223
if((z > zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
// ROR Label 224
if((z <= zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 224);
}
if( z>=zEnd ) { goto do_atof_calc;
}

  /* if exponent is present */
  
// COR Label 225
if((*z == 'e' && *z == 'E') != (*z == 'e' || *z == 'E'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 225);
}

// ROR Label 226
if((*z != 'e') != (*z == 'e'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 226);
}
// ROR Label 227
if((*z != 'E') != (*z == 'E'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 227);
}

// MCC Label 228
if(*z == 'e' && *z == 'E' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(*z == 'e' && !(*z == 'E') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(!(*z == 'e') && *z == 'E' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(!(*z == 'e') && !(*z == 'E') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
if( *z=='e' || *z=='E' ){
    z+=incr;
    eValid = 0;
    eType++;

    /* This branch is needed to avoid a (harmless) buffer overread.  The 
    ** special comment alerts the mutation tester that the correct answer
    ** is obtained even if the branch is omitted */
    
// ABS Label 232
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}
// ABS Label 233
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}

// ROR Label 234
if((z < zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}
// ROR Label 235
if((z > zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
// ROR Label 236
if((z <= zEnd) != (z >= zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
if( z>=zEnd ) { goto do_atof_calc;              /*PREVENTS-HARMLESS-OVERREAD*/
}

    /* get sign of exponent */
    
// ROR Label 237
if((*z != '-') != (*z == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
if( *z=='-' ){
      esign = -1;
      z+=incr;
    }else { 
// ROR Label 238
if((*z != '+') != (*z == '+'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
if( *z=='+' ){
      z+=incr;
    };}

    /* copy digits to exponent */
    
// ABS Label 239
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}
// ABS Label 240
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// COR Label 241
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 241);
}

// ROR Label 242
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
// ROR Label 243
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
// ROR Label 244
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}

// MCC Label 245
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
// MCC Label 247
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
while( z<zEnd && sqlite3Isdigit(*z) ){
      e = e<10000 ? (e*10 + (*z - '0')) : 10000;
      z+=incr;
      eValid = 1;
    };
// ABS Label 249
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
// ABS Label 250
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

// COR Label 251
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 4)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 251);
}

// ROR Label 252
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
// ROR Label 254
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}

// MCC Label 255
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
// MCC Label 256
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 256);
}
// MCC Label 257
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 257);
}
// MCC Label 258
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 258);
}

  }

  /* skip trailing spaces */
  
// ABS Label 259
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}
// ABS Label 260
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}

// COR Label 261
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 1)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 261);
}

// ROR Label 262
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}
// ROR Label 264
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}

// MCC Label 265
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
while( z<zEnd && sqlite3Isspace(*z) ) { z+=incr;
};
// ABS Label 269
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
// ABS Label 270
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}

// COR Label 271
if((z < zEnd || (sqlite3CtypeMap[(unsigned char)(*z)] & 1)) != (z < zEnd && (sqlite3CtypeMap[(unsigned char)(*z)] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 271);
}

// ROR Label 272
if((z <= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 272);
}
// ROR Label 273
if((z > zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
// ROR Label 274
if((z >= zEnd) != (z < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 274);
}

// MCC Label 275
if(z < zEnd && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
// MCC Label 276
if(z < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 276);
}
// MCC Label 277
if(!(z < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*z)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 277);
}
// MCC Label 278
if(!(z < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*z)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}


do_atof_calc:
  /* adjust exponent by d, and update sign */
  e = (e*esign) + d;
  
// ABS Label 279
if(e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}

// ROR Label 280
if((e <= 0) != (e < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((e > 0) != (e < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}
// ROR Label 282
if((e >= 0) != (e < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
if( e<0 ) {
    esign = -1;
    e *= -1;
  } else {
    esign = 1;
  }

  
// ABS Label 283
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((s != 0) != (s == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
if( s==0 ) {
    /* In the IEEE 754 standard, zero is signed. */
    result = sign<0 ? -(double)0 : (double)0;
  } else {
    /* Attempt to reduce exponent.
    **
    ** Branches that are not required for the correct answer but which only
    ** help to obtain the correct answer faster are marked with special
    ** comments, as a hint to the mutation tester.
    */
    
// ABS Label 285
if(e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}

// ROR Label 286
if((e <= 0) != (e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
// ROR Label 287
if((e < 0) != (e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
// ROR Label 288
if((e >= 0) != (e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
while( e>0 ){                                       /*OPTIMIZATION-IF-TRUE*/
      
// ABS Label 293
if(esign < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ROR Label 294
if((esign <= 0) != (esign > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}
// ROR Label 295
if((esign < 0) != (esign > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}
// ROR Label 296
if((esign >= 0) != (esign > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
if( esign>0 ){
        
// ABS Label 297
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ROR Label 298
if((s < ((4294967295U | (((i64)2147483647) << 32)) / 10)) != (s >= ((4294967295U | (((i64)2147483647) << 32)) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
// ROR Label 299
if((s > ((4294967295U | (((i64)2147483647) << 32)) / 10)) != (s >= ((4294967295U | (((i64)2147483647) << 32)) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 299);
}
// ROR Label 300
if((s <= ((4294967295U | (((i64)2147483647) << 32)) / 10)) != (s >= ((4294967295U | (((i64)2147483647) << 32)) / 10)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
if( s>=(LARGEST_INT64/10) ) { break;             /*OPTIMIZATION-IF-FALSE*/
}
        s *= 10;
      }else{
        
// ABS Label 301
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// AOR Label 302
if(s - 10 != s % 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 302);
}
// AOR Label 303
if(s + 10 != s % 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 303);
}
// AOR Label 304
if(s * 10 != s % 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 304);
}

// ROR Label 305
if((s % 10 == 0) != (s % 10 != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}
if( s%10!=0 ) { break;                           /*OPTIMIZATION-IF-FALSE*/
}
        s /= 10;
      }
      e--;
    };
// ABS Label 289
if(e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// ROR Label 290
if((e <= 0) != (e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 290);
}
// ROR Label 291
if((e < 0) != (e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 291);
}
// ROR Label 292
if((e >= 0) != (e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}


    /* adjust the sign of significand */
    s = sign<0 ? -s : s;

    
// ABS Label 306
if(e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}

// ROR Label 307
if((e != 0) != (e == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 307);
}
if( e==0 ){                                         /*OPTIMIZATION-IF-TRUE*/
      result = (double)s;
    }else{
      /* attempt to handle extremely small/large numbers better */
      
// ABS Label 308
if(e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// ROR Label 309
if((e <= 307) != (e > 307))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
// ROR Label 310
if((e < 307) != (e > 307))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((e >= 307) != (e > 307))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
if( e>307 ){                                      /*OPTIMIZATION-IF-TRUE*/
        
// ABS Label 312
if(e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}

// ROR Label 313
if((e <= 342) != (e < 342))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 313);
}
// ROR Label 314
if((e > 342) != (e < 342))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
// ROR Label 315
if((e >= 342) != (e < 342))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}
if( e<342 ){                                    /*OPTIMIZATION-IF-TRUE*/
          LONGDOUBLE_TYPE scale = sqlite3Pow10(e-308);
          
// ABS Label 316
if(esign < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}

// ROR Label 317
if((esign <= 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}
// ROR Label 318
if((esign > 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
// ROR Label 319
if((esign >= 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 319);
}
if( esign<0 ){
            result = s / scale;
            result /= 1.0e+308;
          }else{
            result = s * scale;
            result *= 1.0e+308;
          }
        }else{ assert( e>=342 );
          
// ABS Label 320
if(esign < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}

// ROR Label 321
if((esign <= 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 321);
}
// ROR Label 322
if((esign > 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}
// ROR Label 323
if((esign >= 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 323);
}
if( esign<0 ){
            result = 0.0*s;
          }else{
#ifdef INFINITY
            result = INFINITY*s;
#else
            result = 1e308*1e308*s;  /* Infinity */
#endif
          }
        }
      }else{
        LONGDOUBLE_TYPE scale = sqlite3Pow10(e);
        
// ABS Label 324
if(esign < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ROR Label 325
if((esign <= 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}
// ROR Label 326
if((esign > 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 326);
}
// ROR Label 327
if((esign >= 0) != (esign < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
if( esign<0 ){
          result = s / scale;
        }else{
          result = s * scale;
        }
      }
    }
  }

  /* store the result */
  *pResult = result;

  /* return true if number and no extra non-whitespace chracters after */
  
// ABS Label 328
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
// ABS Label 329
if(eValid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
// ABS Label 330
if(nDigit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
// ABS Label 331
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
// ABS Label 332
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// COR Label 333
if((z == zEnd && nDigit > 0 && eValid || eType > 0) != (z == zEnd && nDigit > 0 && eValid && eType > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 333);
}
// COR Label 334
if((z == zEnd && nDigit > 0 || eValid) != (z == zEnd && nDigit > 0 && eValid))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 334);
}
// COR Label 335
if((z == zEnd || nDigit > 0) != (z == zEnd && nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 335);
}

// ROR Label 336
if((z != zEnd) != (z == zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}
// ROR Label 337
if((nDigit <= 0) != (nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
// ROR Label 338
if((nDigit < 0) != (nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}
// ROR Label 339
if((nDigit >= 0) != (nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
// ROR Label 340
if((eType <= 0) != (eType > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 340);
}
// ROR Label 341
if((eType < 0) != (eType > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 341);
}
// ROR Label 342
if((eType >= 0) != (eType > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}

// MCC Label 343
if(z == zEnd && nDigit > 0 && eValid && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 343);
}
// MCC Label 344
if(z == zEnd && nDigit > 0 && eValid && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 344);
}
// MCC Label 345
if(z == zEnd && nDigit > 0 && !(eValid) && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 345);
}
// MCC Label 346
if(z == zEnd && nDigit > 0 && !(eValid) && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 346);
}
// MCC Label 347
if(z == zEnd && !(nDigit > 0) && eValid && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 347);
}
// MCC Label 348
if(z == zEnd && !(nDigit > 0) && eValid && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 348);
}
// MCC Label 349
if(z == zEnd && !(nDigit > 0) && !(eValid) && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
// MCC Label 350
if(z == zEnd && !(nDigit > 0) && !(eValid) && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
// MCC Label 351
if(!(z == zEnd) && nDigit > 0 && eValid && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
// MCC Label 352
if(!(z == zEnd) && nDigit > 0 && eValid && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 352);
}
// MCC Label 353
if(!(z == zEnd) && nDigit > 0 && !(eValid) && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 353);
}
// MCC Label 354
if(!(z == zEnd) && nDigit > 0 && !(eValid) && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 354);
}
// MCC Label 355
if(!(z == zEnd) && !(nDigit > 0) && eValid && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 355);
}
// MCC Label 356
if(!(z == zEnd) && !(nDigit > 0) && eValid && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 356);
}
// MCC Label 357
if(!(z == zEnd) && !(nDigit > 0) && !(eValid) && eType > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 357);
}
// MCC Label 358
if(!(z == zEnd) && !(nDigit > 0) && !(eValid) && !(eType > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 358);
}
if( z==zEnd && nDigit>0 && eValid && eType>0 ){
    
// ABS Label 359
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}
return eType;
  }else { 
// ABS Label 360
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}
// ABS Label 361
if(nDigit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}

// COR Label 362
if((eType >= 2 && (eType == 3 || eValid) || nDigit > 0) != (eType >= 2 && (eType == 3 || eValid) && nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 362);
}
// COR Label 363
if((eType >= 2 || (eType == 3 || eValid)) != (eType >= 2 && (eType == 3 || eValid)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 363);
}

// ROR Label 364
if((eType < 2) != (eType >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}
// ROR Label 365
if((eType > 2) != (eType >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 365);
}
// ROR Label 366
if((eType <= 2) != (eType >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 366);
}
// ROR Label 367
if((nDigit <= 0) != (nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}
// ROR Label 368
if((nDigit < 0) != (nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}
// ROR Label 369
if((nDigit >= 0) != (nDigit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}

// MCC Label 370
if(eType >= 2 && ( eType == 3 && eValid ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(eType >= 2 && ( eType == 3 && eValid ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}
// MCC Label 372
if(eType >= 2 && ( eType == 3 && !(eValid) ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 372);
}
// MCC Label 373
if(eType >= 2 && ( eType == 3 && !(eValid) ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 373);
}
// MCC Label 374
if(eType >= 2 && ( !(eType == 3) && eValid ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 374);
}
// MCC Label 375
if(eType >= 2 && ( !(eType == 3) && eValid ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 375);
}
// MCC Label 376
if(eType >= 2 && ( !(eType == 3) && !(eValid) ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 376);
}
// MCC Label 377
if(eType >= 2 && ( !(eType == 3) && !(eValid) ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 377);
}
// MCC Label 378
if(!(eType >= 2) && ( eType == 3 && eValid ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 378);
}
// MCC Label 379
if(!(eType >= 2) && ( eType == 3 && eValid ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(!(eType >= 2) && ( eType == 3 && !(eValid) ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(!(eType >= 2) && ( eType == 3 && !(eValid) ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(!(eType >= 2) && ( !(eType == 3) && eValid ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}
// MCC Label 383
if(!(eType >= 2) && ( !(eType == 3) && eValid ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(!(eType >= 2) && ( !(eType == 3) && !(eValid) ) && nDigit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
// MCC Label 385
if(!(eType >= 2) && ( !(eType == 3) && !(eValid) ) && !(nDigit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
if( eType>=2 && (eType==3 || eValid) && nDigit>0 ){
    return -1;
  }else{
    return 0;
  };}

#else
  return !sqlite3Atoi64(z, pResult, length, enc);
#endif /* SQLITE_OMIT_FLOATING_POINT */
}
#if defined(_MSC_VER)
#pragma warning(default : 4756)
#endif

/*
** Render an signed 64-bit integer as text.  Store the result in zOut[].
**
** The caller must ensure that zOut[] is at least 21 bytes in size.
*/
void sqlite3Int64ToText(i64 v, char *zOut){
  int i;
  u64 x;
  char zTemp[22];
  
// ABS Label 392
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

// ROR Label 393
if((v <= 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 393);
}
// ROR Label 394
if((v > 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 394);
}
// ROR Label 395
if((v >= 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 395);
}
if( v<0 ){
    x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : (u64)-v;
  }else{
    x = v;
  }
  i = sizeof(zTemp)-2;
  zTemp[sizeof(zTemp)-1] = 0;
  
// ABS Label 396
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}
do{
    zTemp[i--] = (x%10) + '0';
    x = x/10;
  }while( x );
// ABS Label 397
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
;
  
// ABS Label 398
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}

// ROR Label 399
if((v <= 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 399);
}
// ROR Label 400
if((v > 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 400);
}
// ROR Label 401
if((v >= 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 401);
}
if( v<0 ) { zTemp[i--] = '-';
}
  
// AOR Label 386
if(sizeof (zTemp) - 1 / i != sizeof (zTemp) - 1 - i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 386);
}
// AOR Label 387
if(sizeof (zTemp) - 1 + i != sizeof (zTemp) - 1 - i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 387);
}
// AOR Label 388
if(sizeof (zTemp) - 1 * i != sizeof (zTemp) - 1 - i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 388);
}
// AOR Label 389
if(sizeof (zTemp) / 1 != sizeof (zTemp) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 389);
}
// AOR Label 390
if(sizeof (zTemp) + 1 != sizeof (zTemp) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 390);
}
// AOR Label 391
if(sizeof (zTemp) * 1 != sizeof (zTemp) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 391);
}
memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i);
}

/*
** Compare the 19-character string zNum against the text representation
** value 2^63:  9223372036854775808.  Return negative, zero, or positive
** if zNum is less than, equal to, or greater than the string.
** Note that zNum must contain exactly 19 characters.
**
** Unlike memcmp() this routine is guaranteed to return the difference
** in the values of the last digit if the only difference is in the
** last digit.  So, for example,
**
**      compare2pow63("9223372036854775800", 1)
**
** will return -8.
*/
static int compare2pow63(const char *zNum, int incr){
  int c = 0;
  int i;
                    /* 012345678901234567 */
  const char *pow63 = "922337203685477580";
  i = 0;

// ABS Label 402
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}
// ABS Label 403
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}

// COR Label 404
if((c == 0 || i < 18) != (c == 0 && i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 404);
}

// ROR Label 405
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 405);
}
// ROR Label 406
if((i <= 18) != (i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 406);
}
// ROR Label 407
if((i > 18) != (i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 407);
}
// ROR Label 408
if((i >= 18) != (i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}

// MCC Label 409
if(c == 0 && i < 18 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 409);
}
// MCC Label 410
if(c == 0 && !(i < 18) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 410);
}
// MCC Label 411
if(!(c == 0) && i < 18 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
// MCC Label 412
if(!(c == 0) && !(i < 18) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
for(; c==0 && i<18; i++){
    c = (zNum[i*incr]-pow63[i])*10;
  };
// ABS Label 413
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
// ABS Label 414
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// COR Label 415
if((c == 0 || i < 18) != (c == 0 && i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 415);
}

// ROR Label 416
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 416);
}
// ROR Label 417
if((i <= 18) != (i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 417);
}
// ROR Label 418
if((i > 18) != (i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 418);
}
// ROR Label 419
if((i >= 18) != (i < 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}

// MCC Label 420
if(c == 0 && i < 18 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 420);
}
// MCC Label 421
if(c == 0 && !(i < 18) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 421);
}
// MCC Label 422
if(!(c == 0) && i < 18 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 422);
}
// MCC Label 423
if(!(c == 0) && !(i < 18) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 423);
}

  
// ABS Label 424
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}

// ROR Label 425
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
if( c==0 ){
    c = zNum[18*incr] - '8';
    testcase( c==(-1) );
    testcase( c==0 );
    testcase( c==(+1) );
  }
  
// ABS Label 426
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}
return c;
}

/*
** Convert zNum to a 64-bit signed integer.  zNum must be decimal. This
** routine does *not* accept hexadecimal notation.
**
** Returns:
**
**    -1    Not even a prefix of the input text looks like an integer
**     0    Successful transformation.  Fits in a 64-bit signed integer.
**     1    Excess non-space text after the integer value
**     2    Integer too large for a 64-bit signed integer or is malformed
**     3    Special case of 9223372036854775808
**
** length is the number of bytes in the string (bytes, not characters).
** The string is not necessarily zero-terminated.  The encoding is
** given by enc.
*/
int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){
  int incr;
  u64 u = 0;
  int neg = 0; /* assume positive */
  int i;
  int c = 0;
  int nonNum = 0;  /* True if input contains UTF16 with high byte non-zero */
  int rc;          /* Baseline return code */
  const char *zStart;
  
// ABS Label 427
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}
// ABS Label 428
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// AOR Label 429
if(zNum - length != zNum + length)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 429);
}
// AOR Label 430
if(zNum / length != zNum + length)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 430);
}
// AOR Label 431
if(zNum * length != zNum + length)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 431);
}
const char *zEnd = zNum + length;
  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );
  
// ROR Label 432
if((enc != 1) != (enc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 432);
}
if( enc==SQLITE_UTF8 ){
    incr = 1;
  }else{
    incr = 2;
    length &= ~1;
    assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );
    i = 3 - enc;

// ABS Label 433
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 433);
}
// ABS Label 434
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}

// COR Label 435
if((i < length || zNum[i] == 0) != (i < length && zNum[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 435);
}

// ROR Label 436
if((i <= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((i > length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
// ROR Label 438
if((i >= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}
// ROR Label 439
if((zNum[i] != 0) != (zNum[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 439);
}

// MCC Label 440
if(i < length && zNum[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(i < length && !(zNum[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(!(i < length) && zNum[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(!(i < length) && !(zNum[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}
for(; i<length && zNum[i]==0; i+=2){};
// ABS Label 444
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
// ABS Label 445
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// COR Label 446
if((i < length || zNum[i] == 0) != (i < length && zNum[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 446);
}

// ROR Label 447
if((i <= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((i > length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
// ROR Label 449
if((i >= length) != (i < length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 449);
}
// ROR Label 450
if((zNum[i] != 0) != (zNum[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 450);
}

// MCC Label 451
if(i < length && zNum[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 451);
}
// MCC Label 452
if(i < length && !(zNum[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 452);
}
// MCC Label 453
if(!(i < length) && zNum[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 453);
}
// MCC Label 454
if(!(i < length) && !(zNum[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 454);
}

    nonNum = i<length;
    zEnd = &zNum[i^1];
    zNum += (enc&1);
  }
  
// ABS Label 455
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}
// ABS Label 456
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}

// COR Label 457
if((zNum < zEnd || (sqlite3CtypeMap[(unsigned char)(*zNum)] & 1)) != (zNum < zEnd && (sqlite3CtypeMap[(unsigned char)(*zNum)] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 457);
}

// ROR Label 458
if((zNum <= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 458);
}
// ROR Label 459
if((zNum > zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 459);
}
// ROR Label 460
if((zNum >= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}

// MCC Label 461
if(zNum < zEnd && ( sqlite3CtypeMap[(unsigned char)(*zNum)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 461);
}
// MCC Label 462
if(zNum < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*zNum)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 462);
}
// MCC Label 463
if(!(zNum < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*zNum)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 463);
}
// MCC Label 464
if(!(zNum < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*zNum)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
while( zNum<zEnd && sqlite3Isspace(*zNum) ) { zNum+=incr;
};
// ABS Label 465
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 465);
}
// ABS Label 466
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}

// COR Label 467
if((zNum < zEnd || (sqlite3CtypeMap[(unsigned char)(*zNum)] & 1)) != (zNum < zEnd && (sqlite3CtypeMap[(unsigned char)(*zNum)] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 467);
}

// ROR Label 468
if((zNum <= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 468);
}
// ROR Label 469
if((zNum > zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 469);
}
// ROR Label 470
if((zNum >= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 470);
}

// MCC Label 471
if(zNum < zEnd && ( sqlite3CtypeMap[(unsigned char)(*zNum)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 471);
}
// MCC Label 472
if(zNum < zEnd && ( !(sqlite3CtypeMap[(unsigned char)(*zNum)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 472);
}
// MCC Label 473
if(!(zNum < zEnd) && ( sqlite3CtypeMap[(unsigned char)(*zNum)] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 473);
}
// MCC Label 474
if(!(zNum < zEnd) && ( !(sqlite3CtypeMap[(unsigned char)(*zNum)] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 474);
}

  
// ABS Label 475
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}
// ABS Label 476
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}

// ROR Label 477
if((zNum <= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 477);
}
// ROR Label 478
if((zNum > zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 478);
}
// ROR Label 479
if((zNum >= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 479);
}
if( zNum<zEnd ){
    
// ROR Label 480
if((*zNum != '-') != (*zNum == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
if( *zNum=='-' ){
      neg = 1;
      zNum+=incr;
    }else { 
// ROR Label 481
if((*zNum != '+') != (*zNum == '+'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 481);
}
if( *zNum=='+' ){
      zNum+=incr;
    };}

  }
  zStart = zNum;
  
// ABS Label 482
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}
// ABS Label 483
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}

// COR Label 484
if((zNum < zEnd || zNum[0] == '0') != (zNum < zEnd && zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 484);
}

// ROR Label 485
if((zNum <= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 485);
}
// ROR Label 486
if((zNum > zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 486);
}
// ROR Label 487
if((zNum >= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 487);
}
// ROR Label 488
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 488);
}

// MCC Label 489
if(zNum < zEnd && zNum[0] == '0' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 489);
}
// MCC Label 490
if(zNum < zEnd && !(zNum[0] == '0') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 490);
}
// MCC Label 491
if(!(zNum < zEnd) && zNum[0] == '0' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 491);
}
// MCC Label 492
if(!(zNum < zEnd) && !(zNum[0] == '0') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 492);
}
while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; };
// ABS Label 493
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}
// ABS Label 494
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 494);
}

// COR Label 495
if((zNum < zEnd || zNum[0] == '0') != (zNum < zEnd && zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 495);
}

// ROR Label 496
if((zNum <= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 496);
}
// ROR Label 497
if((zNum > zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 497);
}
// ROR Label 498
if((zNum >= zEnd) != (zNum < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}
// ROR Label 499
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 499);
}

// MCC Label 500
if(zNum < zEnd && zNum[0] == '0' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(zNum < zEnd && !(zNum[0] == '0') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(!(zNum < zEnd) && zNum[0] == '0' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(!(zNum < zEnd) && !(zNum[0] == '0') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
 /* Skip leading zeros. */
  i = 0;
for(; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){
    u = u*10 + c - '0';
  };
  testcase( i==18*incr );
  testcase( i==19*incr );
  testcase( i==20*incr );
  
// ABS Label 504
if(u < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}

// ROR Label 505
if((u <= (4294967295U | (((i64)2147483647) << 32))) != (u > (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 505);
}
// ROR Label 506
if((u < (4294967295U | (((i64)2147483647) << 32))) != (u > (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 506);
}
// ROR Label 507
if((u >= (4294967295U | (((i64)2147483647) << 32))) != (u > (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 507);
}
if( u>LARGEST_INT64 ){
    /* This test and assignment is needed only to suppress UB warnings
    ** from clang and -fsanitize=undefined.  This test and assignment make
    ** the code a little larger and slower, and no harm comes from omitting
    ** them, but we must appaise the undefined-behavior pharisees. */
    *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;
  }else { 
// ABS Label 508
if(neg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}
if( neg ){
    *pNum = -(i64)u;
  }else{
    *pNum = (i64)u;
  };}

  rc = 0;
  
// ABS Label 509
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}
// ABS Label 510
if(zNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}
// ABS Label 511
if(zStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}

// COR Label 512
if((i == 0 || zStart == zNum) != (i == 0 && zStart == zNum))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 512);
}

// ROR Label 513
if((i != 0) != (i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}
// ROR Label 514
if((zStart != zNum) != (zStart == zNum))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 514);
}

// MCC Label 515
if(i == 0 && zStart == zNum ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 515);
}
// MCC Label 516
if(i == 0 && !(zStart == zNum) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 516);
}
// MCC Label 517
if(!(i == 0) && zStart == zNum ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 517);
}
// MCC Label 518
if(!(i == 0) && !(zStart == zNum) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 518);
}
if( i==0 && zStart==zNum ){    /* No digits */
    rc = -1;
  }else { 
// ABS Label 519
if(nonNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}
if( nonNum ){            /* UTF16 with high-order bytes non-zero */
    rc = 1;
  }else { 
// ABS Label 520
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 520);
}

// ROR Label 521
if((&zNum[i] <= zEnd) != (&zNum[i] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 521);
}
// ROR Label 522
if((&zNum[i] > zEnd) != (&zNum[i] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 522);
}
// ROR Label 523
if((&zNum[i] >= zEnd) != (&zNum[i] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 523);
}
if( &zNum[i]<zEnd ){     /* Extra bytes at the end */
    
// ABS Label 524
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}
int jj = i;
    
// ABS Label 525
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}

// ROR Label 526
if((&zNum[jj] <= zEnd) != (&zNum[jj] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 526);
}
// ROR Label 527
if((&zNum[jj] > zEnd) != (&zNum[jj] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 527);
}
// ROR Label 528
if((&zNum[jj] >= zEnd) != (&zNum[jj] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 528);
}
do{
      if( !sqlite3Isspace(zNum[jj]) ){
        rc = 1;          /* Extra non-space text after the integer */
        break;
      }
      jj += incr;
    }while( &zNum[jj]<zEnd );
// ABS Label 529
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// ROR Label 530
if((&zNum[jj] <= zEnd) != (&zNum[jj] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 530);
}
// ROR Label 531
if((&zNum[jj] > zEnd) != (&zNum[jj] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 531);
}
// ROR Label 532
if((&zNum[jj] >= zEnd) != (&zNum[jj] < zEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 532);
}
;
  };}
;}

  
// ABS Label 533
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}
// ABS Label 534
if(incr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}

// AOR Label 535
if(19 - incr != 19 * incr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 535);
}
// AOR Label 536
if(19 + incr != 19 * incr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 536);
}
// AOR Label 537
if(19 / incr != 19 * incr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 537);
}

// ROR Label 538
if((i <= 19 * incr) != (i < 19 * incr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 538);
}
// ROR Label 539
if((i > 19 * incr) != (i < 19 * incr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 539);
}
// ROR Label 540
if((i >= 19 * incr) != (i < 19 * incr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 540);
}
if( i<19*incr ){
    /* Less than 19 digits, so we know that it fits in 64 bits */
    assert( u<=LARGEST_INT64 );
    
// ABS Label 541
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}
return rc;
  }else{
    /* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */
    c = i>19*incr ? 1 : compare2pow63(zNum, incr);
    
// ABS Label 542
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}

// ROR Label 543
if((c <= 0) != (c < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 543);
}
// ROR Label 544
if((c > 0) != (c < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 544);
}
// ROR Label 545
if((c >= 0) != (c < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 545);
}
if( c<0 ){
      /* zNum is less than 9223372036854775808 so it fits */
      assert( u<=LARGEST_INT64 );
      
// ABS Label 546
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}
return rc;
    }else{
      *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;
      
// ABS Label 547
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}

// ROR Label 548
if((c <= 0) != (c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 548);
}
// ROR Label 549
if((c < 0) != (c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 549);
}
// ROR Label 550
if((c >= 0) != (c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 550);
}
if( c>0 ){
        /* zNum is greater than 9223372036854775808 so it overflows */
        return 2;
      }else{
        /* zNum is exactly 9223372036854775808.  Fits if negative.  The
        ** special case 2 overflow if positive */
        assert( u-1==LARGEST_INT64 );
        return neg ? rc : 3;
      }
    }
  }
}

/*
** Transform a UTF-8 integer literal, in either decimal or hexadecimal,
** into a 64-bit signed integer.  This routine accepts hexadecimal literals,
** whereas sqlite3Atoi64() does not.
**
** Returns:
**
**     0    Successful transformation.  Fits in a 64-bit signed integer.
**     1    Excess text after the integer value
**     2    Integer too large for a 64-bit signed integer or is malformed
**     3    Special case of 9223372036854775808
*/
int sqlite3DecOrHexToI64(const char *z, i64 *pOut){
#ifndef SQLITE_OMIT_HEX_INTEGER
  
// COR Label 551
if((z[0] == '0' || (z[1] == 'x' || z[1] == 'X')) != (z[0] == '0' && (z[1] == 'x' || z[1] == 'X')))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 551);
}

// ROR Label 552
if((z[0] != '0') != (z[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 552);
}

// MCC Label 553
if(z[0] == '0' && ( z[1] == 'x' && z[1] == 'X' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 553);
}
// MCC Label 554
if(z[0] == '0' && ( z[1] == 'x' && !(z[1] == 'X') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 554);
}
// MCC Label 555
if(z[0] == '0' && ( !(z[1] == 'x') && z[1] == 'X' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 555);
}
// MCC Label 556
if(z[0] == '0' && ( !(z[1] == 'x') && !(z[1] == 'X') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 556);
}
// MCC Label 557
if(!(z[0] == '0') && ( z[1] == 'x' && z[1] == 'X' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 557);
}
// MCC Label 558
if(!(z[0] == '0') && ( z[1] == 'x' && !(z[1] == 'X') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 558);
}
// MCC Label 559
if(!(z[0] == '0') && ( !(z[1] == 'x') && z[1] == 'X' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 559);
}
// MCC Label 560
if(!(z[0] == '0') && ( !(z[1] == 'x') && !(z[1] == 'X') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 560);
}
if( z[0]=='0'
   && (z[1]=='x' || z[1]=='X')
  ){
    u64 u = 0;
    int i, k;
    i = 2;

// ROR Label 561
if((z[i] != '0') != (z[i] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 561);
}
for(; z[i]=='0'; i++){};
// ROR Label 562
if((z[i] != '0') != (z[i] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 562);
}

    k = i;

// MCC Label 563
if(( sqlite3CtypeMap[(unsigned char)(z[k])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 563);
}
// MCC Label 564
if(( !(sqlite3CtypeMap[(unsigned char)(z[k])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 564);
}
for(; sqlite3Isxdigit(z[k]); k++){
      u = u*16 + sqlite3HexToInt(z[k]);
    };
// MCC Label 565
if(( sqlite3CtypeMap[(unsigned char)(z[k])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 565);
}
// MCC Label 566
if(( !(sqlite3CtypeMap[(unsigned char)(z[k])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 566);
}

    memcpy(pOut, &u, 8);
    return (z[k]==0 && k-i<=16) ? 0 : 2;
  }else
#endif /* SQLITE_OMIT_HEX_INTEGER */
  {
    return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), SQLITE_UTF8);
  }
}

/*
** If zNum represents an integer that will fit in 32-bits, then set
** *pValue to that integer and return true.  Otherwise return false.
**
** This routine accepts both decimal and hexadecimal notation for integers.
**
** Any non-numeric characters that following zNum are ignored.
** This is different from sqlite3Atoi64() which requires the
** input number to be zero-terminated.
*/
int sqlite3GetInt32(const char *zNum, int *pValue){
  sqlite_int64 v = 0;
  int i, c;
  int neg = 0;
  
// ROR Label 567
if((zNum[0] != '-') != (zNum[0] == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 567);
}
if( zNum[0]=='-' ){
    neg = 1;
    zNum++;
  }else { 
// ROR Label 568
if((zNum[0] != '+') != (zNum[0] == '+'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 568);
}
if( zNum[0]=='+' ){
    zNum++;
  }
#ifndef SQLITE_OMIT_HEX_INTEGER
  else { 
// COR Label 569
if((zNum[0] == '0' && (zNum[1] == 'x' || zNum[1] == 'X') || (sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8)) != (zNum[0] == '0' && (zNum[1] == 'x' || zNum[1] == 'X') && (sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 569);
}
// COR Label 570
if((zNum[0] == '0' || (zNum[1] == 'x' || zNum[1] == 'X')) != (zNum[0] == '0' && (zNum[1] == 'x' || zNum[1] == 'X')))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 570);
}

// ROR Label 571
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}

// MCC Label 572
if(zNum[0] == '0' && ( zNum[1] == 'x' && zNum[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 572);
}
// MCC Label 573
if(zNum[0] == '0' && ( zNum[1] == 'x' && zNum[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 573);
}
// MCC Label 574
if(zNum[0] == '0' && ( zNum[1] == 'x' && !(zNum[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 574);
}
// MCC Label 575
if(zNum[0] == '0' && ( zNum[1] == 'x' && !(zNum[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(zNum[0] == '0' && ( !(zNum[1] == 'x') && zNum[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
// MCC Label 577
if(zNum[0] == '0' && ( !(zNum[1] == 'x') && zNum[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 577);
}
// MCC Label 578
if(zNum[0] == '0' && ( !(zNum[1] == 'x') && !(zNum[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
// MCC Label 579
if(zNum[0] == '0' && ( !(zNum[1] == 'x') && !(zNum[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 579);
}
// MCC Label 580
if(!(zNum[0] == '0') && ( zNum[1] == 'x' && zNum[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 580);
}
// MCC Label 581
if(!(zNum[0] == '0') && ( zNum[1] == 'x' && zNum[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 581);
}
// MCC Label 582
if(!(zNum[0] == '0') && ( zNum[1] == 'x' && !(zNum[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(!(zNum[0] == '0') && ( zNum[1] == 'x' && !(zNum[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(!(zNum[0] == '0') && ( !(zNum[1] == 'x') && zNum[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(!(zNum[0] == '0') && ( !(zNum[1] == 'x') && zNum[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
// MCC Label 586
if(!(zNum[0] == '0') && ( !(zNum[1] == 'x') && !(zNum[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 586);
}
// MCC Label 587
if(!(zNum[0] == '0') && ( !(zNum[1] == 'x') && !(zNum[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(zNum[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 587);
}
if( zNum[0]=='0'
        && (zNum[1]=='x' || zNum[1]=='X')
        && sqlite3Isxdigit(zNum[2])
  ){
    u32 u = 0;
    zNum += 2;
    
// ROR Label 588
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 588);
}
while( zNum[0]=='0' ) { zNum++;
};
// ROR Label 589
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 589);
}

    i = 0;

// ABS Label 590
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 590);
}

// COR Label 591
if(((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) || i < 8) != ((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) && i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 591);
}

// ROR Label 592
if((i <= 8) != (i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}
// ROR Label 593
if((i > 8) != (i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((i >= 8) != (i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}

// MCC Label 595
if(( sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8 ) && i < 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(( sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8 ) && !(i < 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
// MCC Label 597
if(( !(sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) ) && i < 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(( !(sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) ) && !(i < 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}
for(; sqlite3Isxdigit(zNum[i]) && i<8; i++){
      u = u*16 + sqlite3HexToInt(zNum[i]);
    };
// ABS Label 599
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}

// COR Label 600
if(((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) || i < 8) != ((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) && i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 600);
}

// ROR Label 601
if((i <= 8) != (i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 601);
}
// ROR Label 602
if((i > 8) != (i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 602);
}
// ROR Label 603
if((i >= 8) != (i < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 603);
}

// MCC Label 604
if(( sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8 ) && i < 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 604);
}
// MCC Label 605
if(( sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8 ) && !(i < 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 605);
}
// MCC Label 606
if(( !(sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) ) && i < 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 606);
}
// MCC Label 607
if(( !(sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) ) && !(i < 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 607);
}

    
// COR Label 608
if(((u & 2147483648U) == 0 || (sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0) != ((u & 2147483648U) == 0 && (sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 608);
}

// ROR Label 609
if(((u & 2147483648U) != 0) != ((u & 2147483648U) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 609);
}
// ROR Label 610
if(((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) != 0) != ((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}

// MCC Label 611
if((u & 2147483648U) == 0 && (sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 611);
}
// MCC Label 612
if((u & 2147483648U) == 0 && !((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 612);
}
// MCC Label 613
if(!((u & 2147483648U) == 0) && (sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 613);
}
// MCC Label 614
if(!((u & 2147483648U) == 0) && !((sqlite3CtypeMap[(unsigned char)(zNum[i])] & 8) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 614);
}
if( (u&0x80000000)==0 && sqlite3Isxdigit(zNum[i])==0 ){
      memcpy(pValue, &u, 4);
      return 1;
    }else{
      return 0;
    }
  };}
;}

#endif
  if( !sqlite3Isdigit(zNum[0]) ) { return 0;
}
  
// ROR Label 615
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 615);
}
while( zNum[0]=='0' ) { zNum++;
};
// ROR Label 616
if((zNum[0] != '0') != (zNum[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 616);
}

  i = 0;
for(; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){
    v = v*10 + c;
  };

  /* The longest decimal representation of a 32 bit integer is 10 digits:
  **
  **             1234567890
  **     2^31 -> 2147483648
  */
  testcase( i==10 );
  
// ABS Label 617
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}

// ROR Label 618
if((i <= 10) != (i > 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 618);
}
// ROR Label 619
if((i < 10) != (i > 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 619);
}
// ROR Label 620
if((i >= 10) != (i > 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
if( i>10 ){
    return 0;
  }
  testcase( v-neg==2147483647 );
  
// ABS Label 621
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 621);
}

// AOR Label 622
if(v / neg != v - neg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 622);
}
// AOR Label 623
if(v + neg != v - neg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 623);
}
// AOR Label 624
if(v * neg != v - neg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 624);
}

// ROR Label 625
if((v - neg <= 2147483647) != (v - neg > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}
// ROR Label 626
if((v - neg < 2147483647) != (v - neg > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 626);
}
// ROR Label 627
if((v - neg >= 2147483647) != (v - neg > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 627);
}
if( v-neg>2147483647 ){
    return 0;
  }
  
// ABS Label 628
if(neg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}
if( neg ){
    v = -v;
  }
  *pValue = (int)v;
  return 1;
}

/*
** Return a 32-bit integer value extracted from a string.  If the
** string is not an integer, just return 0.
*/
int sqlite3Atoi(const char *z){
  int x = 0;
  
// ABS Label 629
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}
sqlite3GetInt32(z, &x);
  
// ABS Label 630
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}
return x;
}

/*
** Try to convert z into an unsigned 32-bit integer.  Return true on
** success and false if there is an error.
**
** Only decimal notation is accepted.
*/
int sqlite3GetUInt32(const char *z, u32 *pI){
  u64 v = 0;
  int i;
  i = 0;

// MCC Label 631
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 631);
}
// MCC Label 632
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 632);
}
for(; sqlite3Isdigit(z[i]); i++){
    v = v*10 + z[i] - '0';
    
// ABS Label 635
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}

// ROR Label 636
if((v <= 4294967296LL) != (v > 4294967296LL))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
// ROR Label 637
if((v < 4294967296LL) != (v > 4294967296LL))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}
// ROR Label 638
if((v >= 4294967296LL) != (v > 4294967296LL))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 638);
}
if( v>4294967296LL ){ *pI = 0; return 0; }
  };
// MCC Label 633
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 633);
}
// MCC Label 634
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 634);
}

  
// ABS Label 639
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// COR Label 640
if((i == 0 && z[i] != 0) != (i == 0 || z[i] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 640);
}

// ROR Label 641
if((i != 0) != (i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 641);
}
// ROR Label 642
if((z[i] == 0) != (z[i] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}

// MCC Label 643
if(i == 0 && z[i] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 643);
}
// MCC Label 644
if(i == 0 && !(z[i] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 644);
}
// MCC Label 645
if(!(i == 0) && z[i] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 645);
}
// MCC Label 646
if(!(i == 0) && !(z[i] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 646);
}
if( i==0 || z[i]!=0 ){ *pI = 0; return 0; }
  *pI = (u32)v;
  return 1;
}

/*
** The variable-length integer encoding is as follows:
**
** KEY:
**         A = 0xxxxxxx    7 bits of data and one flag bit
**         B = 1xxxxxxx    7 bits of data and one flag bit
**         C = xxxxxxxx    8 bits of data
**
**  7 bits - A
** 14 bits - BA
** 21 bits - BBA
** 28 bits - BBBA
** 35 bits - BBBBA
** 42 bits - BBBBBA
** 49 bits - BBBBBBA
** 56 bits - BBBBBBBA
** 64 bits - BBBBBBBBC
*/

/*
** Write a 64-bit variable-length integer to memory starting at p[0].
** The length of data write will be between 1 and 9 bytes.  The number
** of bytes written is returned.
**
** A variable-length integer consists of the lower 7 bits of each byte
** for all bytes that have the 8th bit set and one byte with the 8th
** bit clear.  Except, if we get to the 9th byte, it stores the full
** 8 bits and is the last byte.
*/
static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){
  int i, j, n;
  u8 buf[10];
  
// ABS Label 647
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}

// AOR Label 648
if(v | (((u64)4278190080U) << 32) != v & (((u64)4278190080U) << 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 648);
}
// AOR Label 649
if(v ^ (((u64)4278190080U) << 32) != v & (((u64)4278190080U) << 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 649);
}
if( v & (((u64)0xff000000)<<32) ){
    p[8] = (u8)v;
    v >>= 8;
    i = 7;

// ABS Label 650
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}

// ROR Label 651
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}
// ROR Label 652
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 652);
}
// ROR Label 653
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 653);
}
for(; i>=0; i--){
      p[i] = (u8)((v & 0x7f) | 0x80);
      v >>= 7;
    };
// ABS Label 654
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}

// ROR Label 655
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 655);
}
// ROR Label 656
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 656);
}
// ROR Label 657
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 657);
}

    return 9;
  }    
  n = 0;
  
// ABS Label 658
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}

// ROR Label 659
if((v == 0) != (v != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 659);
}
do{
    buf[n++] = (u8)((v & 0x7f) | 0x80);
    v >>= 7;
  }while( v!=0 );
// ABS Label 660
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}

// ROR Label 661
if((v == 0) != (v != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 661);
}
;
  buf[0] &= 0x7f;
  assert( n<=9 );
  i = 0 , j = n - 1;

// ABS Label 662
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 662);
}

// ROR Label 663
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 663);
}
// ROR Label 664
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 664);
}
// ROR Label 665
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 665);
}
for(; j>=0; j--, i++){
    p[i] = buf[j];
  };
// ABS Label 666
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ROR Label 667
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
// ROR Label 668
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 668);
}
// ROR Label 669
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 669);
}

  
// ABS Label 670
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}
return n;
}
int sqlite3PutVarint(unsigned char *p, u64 v){
  
// ABS Label 671
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ROR Label 672
if((v < 127) != (v <= 127))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 672);
}
// ROR Label 673
if((v > 127) != (v <= 127))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 673);
}
// ROR Label 674
if((v >= 127) != (v <= 127))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 674);
}
if( v<=0x7f ){
    p[0] = v&0x7f;
    return 1;
  }
  
// ABS Label 675
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}

// ROR Label 676
if((v < 16383) != (v <= 16383))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 676);
}
// ROR Label 677
if((v > 16383) != (v <= 16383))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 677);
}
// ROR Label 678
if((v >= 16383) != (v <= 16383))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 678);
}
if( v<=0x3fff ){
    p[0] = ((v>>7)&0x7f)|0x80;
    p[1] = v&0x7f;
    return 2;
  }
  return putVarint64(p,v);
}

/*
** Bitmasks used by sqlite3GetVarint().  These precomputed constants
** are defined here rather than simply putting the constant expressions
** inline in order to work around bugs in the RVT compiler.
**
** SLOT_2_0     A mask for  (0x7f<<14) | 0x7f
**
** SLOT_4_2_0   A mask for  (0x7f<<28) | SLOT_2_0
*/
#define SLOT_2_0     0x001fc07f
#define SLOT_4_2_0   0xf01fc07f


/*
** Read a 64-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read.  The value is stored in *v.
*/
u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
  u32 a,b,s;

  
// ROR Label 679
if((((signed char *)p)[0] < 0) != (((signed char *)p)[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 679);
}
// ROR Label 680
if((((signed char *)p)[0] > 0) != (((signed char *)p)[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 680);
}
// ROR Label 681
if((((signed char *)p)[0] <= 0) != (((signed char *)p)[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 681);
}
if( ((signed char*)p)[0]>=0 ){
    *v = *p;
    return 1;
  }
  
// ROR Label 682
if((((signed char *)p)[1] < 0) != (((signed char *)p)[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 682);
}
// ROR Label 683
if((((signed char *)p)[1] > 0) != (((signed char *)p)[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 683);
}
// ROR Label 684
if((((signed char *)p)[1] <= 0) != (((signed char *)p)[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 684);
}
if( ((signed char*)p)[1]>=0 ){
    *v = ((u32)(p[0]&0x7f)<<7) | p[1];
    return 2;
  }

  /* Verify that constants are precomputed correctly */
  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );
  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );

  a = ((u32)p[0])<<14;
  b = p[1];
  p += 2;
  a |= *p;
  /* a: p0<<14 | p2 (unmasked) */
  if (!(a&0x80))
  {
    a &= SLOT_2_0;
    b &= 0x7f;
    b = b<<7;
    a |= b;
    *v = a;
    return 3;
  }

  /* CSE1 from below */
  a &= SLOT_2_0;
  p++;
  b = b<<14;
  b |= *p;
  /* b: p1<<14 | p3 (unmasked) */
  if (!(b&0x80))
  {
    b &= SLOT_2_0;
    /* moved CSE1 up */
    /* a &= (0x7f<<14)|(0x7f); */
    a = a<<7;
    a |= b;
    *v = a;
    return 4;
  }

  /* a: p0<<14 | p2 (masked) */
  /* b: p1<<14 | p3 (unmasked) */
  /* 1:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */
  /* moved CSE1 up */
  /* a &= (0x7f<<14)|(0x7f); */
  b &= SLOT_2_0;
  s = a;
  /* s: p0<<14 | p2 (masked) */

  p++;
  a = a<<14;
  a |= *p;
  /* a: p0<<28 | p2<<14 | p4 (unmasked) */
  if (!(a&0x80))
  {
    /* we can skip these cause they were (effectively) done above
    ** while calculating s */
    /* a &= (0x7f<<28)|(0x7f<<14)|(0x7f); */
    /* b &= (0x7f<<14)|(0x7f); */
    b = b<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 5;
  }

  /* 2:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */
  s = s<<7;
  s |= b;
  /* s: p0<<21 | p1<<14 | p2<<7 | p3 (masked) */

  p++;
  b = b<<14;
  b |= *p;
  /* b: p1<<28 | p3<<14 | p5 (unmasked) */
  if (!(b&0x80))
  {
    /* we can skip this cause it was (effectively) done above in calc'ing s */
    /* b &= (0x7f<<28)|(0x7f<<14)|(0x7f); */
    a &= SLOT_2_0;
    a = a<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 6;
  }

  p++;
  a = a<<14;
  a |= *p;
  /* a: p2<<28 | p4<<14 | p6 (unmasked) */
  if (!(a&0x80))
  {
    a &= SLOT_4_2_0;
    b &= SLOT_2_0;
    b = b<<7;
    a |= b;
    s = s>>11;
    *v = ((u64)s)<<32 | a;
    return 7;
  }

  /* CSE2 from below */
  a &= SLOT_2_0;
  p++;
  b = b<<14;
  b |= *p;
  /* b: p3<<28 | p5<<14 | p7 (unmasked) */
  if (!(b&0x80))
  {
    b &= SLOT_4_2_0;
    /* moved CSE2 up */
    /* a &= (0x7f<<14)|(0x7f); */
    a = a<<7;
    a |= b;
    s = s>>4;
    *v = ((u64)s)<<32 | a;
    return 8;
  }

  p++;
  a = a<<15;
  a |= *p;
  /* a: p4<<29 | p6<<15 | p8 (unmasked) */

  /* moved CSE2 up */
  /* a &= (0x7f<<29)|(0x7f<<15)|(0xff); */
  b &= SLOT_2_0;
  b = b<<8;
  a |= b;

  s = s<<4;
  b = p[-4];
  b &= 0x7f;
  b = b>>3;
  s |= b;

  *v = ((u64)s)<<32 | a;

  return 9;
}

/*
** Read a 32-bit variable-length integer from memory starting at p[0].
** Return the number of bytes read.  The value is stored in *v.
**
** If the varint stored in p[0] is larger than can fit in a 32-bit unsigned
** integer, then set *v to 0xffffffff.
**
** A MACRO version, getVarint32, is provided which inlines the 
** single-byte case.  All code should use the MACRO version as 
** this function assumes the single-byte case has already been handled.
*/
u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
  u32 a,b;

  /* The 1-byte case.  Overwhelmingly the most common.  Handled inline
  ** by the getVarin32() macro */
  a = *p;
  /* a: p0 (unmasked) */
#ifndef getVarint32
  if (!(a&0x80))
  {
    /* Values between 0 and 127 */
    *v = a;
    return 1;
  }
#endif

  /* The 2-byte case */
  p++;
  b = *p;
  /* b: p1 (unmasked) */
  if (!(b&0x80))
  {
    /* Values between 128 and 16383 */
    a &= 0x7f;
    a = a<<7;
    *v = a | b;
    return 2;
  }

  /* The 3-byte case */
  p++;
  a = a<<14;
  a |= *p;
  /* a: p0<<14 | p2 (unmasked) */
  if (!(a&0x80))
  {
    /* Values between 16384 and 2097151 */
    a &= (0x7f<<14)|(0x7f);
    b &= 0x7f;
    b = b<<7;
    *v = a | b;
    return 3;
  }

  /* A 32-bit varint is used to store size information in btrees.
  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.
  ** A 3-byte varint is sufficient, for example, to record the size
  ** of a 1048569-byte BLOB or string.
  **
  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very
  ** rare larger cases can be handled by the slower 64-bit varint
  ** routine.
  */
#if 1
  {
    u64 v64;
    u8 n;

    n = sqlite3GetVarint(p-2, &v64);
    assert( n>3 && n<=9 );
    
// ABS Label 685
if(v64 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}

// ROR Label 686
if(((v64 & ((((u64)1) << 32) - 1)) == v64) != ((v64 & ((((u64)1) << 32) - 1)) != v64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 686);
}
if( (v64 & SQLITE_MAX_U32)!=v64 ){
      *v = 0xffffffff;
    }else{
      *v = (u32)v64;
    }
    
// ABS Label 687
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}
return n;
  }

#else
  /* For following code (kept for historical record only) shows an
  ** unrolling for the 3- and 4-byte varint cases.  This code is
  ** slightly faster, but it is also larger and much harder to test.
  */
  p++;
  b = b<<14;
  b |= *p;
  /* b: p1<<14 | p3 (unmasked) */
  if (!(b&0x80))
  {
    /* Values between 2097152 and 268435455 */
    b &= (0x7f<<14)|(0x7f);
    a &= (0x7f<<14)|(0x7f);
    a = a<<7;
    *v = a | b;
    return 4;
  }

  p++;
  a = a<<14;
  a |= *p;
  /* a: p0<<28 | p2<<14 | p4 (unmasked) */
  if (!(a&0x80))
  {
    /* Values  between 268435456 and 34359738367 */
    a &= SLOT_4_2_0;
    b &= SLOT_4_2_0;
    b = b<<7;
    *v = a | b;
    return 5;
  }

  /* We can only reach this point when reading a corrupt database
  ** file.  In that case we are not in any hurry.  Use the (relatively
  ** slow) general-purpose sqlite3GetVarint() routine to extract the
  ** value. */
  {
    u64 v64;
    u8 n;

    p -= 4;
    n = sqlite3GetVarint(p, &v64);
    assert( n>5 && n<=9 );
    *v = (u32)v64;
    return n;
  }
#endif
}

/*
** Return the number of bytes that will be needed to store the given
** 64-bit integer.
*/
int sqlite3VarintLen(u64 v){
  int i;
  i = 1;
for(; (v >>= 7)!=0; i++){ assert( i<10 ); };
  
// ABS Label 688
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}
return i;
}


/*
** Read or write a four-byte big-endian integer value.
*/
u32 sqlite3Get4byte(const u8 *p){
#if SQLITE_BYTEORDER==4321
  u32 x;
  memcpy(&x,p,4);
  return x;
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
  u32 x;
  memcpy(&x,p,4);
  return __builtin_bswap32(x);
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
  u32 x;
  memcpy(&x,p,4);
  return _byteswap_ulong(x);
#else
  testcase( p[0]&0x80 );
  
// AOR Label 689
if(((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8) & p[3] != ((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3])  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 689);
}
// AOR Label 690
if(((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8) ^ p[3] != ((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3])  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 690);
}
// AOR Label 691
if(((unsigned int)p[0] << 24) | (p[1] << 16) & (p[2] << 8) != ((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 691);
}
// AOR Label 692
if(((unsigned int)p[0] << 24) | (p[1] << 16) ^ (p[2] << 8) != ((unsigned int)p[0] << 24) | (p[1] << 16) | (p[2] << 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 692);
}
// AOR Label 693
if(((unsigned int)p[0] << 24) & (p[1] << 16) != ((unsigned int)p[0] << 24) | (p[1] << 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 693);
}
// AOR Label 694
if(((unsigned int)p[0] << 24) ^ (p[1] << 16) != ((unsigned int)p[0] << 24) | (p[1] << 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 694);
}
return ((unsigned)p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];
#endif
}
void sqlite3Put4byte(unsigned char *p, u32 v){
#if SQLITE_BYTEORDER==4321
  memcpy(p,&v,4);
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
  u32 x = __builtin_bswap32(v);
  memcpy(p,&x,4);
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
  u32 x = _byteswap_ulong(v);
  memcpy(p,&x,4);
#else
  p[0] = (u8)(v>>24);
  p[1] = (u8)(v>>16);
  p[2] = (u8)(v>>8);
  p[3] = (u8)v;
#endif
}



/*
** Translate a single byte of Hex into an integer.
** This routine only works if h really is a valid hexadecimal
** character:  0..9a..fA..F
*/
u8 sqlite3HexToInt(int h){
  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );
#ifdef SQLITE_ASCII
  h += 9*(1&(h>>6));
#endif
#ifdef SQLITE_EBCDIC
  h += 9*(1&~(h>>4));
#endif
  return (u8)(h & 0xf);
}

#if !defined(SQLITE_OMIT_BLOB_LITERAL)
/*
** Convert a BLOB literal of the form "x'hhhhhh'" into its binary
** value.  Return a pointer to its binary value.  Space to hold the
** binary value has been obtained from malloc and must be freed by
** the calling routine.
*/
void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){
  char *zBlob;
  int i;

  zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);
  n--;
  
// ABS Label 695
if(zBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}
if( zBlob ){
    i = 0;

// ABS Label 696
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}
// ABS Label 697
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}

// ROR Label 698
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 698);
}
// ROR Label 699
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}
// ROR Label 700
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 700);
}
for(; i<n; i+=2){
      zBlob[i/2] = (sqlite3HexToInt(z[i])<<4) | sqlite3HexToInt(z[i+1]);
    };
// ABS Label 701
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}
// ABS Label 702
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}

// ROR Label 703
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 703);
}
// ROR Label 704
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 704);
}
// ROR Label 705
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 705);
}

    zBlob[i/2] = 0;
  }
  return zBlob;
}
#endif /* !SQLITE_OMIT_BLOB_LITERAL */

/*
** Log an error that is an API call on a connection pointer that should
** not have been used.  The "type" of connection pointer is given as the
** argument.  The zType is a word like "NULL" or "closed" or "invalid".
*/
static void logBadConnection(const char *zType){
  
// ABS Label 706
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}
sqlite3_log(SQLITE_MISUSE, 
     "API call with %s database connection pointer",
     zType
  );
}

/*
** Check to make sure we have a valid db pointer.  This test is not
** foolproof but it does provide some measure of protection against
** misuse of the interface such as passing in db pointers that are
** NULL or which have been previously closed.  If this routine returns
** 1 it means that the db pointer is valid and 0 if it should not be
** dereferenced for any reason.  The calling function should invoke
** SQLITE_MISUSE immediately.
**
** sqlite3SafetyCheckOk() requires that the db pointer be valid for
** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to
** open properly and is not fit for general use but which can be
** used as an argument to sqlite3_errmsg() or sqlite3_close().
*/
int sqlite3SafetyCheckOk(sqlite3 *db){
  u32 magic;
  
// ABS Label 707
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}

// ROR Label 708
if((db != 0) != (db == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 708);
}
if( db==0 ){
    logBadConnection("NULL");
    return 0;
  }
  magic = db->magic;
  
// ABS Label 709
if(magic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}

// ROR Label 710
if((magic == 2687084183U) != (magic != 2687084183U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 710);
}
if( magic!=SQLITE_MAGIC_OPEN ){
    if( sqlite3SafetyCheckSickOrOk(db) ){
      testcase( sqlite3GlobalConfig.xLog!=0 );
      logBadConnection("unopened");
    }
    return 0;
  }else{
    return 1;
  }
}
int sqlite3SafetyCheckSickOrOk(sqlite3 *db){
  u32 magic;
  magic = db->magic;
  
// ABS Label 711
if(magic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 711);
}

// COR Label 712
if((magic != 1266094736 && magic != 2687084183U || magic != 4030429446U) != (magic != 1266094736 && magic != 2687084183U && magic != 4030429446U))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 712);
}
// COR Label 713
if((magic != 1266094736 || magic != 2687084183U) != (magic != 1266094736 && magic != 2687084183U))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 713);
}

// ROR Label 714
if((magic == 1266094736) != (magic != 1266094736))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 714);
}
// ROR Label 715
if((magic == 2687084183U) != (magic != 2687084183U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 715);
}
// ROR Label 716
if((magic == 4030429446U) != (magic != 4030429446U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 716);
}

// MCC Label 717
if(magic != 1266094736 && magic != 2687084183U && magic != 4030429446U ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 717);
}
// MCC Label 718
if(magic != 1266094736 && magic != 2687084183U && !(magic != 4030429446U) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 718);
}
// MCC Label 719
if(magic != 1266094736 && !(magic != 2687084183U) && magic != 4030429446U ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 719);
}
// MCC Label 720
if(magic != 1266094736 && !(magic != 2687084183U) && !(magic != 4030429446U) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 720);
}
// MCC Label 721
if(!(magic != 1266094736) && magic != 2687084183U && magic != 4030429446U ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 721);
}
// MCC Label 722
if(!(magic != 1266094736) && magic != 2687084183U && !(magic != 4030429446U) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 722);
}
// MCC Label 723
if(!(magic != 1266094736) && !(magic != 2687084183U) && magic != 4030429446U ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 723);
}
// MCC Label 724
if(!(magic != 1266094736) && !(magic != 2687084183U) && !(magic != 4030429446U) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 724);
}
if( magic!=SQLITE_MAGIC_SICK &&
      magic!=SQLITE_MAGIC_OPEN &&
      magic!=SQLITE_MAGIC_BUSY ){
    testcase( sqlite3GlobalConfig.xLog!=0 );
    logBadConnection("invalid");
    return 0;
  }else{
    return 1;
  }
}

/*
** Attempt to add, substract, or multiply the 64-bit signed value iB against
** the other 64-bit signed integer at *pA and store the result in *pA.
** Return 0 on success.  Or if the operation would have resulted in an
** overflow, leave *pA unchanged and return 1.
*/
int sqlite3AddInt64(i64 *pA, i64 iB){
#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)
  return __builtin_add_overflow(*pA, iB, pA);
#else
  
// ABS Label 725
if(*pA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 725);
}
i64 iA = *pA;
  testcase( iA==0 ); testcase( iA==1 );
  testcase( iB==-1 ); testcase( iB==0 );
  
// ABS Label 726
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}

// ROR Label 727
if((iB < 0) != (iB >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 727);
}
// ROR Label 728
if((iB > 0) != (iB >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 728);
}
// ROR Label 729
if((iB <= 0) != (iB >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 729);
}
if( iB>=0 ){
    testcase( iA>0 && LARGEST_INT64 - iA == iB );
    testcase( iA>0 && LARGEST_INT64 - iA == iB - 1 );
    
// ABS Label 730
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
// ABS Label 731
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

// AOR Label 732
if((4294967295U | (((i64)2147483647) << 32)) / iA != (4294967295U | (((i64)2147483647) << 32)) - iA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 732);
}
// AOR Label 733
if((4294967295U | (((i64)2147483647) << 32)) + iA != (4294967295U | (((i64)2147483647) << 32)) - iA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 733);
}
// AOR Label 734
if((4294967295U | (((i64)2147483647) << 32)) * iA != (4294967295U | (((i64)2147483647) << 32)) - iA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 734);
}

// COR Label 735
if((iA > 0 || (4294967295U | (((i64)2147483647) << 32)) - iA < iB) != (iA > 0 && (4294967295U | (((i64)2147483647) << 32)) - iA < iB))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 735);
}

// ROR Label 736
if((iA <= 0) != (iA > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 736);
}
// ROR Label 737
if((iA < 0) != (iA > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 737);
}
// ROR Label 738
if((iA >= 0) != (iA > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 738);
}
// ROR Label 739
if(((4294967295U | (((i64)2147483647) << 32)) - iA <= iB) != ((4294967295U | (((i64)2147483647) << 32)) - iA < iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 739);
}
// ROR Label 740
if(((4294967295U | (((i64)2147483647) << 32)) - iA > iB) != ((4294967295U | (((i64)2147483647) << 32)) - iA < iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 740);
}
// ROR Label 741
if(((4294967295U | (((i64)2147483647) << 32)) - iA >= iB) != ((4294967295U | (((i64)2147483647) << 32)) - iA < iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 741);
}

// MCC Label 742
if(iA > 0 && (4294967295U | (((i64)2147483647) << 32)) - iA < iB ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 742);
}
// MCC Label 743
if(iA > 0 && !((4294967295U | (((i64)2147483647) << 32)) - iA < iB) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 743);
}
// MCC Label 744
if(!(iA > 0) && (4294967295U | (((i64)2147483647) << 32)) - iA < iB ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 744);
}
// MCC Label 745
if(!(iA > 0) && !((4294967295U | (((i64)2147483647) << 32)) - iA < iB) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 745);
}
if( iA>0 && LARGEST_INT64 - iA < iB ) { return 1;
}
  }else{
    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 1 );
    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 2 );
    
// ABS Label 746
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}
// ABS Label 747
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// AOR Label 748
if(iB - 1 != iB + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 748);
}
// AOR Label 749
if(iB / 1 != iB + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 749);
}
// AOR Label 750
if(iB * 1 != iB + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 750);
}

// COR Label 751
if((iA < 0 || -(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1) != (iA < 0 && -(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 751);
}

// ROR Label 752
if((iA <= 0) != (iA < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 752);
}
// ROR Label 753
if((iA > 0) != (iA < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 753);
}
// ROR Label 754
if((iA >= 0) != (iA < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 754);
}
// ROR Label 755
if((-(iA + (4294967295U | (((i64)2147483647) << 32))) <= iB + 1) != (-(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 755);
}
// ROR Label 756
if((-(iA + (4294967295U | (((i64)2147483647) << 32))) < iB + 1) != (-(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 756);
}
// ROR Label 757
if((-(iA + (4294967295U | (((i64)2147483647) << 32))) >= iB + 1) != (-(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 757);
}

// MCC Label 758
if(iA < 0 && -(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 758);
}
// MCC Label 759
if(iA < 0 && !(-(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 759);
}
// MCC Label 760
if(!(iA < 0) && -(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 760);
}
// MCC Label 761
if(!(iA < 0) && !(-(iA + (4294967295U | (((i64)2147483647) << 32))) > iB + 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 761);
}
if( iA<0 && -(iA + LARGEST_INT64) > iB + 1 ) { return 1;
}
  }
  *pA += iB;
  return 0; 
#endif
}
int sqlite3SubInt64(i64 *pA, i64 iB){
#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)
  return __builtin_sub_overflow(*pA, iB, pA);
#else
  testcase( iB==SMALLEST_INT64+1 );
  
// ABS Label 762
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}

// ROR Label 763
if((iB != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 763);
}
if( iB==SMALLEST_INT64 ){
    testcase( (*pA)==(-1) ); testcase( (*pA)==0 );
    
// ABS Label 764
if((*pA) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// ROR Label 765
if(((*pA) < 0) != ((*pA) >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 765);
}
// ROR Label 766
if(((*pA) > 0) != ((*pA) >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 766);
}
// ROR Label 767
if(((*pA) <= 0) != ((*pA) >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 767);
}
if( (*pA)>=0 ) { return 1;
}
    *pA -= iB;
    return 0;
  }else{
    return sqlite3AddInt64(pA, -iB);
  }
#endif
}
int sqlite3MulInt64(i64 *pA, i64 iB){
#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)
  return __builtin_mul_overflow(*pA, iB, pA);
#else
  
// ABS Label 768
if(*pA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}
i64 iA = *pA;
  
// ABS Label 769
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 769);
}

// ROR Label 770
if((iB <= 0) != (iB > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 770);
}
// ROR Label 771
if((iB < 0) != (iB > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 771);
}
// ROR Label 772
if((iB >= 0) != (iB > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 772);
}
if( iB>0 ){
    
// ABS Label 773
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}
// ABS Label 774
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}

// AOR Label 775
if((4294967295U | (((i64)2147483647) << 32)) - iB != (4294967295U | (((i64)2147483647) << 32)) / iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 775);
}
// AOR Label 776
if((4294967295U | (((i64)2147483647) << 32)) + iB != (4294967295U | (((i64)2147483647) << 32)) / iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 776);
}
// AOR Label 777
if((4294967295U | (((i64)2147483647) << 32)) * iB != (4294967295U | (((i64)2147483647) << 32)) / iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 777);
}

// ROR Label 778
if((iA <= (4294967295U | (((i64)2147483647) << 32)) / iB) != (iA > (4294967295U | (((i64)2147483647) << 32)) / iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 778);
}
// ROR Label 779
if((iA < (4294967295U | (((i64)2147483647) << 32)) / iB) != (iA > (4294967295U | (((i64)2147483647) << 32)) / iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 779);
}
// ROR Label 780
if((iA >= (4294967295U | (((i64)2147483647) << 32)) / iB) != (iA > (4294967295U | (((i64)2147483647) << 32)) / iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 780);
}
if( iA>LARGEST_INT64/iB ) { return 1;
}
    
// ABS Label 781
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}
// ABS Label 782
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}

// AOR Label 783
if((((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) - iB != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 783);
}
// AOR Label 784
if((((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) + iB != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 784);
}
// AOR Label 785
if((((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) * iB != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 785);
}

// ROR Label 786
if((iA <= (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB) != (iA < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 786);
}
// ROR Label 787
if((iA > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB) != (iA < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 787);
}
// ROR Label 788
if((iA >= (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB) != (iA < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 788);
}
if( iA<SMALLEST_INT64/iB ) { return 1;
}
  }else { 
// ABS Label 789
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}

// ROR Label 790
if((iB <= 0) != (iB < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 790);
}
// ROR Label 791
if((iB > 0) != (iB < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 791);
}
// ROR Label 792
if((iB >= 0) != (iB < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 792);
}
if( iB<0 ){
    
// ABS Label 793
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}

// ROR Label 794
if((iA <= 0) != (iA > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 794);
}
// ROR Label 795
if((iA < 0) != (iA > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 795);
}
// ROR Label 796
if((iA >= 0) != (iA > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 796);
}
if( iA>0 ){
      
// ABS Label 797
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}
// ABS Label 798
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}

// AOR Label 799
if((((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) - iA != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 799);
}
// AOR Label 800
if((((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) + iA != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 800);
}
// AOR Label 801
if((((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) * iA != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 801);
}

// ROR Label 802
if((iB <= (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA) != (iB < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 802);
}
// ROR Label 803
if((iB > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA) != (iB < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 803);
}
// ROR Label 804
if((iB >= (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA) != (iB < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) / iA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 804);
}
if( iB<SMALLEST_INT64/iA ) { return 1;
}
    }else { 
// ABS Label 805
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}

// ROR Label 806
if((iA <= 0) != (iA < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 806);
}
// ROR Label 807
if((iA > 0) != (iA < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 807);
}
// ROR Label 808
if((iA >= 0) != (iA < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 808);
}
if( iA<0 ){
      
// ABS Label 809
if(iB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}

// ROR Label 810
if((iB != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (iB == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 810);
}
if( iB==SMALLEST_INT64 ) { return 1;
}
      
// ABS Label 811
if(iA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}

// ROR Label 812
if((iA != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (iA == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 812);
}
if( iA==SMALLEST_INT64 ) { return 1;
}
      
// AOR Label 813
if((4294967295U | (((i64)2147483647) << 32)) - -iB != (4294967295U | (((i64)2147483647) << 32)) / -iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 813);
}
// AOR Label 814
if((4294967295U | (((i64)2147483647) << 32)) + -iB != (4294967295U | (((i64)2147483647) << 32)) / -iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 814);
}
// AOR Label 815
if((4294967295U | (((i64)2147483647) << 32)) * -iB != (4294967295U | (((i64)2147483647) << 32)) / -iB)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 815);
}

// ROR Label 816
if((-iA <= (4294967295U | (((i64)2147483647) << 32)) / -iB) != (-iA > (4294967295U | (((i64)2147483647) << 32)) / -iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 816);
}
// ROR Label 817
if((-iA < (4294967295U | (((i64)2147483647) << 32)) / -iB) != (-iA > (4294967295U | (((i64)2147483647) << 32)) / -iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 817);
}
// ROR Label 818
if((-iA >= (4294967295U | (((i64)2147483647) << 32)) / -iB) != (-iA > (4294967295U | (((i64)2147483647) << 32)) / -iB))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 818);
}
if( -iA>LARGEST_INT64/-iB ) { return 1;
}
    };}

  };}

  *pA = iA*iB;
  return 0;
#endif
}

/*
** Compute the absolute value of a 32-bit signed integer, of possible.  Or 
** if the integer has a value of -2147483648, return +2147483647
*/
int sqlite3AbsInt32(int x){
  
// ABS Label 819
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}

// ROR Label 820
if((x < 0) != (x >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 820);
}
// ROR Label 821
if((x > 0) != (x >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 821);
}
// ROR Label 822
if((x <= 0) != (x >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 822);
}
if( x>=0 ) { 
// ABS Label 823
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}
return x;
}
  
// ABS Label 824
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ROR Label 825
if((x != (int)2147483648U) != (x == (int)2147483648U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 825);
}
if( x==(int)0x80000000 ) { return 0x7fffffff;
}
  return -x;
}

#ifdef SQLITE_ENABLE_8_3_NAMES
/*
** If SQLITE_ENABLE_8_3_NAMES is set at compile-time and if the database
** filename in zBaseFilename is a URI with the "8_3_names=1" parameter and
** if filename in z[] has a suffix (a.k.a. "extension") that is longer than
** three characters, then shorten the suffix on z[] to be the last three
** characters of the original suffix.
**
** If SQLITE_ENABLE_8_3_NAMES is set to 2 at compile-time, then always
** do the suffix shortening regardless of URI parameter.
**
** Examples:
**
**     test.db-journal    =>   test.nal
**     test.db-wal        =>   test.wal
**     test.db-shm        =>   test.shm
**     test.db-mj7f3319fa =>   test.9fa
*/
void sqlite3FileSuffix3(const char *zBaseFilename, char *z){
#if SQLITE_ENABLE_8_3_NAMES<2
  if( sqlite3_uri_boolean(zBaseFilename, "8_3_names", 0) )
#endif
  {
    int i, sz;
    sz = sqlite3Strlen30(z);
    for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}
    if( z[i]=='.' && ALWAYS(sz>i+4) ) memmove(&z[i+1], &z[sz-3], 4);
  }
}
#endif

/* 
** Find (an approximate) sum of two LogEst values.  This computation is
** not a simple "+" operator because LogEst is stored as a logarithmic
** value.
** 
*/
LogEst sqlite3LogEstAdd(LogEst a, LogEst b){
  static const unsigned char x[] = {
     10, 10,                         /* 0,1 */
      9, 9,                          /* 2,3 */
      8, 8,                          /* 4,5 */
      7, 7, 7,                       /* 6,7,8 */
      6, 6, 6,                       /* 9,10,11 */
      5, 5, 5,                       /* 12-14 */
      4, 4, 4, 4,                    /* 15-18 */
      3, 3, 3, 3, 3, 3,              /* 19-24 */
      2, 2, 2, 2, 2, 2, 2,           /* 25-31 */
  };
  
// ROR Label 826
if((a < b) != (a >= b))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 826);
}
// ROR Label 827
if((a > b) != (a >= b))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 827);
}
// ROR Label 828
if((a <= b) != (a >= b))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 828);
}
if( a>=b ){
    
// AOR Label 829
if(b - 49 != b + 49)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 829);
}
// AOR Label 830
if(b / 49 != b + 49)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 830);
}
// AOR Label 831
if(b * 49 != b + 49)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 831);
}

// ROR Label 832
if((a <= b + 49) != (a > b + 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}
// ROR Label 833
if((a < b + 49) != (a > b + 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 833);
}
// ROR Label 834
if((a >= b + 49) != (a > b + 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 834);
}
if( a>b+49 ) { 
// ABS Label 835
if(a < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}
return a;
}
    
// AOR Label 836
if(b - 31 != b + 31)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 836);
}
// AOR Label 837
if(b / 31 != b + 31)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 837);
}
// AOR Label 838
if(b * 31 != b + 31)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 838);
}

// ROR Label 839
if((a <= b + 31) != (a > b + 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 839);
}
// ROR Label 840
if((a < b + 31) != (a > b + 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 840);
}
// ROR Label 841
if((a >= b + 31) != (a > b + 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 841);
}
if( a>b+31 ) { return a+1;
}
    return a+x[a-b];
  }else{
    
// AOR Label 842
if(a - 49 != a + 49)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 842);
}
// AOR Label 843
if(a / 49 != a + 49)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 843);
}
// AOR Label 844
if(a * 49 != a + 49)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 844);
}

// ROR Label 845
if((b <= a + 49) != (b > a + 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 845);
}
// ROR Label 846
if((b < a + 49) != (b > a + 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 846);
}
// ROR Label 847
if((b >= a + 49) != (b > a + 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 847);
}
if( b>a+49 ) { 
// ABS Label 848
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}
return b;
}
    
// AOR Label 849
if(a - 31 != a + 31)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 849);
}
// AOR Label 850
if(a / 31 != a + 31)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 850);
}
// AOR Label 851
if(a * 31 != a + 31)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 851);
}

// ROR Label 852
if((b <= a + 31) != (b > a + 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 852);
}
// ROR Label 853
if((b < a + 31) != (b > a + 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
// ROR Label 854
if((b >= a + 31) != (b > a + 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 854);
}
if( b>a+31 ) { return b+1;
}
    return b+x[b-a];
  }
}

/*
** Convert an integer into a LogEst.  In other words, compute an
** approximation for 10*log2(x).
*/
LogEst sqlite3LogEst(u64 x){
  static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };
  LogEst y = 40;
  
// ABS Label 855
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}

// ROR Label 856
if((x <= 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 856);
}
// ROR Label 857
if((x > 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 857);
}
// ROR Label 858
if((x >= 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 858);
}
if( x<8 ){
    
// ABS Label 859
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}

// ROR Label 860
if((x <= 2) != (x < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 860);
}
// ROR Label 861
if((x > 2) != (x < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 861);
}
// ROR Label 862
if((x >= 2) != (x < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
if( x<2 ) { return 0;
}
    
// ABS Label 863
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}

// ROR Label 864
if((x <= 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}
// ROR Label 865
if((x > 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 865);
}
// ROR Label 866
if((x >= 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}
while( x<8 ){  y -= 10; x <<= 1; };
// ABS Label 867
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 867);
}

// ROR Label 868
if((x <= 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 868);
}
// ROR Label 869
if((x > 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 869);
}
// ROR Label 870
if((x >= 8) != (x < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 870);
}

  }else{
#if GCC_VERSION>=5004000
    int i = 60 - __builtin_clzll(x);
    y += i*10;
    x >>= i;
#else
    
// ABS Label 871
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}

// ROR Label 872
if((x <= 255) != (x > 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 872);
}
// ROR Label 873
if((x < 255) != (x > 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 873);
}
// ROR Label 874
if((x >= 255) != (x > 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 874);
}
while( x>255 ){ y += 40; x >>= 4; };
// ABS Label 875
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 875);
}

// ROR Label 876
if((x <= 255) != (x > 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 876);
}
// ROR Label 877
if((x < 255) != (x > 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 877);
}
// ROR Label 878
if((x >= 255) != (x > 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 878);
}
  /*OPTIMIZATION-IF-TRUE*/
    
// ABS Label 879
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 879);
}

// ROR Label 880
if((x <= 15) != (x > 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 880);
}
// ROR Label 881
if((x < 15) != (x > 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 881);
}
// ROR Label 882
if((x >= 15) != (x > 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 882);
}
while( x>15 ){  y += 10; x >>= 1; };
// ABS Label 883
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}

// ROR Label 884
if((x <= 15) != (x > 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 884);
}
// ROR Label 885
if((x < 15) != (x > 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 885);
}
// ROR Label 886
if((x >= 15) != (x > 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}

#endif
  }
  return a[x&7] + y - 10;
}

#ifndef SQLITE_OMIT_VIRTUALTABLE
/*
** Convert a double into a LogEst
** In other words, compute an approximation for 10*log2(x).
*/
LogEst sqlite3LogEstFromDouble(double x){
  u64 a;
  LogEst e;
  assert( sizeof(x)==8 && sizeof(a)==8 );
  
// ABS Label 887
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 887);
}

// ROR Label 888
if((x < 1) != (x <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
// ROR Label 889
if((x > 1) != (x <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 889);
}
// ROR Label 890
if((x >= 1) != (x <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 890);
}
if( x<=1 ) { return 0;
}
  
// ABS Label 891
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}

// ROR Label 892
if((x < 2000000000) != (x <= 2000000000))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
// ROR Label 893
if((x > 2000000000) != (x <= 2000000000))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 893);
}
// ROR Label 894
if((x >= 2000000000) != (x <= 2000000000))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 894);
}
if( x<=2000000000 ) { return sqlite3LogEst((u64)x);
}
  memcpy(&a, &x, 8);
  e = (a>>52) - 1022;
  return e*10;
}
#endif /* SQLITE_OMIT_VIRTUALTABLE */

#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
    defined(SQLITE_ENABLE_STAT4) || \
    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
/*
** Convert a LogEst into an integer.
**
** Note that this routine is only used when one or more of various
** non-standard compile-time options is enabled.
*/
u64 sqlite3LogEstToInt(LogEst x){
  u64 n;
  n = x%10;
  x /= 10;
  if( n>=5 ) n -= 2;
  else if( n>=1 ) n -= 1;
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \
    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)
  if( x>60 ) return (u64)LARGEST_INT64;
#else
  /* If only SQLITE_ENABLE_STAT4 is on, then the largest input
  ** possible to this routine is 310, resulting in a maximum x of 31 */
  assert( x<=60 );
#endif
  return x>=3 ? (n+8)<<(x-3) : (n+8)>>(3-x);
}
#endif /* defined SCANSTAT or STAT4 or ESTIMATED_ROWS */

/*
** Add a new name/number pair to a VList.  This might require that the
** VList object be reallocated, so return the new VList.  If an OOM
** error occurs, the original VList returned and the
** db->mallocFailed flag is set.
**
** A VList is really just an array of integers.  To destroy a VList,
** simply pass it to sqlite3DbFree().
**
** The first integer is the number of integers allocated for the whole
** VList.  The second integer is the number of integers actually used.
** Each name/number pair is encoded by subsequent groups of 3 or more
** integers.
**
** Each name/number pair starts with two integers which are the numeric
** value for the pair and the size of the name/number pair, respectively.
** The text name overlays one or more following integers.  The text name
** is always zero-terminated.
**
** Conceptually:
**
**    struct VList {
**      int nAlloc;   // Number of allocated slots 
**      int nUsed;    // Number of used slots 
**      struct VListEntry {
**        int iValue;    // Value for this entry
**        int nSlot;     // Slots used by this entry
**        // ... variable name goes here
**      } a[0];
**    }
**
** During code generation, pointers to the variable names within the
** VList are taken.  When that happens, nAlloc is set to zero as an 
** indication that the VList may never again be enlarged, since the
** accompanying realloc() would invalidate the pointers.
*/
VList *sqlite3VListAdd(
  sqlite3 *db,           /* The database connection used for malloc() */
  VList *pIn,            /* The input VList.  Might be NULL */
  const char *zName,     /* Name of symbol to add */
  int nName,             /* Bytes of text in zName */
  int iVal               /* Value to associate with zName */
){
  int nInt;              /* number of sizeof(int) objects needed for zName */
  char *z;               /* Pointer to where zName will be stored */
  int i;                 /* Index in pIn[] where zName is stored */

  nInt = nName/4 + 3;
  assert( pIn==0 || pIn[0]>=3 );  /* Verify ok to add new elements */
  
// ABS Label 895
if(nInt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}
// ABS Label 896
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}
// ABS Label 897
if(pIn[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}
// ABS Label 898
if(pIn[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 898);
}

// AOR Label 899
if(pIn[1] - nInt != pIn[1] + nInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 899);
}
// AOR Label 900
if(pIn[1] / nInt != pIn[1] + nInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 900);
}
// AOR Label 901
if(pIn[1] * nInt != pIn[1] + nInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 901);
}

// COR Label 902
if((pIn == 0 && pIn[1] + nInt > pIn[0]) != (pIn == 0 || pIn[1] + nInt > pIn[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 902);
}

// ROR Label 903
if((pIn != 0) != (pIn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 903);
}
// ROR Label 904
if((pIn[1] + nInt <= pIn[0]) != (pIn[1] + nInt > pIn[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 904);
}
// ROR Label 905
if((pIn[1] + nInt < pIn[0]) != (pIn[1] + nInt > pIn[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 905);
}
// ROR Label 906
if((pIn[1] + nInt >= pIn[0]) != (pIn[1] + nInt > pIn[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 906);
}

// MCC Label 907
if(pIn == 0 && pIn[1] + nInt > pIn[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(pIn == 0 && !(pIn[1] + nInt > pIn[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
// MCC Label 909
if(!(pIn == 0) && pIn[1] + nInt > pIn[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 909);
}
// MCC Label 910
if(!(pIn == 0) && !(pIn[1] + nInt > pIn[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 910);
}
if( pIn==0 || pIn[1]+nInt > pIn[0] ){
    /* Enlarge the allocation */
    
// AOR Label 911
if((pIn ? 2 * (sqlite3_int64)pIn[0] : 10) - nInt != (pIn ? 2 * (sqlite3_int64)pIn[0] : 10) + nInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 911);
}
// AOR Label 912
if((pIn ? 2 * (sqlite3_int64)pIn[0] : 10) / nInt != (pIn ? 2 * (sqlite3_int64)pIn[0] : 10) + nInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 912);
}
// AOR Label 913
if((pIn ? 2 * (sqlite3_int64)pIn[0] : 10) * nInt != (pIn ? 2 * (sqlite3_int64)pIn[0] : 10) + nInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 913);
}
sqlite3_int64 nAlloc = (pIn ? 2*(sqlite3_int64)pIn[0] : 10) + nInt;
    VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));
    
// ABS Label 914
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 914);
}

// ROR Label 915
if((pOut != 0) != (pOut == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 915);
}
if( pOut==0 ) { 
// ABS Label 916
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 916);
}
return pIn;
}
    
// ABS Label 917
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ROR Label 918
if((pIn != 0) != (pIn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
if( pIn==0 ) { pOut[1] = 2;
}
    pIn = pOut;
    pIn[0] = nAlloc;
  }
  i = pIn[1];
  pIn[i] = iVal;
  pIn[i+1] = nInt;
  z = (char*)&pIn[i+2];
  pIn[1] = i+nInt;
  assert( pIn[1]<=pIn[0] );
  memcpy(z, zName, nName);
  z[nName] = 0;
  
// ABS Label 919
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}
return pIn;
}

/*
** Return a pointer to the name of a variable in the given VList that
** has the value iVal.  Or return a NULL if there is no such variable in
** the list
*/
const char *sqlite3VListNumToName(VList *pIn, int iVal){
  int i, mx;
  
// ABS Label 920
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}

// ROR Label 921
if((pIn != 0) != (pIn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 921);
}
if( pIn==0 ) { return 0;
}
  mx = pIn[1];
  i = 2;
  
// ABS Label 922
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}
// ABS Label 923
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}

// ROR Label 924
if((i <= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 924);
}
// ROR Label 925
if((i > mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 925);
}
// ROR Label 926
if((i >= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 926);
}
do{
    
// ABS Label 932
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 932);
}
// ABS Label 933
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}
// ABS Label 934
if(pIn[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}

// ROR Label 935
if((pIn[i] != iVal) != (pIn[i] == iVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 935);
}
if( pIn[i]==iVal ) { return (char*)&pIn[i+2];
}
    i += pIn[i+1];
  }while( i<mx );
// ABS Label 927
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 927);
}
// ABS Label 928
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 928);
}

// ROR Label 929
if((i <= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 929);
}
// ROR Label 930
if((i > mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 930);
}
// ROR Label 931
if((i >= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 931);
}
;
  return 0;
}

/*
** Return the number of the variable named zName, if it is in VList.
** or return 0 if there is no such variable.
*/
int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){
  int i, mx;
  
// ABS Label 936
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 936);
}

// ROR Label 937
if((pIn != 0) != (pIn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 937);
}
if( pIn==0 ) { return 0;
}
  mx = pIn[1];
  i = 2;
  
// ABS Label 938
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}
// ABS Label 939
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}

// ROR Label 940
if((i <= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 940);
}
// ROR Label 941
if((i > mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 941);
}
// ROR Label 942
if((i >= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 942);
}
do{
    const char *z = (const char*)&pIn[i+2];
    
// ROR Label 948
if((z[nName] != 0) != (z[nName] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 948);
}

// MCC Label 949
if(1 && z[nName] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 949);
}
// MCC Label 950
if(1 && !(z[nName] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 950);
}
if( strncmp(z,zName,nName)==0 && z[nName]==0 ) { 
// ABS Label 951
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 951);
}
// ABS Label 952
if(pIn[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 952);
}
return pIn[i];
}
    i += pIn[i+1];
  }while( i<mx );
// ABS Label 943
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}
// ABS Label 944
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}

// ROR Label 945
if((i <= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 945);
}
// ROR Label 946
if((i > mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 946);
}
// ROR Label 947
if((i >= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 947);
}
;
  return 0;
}
