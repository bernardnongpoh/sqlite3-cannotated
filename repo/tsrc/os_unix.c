/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2004 May 22
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file contains the VFS implementation for unix-like operating systems
** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.
**
** There are actually several different VFS implementations in this file.
** The differences are in the way that file locking is done.  The default
** implementation uses Posix Advisory Locks.  Alternative implementations
** use flock(), dot-files, various proprietary locking schemas, or simply
** skip locking all together.
**
** This source file is organized into divisions where the logic for various
** subfunctions is contained within the appropriate division.  PLEASE
** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placed
** in the correct division and should be clearly labeled.
**
** The layout of divisions is as follows:
**
**   *  General-purpose declarations and utility functions.
**   *  Unique file ID logic used by VxWorks.
**   *  Various locking primitive implementations (all except proxy locking):
**      + for Posix Advisory Locks
**      + for no-op locks
**      + for dot-file locks
**      + for flock() locking
**      + for named semaphore locks (VxWorks only)
**      + for AFP filesystem locks (MacOSX only)
**   *  sqlite3_file methods not associated with locking.
**   *  Definitions of sqlite3_io_methods objects for all locking
**      methods plus "finder" functions for each locking method.
**   *  sqlite3_vfs method implementations.
**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)
**   *  Definitions of sqlite3_vfs objects for all locking methods
**      plus implementations of sqlite3_os_init() and sqlite3_os_end().
*/
#include "sqliteInt.h"
#if SQLITE_OS_UNIX              /* This file is used on unix only */

/*
** There are various methods for file locking used for concurrency
** control:
**
**   1. POSIX locking (the default),
**   2. No locking,
**   3. Dot-file locking,
**   4. flock() locking,
**   5. AFP locking (OSX only),
**   6. Named POSIX semaphores (VXWorks only),
**   7. proxy locking. (OSX only)
**
** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLE
** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automatic
** selection of the appropriate locking style based on the filesystem
** where the database is located.  
*/
#if !defined(SQLITE_ENABLE_LOCKING_STYLE)
#  if defined(__APPLE__)
#    define SQLITE_ENABLE_LOCKING_STYLE 1
#  else
#    define SQLITE_ENABLE_LOCKING_STYLE 0
#  endif
#endif

/* Use pread() and pwrite() if they are available */
#if defined(__APPLE__)
# define HAVE_PREAD 1
# define HAVE_PWRITE 1
#endif
#if defined(HAVE_PREAD64) && defined(HAVE_PWRITE64)
# undef USE_PREAD
# define USE_PREAD64 1
#elif defined(HAVE_PREAD) && defined(HAVE_PWRITE)
# undef USE_PREAD64
# define USE_PREAD 1
#endif

/*
** standard include files.
*/
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <time.h>
#include <sys/time.h>
#include <errno.h>
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
# include <sys/mman.h>
#endif

#if SQLITE_ENABLE_LOCKING_STYLE
# include <sys/ioctl.h>
# include <sys/file.h>
# include <sys/param.h>
#endif /* SQLITE_ENABLE_LOCKING_STYLE */

/*
** Try to determine if gethostuuid() is available based on standard
** macros.  This might sometimes compute the wrong value for some
** obscure platforms.  For those cases, simply compile with one of
** the following:
**
**    -DHAVE_GETHOSTUUID=0
**    -DHAVE_GETHOSTUUID=1
**
** None if this matters except when building on Apple products with
** -DSQLITE_ENABLE_LOCKING_STYLE.
*/
#ifndef HAVE_GETHOSTUUID
# define HAVE_GETHOSTUUID 0
# if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) || \
                            (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))
#    if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0)) \
        && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0))\
        && (!defined(TARGET_OS_MACCATALYST) || (TARGET_OS_MACCATALYST==0))
#      undef HAVE_GETHOSTUUID
#      define HAVE_GETHOSTUUID 1
#    else
#      warning "gethostuuid() is disabled."
#    endif
#  endif
#endif


#if OS_VXWORKS
# include <sys/ioctl.h>
# include <semaphore.h>
# include <limits.h>
#endif /* OS_VXWORKS */

#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
# include <sys/mount.h>
#endif

#ifdef HAVE_UTIME
# include <utime.h>
#endif

/*
** Allowed values of unixFile.fsFlags
*/
#define SQLITE_FSFLAGS_IS_MSDOS     0x1

/*
** If we are to be thread-safe, include the pthreads header.
*/
#if SQLITE_THREADSAFE
# include <pthread.h>
#endif

/*
** Default permissions when creating a new file
*/
#ifndef SQLITE_DEFAULT_FILE_PERMISSIONS
# define SQLITE_DEFAULT_FILE_PERMISSIONS 0644
#endif

/*
** Default permissions when creating auto proxy dir
*/
#ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
# define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755
#endif

/*
** Maximum supported path-length.
*/
#define MAX_PATHNAME 512

/*
** Maximum supported symbolic links
*/
#define SQLITE_MAX_SYMLINKS 100

/* Always cast the getpid() return type for compatibility with
** kernel modules in VxWorks. */
#define osGetpid(X) (pid_t)getpid()

/*
** Only set the lastErrno if the error code is a real error and not 
** a normal expected return code of SQLITE_BUSY or SQLITE_OK
*/
#define IS_LOCK_ERROR(x)  ((x != SQLITE_OK) && (x != SQLITE_BUSY))

/* Forward references */
typedef struct unixShm unixShm;               /* Connection shared memory */
typedef struct unixShmNode unixShmNode;       /* Shared memory instance */
typedef struct unixInodeInfo unixInodeInfo;   /* An i-node */
typedef struct UnixUnusedFd UnixUnusedFd;     /* An unused file descriptor */

/*
** Sometimes, after a file handle is closed by SQLite, the file descriptor
** cannot be closed immediately. In these cases, instances of the following
** structure are used to store the file descriptor while waiting for an
** opportunity to either close or reuse it.
*/
struct UnixUnusedFd {
  int fd;                   /* File descriptor to close */
  int flags;                /* Flags this file descriptor was opened with */
  UnixUnusedFd *pNext;      /* Next unused file descriptor on same file */
};

/*
** The unixFile structure is subclass of sqlite3_file specific to the unix
** VFS implementations.
*/
typedef struct unixFile unixFile;
struct unixFile {
  sqlite3_io_methods const *pMethod;  /* Always the first entry */
  sqlite3_vfs *pVfs;                  /* The VFS that created this unixFile */
  unixInodeInfo *pInode;              /* Info about locks on this inode */
  int h;                              /* The file descriptor */
  unsigned char eFileLock;            /* The type of lock held on this fd */
  unsigned short int ctrlFlags;       /* Behavioral bits.  UNIXFILE_* flags */
  int lastErrno;                      /* The unix errno from last I/O error */
  void *lockingContext;               /* Locking style specific state */
  UnixUnusedFd *pPreallocatedUnused;  /* Pre-allocated UnixUnusedFd */
  const char *zPath;                  /* Name of the file */
  unixShm *pShm;                      /* Shared memory segment information */
  int szChunk;                        /* Configured by FCNTL_CHUNK_SIZE */
#if SQLITE_MAX_MMAP_SIZE>0
  int nFetchOut;                      /* Number of outstanding xFetch refs */
  sqlite3_int64 mmapSize;             /* Usable size of mapping at pMapRegion */
  sqlite3_int64 mmapSizeActual;       /* Actual size of mapping at pMapRegion */
  sqlite3_int64 mmapSizeMax;          /* Configured FCNTL_MMAP_SIZE value */
  void *pMapRegion;                   /* Memory mapped region */
#endif
  int sectorSize;                     /* Device sector size */
  int deviceCharacteristics;          /* Precomputed device characteristics */
#if SQLITE_ENABLE_LOCKING_STYLE
  int openFlags;                      /* The flags specified at open() */
#endif
#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
  unsigned fsFlags;                   /* cached details from statfs() */
#endif
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
  unsigned iBusyTimeout;              /* Wait this many millisec on locks */
#endif
#if OS_VXWORKS
  struct vxworksFileId *pId;          /* Unique file ID */
#endif
#ifdef SQLITE_DEBUG
  /* The next group of variables are used to track whether or not the
  ** transaction counter in bytes 24-27 of database files are updated
  ** whenever any part of the database changes.  An assertion fault will
  ** occur if a file is updated without also updating the transaction
  ** counter.  This test is made to avoid new problems similar to the
  ** one described by ticket #3584. 
  */
  unsigned char transCntrChng;   /* True if the transaction counter changed */
  unsigned char dbUpdate;        /* True if any part of database file changed */
  unsigned char inNormalWrite;   /* True if in a normal write operation */

#endif

#ifdef SQLITE_TEST
  /* In test mode, increase the size of this structure a bit so that 
  ** it is larger than the struct CrashFile defined in test6.c.
  */
  char aPadding[32];
#endif
};

/* This variable holds the process id (pid) from when the xRandomness()
** method was called.  If xOpen() is called from a different process id,
** indicating that a fork() has occurred, the PRNG will be reset.
*/
static pid_t randomnessPid = 0;

/*
** Allowed values for the unixFile.ctrlFlags bitmask:
*/
#define UNIXFILE_EXCL        0x01     /* Connections from one process only */
#define UNIXFILE_RDONLY      0x02     /* Connection is read only */
#define UNIXFILE_PERSIST_WAL 0x04     /* Persistent WAL mode */
#ifndef SQLITE_DISABLE_DIRSYNC
# define UNIXFILE_DIRSYNC    0x08     /* Directory sync needed */
#else
# define UNIXFILE_DIRSYNC    0x00
#endif
#define UNIXFILE_PSOW        0x10     /* SQLITE_IOCAP_POWERSAFE_OVERWRITE */
#define UNIXFILE_DELETE      0x20     /* Delete on close */
#define UNIXFILE_URI         0x40     /* Filename might have query parameters */
#define UNIXFILE_NOLOCK      0x80     /* Do no file locking */

/*
** Include code that is common to all os_*.c files
*/
#include "os_common.h"

/*
** Define various macros that are missing from some systems.
*/
#ifndef O_LARGEFILE
# define O_LARGEFILE 0
#endif
#ifdef SQLITE_DISABLE_LFS
# undef O_LARGEFILE
# define O_LARGEFILE 0
#endif
#ifndef O_NOFOLLOW
# define O_NOFOLLOW 0
#endif
#ifndef O_BINARY
# define O_BINARY 0
#endif

/*
** The threadid macro resolves to the thread-id or to 0.  Used for
** testing and debugging only.
*/
#if SQLITE_THREADSAFE
#define threadid pthread_self()
#else
#define threadid 0
#endif

/*
** HAVE_MREMAP defaults to true on Linux and false everywhere else.
*/
#if !defined(HAVE_MREMAP)
# if defined(__linux__) && defined(_GNU_SOURCE)
#  define HAVE_MREMAP 1
# else
#  define HAVE_MREMAP 0
# endif
#endif

/*
** Explicitly call the 64-bit version of lseek() on Android. Otherwise, lseek()
** is the 32-bit version, even if _FILE_OFFSET_BITS=64 is defined.
*/
#ifdef __ANDROID__
# define lseek lseek64
#endif

#ifdef __linux__
/*
** Linux-specific IOCTL magic numbers used for controlling F2FS
*/
#define F2FS_IOCTL_MAGIC        0xf5
#define F2FS_IOC_START_ATOMIC_WRITE     _IO(F2FS_IOCTL_MAGIC, 1)
#define F2FS_IOC_COMMIT_ATOMIC_WRITE    _IO(F2FS_IOCTL_MAGIC, 2)
#define F2FS_IOC_START_VOLATILE_WRITE   _IO(F2FS_IOCTL_MAGIC, 3)
#define F2FS_IOC_ABORT_VOLATILE_WRITE   _IO(F2FS_IOCTL_MAGIC, 5)
#define F2FS_IOC_GET_FEATURES           _IOR(F2FS_IOCTL_MAGIC, 12, u32)
#define F2FS_FEATURE_ATOMIC_WRITE 0x0004
#endif /* __linux__ */


/*
** Different Unix systems declare open() in different ways.  Same use
** open(const char*,int,mode_t).  Others use open(const char*,int,...).
** The difference is important when using a pointer to the function.
**
** The safest way to deal with the problem is to always use this wrapper
** which always has the same well-defined interface.
*/
static int posixOpen(const char *zFile, int flags, int mode){
  return open(zFile, flags, mode);
}

/* Forward reference */
static int openDirectory(const char*, int*);
static int unixGetpagesize(void);

/*
** Many system calls are accessed through pointer-to-functions so that
** they may be overridden at runtime to facilitate fault injection during
** testing and sandboxing.  The following array holds the names and pointers
** to all overrideable system calls.
*/
static struct unix_syscall {
  const char *zName;            /* Name of the system call */
  sqlite3_syscall_ptr pCurrent; /* Current value of the system call */
  sqlite3_syscall_ptr pDefault; /* Default value */
} aSyscall[] = {
  { "open",         (sqlite3_syscall_ptr)posixOpen,  0  },
#define osOpen      ((int(*)(const char*,int,int))aSyscall[0].pCurrent)

  { "close",        (sqlite3_syscall_ptr)close,      0  },
#define osClose     ((int(*)(int))aSyscall[1].pCurrent)

  { "access",       (sqlite3_syscall_ptr)access,     0  },
#define osAccess    ((int(*)(const char*,int))aSyscall[2].pCurrent)

  { "getcwd",       (sqlite3_syscall_ptr)getcwd,     0  },
#define osGetcwd    ((char*(*)(char*,size_t))aSyscall[3].pCurrent)

  { "stat",         (sqlite3_syscall_ptr)stat,       0  },
#define osStat      ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)

/*
** The DJGPP compiler environment looks mostly like Unix, but it
** lacks the fcntl() system call.  So redefine fcntl() to be something
** that always succeeds.  This means that locking does not occur under
** DJGPP.  But it is DOS - what did you expect?
*/
#ifdef __DJGPP__
  { "fstat",        0,                 0  },
#define osFstat(a,b,c)    0
#else     
  { "fstat",        (sqlite3_syscall_ptr)fstat,      0  },
#define osFstat     ((int(*)(int,struct stat*))aSyscall[5].pCurrent)
#endif

  { "ftruncate",    (sqlite3_syscall_ptr)ftruncate,  0  },
#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent)

  { "fcntl",        (sqlite3_syscall_ptr)fcntl,      0  },
#define osFcntl     ((int(*)(int,int,...))aSyscall[7].pCurrent)

  { "read",         (sqlite3_syscall_ptr)read,       0  },
#define osRead      ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)

#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
  { "pread",        (sqlite3_syscall_ptr)pread,      0  },
#else
  { "pread",        (sqlite3_syscall_ptr)0,          0  },
#endif
#define osPread     ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)

#if defined(USE_PREAD64)
  { "pread64",      (sqlite3_syscall_ptr)pread64,    0  },
#else
  { "pread64",      (sqlite3_syscall_ptr)0,          0  },
#endif
#define osPread64 ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent)

  { "write",        (sqlite3_syscall_ptr)write,      0  },
#define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)

#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
  { "pwrite",       (sqlite3_syscall_ptr)pwrite,     0  },
#else
  { "pwrite",       (sqlite3_syscall_ptr)0,          0  },
#endif
#define osPwrite    ((ssize_t(*)(int,const void*,size_t,off_t))\
                    aSyscall[12].pCurrent)

#if defined(USE_PREAD64)
  { "pwrite64",     (sqlite3_syscall_ptr)pwrite64,   0  },
#else
  { "pwrite64",     (sqlite3_syscall_ptr)0,          0  },
#endif
#define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off64_t))\
                    aSyscall[13].pCurrent)

  { "fchmod",       (sqlite3_syscall_ptr)fchmod,          0  },
#define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent)

#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
  { "fallocate",    (sqlite3_syscall_ptr)posix_fallocate,  0 },
#else
  { "fallocate",    (sqlite3_syscall_ptr)0,                0 },
#endif
#define osFallocate ((int(*)(int,off_t,off_t))aSyscall[15].pCurrent)

  { "unlink",       (sqlite3_syscall_ptr)unlink,           0 },
#define osUnlink    ((int(*)(const char*))aSyscall[16].pCurrent)

  { "openDirectory",    (sqlite3_syscall_ptr)openDirectory,      0 },
#define osOpenDirectory ((int(*)(const char*,int*))aSyscall[17].pCurrent)

  { "mkdir",        (sqlite3_syscall_ptr)mkdir,           0 },
#define osMkdir     ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)

  { "rmdir",        (sqlite3_syscall_ptr)rmdir,           0 },
#define osRmdir     ((int(*)(const char*))aSyscall[19].pCurrent)

#if defined(HAVE_FCHOWN)
  { "fchown",       (sqlite3_syscall_ptr)fchown,          0 },
#else
  { "fchown",       (sqlite3_syscall_ptr)0,               0 },
#endif
#define osFchown    ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)

#if defined(HAVE_FCHOWN)
  { "geteuid",      (sqlite3_syscall_ptr)geteuid,         0 },
#else
  { "geteuid",      (sqlite3_syscall_ptr)0,               0 },
#endif
#define osGeteuid   ((uid_t(*)(void))aSyscall[21].pCurrent)

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
  { "mmap",         (sqlite3_syscall_ptr)mmap,            0 },
#else
  { "mmap",         (sqlite3_syscall_ptr)0,               0 },
#endif
#define osMmap ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
  { "munmap",       (sqlite3_syscall_ptr)munmap,          0 },
#else
  { "munmap",       (sqlite3_syscall_ptr)0,               0 },
#endif
#define osMunmap ((int(*)(void*,size_t))aSyscall[23].pCurrent)

#if HAVE_MREMAP && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
  { "mremap",       (sqlite3_syscall_ptr)mremap,          0 },
#else
  { "mremap",       (sqlite3_syscall_ptr)0,               0 },
#endif
#define osMremap ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
  { "getpagesize",  (sqlite3_syscall_ptr)unixGetpagesize, 0 },
#else
  { "getpagesize",  (sqlite3_syscall_ptr)0,               0 },
#endif
#define osGetpagesize ((int(*)(void))aSyscall[25].pCurrent)

#if defined(HAVE_READLINK)
  { "readlink",     (sqlite3_syscall_ptr)readlink,        0 },
#else
  { "readlink",     (sqlite3_syscall_ptr)0,               0 },
#endif
#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)

#if defined(HAVE_LSTAT)
  { "lstat",         (sqlite3_syscall_ptr)lstat,          0 },
#else
  { "lstat",         (sqlite3_syscall_ptr)0,              0 },
#endif
#define osLstat      ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)

#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
# ifdef __ANDROID__
  { "ioctl", (sqlite3_syscall_ptr)(int(*)(int, int, ...))ioctl, 0 },
#define osIoctl ((int(*)(int,int,...))aSyscall[28].pCurrent)
# else
  { "ioctl",         (sqlite3_syscall_ptr)ioctl,          0 },
#define osIoctl ((int(*)(int,unsigned long,...))aSyscall[28].pCurrent)
# endif
#else
  { "ioctl",         (sqlite3_syscall_ptr)0,              0 },
#endif

}; /* End of the overrideable system calls */


/*
** On some systems, calls to fchown() will trigger a message in a security
** log if they come from non-root processes.  So avoid calling fchown() if
** we are not running as root.
*/
static int robustFchown(int fd, uid_t uid, gid_t gid){
#if defined(HAVE_FCHOWN)
  return osGeteuid() ? 0 : osFchown(fd,uid,gid);
#else
  return 0;
#endif
}

/*
** This is the xSetSystemCall() method of sqlite3_vfs for all of the
** "unix" VFSes.  Return SQLITE_OK opon successfully updating the
** system call pointer, or SQLITE_NOTFOUND if there is no configurable
** system call named zName.
*/
static int unixSetSystemCall(
  sqlite3_vfs *pNotUsed,        /* The VFS pointer.  Not used */
  const char *zName,            /* Name of system call to override */
  sqlite3_syscall_ptr pNewFunc  /* Pointer to new system call value */
){
  unsigned int i;
  int rc = SQLITE_NOTFOUND;

  UNUSED_PARAMETER(pNotUsed);
  
// ABS Label 7
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ROR Label 8
if((zName != 0) != (zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
if( zName==0 ){
    /* If no zName is given, restore all system calls to their default
    ** settings and return NULL
    */
    rc = SQLITE_OK;
    i = 0;

// AOR Label 9
if(sizeof (aSyscall) - sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 9);
}
// AOR Label 10
if(sizeof (aSyscall) + sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 10);
}
// AOR Label 11
if(sizeof (aSyscall) * sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 11);
}

// ROR Label 12
if((i <= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
// ROR Label 13
if((i > sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if((i >= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
for(; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      
// ABS Label 21
if(aSyscall[i].pDefault < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
if( aSyscall[i].pDefault ){
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
    };
// AOR Label 15
if(sizeof (aSyscall) - sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 15);
}
// AOR Label 16
if(sizeof (aSyscall) + sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 16);
}
// AOR Label 17
if(sizeof (aSyscall) * sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 17);
}

// ROR Label 18
if((i <= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
// ROR Label 19
if((i > sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if((i >= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}

  }else{
    /* If zName is specified, operate on only the one system call
    ** specified.
    */
    i = 0;

// AOR Label 22
if(sizeof (aSyscall) - sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 22);
}
// AOR Label 23
if(sizeof (aSyscall) + sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 23);
}
// AOR Label 24
if(sizeof (aSyscall) * sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 24);
}

// ROR Label 25
if((i <= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
// ROR Label 26
if((i > sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
// ROR Label 27
if((i >= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
for(; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ){
        
// ABS Label 34
if(aSyscall[i].pDefault < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ROR Label 35
if((aSyscall[i].pDefault != 0) != (aSyscall[i].pDefault == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
if( aSyscall[i].pDefault==0 ){
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = SQLITE_OK;
        
// ABS Label 36
if(pNewFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ROR Label 37
if((pNewFunc != 0) != (pNewFunc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
if( pNewFunc==0 ) { pNewFunc = aSyscall[i].pDefault;
}
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
    };
// AOR Label 28
if(sizeof (aSyscall) - sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 28);
}
// AOR Label 29
if(sizeof (aSyscall) + sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 29);
}
// AOR Label 30
if(sizeof (aSyscall) * sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 30);
}

// ROR Label 31
if((i <= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((i > sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((i >= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}

  }
  
// ABS Label 38
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
return rc;
}

/*
** Return the value of a system call.  Return NULL if zName is not a
** recognized system call name.  NULL is also returned if the system call
** is currently undefined.
*/
static sqlite3_syscall_ptr unixGetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName
){
  unsigned int i;

  UNUSED_PARAMETER(pNotUsed);
  i = 0;

// AOR Label 39
if(sizeof (aSyscall) - sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 39);
}
// AOR Label 40
if(sizeof (aSyscall) + sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 40);
}
// AOR Label 41
if(sizeof (aSyscall) * sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 41);
}

// ROR Label 42
if((i <= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((i > sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((i >= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
for(; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
    if( strcmp(zName, aSyscall[i].zName)==0 ) { 
// ABS Label 51
if(aSyscall[i].pCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
return aSyscall[i].pCurrent;
}
  };
// AOR Label 45
if(sizeof (aSyscall) - sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 45);
}
// AOR Label 46
if(sizeof (aSyscall) + sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 46);
}
// AOR Label 47
if(sizeof (aSyscall) * sizeof (aSyscall[0]) != sizeof (aSyscall) / sizeof (aSyscall[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 47);
}

// ROR Label 48
if((i <= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
// ROR Label 49
if((i > sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
// ROR Label 50
if((i >= sizeof (aSyscall) / sizeof (aSyscall[0])) != (i < sizeof (aSyscall) / sizeof (aSyscall[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}

  return 0;
}

/*
** Return the name of the first system call after zName.  If zName==NULL
** then return the name of the first system call.  Return NULL if zName
** is the last system call or if zName is not the name of a valid
** system call.
*/
static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){
  int i = -1;

  UNUSED_PARAMETER(p);
  
// ABS Label 52
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
if( zName ){
    i = 0;

// ABS Label 53
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// AOR Label 54
if(((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) / 1 != ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 54);
}
// AOR Label 55
if(((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) + 1 != ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 55);
}
// AOR Label 56
if(((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) * 1 != ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 56);
}

// ROR Label 57
if((i <= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if((i > ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((i >= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
for(; i<ArraySize(aSyscall)-1; i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ) { break;
}
    };
// ABS Label 60
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}

// AOR Label 61
if(((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) / 1 != ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 61);
}
// AOR Label 62
if(((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) + 1 != ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 62);
}
// AOR Label 63
if(((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) * 1 != ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 63);
}

// ROR Label 64
if((i <= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((i > ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
// ROR Label 66
if((i >= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0]))) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}

  }
  i++;

// ABS Label 67
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}

// ROR Label 68
if((i <= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
// ROR Label 69
if((i > ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((i >= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
for(; i<ArraySize(aSyscall); i++){
    
// ABS Label 75
if(aSyscall[i].pCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ROR Label 76
if((aSyscall[i].pCurrent == 0) != (aSyscall[i].pCurrent != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
if( aSyscall[i].pCurrent!=0 ) { 
// ABS Label 77
if(aSyscall[i].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}
return aSyscall[i].zName;
}
  };
// ABS Label 71
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}

// ROR Label 72
if((i <= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}
// ROR Label 73
if((i > ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
// ROR Label 74
if((i >= ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))) != (i < ((int)(sizeof (aSyscall) / sizeof (aSyscall[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}

  return 0;
}

/*
** Do not accept any file descriptor less than this value, in order to avoid
** opening database file using file descriptors that are commonly used for 
** standard input, output, and error.
*/
#ifndef SQLITE_MINIMUM_FILE_DESCRIPTOR
# define SQLITE_MINIMUM_FILE_DESCRIPTOR 3
#endif

/*
** Invoke open().  Do so multiple times, until it either succeeds or
** fails for some reason other than EINTR.
**
** If the file creation mode "m" is 0 then set it to the default for
** SQLite.  The default is SQLITE_DEFAULT_FILE_PERMISSIONS (normally
** 0644) as modified by the system umask.  If m is not 0, then
** make the file creation mode be exactly m ignoring the umask.
**
** The m parameter will be non-zero only when creating -wal, -journal,
** and -shm files.  We want those files to have *exactly* the same
** permissions as their original database, unadulterated by the umask.
** In that way, if a database file is -rw-rw-rw or -rw-rw-r-, and a
** transaction crashes and leaves behind hot journals, then any
** process that is able to write to the database will also be able to
** recover the hot journals.
*/
static int robust_open(const char *z, int f, mode_t m){
  int fd;
  mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;
  while(1){
#if defined(O_CLOEXEC)
    fd = osOpen(z,f|O_CLOEXEC,m2);
#else
    fd = osOpen(z,f,m2);
#endif
    
// ABS Label 81
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ROR Label 82
if((fd <= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
// ROR Label 83
if((fd > 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
// ROR Label 84
if((fd >= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 84);
}
if( fd<0 ){
      
// ABS Label 85
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}

// ROR Label 86
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
if( errno==EINTR ) { continue;
}
      break;
    }
    
// ABS Label 87
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// ROR Label 88
if((fd < 3) != (fd >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 88);
}
// ROR Label 89
if((fd > 3) != (fd >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 89);
}
// ROR Label 90
if((fd <= 3) != (fd >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( fd>=SQLITE_MINIMUM_FILE_DESCRIPTOR ) { break;
}
    osClose(fd);
    
// ABS Label 79
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ABS Label 80
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}
sqlite3_log(SQLITE_WARNING, 
                "attempt to open \"%s\" as file descriptor %d", z, fd);
    fd = -1;
    if( osOpen("/dev/null", O_RDONLY, m)<0 ) { break;
}
  };
  
// ABS Label 91
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}

// ROR Label 92
if((fd < 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((fd > 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
// ROR Label 94
if((fd <= 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 94);
}
if( fd>=0 ){
    
// ABS Label 95
if(m < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}

// ROR Label 96
if((m == 0) != (m != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
if( m!=0 ){
      struct stat statbuf;
      if( osFstat(fd, &statbuf)==0 
       && statbuf.st_size==0
       && (statbuf.st_mode&0777)!=m 
      ){
        osFchmod(fd, m);
      }
    }
#if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)
    osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);
#endif
  }
  
// ABS Label 99
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
return fd;
}

/*
** Helper functions to obtain and relinquish the global mutex. The
** global mutex is used to protect the unixInodeInfo and
** vxworksFileId objects used by this file, all of which may be 
** shared by multiple threads.
**
** Function unixMutexHeld() is used to assert() that the global mutex 
** is held when required. This function is only used as part of assert() 
** statements. e.g.
**
**   unixEnterMutex()
**     assert( unixMutexHeld() );
**   unixEnterLeave()
**
** To prevent deadlock, the global unixBigLock must must be acquired
** before the unixInodeInfo.pLockMutex mutex, if both are held.  It is
** OK to get the pLockMutex without holding unixBigLock first, but if
** that happens, the unixBigLock mutex must not be acquired until after
** pLockMutex is released.
**
**      OK:     enter(unixBigLock),  enter(pLockInfo)
**      OK:     enter(unixBigLock)
**      OK:     enter(pLockInfo)
**   ERROR:     enter(pLockInfo), enter(unixBigLock)
*/
static sqlite3_mutex *unixBigLock = 0;
static void unixEnterMutex(void){
  assert( sqlite3_mutex_notheld(unixBigLock) );  /* Not a recursive mutex */
  
// ABS Label 100
if(unixBigLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
sqlite3_mutex_enter(unixBigLock);
}
static void unixLeaveMutex(void){
  assert( sqlite3_mutex_held(unixBigLock) );
  
// ABS Label 101
if(unixBigLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
sqlite3_mutex_leave(unixBigLock);
}
#ifdef SQLITE_DEBUG
static int unixMutexHeld(void) {
  return sqlite3_mutex_held(unixBigLock);
}
#endif


#ifdef SQLITE_HAVE_OS_TRACE
/*
** Helper function for printing out trace information from debugging
** binaries. This returns the string representation of the supplied
** integer lock-type.
*/
static const char *azFileLock(int eFileLock){
  switch( eFileLock ){
    case NO_LOCK: return "NONE";
    case SHARED_LOCK: return "SHARED";
    case RESERVED_LOCK: return "RESERVED";
    case PENDING_LOCK: return "PENDING";
    case EXCLUSIVE_LOCK: return "EXCLUSIVE";
  }
  return "ERROR";
}
#endif

#ifdef SQLITE_LOCK_TRACE
/*
** Print out information about all locking operations.
**
** This routine is used for troubleshooting locks on multithreaded
** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACE
** command-line option on the compiler.  This code is normally
** turned off.
*/
static int lockTrace(int fd, int op, struct flock *p){
  char *zOpName, *zType;
  int s;
  int savedErrno;
  if( op==F_GETLK ){
    zOpName = "GETLK";
  }else if( op==F_SETLK ){
    zOpName = "SETLK";
  }else{
    s = osFcntl(fd, op, p);
    sqlite3DebugPrintf("fcntl unknown %d %d %d\n", fd, op, s);
    return s;
  }
  if( p->l_type==F_RDLCK ){
    zType = "RDLCK";
  }else if( p->l_type==F_WRLCK ){
    zType = "WRLCK";
  }else if( p->l_type==F_UNLCK ){
    zType = "UNLCK";
  }else{
    assert( 0 );
  }
  assert( p->l_whence==SEEK_SET );
  s = osFcntl(fd, op, p);
  savedErrno = errno;
  sqlite3DebugPrintf("fcntl %d %d %s %s %d %d %d %d\n",
     threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,
     (int)p->l_pid, s);
  if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){
    struct flock l2;
    l2 = *p;
    osFcntl(fd, F_GETLK, &l2);
    if( l2.l_type==F_RDLCK ){
      zType = "RDLCK";
    }else if( l2.l_type==F_WRLCK ){
      zType = "WRLCK";
    }else if( l2.l_type==F_UNLCK ){
      zType = "UNLCK";
    }else{
      assert( 0 );
    }
    sqlite3DebugPrintf("fcntl-failure-reason: %s %d %d %d\n",
       zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);
  }
  errno = savedErrno;
  return s;
}
#undef osFcntl
#define osFcntl lockTrace
#endif /* SQLITE_LOCK_TRACE */

/*
** Retry ftruncate() calls that fail due to EINTR
**
** All calls to ftruncate() within this file should be made through
** this wrapper.  On the Android platform, bypassing the logic below
** could lead to a corrupt database.
*/
static int robust_ftruncate(int h, sqlite3_int64 sz){
  int rc;
#ifdef __ANDROID__
  /* On Android, ftruncate() always uses 32-bit offsets, even if 
  ** _FILE_OFFSET_BITS=64 is defined. This means it is unsafe to attempt to
  ** truncate a file to any size larger than 2GiB. Silently ignore any
  ** such attempts.  */
  if( sz>(sqlite3_int64)0x7FFFFFFF ){
    rc = SQLITE_OK;
  }else
#endif
  
// ABS Label 102
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
// ABS Label 103
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}

// COR Label 104
if((rc < 0 || (*__errno_location()) == 4) != (rc < 0 && (*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 104);
}

// ROR Label 105
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
// ROR Label 106
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
// ROR Label 107
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
// ROR Label 108
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 108);
}

// MCC Label 109
if(rc < 0 && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 109);
}
// MCC Label 110
if(rc < 0 && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(!(rc < 0) && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
// MCC Label 112
if(!(rc < 0) && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );
// ABS Label 113
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
// ABS Label 114
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// COR Label 115
if((rc < 0 || (*__errno_location()) == 4) != (rc < 0 && (*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 115);
}

// ROR Label 116
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
// ROR Label 117
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
// ROR Label 118
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
// ROR Label 119
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}

// MCC Label 120
if(rc < 0 && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 120);
}
// MCC Label 121
if(rc < 0 && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 121);
}
// MCC Label 122
if(!(rc < 0) && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(!(rc < 0) && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
;
  
// ABS Label 124
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}
return rc;
}

/*
** This routine translates a standard POSIX errno code into something
** useful to the clients of the sqlite3 functions.  Specifically, it is
** intended to translate a variety of "try again" errors into SQLITE_BUSY
** and a variety of "please close the file descriptor NOW" errors into 
** SQLITE_IOERR
** 
** Errors during initialization of locks, or file system support for locks,
** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.
*/
static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {
  assert( (sqliteIOErr == SQLITE_IOERR_LOCK) || 
          (sqliteIOErr == SQLITE_IOERR_UNLOCK) || 
          (sqliteIOErr == SQLITE_IOERR_RDLOCK) ||
          (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) );
  switch (posixError) {
  case EACCES: 
  case EAGAIN:
  case ETIMEDOUT:
  case EBUSY:
  case EINTR:
  case ENOLCK:  
    /* random NFS retry error, unless during file system support 
     * introspection, in which it actually means what it says */
    return SQLITE_BUSY;
    
  case EPERM: 
    return SQLITE_PERM;
    
  default: 
    
// ABS Label 125
if(sqliteIOErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
return sqliteIOErr;
  }
}


/******************************************************************************
****************** Begin Unique File ID Utility Used By VxWorks ***************
**
** On most versions of unix, we can get a unique ID for a file by concatenating
** the device number and the inode number.  But this does not work on VxWorks.
** On VxWorks, a unique file id must be based on the canonical filename.
**
** A pointer to an instance of the following structure can be used as a
** unique file ID in VxWorks.  Each instance of this structure contains
** a copy of the canonical filename.  There is also a reference count.  
** The structure is reclaimed when the number of pointers to it drops to
** zero.
**
** There are never very many files open at one time and lookups are not
** a performance-critical path, so it is sufficient to put these
** structures on a linked list.
*/
struct vxworksFileId {
  struct vxworksFileId *pNext;  /* Next in a list of them all */
  int nRef;                     /* Number of references to this one */
  int nName;                    /* Length of the zCanonicalName[] string */
  char *zCanonicalName;         /* Canonical filename */
};

#if OS_VXWORKS
/* 
** All unique filenames are held on a linked list headed by this
** variable:
*/
static struct vxworksFileId *vxworksFileList = 0;

/*
** Simplify a filename into its canonical form
** by making the following changes:
**
**  * removing any trailing and duplicate /
**  * convert /./ into just /
**  * convert /A/../ where A is any simple name into just /
**
** Changes are made in-place.  Return the new name length.
**
** The original filename is in z[0..n-1].  Return the number of
** characters in the simplified name.
*/
static int vxworksSimplifyName(char *z, int n){
  int i, j;
  while( n>1 && z[n-1]=='/' ){ n--; }
  for(i=j=0; i<n; i++){
    if( z[i]=='/' ){
      if( z[i+1]=='/' ) continue;
      if( z[i+1]=='.' && i+2<n && z[i+2]=='/' ){
        i += 1;
        continue;
      }
      if( z[i+1]=='.' && i+3<n && z[i+2]=='.' && z[i+3]=='/' ){
        while( j>0 && z[j-1]!='/' ){ j--; }
        if( j>0 ){ j--; }
        i += 2;
        continue;
      }
    }
    z[j++] = z[i];
  }
  z[j] = 0;
  return j;
}

/*
** Find a unique file ID for the given absolute pathname.  Return
** a pointer to the vxworksFileId object.  This pointer is the unique
** file ID.
**
** The nRef field of the vxworksFileId object is incremented before
** the object is returned.  A new vxworksFileId object is created
** and added to the global list if necessary.
**
** If a memory allocation error occurs, return NULL.
*/
static struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){
  struct vxworksFileId *pNew;         /* search key and new file ID */
  struct vxworksFileId *pCandidate;   /* For looping over existing file IDs */
  int n;                              /* Length of zAbsoluteName string */

  assert( zAbsoluteName[0]=='/' );
  n = (int)strlen(zAbsoluteName);
  pNew = sqlite3_malloc64( sizeof(*pNew) + (n+1) );
  if( pNew==0 ) return 0;
  pNew->zCanonicalName = (char*)&pNew[1];
  memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);
  n = vxworksSimplifyName(pNew->zCanonicalName, n);

  /* Search for an existing entry that matching the canonical name.
  ** If found, increment the reference count and return a pointer to
  ** the existing file ID.
  */
  unixEnterMutex();
  for(pCandidate=vxworksFileList; pCandidate; pCandidate=pCandidate->pNext){
    if( pCandidate->nName==n 
     && memcmp(pCandidate->zCanonicalName, pNew->zCanonicalName, n)==0
    ){
       sqlite3_free(pNew);
       pCandidate->nRef++;
       unixLeaveMutex();
       return pCandidate;
    }
  }

  /* No match was found.  We will make a new file ID */
  pNew->nRef = 1;
  pNew->nName = n;
  pNew->pNext = vxworksFileList;
  vxworksFileList = pNew;
  unixLeaveMutex();
  return pNew;
}

/*
** Decrement the reference count on a vxworksFileId object.  Free
** the object when the reference count reaches zero.
*/
static void vxworksReleaseFileId(struct vxworksFileId *pId){
  unixEnterMutex();
  assert( pId->nRef>0 );
  pId->nRef--;
  if( pId->nRef==0 ){
    struct vxworksFileId **pp;
    for(pp=&vxworksFileList; *pp && *pp!=pId; pp = &((*pp)->pNext)){}
    assert( *pp==pId );
    *pp = pId->pNext;
    sqlite3_free(pId);
  }
  unixLeaveMutex();
}
#endif /* OS_VXWORKS */
/*************** End of Unique File ID Utility Used By VxWorks ****************
******************************************************************************/


/******************************************************************************
*************************** Posix Advisory Locking ****************************
**
** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)
** section 6.5.2.2 lines 483 through 490 specify that when a process
** sets or clears a lock, that operation overrides any prior locks set
** by the same process.  It does not explicitly say so, but this implies
** that it overrides locks set by the same process using a different
** file descriptor.  Consider this test case:
**
**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);
**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);
**
** Suppose ./file1 and ./file2 are really the same file (because
** one is a hard or symbolic link to the other) then if you set
** an exclusive lock on fd1, then try to get an exclusive lock
** on fd2, it works.  I would have expected the second lock to
** fail since there was already a lock on the file due to fd1.
** But not so.  Since both locks came from the same process, the
** second overrides the first, even though they were on different
** file descriptors opened on different file names.
**
** This means that we cannot use POSIX locks to synchronize file access
** among competing threads of the same process.  POSIX locks will work fine
** to synchronize access for threads in separate processes, but not
** threads within the same process.
**
** To work around the problem, SQLite has to manage file locks internally
** on its own.  Whenever a new database is opened, we have to find the
** specific inode of the database file (the inode is determined by the
** st_dev and st_ino fields of the stat structure that fstat() fills in)
** and check for locks already existing on that inode.  When locks are
** created or removed, we have to look at our own internal record of the
** locks to see if another thread has previously set a lock on that same
** inode.
**
** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.
** For VxWorks, we have to use the alternative unique ID system based on
** canonical filename and implemented in the previous division.)
**
** The sqlite3_file structure for POSIX is no longer just an integer file
** descriptor.  It is now a structure that holds the integer file
** descriptor and a pointer to a structure that describes the internal
** locks on the corresponding inode.  There is one locking structure
** per inode, so if the same inode is opened twice, both unixFile structures
** point to the same locking structure.  The locking structure keeps
** a reference count (so we will know when to delete it) and a "cnt"
** field that tells us its internal lock status.  cnt==0 means the
** file is unlocked.  cnt==-1 means the file has an exclusive lock.
** cnt>0 means there are cnt shared locks on the file.
**
** Any attempt to lock or unlock a file first checks the locking
** structure.  The fcntl() system call is only invoked to set a 
** POSIX lock if the internal lock structure transitions between
** a locked and an unlocked state.
**
** But wait:  there are yet more problems with POSIX advisory locks.
**
** If you close a file descriptor that points to a file that has locks,
** all locks on that file that are owned by the current process are
** released.  To work around this problem, each unixInodeInfo object
** maintains a count of the number of pending locks on tha inode.
** When an attempt is made to close an unixFile, if there are
** other unixFile open on the same inode that are holding locks, the call
** to close() the file descriptor is deferred until all of the locks clear.
** The unixInodeInfo structure keeps a list of file descriptors that need to
** be closed and that list is walked (and cleared) when the last lock
** clears.
**
** Yet another problem:  LinuxThreads do not play well with posix locks.
**
** Many older versions of linux use the LinuxThreads library which is
** not posix compliant.  Under LinuxThreads, a lock created by thread
** A cannot be modified or overridden by a different thread B.
** Only thread A can modify the lock.  Locking behavior is correct
** if the appliation uses the newer Native Posix Thread Library (NPTL)
** on linux - with NPTL a lock created by thread A can override locks
** in thread B.  But there is no way to know at compile-time which
** threading library is being used.  So there is no way to know at
** compile-time whether or not thread A can override locks on thread B.
** One has to do a run-time check to discover the behavior of the
** current process.
**
** SQLite used to support LinuxThreads.  But support for LinuxThreads
** was dropped beginning with version 3.7.0.  SQLite will still work with
** LinuxThreads provided that (1) there is no more than one connection 
** per database file in the same process and (2) database connections
** do not move across threads.
*/

/*
** An instance of the following structure serves as the key used
** to locate a particular unixInodeInfo object.
*/
struct unixFileId {
  dev_t dev;                  /* Device number */
#if OS_VXWORKS
  struct vxworksFileId *pId;  /* Unique file ID for vxworks. */
#else
  /* We are told that some versions of Android contain a bug that
  ** sizes ino_t at only 32-bits instead of 64-bits. (See
  ** https://android-review.googlesource.com/#/c/115351/3/dist/sqlite3.c)
  ** To work around this, always allocate 64-bits for the inode number.  
  ** On small machines that only have 32-bit inodes, this wastes 4 bytes,
  ** but that should not be a big deal. */
  /* WAS:  ino_t ino;   */
  u64 ino;                   /* Inode number */
#endif
};

/*
** An instance of the following structure is allocated for each open
** inode.
**
** A single inode can have multiple file descriptors, so each unixFile
** structure contains a pointer to an instance of this object and this
** object keeps a count of the number of unixFile pointing to it.
**
** Mutex rules:
**
**  (1) Only the pLockMutex mutex must be held in order to read or write
**      any of the locking fields:
**          nShared, nLock, eFileLock, bProcessLock, pUnused
**
**  (2) When nRef>0, then the following fields are unchanging and can
**      be read (but not written) without holding any mutex:
**          fileId, pLockMutex
**
**  (3) With the exceptions above, all the fields may only be read
**      or written while holding the global unixBigLock mutex.
**
** Deadlock prevention:  The global unixBigLock mutex may not
** be acquired while holding the pLockMutex mutex.  If both unixBigLock
** and pLockMutex are needed, then unixBigLock must be acquired first.
*/
struct unixInodeInfo {
  struct unixFileId fileId;       /* The lookup key */
  sqlite3_mutex *pLockMutex;      /* Hold this mutex for... */
  int nShared;                      /* Number of SHARED locks held */
  int nLock;                        /* Number of outstanding file locks */
  unsigned char eFileLock;          /* One of SHARED_LOCK, RESERVED_LOCK etc. */
  unsigned char bProcessLock;       /* An exclusive process lock is held */
  UnixUnusedFd *pUnused;            /* Unused file descriptors to close */
  int nRef;                       /* Number of pointers to this structure */
  unixShmNode *pShmNode;          /* Shared memory associated with this inode */
  unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */
  unixInodeInfo *pPrev;           /*    .... doubly linked */
#if SQLITE_ENABLE_LOCKING_STYLE
  unsigned long long sharedByte;  /* for AFP simulated shared lock */
#endif
#if OS_VXWORKS
  sem_t *pSem;                    /* Named POSIX semaphore */
  char aSemName[MAX_PATHNAME+2];  /* Name of that semaphore */
#endif
};

/*
** A lists of all unixInodeInfo objects.
**
** Must hold unixBigLock in order to read or write this variable.
*/
static unixInodeInfo *inodeList = 0;  /* All unixInodeInfo objects */

#ifdef SQLITE_DEBUG
/*
** True if the inode mutex (on the unixFile.pFileMutex field) is held, or not.
** This routine is used only within assert() to help verify correct mutex
** usage.
*/
int unixFileMutexHeld(unixFile *pFile){
  assert( pFile->pInode );
  return sqlite3_mutex_held(pFile->pInode->pLockMutex);
}
int unixFileMutexNotheld(unixFile *pFile){
  assert( pFile->pInode );
  return sqlite3_mutex_notheld(pFile->pInode->pLockMutex);
}
#endif

/*
**
** This function - unixLogErrorAtLine(), is only ever called via the macro
** unixLogError().
**
** It is invoked after an error occurs in an OS function and errno has been
** set. It logs a message using sqlite3_log() containing the current value of
** errno and, if possible, the human-readable equivalent from strerror() or
** strerror_r().
**
** The first argument passed to the macro should be the error code that
** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN). 
** The two subsequent arguments should be the name of the OS function that
** failed (e.g. "unlink", "open") and the associated file-system path,
** if any.
*/
#define unixLogError(a,b,c)     unixLogErrorAtLine(a,b,c,__LINE__)
static int unixLogErrorAtLine(
  int errcode,                    /* SQLite error code */
  const char *zFunc,              /* Name of OS function that failed */
  const char *zPath,              /* File path associated with error */
  int iLine                       /* Source line number where error occurred */
){
  char *zErr;                     /* Message from strerror() or equivalent */
  
// ABS Label 126
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}
int iErrno = errno;             /* Saved syscall error number */

  /* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then use
  ** the strerror() function to obtain the human-readable error message
  ** equivalent to errno. Otherwise, use strerror_r().
  */ 
#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)
  char aErr[80];
  memset(aErr, 0, sizeof(aErr));
  zErr = aErr;

  /* If STRERROR_R_CHAR_P (set by autoconf scripts) or __USE_GNU is defined,
  ** assume that the system provides the GNU version of strerror_r() that
  ** returns a pointer to a buffer containing the error message. That pointer 
  ** may point to aErr[], or it may point to some static storage somewhere. 
  ** Otherwise, assume that the system provides the POSIX version of 
  ** strerror_r(), which always writes an error message into aErr[].
  **
  ** If the code incorrectly assumes that it is the POSIX version that is
  ** available, the error message will often be an empty string. Not a
  ** huge problem. Incorrectly concluding that the GNU version is available 
  ** could lead to a segfault though.
  */
#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)
  zErr = 
# endif
  strerror_r(iErrno, aErr, sizeof(aErr)-1);

#elif SQLITE_THREADSAFE
  /* This is a threadsafe build, but strerror_r() is not available. */
  zErr = "";
#else
  /* Non-threadsafe build, use strerror(). */
  zErr = strerror(iErrno);
#endif

  
// ABS Label 133
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}

// ROR Label 134
if((zPath != 0) != (zPath == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}
if( zPath==0 ) { zPath = "";
}
  
// ABS Label 127
if(errcode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}

// ABS Label 128
if(iLine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}

// ABS Label 129
if(iErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}

// ABS Label 130
if(zFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}

// ABS Label 131
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}

// ABS Label 132
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}
sqlite3_log(errcode,
      "os_unix.c:%d: (%d) %s(%s) - %s",
      iLine, iErrno, zFunc, zPath, zErr
  );

  
// ABS Label 135
if(errcode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}
return errcode;
}

/*
** Close a file descriptor.
**
** We assume that close() almost always works, since it is only in a
** very sick application or on a very sick platform that it might fail.
** If it does fail, simply leak the file descriptor, but do log the
** error.
**
** Note that it is not safe to retry close() after EINTR since the
** file descriptor might have already been reused by another thread.
** So we don't even try to recover from an EINTR.  Just log the error
** and move on.
*/
static void robust_close(unixFile *pFile, int h, int lineno){
  if( osClose(h) ){
    
// ABS Label 136
if(lineno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",
                       pFile ? pFile->zPath : 0, lineno);
  }
}

/*
** Set the pFile->lastErrno.  Do this in a subroutine as that provides
** a convenient place to set a breakpoint.
*/
static void storeLastErrno(unixFile *pFile, int error){
  pFile->lastErrno = error;
}

/*
** Close all file descriptors accumuated in the unixInodeInfo->pUnused list.
*/ 
static void closePendingFds(unixFile *pFile){
  
// ABS Label 137
if(pFile->pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p;
  UnixUnusedFd *pNext;
  assert( unixFileMutexHeld(pFile) );
  p = pInode->pUnused;

// ABS Label 138
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}
for(; p; p=pNext){
    pNext = p->pNext;
    
// ABS Label 140
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ABS Label 141
if(p->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
robust_close(pFile, p->fd, __LINE__);
    sqlite3_free(p);
  };
// ABS Label 139
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}

  pInode->pUnused = 0;
}

/*
** Release a unixInodeInfo structure previously allocated by findInodeInfo().
**
** The global mutex must be held when this routine is called, but the mutex
** on the inode being deleted must NOT be held.
*/
static void releaseInodeInfo(unixFile *pFile){
  
// ABS Label 142
if(pFile->pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
unixInodeInfo *pInode = pFile->pInode;
  assert( unixMutexHeld() );
  assert( unixFileMutexNotheld(pFile) );
  
// ABS Label 143
if((pInode) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
if( ALWAYS(pInode) ){
    pInode->nRef--;
    
// ABS Label 144
if(pInode->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}

// ROR Label 145
if((pInode->nRef != 0) != (pInode->nRef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
if( pInode->nRef==0 ){
      assert( pInode->pShmNode==0 );
      
// ABS Label 146
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
sqlite3_mutex_enter(pInode->pLockMutex);
      
// ABS Label 147
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
closePendingFds(pFile);
      
// ABS Label 148
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
sqlite3_mutex_leave(pInode->pLockMutex);
      
// ABS Label 150
if(pInode->pPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
if( pInode->pPrev ){
        assert( pInode->pPrev->pNext==pInode );
        pInode->pPrev->pNext = pInode->pNext;
      }else{
        assert( inodeList==pInode );
        inodeList = pInode->pNext;
      }
      
// ABS Label 151
if(pInode->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}
if( pInode->pNext ){
        assert( pInode->pNext->pPrev==pInode );
        pInode->pNext->pPrev = pInode->pPrev;
      }
      
// ABS Label 149
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3_mutex_free(pInode->pLockMutex);
      sqlite3_free(pInode);
    }
  }
}

/*
** Given a file descriptor, locate the unixInodeInfo object that
** describes that file descriptor.  Create a new one if necessary.  The
** return value might be uninitialized if an error occurs.
**
** The global mutex must held when calling this routine.
**
** Return an appropriate error code.
*/
static int findInodeInfo(
  unixFile *pFile,               /* Unix file with file desc used in the key */
  unixInodeInfo **ppInode        /* Return the unixInodeInfo object here */
){
  int rc;                        /* System call return code */
  int fd;                        /* The file descriptor for pFile */
  struct unixFileId fileId;      /* Lookup key for the unixInodeInfo */
  struct stat statbuf;           /* Low-level file information */
  unixInodeInfo *pInode = 0;     /* Candidate unixInodeInfo object */

  assert( unixMutexHeld() );

  /* Get low-level information about the file that we can used to
  ** create a unique name for the file.
  */
  fd = pFile->h;
  rc = osFstat(fd, &statbuf);
  
// ABS Label 152
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// ROR Label 153
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 153);
}
if( rc!=0 ){
    
// ABS Label 154
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}

// ABS Label 155
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}
storeLastErrno(pFile, errno);
#if defined(EOVERFLOW) && defined(SQLITE_DISABLE_LFS)
    if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;
#endif
    return SQLITE_IOERR;
  }

#ifdef __APPLE__
  /* On OS X on an msdos filesystem, the inode number is reported
  ** incorrectly for zero-size files.  See ticket #3260.  To work
  ** around this problem (we consider it a bug in OS X, not SQLite)
  ** we always increase the file size to 1 by writing a single byte
  ** prior to accessing the inode number.  The one byte written is
  ** an ASCII 'S' character which also happens to be the first byte
  ** in the header of every SQLite database.  In this way, if there
  ** is a race condition such that another thread has already populated
  ** the first page of the database, no damage is done.
  */
  if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){
    do{ rc = osWrite(fd, "S", 1); }while( rc<0 && errno==EINTR );
    if( rc!=1 ){
      storeLastErrno(pFile, errno);
      return SQLITE_IOERR;
    }
    rc = osFstat(fd, &statbuf);
    if( rc!=0 ){
      storeLastErrno(pFile, errno);
      return SQLITE_IOERR;
    }
  }
#endif

  memset(&fileId, 0, sizeof(fileId));
  fileId.dev = statbuf.st_dev;
#if OS_VXWORKS
  fileId.pId = pFile->pId;
#else
  fileId.ino = (u64)statbuf.st_ino;
#endif
  assert( unixMutexHeld() );
  pInode = inodeList;
  
// ABS Label 156
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}

// MCC Label 157
if(pInode && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
// MCC Label 158
if(!(pInode) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){
    pInode = pInode->pNext;
  };
// ABS Label 159
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}

// MCC Label 160
if(pInode && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 160);
}
// MCC Label 161
if(!(pInode) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 161);
}

  
// ABS Label 162
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}

// ROR Label 163
if((pInode != 0) != (pInode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
if( pInode==0 ){
    pInode = sqlite3_malloc64( sizeof(*pInode) );
    
// ABS Label 164
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}

// ROR Label 165
if((pInode != 0) != (pInode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
if( pInode==0 ){
      return SQLITE_NOMEM_BKPT;
    }
    memset(pInode, 0, sizeof(*pInode));
    memcpy(&pInode->fileId, &fileId, sizeof(fileId));
    
// ABS Label 166
if(sqlite3Config.bCoreMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}
if( sqlite3GlobalConfig.bCoreMutex ){
      pInode->pLockMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
      
// ABS Label 167
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}

// ROR Label 168
if((pInode->pLockMutex != 0) != (pInode->pLockMutex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
if( pInode->pLockMutex==0 ){
        sqlite3_free(pInode);
        return SQLITE_NOMEM_BKPT;
      }
    }
    pInode->nRef = 1;
    assert( unixMutexHeld() );
    pInode->pNext = inodeList;
    pInode->pPrev = 0;
    
// ABS Label 169
if(inodeList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
if( inodeList ) { inodeList->pPrev = pInode;
}
    inodeList = pInode;
  }else{
    pInode->nRef++;
  }
  *ppInode = pInode;
  return SQLITE_OK;
}

/*
** Return TRUE if pFile has been renamed or unlinked since it was first opened.
*/
static int fileHasMoved(unixFile *pFile){
#if OS_VXWORKS
  return pFile->pInode!=0 && pFile->pId!=pFile->pInode->fileId.pId;
#else
  struct stat buf;
  return pFile->pInode!=0 &&
      (osStat(pFile->zPath, &buf)!=0 
         || (u64)buf.st_ino!=pFile->pInode->fileId.ino);
#endif
}


/*
** Check a unixFile that is a database.  Verify the following:
**
** (1) There is exactly one hard link on the file
** (2) The file is not a symbolic link
** (3) The file has not been renamed or unlinked
**
** Issue sqlite3_log(SQLITE_WARNING,...) messages if anything is not right.
*/
static void verifyDbFile(unixFile *pFile){
  struct stat buf;
  int rc;

  /* These verifications occurs for the main database only */
  
// AOR Label 170
if(pFile->ctrlFlags | 128 != pFile->ctrlFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 170);
}
// AOR Label 171
if(pFile->ctrlFlags ^ 128 != pFile->ctrlFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 171);
}
if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) { return;
}

  rc = osFstat(pFile->h, &buf);
  
// ABS Label 172
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}

// ROR Label 173
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
if( rc!=0 ){
    
// ABS Label 174
if(pFile->zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}
sqlite3_log(SQLITE_WARNING, "cannot fstat db file %s", pFile->zPath);
    return;
  }
  
// ABS Label 175
if(buf.st_nlink < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}

// ROR Label 176
if((buf.st_nlink != 0) != (buf.st_nlink == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
if( buf.st_nlink==0 ){
    
// ABS Label 177
if(pFile->zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}
sqlite3_log(SQLITE_WARNING, "file unlinked while open: %s", pFile->zPath);
    return;
  }
  
// ABS Label 178
if(buf.st_nlink < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}

// ROR Label 179
if((buf.st_nlink <= 1) != (buf.st_nlink > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}
// ROR Label 180
if((buf.st_nlink < 1) != (buf.st_nlink > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 180);
}
// ROR Label 181
if((buf.st_nlink >= 1) != (buf.st_nlink > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 181);
}
if( buf.st_nlink>1 ){
    
// ABS Label 182
if(pFile->zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
sqlite3_log(SQLITE_WARNING, "multiple links to file: %s", pFile->zPath);
    return;
  }
  if( fileHasMoved(pFile) ){
    
// ABS Label 183
if(pFile->zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
sqlite3_log(SQLITE_WARNING, "file renamed while open: %s", pFile->zPath);
    return;
  }
}


/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/
static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = SQLITE_OK;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );

  assert( pFile );
  assert( pFile->eFileLock<=SHARED_LOCK );
  
// ABS Label 184
if(pFile->pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}
sqlite3_mutex_enter(pFile->pInode->pLockMutex);

  /* Check if a thread in this process holds such a lock */
  
// ROR Label 186
if((pFile->pInode->eFileLock <= 1) != (pFile->pInode->eFileLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 186);
}
// ROR Label 187
if((pFile->pInode->eFileLock < 1) != (pFile->pInode->eFileLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
// ROR Label 188
if((pFile->pInode->eFileLock >= 1) != (pFile->pInode->eFileLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
if( pFile->pInode->eFileLock>SHARED_LOCK ){
    reserved = 1;
  }

  /* Otherwise see if some other process holds it.
  */
#ifndef __DJGPP__
  
// COR Label 189
if((!reserved || !pFile->pInode->bProcessLock) != (!reserved && !pFile->pInode->bProcessLock))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 189);
}

// MCC Label 190
if(!reserved && !pFile->pInode->bProcessLock ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 190);
}
// MCC Label 191
if(!reserved && !(!pFile->pInode->bProcessLock) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 191);
}
// MCC Label 192
if(!(!reserved) && !pFile->pInode->bProcessLock ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 192);
}
// MCC Label 193
if(!(!reserved) && !(!pFile->pInode->bProcessLock) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 193);
}
if( !reserved && !pFile->pInode->bProcessLock ){
    struct flock lock;
    lock.l_whence = SEEK_SET;
    lock.l_start = RESERVED_BYTE;
    lock.l_len = 1;
    lock.l_type = F_WRLCK;
    if( osFcntl(pFile->h, F_GETLK, &lock) ){
      rc = SQLITE_IOERR_CHECKRESERVEDLOCK;
      
// ABS Label 194
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}

// ABS Label 195
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}
storeLastErrno(pFile, errno);
    } else { 
// ROR Label 196
if((lock.l_type == 2) != (lock.l_type != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}
if( lock.l_type!=F_UNLCK ){
      reserved = 1;
    };}

  }
#endif
  
  
// ABS Label 185
if(pFile->pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
sqlite3_mutex_leave(pFile->pInode->pLockMutex);
  OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved));

  *pResOut = reserved;
  
// ABS Label 197
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
return rc;
}

/* Forward declaration*/
static int unixSleep(sqlite3_vfs*,int);

/*
** Set a posix-advisory-lock.
**
** There are two versions of this routine.  If compiled with
** SQLITE_ENABLE_SETLK_TIMEOUT then the routine has an extra parameter
** which is a pointer to a unixFile.  If the unixFile->iBusyTimeout
** value is set, then it is the number of milliseconds to wait before
** failing the lock.  The iBusyTimeout value is always reset back to
** zero on each call.
**
** If SQLITE_ENABLE_SETLK_TIMEOUT is not defined, then do a non-blocking
** attempt to set the lock.
*/
#ifndef SQLITE_ENABLE_SETLK_TIMEOUT
# define osSetPosixAdvisoryLock(h,x,t) osFcntl(h,F_SETLK,x)
#else
static int osSetPosixAdvisoryLock(
  int h,                /* The file descriptor on which to take the lock */
  struct flock *pLock,  /* The description of the lock */
  unixFile *pFile       /* Structure holding timeout value */
){
  int tm = pFile->iBusyTimeout;
  int rc = osFcntl(h,F_SETLK,pLock);
  while( rc<0 && tm>0 ){
    /* On systems that support some kind of blocking file lock with a timeout,
    ** make appropriate changes here to invoke that blocking file lock.  On
    ** generic posix, however, there is no such API.  So we simply try the
    ** lock once every millisecond until either the timeout expires, or until
    ** the lock is obtained. */
    unixSleep(0,1000);
    rc = osFcntl(h,F_SETLK,pLock);
    tm--;
  }
  return rc;
}
#endif /* SQLITE_ENABLE_SETLK_TIMEOUT */


/*
** Attempt to set a system-lock on the file pFile.  The lock is 
** described by pLock.
**
** If the pFile was opened read/write from unix-excl, then the only lock
** ever obtained is an exclusive lock, and it is obtained exactly once
** the first time any lock is attempted.  All subsequent system locking
** operations become no-ops.  Locking operations still happen internally,
** in order to coordinate access between separate database connections
** within this process, but all of that is handled in memory and the
** operating system does not participate.
**
** This function is a pass-through to fcntl(F_SETLK) if pFile is using
** any VFS other than "unix-excl" or if pFile is opened on "unix-excl"
** and is read-only.
**
** Zero is returned if the call completes successfully, or -1 if a call
** to fcntl() fails. In this case, errno is set appropriately (by fcntl()).
*/
static int unixFileLock(unixFile *pFile, struct flock *pLock){
  int rc;
  
// ABS Label 198
if(pFile->pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
unixInodeInfo *pInode = pFile->pInode;
  assert( pInode!=0 );
  assert( sqlite3_mutex_held(pInode->pLockMutex) );
  
// ROR Label 199
if(((pFile->ctrlFlags & (1 | 2)) != 1) != ((pFile->ctrlFlags & (1 | 2)) == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
if( (pFile->ctrlFlags & (UNIXFILE_EXCL|UNIXFILE_RDONLY))==UNIXFILE_EXCL ){
    
// ROR Label 200
if((pInode->bProcessLock != 0) != (pInode->bProcessLock == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
if( pInode->bProcessLock==0 ){
      struct flock lock;
      assert( pInode->nLock==0 );
      lock.l_whence = SEEK_SET;
      lock.l_start = SHARED_FIRST;
      lock.l_len = SHARED_SIZE;
      lock.l_type = F_WRLCK;
      rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);
      
// ABS Label 201
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}

// ROR Label 202
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
// ROR Label 203
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
// ROR Label 204
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
if( rc<0 ) { 
// ABS Label 205
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}
return rc;
}
      pInode->bProcessLock = 1;
      pInode->nLock++;
    }else{
      rc = 0;
    }
  }else{
    rc = osSetPosixAdvisoryLock(pFile->h, pLock, pFile);
  }
  
// ABS Label 206
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
return rc;
}

/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -> SHARED
**    SHARED -> RESERVED
**    SHARED -> (PENDING) -> EXCLUSIVE
**    RESERVED -> (PENDING) -> EXCLUSIVE
**    PENDING -> EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/
static int unixLock(sqlite3_file *id, int eFileLock){
  /* The following describes the implementation of the various locks and
  ** lock transitions in terms of the POSIX advisory shared and exclusive
  ** lock primitives (called read-locks and write-locks below, to avoid
  ** confusion with SQLite lock names). The algorithms are complicated
  ** slightly in order to be compatible with Windows95 systems simultaneously
  ** accessing the same database file, in case that is ever required.
  **
  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved
  ** byte', each single bytes at well known offsets, and the 'shared byte
  ** range', a range of 510 bytes at a well known offset.
  **
  ** To obtain a SHARED lock, a read-lock is obtained on the 'pending
  ** byte'.  If this is successful, 'shared byte range' is read-locked
  ** and the lock on the 'pending byte' released.  (Legacy note:  When
  ** SQLite was first developed, Windows95 systems were still very common,
  ** and Widnows95 lacks a shared-lock capability.  So on Windows95, a
  ** single randomly selected by from the 'shared byte range' is locked.
  ** Windows95 is now pretty much extinct, but this work-around for the
  ** lack of shared-locks on Windows95 lives on, for backwards
  ** compatibility.)
  **
  ** A process may only obtain a RESERVED lock after it has a SHARED lock.
  ** A RESERVED lock is implemented by grabbing a write-lock on the
  ** 'reserved byte'. 
  **
  ** A process may only obtain a PENDING lock after it has obtained a
  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock
  ** on the 'pending byte'. This ensures that no new SHARED locks can be
  ** obtained, but existing SHARED locks are allowed to persist. A process
  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.
  ** This property is used by the algorithm for rolling back a journal file
  ** after a crash.
  **
  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is
  ** implemented by obtaining a write-lock on the entire 'shared byte
  ** range'. Since all other locks require a read-lock on one of the bytes
  ** within this range, this ensures that no other locks are held on the
  ** database. 
  */
  int rc = SQLITE_OK;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int tErrno = 0;

  assert( pFile );
  OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,
      azFileLock(eFileLock), azFileLock(pFile->eFileLock),
      azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,
      osGetpid(0)));

  /* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */
  
// ABS Label 208
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 208);
}

// ROR Label 209
if((pFile->eFileLock < eFileLock) != (pFile->eFileLock >= eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((pFile->eFileLock > eFileLock) != (pFile->eFileLock >= eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
// ROR Label 211
if((pFile->eFileLock <= eFileLock) != (pFile->eFileLock >= eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
if( pFile->eFileLock>=eFileLock ){
    OSTRACE(("LOCK    %d %s ok (already held) (unix)\n", pFile->h,
            azFileLock(eFileLock)));
    return SQLITE_OK;
  }

  /* Make sure the locking sequence is correct.
  **  (1) We never move from unlocked to anything higher than shared lock.
  **  (2) SQLite never explicitly requests a pendig lock.
  **  (3) A shared lock is always held when a reserve lock is requested.
  */
  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );
  assert( eFileLock!=PENDING_LOCK );
  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );

  /* This mutex is needed because pFile->pInode is shared across threads
  */
  pInode = pFile->pInode;
  
// ABS Label 207
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}
sqlite3_mutex_enter(pInode->pLockMutex);

  /* If some thread using this PID has a lock via a different unixFile*
  ** handle that precludes the requested lock, return BUSY.
  */
  
// MCC Label 212
if(( pFile->eFileLock != pInode->eFileLock && ( pInode->eFileLock >= 3 && eFileLock > 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(( pFile->eFileLock != pInode->eFileLock && ( pInode->eFileLock >= 3 && !(eFileLock > 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(( pFile->eFileLock != pInode->eFileLock && ( !(pInode->eFileLock >= 3) && eFileLock > 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(( pFile->eFileLock != pInode->eFileLock && ( !(pInode->eFileLock >= 3) && !(eFileLock > 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(( !(pFile->eFileLock != pInode->eFileLock) && ( pInode->eFileLock >= 3 && eFileLock > 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(( !(pFile->eFileLock != pInode->eFileLock) && ( pInode->eFileLock >= 3 && !(eFileLock > 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(( !(pFile->eFileLock != pInode->eFileLock) && ( !(pInode->eFileLock >= 3) && eFileLock > 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
// MCC Label 219
if(( !(pFile->eFileLock != pInode->eFileLock) && ( !(pInode->eFileLock >= 3) && !(eFileLock > 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
if( (pFile->eFileLock!=pInode->eFileLock && 
          (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))
  ){
    rc = SQLITE_BUSY;
    goto end_lock;
  }

  /* If a SHARED lock is requested, and some thread using this PID already
  ** has a SHARED or RESERVED lock, then increment reference counts and
  ** return SQLITE_OK.
  */
  
// ABS Label 220
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}

// COR Label 221
if((eFileLock == 1 || (pInode->eFileLock == 1 || pInode->eFileLock == 2)) != (eFileLock == 1 && (pInode->eFileLock == 1 || pInode->eFileLock == 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 221);
}

// ROR Label 222
if((eFileLock != 1) != (eFileLock == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}

// MCC Label 223
if(eFileLock == 1 && ( pInode->eFileLock == 1 && pInode->eFileLock == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(eFileLock == 1 && ( pInode->eFileLock == 1 && !(pInode->eFileLock == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(eFileLock == 1 && ( !(pInode->eFileLock == 1) && pInode->eFileLock == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(eFileLock == 1 && ( !(pInode->eFileLock == 1) && !(pInode->eFileLock == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(!(eFileLock == 1) && ( pInode->eFileLock == 1 && pInode->eFileLock == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(!(eFileLock == 1) && ( pInode->eFileLock == 1 && !(pInode->eFileLock == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(!(eFileLock == 1) && ( !(pInode->eFileLock == 1) && pInode->eFileLock == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(!(eFileLock == 1) && ( !(pInode->eFileLock == 1) && !(pInode->eFileLock == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
if( eFileLock==SHARED_LOCK && 
      (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){
    assert( eFileLock==SHARED_LOCK );
    assert( pFile->eFileLock==0 );
    assert( pInode->nShared>0 );
    pFile->eFileLock = SHARED_LOCK;
    pInode->nShared++;
    pInode->nLock++;
    goto end_lock;
  }


  /* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */
  lock.l_len = 1L;
  lock.l_whence = SEEK_SET;
  
// ABS Label 231
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// COR Label 232
if((eFileLock == 1 && (eFileLock == 4 && pFile->eFileLock < 3)) != (eFileLock == 1 || (eFileLock == 4 && pFile->eFileLock < 3)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 232);
}

// ROR Label 233
if((eFileLock != 1) != (eFileLock == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 233);
}

// MCC Label 234
if(eFileLock == 1 && ( eFileLock == 4 && pFile->eFileLock < 3 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
// MCC Label 235
if(eFileLock == 1 && ( eFileLock == 4 && !(pFile->eFileLock < 3) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
// MCC Label 236
if(eFileLock == 1 && ( !(eFileLock == 4) && pFile->eFileLock < 3 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
// MCC Label 237
if(eFileLock == 1 && ( !(eFileLock == 4) && !(pFile->eFileLock < 3) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 237);
}
// MCC Label 238
if(!(eFileLock == 1) && ( eFileLock == 4 && pFile->eFileLock < 3 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 238);
}
// MCC Label 239
if(!(eFileLock == 1) && ( eFileLock == 4 && !(pFile->eFileLock < 3) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 239);
}
// MCC Label 240
if(!(eFileLock == 1) && ( !(eFileLock == 4) && pFile->eFileLock < 3 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(!(eFileLock == 1) && ( !(eFileLock == 4) && !(pFile->eFileLock < 3) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}
if( eFileLock==SHARED_LOCK 
      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)
  ){
    lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);
    lock.l_start = PENDING_BYTE;
    if( unixFileLock(pFile, &lock) ){
      tErrno = errno;
      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
      
// ABS Label 242
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}

// ROR Label 243
if((rc == 5) != (rc != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
if( rc!=SQLITE_BUSY ){
        
// ABS Label 244
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ABS Label 245
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}
storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    }
  }


  /* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */
  
// ABS Label 246
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}

// ROR Label 247
if((eFileLock != 1) != (eFileLock == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 247);
}
if( eFileLock==SHARED_LOCK ){
    assert( pInode->nShared==0 );
    assert( pInode->eFileLock==0 );
    assert( rc==SQLITE_OK );

    /* Now get the read-lock */
    lock.l_start = SHARED_FIRST;
    lock.l_len = SHARED_SIZE;
    if( unixFileLock(pFile, &lock) ){
      tErrno = errno;
      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
    }

    /* Drop the temporary PENDING lock */
    lock.l_start = PENDING_BYTE;
    lock.l_len = 1L;
    lock.l_type = F_UNLCK;
    if( unixFileLock(pFile, &lock) && rc==SQLITE_OK ){
      /* This could happen with a network mount */
      tErrno = errno;
      rc = SQLITE_IOERR_UNLOCK; 
    }

    
// ABS Label 248
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
if( rc ){
      
// ABS Label 249
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}

// ROR Label 250
if((rc == 5) != (rc != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
if( rc!=SQLITE_BUSY ){
        
// ABS Label 251
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ABS Label 252
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}
storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    }else{
      pFile->eFileLock = SHARED_LOCK;
      pInode->nLock++;
      pInode->nShared = 1;
    }
  }else { 
// ABS Label 253
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}
// ABS Label 254
if(pInode->nShared < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}

// COR Label 255
if((eFileLock == 4 || pInode->nShared > 1) != (eFileLock == 4 && pInode->nShared > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 255);
}

// ROR Label 256
if((eFileLock != 4) != (eFileLock == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 256);
}
// ROR Label 257
if((pInode->nShared <= 1) != (pInode->nShared > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
// ROR Label 258
if((pInode->nShared < 1) != (pInode->nShared > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}
// ROR Label 259
if((pInode->nShared >= 1) != (pInode->nShared > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}

// MCC Label 260
if(eFileLock == 4 && pInode->nShared > 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if(eFileLock == 4 && !(pInode->nShared > 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(!(eFileLock == 4) && pInode->nShared > 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(!(eFileLock == 4) && !(pInode->nShared > 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){
    /* We are trying for an exclusive lock but another thread in this
    ** same process is still holding a shared lock. */
    rc = SQLITE_BUSY;
  }else{
    /* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */
    assert( 0!=pFile->eFileLock );
    lock.l_type = F_WRLCK;

    assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );
    
// ABS Label 264
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}

// ROR Label 265
if((eFileLock != 2) != (eFileLock == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
if( eFileLock==RESERVED_LOCK ){
      lock.l_start = RESERVED_BYTE;
      lock.l_len = 1L;
    }else{
      lock.l_start = SHARED_FIRST;
      lock.l_len = SHARED_SIZE;
    }

    if( unixFileLock(pFile, &lock) ){
      tErrno = errno;
      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
      
// ABS Label 266
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}

// ROR Label 267
if((rc == 5) != (rc != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
if( rc!=SQLITE_BUSY ){
        
// ABS Label 268
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}

// ABS Label 269
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
storeLastErrno(pFile, tErrno);
      }
    }
  };}

  

#ifdef SQLITE_DEBUG
  /* Set up the transaction-counter change checking flags when
  ** transitioning from a SHARED to a RESERVED lock.  The change
  ** from SHARED to RESERVED marks the beginning of a normal
  ** write operation (not a hot journal rollback).
  */
  if( rc==SQLITE_OK
   && pFile->eFileLock<=SHARED_LOCK
   && eFileLock==RESERVED_LOCK
  ){
    pFile->transCntrChng = 0;
    pFile->dbUpdate = 0;
    pFile->inNormalWrite = 1;
  }
#endif


  
// ABS Label 270
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}

// ROR Label 271
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 271);
}
if( rc==SQLITE_OK ){
    pFile->eFileLock = eFileLock;
    pInode->eFileLock = eFileLock;
  }else { 
// ABS Label 272
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}

// ROR Label 273
if((eFileLock != 4) != (eFileLock == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
if( eFileLock==EXCLUSIVE_LOCK ){
    pFile->eFileLock = PENDING_LOCK;
    pInode->eFileLock = PENDING_LOCK;
  };}


end_lock:
  sqlite3_mutex_leave(pInode->pLockMutex);
  OSTRACE(("LOCK    %d %s %s (unix)\n", pFile->h, azFileLock(eFileLock), 
      rc==SQLITE_OK ? "ok" : "failed"));
  
// ABS Label 274
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
return rc;
}

/*
** Add the file descriptor used by file handle pFile to the corresponding
** pUnused list.
*/
static void setPendingFd(unixFile *pFile){
  
// ABS Label 275
if(pFile->pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
unixInodeInfo *pInode = pFile->pInode;
  
// ABS Label 276
if(pFile->pPreallocatedUnused < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
UnixUnusedFd *p = pFile->pPreallocatedUnused;
  assert( unixFileMutexHeld(pFile) );
  p->pNext = pInode->pUnused;
  pInode->pUnused = p;
  pFile->h = -1;
  pFile->pPreallocatedUnused = 0;
}

/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
** 
** If handleNFSUnlock is true, then on downgrading an EXCLUSIVE_LOCK to SHARED
** the byte range is divided into 2 parts and the first part is unlocked then
** set to a read lock, then the other part is simply unlocked.  This works 
** around a bug in BSD NFS lockd (also seen on MacOSX 10.3+) that fails to 
** remove the write lock on a region when a read lock is set.
*/
static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int rc = SQLITE_OK;

  assert( pFile );
  OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,
      pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,
      osGetpid(0)));

  assert( eFileLock<=SHARED_LOCK );
  
// ABS Label 278
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}

// ROR Label 279
if((pFile->eFileLock < eFileLock) != (pFile->eFileLock <= eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((pFile->eFileLock > eFileLock) != (pFile->eFileLock <= eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((pFile->eFileLock >= eFileLock) != (pFile->eFileLock <= eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}
if( pFile->eFileLock<=eFileLock ){
    return SQLITE_OK;
  }
  pInode = pFile->pInode;
  
// ABS Label 277
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
sqlite3_mutex_enter(pInode->pLockMutex);
  assert( pInode->nShared!=0 );
  
// ROR Label 282
if((pFile->eFileLock <= 1) != (pFile->eFileLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
// ROR Label 283
if((pFile->eFileLock < 1) != (pFile->eFileLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 283);
}
// ROR Label 284
if((pFile->eFileLock >= 1) != (pFile->eFileLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
if( pFile->eFileLock>SHARED_LOCK ){
    assert( pInode->eFileLock==pFile->eFileLock );

#ifdef SQLITE_DEBUG
    /* When reducing a lock such that other processes can start
    ** reading the database file again, make sure that the
    ** transaction counter was updated if any part of the database
    ** file changed.  If the transaction counter is not updated,
    ** other connections to the same file might not realize that
    ** the file has changed and hence might not know to flush their
    ** cache.  The use of a stale cache can lead to database corruption.
    */
    pFile->inNormalWrite = 0;
#endif

    /* downgrading to a shared lock on NFS involves clearing the write lock
    ** before establishing the readlock - to avoid a race condition we downgrade
    ** the lock in 2 blocks, so that part of the range will be covered by a 
    ** write lock until the rest is covered by a read lock:
    **  1:   [WWWWW]
    **  2:   [....W]
    **  3:   [RRRRW]
    **  4:   [RRRR.]
    */
    
// ABS Label 285
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}

// ROR Label 286
if((eFileLock != 1) != (eFileLock == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
if( eFileLock==SHARED_LOCK ){
#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE
      (void)handleNFSUnlock;
      assert( handleNFSUnlock==0 );
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
      if( handleNFSUnlock ){
        int tErrno;               /* Error code from system call errors */
        off_t divSize = SHARED_SIZE - 1;
        
        lock.l_type = F_UNLCK;
        lock.l_whence = SEEK_SET;
        lock.l_start = SHARED_FIRST;
        lock.l_len = divSize;
        if( unixFileLock(pFile, &lock)==(-1) ){
          tErrno = errno;
          rc = SQLITE_IOERR_UNLOCK;
          storeLastErrno(pFile, tErrno);
          goto end_unlock;
        }
        lock.l_type = F_RDLCK;
        lock.l_whence = SEEK_SET;
        lock.l_start = SHARED_FIRST;
        lock.l_len = divSize;
        if( unixFileLock(pFile, &lock)==(-1) ){
          tErrno = errno;
          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);
          if( IS_LOCK_ERROR(rc) ){
            storeLastErrno(pFile, tErrno);
          }
          goto end_unlock;
        }
        lock.l_type = F_UNLCK;
        lock.l_whence = SEEK_SET;
        lock.l_start = SHARED_FIRST+divSize;
        lock.l_len = SHARED_SIZE-divSize;
        if( unixFileLock(pFile, &lock)==(-1) ){
          tErrno = errno;
          rc = SQLITE_IOERR_UNLOCK;
          storeLastErrno(pFile, tErrno);
          goto end_unlock;
        }
      }else
#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */
      {
        lock.l_type = F_RDLCK;
        lock.l_whence = SEEK_SET;
        lock.l_start = SHARED_FIRST;
        lock.l_len = SHARED_SIZE;
        if( unixFileLock(pFile, &lock) ){
          /* In theory, the call to unixFileLock() cannot fail because another
          ** process is holding an incompatible lock. If it does, this 
          ** indicates that the other process is not following the locking
          ** protocol. If this happens, return SQLITE_IOERR_RDLOCK. Returning
          ** SQLITE_BUSY would confuse the upper layer (in practice it causes 
          ** an assert to fail). */ 
          rc = SQLITE_IOERR_RDLOCK;
          
// ABS Label 287
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}

// ABS Label 288
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}
storeLastErrno(pFile, errno);
          goto end_unlock;
        }
      }
    }
    lock.l_type = F_UNLCK;
    lock.l_whence = SEEK_SET;
    lock.l_start = PENDING_BYTE;
    lock.l_len = 2L;  assert( PENDING_BYTE+1==RESERVED_BYTE );
    if( unixFileLock(pFile, &lock)==0 ){
      pInode->eFileLock = SHARED_LOCK;
    }else{
      rc = SQLITE_IOERR_UNLOCK;
      
// ABS Label 289
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// ABS Label 290
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}
storeLastErrno(pFile, errno);
      goto end_unlock;
    }
  }
  
// ABS Label 291
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ROR Label 292
if((eFileLock != 0) != (eFileLock == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}
if( eFileLock==NO_LOCK ){
    /* Decrement the shared lock counter.  Release the lock using an
    ** OS call only when all threads in this same process have released
    ** the lock.
    */
    pInode->nShared--;
    
// ABS Label 293
if(pInode->nShared < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ROR Label 294
if((pInode->nShared != 0) != (pInode->nShared == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}
if( pInode->nShared==0 ){
      lock.l_type = F_UNLCK;
      lock.l_whence = SEEK_SET;
      lock.l_start = lock.l_len = 0L;
      if( unixFileLock(pFile, &lock)==0 ){
        pInode->eFileLock = NO_LOCK;
      }else{
        rc = SQLITE_IOERR_UNLOCK;
        
// ABS Label 295
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
storeLastErrno(pFile, errno);
        pInode->eFileLock = NO_LOCK;
        pFile->eFileLock = NO_LOCK;
      }
    }

    /* Decrement the count of locks against this same file.  When the
    ** count reaches zero, close any other file descriptors whose close
    ** was deferred because of outstanding locks.
    */
    pInode->nLock--;
    assert( pInode->nLock>=0 );
    
// ABS Label 297
if(pInode->nLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ROR Label 298
if((pInode->nLock != 0) != (pInode->nLock == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
if( pInode->nLock==0 ) { 
// ABS Label 299
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
closePendingFds(pFile);
}
  }

end_unlock:
  sqlite3_mutex_leave(pInode->pLockMutex);
  
// ABS Label 300
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}

// ROR Label 301
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}
if( rc==SQLITE_OK ){
    pFile->eFileLock = eFileLock;
  }
  
// ABS Label 302
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
return rc;
}

/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/
static int unixUnlock(sqlite3_file *id, int eFileLock){
#if SQLITE_MAX_MMAP_SIZE>0
  assert( eFileLock==SHARED_LOCK || ((unixFile *)id)->nFetchOut==0 );
#endif
  return posixUnlock(id, eFileLock, 0);
}

#if SQLITE_MAX_MMAP_SIZE>0
static int unixMapfile(unixFile *pFd, i64 nByte);
static void unixUnmapfile(unixFile *pFd);
#endif

/*
** This function performs the parts of the "close file" operation 
** common to all locking schemes. It closes the directory and file
** handles, if they are valid, and sets all fields of the unixFile
** structure to 0.
**
** It is *not* necessary to hold the mutex when this routine is called,
** even on VxWorks.  A mutex will be acquired on VxWorks by the
** vxworksReleaseFileId() routine.
*/
static int closeUnixFile(sqlite3_file *id){
  unixFile *pFile = (unixFile*)id;
#if SQLITE_MAX_MMAP_SIZE>0
  
// ABS Label 303
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
unixUnmapfile(pFile);
#endif
  
// ABS Label 304
if(pFile->h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}

// ROR Label 305
if((pFile->h < 0) != (pFile->h >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}
// ROR Label 306
if((pFile->h > 0) != (pFile->h >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 306);
}
// ROR Label 307
if((pFile->h <= 0) != (pFile->h >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 307);
}
if( pFile->h>=0 ){
    
// ABS Label 308
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// ABS Label 309
if(pFile->h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}
robust_close(pFile, pFile->h, __LINE__);
    pFile->h = -1;
  }
#if OS_VXWORKS
  if( pFile->pId ){
    if( pFile->ctrlFlags & UNIXFILE_DELETE ){
      osUnlink(pFile->pId->zCanonicalName);
    }
    vxworksReleaseFileId(pFile->pId);
    pFile->pId = 0;
  }
#endif
#ifdef SQLITE_UNLINK_AFTER_CLOSE
  if( pFile->ctrlFlags & UNIXFILE_DELETE ){
    osUnlink(pFile->zPath);
    sqlite3_free(*(char**)&pFile->zPath);
    pFile->zPath = 0;
  }
#endif
  OSTRACE(("CLOSE   %-3d\n", pFile->h));
  OpenCounter(-1);
  sqlite3_free(pFile->pPreallocatedUnused);
  memset(pFile, 0, sizeof(unixFile));
  return SQLITE_OK;
}

/*
** Close a file.
*/
static int unixClose(sqlite3_file *id){
  int rc = SQLITE_OK;
  unixFile *pFile = (unixFile *)id;
  
// ABS Label 310
if(pFile->pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}
unixInodeInfo *pInode = pFile->pInode;

  assert( pInode!=0 );
  
// ABS Label 311
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
verifyDbFile(pFile);
  
// ABS Label 312
if(id < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
unixUnlock(id, NO_LOCK);
  assert( unixFileMutexNotheld(pFile) );
  unixEnterMutex();

  /* unixFile.pInode is always valid here. Otherwise, a different close
  ** routine (e.g. nolockClose()) would be called instead.
  */
  assert( pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 );
  
// ABS Label 313
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
sqlite3_mutex_enter(pInode->pLockMutex);
  
// ABS Label 316
if(pInode->nLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
if( pInode->nLock ){
    /* If there are outstanding locks, do not actually close the file just
    ** yet because that would clear those locks.  Instead, add the file
    ** descriptor to pInode->pUnused list.  It will be automatically closed 
    ** when the last lock is cleared.
    */
    
// ABS Label 317
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
setPendingFd(pFile);
  }
  
// ABS Label 314
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
sqlite3_mutex_leave(pInode->pLockMutex);
  
// ABS Label 315
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
releaseInodeInfo(pFile);
  assert( pFile->pShm==0 );
  rc = closeUnixFile(id);
  unixLeaveMutex();
  
// ABS Label 318
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
return rc;
}

/************** End of the posix advisory lock implementation *****************
******************************************************************************/

/******************************************************************************
****************************** No-op Locking **********************************
**
** Of the various locking implementations available, this is by far the
** simplest:  locking is ignored.  No attempt is made to lock the database
** file for reading or writing.
**
** This locking mode is appropriate for use on read-only databases
** (ex: databases that are burned into CD-ROM, for example.)  It can
** also be used if the application employs some external mechanism to
** prevent simultaneous access of the same database by two or more
** database connections.  But there is a serious risk of database
** corruption if this locking mode is used in situations where multiple
** database connections are accessing the same database file at the same
** time and one or more of those connections are writing.
*/

static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){
  UNUSED_PARAMETER(NotUsed);
  *pResOut = 0;
  return SQLITE_OK;
}
static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  return SQLITE_OK;
}
static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  return SQLITE_OK;
}

/*
** Close the file.
*/
static int nolockClose(sqlite3_file *id) {
  return closeUnixFile(id);
}

/******************* End of the no-op lock implementation *********************
******************************************************************************/

/******************************************************************************
************************* Begin dot-file Locking ******************************
**
** The dotfile locking implementation uses the existence of separate lock
** files (really a directory) to control access to the database.  This works
** on just about every filesystem imaginable.  But there are serious downsides:
**
**    (1)  There is zero concurrency.  A single reader blocks all other
**         connections from reading or writing the database.
**
**    (2)  An application crash or power loss can leave stale lock files
**         sitting around that need to be cleared manually.
**
** Nevertheless, a dotlock is an appropriate locking mode for use if no
** other locking strategy is available.
**
** Dotfile locking works by creating a subdirectory in the same directory as
** the database and with the same name but with a ".lock" extension added.
** The existence of a lock directory implies an EXCLUSIVE lock.  All other
** lock types (SHARED, RESERVED, PENDING) are mapped into EXCLUSIVE.
*/

/*
** The file suffix added to the data base filename in order to create the
** lock directory.
*/
#define DOTLOCK_SUFFIX ".lock"

/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
**
** In dotfile locking, either a lock exists or it does not.  So in this
** variation of CheckReservedLock(), *pResOut is set to true if any lock
** is held on the file and false if the file is unlocked.
*/
static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {
  int rc = SQLITE_OK;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );
  
  assert( pFile );
  reserved = osAccess((const char*)pFile->lockingContext, 0)==0;
  OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, rc, reserved));
  *pResOut = reserved;
  
// ABS Label 319
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
return rc;
}

/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -> SHARED
**    SHARED -> RESERVED
**    SHARED -> (PENDING) -> EXCLUSIVE
**    RESERVED -> (PENDING) -> EXCLUSIVE
**    PENDING -> EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
**
** With dotfile locking, we really only support state (4): EXCLUSIVE.
** But we track the other locking levels internally.
*/
static int dotlockLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc = SQLITE_OK;


  /* If we have any lock, then the lock file already exists.  All we have
  ** to do is adjust our internal record of the lock level.
  */
  
// ROR Label 320
if((pFile->eFileLock <= 0) != (pFile->eFileLock > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 320);
}
// ROR Label 321
if((pFile->eFileLock < 0) != (pFile->eFileLock > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 321);
}
// ROR Label 322
if((pFile->eFileLock >= 0) != (pFile->eFileLock > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}
if( pFile->eFileLock > NO_LOCK ){
    pFile->eFileLock = eFileLock;
    /* Always update the timestamp on the old file */
#ifdef HAVE_UTIME
    utime(zLockFile, NULL);
#else
    utimes(zLockFile, NULL);
#endif
    return SQLITE_OK;
  }
  
  /* grab an exclusive lock */
  rc = osMkdir(zLockFile, 0777);
  
// ABS Label 323
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}

// ROR Label 324
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 324);
}
// ROR Label 325
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}
// ROR Label 326
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 326);
}
if( rc<0 ){
    /* failed to open/create the lock directory */
    
// ABS Label 327
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
int tErrno = errno;
    
// ABS Label 328
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ROR Label 329
if((17 != tErrno) != (17 == tErrno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 329);
}
if( EEXIST == tErrno ){
      rc = SQLITE_BUSY;
    } else {
      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
      
// ABS Label 330
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ROR Label 331
if((rc == 5) != (rc != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 331);
}
if( rc!=SQLITE_BUSY ){
        
// ABS Label 332
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// ABS Label 333
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
storeLastErrno(pFile, tErrno);
      }
    }
    
// ABS Label 334
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
return rc;
  } 
  
  /* got it, set the type and return ok */
  pFile->eFileLock = eFileLock;
  
// ABS Label 335
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
return rc;
}

/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
**
** When the locking level reaches NO_LOCK, delete the lock file.
*/
static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc;

  assert( pFile );
  OSTRACE(("UNLOCK  %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,
           pFile->eFileLock, osGetpid(0)));
  assert( eFileLock<=SHARED_LOCK );
  
  /* no-op if possible */
  
// ABS Label 336
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ROR Label 337
if((pFile->eFileLock != eFileLock) != (pFile->eFileLock == eFileLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
if( pFile->eFileLock==eFileLock ){
    return SQLITE_OK;
  }

  /* To downgrade to shared, simply update our internal notion of the
  ** lock state.  No need to mess with the file on disk.
  */
  
// ABS Label 338
if(eFileLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}

// ROR Label 339
if((eFileLock != 1) != (eFileLock == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
if( eFileLock==SHARED_LOCK ){
    pFile->eFileLock = SHARED_LOCK;
    return SQLITE_OK;
  }
  
  /* To fully unlock the database, delete the lock file */
  assert( eFileLock==NO_LOCK );
  rc = osRmdir(zLockFile);
  
// ABS Label 340
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// ROR Label 341
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 341);
}
// ROR Label 342
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}
// ROR Label 343
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 343);
}
if( rc<0 ){
    
// ABS Label 344
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
int tErrno = errno;
    
// ABS Label 345
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}

// ROR Label 346
if((tErrno != 2) != (tErrno == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 346);
}
if( tErrno==ENOENT ){
      rc = SQLITE_OK;
    }else{
      rc = SQLITE_IOERR_UNLOCK;
      
// ABS Label 347
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}

// ABS Label 348
if(tErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}
storeLastErrno(pFile, tErrno);
    }
    
// ABS Label 349
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
return rc; 
  }
  pFile->eFileLock = NO_LOCK;
  return SQLITE_OK;
}

/*
** Close a file.  Make sure the lock has been released before closing.
*/
static int dotlockClose(sqlite3_file *id) {
  unixFile *pFile = (unixFile*)id;
  assert( id!=0 );
  
// ABS Label 350
if(id < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
dotlockUnlock(id, NO_LOCK);
  
// ABS Label 351
if(pFile->lockingContext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
sqlite3_free(pFile->lockingContext);
  return closeUnixFile(id);
}
/****************** End of the dot-file lock implementation *******************
******************************************************************************/

/******************************************************************************
************************** Begin flock Locking ********************************
**
** Use the flock() system call to do file locking.
**
** flock() locking is like dot-file locking in that the various
** fine-grain locking levels supported by SQLite are collapsed into
** a single exclusive lock.  In other words, SHARED, RESERVED, and
** PENDING locks are the same thing as an EXCLUSIVE lock.  SQLite
** still works when you do this, but concurrency is reduced since
** only a single process can be reading the database at a time.
**
** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off
*/
#if SQLITE_ENABLE_LOCKING_STYLE

/*
** Retry flock() calls that fail with EINTR
*/
#ifdef EINTR
static int robust_flock(int fd, int op){
  int rc;
  do{ rc = flock(fd,op); }while( rc<0 && errno==EINTR );
  return rc;
}
#else
# define robust_flock(a,b) flock(a,b)
#endif
     

/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/
static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = SQLITE_OK;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;
  
  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );
  
  assert( pFile );
  
  /* Check if a thread in this process holds such a lock */
  if( pFile->eFileLock>SHARED_LOCK ){
    reserved = 1;
  }
  
  /* Otherwise see if some other process holds it. */
  if( !reserved ){
    /* attempt to get the lock */
    int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);
    if( !lrc ){
      /* got the lock, unlock it */
      lrc = robust_flock(pFile->h, LOCK_UN);
      if ( lrc ) {
        int tErrno = errno;
        /* unlock failed with an error */
        lrc = SQLITE_IOERR_UNLOCK; 
        storeLastErrno(pFile, tErrno);
        rc = lrc;
      }
    } else {
      int tErrno = errno;
      reserved = 1;
      /* someone else might have it reserved */
      lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); 
      if( IS_LOCK_ERROR(lrc) ){
        storeLastErrno(pFile, tErrno);
        rc = lrc;
      }
    }
  }
  OSTRACE(("TEST WR-LOCK %d %d %d (flock)\n", pFile->h, rc, reserved));

#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
  if( (rc & 0xff) == SQLITE_IOERR ){
    rc = SQLITE_OK;
    reserved=1;
  }
#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */
  *pResOut = reserved;
  return rc;
}

/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -> SHARED
**    SHARED -> RESERVED
**    SHARED -> (PENDING) -> EXCLUSIVE
**    RESERVED -> (PENDING) -> EXCLUSIVE
**    PENDING -> EXCLUSIVE
**
** flock() only really support EXCLUSIVE locks.  We track intermediate
** lock states in the sqlite3_file structure, but all locks SHARED or
** above are really EXCLUSIVE locks and exclude all other processes from
** access the file.
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/
static int flockLock(sqlite3_file *id, int eFileLock) {
  int rc = SQLITE_OK;
  unixFile *pFile = (unixFile*)id;

  assert( pFile );

  /* if we already have a lock, it is exclusive.  
  ** Just adjust level and punt on outta here. */
  if (pFile->eFileLock > NO_LOCK) {
    pFile->eFileLock = eFileLock;
    return SQLITE_OK;
  }
  
  /* grab an exclusive lock */
  
  if (robust_flock(pFile->h, LOCK_EX | LOCK_NB)) {
    int tErrno = errno;
    /* didn't get, must be busy */
    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);
    if( IS_LOCK_ERROR(rc) ){
      storeLastErrno(pFile, tErrno);
    }
  } else {
    /* got it, set the type and return ok */
    pFile->eFileLock = eFileLock;
  }
  OSTRACE(("LOCK    %d %s %s (flock)\n", pFile->h, azFileLock(eFileLock), 
           rc==SQLITE_OK ? "ok" : "failed"));
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
  if( (rc & 0xff) == SQLITE_IOERR ){
    rc = SQLITE_BUSY;
  }
#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */
  return rc;
}


/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/
static int flockUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  
  assert( pFile );
  OSTRACE(("UNLOCK  %d %d was %d pid=%d (flock)\n", pFile->h, eFileLock,
           pFile->eFileLock, osGetpid(0)));
  assert( eFileLock<=SHARED_LOCK );
  
  /* no-op if possible */
  if( pFile->eFileLock==eFileLock ){
    return SQLITE_OK;
  }
  
  /* shared can just be set because we always have an exclusive */
  if (eFileLock==SHARED_LOCK) {
    pFile->eFileLock = eFileLock;
    return SQLITE_OK;
  }
  
  /* no, really, unlock. */
  if( robust_flock(pFile->h, LOCK_UN) ){
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
    return SQLITE_OK;
#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */
    return SQLITE_IOERR_UNLOCK;
  }else{
    pFile->eFileLock = NO_LOCK;
    return SQLITE_OK;
  }
}

/*
** Close a file.
*/
static int flockClose(sqlite3_file *id) {
  assert( id!=0 );
  flockUnlock(id, NO_LOCK);
  return closeUnixFile(id);
}

#endif /* SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORK */

/******************* End of the flock lock implementation *********************
******************************************************************************/

/******************************************************************************
************************ Begin Named Semaphore Locking ************************
**
** Named semaphore locking is only supported on VxWorks.
**
** Semaphore locking is like dot-lock and flock in that it really only
** supports EXCLUSIVE locking.  Only a single process can read or write
** the database file at a time.  This reduces potential concurrency, but
** makes the lock implementation much easier.
*/
#if OS_VXWORKS

/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/
static int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {
  int rc = SQLITE_OK;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );
  
  assert( pFile );

  /* Check if a thread in this process holds such a lock */
  if( pFile->eFileLock>SHARED_LOCK ){
    reserved = 1;
  }
  
  /* Otherwise see if some other process holds it. */
  if( !reserved ){
    sem_t *pSem = pFile->pInode->pSem;

    if( sem_trywait(pSem)==-1 ){
      int tErrno = errno;
      if( EAGAIN != tErrno ){
        rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);
        storeLastErrno(pFile, tErrno);
      } else {
        /* someone else has the lock when we are in NO_LOCK */
        reserved = (pFile->eFileLock < SHARED_LOCK);
      }
    }else{
      /* we could have it if we want it */
      sem_post(pSem);
    }
  }
  OSTRACE(("TEST WR-LOCK %d %d %d (sem)\n", pFile->h, rc, reserved));

  *pResOut = reserved;
  return rc;
}

/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -> SHARED
**    SHARED -> RESERVED
**    SHARED -> (PENDING) -> EXCLUSIVE
**    RESERVED -> (PENDING) -> EXCLUSIVE
**    PENDING -> EXCLUSIVE
**
** Semaphore locks only really support EXCLUSIVE locks.  We track intermediate
** lock states in the sqlite3_file structure, but all locks SHARED or
** above are really EXCLUSIVE locks and exclude all other processes from
** access the file.
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/
static int semXLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  sem_t *pSem = pFile->pInode->pSem;
  int rc = SQLITE_OK;

  /* if we already have a lock, it is exclusive.  
  ** Just adjust level and punt on outta here. */
  if (pFile->eFileLock > NO_LOCK) {
    pFile->eFileLock = eFileLock;
    rc = SQLITE_OK;
    goto sem_end_lock;
  }
  
  /* lock semaphore now but bail out when already locked. */
  if( sem_trywait(pSem)==-1 ){
    rc = SQLITE_BUSY;
    goto sem_end_lock;
  }

  /* got it, set the type and return ok */
  pFile->eFileLock = eFileLock;

 sem_end_lock:
  return rc;
}

/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/
static int semXUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  sem_t *pSem = pFile->pInode->pSem;

  assert( pFile );
  assert( pSem );
  OSTRACE(("UNLOCK  %d %d was %d pid=%d (sem)\n", pFile->h, eFileLock,
           pFile->eFileLock, osGetpid(0)));
  assert( eFileLock<=SHARED_LOCK );
  
  /* no-op if possible */
  if( pFile->eFileLock==eFileLock ){
    return SQLITE_OK;
  }
  
  /* shared can just be set because we always have an exclusive */
  if (eFileLock==SHARED_LOCK) {
    pFile->eFileLock = eFileLock;
    return SQLITE_OK;
  }
  
  /* no, really unlock. */
  if ( sem_post(pSem)==-1 ) {
    int rc, tErrno = errno;
    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);
    if( IS_LOCK_ERROR(rc) ){
      storeLastErrno(pFile, tErrno);
    }
    return rc; 
  }
  pFile->eFileLock = NO_LOCK;
  return SQLITE_OK;
}

/*
 ** Close a file.
 */
static int semXClose(sqlite3_file *id) {
  if( id ){
    unixFile *pFile = (unixFile*)id;
    semXUnlock(id, NO_LOCK);
    assert( pFile );
    assert( unixFileMutexNotheld(pFile) );
    unixEnterMutex();
    releaseInodeInfo(pFile);
    unixLeaveMutex();
    closeUnixFile(id);
  }
  return SQLITE_OK;
}

#endif /* OS_VXWORKS */
/*
** Named semaphore locking is only available on VxWorks.
**
*************** End of the named semaphore lock implementation ****************
******************************************************************************/


/******************************************************************************
*************************** Begin AFP Locking *********************************
**
** AFP is the Apple Filing Protocol.  AFP is a network filesystem found
** on Apple Macintosh computers - both OS9 and OSX.
**
** Third-party implementations of AFP are available.  But this code here
** only works on OSX.
*/

#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
/*
** The afpLockingContext structure contains all afp lock specific state
*/
typedef struct afpLockingContext afpLockingContext;
struct afpLockingContext {
  int reserved;
  const char *dbPath;             /* Name of the open file */
};

struct ByteRangeLockPB2
{
  unsigned long long offset;        /* offset to first byte to lock */
  unsigned long long length;        /* nbr of bytes to lock */
  unsigned long long retRangeStart; /* nbr of 1st byte locked if successful */
  unsigned char unLockFlag;         /* 1 = unlock, 0 = lock */
  unsigned char startEndFlag;       /* 1=rel to end of fork, 0=rel to start */
  int fd;                           /* file desc to assoc this lock with */
};

#define afpfsByteRangeLock2FSCTL        _IOWR('z', 23, struct ByteRangeLockPB2)

/*
** This is a utility for setting or clearing a bit-range lock on an
** AFP filesystem.
** 
** Return SQLITE_OK on success, SQLITE_BUSY on failure.
*/
static int afpSetLock(
  const char *path,              /* Name of the file to be locked or unlocked */
  unixFile *pFile,               /* Open file descriptor on path */
  unsigned long long offset,     /* First byte to be locked */
  unsigned long long length,     /* Number of bytes to lock */
  int setLockFlag                /* True to set lock.  False to clear lock */
){
  struct ByteRangeLockPB2 pb;
  int err;
  
  pb.unLockFlag = setLockFlag ? 0 : 1;
  pb.startEndFlag = 0;
  pb.offset = offset;
  pb.length = length; 
  pb.fd = pFile->h;
  
  OSTRACE(("AFPSETLOCK [%s] for %d%s in range %llx:%llx\n", 
    (setLockFlag?"ON":"OFF"), pFile->h, (pb.fd==-1?"[testval-1]":""),
    offset, length));
  err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0);
  if ( err==-1 ) {
    int rc;
    int tErrno = errno;
    OSTRACE(("AFPSETLOCK failed to fsctl() '%s' %d %s\n",
             path, tErrno, strerror(tErrno)));
#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS
    rc = SQLITE_BUSY;
#else
    rc = sqliteErrorFromPosixError(tErrno,
                    setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);
#endif /* SQLITE_IGNORE_AFP_LOCK_ERRORS */
    if( IS_LOCK_ERROR(rc) ){
      storeLastErrno(pFile, tErrno);
    }
    return rc;
  } else {
    return SQLITE_OK;
  }
}

/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/
static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = SQLITE_OK;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;
  afpLockingContext *context;
  
  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );
  
  assert( pFile );
  context = (afpLockingContext *) pFile->lockingContext;
  if( context->reserved ){
    *pResOut = 1;
    return SQLITE_OK;
  }
  sqlite3_mutex_enter(pFile->pInode->pLockMutex);
  /* Check if a thread in this process holds such a lock */
  if( pFile->pInode->eFileLock>SHARED_LOCK ){
    reserved = 1;
  }
  
  /* Otherwise see if some other process holds it.
   */
  if( !reserved ){
    /* lock the RESERVED byte */
    int lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);  
    if( SQLITE_OK==lrc ){
      /* if we succeeded in taking the reserved lock, unlock it to restore
      ** the original state */
      lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);
    } else {
      /* if we failed to get the lock then someone else must have it */
      reserved = 1;
    }
    if( IS_LOCK_ERROR(lrc) ){
      rc=lrc;
    }
  }
  
  sqlite3_mutex_leave(pFile->pInode->pLockMutex);
  OSTRACE(("TEST WR-LOCK %d %d %d (afp)\n", pFile->h, rc, reserved));
  
  *pResOut = reserved;
  return rc;
}

/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -> SHARED
**    SHARED -> RESERVED
**    SHARED -> (PENDING) -> EXCLUSIVE
**    RESERVED -> (PENDING) -> EXCLUSIVE
**    PENDING -> EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/
static int afpLock(sqlite3_file *id, int eFileLock){
  int rc = SQLITE_OK;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode = pFile->pInode;
  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;
  
  assert( pFile );
  OSTRACE(("LOCK    %d %s was %s(%s,%d) pid=%d (afp)\n", pFile->h,
           azFileLock(eFileLock), azFileLock(pFile->eFileLock),
           azFileLock(pInode->eFileLock), pInode->nShared , osGetpid(0)));

  /* If there is already a lock of this type or more restrictive on the
  ** unixFile, do nothing. Don't use the afp_end_lock: exit path, as
  ** unixEnterMutex() hasn't been called yet.
  */
  if( pFile->eFileLock>=eFileLock ){
    OSTRACE(("LOCK    %d %s ok (already held) (afp)\n", pFile->h,
           azFileLock(eFileLock)));
    return SQLITE_OK;
  }

  /* Make sure the locking sequence is correct
  **  (1) We never move from unlocked to anything higher than shared lock.
  **  (2) SQLite never explicitly requests a pendig lock.
  **  (3) A shared lock is always held when a reserve lock is requested.
  */
  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );
  assert( eFileLock!=PENDING_LOCK );
  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );
  
  /* This mutex is needed because pFile->pInode is shared across threads
  */
  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);

  /* If some thread using this PID has a lock via a different unixFile*
  ** handle that precludes the requested lock, return BUSY.
  */
  if( (pFile->eFileLock!=pInode->eFileLock && 
       (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))
     ){
    rc = SQLITE_BUSY;
    goto afp_end_lock;
  }
  
  /* If a SHARED lock is requested, and some thread using this PID already
  ** has a SHARED or RESERVED lock, then increment reference counts and
  ** return SQLITE_OK.
  */
  if( eFileLock==SHARED_LOCK && 
     (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){
    assert( eFileLock==SHARED_LOCK );
    assert( pFile->eFileLock==0 );
    assert( pInode->nShared>0 );
    pFile->eFileLock = SHARED_LOCK;
    pInode->nShared++;
    pInode->nLock++;
    goto afp_end_lock;
  }
    
  /* A PENDING lock is needed before acquiring a SHARED lock and before
  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will
  ** be released.
  */
  if( eFileLock==SHARED_LOCK 
      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)
  ){
    int failed;
    failed = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 1);
    if (failed) {
      rc = failed;
      goto afp_end_lock;
    }
  }
  
  /* If control gets to this point, then actually go ahead and make
  ** operating system calls for the specified lock.
  */
  if( eFileLock==SHARED_LOCK ){
    int lrc1, lrc2, lrc1Errno = 0;
    long lk, mask;
    
    assert( pInode->nShared==0 );
    assert( pInode->eFileLock==0 );
        
    mask = (sizeof(long)==8) ? LARGEST_INT64 : 0x7fffffff;
    /* Now get the read-lock SHARED_LOCK */
    /* note that the quality of the randomness doesn't matter that much */
    lk = random(); 
    pInode->sharedByte = (lk & mask)%(SHARED_SIZE - 1);
    lrc1 = afpSetLock(context->dbPath, pFile, 
          SHARED_FIRST+pInode->sharedByte, 1, 1);
    if( IS_LOCK_ERROR(lrc1) ){
      lrc1Errno = pFile->lastErrno;
    }
    /* Drop the temporary PENDING lock */
    lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);
    
    if( IS_LOCK_ERROR(lrc1) ) {
      storeLastErrno(pFile, lrc1Errno);
      rc = lrc1;
      goto afp_end_lock;
    } else if( IS_LOCK_ERROR(lrc2) ){
      rc = lrc2;
      goto afp_end_lock;
    } else if( lrc1 != SQLITE_OK ) {
      rc = lrc1;
    } else {
      pFile->eFileLock = SHARED_LOCK;
      pInode->nLock++;
      pInode->nShared = 1;
    }
  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){
    /* We are trying for an exclusive lock but another thread in this
     ** same process is still holding a shared lock. */
    rc = SQLITE_BUSY;
  }else{
    /* The request was for a RESERVED or EXCLUSIVE lock.  It is
    ** assumed that there is a SHARED or greater lock on the file
    ** already.
    */
    int failed = 0;
    assert( 0!=pFile->eFileLock );
    if (eFileLock >= RESERVED_LOCK && pFile->eFileLock < RESERVED_LOCK) {
        /* Acquire a RESERVED lock */
        failed = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);
      if( !failed ){
        context->reserved = 1;
      }
    }
    if (!failed && eFileLock == EXCLUSIVE_LOCK) {
      /* Acquire an EXCLUSIVE lock */
        
      /* Remove the shared lock before trying the range.  we'll need to 
      ** reestablish the shared lock if we can't get the  afpUnlock
      */
      if( !(failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST +
                         pInode->sharedByte, 1, 0)) ){
        int failed2 = SQLITE_OK;
        /* now attemmpt to get the exclusive lock range */
        failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST, 
                               SHARED_SIZE, 1);
        if( failed && (failed2 = afpSetLock(context->dbPath, pFile, 
                       SHARED_FIRST + pInode->sharedByte, 1, 1)) ){
          /* Can't reestablish the shared lock.  Sqlite can't deal, this is
          ** a critical I/O error
          */
          rc = ((failed & 0xff) == SQLITE_IOERR) ? failed2 : 
               SQLITE_IOERR_LOCK;
          goto afp_end_lock;
        } 
      }else{
        rc = failed; 
      }
    }
    if( failed ){
      rc = failed;
    }
  }
  
  if( rc==SQLITE_OK ){
    pFile->eFileLock = eFileLock;
    pInode->eFileLock = eFileLock;
  }else if( eFileLock==EXCLUSIVE_LOCK ){
    pFile->eFileLock = PENDING_LOCK;
    pInode->eFileLock = PENDING_LOCK;
  }
  
afp_end_lock:
  sqlite3_mutex_leave(pInode->pLockMutex);
  OSTRACE(("LOCK    %d %s %s (afp)\n", pFile->h, azFileLock(eFileLock), 
         rc==SQLITE_OK ? "ok" : "failed"));
  return rc;
}

/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/
static int afpUnlock(sqlite3_file *id, int eFileLock) {
  int rc = SQLITE_OK;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;
  int skipShared = 0;
#ifdef SQLITE_TEST
  int h = pFile->h;
#endif

  assert( pFile );
  OSTRACE(("UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\n", pFile->h, eFileLock,
           pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,
           osGetpid(0)));

  assert( eFileLock<=SHARED_LOCK );
  if( pFile->eFileLock<=eFileLock ){
    return SQLITE_OK;
  }
  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);
  assert( pInode->nShared!=0 );
  if( pFile->eFileLock>SHARED_LOCK ){
    assert( pInode->eFileLock==pFile->eFileLock );
    SimulateIOErrorBenign(1);
    SimulateIOError( h=(-1) )
    SimulateIOErrorBenign(0);
    
#ifdef SQLITE_DEBUG
    /* When reducing a lock such that other processes can start
    ** reading the database file again, make sure that the
    ** transaction counter was updated if any part of the database
    ** file changed.  If the transaction counter is not updated,
    ** other connections to the same file might not realize that
    ** the file has changed and hence might not know to flush their
    ** cache.  The use of a stale cache can lead to database corruption.
    */
    assert( pFile->inNormalWrite==0
           || pFile->dbUpdate==0
           || pFile->transCntrChng==1 );
    pFile->inNormalWrite = 0;
#endif
    
    if( pFile->eFileLock==EXCLUSIVE_LOCK ){
      rc = afpSetLock(context->dbPath, pFile, SHARED_FIRST, SHARED_SIZE, 0);
      if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1) ){
        /* only re-establish the shared lock if necessary */
        int sharedLockByte = SHARED_FIRST+pInode->sharedByte;
        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);
      } else {
        skipShared = 1;
      }
    }
    if( rc==SQLITE_OK && pFile->eFileLock>=PENDING_LOCK ){
      rc = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);
    } 
    if( rc==SQLITE_OK && pFile->eFileLock>=RESERVED_LOCK && context->reserved ){
      rc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);
      if( !rc ){ 
        context->reserved = 0; 
      }
    }
    if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1)){
      pInode->eFileLock = SHARED_LOCK;
    }
  }
  if( rc==SQLITE_OK && eFileLock==NO_LOCK ){

    /* Decrement the shared lock counter.  Release the lock using an
    ** OS call only when all threads in this same process have released
    ** the lock.
    */
    unsigned long long sharedLockByte = SHARED_FIRST+pInode->sharedByte;
    pInode->nShared--;
    if( pInode->nShared==0 ){
      SimulateIOErrorBenign(1);
      SimulateIOError( h=(-1) )
      SimulateIOErrorBenign(0);
      if( !skipShared ){
        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);
      }
      if( !rc ){
        pInode->eFileLock = NO_LOCK;
        pFile->eFileLock = NO_LOCK;
      }
    }
    if( rc==SQLITE_OK ){
      pInode->nLock--;
      assert( pInode->nLock>=0 );
      if( pInode->nLock==0 ) closePendingFds(pFile);
    }
  }
  
  sqlite3_mutex_leave(pInode->pLockMutex);
  if( rc==SQLITE_OK ){
    pFile->eFileLock = eFileLock;
  }
  return rc;
}

/*
** Close a file & cleanup AFP specific locking context 
*/
static int afpClose(sqlite3_file *id) {
  int rc = SQLITE_OK;
  unixFile *pFile = (unixFile*)id;
  assert( id!=0 );
  afpUnlock(id, NO_LOCK);
  assert( unixFileMutexNotheld(pFile) );
  unixEnterMutex();
  if( pFile->pInode ){
    unixInodeInfo *pInode = pFile->pInode;
    sqlite3_mutex_enter(pInode->pLockMutex);
    if( pInode->nLock ){
      /* If there are outstanding locks, do not actually close the file just
      ** yet because that would clear those locks.  Instead, add the file
      ** descriptor to pInode->aPending.  It will be automatically closed when
      ** the last lock is cleared.
      */
      setPendingFd(pFile);
    }
    sqlite3_mutex_leave(pInode->pLockMutex);
  }
  releaseInodeInfo(pFile);
  sqlite3_free(pFile->lockingContext);
  rc = closeUnixFile(id);
  unixLeaveMutex();
  return rc;
}

#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */
/*
** The code above is the AFP lock implementation.  The code is specific
** to MacOSX and does not work on other unix platforms.  No alternative
** is available.  If you don't compile for a mac, then the "unix-afp"
** VFS is not available.
**
********************* End of the AFP lock implementation **********************
******************************************************************************/

/******************************************************************************
*************************** Begin NFS Locking ********************************/

#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
/*
 ** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
 ** must be either NO_LOCK or SHARED_LOCK.
 **
 ** If the locking level of the file descriptor is already at or below
 ** the requested locking level, this routine is a no-op.
 */
static int nfsUnlock(sqlite3_file *id, int eFileLock){
  return posixUnlock(id, eFileLock, 1);
}

#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */
/*
** The code above is the NFS lock implementation.  The code is specific
** to MacOSX and does not work on other unix platforms.  No alternative
** is available.  
**
********************* End of the NFS lock implementation **********************
******************************************************************************/

/******************************************************************************
**************** Non-locking sqlite3_file methods *****************************
**
** The next division contains implementations for all methods of the 
** sqlite3_file object other than the locking methods.  The locking
** methods were defined in divisions above (one locking method per
** division).  Those methods that are common to all locking modes
** are gather together into this division.
*/

/*
** Seek to the offset passed as the second argument, then read cnt 
** bytes into pBuf. Return the number of bytes actually read.
**
** NB:  If you define USE_PREAD or USE_PREAD64, then it might also
** be necessary to define _XOPEN_SOURCE to be 500.  This varies from
** one system to another.  Since SQLite does not define USE_PREAD
** in any form by default, we will not attempt to define _XOPEN_SOURCE.
** See tickets #2741 and #2681.
**
** To avoid stomping the errno value on a failed read the lastErrno value
** is set before returning.
*/
static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
  int got;
  int prior = 0;
#if (!defined(USE_PREAD) && !defined(USE_PREAD64))
  i64 newOffset;
#endif
  TIMER_START;
  assert( cnt==(cnt&0x1ffff) );
  assert( id->h>2 );
  
// ABS Label 352
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}

// ROR Label 353
if((got <= 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 353);
}
// ROR Label 354
if((got < 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}
// ROR Label 355
if((got >= 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}
do{
#if defined(USE_PREAD)
    got = osPread(id->h, pBuf, cnt, offset);
    SimulateIOError( got = -1 );
#elif defined(USE_PREAD64)
    got = osPread64(id->h, pBuf, cnt, offset);
    SimulateIOError( got = -1 );
#else
    newOffset = lseek(id->h, offset, SEEK_SET);
    SimulateIOError( newOffset = -1 );
    
// ABS Label 360
if(newOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}

// ROR Label 361
if((newOffset <= 0) != (newOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 361);
}
// ROR Label 362
if((newOffset > 0) != (newOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}
// ROR Label 363
if((newOffset >= 0) != (newOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}
if( newOffset<0 ){
      
// ABS Label 364
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
storeLastErrno((unixFile*)id, errno);
      return -1;
    }
    got = osRead(id->h, pBuf, cnt);
#endif
    
// ABS Label 365
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
// ABS Label 366
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}

// ROR Label 367
if((got != cnt) != (got == cnt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}
if( got==cnt ) { break;
}
    
// ABS Label 368
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}

// ROR Label 369
if((got <= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}
// ROR Label 370
if((got > 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 370);
}
// ROR Label 371
if((got >= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 371);
}
if( got<0 ){
      
// ABS Label 373
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// ROR Label 374
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 374);
}
if( errno==EINTR ){ got = 1; continue; }
      prior = 0;
      
// ABS Label 372
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
storeLastErrno((unixFile*)id,  errno);
      break;
    }else { 
// ABS Label 375
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}

// ROR Label 376
if((got <= 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((got < 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((got >= 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
if( got>0 ){
      cnt -= got;
      offset += got;
      prior += got;
      pBuf = (void*)(got + (char*)pBuf);
    };}

  }while( got>0 );
// ABS Label 356
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ROR Label 357
if((got <= 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
// ROR Label 358
if((got < 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}
// ROR Label 359
if((got >= 0) != (got > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}
;
  TIMER_END;
  OSTRACE(("READ    %-3d %5d %7lld %llu\n",
            id->h, got+prior, offset-prior, TIMER_ELAPSED));
  
// ABS Label 379
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}
// ABS Label 380
if(prior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}

// AOR Label 381
if(got - prior != got + prior)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 381);
}
// AOR Label 382
if(got / prior != got + prior)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 382);
}
// AOR Label 383
if(got * prior != got + prior)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 383);
}
return got+prior;
}

/*
** Read data from a file into a buffer.  Return SQLITE_OK if all
** bytes were read successfully and SQLITE_IOERR if anything goes
** wrong.
*/
static int unixRead(
  sqlite3_file *id, 
  void *pBuf, 
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile *)id;
  int got;
  assert( id );
  assert( offset>=0 );
  assert( amt>0 );

  /* If this is a database file (not a journal, super-journal or temp
  ** file), the bytes in the locking range should never be read or written. */
#if 0
  assert( pFile->pPreallocatedUnused==0
       || offset>=PENDING_BYTE+512
       || offset+amt<=PENDING_BYTE 
  );
#endif

#if SQLITE_MAX_MMAP_SIZE>0
  /* Deal with as much of this read request as possible by transfering
  ** data from the memory mapping using memcpy().  */
  
// ABS Label 384
if(offset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}
// ABS Label 385
if(pFile->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}

// ROR Label 386
if((offset <= pFile->mmapSize) != (offset < pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
// ROR Label 387
if((offset > pFile->mmapSize) != (offset < pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 387);
}
// ROR Label 388
if((offset >= pFile->mmapSize) != (offset < pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 388);
}
if( offset<pFile->mmapSize ){
    
// ABS Label 389
if(offset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}
// ABS Label 390
if(pFile->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}

// AOR Label 391
if(offset - amt != offset + amt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 391);
}
// AOR Label 392
if(offset / amt != offset + amt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 392);
}
// AOR Label 393
if(offset * amt != offset + amt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 393);
}

// ROR Label 394
if((offset + amt < pFile->mmapSize) != (offset + amt <= pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 394);
}
// ROR Label 395
if((offset + amt > pFile->mmapSize) != (offset + amt <= pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 395);
}
// ROR Label 396
if((offset + amt >= pFile->mmapSize) != (offset + amt <= pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 396);
}
if( offset+amt <= pFile->mmapSize ){
      
// ABS Label 397
if(pBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
      return SQLITE_OK;
    }else{
      int nCopy = pFile->mmapSize - offset;
      
// ABS Label 398
if(pBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}
memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
      pBuf = &((u8 *)pBuf)[nCopy];
      amt -= nCopy;
      offset += nCopy;
    }
  }
#endif

  got = seekAndRead(pFile, offset, pBuf, amt);
  
// ABS Label 399
if(amt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}
// ABS Label 400
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}

// ROR Label 401
if((got != amt) != (got == amt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 401);
}
if( got==amt ){
    return SQLITE_OK;
  }else { 
// ABS Label 402
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}

// ROR Label 403
if((got <= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
// ROR Label 404
if((got > 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 404);
}
// ROR Label 405
if((got >= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 405);
}
if( got<0 ){
    /* pFile->lastErrno has been set by seekAndRead().
    ** Usually we return SQLITE_IOERR_READ here, though for some
    ** kinds of errors we return SQLITE_IOERR_CORRUPTFS.  The
    ** SQLITE_IOERR_CORRUPTFS will be converted into SQLITE_CORRUPT
    ** prior to returning to the application by the sqlite3ApiExit()
    ** routine.
    */
    switch( pFile->lastErrno ){
      case ERANGE:
      case EIO:
#ifdef ENXIO
      case ENXIO:
#endif
#ifdef EDEVERR
      case EDEVERR:
#endif
        
// MCC Label 406
if(( 10 | (33 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 406);
}
// MCC Label 407
if(( !(10 | (33 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 407);
}
return SQLITE_IOERR_CORRUPTFS;
    }
    
// MCC Label 408
if(( 10 | (1 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 408);
}
// MCC Label 409
if(( !(10 | (1 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 409);
}
return SQLITE_IOERR_READ;
  }else{
    
// ABS Label 410
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}
storeLastErrno(pFile, 0);   /* not a system error */
    /* Unread parts of the buffer must be zero-filled */
    memset(&((char*)pBuf)[got], 0, amt-got);
    
// MCC Label 411
if(( 10 | (2 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
// MCC Label 412
if(( !(10 | (2 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
return SQLITE_IOERR_SHORT_READ;
  };}

}

/*
** Attempt to seek the file-descriptor passed as the first argument to
** absolute offset iOff, then attempt to write nBuf bytes of data from
** pBuf to it. If an error occurs, return -1 and set *piErrno. Otherwise, 
** return the actual number of bytes written (which may be less than
** nBuf).
*/
static int seekAndWriteFd(
  int fd,                         /* File descriptor to write to */
  i64 iOff,                       /* File offset to begin writing at */
  const void *pBuf,               /* Copy data from this buffer to the file */
  int nBuf,                       /* Size of buffer pBuf in bytes */
  int *piErrno                    /* OUT: Error number if error occurs */
){
  int rc = 0;                     /* Value returned by system call */

  assert( nBuf==(nBuf&0x1ffff) );
  assert( fd>2 );
  assert( piErrno!=0 );
  nBuf &= 0x1ffff;
  TIMER_START;

#if defined(USE_PREAD)
  do{ rc = (int)osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );
#elif defined(USE_PREAD64)
  do{ rc = (int)osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);
#else
  
// ABS Label 413
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
// ABS Label 414
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// COR Label 415
if((rc < 0 || (*__errno_location()) == 4) != (rc < 0 && (*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 415);
}

// ROR Label 416
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 416);
}
// ROR Label 417
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 417);
}
// ROR Label 418
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 418);
}
// ROR Label 419
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}

// MCC Label 420
if(rc < 0 && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 420);
}
// MCC Label 421
if(rc < 0 && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 421);
}
// MCC Label 422
if(!(rc < 0) && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 422);
}
// MCC Label 423
if(!(rc < 0) && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 423);
}
do{
    i64 iSeek = lseek(fd, iOff, SEEK_SET);
    SimulateIOError( iSeek = -1 );
    
// ABS Label 435
if(iSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}

// ROR Label 436
if((iSeek <= 0) != (iSeek < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((iSeek > 0) != (iSeek < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
// ROR Label 438
if((iSeek >= 0) != (iSeek < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}
if( iSeek<0 ){
      rc = -1;
      break;
    }
    rc = osWrite(fd, pBuf, nBuf);
  }while( rc<0 && errno==EINTR );
// ABS Label 424
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}
// ABS Label 425
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}

// COR Label 426
if((rc < 0 || (*__errno_location()) == 4) != (rc < 0 && (*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 426);
}

// ROR Label 427
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
// ROR Label 428
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 428);
}
// ROR Label 429
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 429);
}
// ROR Label 430
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}

// MCC Label 431
if(rc < 0 && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 431);
}
// MCC Label 432
if(rc < 0 && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 432);
}
// MCC Label 433
if(!(rc < 0) && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 433);
}
// MCC Label 434
if(!(rc < 0) && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 434);
}
;
#endif

  TIMER_END;
  OSTRACE(("WRITE   %-3d %5d %7lld %llu\n", fd, rc, iOff, TIMER_ELAPSED));

  
// ABS Label 439
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 439);
}

// ROR Label 440
if((rc <= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 440);
}
// ROR Label 441
if((rc > 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 441);
}
// ROR Label 442
if((rc >= 0) != (rc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 442);
}
if( rc<0 ) { *piErrno = errno;
}
  
// ABS Label 443
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}
return rc;
}


/*
** Seek to the offset in id->offset then read cnt bytes into pBuf.
** Return the number of bytes actually read.  Update the offset.
**
** To avoid stomping the errno value on a failed write the lastErrno value
** is set before returning.
*/
static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){
  return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);
}


/*
** Write data from a buffer into a file.  Return SQLITE_OK on success
** or some other error code on failure.
*/
static int unixWrite(
  sqlite3_file *id, 
  const void *pBuf, 
  int amt,
  sqlite3_int64 offset 
){
  unixFile *pFile = (unixFile*)id;
  int wrote = 0;
  assert( id );
  assert( amt>0 );

  /* If this is a database file (not a journal, super-journal or temp
  ** file), the bytes in the locking range should never be read or written. */
#if 0
  assert( pFile->pPreallocatedUnused==0
       || offset>=PENDING_BYTE+512
       || offset+amt<=PENDING_BYTE 
  );
#endif

#ifdef SQLITE_DEBUG
  /* If we are doing a normal write to a database file (as opposed to
  ** doing a hot-journal rollback or a write to some file other than a
  ** normal database file) then record the fact that the database
  ** has changed.  If the transaction counter is modified, record that
  ** fact too.
  */
  if( pFile->inNormalWrite ){
    pFile->dbUpdate = 1;  /* The database has been modified */
    if( offset<=24 && offset+amt>=27 ){
      int rc;
      char oldCntr[4];
      SimulateIOErrorBenign(1);
      rc = seekAndRead(pFile, 24, oldCntr, 4);
      SimulateIOErrorBenign(0);
      if( rc!=4 || memcmp(oldCntr, &((char*)pBuf)[24-offset], 4)!=0 ){
        pFile->transCntrChng = 1;  /* The transaction counter has changed */
      }
    }
  }
#endif

#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0
  /* Deal with as much of this write request as possible by transfering
  ** data from the memory mapping using memcpy().  */
  if( offset<pFile->mmapSize ){
    if( offset+amt <= pFile->mmapSize ){
      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);
      return SQLITE_OK;
    }else{
      int nCopy = pFile->mmapSize - offset;
      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);
      pBuf = &((u8 *)pBuf)[nCopy];
      amt -= nCopy;
      offset += nCopy;
    }
  }
#endif
 
  while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){
    amt -= wrote;
    offset += wrote;
    pBuf = &((char*)pBuf)[wrote];
  };
  SimulateIOError(( wrote=(-1), amt=1 ));
  SimulateDiskfullError(( wrote=0, amt=1 ));

  
// ABS Label 444
if(amt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
// ABS Label 445
if(wrote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// ROR Label 446
if((amt <= wrote) != (amt > wrote))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 446);
}
// ROR Label 447
if((amt < wrote) != (amt > wrote))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((amt >= wrote) != (amt > wrote))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
if( amt>wrote ){
    
// ABS Label 449
if(pFile->lastErrno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}
// ABS Label 450
if(wrote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}

// COR Label 451
if((wrote < 0 || pFile->lastErrno != 28) != (wrote < 0 && pFile->lastErrno != 28))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 451);
}

// ROR Label 452
if((wrote <= 0) != (wrote < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 452);
}
// ROR Label 453
if((wrote > 0) != (wrote < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}
// ROR Label 454
if((wrote >= 0) != (wrote < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 454);
}
// ROR Label 455
if((pFile->lastErrno == 28) != (pFile->lastErrno != 28))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}

// MCC Label 456
if(wrote < 0 && pFile->lastErrno != 28 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 456);
}
// MCC Label 457
if(wrote < 0 && !(pFile->lastErrno != 28) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 457);
}
// MCC Label 458
if(!(wrote < 0) && pFile->lastErrno != 28 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 458);
}
// MCC Label 459
if(!(wrote < 0) && !(pFile->lastErrno != 28) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 459);
}
if( wrote<0 && pFile->lastErrno!=ENOSPC ){
      /* lastErrno set by seekAndWrite */
      
// MCC Label 460
if(( 10 | (3 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 460);
}
// MCC Label 461
if(( !(10 | (3 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 461);
}
return SQLITE_IOERR_WRITE;
    }else{
      
// ABS Label 462
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 462);
}
storeLastErrno(pFile, 0); /* not a system error */
      return SQLITE_FULL;
    }
  }

  return SQLITE_OK;
}

#ifdef SQLITE_TEST
/*
** Count the number of fullsyncs and normal syncs.  This is used to test
** that syncs and fullsyncs are occurring at the right times.
*/
int sqlite3_sync_count = 0;
int sqlite3_fullsync_count = 0;
#endif

/*
** We do not trust systems to provide a working fdatasync().  Some do.
** Others do no.  To be safe, we will stick with the (slightly slower)
** fsync(). If you know that your system does support fdatasync() correctly,
** then simply compile with -Dfdatasync=fdatasync or -DHAVE_FDATASYNC
*/
#if !defined(fdatasync) && !HAVE_FDATASYNC
# define fdatasync fsync
#endif

/*
** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or not
** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currently
** only available on Mac OS X.  But that could change.
*/
#ifdef F_FULLFSYNC
# define HAVE_FULLFSYNC 1
#else
# define HAVE_FULLFSYNC 0
#endif


/*
** The fsync() system call does not work as advertised on many
** unix systems.  The following procedure is an attempt to make
** it work better.
**
** The SQLITE_NO_SYNC macro disables all fsync()s.  This is useful
** for testing when we want to run through the test suite quickly.
** You are strongly advised *not* to deploy with SQLITE_NO_SYNC
** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crash
** or power failure will likely corrupt the database file.
**
** SQLite sets the dataOnly flag if the size of the file is unchanged.
** The idea behind dataOnly is that it should only write the file content
** to disk, not the inode.  We only set dataOnly if the file size is 
** unchanged since the file size is part of the inode.  However, 
** Ted Ts'o tells us that fdatasync() will also write the inode if the
** file size has changed.  The only real difference between fdatasync()
** and fsync(), Ted tells us, is that fdatasync() will not flush the
** inode if the mtime or owner or other inode attributes have changed.
** We only care about the file size, not the other file attributes, so
** as far as SQLite is concerned, an fdatasync() is always adequate.
** So, we always use fdatasync() if it is available, regardless of
** the value of the dataOnly flag.
*/
static int full_fsync(int fd, int fullSync, int dataOnly){
  int rc;

  /* The following "ifdef/elif/else/" block has the same structure as
  ** the one below. It is replicated here solely to avoid cluttering 
  ** up the real code with the UNUSED_PARAMETER() macros.
  */
#ifdef SQLITE_NO_SYNC
  UNUSED_PARAMETER(fd);
  UNUSED_PARAMETER(fullSync);
  UNUSED_PARAMETER(dataOnly);
#elif HAVE_FULLFSYNC
  UNUSED_PARAMETER(dataOnly);
#else
  UNUSED_PARAMETER(fullSync);
  UNUSED_PARAMETER(dataOnly);
#endif

  /* Record the number of times that we do a normal fsync() and 
  ** FULLSYNC.  This is used during testing to verify that this procedure
  ** gets called with the correct arguments.
  */
#ifdef SQLITE_TEST
  if( fullSync ) sqlite3_fullsync_count++;
  sqlite3_sync_count++;
#endif

  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a
  ** no-op.  But go ahead and call fstat() to validate the file
  ** descriptor as we need a method to provoke a failure during
  ** coverate testing.
  */
#ifdef SQLITE_NO_SYNC
  {
    struct stat buf;
    rc = osFstat(fd, &buf);
  }
#elif HAVE_FULLFSYNC
  if( fullSync ){
    rc = osFcntl(fd, F_FULLFSYNC, 0);
  }else{
    rc = 1;
  }
  /* If the FULLFSYNC failed, fall back to attempting an fsync().
  ** It shouldn't be possible for fullfsync to fail on the local 
  ** file system (on OSX), so failure indicates that FULLFSYNC
  ** isn't supported for this file system. So, attempt an fsync 
  ** and (for now) ignore the overhead of a superfluous fcntl call.  
  ** It'd be better to detect fullfsync support once and avoid 
  ** the fcntl call every time sync is called.
  */
  if( rc ) rc = fsync(fd);

#elif defined(__APPLE__)
  /* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctly
  ** so currently we default to the macro that redefines fdatasync to fsync
  */
  rc = fsync(fd);
#else 
  rc = fdatasync(fd);
#if OS_VXWORKS
  if( rc==-1 && errno==ENOTSUP ){
    rc = fsync(fd);
  }
#endif /* OS_VXWORKS */
#endif /* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */

  
// ABS Label 463
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}

// COR Label 464
if((0 || rc != -1) != (0 && rc != -1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 464);
}

// ROR Label 465
if((rc == -1) != (rc != -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}

// MCC Label 466
if(0 && rc != -1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 466);
}
// MCC Label 467
if(0 && !(rc != -1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 467);
}
// MCC Label 468
if(!(0) && rc != -1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 468);
}
// MCC Label 469
if(!(0) && !(rc != -1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 469);
}
if( OS_VXWORKS && rc!= -1 ){
    rc = 0;
  }
  
// ABS Label 470
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}
return rc;
}

/*
** Open a file descriptor to the directory containing file zFilename.
** If successful, *pFd is set to the opened file descriptor and
** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEM
** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined
** value.
**
** The directory file descriptor is used for only one thing - to
** fsync() a directory to make sure file creation and deletion events
** are flushed to disk.  Such fsyncs are not needed on newer
** journaling filesystems, but are required on older filesystems.
**
** This routine can be overridden using the xSetSysCall interface.
** The ability to override this routine was added in support of the
** chromium sandbox.  Opening a directory is a security risk (we are
** told) so making it overrideable allows the chromium sandbox to
** replace this routine with a harmless no-op.  To make this routine
** a no-op, replace it with a stub that returns SQLITE_OK but leaves
** *pFd set to a negative number.
**
** If SQLITE_OK is returned, the caller is responsible for closing
** the file descriptor *pFd using close().
*/
static int openDirectory(const char *zFilename, int *pFd){
  int ii;
  int fd = -1;
  char zDirname[MAX_PATHNAME+1];

  
// ABS Label 471
if(zFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}
sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename);
  ii = (int)strlen(zDirname);

// ABS Label 472
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}

// COR Label 473
if((ii > 0 || zDirname[ii] != '/') != (ii > 0 && zDirname[ii] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 473);
}

// ROR Label 474
if((ii <= 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 474);
}
// ROR Label 475
if((ii < 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 475);
}
// ROR Label 476
if((ii >= 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 476);
}
// ROR Label 477
if((zDirname[ii] == '/') != (zDirname[ii] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 477);
}

// MCC Label 478
if(ii > 0 && zDirname[ii] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 478);
}
// MCC Label 479
if(ii > 0 && !(zDirname[ii] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 479);
}
// MCC Label 480
if(!(ii > 0) && zDirname[ii] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 480);
}
// MCC Label 481
if(!(ii > 0) && !(zDirname[ii] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 481);
}
for(; ii>0 && zDirname[ii]!='/'; ii--) {;
};
// ABS Label 482
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}

// COR Label 483
if((ii > 0 || zDirname[ii] != '/') != (ii > 0 && zDirname[ii] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 483);
}

// ROR Label 484
if((ii <= 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 484);
}
// ROR Label 485
if((ii < 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 485);
}
// ROR Label 486
if((ii >= 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 486);
}
// ROR Label 487
if((zDirname[ii] == '/') != (zDirname[ii] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 487);
}

// MCC Label 488
if(ii > 0 && zDirname[ii] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 488);
}
// MCC Label 489
if(ii > 0 && !(zDirname[ii] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 489);
}
// MCC Label 490
if(!(ii > 0) && zDirname[ii] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 490);
}
// MCC Label 491
if(!(ii > 0) && !(zDirname[ii] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 491);
}

  
// ABS Label 492
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}

// ROR Label 493
if((ii <= 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}
// ROR Label 494
if((ii < 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
// ROR Label 495
if((ii >= 0) != (ii > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}
if( ii>0 ){
    zDirname[ii] = '\0';
  }else{
    
// ROR Label 496
if((zDirname[0] == '/') != (zDirname[0] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 496);
}
if( zDirname[0]!='/' ) { zDirname[0] = '.';
}
    zDirname[1] = 0;
  }
  fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);
  
// ABS Label 497
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// ROR Label 498
if((fd < 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}
// ROR Label 499
if((fd > 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 499);
}
// ROR Label 500
if((fd <= 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 500);
}
if( fd>=0 ){
    OSTRACE(("OPENDIR %-3d %s\n", fd, zDirname));
  }
  *pFd = fd;
  
// ABS Label 501
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}

// ROR Label 502
if((fd < 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 502);
}
// ROR Label 503
if((fd > 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 503);
}
// ROR Label 504
if((fd <= 0) != (fd >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 504);
}
if( fd>=0 ) { return SQLITE_OK;
}
  return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname);
}

/*
** Make sure all writes to a particular file are committed to disk.
**
** If dataOnly==0 then both the file itself and its metadata (file
** size, access time, etc) are synced.  If dataOnly!=0 then only the
** file data is synced.
**
** Under Unix, also make sure that the directory entry for the file
** has been created by fsync-ing the directory that contains the file.
** If we do not do this and we encounter a power failure, the directory
** entry for the journal might not exist after we reboot.  The next
** SQLite to access the file will not know that the journal exists (because
** the directory entry for the journal was never created) and the transaction
** will not roll back - possibly leading to database corruption.
*/
static int unixSync(sqlite3_file *id, int flags){
  int rc;
  unixFile *pFile = (unixFile*)id;

  int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);
  
// ROR Label 505
if(((flags & 15) != 3) != ((flags & 15) == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 505);
}
int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL;

  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */
  assert((flags&0x0F)==SQLITE_SYNC_NORMAL
      || (flags&0x0F)==SQLITE_SYNC_FULL
  );

  /* Unix cannot, but some systems may return SQLITE_FULL from here. This
  ** line is to test that doing so does not cause any problems.
  */
  SimulateDiskfullError( return SQLITE_FULL );

  assert( pFile );
  OSTRACE(("SYNC    %-3d\n", pFile->h));
  rc = full_fsync(pFile->h, isFullsync, isDataOnly);
  SimulateIOError( rc=1 );
  
// ABS Label 506
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 506);
}
if( rc ){
    
// ABS Label 507
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 507);
}

// ABS Label 508
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}
storeLastErrno(pFile, errno);
    return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);
  }

  /* Also fsync the directory containing the file if the DIRSYNC flag
  ** is set.  This is a one-time occurrence.  Many systems (examples: AIX)
  ** are unable to fsync a directory, so ignore errors on the fsync.
  */
  
// AOR Label 509
if(pFile->ctrlFlags | 8 != pFile->ctrlFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 509);
}
// AOR Label 510
if(pFile->ctrlFlags ^ 8 != pFile->ctrlFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 510);
}
if( pFile->ctrlFlags & UNIXFILE_DIRSYNC ){
    int dirfd;
    OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,
            HAVE_FULLFSYNC, isFullsync));
    rc = osOpenDirectory(pFile->zPath, &dirfd);
    
// ABS Label 511
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}

// ROR Label 512
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 512);
}
if( rc==SQLITE_OK ){
      
// ABS Label 513
if(dirfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}
full_fsync(dirfd, 0, 0);
      
// ABS Label 514
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}

// ABS Label 515
if(dirfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}
robust_close(pFile, dirfd, __LINE__);
    }else{
      assert( rc==SQLITE_CANTOPEN );
      rc = SQLITE_OK;
    }
    pFile->ctrlFlags &= ~UNIXFILE_DIRSYNC;
  }
  
// ABS Label 516
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}
return rc;
}

/*
** Truncate an open file to a specified size
*/
static int unixTruncate(sqlite3_file *id, i64 nByte){
  unixFile *pFile = (unixFile *)id;
  int rc;
  assert( pFile );
  SimulateIOError( return SQLITE_IOERR_TRUNCATE );

  /* If the user has configured a chunk-size for this file, truncate the
  ** file so that it consists of an integer number of chunks (i.e. the
  ** actual file size after the operation may be larger than the requested
  ** size).
  */
  
// ABS Label 517
if(pFile->szChunk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}

// ROR Label 518
if((pFile->szChunk <= 0) != (pFile->szChunk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 518);
}
// ROR Label 519
if((pFile->szChunk < 0) != (pFile->szChunk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 519);
}
// ROR Label 520
if((pFile->szChunk >= 0) != (pFile->szChunk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 520);
}
if( pFile->szChunk>0 ){
    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;
  }

  rc = robust_ftruncate(pFile->h, nByte);
  
// ABS Label 521
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}
if( rc ){
    
// ABS Label 522
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 522);
}

// ABS Label 523
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}
storeLastErrno(pFile, errno);
    return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);
  }else{
#ifdef SQLITE_DEBUG
    /* If we are doing a normal write to a database file (as opposed to
    ** doing a hot-journal rollback or a write to some file other than a
    ** normal database file) and we truncate the file to zero length,
    ** that effectively updates the change counter.  This might happen
    ** when restoring a database using the backup API from a zero-length
    ** source.
    */
    if( pFile->inNormalWrite && nByte==0 ){
      pFile->transCntrChng = 1;
    }
#endif

#if SQLITE_MAX_MMAP_SIZE>0
    /* If the file was just truncated to a size smaller than the currently
    ** mapped region, reduce the effective mapping size as well. SQLite will
    ** use read() and write() to access data beyond this point from now on.  
    */
    
// ABS Label 524
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}
// ABS Label 525
if(pFile->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}

// ROR Label 526
if((nByte <= pFile->mmapSize) != (nByte < pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 526);
}
// ROR Label 527
if((nByte > pFile->mmapSize) != (nByte < pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 527);
}
// ROR Label 528
if((nByte >= pFile->mmapSize) != (nByte < pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 528);
}
if( nByte<pFile->mmapSize ){
      pFile->mmapSize = nByte;
    }
#endif

    return SQLITE_OK;
  }
}

/*
** Determine the current size of a file in bytes
*/
static int unixFileSize(sqlite3_file *id, i64 *pSize){
  int rc;
  struct stat buf;
  assert( id );
  rc = osFstat(((unixFile*)id)->h, &buf);
  SimulateIOError( rc=1 );
  
// ABS Label 529
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// ROR Label 530
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 530);
}
if( rc!=0 ){
    
// ABS Label 531
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 531);
}
storeLastErrno((unixFile*)id, errno);
    
// MCC Label 532
if(( 10 | (7 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 532);
}
// MCC Label 533
if(( !(10 | (7 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 533);
}
return SQLITE_IOERR_FSTAT;
  }
  *pSize = buf.st_size;

  /* When opening a zero-size database, the findInodeInfo() procedure
  ** writes a single byte into that file in order to work around a bug
  ** in the OS-X msdos filesystem.  In order to avoid problems with upper
  ** layers, we need to report this file size as zero even though it is
  ** really 1.   Ticket #3260.
  */
  
// ABS Label 534
if(*pSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}

// ROR Label 535
if((*pSize != 1) != (*pSize == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 535);
}
if( *pSize==1 ) { *pSize = 0;
}


  return SQLITE_OK;
}

#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
/*
** Handler for proxy-locking file-control verbs.  Defined below in the
** proxying locking division.
*/
static int proxyFileControl(sqlite3_file*,int,void*);
#endif

/* 
** This function is called to handle the SQLITE_FCNTL_SIZE_HINT 
** file-control operation.  Enlarge the database to nBytes in size
** (rounded up to the next chunk-size).  If the database is already
** nBytes or larger, this routine is a no-op.
*/
static int fcntlSizeHint(unixFile *pFile, i64 nByte){
  
// ABS Label 536
if(pFile->szChunk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}

// ROR Label 537
if((pFile->szChunk <= 0) != (pFile->szChunk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 537);
}
// ROR Label 538
if((pFile->szChunk < 0) != (pFile->szChunk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 538);
}
// ROR Label 539
if((pFile->szChunk >= 0) != (pFile->szChunk > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 539);
}
if( pFile->szChunk>0 ){
    i64 nSize;                    /* Required file size */
    struct stat buf;              /* Used to hold return values of fstat() */
   
    if( osFstat(pFile->h, &buf) ){
      
// MCC Label 540
if(( 10 | (7 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 540);
}
// MCC Label 541
if(( !(10 | (7 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
return SQLITE_IOERR_FSTAT;
    }

    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
    
// ABS Label 542
if(nSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}

// ROR Label 543
if((nSize <= (i64)buf.st_size) != (nSize > (i64)buf.st_size))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 543);
}
// ROR Label 544
if((nSize < (i64)buf.st_size) != (nSize > (i64)buf.st_size))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 544);
}
// ROR Label 545
if((nSize >= (i64)buf.st_size) != (nSize > (i64)buf.st_size))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 545);
}
if( nSize>(i64)buf.st_size ){

#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
      /* The code below is handling the return value of osFallocate() 
      ** correctly. posix_fallocate() is defined to "returns zero on success, 
      ** or an error number on  failure". See the manpage for details. */
      int err;
      do{
        err = osFallocate(pFile->h, buf.st_size, nSize-buf.st_size);
      }while( err==EINTR );
      if( err && err!=EINVAL ) return SQLITE_IOERR_WRITE;
#else
      /* If the OS does not have posix_fallocate(), fake it. Write a 
      ** single byte to the last byte in each block that falls entirely
      ** within the extended region. Then, if required, a single byte
      ** at offset (nSize-1), to set the size of the file correctly.
      ** This is a similar technique to that used by glibc on systems
      ** that do not have a real fallocate() call.
      */
      int nBlk = buf.st_blksize;  /* File-system block size */
      int nWrite = 0;             /* Number of bytes written by seekAndWrite */
      i64 iWrite;                 /* Next offset to write to */

      iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;
      assert( iWrite>=buf.st_size );
      assert( ((iWrite+1)%nBlk)==0 );
      
// ABS Label 546
if(iWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}
// ABS Label 547
if(nSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}

// AOR Label 548
if(nSize + nBlk / 1 != nSize + nBlk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 548);
}
// AOR Label 549
if(nSize + nBlk + 1 != nSize + nBlk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 549);
}
// AOR Label 550
if(nSize + nBlk * 1 != nSize + nBlk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 550);
}
// AOR Label 551
if(nSize - nBlk != nSize + nBlk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 551);
}
// AOR Label 552
if(nSize / nBlk != nSize + nBlk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 552);
}
// AOR Label 553
if(nSize * nBlk != nSize + nBlk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 553);
}

// ROR Label 554
if((iWrite <= nSize + nBlk - 1) != (iWrite < nSize + nBlk - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 554);
}
// ROR Label 555
if((iWrite > nSize + nBlk - 1) != (iWrite < nSize + nBlk - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}
// ROR Label 556
if((iWrite >= nSize + nBlk - 1) != (iWrite < nSize + nBlk - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 556);
}
for(/*no-op*/; iWrite<nSize+nBlk-1; iWrite+=nBlk ){
        
// ABS Label 568
if(iWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 568);
}
// ABS Label 569
if(nSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 569);
}

// ROR Label 570
if((iWrite < nSize) != (iWrite >= nSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 570);
}
// ROR Label 571
if((iWrite > nSize) != (iWrite >= nSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}
// ROR Label 572
if((iWrite <= nSize) != (iWrite >= nSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
if( iWrite>=nSize ) { iWrite = nSize - 1;
}
        nWrite = seekAndWrite(pFile, iWrite, "", 1);
        
// ABS Label 573
if(nWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}

// ROR Label 574
if((nWrite == 1) != (nWrite != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 574);
}
if( nWrite!=1 ) { 
// MCC Label 575
if(( 10 | (3 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(( !(10 | (3 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
return SQLITE_IOERR_WRITE;
}
      };
// ABS Label 557
if(iWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}
// ABS Label 558
if(nSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// AOR Label 559
if(nSize + nBlk / 1 != nSize + nBlk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 559);
}
// AOR Label 560
if(nSize + nBlk + 1 != nSize + nBlk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 560);
}
// AOR Label 561
if(nSize + nBlk * 1 != nSize + nBlk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 561);
}
// AOR Label 562
if(nSize - nBlk != nSize + nBlk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 562);
}
// AOR Label 563
if(nSize / nBlk != nSize + nBlk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 563);
}
// AOR Label 564
if(nSize * nBlk != nSize + nBlk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 564);
}

// ROR Label 565
if((iWrite <= nSize + nBlk - 1) != (iWrite < nSize + nBlk - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 565);
}
// ROR Label 566
if((iWrite > nSize + nBlk - 1) != (iWrite < nSize + nBlk - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 566);
}
// ROR Label 567
if((iWrite >= nSize + nBlk - 1) != (iWrite < nSize + nBlk - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 567);
}

#endif
    }
  }

#if SQLITE_MAX_MMAP_SIZE>0
  
// ABS Label 577
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 577);
}
// ABS Label 578
if(pFile->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 578);
}
// ABS Label 579
if(pFile->mmapSizeMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}

// COR Label 580
if((pFile->mmapSizeMax > 0 || nByte > pFile->mmapSize) != (pFile->mmapSizeMax > 0 && nByte > pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 580);
}

// ROR Label 581
if((pFile->mmapSizeMax <= 0) != (pFile->mmapSizeMax > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 581);
}
// ROR Label 582
if((pFile->mmapSizeMax < 0) != (pFile->mmapSizeMax > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 582);
}
// ROR Label 583
if((pFile->mmapSizeMax >= 0) != (pFile->mmapSizeMax > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 583);
}
// ROR Label 584
if((nByte <= pFile->mmapSize) != (nByte > pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 584);
}
// ROR Label 585
if((nByte < pFile->mmapSize) != (nByte > pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 585);
}
// ROR Label 586
if((nByte >= pFile->mmapSize) != (nByte > pFile->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 586);
}

// MCC Label 587
if(pFile->mmapSizeMax > 0 && nByte > pFile->mmapSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 587);
}
// MCC Label 588
if(pFile->mmapSizeMax > 0 && !(nByte > pFile->mmapSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 588);
}
// MCC Label 589
if(!(pFile->mmapSizeMax > 0) && nByte > pFile->mmapSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 589);
}
// MCC Label 590
if(!(pFile->mmapSizeMax > 0) && !(nByte > pFile->mmapSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 590);
}
if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){
    int rc;
    
// ABS Label 591
if(pFile->szChunk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 591);
}

// ROR Label 592
if((pFile->szChunk < 0) != (pFile->szChunk <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}
// ROR Label 593
if((pFile->szChunk > 0) != (pFile->szChunk <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((pFile->szChunk >= 0) != (pFile->szChunk <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}
if( pFile->szChunk<=0 ){
      if( robust_ftruncate(pFile->h, nByte) ){
        
// ABS Label 595
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 595);
}

// ABS Label 596
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}
storeLastErrno(pFile, errno);
        return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);
      }
    }

    rc = unixMapfile(pFile, nByte);
    
// ABS Label 597
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 597);
}
return rc;
  }
#endif

  return SQLITE_OK;
}

/*
** If *pArg is initially negative then this is a query.  Set *pArg to
** 1 or 0 depending on whether or not bit mask of pFile->ctrlFlags is set.
**
** If *pArg is 0 or 1, then clear or set the mask bit of pFile->ctrlFlags.
*/
static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){
  
// ABS Label 598
if(*pArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}

// ROR Label 599
if((*pArg <= 0) != (*pArg < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 599);
}
// ROR Label 600
if((*pArg > 0) != (*pArg < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 600);
}
// ROR Label 601
if((*pArg >= 0) != (*pArg < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 601);
}
if( *pArg<0 ){
    *pArg = (pFile->ctrlFlags & mask)!=0;
  }else { 
// ABS Label 602
if((*pArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}

// ROR Label 603
if(((*pArg) != 0) != ((*pArg) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 603);
}
if( (*pArg)==0 ){
    pFile->ctrlFlags &= ~mask;
  }else{
    pFile->ctrlFlags |= mask;
  };}

}

/* Forward declaration */
static int unixGetTempname(int nBuf, char *zBuf);
static int unixFcntlExternalReader(unixFile*, int*);

/*
** Information and control of an open file handle.
*/
static int unixFileControl(sqlite3_file *id, int op, void *pArg){
  unixFile *pFile = (unixFile*)id;
  switch( op ){
#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
    case SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: {
      int rc = osIoctl(pFile->h, F2FS_IOC_START_ATOMIC_WRITE);
      return rc ? SQLITE_IOERR_BEGIN_ATOMIC : SQLITE_OK;
    }
    case SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: {
      int rc = osIoctl(pFile->h, F2FS_IOC_COMMIT_ATOMIC_WRITE);
      return rc ? SQLITE_IOERR_COMMIT_ATOMIC : SQLITE_OK;
    }
    case SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: {
      int rc = osIoctl(pFile->h, F2FS_IOC_ABORT_VOLATILE_WRITE);
      return rc ? SQLITE_IOERR_ROLLBACK_ATOMIC : SQLITE_OK;
    }
#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */

    case SQLITE_FCNTL_LOCKSTATE: {
      *(int*)pArg = pFile->eFileLock;
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_LAST_ERRNO: {
      *(int*)pArg = pFile->lastErrno;
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_CHUNK_SIZE: {
      pFile->szChunk = *(int *)pArg;
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_SIZE_HINT: {
      int rc;
      SimulateIOErrorBenign(1);
      rc = fcntlSizeHint(pFile, *(i64 *)pArg);
      SimulateIOErrorBenign(0);
      
// ABS Label 604
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}
return rc;
    }
    case SQLITE_FCNTL_PERSIST_WAL: {
      
// ABS Label 605
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}
unixModeBit(pFile, UNIXFILE_PERSIST_WAL, (int*)pArg);
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {
      
// ABS Label 606
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}
unixModeBit(pFile, UNIXFILE_PSOW, (int*)pArg);
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_VFSNAME: {
      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_TEMPFILENAME: {
      char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );
      
// ABS Label 607
if(zTFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}
if( zTFile ){
        
// ABS Label 608
if(pFile->pVfs->mxPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}

// ABS Label 609
if(zTFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}
unixGetTempname(pFile->pVfs->mxPathname, zTFile);
        *(char**)pArg = zTFile;
      }
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_HAS_MOVED: {
      *(int*)pArg = fileHasMoved(pFile);
      return SQLITE_OK;
    }
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
    case SQLITE_FCNTL_LOCK_TIMEOUT: {
      int iOld = pFile->iBusyTimeout;
      pFile->iBusyTimeout = *(int*)pArg;
      *(int*)pArg = iOld;
      return SQLITE_OK;
    }
#endif
#if SQLITE_MAX_MMAP_SIZE>0
    case SQLITE_FCNTL_MMAP_SIZE: {
      
// ABS Label 610
if(*(i64 *)pArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}
i64 newLimit = *(i64*)pArg;
      int rc = SQLITE_OK;
      
// ABS Label 611
if(newLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}
// ABS Label 612
if(sqlite3Config.mxMmap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}

// ROR Label 613
if((newLimit <= sqlite3Config.mxMmap) != (newLimit > sqlite3Config.mxMmap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 613);
}
// ROR Label 614
if((newLimit < sqlite3Config.mxMmap) != (newLimit > sqlite3Config.mxMmap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 614);
}
// ROR Label 615
if((newLimit >= sqlite3Config.mxMmap) != (newLimit > sqlite3Config.mxMmap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 615);
}
if( newLimit>sqlite3GlobalConfig.mxMmap ){
        newLimit = sqlite3GlobalConfig.mxMmap;
      }

      /* The value of newLimit may be eventually cast to (size_t) and passed
      ** to mmap(). Restrict its value to 2GB if (size_t) is not at least a
      ** 64-bit type. */
      
// ABS Label 616
if(newLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 616);
}

// COR Label 617
if((newLimit > 0 || sizeof(size_t) < 8) != (newLimit > 0 && sizeof(size_t) < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 617);
}

// ROR Label 618
if((newLimit <= 0) != (newLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 618);
}
// ROR Label 619
if((newLimit < 0) != (newLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 619);
}
// ROR Label 620
if((newLimit >= 0) != (newLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
// ROR Label 621
if((sizeof(size_t) <= 8) != (sizeof(size_t) < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}
// ROR Label 622
if((sizeof(size_t) > 8) != (sizeof(size_t) < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 622);
}
// ROR Label 623
if((sizeof(size_t) >= 8) != (sizeof(size_t) < 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 623);
}

// MCC Label 624
if(newLimit > 0 && sizeof(size_t) < 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(newLimit > 0 && !(sizeof(size_t) < 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
// MCC Label 626
if(!(newLimit > 0) && sizeof(size_t) < 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 626);
}
// MCC Label 627
if(!(newLimit > 0) && !(sizeof(size_t) < 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 627);
}
if( newLimit>0 && sizeof(size_t)<8 ){
        newLimit = (newLimit & 0x7FFFFFFF);
      }

      *(i64*)pArg = pFile->mmapSizeMax;
      
// ABS Label 628
if(newLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}
// ABS Label 629
if(pFile->mmapSizeMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}
// ABS Label 630
if(pFile->nFetchOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}

// COR Label 631
if((newLimit >= 0 && newLimit != pFile->mmapSizeMax || pFile->nFetchOut == 0) != (newLimit >= 0 && newLimit != pFile->mmapSizeMax && pFile->nFetchOut == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 631);
}
// COR Label 632
if((newLimit >= 0 || newLimit != pFile->mmapSizeMax) != (newLimit >= 0 && newLimit != pFile->mmapSizeMax))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 632);
}

// ROR Label 633
if((newLimit < 0) != (newLimit >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 633);
}
// ROR Label 634
if((newLimit > 0) != (newLimit >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 634);
}
// ROR Label 635
if((newLimit <= 0) != (newLimit >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 635);
}
// ROR Label 636
if((newLimit == pFile->mmapSizeMax) != (newLimit != pFile->mmapSizeMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
// ROR Label 637
if((pFile->nFetchOut != 0) != (pFile->nFetchOut == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}

// MCC Label 638
if(newLimit >= 0 && newLimit != pFile->mmapSizeMax && pFile->nFetchOut == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 638);
}
// MCC Label 639
if(newLimit >= 0 && newLimit != pFile->mmapSizeMax && !(pFile->nFetchOut == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 639);
}
// MCC Label 640
if(newLimit >= 0 && !(newLimit != pFile->mmapSizeMax) && pFile->nFetchOut == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 640);
}
// MCC Label 641
if(newLimit >= 0 && !(newLimit != pFile->mmapSizeMax) && !(pFile->nFetchOut == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 641);
}
// MCC Label 642
if(!(newLimit >= 0) && newLimit != pFile->mmapSizeMax && pFile->nFetchOut == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 642);
}
// MCC Label 643
if(!(newLimit >= 0) && newLimit != pFile->mmapSizeMax && !(pFile->nFetchOut == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 643);
}
// MCC Label 644
if(!(newLimit >= 0) && !(newLimit != pFile->mmapSizeMax) && pFile->nFetchOut == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 644);
}
// MCC Label 645
if(!(newLimit >= 0) && !(newLimit != pFile->mmapSizeMax) && !(pFile->nFetchOut == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 645);
}
if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){
        pFile->mmapSizeMax = newLimit;
        
// ABS Label 646
if(pFile->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}

// ROR Label 647
if((pFile->mmapSize <= 0) != (pFile->mmapSize > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 647);
}
// ROR Label 648
if((pFile->mmapSize < 0) != (pFile->mmapSize > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 648);
}
// ROR Label 649
if((pFile->mmapSize >= 0) != (pFile->mmapSize > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 649);
}
if( pFile->mmapSize>0 ){
          
// ABS Label 650
if(pFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}
unixUnmapfile(pFile);
          rc = unixMapfile(pFile, -1);
        }
      }
      
// ABS Label 651
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}
return rc;
    }
#endif
#ifdef SQLITE_DEBUG
    /* The pager calls this method to signal that it has done
    ** a rollback and that the database is therefore unchanged and
    ** it hence it is OK for the transaction change counter to be
    ** unchanged.
    */
    case SQLITE_FCNTL_DB_UNCHANGED: {
      ((unixFile*)id)->dbUpdate = 0;
      return SQLITE_OK;
    }
#endif
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
    case SQLITE_FCNTL_SET_LOCKPROXYFILE:
    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {
      return proxyFileControl(id,op,pArg);
    }
#endif /* SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__) */

    case SQLITE_FCNTL_EXTERNAL_READER: {
      return unixFcntlExternalReader((unixFile*)id, (int*)pArg);
    }
  }
  return SQLITE_NOTFOUND;
}

/*
** If pFd->sectorSize is non-zero when this function is called, it is a
** no-op. Otherwise, the values of pFd->sectorSize and 
** pFd->deviceCharacteristics are set according to the file-system 
** characteristics. 
**
** There are two versions of this function. One for QNX and one for all
** other systems.
*/
#ifndef __QNXNTO__
static void setDeviceCharacteristics(unixFile *pFd){
  assert( pFd->deviceCharacteristics==0 || pFd->sectorSize!=0 );
  
// ABS Label 652
if(pFd->sectorSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}

// ROR Label 653
if((pFd->sectorSize != 0) != (pFd->sectorSize == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 653);
}
if( pFd->sectorSize==0 ){
#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
    int res;
    u32 f = 0;

    /* Check for support for F2FS atomic batch writes. */
    res = osIoctl(pFd->h, F2FS_IOC_GET_FEATURES, &f);
    if( res==0 && (f & F2FS_FEATURE_ATOMIC_WRITE) ){
      pFd->deviceCharacteristics = SQLITE_IOCAP_BATCH_ATOMIC;
    }
#endif /* __linux__ && SQLITE_ENABLE_BATCH_ATOMIC_WRITE */

    /* Set the POWERSAFE_OVERWRITE flag if requested. */
    
// AOR Label 654
if(pFd->ctrlFlags | 16 != pFd->ctrlFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 654);
}
// AOR Label 655
if(pFd->ctrlFlags ^ 16 != pFd->ctrlFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 655);
}
if( pFd->ctrlFlags & UNIXFILE_PSOW ){
      pFd->deviceCharacteristics |= SQLITE_IOCAP_POWERSAFE_OVERWRITE;
    }

    pFd->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;
  }
}
#else
#include <sys/dcmd_blk.h>
#include <sys/statvfs.h>
static void setDeviceCharacteristics(unixFile *pFile){
  if( pFile->sectorSize == 0 ){
    struct statvfs fsInfo;
       
    /* Set defaults for non-supported filesystems */
    pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;
    pFile->deviceCharacteristics = 0;
    if( fstatvfs(pFile->h, &fsInfo) == -1 ) {
      return;
    }

    if( !strcmp(fsInfo.f_basetype, "tmp") ) {
      pFile->sectorSize = fsInfo.f_bsize;
      pFile->deviceCharacteristics =
        SQLITE_IOCAP_ATOMIC4K |       /* All ram filesystem writes are atomic */
        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur until
                                      ** the write succeeds */
        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behind
                                      ** so it is ordered */
        0;
    }else if( strstr(fsInfo.f_basetype, "etfs") ){
      pFile->sectorSize = fsInfo.f_bsize;
      pFile->deviceCharacteristics =
        /* etfs cluster size writes are atomic */
        (pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) |
        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur until
                                      ** the write succeeds */
        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behind
                                      ** so it is ordered */
        0;
    }else if( !strcmp(fsInfo.f_basetype, "qnx6") ){
      pFile->sectorSize = fsInfo.f_bsize;
      pFile->deviceCharacteristics =
        SQLITE_IOCAP_ATOMIC |         /* All filesystem writes are atomic */
        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur until
                                      ** the write succeeds */
        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behind
                                      ** so it is ordered */
        0;
    }else if( !strcmp(fsInfo.f_basetype, "qnx4") ){
      pFile->sectorSize = fsInfo.f_bsize;
      pFile->deviceCharacteristics =
        /* full bitset of atomics from max sector size and smaller */
        ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |
        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behind
                                      ** so it is ordered */
        0;
    }else if( strstr(fsInfo.f_basetype, "dos") ){
      pFile->sectorSize = fsInfo.f_bsize;
      pFile->deviceCharacteristics =
        /* full bitset of atomics from max sector size and smaller */
        ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |
        SQLITE_IOCAP_SEQUENTIAL |     /* The ram filesystem has no write behind
                                      ** so it is ordered */
        0;
    }else{
      pFile->deviceCharacteristics =
        SQLITE_IOCAP_ATOMIC512 |      /* blocks are atomic */
        SQLITE_IOCAP_SAFE_APPEND |    /* growing the file does not occur until
                                      ** the write succeeds */
        0;
    }
  }
  /* Last chance verification.  If the sector size isn't a multiple of 512
  ** then it isn't valid.*/
  if( pFile->sectorSize % 512 != 0 ){
    pFile->deviceCharacteristics = 0;
    pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;
  }
}
#endif

/*
** Return the sector size in bytes of the underlying block device for
** the specified file. This is almost always 512 bytes, but may be
** larger for some devices.
**
** SQLite code assumes this function cannot fail. It also assumes that
** if two files are created in the same file-system directory (i.e.
** a database and its journal file) that the sector size will be the
** same for both.
*/
static int unixSectorSize(sqlite3_file *id){
  unixFile *pFd = (unixFile*)id;
  
// ABS Label 656
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}
setDeviceCharacteristics(pFd);
  
// ABS Label 657
if(pFd->sectorSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}
return pFd->sectorSize;
}

/*
** Return the device characteristics for the file.
**
** This VFS is set up to return SQLITE_IOCAP_POWERSAFE_OVERWRITE by default.
** However, that choice is controversial since technically the underlying
** file system does not always provide powersafe overwrites.  (In other
** words, after a power-loss event, parts of the file that were never
** written might end up being altered.)  However, non-PSOW behavior is very,
** very rare.  And asserting PSOW makes a large reduction in the amount
** of required I/O for journaling, since a lot of padding is eliminated.
**  Hence, while POWERSAFE_OVERWRITE is on by default, there is a file-control
** available to turn it off and URI query parameter available to turn it off.
*/
static int unixDeviceCharacteristics(sqlite3_file *id){
  unixFile *pFd = (unixFile*)id;
  
// ABS Label 658
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
setDeviceCharacteristics(pFd);
  
// ABS Label 659
if(pFd->deviceCharacteristics < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}
return pFd->deviceCharacteristics;
}

#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0

/*
** Return the system page size.
**
** This function should not be called directly by other code in this file. 
** Instead, it should be called via macro osGetpagesize().
*/
static int unixGetpagesize(void){
#if OS_VXWORKS
  return 1024;
#elif defined(_BSD_SOURCE)
  return getpagesize();
#else
  return (int)sysconf(_SC_PAGESIZE);
#endif
}

#endif /* !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0 */

#ifndef SQLITE_OMIT_WAL

/*
** Object used to represent an shared memory buffer.  
**
** When multiple threads all reference the same wal-index, each thread
** has its own unixShm object, but they all point to a single instance
** of this unixShmNode object.  In other words, each wal-index is opened
** only once per process.
**
** Each unixShmNode object is connected to a single unixInodeInfo object.
** We could coalesce this object into unixInodeInfo, but that would mean
** every open file that does not use shared memory (in other words, most
** open files) would have to carry around this extra information.  So
** the unixInodeInfo object contains a pointer to this unixShmNode object
** and the unixShmNode object is created only when needed.
**
** unixMutexHeld() must be true when creating or destroying
** this object or while reading or writing the following fields:
**
**      nRef
**
** The following fields are read-only after the object is created:
** 
**      hShm
**      zFilename
**
** Either unixShmNode.pShmMutex must be held or unixShmNode.nRef==0 and
** unixMutexHeld() is true when reading or writing any other field
** in this structure.
*/
struct unixShmNode {
  unixInodeInfo *pInode;     /* unixInodeInfo that owns this SHM node */
  sqlite3_mutex *pShmMutex;  /* Mutex to access this object */
  char *zFilename;           /* Name of the mmapped file */
  int hShm;                  /* Open file descriptor */
  int szRegion;              /* Size of shared-memory regions */
  u16 nRegion;               /* Size of array apRegion */
  u8 isReadonly;             /* True if read-only */
  u8 isUnlocked;             /* True if no DMS lock held */
  char **apRegion;           /* Array of mapped shared-memory regions */
  int nRef;                  /* Number of unixShm objects pointing to this */
  unixShm *pFirst;           /* All unixShm objects pointing to this */
  int aLock[SQLITE_SHM_NLOCK];  /* # shared locks on slot, -1==excl lock */
#ifdef SQLITE_DEBUG
  u8 exclMask;               /* Mask of exclusive locks held */
  u8 sharedMask;             /* Mask of shared locks held */
  u8 nextShmId;              /* Next available unixShm.id value */
#endif
};

/*
** Structure used internally by this VFS to record the state of an
** open shared memory connection.
**
** The following fields are initialized when this object is created and
** are read-only thereafter:
**
**    unixShm.pShmNode
**    unixShm.id
**
** All other fields are read/write.  The unixShm.pShmNode->pShmMutex must
** be held while accessing any read/write fields.
*/
struct unixShm {
  unixShmNode *pShmNode;     /* The underlying unixShmNode object */
  unixShm *pNext;            /* Next unixShm with the same unixShmNode */
  u8 hasMutex;               /* True if holding the unixShmNode->pShmMutex */
  u8 id;                     /* Id of this connection within its unixShmNode */
  u16 sharedMask;            /* Mask of shared locks held */
  u16 exclMask;              /* Mask of exclusive locks held */
};

/*
** Constants used for locking
*/
#define UNIX_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)         /* first lock byte */
#define UNIX_SHM_DMS    (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */

/*
** Use F_GETLK to check whether or not there are any readers with open
** wal-mode transactions in other processes on database file pFile. If
** no error occurs, return SQLITE_OK and set (*piOut) to 1 if there are 
** such transactions, or 0 otherwise. If an error occurs, return an
** SQLite error code. The final value of *piOut is undefined in this
** case.
*/
static int unixFcntlExternalReader(unixFile *pFile, int *piOut){
  int rc = SQLITE_OK;
  *piOut = 0;
  
// ABS Label 660
if(pFile->pShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}
if( pFile->pShm){
    
// ABS Label 661
if(pFile->pShm->pShmNode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}
unixShmNode *pShmNode = pFile->pShm->pShmNode;
    struct flock f;

    memset(&f, 0, sizeof(f));
    f.l_type = F_WRLCK;
    f.l_whence = SEEK_SET;
    f.l_start = UNIX_SHM_BASE + 3;
    f.l_len = SQLITE_SHM_NLOCK - 3;

    
// ABS Label 662
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 662);
}
sqlite3_mutex_enter(pShmNode->pShmMutex);
    if( osFcntl(pShmNode->hShm, F_GETLK, &f)<0 ){
      rc = SQLITE_IOERR_LOCK;
    }else{
      *piOut = (f.l_type!=F_UNLCK);
    }
    
// ABS Label 663
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}
sqlite3_mutex_leave(pShmNode->pShmMutex);
  }

  
// ABS Label 664
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 664);
}
return rc;
}


/*
** Apply posix advisory locks for all bytes from ofst through ofst+n-1.
**
** Locks block if the mask is exactly UNIX_SHM_C and are non-blocking
** otherwise.
*/
static int unixShmSystemLock(
  unixFile *pFile,       /* Open connection to the WAL file */
  int lockType,          /* F_UNLCK, F_RDLCK, or F_WRLCK */
  int ofst,              /* First byte of the locking range */
  int n                  /* Number of bytes to lock */
){
  unixShmNode *pShmNode; /* Apply locks to this open shared-memory segment */
  struct flock f;        /* The posix advisory locking structure */
  int rc = SQLITE_OK;    /* Result code form fcntl() */

  /* Access to the unixShmNode object is serialized by the caller */
  pShmNode = pFile->pInode->pShmNode;
  assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->pShmMutex) );
  assert( pShmNode->nRef>0 || unixMutexHeld() );

  /* Shared locks never span more than one byte */
  assert( n==1 || lockType!=F_RDLCK );

  /* Locks are within range */
  assert( n>=1 && n<=SQLITE_SHM_NLOCK );

  
// ABS Label 665
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 665);
}

// ROR Label 666
if((pShmNode->hShm < 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 666);
}
// ROR Label 667
if((pShmNode->hShm > 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
// ROR Label 668
if((pShmNode->hShm <= 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 668);
}
if( pShmNode->hShm>=0 ){
    int res;
    /* Initialize the locking parameters */
    f.l_type = lockType;
    f.l_whence = SEEK_SET;
    f.l_start = ofst;
    f.l_len = n;
    res = osSetPosixAdvisoryLock(pShmNode->hShm, &f, pFile);
    
// ABS Label 669
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}

// ROR Label 670
if((res != -1) != (res == -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 670);
}
if( res==-1 ){
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
      rc = (pFile->iBusyTimeout ? SQLITE_BUSY_TIMEOUT : SQLITE_BUSY);
#else
      rc = SQLITE_BUSY;
#endif
    }
  }

  /* Update the global lock state and do debug tracing */
#ifdef SQLITE_DEBUG
  { u16 mask;
  OSTRACE(("SHM-LOCK "));
  mask = ofst>31 ? 0xffff : (1<<(ofst+n)) - (1<<ofst);
  if( rc==SQLITE_OK ){
    if( lockType==F_UNLCK ){
      OSTRACE(("unlock %d ok", ofst));
      pShmNode->exclMask &= ~mask;
      pShmNode->sharedMask &= ~mask;
    }else if( lockType==F_RDLCK ){
      OSTRACE(("read-lock %d ok", ofst));
      pShmNode->exclMask &= ~mask;
      pShmNode->sharedMask |= mask;
    }else{
      assert( lockType==F_WRLCK );
      OSTRACE(("write-lock %d ok", ofst));
      pShmNode->exclMask |= mask;
      pShmNode->sharedMask &= ~mask;
    }
  }else{
    if( lockType==F_UNLCK ){
      OSTRACE(("unlock %d failed", ofst));
    }else if( lockType==F_RDLCK ){
      OSTRACE(("read-lock failed"));
    }else{
      assert( lockType==F_WRLCK );
      OSTRACE(("write-lock %d failed", ofst));
    }
  }
  OSTRACE((" - afterwards %03x,%03x\n",
           pShmNode->sharedMask, pShmNode->exclMask));
  }
#endif

  
// ABS Label 671
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}
return rc;        
}

/*
** Return the minimum number of 32KB shm regions that should be mapped at
** a time, assuming that each mapping must be an integer multiple of the
** current system page-size.
**
** Usually, this is 1. The exception seems to be systems that are configured
** to use 64KB pages - in this case each mapping must cover at least two
** shm regions.
*/
static int unixShmRegionPerMap(void){
  
// AOR Label 672
if(32 - 1024 != 32 * 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 672);
}
// AOR Label 673
if(32 + 1024 != 32 * 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 673);
}
// AOR Label 674
if(32 / 1024 != 32 * 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 674);
}
int shmsz = 32*1024;            /* SHM region size */
  int pgsz = osGetpagesize();   /* System page size */
  assert( ((pgsz-1)&pgsz)==0 );   /* Page size must be a power of 2 */
  
// ABS Label 675
if(pgsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}
// ABS Label 676
if(shmsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}

// ROR Label 677
if((pgsz <= shmsz) != (pgsz < shmsz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 677);
}
// ROR Label 678
if((pgsz > shmsz) != (pgsz < shmsz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 678);
}
// ROR Label 679
if((pgsz >= shmsz) != (pgsz < shmsz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 679);
}
if( pgsz<shmsz ) { return 1;
}
  
// ABS Label 680
if(pgsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}
// ABS Label 681
if(shmsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}

// AOR Label 682
if(pgsz - shmsz != pgsz / shmsz)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 682);
}
// AOR Label 683
if(pgsz + shmsz != pgsz / shmsz)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 683);
}
// AOR Label 684
if(pgsz * shmsz != pgsz / shmsz)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 684);
}
return pgsz/shmsz;
}

/*
** Purge the unixShmNodeList list of all entries with unixShmNode.nRef==0.
**
** This is not a VFS shared-memory method; it is a utility function called
** by VFS shared-memory methods.
*/
static void unixShmPurge(unixFile *pFd){
  
// ABS Label 685
if(pFd->pInode->pShmNode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}
unixShmNode *p = pFd->pInode->pShmNode;
  assert( unixMutexHeld() );
  
// ABS Label 686
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}

// COR Label 687
if((p || (p->nRef == 0)) != (p && (p->nRef == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 687);
}

// MCC Label 688
if(p && ( p->nRef == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 688);
}
// MCC Label 689
if(p && ( !(p->nRef == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 689);
}
// MCC Label 690
if(!(p) && ( p->nRef == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 690);
}
// MCC Label 691
if(!(p) && ( !(p->nRef == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 691);
}
if( p && ALWAYS(p->nRef==0) ){
    int nShmPerMap = unixShmRegionPerMap();
    int i;
    assert( p->pInode==pFd->pInode );
    
// ABS Label 692
if(p->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}
sqlite3_mutex_free(p->pShmMutex);
    i = 0;

// ABS Label 693
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 693);
}

// ROR Label 694
if((i <= p->nRegion) != (i < p->nRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 694);
}
// ROR Label 695
if((i > p->nRegion) != (i < p->nRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 695);
}
// ROR Label 696
if((i >= p->nRegion) != (i < p->nRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 696);
}
for(; i<p->nRegion; i+=nShmPerMap){
      
// ABS Label 701
if(p->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}

// ROR Label 702
if((p->hShm < 0) != (p->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 702);
}
// ROR Label 703
if((p->hShm > 0) != (p->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 703);
}
// ROR Label 704
if((p->hShm <= 0) != (p->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 704);
}
if( p->hShm>=0 ){
        osMunmap(p->apRegion[i], p->szRegion);
      }else{
        sqlite3_free(p->apRegion[i]);
      }
    };
// ABS Label 697
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}

// ROR Label 698
if((i <= p->nRegion) != (i < p->nRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 698);
}
// ROR Label 699
if((i > p->nRegion) != (i < p->nRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}
// ROR Label 700
if((i >= p->nRegion) != (i < p->nRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 700);
}

    sqlite3_free(p->apRegion);
    
// ABS Label 705
if(p->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}

// ROR Label 706
if((p->hShm < 0) != (p->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 706);
}
// ROR Label 707
if((p->hShm > 0) != (p->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 707);
}
// ROR Label 708
if((p->hShm <= 0) != (p->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 708);
}
if( p->hShm>=0 ){
      
// ABS Label 709
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}

// ABS Label 710
if(p->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}
robust_close(pFd, p->hShm, __LINE__);
      p->hShm = -1;
    }
    p->pInode->pShmNode = 0;
    sqlite3_free(p);
  }
}

/*
** The DMS lock has not yet been taken on shm file pShmNode. Attempt to
** take it now. Return SQLITE_OK if successful, or an SQLite error
** code otherwise.
**
** If the DMS cannot be locked because this is a readonly_shm=1 
** connection and no other process already holds a lock, return
** SQLITE_READONLY_CANTINIT and set pShmNode->isUnlocked=1.
*/
static int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){
  struct flock lock;
  int rc = SQLITE_OK;

  /* Use F_GETLK to determine the locks other processes are holding
  ** on the DMS byte. If it indicates that another process is holding
  ** a SHARED lock, then this process may also take a SHARED lock
  ** and proceed with opening the *-shm file. 
  **
  ** Or, if no other process is holding any lock, then this process
  ** is the first to open it. In this case take an EXCLUSIVE lock on the
  ** DMS byte and truncate the *-shm file to zero bytes in size. Then
  ** downgrade to a SHARED lock on the DMS byte.
  **
  ** If another process is holding an EXCLUSIVE lock on the DMS byte,
  ** return SQLITE_BUSY to the caller (it will try again). An earlier
  ** version of this code attempted the SHARED lock at this point. But
  ** this introduced a subtle race condition: if the process holding
  ** EXCLUSIVE failed just before truncating the *-shm file, then this
  ** process might open and use the *-shm file without truncating it.
  ** And if the *-shm file has been corrupted by a power failure or
  ** system crash, the database itself may also become corrupt.  */
  lock.l_whence = SEEK_SET;
  lock.l_start = UNIX_SHM_DMS;
  lock.l_len = 1;
  lock.l_type = F_WRLCK;
  if( osFcntl(pShmNode->hShm, F_GETLK, &lock)!=0 ) {
    rc = SQLITE_IOERR_LOCK;
  }else { 
// ROR Label 711
if((lock.l_type != 2) != (lock.l_type == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 711);
}
if( lock.l_type==F_UNLCK ){
    
// ABS Label 712
if(pShmNode->isReadonly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}
if( pShmNode->isReadonly ){
      pShmNode->isUnlocked = 1;
      rc = SQLITE_READONLY_CANTINIT;
    }else{
      rc = unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1);
      /* The first connection to attach must truncate the -shm file.  We
      ** truncate to 3 bytes (an arbitrary small number, less than the
      ** -shm header size) rather than 0 as a system debugging aid, to
      ** help detect if a -shm file truncation is legitimate or is the work
      ** or a rogue process. */
      if( rc==SQLITE_OK && robust_ftruncate(pShmNode->hShm, 3) ){
        rc = unixLogError(SQLITE_IOERR_SHMOPEN,"ftruncate",pShmNode->zFilename);
      }
    }
  }else { 
// ROR Label 713
if((lock.l_type != 1) != (lock.l_type == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 713);
}
if( lock.l_type==F_WRLCK ){
    rc = SQLITE_BUSY;
  };}
;}


  
// ABS Label 714
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}

// ROR Label 715
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 715);
}
if( rc==SQLITE_OK ){
    assert( lock.l_type==F_UNLCK || lock.l_type==F_RDLCK );
    rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);
  }
  
// ABS Label 716
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}
return rc;
}

/*
** Open a shared-memory area associated with open database file pDbFd.  
** This particular implementation uses mmapped files.
**
** The file used to implement shared-memory is in the same directory
** as the open database file and has the same name as the open database
** file with the "-shm" suffix added.  For example, if the database file
** is "/home/user1/config.db" then the file that is created and mmapped
** for shared memory will be called "/home/user1/config.db-shm".  
**
** Another approach to is to use files in /dev/shm or /dev/tmp or an
** some other tmpfs mount. But if a file in a different directory
** from the database file is used, then differing access permissions
** or a chroot() might cause two different processes on the same
** database to end up using different files for shared memory - 
** meaning that their memory would not really be shared - resulting
** in database corruption.  Nevertheless, this tmpfs file usage
** can be enabled at compile-time using -DSQLITE_SHM_DIRECTORY="/dev/shm"
** or the equivalent.  The use of the SQLITE_SHM_DIRECTORY compile-time
** option results in an incompatible build of SQLite;  builds of SQLite
** that with differing SQLITE_SHM_DIRECTORY settings attempt to use the
** same database file at the same time, database corruption will likely
** result. The SQLITE_SHM_DIRECTORY compile-time option is considered
** "unsupported" and may go away in a future SQLite release.
**
** When opening a new shared-memory file, if no other instances of that
** file are currently open, in this process or in other processes, then
** the file must be truncated to zero length or have its header cleared.
**
** If the original database file (pDbFd) is using the "unix-excl" VFS
** that means that an exclusive lock is held on the database file and
** that no other processes are able to read or write the database.  In
** that case, we do not really need shared memory.  No shared memory
** file is created.  The shared memory will be simulated with heap memory.
*/
static int unixOpenSharedMemory(unixFile *pDbFd){
  struct unixShm *p = 0;          /* The connection to be opened */
  struct unixShmNode *pShmNode;   /* The underlying mmapped file */
  int rc = SQLITE_OK;             /* Result code */
  unixInodeInfo *pInode;          /* The inode of fd */
  char *zShm;             /* Name of the file used for SHM */
  int nShmFilename;               /* Size of the SHM filename in bytes */

  /* Allocate space for the new unixShm object. */
  p = sqlite3_malloc64( sizeof(*p) );
  
// ABS Label 719
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}

// ROR Label 720
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}
if( p==0 ) { return SQLITE_NOMEM_BKPT;
}
  memset(p, 0, sizeof(*p));
  assert( pDbFd->pShm==0 );

  /* Check to see if a unixShmNode object already exists. Reuse an existing
  ** one if present. Create a new one if necessary.
  */
  assert( unixFileMutexNotheld(pDbFd) );
  unixEnterMutex();
  pInode = pDbFd->pInode;
  pShmNode = pInode->pShmNode;
  
// ABS Label 721
if(pShmNode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}

// ROR Label 722
if((pShmNode != 0) != (pShmNode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 722);
}
if( pShmNode==0 ){
    struct stat sStat;                 /* fstat() info for database file */
#ifndef SQLITE_SHM_DIRECTORY
    
// ABS Label 723
if(pDbFd->zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 723);
}
const char *zBasePath = pDbFd->zPath;
#endif

    /* Call fstat() to figure out the permissions on the database file. If
    ** a new *-shm file is created, an attempt will be made to create it
    ** with the same permissions.
    */
    if( osFstat(pDbFd->h, &sStat) ){
      rc = SQLITE_IOERR_FSTAT;
      goto shm_open_err;
    }

#ifdef SQLITE_SHM_DIRECTORY
    nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;
#else
    nShmFilename = 6 + (int)strlen(zBasePath);
#endif
    pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );
    
// ABS Label 730
if(pShmNode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}

// ROR Label 731
if((pShmNode != 0) != (pShmNode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 731);
}
if( pShmNode==0 ){
      rc = SQLITE_NOMEM_BKPT;
      goto shm_open_err;
    }
    
// AOR Label 724
if(sizeof (*pShmNode) - nShmFilename != sizeof (*pShmNode) + nShmFilename)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 724);
}
// AOR Label 725
if(sizeof (*pShmNode) / nShmFilename != sizeof (*pShmNode) + nShmFilename)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 725);
}
// AOR Label 726
if(sizeof (*pShmNode) * nShmFilename != sizeof (*pShmNode) + nShmFilename)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 726);
}
memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);
    zShm = pShmNode->zFilename = (char*)&pShmNode[1];
#ifdef SQLITE_SHM_DIRECTORY
    sqlite3_snprintf(nShmFilename, zShm, 
                     SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",
                     (u32)sStat.st_ino, (u32)sStat.st_dev);
#else
    
// ABS Label 727
if(nShmFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}

// ABS Label 728
if(zShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}

// ABS Label 729
if(zBasePath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}
sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);
    sqlite3FileSuffix3(pDbFd->zPath, zShm);
#endif
    pShmNode->hShm = -1;
    pDbFd->pInode->pShmNode = pShmNode;
    pShmNode->pInode = pDbFd->pInode;
    
// ABS Label 732
if(sqlite3Config.bCoreMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}
if( sqlite3GlobalConfig.bCoreMutex ){
      pShmNode->pShmMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
      
// ABS Label 733
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 733);
}

// ROR Label 734
if((pShmNode->pShmMutex != 0) != (pShmNode->pShmMutex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 734);
}
if( pShmNode->pShmMutex==0 ){
        rc = SQLITE_NOMEM_BKPT;
        goto shm_open_err;
      }
    }

    
// ROR Label 735
if((pInode->bProcessLock != 0) != (pInode->bProcessLock == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 735);
}
if( pInode->bProcessLock==0 ){
      if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){
        pShmNode->hShm = robust_open(zShm, O_RDWR|O_CREAT|O_NOFOLLOW,
                                     (sStat.st_mode&0777));
      }
      
// ABS Label 739
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 739);
}

// ROR Label 740
if((pShmNode->hShm <= 0) != (pShmNode->hShm < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 740);
}
// ROR Label 741
if((pShmNode->hShm > 0) != (pShmNode->hShm < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 741);
}
// ROR Label 742
if((pShmNode->hShm >= 0) != (pShmNode->hShm < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 742);
}
if( pShmNode->hShm<0 ){
        pShmNode->hShm = robust_open(zShm, O_RDONLY|O_NOFOLLOW,
                                     (sStat.st_mode&0777));
        
// ABS Label 743
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}

// ROR Label 744
if((pShmNode->hShm <= 0) != (pShmNode->hShm < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 744);
}
// ROR Label 745
if((pShmNode->hShm > 0) != (pShmNode->hShm < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 745);
}
// ROR Label 746
if((pShmNode->hShm >= 0) != (pShmNode->hShm < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 746);
}
if( pShmNode->hShm<0 ){
          rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zShm);
          goto shm_open_err;
        }
        pShmNode->isReadonly = 1;
      }

      /* If this process is running as root, make sure that the SHM file
      ** is owned by the same user that owns the original database.  Otherwise,
      ** the original owner will not be able to connect.
      */
      
// ABS Label 736
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// ABS Label 737
if(sStat.st_uid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 737);
}

// ABS Label 738
if(sStat.st_gid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 738);
}
robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);

      rc = unixLockSharedMemory(pDbFd, pShmNode);
      
// ABS Label 747
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// COR Label 748
if((rc != 0 || rc != (8 | (5 << 8))) != (rc != 0 && rc != (8 | (5 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 748);
}

// ROR Label 749
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 749);
}
// ROR Label 750
if((rc == (8 | (5 << 8))) != (rc != (8 | (5 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 750);
}

// MCC Label 751
if(rc != 0 && rc != (8 | (5 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 751);
}
// MCC Label 752
if(rc != 0 && !(rc != (8 | (5 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 752);
}
// MCC Label 753
if(!(rc != 0) && rc != (8 | (5 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 753);
}
// MCC Label 754
if(!(rc != 0) && !(rc != (8 | (5 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 754);
}
if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) { goto shm_open_err;
}
    }
  }

  /* Make the new connection a child of the unixShmNode */
  p->pShmNode = pShmNode;
#ifdef SQLITE_DEBUG
  p->id = pShmNode->nextShmId++;
#endif
  pShmNode->nRef++;
  pDbFd->pShm = p;
  unixLeaveMutex();

  /* The reference count on pShmNode has already been incremented under
  ** the cover of the unixEnterMutex() mutex and the pointer from the
  ** new (struct unixShm) object to the pShmNode has been set. All that is
  ** left to do is to link the new object into the linked list starting
  ** at pShmNode->pFirst. This must be done while holding the
  ** pShmNode->pShmMutex.
  */
  
// ABS Label 717
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}
sqlite3_mutex_enter(pShmNode->pShmMutex);
  p->pNext = pShmNode->pFirst;
  pShmNode->pFirst = p;
  
// ABS Label 718
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 718);
}
sqlite3_mutex_leave(pShmNode->pShmMutex);
  
// ABS Label 755
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}
return rc;

  /* Jump here on any error */
shm_open_err:
  unixShmPurge(pDbFd);       /* This call frees pShmNode if required */
  sqlite3_free(p);
  unixLeaveMutex();
  
// ABS Label 756
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}
return rc;
}

/*
** This function is called to obtain a pointer to region iRegion of the 
** shared-memory associated with the database file fd. Shared-memory regions 
** are numbered starting from zero. Each shared-memory region is szRegion 
** bytes in size.
**
** If an error occurs, an error code is returned and *pp is set to NULL.
**
** Otherwise, if the bExtend parameter is 0 and the requested shared-memory
** region has not been allocated (by any client, including one running in a
** separate process), then *pp is set to NULL and SQLITE_OK returned. If 
** bExtend is non-zero and the requested shared-memory region has not yet 
** been allocated, it is allocated by this function.
**
** If the shared-memory region has already been allocated or is allocated by
** this call as described above, then it is mapped into this processes 
** address space (if it is not already), *pp is set to point to the mapped 
** memory and SQLITE_OK returned.
*/
static int unixShmMap(
  sqlite3_file *fd,               /* Handle open on database file */
  int iRegion,                    /* Region to retrieve */
  int szRegion,                   /* Size of regions */
  int bExtend,                    /* True to extend file if necessary */
  void volatile **pp              /* OUT: Mapped memory */
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p;
  unixShmNode *pShmNode;
  int rc = SQLITE_OK;
  int nShmPerMap = unixShmRegionPerMap();
  int nReqRegion;

  /* If the shared-memory file has not yet been opened, open it now. */
  
// ABS Label 759
if(pDbFd->pShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}

// ROR Label 760
if((pDbFd->pShm != 0) != (pDbFd->pShm == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 760);
}
if( pDbFd->pShm==0 ){
    rc = unixOpenSharedMemory(pDbFd);
    
// ABS Label 761
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 761);
}

// ROR Label 762
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 762);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 763
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 763);
}
return rc;
}
  }

  p = pDbFd->pShm;
  pShmNode = p->pShmNode;
  
// ABS Label 757
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}
sqlite3_mutex_enter(pShmNode->pShmMutex);
  
// ABS Label 764
if(pShmNode->isUnlocked < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}
if( pShmNode->isUnlocked ){
    rc = unixLockSharedMemory(pDbFd, pShmNode);
    
// ABS Label 765
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}

// ROR Label 766
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 766);
}
if( rc!=SQLITE_OK ) { goto shmpage_out;
}
    pShmNode->isUnlocked = 0;
  }
  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );
  assert( pShmNode->pInode==pDbFd->pInode );
  assert( pShmNode->hShm>=0 || pDbFd->pInode->bProcessLock==1 );
  assert( pShmNode->hShm<0 || pDbFd->pInode->bProcessLock==0 );

  /* Minimum number of regions required to be mapped. */
  nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;

  
// ABS Label 767
if(nReqRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 767);
}

// ROR Label 768
if((pShmNode->nRegion <= nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 768);
}
// ROR Label 769
if((pShmNode->nRegion > nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 769);
}
// ROR Label 770
if((pShmNode->nRegion >= nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 770);
}
if( pShmNode->nRegion<nReqRegion ){
    char **apNew;                      /* New apRegion[] array */
    
// ABS Label 771
if(nReqRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 771);
}
// ABS Label 772
if(szRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 772);
}

// AOR Label 773
if(nReqRegion - szRegion != nReqRegion * szRegion)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 773);
}
// AOR Label 774
if(nReqRegion + szRegion != nReqRegion * szRegion)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 774);
}
// AOR Label 775
if(nReqRegion / szRegion != nReqRegion * szRegion)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 775);
}
int nByte = nReqRegion*szRegion;   /* Minimum required file size */
    struct stat sStat;                 /* Used by fstat() */

    pShmNode->szRegion = szRegion;

    
// ABS Label 776
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}

// ROR Label 777
if((pShmNode->hShm < 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 777);
}
// ROR Label 778
if((pShmNode->hShm > 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 778);
}
// ROR Label 779
if((pShmNode->hShm <= 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 779);
}
if( pShmNode->hShm>=0 ){
      /* The requested region is not mapped into this processes address space.
      ** Check to see if it has been allocated (i.e. if the wal-index file is
      ** large enough to contain the requested region).
      */
      if( osFstat(pShmNode->hShm, &sStat) ){
        rc = SQLITE_IOERR_SHMSIZE;
        goto shmpage_out;
      }
  
      
// ABS Label 780
if(sStat.st_size < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}

// ROR Label 781
if((sStat.st_size <= nByte) != (sStat.st_size < nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 781);
}
// ROR Label 782
if((sStat.st_size > nByte) != (sStat.st_size < nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 782);
}
// ROR Label 783
if((sStat.st_size >= nByte) != (sStat.st_size < nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 783);
}
if( sStat.st_size<nByte ){
        /* The requested memory region does not exist. If bExtend is set to
        ** false, exit early. *pp will be set to NULL and SQLITE_OK returned.
        */
        if( !bExtend ){
          goto shmpage_out;
        }

        /* Alternatively, if bExtend is true, extend the file. Do this by
        ** writing a single byte to the end of each (OS) page being
        ** allocated or extended. Technically, we need only write to the
        ** last page in order to extend the file. But writing to all new
        ** pages forces the OS to allocate them immediately, which reduces
        ** the chances of SIGBUS while accessing the mapped region later on.
        */
        else{
          static const int pgsz = 4096;
          int iPg;

          /* Write to the last byte of each newly allocated or extended page */
          assert( (nByte % pgsz)==0 );
          iPg = (sStat.st_size / pgsz);

// ABS Label 784
if(iPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}

// ROR Label 785
if((iPg <= (nByte / pgsz)) != (iPg < (nByte / pgsz)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 785);
}
// ROR Label 786
if((iPg > (nByte / pgsz)) != (iPg < (nByte / pgsz)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 786);
}
// ROR Label 787
if((iPg >= (nByte / pgsz)) != (iPg < (nByte / pgsz)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 787);
}
for(; iPg<(nByte/pgsz); iPg++){
            int x = 0;
            if( seekAndWriteFd(pShmNode->hShm, iPg*pgsz + pgsz-1,"",1,&x)!=1 ){
              const char *zFile = pShmNode->zFilename;
              rc = unixLogError(SQLITE_IOERR_SHMSIZE, "write", zFile);
              goto shmpage_out;
            }
          };
// ABS Label 788
if(iPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}

// ROR Label 789
if((iPg <= (nByte / pgsz)) != (iPg < (nByte / pgsz)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 789);
}
// ROR Label 790
if((iPg > (nByte / pgsz)) != (iPg < (nByte / pgsz)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 790);
}
// ROR Label 791
if((iPg >= (nByte / pgsz)) != (iPg < (nByte / pgsz)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 791);
}

        }
      }
    }

    /* Map the requested memory region into this processes address space. */
    apNew = (char **)sqlite3_realloc(
        pShmNode->apRegion, nReqRegion*sizeof(char *)
    );
    if( !apNew ){
      rc = SQLITE_IOERR_NOMEM_BKPT;
      goto shmpage_out;
    }
    pShmNode->apRegion = apNew;
    
// ABS Label 792
if(nReqRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}

// ROR Label 793
if((pShmNode->nRegion <= nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 793);
}
// ROR Label 794
if((pShmNode->nRegion > nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 794);
}
// ROR Label 795
if((pShmNode->nRegion >= nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 795);
}
while( pShmNode->nRegion<nReqRegion ){
      
// ABS Label 800
if(nShmPerMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}
// ABS Label 801
if(szRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}

// AOR Label 802
if(szRegion - nShmPerMap != szRegion * nShmPerMap)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 802);
}
// AOR Label 803
if(szRegion + nShmPerMap != szRegion * nShmPerMap)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 803);
}
// AOR Label 804
if(szRegion / nShmPerMap != szRegion * nShmPerMap)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 804);
}
int nMap = szRegion*nShmPerMap;
      int i;
      void *pMem;
      
// ABS Label 805
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}

// ROR Label 806
if((pShmNode->hShm < 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 806);
}
// ROR Label 807
if((pShmNode->hShm > 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 807);
}
// ROR Label 808
if((pShmNode->hShm <= 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 808);
}
if( pShmNode->hShm>=0 ){
        pMem = osMmap(0, nMap,
            pShmNode->isReadonly ? PROT_READ : PROT_READ|PROT_WRITE, 
            MAP_SHARED, pShmNode->hShm, szRegion*(i64)pShmNode->nRegion
        );
        
// ABS Label 809
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}

// ROR Label 810
if((pMem != ((void *)-1)) != (pMem == ((void *)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 810);
}
if( pMem==MAP_FAILED ){
          rc = unixLogError(SQLITE_IOERR_SHMMAP, "mmap", pShmNode->zFilename);
          goto shmpage_out;
        }
      }else{
        pMem = sqlite3_malloc64(nMap);
        
// ABS Label 812
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}

// ROR Label 813
if((pMem != 0) != (pMem == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 813);
}
if( pMem==0 ){
          rc = SQLITE_NOMEM_BKPT;
          goto shmpage_out;
        }
        
// ABS Label 811
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
memset(pMem, 0, nMap);
      }

      i = 0;

// ABS Label 814
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}
// ABS Label 815
if(nShmPerMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}

// ROR Label 816
if((i <= nShmPerMap) != (i < nShmPerMap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 816);
}
// ROR Label 817
if((i > nShmPerMap) != (i < nShmPerMap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 817);
}
// ROR Label 818
if((i >= nShmPerMap) != (i < nShmPerMap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 818);
}
for(; i<nShmPerMap; i++){
        pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];
      };
// ABS Label 819
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}
// ABS Label 820
if(nShmPerMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}

// ROR Label 821
if((i <= nShmPerMap) != (i < nShmPerMap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 821);
}
// ROR Label 822
if((i > nShmPerMap) != (i < nShmPerMap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 822);
}
// ROR Label 823
if((i >= nShmPerMap) != (i < nShmPerMap))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 823);
}

      pShmNode->nRegion += nShmPerMap;
    };
// ABS Label 796
if(nReqRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}

// ROR Label 797
if((pShmNode->nRegion <= nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 797);
}
// ROR Label 798
if((pShmNode->nRegion > nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 798);
}
// ROR Label 799
if((pShmNode->nRegion >= nReqRegion) != (pShmNode->nRegion < nReqRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 799);
}

  }

shmpage_out:
  
// ABS Label 824
if(iRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ROR Label 825
if((pShmNode->nRegion <= iRegion) != (pShmNode->nRegion > iRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 825);
}
// ROR Label 826
if((pShmNode->nRegion < iRegion) != (pShmNode->nRegion > iRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 826);
}
// ROR Label 827
if((pShmNode->nRegion >= iRegion) != (pShmNode->nRegion > iRegion))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 827);
}
if( pShmNode->nRegion>iRegion ){
    *pp = pShmNode->apRegion[iRegion];
  }else{
    *pp = 0;
  }
  
// ABS Label 828
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// COR Label 829
if((pShmNode->isReadonly || rc == 0) != (pShmNode->isReadonly && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 829);
}

// ROR Label 830
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}

// MCC Label 831
if(pShmNode->isReadonly && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 831);
}
// MCC Label 832
if(pShmNode->isReadonly && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 832);
}
// MCC Label 833
if(!(pShmNode->isReadonly) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 833);
}
// MCC Label 834
if(!(pShmNode->isReadonly) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 834);
}
if( pShmNode->isReadonly && rc==SQLITE_OK ) { rc = SQLITE_READONLY;
}
  
// ABS Label 758
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}
sqlite3_mutex_leave(pShmNode->pShmMutex);
  
// ABS Label 835
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}
return rc;
}

/*
** Check that the pShmNode->aLock[] array comports with the locking bitmasks
** held by each client. Return true if it does, or false otherwise. This
** is to be used in an assert(). e.g.
**
**     assert( assertLockingArrayOk(pShmNode) );
*/
#ifdef SQLITE_DEBUG
static int assertLockingArrayOk(unixShmNode *pShmNode){
  unixShm *pX;
  int aLock[SQLITE_SHM_NLOCK];
  assert( sqlite3_mutex_held(pShmNode->pShmMutex) );

  memset(aLock, 0, sizeof(aLock));
  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
    int i;
    for(i=0; i<SQLITE_SHM_NLOCK; i++){
      if( pX->exclMask & (1<<i) ){
        assert( aLock[i]==0 );
        aLock[i] = -1;
      }else if( pX->sharedMask & (1<<i) ){
        assert( aLock[i]>=0 );
        aLock[i]++;
      }
    }
  }

  assert( 0==memcmp(pShmNode->aLock, aLock, sizeof(aLock)) );
  return (memcmp(pShmNode->aLock, aLock, sizeof(aLock))==0);
}
#endif

/*
** Change the lock state for a shared-memory segment.
**
** Note that the relationship between SHAREd and EXCLUSIVE locks is a little
** different here than in posix.  In xShmLock(), one can go from unlocked
** to shared and back or from unlocked to exclusive and back.  But one may
** not go from shared to exclusive or from exclusive to shared.
*/
static int unixShmLock(
  sqlite3_file *fd,          /* Database file holding the shared memory */
  int ofst,                  /* First lock to acquire or release */
  int n,                     /* Number of locks to acquire or release */
  int flags                  /* What to do with the lock */
){
  unixFile *pDbFd = (unixFile*)fd;      /* Connection holding shared memory */
  
// ABS Label 836
if(pDbFd->pShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 836);
}
unixShm *p = pDbFd->pShm;             /* The shared memory being locked */
  
// ABS Label 837
if(p->pShmNode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 837);
}
unixShmNode *pShmNode = p->pShmNode;  /* The underlying file iNode */
  int rc = SQLITE_OK;                   /* Result code */
  u16 mask;                             /* Mask of locks to take or release */
  int *aLock = pShmNode->aLock;

  assert( pShmNode==pDbFd->pInode->pShmNode );
  assert( pShmNode->pInode==pDbFd->pInode );
  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );
  assert( n>=1 );
  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)
       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)
       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)
       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );
  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );
  assert( pShmNode->hShm>=0 || pDbFd->pInode->bProcessLock==1 );
  assert( pShmNode->hShm<0 || pDbFd->pInode->bProcessLock==0 );

  /* Check that, if this to be a blocking lock, no locks that occur later
  ** in the following list than the lock being obtained are already held:
  **
  **   1. Checkpointer lock (ofst==1).
  **   2. Write lock (ofst==0).
  **   3. Read locks (ofst>=3 && ofst<SQLITE_SHM_NLOCK).
  **
  ** In other words, if this is a blocking lock, none of the locks that
  ** occur later in the above list than the lock being obtained may be
  ** held.  
  **
  ** It is not permitted to block on the RECOVER lock.
  */
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
  assert( (flags & SQLITE_SHM_UNLOCK) || pDbFd->iBusyTimeout==0 || (
         (ofst!=2)                                   /* not RECOVER */
      && (ofst!=1 || (p->exclMask|p->sharedMask)==0)
      && (ofst!=0 || (p->exclMask|p->sharedMask)<3)
      && (ofst<3  || (p->exclMask|p->sharedMask)<(1<<ofst))
  ));
#endif

  mask = (1<<(ofst+n)) - (1<<ofst);
  assert( n>1 || mask==(1<<ofst) );
  
// ABS Label 838
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}
sqlite3_mutex_enter(pShmNode->pShmMutex);
  assert( assertLockingArrayOk(pShmNode) );
  
// ABS Label 840
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 840);
}

// AOR Label 841
if(flags | 1 != flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 841);
}
// AOR Label 842
if(flags ^ 1 != flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 842);
}
if( flags & SQLITE_SHM_UNLOCK ){
    
// AOR Label 843
if((p->exclMask | p->sharedMask) | mask != (p->exclMask | p->sharedMask) & mask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 843);
}
// AOR Label 844
if((p->exclMask | p->sharedMask) ^ mask != (p->exclMask | p->sharedMask) & mask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 844);
}
if( (p->exclMask|p->sharedMask) & mask ){
      int ii;
      int bUnlock = 1;

      ii = ofst;

// ABS Label 845
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}
// ABS Label 846
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}
// ABS Label 847
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}

// AOR Label 848
if(ofst - n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 848);
}
// AOR Label 849
if(ofst / n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 849);
}
// AOR Label 850
if(ofst * n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 850);
}

// ROR Label 851
if((ii <= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 851);
}
// ROR Label 852
if((ii > ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 852);
}
// ROR Label 853
if((ii >= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
for(; ii<ofst+n; ii++){
        
// ABS Label 863
if(aLock[ii] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}
// ABS Label 864
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 864);
}

// ROR Label 865
if((aLock[ii] <= ((p->sharedMask & (1 << ii)) ? 1 : 0)) != (aLock[ii] > ((p->sharedMask & (1 << ii)) ? 1 : 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 865);
}
// ROR Label 866
if((aLock[ii] < ((p->sharedMask & (1 << ii)) ? 1 : 0)) != (aLock[ii] > ((p->sharedMask & (1 << ii)) ? 1 : 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}
// ROR Label 867
if((aLock[ii] >= ((p->sharedMask & (1 << ii)) ? 1 : 0)) != (aLock[ii] > ((p->sharedMask & (1 << ii)) ? 1 : 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 867);
}
if( aLock[ii]>((p->sharedMask & (1<<ii)) ? 1 : 0) ){
          bUnlock = 0;
        }
      };
// ABS Label 854
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}
// ABS Label 855
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}
// ABS Label 856
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}

// AOR Label 857
if(ofst - n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 857);
}
// AOR Label 858
if(ofst / n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 858);
}
// AOR Label 859
if(ofst * n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 859);
}

// ROR Label 860
if((ii <= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 860);
}
// ROR Label 861
if((ii > ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 861);
}
// ROR Label 862
if((ii >= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}


      
// ABS Label 868
if(bUnlock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 868);
}
if( bUnlock ){
        rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);
        
// ABS Label 869
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 869);
}

// ROR Label 870
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 870);
}
if( rc==SQLITE_OK ){
          
// AOR Label 871
if(sizeof(int) - n != sizeof(int) * n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 871);
}
// AOR Label 872
if(sizeof(int) + n != sizeof(int) * n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 872);
}
// AOR Label 873
if(sizeof(int) / n != sizeof(int) * n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 873);
}
memset(&aLock[ofst], 0, sizeof(int)*n);
        }
      }else { 
// MCC Label 874
if(( p->sharedMask & (1 << ofst) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 874);
}
// MCC Label 875
if(( !(p->sharedMask & (1 << ofst)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 875);
}
if( ALWAYS(p->sharedMask & (1<<ofst)) ){
        assert( n==1 && aLock[ofst]>1 );
        aLock[ofst]--;
      };}


      /* Undo the local locks */
      
// ABS Label 876
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}

// ROR Label 877
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 877);
}
if( rc==SQLITE_OK ){
        p->exclMask &= ~mask;
        p->sharedMask &= ~mask;
      } 
    }
  }else { 
// ABS Label 878
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 878);
}

// AOR Label 879
if(flags | 4 != flags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 879);
}
// AOR Label 880
if(flags ^ 4 != flags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 880);
}
if( flags & SQLITE_SHM_SHARED ){
    assert( n==1 );
    assert( (p->exclMask & (1<<ofst))==0 );
    
// ROR Label 881
if(((p->sharedMask & mask) != 0) != ((p->sharedMask & mask) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 881);
}
if( (p->sharedMask & mask)==0 ){
      
// ABS Label 882
if(aLock[ofst] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}
// ABS Label 883
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}

// ROR Label 884
if((aLock[ofst] <= 0) != (aLock[ofst] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 884);
}
// ROR Label 885
if((aLock[ofst] > 0) != (aLock[ofst] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 885);
}
// ROR Label 886
if((aLock[ofst] >= 0) != (aLock[ofst] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}
if( aLock[ofst]<0 ){
        rc = SQLITE_BUSY;
      }else { 
// ABS Label 887
if(aLock[ofst] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 887);
}
// ABS Label 888
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 888);
}

// ROR Label 889
if((aLock[ofst] != 0) != (aLock[ofst] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 889);
}
if( aLock[ofst]==0 ){
        rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);
      };}


      /* Get the local shared locks */
      
// ABS Label 890
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 890);
}

// ROR Label 891
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 891);
}
if( rc==SQLITE_OK ){
        p->sharedMask |= mask;
        aLock[ofst]++;
      }
    }
  }else{
    /* Make sure no sibling connections hold locks that will block this
    ** lock.  If any do, return SQLITE_BUSY right away.  */
    int ii;
    ii = ofst;

// ABS Label 892
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 892);
}
// ABS Label 893
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}
// ABS Label 894
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}

// AOR Label 895
if(ofst - n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 895);
}
// AOR Label 896
if(ofst / n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 896);
}
// AOR Label 897
if(ofst * n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 897);
}

// ROR Label 898
if((ii <= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 898);
}
// ROR Label 899
if((ii > ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 899);
}
// ROR Label 900
if((ii >= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 900);
}
for(; ii<ofst+n; ii++){
      assert( (p->sharedMask & mask)==0 );
      
// ABS Label 910
if(aLock[ii] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}
// ABS Label 911
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}

// COR Label 912
if((((p->exclMask & (1 << ii)) == 0) || aLock[ii]) != (((p->exclMask & (1 << ii)) == 0) && aLock[ii]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 912);
}

// MCC Label 913
if(( (p->exclMask & (1 << ii)) == 0 ) && aLock[ii] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 913);
}
// MCC Label 914
if(( (p->exclMask & (1 << ii)) == 0 ) && !(aLock[ii]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(( !((p->exclMask & (1 << ii)) == 0) ) && aLock[ii] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(( !((p->exclMask & (1 << ii)) == 0) ) && !(aLock[ii]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}
if( ALWAYS((p->exclMask & (1<<ii))==0) && aLock[ii] ){
        rc = SQLITE_BUSY;
        break;
      }
    };
// ABS Label 901
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 901);
}
// ABS Label 902
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 902);
}
// ABS Label 903
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 903);
}

// AOR Label 904
if(ofst - n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 904);
}
// AOR Label 905
if(ofst / n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 905);
}
// AOR Label 906
if(ofst * n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 906);
}

// ROR Label 907
if((ii <= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 907);
}
// ROR Label 908
if((ii > ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 908);
}
// ROR Label 909
if((ii >= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 909);
}


    /* Get the exclusive locks at the system level. Then if successful
    ** also update the in-memory values. */
    
// ABS Label 917
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ROR Label 918
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
if( rc==SQLITE_OK ){
      rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);
      
// ABS Label 919
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}

// ROR Label 920
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 920);
}
if( rc==SQLITE_OK ){
        assert( (p->sharedMask & mask)==0 );
        p->exclMask |= mask;
        ii = ofst;

// ABS Label 921
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}
// ABS Label 922
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}
// ABS Label 923
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}

// AOR Label 924
if(ofst - n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 924);
}
// AOR Label 925
if(ofst / n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 925);
}
// AOR Label 926
if(ofst * n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 926);
}

// ROR Label 927
if((ii <= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 927);
}
// ROR Label 928
if((ii > ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 928);
}
// ROR Label 929
if((ii >= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 929);
}
for(; ii<ofst+n; ii++){
          aLock[ii] = -1;
        };
// ABS Label 930
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
// ABS Label 931
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 931);
}
// ABS Label 932
if(ofst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 932);
}

// AOR Label 933
if(ofst - n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 933);
}
// AOR Label 934
if(ofst / n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 934);
}
// AOR Label 935
if(ofst * n != ofst + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 935);
}

// ROR Label 936
if((ii <= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 936);
}
// ROR Label 937
if((ii > ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 937);
}
// ROR Label 938
if((ii >= ofst + n) != (ii < ofst + n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 938);
}

      }
    }
  };}

  assert( assertLockingArrayOk(pShmNode) );
  
// ABS Label 839
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}
sqlite3_mutex_leave(pShmNode->pShmMutex);
  OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",
           p->id, osGetpid(0), p->sharedMask, p->exclMask));
  
// ABS Label 939
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}
return rc;
}

/*
** Implement a memory barrier or memory fence on shared memory.  
**
** All loads and stores begun before the barrier must complete before
** any load or store begun after the barrier.
*/
static void unixShmBarrier(
  sqlite3_file *fd                /* Database file holding the shared memory */
){
  UNUSED_PARAMETER(fd);
  sqlite3MemoryBarrier();         /* compiler-defined memory barrier */
  assert( fd->pMethods->xLock==nolockLock 
       || unixFileMutexNotheld((unixFile*)fd) 
  );
  unixEnterMutex();               /* Also mutex, for redundancy */
  unixLeaveMutex();
}

/*
** Close a connection to shared-memory.  Delete the underlying 
** storage if deleteFlag is true.
**
** If there is no shared memory associated with the connection then this
** routine is a harmless no-op.
*/
static int unixShmUnmap(
  sqlite3_file *fd,               /* The underlying database file */
  int deleteFlag                  /* Delete shared-memory if true */
){
  unixShm *p;                     /* The connection to be closed */
  unixShmNode *pShmNode;          /* The underlying shared-memory file */
  unixShm **pp;                   /* For looping over sibling connections */
  unixFile *pDbFd;                /* The underlying database file */

  pDbFd = (unixFile*)fd;
  p = pDbFd->pShm;
  
// ABS Label 942
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 942);
}

// ROR Label 943
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 943);
}
if( p==0 ) { return SQLITE_OK;
}
  pShmNode = p->pShmNode;

  assert( pShmNode==pDbFd->pInode->pShmNode );
  assert( pShmNode->pInode==pDbFd->pInode );

  /* Remove connection p from the set of connections associated
  ** with pShmNode */
  
// ABS Label 940
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}
sqlite3_mutex_enter(pShmNode->pShmMutex);
  pp = &pShmNode->pFirst;

// ABS Label 944
if((*pp) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}
// ABS Label 945
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}

// ROR Label 946
if(((*pp) == p) != ((*pp) != p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 946);
}
for(; (*pp)!=p; pp = &(*pp)->pNext){};
// ABS Label 947
if((*pp) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}
// ABS Label 948
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 948);
}

// ROR Label 949
if(((*pp) == p) != ((*pp) != p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 949);
}

  *pp = p->pNext;

  /* Free the connection p */
  sqlite3_free(p);
  pDbFd->pShm = 0;
  
// ABS Label 941
if(pShmNode->pShmMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 941);
}
sqlite3_mutex_leave(pShmNode->pShmMutex);

  /* If pShmNode->nRef has reached 0, then close the underlying
  ** shared-memory file, too */
  assert( unixFileMutexNotheld(pDbFd) );
  unixEnterMutex();
  assert( pShmNode->nRef>0 );
  pShmNode->nRef--;
  
// ABS Label 950
if(pShmNode->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 950);
}

// ROR Label 951
if((pShmNode->nRef != 0) != (pShmNode->nRef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 951);
}
if( pShmNode->nRef==0 ){
    
// ABS Label 953
if(deleteFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 953);
}
// ABS Label 954
if(pShmNode->hShm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 954);
}

// COR Label 955
if((deleteFlag || pShmNode->hShm >= 0) != (deleteFlag && pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 955);
}

// ROR Label 956
if((pShmNode->hShm < 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 956);
}
// ROR Label 957
if((pShmNode->hShm > 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 957);
}
// ROR Label 958
if((pShmNode->hShm <= 0) != (pShmNode->hShm >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 958);
}

// MCC Label 959
if(deleteFlag && pShmNode->hShm >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 959);
}
// MCC Label 960
if(deleteFlag && !(pShmNode->hShm >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 960);
}
// MCC Label 961
if(!(deleteFlag) && pShmNode->hShm >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 961);
}
// MCC Label 962
if(!(deleteFlag) && !(pShmNode->hShm >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 962);
}
if( deleteFlag && pShmNode->hShm>=0 ){
      osUnlink(pShmNode->zFilename);
    }
    
// ABS Label 952
if(pDbFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 952);
}
unixShmPurge(pDbFd);
  }
  unixLeaveMutex();

  return SQLITE_OK;
}


#else
# define unixShmMap     0
# define unixShmLock    0
# define unixShmBarrier 0
# define unixShmUnmap   0
#endif /* #ifndef SQLITE_OMIT_WAL */

#if SQLITE_MAX_MMAP_SIZE>0
/*
** If it is currently memory mapped, unmap file pFd.
*/
static void unixUnmapfile(unixFile *pFd){
  assert( pFd->nFetchOut==0 );
  
// ABS Label 963
if(pFd->pMapRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}
if( pFd->pMapRegion ){
    osMunmap(pFd->pMapRegion, pFd->mmapSizeActual);
    pFd->pMapRegion = 0;
    pFd->mmapSize = 0;
    pFd->mmapSizeActual = 0;
  }
}

/*
** Attempt to set the size of the memory mapping maintained by file 
** descriptor pFd to nNew bytes. Any existing mapping is discarded.
**
** If successful, this function sets the following variables:
**
**       unixFile.pMapRegion
**       unixFile.mmapSize
**       unixFile.mmapSizeActual
**
** If unsuccessful, an error message is logged via sqlite3_log() and
** the three variables above are zeroed. In this case SQLite should
** continue accessing the database using the xRead() and xWrite()
** methods.
*/
static void unixRemapfile(
  unixFile *pFd,                  /* File descriptor object */
  i64 nNew                        /* Required mapping size */
){
  const char *zErr = "mmap";
  
// ABS Label 965
if(pFd->h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}
int h = pFd->h;                      /* File descriptor open on db file */
  u8 *pOrig = (u8 *)pFd->pMapRegion;   /* Pointer to current file mapping */
  
// ABS Label 966
if(pFd->mmapSizeActual < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 966);
}
i64 nOrig = pFd->mmapSizeActual;     /* Size of pOrig region in bytes */
  u8 *pNew = 0;                        /* Location of new mapping */
  int flags = PROT_READ;               /* Flags to pass to mmap() */

  assert( pFd->nFetchOut==0 );
  assert( nNew>pFd->mmapSize );
  assert( nNew<=pFd->mmapSizeMax );
  assert( nNew>0 );
  assert( pFd->mmapSizeActual>=pFd->mmapSize );
  assert( MAP_FAILED!=0 );

#ifdef SQLITE_MMAP_READWRITE
  if( (pFd->ctrlFlags & UNIXFILE_RDONLY)==0 ) flags |= PROT_WRITE;
#endif

  
// ABS Label 967
if(pOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 967);
}
if( pOrig ){
#if HAVE_MREMAP
    
// ABS Label 968
if(pFd->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 968);
}
i64 nReuse = pFd->mmapSize;
#else
    const int szSyspage = osGetpagesize();
    i64 nReuse = (pFd->mmapSize & ~(szSyspage-1));
#endif
    u8 *pReq = &pOrig[nReuse];

    /* Unmap any pages of the existing mapping that cannot be reused. */
    
// ABS Label 969
if(nOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 969);
}
// ABS Label 970
if(nReuse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}

// ROR Label 971
if((nReuse == nOrig) != (nReuse != nOrig))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 971);
}
if( nReuse!=nOrig ){
      osMunmap(pReq, nOrig-nReuse);
    }

#if HAVE_MREMAP
    pNew = osMremap(pOrig, nReuse, nNew, MREMAP_MAYMOVE);
    zErr = "mremap";
#else
    pNew = osMmap(pReq, nNew-nReuse, flags, MAP_SHARED, h, nReuse);
    if( pNew!=MAP_FAILED ){
      if( pNew!=pReq ){
        osMunmap(pNew, nNew - nReuse);
        pNew = 0;
      }else{
        pNew = pOrig;
      }
    }
#endif

    /* The attempt to extend the existing mapping failed. Free it. */
    
// ABS Label 972
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 972);
}

// COR Label 973
if((pNew == ((void *)-1) && pNew == 0) != (pNew == ((void *)-1) || pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 973);
}

// ROR Label 974
if((pNew != ((void *)-1)) != (pNew == ((void *)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 974);
}
// ROR Label 975
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 975);
}

// MCC Label 976
if(pNew == ((void *)-1) && pNew == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 976);
}
// MCC Label 977
if(pNew == ((void *)-1) && !(pNew == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 977);
}
// MCC Label 978
if(!(pNew == ((void *)-1)) && pNew == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 978);
}
// MCC Label 979
if(!(pNew == ((void *)-1)) && !(pNew == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 979);
}
if( pNew==MAP_FAILED || pNew==0 ){
      osMunmap(pOrig, nReuse);
    }
  }

  /* If pNew is still NULL, try to create an entirely new mapping. */
  
// ABS Label 980
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}

// ROR Label 981
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 981);
}
if( pNew==0 ){
    pNew = osMmap(0, nNew, flags, MAP_SHARED, h, 0);
  }

  
// ABS Label 982
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}

// ROR Label 983
if((pNew != ((void *)-1)) != (pNew == ((void *)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 983);
}
if( pNew==MAP_FAILED ){
    pNew = 0;
    nNew = 0;
    unixLogError(SQLITE_OK, zErr, pFd->zPath);

    /* If the mmap() above failed, assume that all subsequent mmap() calls
    ** will probably fail too. Fall back to using xRead/xWrite exclusively
    ** in this case.  */
    pFd->mmapSizeMax = 0;
  }
  pFd->pMapRegion = (void *)pNew;
  pFd->mmapSize = pFd->mmapSizeActual = nNew;
}

/*
** Memory map or remap the file opened by file-descriptor pFd (if the file
** is already mapped, the existing mapping is replaced by the new). Or, if 
** there already exists a mapping for this file, and there are still 
** outstanding xFetch() references to it, this function is a no-op.
**
** If parameter nByte is non-negative, then it is the requested size of 
** the mapping to create. Otherwise, if nByte is less than zero, then the 
** requested size is the size of the file on disk. The actual size of the
** created mapping is either the requested size or the value configured 
** using SQLITE_FCNTL_MMAP_LIMIT, whichever is smaller.
**
** SQLITE_OK is returned if no error occurs (even if the mapping is not
** recreated as a result of outstanding references) or an SQLite error
** code otherwise.
*/
static int unixMapfile(unixFile *pFd, i64 nMap){
  assert( nMap>=0 || pFd->nFetchOut==0 );
  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );
  
// ABS Label 986
if(pFd->nFetchOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}

// ROR Label 987
if((pFd->nFetchOut <= 0) != (pFd->nFetchOut > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 987);
}
// ROR Label 988
if((pFd->nFetchOut < 0) != (pFd->nFetchOut > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 988);
}
// ROR Label 989
if((pFd->nFetchOut >= 0) != (pFd->nFetchOut > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 989);
}
if( pFd->nFetchOut>0 ) { return SQLITE_OK;
}

  
// ABS Label 990
if(nMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 990);
}

// ROR Label 991
if((nMap <= 0) != (nMap < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 991);
}
// ROR Label 992
if((nMap > 0) != (nMap < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 992);
}
// ROR Label 993
if((nMap >= 0) != (nMap < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 993);
}
if( nMap<0 ){
    struct stat statbuf;          /* Low-level file information */
    if( osFstat(pFd->h, &statbuf) ){
      
// MCC Label 994
if(( 10 | (7 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 994);
}
// MCC Label 995
if(( !(10 | (7 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 995);
}
return SQLITE_IOERR_FSTAT;
    }
    nMap = statbuf.st_size;
  }
  
// ABS Label 996
if(nMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 996);
}
// ABS Label 997
if(pFd->mmapSizeMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}

// ROR Label 998
if((nMap <= pFd->mmapSizeMax) != (nMap > pFd->mmapSizeMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 998);
}
// ROR Label 999
if((nMap < pFd->mmapSizeMax) != (nMap > pFd->mmapSizeMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 999);
}
// ROR Label 1000
if((nMap >= pFd->mmapSizeMax) != (nMap > pFd->mmapSizeMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1000);
}
if( nMap>pFd->mmapSizeMax ){
    nMap = pFd->mmapSizeMax;
  }

  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );
  
// ABS Label 1001
if(nMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1001);
}
// ABS Label 1002
if(pFd->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}

// ROR Label 1003
if((nMap == pFd->mmapSize) != (nMap != pFd->mmapSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1003);
}
if( nMap!=pFd->mmapSize ){
    
// ABS Label 1004
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1004);
}

// ABS Label 1005
if(nMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1005);
}
unixRemapfile(pFd, nMap);
  }

  return SQLITE_OK;
}
#endif /* SQLITE_MAX_MMAP_SIZE>0 */

/*
** If possible, return a pointer to a mapping of file fd starting at offset
** iOff. The mapping must be valid for at least nAmt bytes.
**
** If such a pointer can be obtained, store it in *pp and return SQLITE_OK.
** Or, if one cannot but no error occurs, set *pp to 0 and return SQLITE_OK.
** Finally, if an error does occur, return an SQLite error code. The final
** value of *pp is undefined in this case.
**
** If this function does return a pointer, the caller must eventually 
** release the reference by calling unixUnfetch().
*/
static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){
#if SQLITE_MAX_MMAP_SIZE>0
  unixFile *pFd = (unixFile *)fd;   /* The underlying database file */
#endif
  *pp = 0;

#if SQLITE_MAX_MMAP_SIZE>0
  
// ABS Label 1006
if(pFd->mmapSizeMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}

// ROR Label 1007
if((pFd->mmapSizeMax <= 0) != (pFd->mmapSizeMax > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1007);
}
// ROR Label 1008
if((pFd->mmapSizeMax < 0) != (pFd->mmapSizeMax > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1008);
}
// ROR Label 1009
if((pFd->mmapSizeMax >= 0) != (pFd->mmapSizeMax > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1009);
}
if( pFd->mmapSizeMax>0 ){
    
// ABS Label 1010
if(pFd->pMapRegion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1010);
}

// ROR Label 1011
if((pFd->pMapRegion != 0) != (pFd->pMapRegion == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1011);
}
if( pFd->pMapRegion==0 ){
      int rc = unixMapfile(pFd, -1);
      
// ABS Label 1012
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1012);
}

// ROR Label 1013
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1013);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1014
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1014);
}
return rc;
}
    }
    
// ABS Label 1015
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}
// ABS Label 1016
if(pFd->mmapSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}

// AOR Label 1017
if(iOff - nAmt != iOff + nAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1017);
}
// AOR Label 1018
if(iOff / nAmt != iOff + nAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1018);
}
// AOR Label 1019
if(iOff * nAmt != iOff + nAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1019);
}

// ROR Label 1020
if((pFd->mmapSize < iOff + nAmt) != (pFd->mmapSize >= iOff + nAmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1020);
}
// ROR Label 1021
if((pFd->mmapSize > iOff + nAmt) != (pFd->mmapSize >= iOff + nAmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1021);
}
// ROR Label 1022
if((pFd->mmapSize <= iOff + nAmt) != (pFd->mmapSize >= iOff + nAmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1022);
}
if( pFd->mmapSize >= iOff+nAmt ){
      *pp = &((u8 *)pFd->pMapRegion)[iOff];
      pFd->nFetchOut++;
    }
  }
#endif
  return SQLITE_OK;
}

/*
** If the third argument is non-NULL, then this function releases a 
** reference obtained by an earlier call to unixFetch(). The second
** argument passed to this function must be the same as the corresponding
** argument that was passed to the unixFetch() invocation. 
**
** Or, if the third argument is NULL, then this function is being called 
** to inform the VFS layer that, according to POSIX, any existing mapping 
** may now be invalid and should be unmapped.
*/
static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){
#if SQLITE_MAX_MMAP_SIZE>0
  unixFile *pFd = (unixFile *)fd;   /* The underlying database file */
  UNUSED_PARAMETER(iOff);

  /* If p==0 (unmap the entire file) then there must be no outstanding 
  ** xFetch references. Or, if p!=0 (meaning it is an xFetch reference),
  ** then there must be at least one outstanding.  */
  assert( (p==0)==(pFd->nFetchOut==0) );

  /* If p!=0, it must match the iOff value. */
  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] );

  
// ABS Label 1023
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}
if( p ){
    pFd->nFetchOut--;
  }else{
    
// ABS Label 1024
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1024);
}
unixUnmapfile(pFd);
  }

  assert( pFd->nFetchOut>=0 );
#else
  UNUSED_PARAMETER(fd);
  UNUSED_PARAMETER(p);
  UNUSED_PARAMETER(iOff);
#endif
  return SQLITE_OK;
}

/*
** Here ends the implementation of all sqlite3_file methods.
**
********************** End sqlite3_file Methods *******************************
******************************************************************************/

/*
** This division contains definitions of sqlite3_io_methods objects that
** implement various file locking strategies.  It also contains definitions
** of "finder" functions.  A finder-function is used to locate the appropriate
** sqlite3_io_methods object for a particular database file.  The pAppData
** field of the sqlite3_vfs VFS objects are initialized to be pointers to
** the correct finder-function for that VFS.
**
** Most finder functions return a pointer to a fixed sqlite3_io_methods
** object.  The only interesting finder-function is autolockIoFinder, which
** looks at the filesystem type and tries to guess the best locking
** strategy from that.
**
** For finder-function F, two objects are created:
**
**    (1) The real finder-function named "FImpt()".
**
**    (2) A constant pointer to this function named just "F".
**
**
** A pointer to the F pointer is used as the pAppData value for VFS
** objects.  We have to do this instead of letting pAppData point
** directly at the finder-function since C90 rules prevent a void*
** from be cast into a function pointer.
**
**
** Each instance of this macro generates two objects:
**
**   *  A constant sqlite3_io_methods object call METHOD that has locking
**      methods CLOSE, LOCK, UNLOCK, CKRESLOCK.
**
**   *  An I/O method finder function called FINDER that returns a pointer
**      to the METHOD object in the previous bullet.
*/
#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP)     \
static const sqlite3_io_methods METHOD = {                                   \
   VERSION,                    /* iVersion */                                \
   CLOSE,                      /* xClose */                                  \
   unixRead,                   /* xRead */                                   \
   unixWrite,                  /* xWrite */                                  \
   unixTruncate,               /* xTruncate */                               \
   unixSync,                   /* xSync */                                   \
   unixFileSize,               /* xFileSize */                               \
   LOCK,                       /* xLock */                                   \
   UNLOCK,                     /* xUnlock */                                 \
   CKLOCK,                     /* xCheckReservedLock */                      \
   unixFileControl,            /* xFileControl */                            \
   unixSectorSize,             /* xSectorSize */                             \
   unixDeviceCharacteristics,  /* xDeviceCapabilities */                     \
   SHMMAP,                     /* xShmMap */                                 \
   unixShmLock,                /* xShmLock */                                \
   unixShmBarrier,             /* xShmBarrier */                             \
   unixShmUnmap,               /* xShmUnmap */                               \
   unixFetch,                  /* xFetch */                                  \
   unixUnfetch,                /* xUnfetch */                                \
};                                                                           \
static const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   \
  UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);                                  \
  return &METHOD;                                                            \
}                                                                            \
static const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)    \
    = FINDER##Impl;

/*
** Here are all of the sqlite3_io_methods objects for each of the
** locking strategies.  Functions that return pointers to these methods
** are also created.
*/
IOMETHODS(
  posixIoFinder,            /* Finder function name */
  posixIoMethods,           /* sqlite3_io_methods object name */
  3,                        /* shared memory and mmap are enabled */
  unixClose,                /* xClose method */
  unixLock,                 /* xLock method */
  unixUnlock,               /* xUnlock method */
  unixCheckReservedLock,    /* xCheckReservedLock method */
  unixShmMap                /* xShmMap method */
)
IOMETHODS(
  nolockIoFinder,           /* Finder function name */
  nolockIoMethods,          /* sqlite3_io_methods object name */
  3,                        /* shared memory and mmap are enabled */
  nolockClose,              /* xClose method */
  nolockLock,               /* xLock method */
  nolockUnlock,             /* xUnlock method */
  nolockCheckReservedLock,  /* xCheckReservedLock method */
  0                         /* xShmMap method */
)
IOMETHODS(
  dotlockIoFinder,          /* Finder function name */
  dotlockIoMethods,         /* sqlite3_io_methods object name */
  1,                        /* shared memory is disabled */
  dotlockClose,             /* xClose method */
  dotlockLock,              /* xLock method */
  dotlockUnlock,            /* xUnlock method */
  dotlockCheckReservedLock, /* xCheckReservedLock method */
  0                         /* xShmMap method */
)

#if SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(
  flockIoFinder,            /* Finder function name */
  flockIoMethods,           /* sqlite3_io_methods object name */
  1,                        /* shared memory is disabled */
  flockClose,               /* xClose method */
  flockLock,                /* xLock method */
  flockUnlock,              /* xUnlock method */
  flockCheckReservedLock,   /* xCheckReservedLock method */
  0                         /* xShmMap method */
)
#endif

#if OS_VXWORKS
IOMETHODS(
  semIoFinder,              /* Finder function name */
  semIoMethods,             /* sqlite3_io_methods object name */
  1,                        /* shared memory is disabled */
  semXClose,                /* xClose method */
  semXLock,                 /* xLock method */
  semXUnlock,               /* xUnlock method */
  semXCheckReservedLock,    /* xCheckReservedLock method */
  0                         /* xShmMap method */
)
#endif

#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(
  afpIoFinder,              /* Finder function name */
  afpIoMethods,             /* sqlite3_io_methods object name */
  1,                        /* shared memory is disabled */
  afpClose,                 /* xClose method */
  afpLock,                  /* xLock method */
  afpUnlock,                /* xUnlock method */
  afpCheckReservedLock,     /* xCheckReservedLock method */
  0                         /* xShmMap method */
)
#endif

/*
** The proxy locking method is a "super-method" in the sense that it
** opens secondary file descriptors for the conch and lock files and
** it uses proxy, dot-file, AFP, and flock() locking methods on those
** secondary files.  For this reason, the division that implements
** proxy locking is located much further down in the file.  But we need
** to go ahead and define the sqlite3_io_methods and finder function
** for proxy locking here.  So we forward declare the I/O methods.
*/
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
static int proxyClose(sqlite3_file*);
static int proxyLock(sqlite3_file*, int);
static int proxyUnlock(sqlite3_file*, int);
static int proxyCheckReservedLock(sqlite3_file*, int*);
IOMETHODS(
  proxyIoFinder,            /* Finder function name */
  proxyIoMethods,           /* sqlite3_io_methods object name */
  1,                        /* shared memory is disabled */
  proxyClose,               /* xClose method */
  proxyLock,                /* xLock method */
  proxyUnlock,              /* xUnlock method */
  proxyCheckReservedLock,   /* xCheckReservedLock method */
  0                         /* xShmMap method */
)
#endif

/* nfs lockd on OSX 10.3+ doesn't clear write locks when a read lock is set */
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(
  nfsIoFinder,               /* Finder function name */
  nfsIoMethods,              /* sqlite3_io_methods object name */
  1,                         /* shared memory is disabled */
  unixClose,                 /* xClose method */
  unixLock,                  /* xLock method */
  nfsUnlock,                 /* xUnlock method */
  unixCheckReservedLock,     /* xCheckReservedLock method */
  0                          /* xShmMap method */
)
#endif

#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
/* 
** This "finder" function attempts to determine the best locking strategy 
** for the database file "filePath".  It then returns the sqlite3_io_methods
** object that implements that strategy.
**
** This is for MacOSX only.
*/
static const sqlite3_io_methods *autolockIoFinderImpl(
  const char *filePath,    /* name of the database file */
  unixFile *pNew           /* open file object for the database file */
){
  static const struct Mapping {
    const char *zFilesystem;              /* Filesystem type name */
    const sqlite3_io_methods *pMethods;   /* Appropriate locking method */
  } aMap[] = {
    { "hfs",    &posixIoMethods },
    { "ufs",    &posixIoMethods },
    { "afpfs",  &afpIoMethods },
    { "smbfs",  &afpIoMethods },
    { "webdav", &nolockIoMethods },
    { 0, 0 }
  };
  int i;
  struct statfs fsInfo;
  struct flock lockInfo;

  if( !filePath ){
    /* If filePath==NULL that means we are dealing with a transient file
    ** that does not need to be locked. */
    return &nolockIoMethods;
  }
  if( statfs(filePath, &fsInfo) != -1 ){
    if( fsInfo.f_flags & MNT_RDONLY ){
      return &nolockIoMethods;
    }
    for(i=0; aMap[i].zFilesystem; i++){
      if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){
        return aMap[i].pMethods;
      }
    }
  }

  /* Default case. Handles, amongst others, "nfs".
  ** Test byte-range lock using fcntl(). If the call succeeds, 
  ** assume that the file-system supports POSIX style locks. 
  */
  lockInfo.l_len = 1;
  lockInfo.l_start = 0;
  lockInfo.l_whence = SEEK_SET;
  lockInfo.l_type = F_RDLCK;
  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {
    if( strcmp(fsInfo.f_fstypename, "nfs")==0 ){
      return &nfsIoMethods;
    } else {
      return &posixIoMethods;
    }
  }else{
    return &dotlockIoMethods;
  }
}
static const sqlite3_io_methods 
  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;

#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */

#if OS_VXWORKS
/*
** This "finder" function for VxWorks checks to see if posix advisory
** locking works.  If it does, then that is what is used.  If it does not
** work, then fallback to named semaphore locking.
*/
static const sqlite3_io_methods *vxworksIoFinderImpl(
  const char *filePath,    /* name of the database file */
  unixFile *pNew           /* the open file object */
){
  struct flock lockInfo;

  if( !filePath ){
    /* If filePath==NULL that means we are dealing with a transient file
    ** that does not need to be locked. */
    return &nolockIoMethods;
  }

  /* Test if fcntl() is supported and use POSIX style locks.
  ** Otherwise fall back to the named semaphore method.
  */
  lockInfo.l_len = 1;
  lockInfo.l_start = 0;
  lockInfo.l_whence = SEEK_SET;
  lockInfo.l_type = F_RDLCK;
  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {
    return &posixIoMethods;
  }else{
    return &semIoMethods;
  }
}
static const sqlite3_io_methods 
  *(*const vxworksIoFinder)(const char*,unixFile*) = vxworksIoFinderImpl;

#endif /* OS_VXWORKS */

/*
** An abstract type for a pointer to an IO method finder function:
*/
typedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);


/****************************************************************************
**************************** sqlite3_vfs methods ****************************
**
** This division contains the implementation of methods on the
** sqlite3_vfs object.
*/

/*
** Initialize the contents of the unixFile structure pointed to by pId.
*/
static int fillInUnixFile(
  sqlite3_vfs *pVfs,      /* Pointer to vfs object */
  int h,                  /* Open file descriptor of file being opened */
  sqlite3_file *pId,      /* Write to the unixFile structure here */
  const char *zFilename,  /* Name of the file being opened */
  int ctrlFlags           /* Zero or more UNIXFILE_* values */
){
  const sqlite3_io_methods *pLockingStyle;
  unixFile *pNew = (unixFile *)pId;
  int rc = SQLITE_OK;

  assert( pNew->pInode==NULL );

  /* No locking occurs in temporary files */
  assert( zFilename!=0 || (ctrlFlags & UNIXFILE_NOLOCK)!=0 );

  OSTRACE(("OPEN    %-3d %s\n", h, zFilename));
  pNew->h = h;
  pNew->pVfs = pVfs;
  pNew->zPath = zFilename;
  pNew->ctrlFlags = (u8)ctrlFlags;
#if SQLITE_MAX_MMAP_SIZE>0
  pNew->mmapSizeMax = sqlite3GlobalConfig.szMmap;
#endif
  if( sqlite3_uri_boolean(((ctrlFlags & UNIXFILE_URI) ? zFilename : 0),
                           "psow", SQLITE_POWERSAFE_OVERWRITE) ){
    pNew->ctrlFlags |= UNIXFILE_PSOW;
  }
  if( strcmp(pVfs->zName,"unix-excl")==0 ){
    pNew->ctrlFlags |= UNIXFILE_EXCL;
  }

#if OS_VXWORKS
  pNew->pId = vxworksFindFileId(zFilename);
  if( pNew->pId==0 ){
    ctrlFlags |= UNIXFILE_NOLOCK;
    rc = SQLITE_NOMEM_BKPT;
  }
#endif

  
// ABS Label 1026
if(ctrlFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1026);
}

// AOR Label 1027
if(ctrlFlags | 128 != ctrlFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1027);
}
// AOR Label 1028
if(ctrlFlags ^ 128 != ctrlFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1028);
}
if( ctrlFlags & UNIXFILE_NOLOCK ){
    pLockingStyle = &nolockIoMethods;
  }else{
    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);
#if SQLITE_ENABLE_LOCKING_STYLE
    /* Cache zFilename in the locking context (AFP and dotlock override) for
    ** proxyLock activation is possible (remote proxy is based on db name)
    ** zFilename remains valid until file is closed, to support */
    pNew->lockingContext = (void*)zFilename;
#endif
  }

  
// ABS Label 1029
if(pLockingStyle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}

// ROR Label 1030
if((pLockingStyle != &posixIoMethods) != (pLockingStyle == &posixIoMethods))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1030);
}
if( pLockingStyle == &posixIoMethods
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
    || pLockingStyle == &nfsIoMethods
#endif
  ){
    unixEnterMutex();
    rc = findInodeInfo(pNew, &pNew->pInode);
    
// ABS Label 1031
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}

// ROR Label 1032
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1032);
}
if( rc!=SQLITE_OK ){
      /* If an error occurred in findInodeInfo(), close the file descriptor
      ** immediately, before releasing the mutex. findInodeInfo() may fail
      ** in two scenarios:
      **
      **   (a) A call to fstat() failed.
      **   (b) A malloc failed.
      **
      ** Scenario (b) may only occur if the process is holding no other
      ** file descriptors open on the same file. If there were other file
      ** descriptors on this file, then no malloc would be required by
      ** findInodeInfo(). If this is the case, it is quite safe to close
      ** handle h - as it is guaranteed that no posix locks will be released
      ** by doing so.
      **
      ** If scenario (a) caused the error then things are not so safe. The
      ** implicit assumption here is that if fstat() fails, things are in
      ** such bad shape that dropping a lock or two doesn't matter much.
      */
      
// ABS Label 1033
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}

// ABS Label 1034
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1034);
}
robust_close(pNew, h, __LINE__);
      h = -1;
    }
    unixLeaveMutex();
  }

#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
  else if( pLockingStyle == &afpIoMethods ){
    /* AFP locking uses the file path so it needs to be included in
    ** the afpLockingContext.
    */
    afpLockingContext *pCtx;
    pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );
    if( pCtx==0 ){
      rc = SQLITE_NOMEM_BKPT;
    }else{
      /* NB: zFilename exists and remains valid until the file is closed
      ** according to requirement F11141.  So we do not need to make a
      ** copy of the filename. */
      pCtx->dbPath = zFilename;
      pCtx->reserved = 0;
      srandomdev();
      unixEnterMutex();
      rc = findInodeInfo(pNew, &pNew->pInode);
      if( rc!=SQLITE_OK ){
        sqlite3_free(pNew->lockingContext);
        robust_close(pNew, h, __LINE__);
        h = -1;
      }
      unixLeaveMutex();        
    }
  }
#endif

  else { 
// ABS Label 1035
if(pLockingStyle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1035);
}

// ROR Label 1036
if((pLockingStyle != &dotlockIoMethods) != (pLockingStyle == &dotlockIoMethods))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1036);
}
if( pLockingStyle == &dotlockIoMethods ){
    /* Dotfile locking uses the file path so it needs to be included in
    ** the dotlockLockingContext 
    */
    char *zLockFile;
    int nFilename;
    assert( zFilename!=0 );
    nFilename = (int)strlen(zFilename) + 6;
    zLockFile = (char *)sqlite3_malloc64(nFilename);
    
// ABS Label 1037
if(zLockFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1037);
}

// ROR Label 1038
if((zLockFile != 0) != (zLockFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1038);
}
if( zLockFile==0 ){
      rc = SQLITE_NOMEM_BKPT;
    }else{
      
// ABS Label 1039
if(nFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1039);
}

// ABS Label 1040
if(zLockFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1040);
}

// ABS Label 1041
if(zFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}
sqlite3_snprintf(nFilename, zLockFile, "%s" DOTLOCK_SUFFIX, zFilename);
    }
    pNew->lockingContext = zLockFile;
  };}


#if OS_VXWORKS
  else if( pLockingStyle == &semIoMethods ){
    /* Named semaphore locking uses the file path so it needs to be
    ** included in the semLockingContext
    */
    unixEnterMutex();
    rc = findInodeInfo(pNew, &pNew->pInode);
    if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){
      char *zSemName = pNew->pInode->aSemName;
      int n;
      sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",
                       pNew->pId->zCanonicalName);
      for( n=1; zSemName[n]; n++ )
        if( zSemName[n]=='/' ) zSemName[n] = '_';
      pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);
      if( pNew->pInode->pSem == SEM_FAILED ){
        rc = SQLITE_NOMEM_BKPT;
        pNew->pInode->aSemName[0] = '\0';
      }
    }
    unixLeaveMutex();
  }
#endif
  
  
// ABS Label 1025
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1025);
}
storeLastErrno(pNew, 0);
#if OS_VXWORKS
  if( rc!=SQLITE_OK ){
    if( h>=0 ) robust_close(pNew, h, __LINE__);
    h = -1;
    osUnlink(zFilename);
    pNew->ctrlFlags |= UNIXFILE_DELETE;
  }
#endif
  
// ABS Label 1042
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}

// ROR Label 1043
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1043);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 1044
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// ROR Label 1045
if((h < 0) != (h >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1045);
}
// ROR Label 1046
if((h > 0) != (h >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1046);
}
// ROR Label 1047
if((h <= 0) != (h >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1047);
}
if( h>=0 ) { 
// ABS Label 1048
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}

// ABS Label 1049
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}
robust_close(pNew, h, __LINE__);
}
  }else{
    pId->pMethods = pLockingStyle;
    OpenCounter(+1);
    
// ABS Label 1050
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1050);
}
verifyDbFile(pNew);
  }
  
// ABS Label 1051
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}
return rc;
}

/*
** Return the name of a directory in which to put temporary files.
** If no suitable temporary file directory can be found, return NULL.
*/
static const char *unixTempFileDir(void){
  static const char *azDirs[] = {
     0,
     0,
     "/var/tmp",
     "/usr/tmp",
     "/tmp",
     "."
  };
  unsigned int i = 0;
  struct stat buf;
  const char *zDir = sqlite3_temp_directory;

  if( !azDirs[0] ) { azDirs[0] = getenv("SQLITE_TMPDIR");
}
  if( !azDirs[1] ) { azDirs[1] = getenv("TMPDIR");
}
  while(1){
    if( zDir!=0
     && osStat(zDir, &buf)==0
     && S_ISDIR(buf.st_mode)
     && osAccess(zDir, 03)==0
    ){
      
// ABS Label 1052
if(zDir < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}
return zDir;
    }
    
// AOR Label 1053
if(sizeof (azDirs) - sizeof (azDirs[0]) != sizeof (azDirs) / sizeof (azDirs[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1053);
}
// AOR Label 1054
if(sizeof (azDirs) + sizeof (azDirs[0]) != sizeof (azDirs) / sizeof (azDirs[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1054);
}
// AOR Label 1055
if(sizeof (azDirs) * sizeof (azDirs[0]) != sizeof (azDirs) / sizeof (azDirs[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1055);
}

// ROR Label 1056
if((i < sizeof (azDirs) / sizeof (azDirs[0])) != (i >= sizeof (azDirs) / sizeof (azDirs[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1056);
}
// ROR Label 1057
if((i > sizeof (azDirs) / sizeof (azDirs[0])) != (i >= sizeof (azDirs) / sizeof (azDirs[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1057);
}
// ROR Label 1058
if((i <= sizeof (azDirs) / sizeof (azDirs[0])) != (i >= sizeof (azDirs) / sizeof (azDirs[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1058);
}
if( i>=sizeof(azDirs)/sizeof(azDirs[0]) ) { break;
}
    zDir = azDirs[i++];
  };
  return 0;
}

/*
** Create a temporary file name in zBuf.  zBuf must be allocated
** by the calling process and must be big enough to hold at least
** pVfs->mxPathname bytes.
*/
static int unixGetTempname(int nBuf, char *zBuf){
  const char *zDir;
  int iLimit = 0;

  /* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. 
  */
  zBuf[0] = 0;
  SimulateIOError( return SQLITE_IOERR );

  zDir = unixTempFileDir();
  
// ABS Label 1059
if(zDir < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}

// ROR Label 1060
if((zDir != 0) != (zDir == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1060);
}
if( zDir==0 ) { 
// MCC Label 1061
if(( 10 | (25 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1061);
}
// MCC Label 1062
if(( !(10 | (25 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1062);
}
return SQLITE_IOERR_GETTEMPPATH;
}
  do{
    u64 r;
    sqlite3_randomness(sizeof(r), &r);
    assert( nBuf>2 );
    zBuf[nBuf-2] = 0;
    
// ABS Label 1063
if(nBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1063);
}

// ABS Label 1064
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1064);
}

// ABS Label 1065
if(zDir < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1065);
}

// ABS Label 1066
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1066);
}
sqlite3_snprintf(nBuf, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX"%llx%c",
                     zDir, r, 0);
    if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ) { return SQLITE_ERROR;
}
  }while( osAccess(zBuf,0)==0 );;
  return SQLITE_OK;
}

#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
/*
** Routine to transform a unixFile into a proxy-locking unixFile.
** Implementation in the proxy-lock division, but used by unixOpen()
** if SQLITE_PREFER_PROXY_LOCKING is defined.
*/
static int proxyTransformUnixFile(unixFile*, const char*);
#endif

/*
** Search for an unused file descriptor that was opened on the database 
** file (not a journal or super-journal file) identified by pathname
** zPath with SQLITE_OPEN_XXX flags matching those passed as the second
** argument to this function.
**
** Such a file descriptor may exist if a database connection was closed
** but the associated file descriptor could not be closed because some
** other file descriptor open on the same file is holding a file-lock.
** Refer to comments in the unixClose() function and the lengthy comment
** describing "Posix Advisory Locking" at the start of this file for 
** further details. Also, ticket #4018.
**
** If a suitable file descriptor is found, then it is returned. If no
** such file descriptor is located, -1 is returned.
*/
static UnixUnusedFd *findReusableFd(const char *zPath, int flags){
  UnixUnusedFd *pUnused = 0;

  /* Do not search for an unused file descriptor on vxworks. Not because
  ** vxworks would not benefit from the change (it might, we're not sure),
  ** but because no way to test it is currently available. It is better 
  ** not to risk breaking vxworks support for the sake of such an obscure 
  ** feature.  */
#if !OS_VXWORKS
  struct stat sStat;                   /* Results of stat() call */

  unixEnterMutex();

  /* A stat() call may fail for various reasons. If this happens, it is
  ** almost certain that an open() call on the same path will also fail.
  ** For this reason, if an error occurs in the stat() call here, it is
  ** ignored and -1 is returned. The caller will try to open a new file
  ** descriptor on the same path, fail, and return an error to SQLite.
  **
  ** Even if a subsequent open() call does succeed, the consequences of
  ** not searching for a reusable file descriptor are not dire.  */
  if( inodeList!=0 && 0==osStat(zPath, &sStat) ){
    unixInodeInfo *pInode;

    pInode = inodeList;
    
// ABS Label 1067
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}

// COR Label 1068
if((pInode || (pInode->fileId.dev != sStat.st_dev || pInode->fileId.ino != (u64)sStat.st_ino)) != (pInode && (pInode->fileId.dev != sStat.st_dev || pInode->fileId.ino != (u64)sStat.st_ino)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1068);
}

// MCC Label 1069
if(pInode && ( pInode->fileId.dev != sStat.st_dev && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1069);
}
// MCC Label 1070
if(pInode && ( pInode->fileId.dev != sStat.st_dev && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1070);
}
// MCC Label 1071
if(pInode && ( !(pInode->fileId.dev != sStat.st_dev) && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1071);
}
// MCC Label 1072
if(pInode && ( !(pInode->fileId.dev != sStat.st_dev) && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1072);
}
// MCC Label 1073
if(!(pInode) && ( pInode->fileId.dev != sStat.st_dev && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1073);
}
// MCC Label 1074
if(!(pInode) && ( pInode->fileId.dev != sStat.st_dev && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1074);
}
// MCC Label 1075
if(!(pInode) && ( !(pInode->fileId.dev != sStat.st_dev) && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1075);
}
// MCC Label 1076
if(!(pInode) && ( !(pInode->fileId.dev != sStat.st_dev) && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1076);
}
while( pInode && (pInode->fileId.dev!=sStat.st_dev
                     || pInode->fileId.ino!=(u64)sStat.st_ino) ){
       pInode = pInode->pNext;
    };
// ABS Label 1077
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1077);
}

// COR Label 1078
if((pInode || (pInode->fileId.dev != sStat.st_dev || pInode->fileId.ino != (u64)sStat.st_ino)) != (pInode && (pInode->fileId.dev != sStat.st_dev || pInode->fileId.ino != (u64)sStat.st_ino)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1078);
}

// MCC Label 1079
if(pInode && ( pInode->fileId.dev != sStat.st_dev && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1079);
}
// MCC Label 1080
if(pInode && ( pInode->fileId.dev != sStat.st_dev && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1080);
}
// MCC Label 1081
if(pInode && ( !(pInode->fileId.dev != sStat.st_dev) && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1081);
}
// MCC Label 1082
if(pInode && ( !(pInode->fileId.dev != sStat.st_dev) && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1082);
}
// MCC Label 1083
if(!(pInode) && ( pInode->fileId.dev != sStat.st_dev && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1083);
}
// MCC Label 1084
if(!(pInode) && ( pInode->fileId.dev != sStat.st_dev && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1084);
}
// MCC Label 1085
if(!(pInode) && ( !(pInode->fileId.dev != sStat.st_dev) && pInode->fileId.ino != (u64)sStat.st_ino ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1085);
}
// MCC Label 1086
if(!(pInode) && ( !(pInode->fileId.dev != sStat.st_dev) && !(pInode->fileId.ino != (u64)sStat.st_ino) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1086);
}

    
// ABS Label 1087
if(pInode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1087);
}
if( pInode ){
      UnixUnusedFd **pp;
      assert( sqlite3_mutex_notheld(pInode->pLockMutex) );
      
// ABS Label 1088
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}
sqlite3_mutex_enter(pInode->pLockMutex);
      flags &= (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);
      pp = &pInode->pUnused;

// ABS Label 1090
if((*pp)->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}
// ABS Label 1091
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}
// ABS Label 1092
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// COR Label 1093
if((*pp || (*pp)->flags != flags) != (*pp && (*pp)->flags != flags))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1093);
}

// ROR Label 1094
if(((*pp)->flags == flags) != ((*pp)->flags != flags))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1094);
}

// MCC Label 1095
if(*pp && (*pp)->flags != flags ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1095);
}
// MCC Label 1096
if(*pp && !((*pp)->flags != flags) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1096);
}
// MCC Label 1097
if(!(*pp) && (*pp)->flags != flags ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1097);
}
// MCC Label 1098
if(!(*pp) && !((*pp)->flags != flags) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1098);
}
for(; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext)) {;
};
// ABS Label 1099
if((*pp)->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}
// ABS Label 1100
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}
// ABS Label 1101
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}

// COR Label 1102
if((*pp || (*pp)->flags != flags) != (*pp && (*pp)->flags != flags))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1102);
}

// ROR Label 1103
if(((*pp)->flags == flags) != ((*pp)->flags != flags))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1103);
}

// MCC Label 1104
if(*pp && (*pp)->flags != flags ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1104);
}
// MCC Label 1105
if(*pp && !((*pp)->flags != flags) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1105);
}
// MCC Label 1106
if(!(*pp) && (*pp)->flags != flags ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1106);
}
// MCC Label 1107
if(!(*pp) && !((*pp)->flags != flags) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1107);
}

      pUnused = *pp;
      
// ABS Label 1108
if(pUnused < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1108);
}
if( pUnused ){
        *pp = pUnused->pNext;
      }
      
// ABS Label 1089
if(pInode->pLockMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}
sqlite3_mutex_leave(pInode->pLockMutex);
    }
  }
  unixLeaveMutex();
#endif    /* if !OS_VXWORKS */
  
// ABS Label 1109
if(pUnused < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1109);
}
return pUnused;
}

/*
** Find the mode, uid and gid of file zFile. 
*/
static int getFileMode(
  const char *zFile,              /* File name */
  mode_t *pMode,                  /* OUT: Permissions of zFile */
  uid_t *pUid,                    /* OUT: uid of zFile. */
  gid_t *pGid                     /* OUT: gid of zFile. */
){
  struct stat sStat;              /* Output of stat() on database file */
  int rc = SQLITE_OK;
  if( 0==osStat(zFile, &sStat) ){
    *pMode = sStat.st_mode & 0777;
    *pUid = sStat.st_uid;
    *pGid = sStat.st_gid;
  }else{
    rc = SQLITE_IOERR_FSTAT;
  }
  
// ABS Label 1110
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1110);
}
return rc;
}

/*
** This function is called by unixOpen() to determine the unix permissions
** to create new files with. If no error occurs, then SQLITE_OK is returned
** and a value suitable for passing as the third argument to open(2) is
** written to *pMode. If an IO error occurs, an SQLite error code is 
** returned and the value of *pMode is not modified.
**
** In most cases, this routine sets *pMode to 0, which will become
** an indication to robust_open() to create the file using
** SQLITE_DEFAULT_FILE_PERMISSIONS adjusted by the umask.
** But if the file being opened is a WAL or regular journal file, then 
** this function queries the file-system for the permissions on the 
** corresponding database file and sets *pMode to this value. Whenever 
** possible, WAL and journal files are created using the same permissions 
** as the associated database file.
**
** If the SQLITE_ENABLE_8_3_NAMES option is enabled, then the
** original filename is unavailable.  But 8_3_NAMES is only used for
** FAT filesystems and permissions do not matter there, so just use
** the default permissions.  In 8_3_NAMES mode, leave *pMode set to zero.
*/
static int findCreateFileMode(
  const char *zPath,              /* Path of file (possibly) being created */
  int flags,                      /* Flags passed as 4th argument to xOpen() */
  mode_t *pMode,                  /* OUT: Permissions to open file with */
  uid_t *pUid,                    /* OUT: uid to set on the file */
  gid_t *pGid                     /* OUT: gid to set on the file */
){
  int rc = SQLITE_OK;             /* Return Code */
  *pMode = 0;
  *pUid = 0;
  *pGid = 0;
  
// ABS Label 1111
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1111);
}

// AOR Label 1112
if(flags | (524288 | 2048) != flags & (524288 | 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1112);
}
// AOR Label 1113
if(flags ^ (524288 | 2048) != flags & (524288 | 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1113);
}
if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){
    char zDb[MAX_PATHNAME+1];     /* Database file path */
    int nDb;                      /* Number of valid bytes in zDb */

    /* zPath is a path to a WAL or journal file. The following block derives
    ** the path to the associated database file from zPath. This block handles
    ** the following naming conventions:
    **
    **   "<path to db>-journal"
    **   "<path to db>-wal"
    **   "<path to db>-journalNN"
    **   "<path to db>-walNN"
    **
    ** where NN is a decimal number. The NN naming schemes are 
    ** used by the test_multiplex.c module.
    */
    nDb = sqlite3Strlen30(zPath) - 1; 
    
// ROR Label 1114
if((zPath[nDb] == '-') != (zPath[nDb] != '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1114);
}
while( zPath[nDb]!='-' ){
      /* In normal operation, the journal file name will always contain
      ** a '-' character.  However in 8+3 filename mode, or if a corrupt
      ** rollback journal specifies a super-journal with a goofy name, then
      ** the '-' might be missing. */
      
// ABS Label 1116
if(nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1116);
}

// COR Label 1117
if((nDb == 0 && zPath[nDb] == '.') != (nDb == 0 || zPath[nDb] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1117);
}

// ROR Label 1118
if((nDb != 0) != (nDb == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1118);
}
// ROR Label 1119
if((zPath[nDb] != '.') != (zPath[nDb] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1119);
}

// MCC Label 1120
if(nDb == 0 && zPath[nDb] == '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1120);
}
// MCC Label 1121
if(nDb == 0 && !(zPath[nDb] == '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1121);
}
// MCC Label 1122
if(!(nDb == 0) && zPath[nDb] == '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1122);
}
// MCC Label 1123
if(!(nDb == 0) && !(zPath[nDb] == '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1123);
}
if( nDb==0 || zPath[nDb]=='.' ) { return SQLITE_OK;
}
      nDb--;
    };
// ROR Label 1115
if((zPath[nDb] == '-') != (zPath[nDb] != '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1115);
}

    memcpy(zDb, zPath, nDb);
    zDb[nDb] = '\0';

    rc = getFileMode(zDb, pMode, pUid, pGid);
  }else { 
// ABS Label 1124
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1124);
}

// AOR Label 1125
if(flags | 8 != flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1125);
}
// AOR Label 1126
if(flags ^ 8 != flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1126);
}
if( flags & SQLITE_OPEN_DELETEONCLOSE ){
    *pMode = 0600;
  }else { 
// ABS Label 1127
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}

// AOR Label 1128
if(flags | 64 != flags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1128);
}
// AOR Label 1129
if(flags ^ 64 != flags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1129);
}
if( flags & SQLITE_OPEN_URI ){
    /* If this is a main database file and the file was opened using a URI
    ** filename, check for the "modeof" parameter. If present, interpret
    ** its value as a filename and try to copy the mode, uid and gid from
    ** that file.  */
    const char *z = sqlite3_uri_parameter(zPath, "modeof");
    
// ABS Label 1130
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1130);
}
if( z ){
      rc = getFileMode(z, pMode, pUid, pGid);
    }
  };}
;}

  
// ABS Label 1131
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1131);
}
return rc;
}

/*
** Open the file zPath.
** 
** Previously, the SQLite OS layer used three functions in place of this
** one:
**
**     sqlite3OsOpenReadWrite();
**     sqlite3OsOpenReadOnly();
**     sqlite3OsOpenExclusive();
**
** These calls correspond to the following combinations of flags:
**
**     ReadWrite() ->     (READWRITE | CREATE)
**     ReadOnly()  ->     (READONLY) 
**     OpenExclusive() -> (READWRITE | CREATE | EXCLUSIVE)
**
** The old OpenExclusive() accepted a boolean argument - "delFlag". If
** true, the file was configured to be automatically deleted when the
** file handle closed. To achieve the same effect using this new 
** interface, add the DELETEONCLOSE flag to those specified above for 
** OpenExclusive().
*/
static int unixOpen(
  sqlite3_vfs *pVfs,           /* The VFS for which this is the xOpen method */
  const char *zPath,           /* Pathname of file to be opened */
  sqlite3_file *pFile,         /* The file descriptor to be filled in */
  int flags,                   /* Input flags to control the opening */
  int *pOutFlags               /* Output flags returned to SQLite core */
){
  unixFile *p = (unixFile *)pFile;
  int fd = -1;                   /* File descriptor returned by open() */
  int openFlags = 0;             /* Flags to pass to open() */
  
// ABS Label 1132
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1132);
}

// AOR Label 1133
if(flags | 1048320 != flags & 1048320)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1133);
}
// AOR Label 1134
if(flags ^ 1048320 != flags & 1048320)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1134);
}
int eType = flags&0x0FFF00;  /* Type of file to open */
  int noLock;                    /* True to omit locking primitives */
  int rc = SQLITE_OK;            /* Function Return Code */
  int ctrlFlags = 0;             /* UNIXFILE_* flags */

  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);
  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);
  int isCreate     = (flags & SQLITE_OPEN_CREATE);
  int isReadonly   = (flags & SQLITE_OPEN_READONLY);
  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);
#if SQLITE_ENABLE_LOCKING_STYLE
  int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);
#endif
#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
  struct statfs fsInfo;
#endif

  /* If creating a super- or main-file journal, this function will open
  ** a file-descriptor on the directory too. The first time unixSync()
  ** is called the directory file descriptor will be fsync()ed and close()d.
  */
  int isNewJrnl = (isCreate && (
        eType==SQLITE_OPEN_SUPER_JOURNAL 
     || eType==SQLITE_OPEN_MAIN_JOURNAL 
     || eType==SQLITE_OPEN_WAL
  ));

  /* If argument zPath is a NULL pointer, this function is required to open
  ** a temporary file. Use this buffer to store the file name in.
  */
  char zTmpname[MAX_PATHNAME+2];
  
// ABS Label 1135
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1135);
}
const char *zName = zPath;

  /* Check the following statements are true: 
  **
  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and 
  **   (b) if CREATE is set, then READWRITE must also be set, and
  **   (c) if EXCLUSIVE is set, then CREATE must also be set.
  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.
  */
  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));
  assert(isCreate==0 || isReadWrite);
  assert(isExclusive==0 || isCreate);
  assert(isDelete==0 || isCreate);

  /* The main DB, main journal, WAL file and super-journal are never 
  ** automatically deleted. Nor are they ever temporary files.  */
  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );
  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );
  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_SUPER_JOURNAL );
  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );

  /* Assert that the upper layer has set one of the "file-type" flags. */
  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB 
       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL 
       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_SUPER_JOURNAL 
       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL
  );

  /* Detect a pid change and reset the PRNG.  There is a race condition
  ** here such that two or more threads all trying to open databases at
  ** the same instant might all reset the PRNG.  But multiple resets
  ** are harmless.
  */
  if( randomnessPid!=osGetpid(0) ){
    randomnessPid = osGetpid(0);
    sqlite3_randomness(0,0);
  }
  memset(p, 0, sizeof(unixFile));

  
// ABS Label 1136
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1136);
}

// ROR Label 1137
if((eType != 256) != (eType == 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1137);
}
if( eType==SQLITE_OPEN_MAIN_DB ){
    UnixUnusedFd *pUnused;
    pUnused = findReusableFd(zName, flags);
    
// ABS Label 1138
if(pUnused < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1138);
}
if( pUnused ){
      fd = pUnused->fd;
    }else{
      pUnused = sqlite3_malloc64(sizeof(*pUnused));
      if( !pUnused ){
        return SQLITE_NOMEM_BKPT;
      }
    }
    p->pPreallocatedUnused = pUnused;

    /* Database filenames are double-zero terminated if they are not
    ** URIs with parameters.  Hence, they can always be passed into
    ** sqlite3_uri_parameter(). */
    assert( (flags & SQLITE_OPEN_URI) || zName[strlen(zName)+1]==0 );

  }else { if( !zName ){
    /* If zName is NULL, the upper layer is requesting a temp file. */
    assert(isDelete && !isNewJrnl);
    rc = unixGetTempname(pVfs->mxPathname, zTmpname);
    
// ABS Label 1139
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1139);
}

// ROR Label 1140
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1140);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 1141
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1141);
}
return rc;
    }
    zName = zTmpname;

    /* Generated temporary filenames are always double-zero terminated
    ** for use by sqlite3_uri_parameter(). */
    assert( zName[strlen(zName)+1]==0 );
  };}


  /* Determine the value of the flags parameter passed to POSIX function
  ** open(). These must be calculated even if open() is not called, as
  ** they may be stored as part of the file handle and used by the 
  ** 'conch file' locking functions later on.  */
  
// ABS Label 1142
if(isReadonly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1142);
}
if( isReadonly ) {  openFlags |= O_RDONLY;
}
  
// ABS Label 1143
if(isReadWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1143);
}
if( isReadWrite ) { openFlags |= O_RDWR;
}
  
// ABS Label 1144
if(isCreate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1144);
}
if( isCreate ) {    openFlags |= O_CREAT;
}
  
// ABS Label 1145
if(isExclusive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1145);
}
if( isExclusive ) { openFlags |= (O_EXCL|O_NOFOLLOW);
}
  openFlags |= (O_LARGEFILE|O_BINARY|O_NOFOLLOW);

  
// ABS Label 1146
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1146);
}

// ROR Label 1147
if((fd <= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1147);
}
// ROR Label 1148
if((fd > 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1148);
}
// ROR Label 1149
if((fd >= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1149);
}
if( fd<0 ){
    mode_t openMode;              /* Permissions to create file with */
    uid_t uid;                    /* Userid for the file */
    gid_t gid;                    /* Groupid for the file */
    rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);
    
// ABS Label 1150
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1150);
}

// ROR Label 1151
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1151);
}
if( rc!=SQLITE_OK ){
      assert( !p->pPreallocatedUnused );
      assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );
      
// ABS Label 1152
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}
return rc;
    }
    fd = robust_open(zName, openFlags, openMode);
    OSTRACE(("OPENX   %-3d %s 0%o\n", fd, zName, openFlags));
    assert( !isExclusive || (openFlags & O_CREAT)!=0 );
    
// ABS Label 1153
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1153);
}

// ROR Label 1154
if((fd <= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1154);
}
// ROR Label 1155
if((fd > 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1155);
}
// ROR Label 1156
if((fd >= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1156);
}
if( fd<0 ){
      if( isNewJrnl && errno==EACCES && osAccess(zName, F_OK) ){
        /* If unable to create a journal because the directory is not
        ** writable, change the error code to indicate that. */
        rc = SQLITE_READONLY_DIRECTORY;
      }else { 
// ABS Label 1157
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}

// ROR Label 1158
if(((*__errno_location()) != 17) != ((*__errno_location()) == 17))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1158);
}
if( errno==EEXIST ){
        rc = SQLITE_CANTOPEN_EXISTS;
      }else { 
// ABS Label 1159
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1159);
}
// ABS Label 1160
if(isReadWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1160);
}

// COR Label 1161
if(((*__errno_location()) != 21 || isReadWrite) != ((*__errno_location()) != 21 && isReadWrite))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1161);
}

// ROR Label 1162
if(((*__errno_location()) == 21) != ((*__errno_location()) != 21))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1162);
}

// MCC Label 1163
if((*__errno_location()) != 21 && isReadWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1163);
}
// MCC Label 1164
if((*__errno_location()) != 21 && !(isReadWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1164);
}
// MCC Label 1165
if(!((*__errno_location()) != 21) && isReadWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1165);
}
// MCC Label 1166
if(!((*__errno_location()) != 21) && !(isReadWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1166);
}
if( errno!=EISDIR && isReadWrite ){
        /* Failed to open the file for read/write access. Try read-only. */
        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);
        openFlags &= ~(O_RDWR|O_CREAT);
        flags |= SQLITE_OPEN_READONLY;
        openFlags |= O_RDONLY;
        isReadonly = 1;
        fd = robust_open(zName, openFlags, openMode);
      };}
;}

    }
    
// ABS Label 1167
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1167);
}

// ROR Label 1168
if((fd <= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1168);
}
// ROR Label 1169
if((fd > 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1169);
}
// ROR Label 1170
if((fd >= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1170);
}
if( fd<0 ){
      int rc2 = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);
      
// ABS Label 1171
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1171);
}

// ROR Label 1172
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1172);
}
if( rc==SQLITE_OK ) { rc = rc2;
}
      goto open_finished;
    }

    /* The owner of the rollback journal or WAL file should always be the
    ** same as the owner of the database file.  Try to ensure that this is
    ** the case.  The chown() system call will be a no-op if the current
    ** process lacks root privileges, be we should at least try.  Without
    ** this step, if a root process opens a database file, it can leave
    ** behinds a journal/WAL that is owned by root and hence make the
    ** database inaccessible to unprivileged processes.
    **
    ** If openMode==0, then that means uid and gid are not set correctly
    ** (probably because SQLite is configured to use 8+3 filename mode) and
    ** in that case we do not want to attempt the chown().
    */
    
// ABS Label 1173
if(openMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1173);
}

// COR Label 1174
if((openMode || (flags & (524288 | 2048)) != 0) != (openMode && (flags & (524288 | 2048)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1174);
}

// ROR Label 1175
if(((flags & (524288 | 2048)) == 0) != ((flags & (524288 | 2048)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1175);
}

// MCC Label 1176
if(openMode && (flags & (524288 | 2048)) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1176);
}
// MCC Label 1177
if(openMode && !((flags & (524288 | 2048)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1177);
}
// MCC Label 1178
if(!(openMode) && (flags & (524288 | 2048)) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1178);
}
// MCC Label 1179
if(!(openMode) && !((flags & (524288 | 2048)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1179);
}
if( openMode && (flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL))!=0 ){
      
// ABS Label 1180
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1180);
}

// ABS Label 1181
if(uid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1181);
}

// ABS Label 1182
if(gid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1182);
}
robustFchown(fd, uid, gid);
    }
  }
  assert( fd>=0 );
  
// ABS Label 1183
if(pOutFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1183);
}
if( pOutFlags ){
    *pOutFlags = flags;
  }

  
// ABS Label 1184
if(p->pPreallocatedUnused < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1184);
}
if( p->pPreallocatedUnused ){
    p->pPreallocatedUnused->fd = fd;
    p->pPreallocatedUnused->flags = 
                          flags & (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);
  }

  
// ABS Label 1185
if(isDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}
if( isDelete ){
#if OS_VXWORKS
    zPath = zName;
#elif defined(SQLITE_UNLINK_AFTER_CLOSE)
    zPath = sqlite3_mprintf("%s", zName);
    if( zPath==0 ){
      robust_close(p, fd, __LINE__);
      return SQLITE_NOMEM_BKPT;
    }
#else
    osUnlink(zName);
#endif
  }
#if SQLITE_ENABLE_LOCKING_STYLE
  else{
    p->openFlags = openFlags;
  }
#endif
  
#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
  if( fstatfs(fd, &fsInfo) == -1 ){
    storeLastErrno(p, errno);
    robust_close(p, fd, __LINE__);
    return SQLITE_IOERR_ACCESS;
  }
  if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {
    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;
  }
  if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {
    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;
  }
#endif

  /* Set up appropriate ctrlFlags */
  
// ABS Label 1187
if(isDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}
if( isDelete ) {                ctrlFlags |= UNIXFILE_DELETE;
}
  
// ABS Label 1188
if(isReadonly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1188);
}
if( isReadonly ) {              ctrlFlags |= UNIXFILE_RDONLY;
}
  noLock = eType!=SQLITE_OPEN_MAIN_DB;
  
// ABS Label 1189
if(noLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1189);
}
if( noLock ) {                  ctrlFlags |= UNIXFILE_NOLOCK;
}
  
// ABS Label 1190
if(isNewJrnl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}
if( isNewJrnl ) {               ctrlFlags |= UNIXFILE_DIRSYNC;
}
  
// ABS Label 1191
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}

// AOR Label 1192
if(flags | 64 != flags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1192);
}
// AOR Label 1193
if(flags ^ 64 != flags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1193);
}
if( flags & SQLITE_OPEN_URI ) { ctrlFlags |= UNIXFILE_URI;
}

#if SQLITE_ENABLE_LOCKING_STYLE
#if SQLITE_PREFER_PROXY_LOCKING
  isAutoProxy = 1;
#endif
  if( isAutoProxy && (zPath!=NULL) && (!noLock) && pVfs->xOpen ){
    char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");
    int useProxy = 0;

    /* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 0 means 
    ** never use proxy, NULL means use proxy for non-local files only.  */
    if( envforce!=NULL ){
      useProxy = atoi(envforce)>0;
    }else{
      useProxy = !(fsInfo.f_flags&MNT_LOCAL);
    }
    if( useProxy ){
      rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);
      if( rc==SQLITE_OK ){
        rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");
        if( rc!=SQLITE_OK ){
          /* Use unixClose to clean up the resources added in fillInUnixFile 
          ** and clear all the structure's references.  Specifically, 
          ** pFile->pMethods will be NULL so sqlite3OsClose will be a no-op 
          */
          unixClose(pFile);
          return rc;
        }
      }
      goto open_finished;
    }
  }
#endif
  
  assert( zPath==0 || zPath[0]=='/' 
      || eType==SQLITE_OPEN_SUPER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL 
  );
  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);

open_finished:
  
// ABS Label 1194
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1194);
}

// ROR Label 1195
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1195);
}
if( rc!=SQLITE_OK ){
    sqlite3_free(p->pPreallocatedUnused);
  }
  
// ABS Label 1196
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1196);
}
return rc;
}


/*
** Delete the file at zPath. If the dirSync argument is true, fsync()
** the directory after deleting the file.
*/
static int unixDelete(
  sqlite3_vfs *NotUsed,     /* VFS containing this as the xDelete method */
  const char *zPath,        /* Name of file to be deleted */
  int dirSync               /* If true, fsync() directory after deleting file */
){
  int rc = SQLITE_OK;
  UNUSED_PARAMETER(NotUsed);
  SimulateIOError(return SQLITE_IOERR_DELETE);
  if( osUnlink(zPath)==(-1) ){
    
// ABS Label 1197
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1197);
}

// ROR Label 1198
if(((*__errno_location()) != 2) != ((*__errno_location()) == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1198);
}
if( errno==ENOENT
#if OS_VXWORKS
        || osAccess(zPath,0)!=0
#endif
    ){
      rc = SQLITE_IOERR_DELETE_NOENT;
    }else{
      rc = unixLogError(SQLITE_IOERR_DELETE, "unlink", zPath);
    }
    
// ABS Label 1199
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}
return rc;
  }
#ifndef SQLITE_DISABLE_DIRSYNC
  
// ROR Label 1200
if(((dirSync & 1) == 0) != ((dirSync & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1200);
}
if( (dirSync & 1)!=0 ){
    int fd;
    rc = osOpenDirectory(zPath, &fd);
    
// ABS Label 1201
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1201);
}

// ROR Label 1202
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1202);
}
if( rc==SQLITE_OK ){
      if( full_fsync(fd,0,0) ){
        rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, "fsync", zPath);
      }
      
// ABS Label 1203
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1203);
}
robust_close(0, fd, __LINE__);
    }else{
      assert( rc==SQLITE_CANTOPEN );
      rc = SQLITE_OK;
    }
  }
#endif
  
// ABS Label 1204
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1204);
}
return rc;
}

/*
** Test the existence of or access permissions of file zPath. The
** test performed depends on the value of flags:
**
**     SQLITE_ACCESS_EXISTS: Return 1 if the file exists
**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.
**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.
**
** Otherwise return 0.
*/
static int unixAccess(
  sqlite3_vfs *NotUsed,   /* The VFS containing this xAccess method */
  const char *zPath,      /* Path of the file to examine */
  int flags,              /* What do we want to learn about the zPath file? */
  int *pResOut            /* Write result boolean here */
){
  UNUSED_PARAMETER(NotUsed);
  SimulateIOError( return SQLITE_IOERR_ACCESS; );
  assert( pResOut!=0 );

  /* The spec says there are three possible values for flags.  But only
  ** two of them are actually used */
  assert( flags==SQLITE_ACCESS_EXISTS || flags==SQLITE_ACCESS_READWRITE );

  
// ABS Label 1205
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1205);
}

// ROR Label 1206
if((flags != 0) != (flags == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1206);
}
if( flags==SQLITE_ACCESS_EXISTS ){
    struct stat buf;
    *pResOut = 0==osStat(zPath, &buf) &&
                (!S_ISREG(buf.st_mode) || buf.st_size>0);
  }else{
    *pResOut = osAccess(zPath, W_OK|R_OK)==0;
  }
  return SQLITE_OK;
}

/*
** If the last component of the pathname in z[0]..z[j-1] is something
** other than ".." then back it out and return true.  If the last
** component is empty or if it is ".." then return false.
*/
static int unixBackupDir(const char *z, int *pJ){
  
// ABS Label 1207
if(*pJ < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1207);
}
int j = *pJ;
  int i;
  
// ABS Label 1208
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1208);
}

// ROR Label 1209
if((j < 0) != (j <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1209);
}
// ROR Label 1210
if((j > 0) != (j <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1210);
}
// ROR Label 1211
if((j >= 0) != (j <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1211);
}
if( j<=0 ) { return 0;
}
  i = j - 1;

// ABS Label 1212
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1212);
}

// COR Label 1213
if((i > 0 || z[i - 1] != '/') != (i > 0 && z[i - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1213);
}

// ROR Label 1214
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1214);
}
// ROR Label 1215
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1215);
}
// ROR Label 1216
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1216);
}
// ROR Label 1217
if((z[i - 1] == '/') != (z[i - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1217);
}

// MCC Label 1218
if(i > 0 && z[i - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1218);
}
// MCC Label 1219
if(i > 0 && !(z[i - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1219);
}
// MCC Label 1220
if(!(i > 0) && z[i - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1220);
}
// MCC Label 1221
if(!(i > 0) && !(z[i - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1221);
}
for(; i>0 && z[i-1]!='/'; i--){};
// ABS Label 1222
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1222);
}

// COR Label 1223
if((i > 0 || z[i - 1] != '/') != (i > 0 && z[i - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1223);
}

// ROR Label 1224
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1224);
}
// ROR Label 1225
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1225);
}
// ROR Label 1226
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1226);
}
// ROR Label 1227
if((z[i - 1] == '/') != (z[i - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1227);
}

// MCC Label 1228
if(i > 0 && z[i - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1228);
}
// MCC Label 1229
if(i > 0 && !(z[i - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1229);
}
// MCC Label 1230
if(!(i > 0) && z[i - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1230);
}
// MCC Label 1231
if(!(i > 0) && !(z[i - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1231);
}

  
// ABS Label 1232
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1232);
}

// ROR Label 1233
if((i != 0) != (i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1233);
}
if( i==0 ) { return 0;
}
  
// ABS Label 1234
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1234);
}
// ABS Label 1235
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1235);
}

// AOR Label 1236
if(j / 2 != j - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1236);
}
// AOR Label 1237
if(j + 2 != j - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1237);
}
// AOR Label 1238
if(j * 2 != j - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1238);
}

// COR Label 1239
if((z[i] == '.' && i == j - 2 || z[i + 1] == '.') != (z[i] == '.' && i == j - 2 && z[i + 1] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1239);
}
// COR Label 1240
if((z[i] == '.' || i == j - 2) != (z[i] == '.' && i == j - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1240);
}

// ROR Label 1241
if((z[i] != '.') != (z[i] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1241);
}
// ROR Label 1242
if((i != j - 2) != (i == j - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1242);
}
// ROR Label 1243
if((z[i + 1] != '.') != (z[i + 1] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1243);
}

// MCC Label 1244
if(z[i] == '.' && i == j - 2 && z[i + 1] == '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1244);
}
// MCC Label 1245
if(z[i] == '.' && i == j - 2 && !(z[i + 1] == '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1245);
}
// MCC Label 1246
if(z[i] == '.' && !(i == j - 2) && z[i + 1] == '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1246);
}
// MCC Label 1247
if(z[i] == '.' && !(i == j - 2) && !(z[i + 1] == '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1247);
}
// MCC Label 1248
if(!(z[i] == '.') && i == j - 2 && z[i + 1] == '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1248);
}
// MCC Label 1249
if(!(z[i] == '.') && i == j - 2 && !(z[i + 1] == '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1249);
}
// MCC Label 1250
if(!(z[i] == '.') && !(i == j - 2) && z[i + 1] == '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1250);
}
// MCC Label 1251
if(!(z[i] == '.') && !(i == j - 2) && !(z[i + 1] == '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1251);
}
if( z[i]=='.' && i==j-2 && z[i+1]=='.' ) { return 0;
}
  *pJ = i-1;
  return 1;
}

/*
** Convert a relative pathname into a full pathname.  Also
** simplify the pathname as follows:
**
**    Remove all instances of /./
**    Remove all isntances of /X/../ for any X
*/
static int mkFullPathname(
  const char *zPath,              /* Input path */
  char *zOut,                     /* Output buffer */
  int nOut                        /* Allocated size of buffer zOut */
){
  int nPath = sqlite3Strlen30(zPath);
  int iOff = 0;
  int i, j;
  
// ROR Label 1258
if((zPath[0] == '/') != (zPath[0] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1258);
}
if( zPath[0]!='/' ){
    if( osGetcwd(zOut, nOut-2)==0 ){
      return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);
    }
    iOff = sqlite3Strlen30(zOut);
    zOut[iOff++] = '/';
  }
  
// ABS Label 1259
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1259);
}

// ROR Label 1260
if(((iOff + nPath + 1) <= nOut) != ((iOff + nPath + 1) > nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1260);
}
// ROR Label 1261
if(((iOff + nPath + 1) < nOut) != ((iOff + nPath + 1) > nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1261);
}
// ROR Label 1262
if(((iOff + nPath + 1) >= nOut) != ((iOff + nPath + 1) > nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1262);
}
if( (iOff+nPath+1)>nOut ){
    /* SQLite assumes that xFullPathname() nul-terminates the output buffer
    ** even if it returns an error.  */
    zOut[iOff] = '\0';
    return SQLITE_CANTOPEN_BKPT;
  }
  
// ABS Label 1252
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1252);
}
// ABS Label 1253
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1253);
}

// AOR Label 1254
if(nOut / iOff != nOut - iOff)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1254);
}
// AOR Label 1255
if(nOut + iOff != nOut - iOff)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1255);
}
// AOR Label 1256
if(nOut * iOff != nOut - iOff)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1256);
}

// ABS Label 1257
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1257);
}
sqlite3_snprintf(nOut-iOff, &zOut[iOff], "%s", zPath);

  /* Remove duplicate '/' characters.  Except, two // at the beginning
  ** of a pathname is allowed since this is important on windows. */
  i = j = 1;

// ABS Label 1263
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1263);
}
// ABS Label 1264
if(zOut[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1264);
}
for(; zOut[i]; i++){
    zOut[j++] = zOut[i];
    
// COR Label 1267
if((zOut[i] == '/' || zOut[i + 1] == '/') != (zOut[i] == '/' && zOut[i + 1] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1267);
}

// ROR Label 1268
if((zOut[i] != '/') != (zOut[i] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1268);
}
// ROR Label 1269
if((zOut[i + 1] != '/') != (zOut[i + 1] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1269);
}

// MCC Label 1270
if(zOut[i] == '/' && zOut[i + 1] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1270);
}
// MCC Label 1271
if(zOut[i] == '/' && !(zOut[i + 1] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1271);
}
// MCC Label 1272
if(!(zOut[i] == '/') && zOut[i + 1] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1272);
}
// MCC Label 1273
if(!(zOut[i] == '/') && !(zOut[i + 1] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1273);
}
while( zOut[i]=='/' && zOut[i+1]=='/' ) { i++;
};
// COR Label 1274
if((zOut[i] == '/' || zOut[i + 1] == '/') != (zOut[i] == '/' && zOut[i + 1] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1274);
}

// ROR Label 1275
if((zOut[i] != '/') != (zOut[i] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1275);
}
// ROR Label 1276
if((zOut[i + 1] != '/') != (zOut[i + 1] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1276);
}

// MCC Label 1277
if(zOut[i] == '/' && zOut[i + 1] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1277);
}
// MCC Label 1278
if(zOut[i] == '/' && !(zOut[i + 1] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1278);
}
// MCC Label 1279
if(!(zOut[i] == '/') && zOut[i + 1] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1279);
}
// MCC Label 1280
if(!(zOut[i] == '/') && !(zOut[i + 1] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1280);
}

  };
// ABS Label 1265
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1265);
}
// ABS Label 1266
if(zOut[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1266);
}

  zOut[j] = 0;

  assert( zOut[0]=='/' );
  i = j = 0;

// ABS Label 1281
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1281);
}
// ABS Label 1282
if(zOut[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1282);
}
for(; zOut[i]; i++){
    
// ROR Label 1285
if((zOut[i] != '/') != (zOut[i] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1285);
}
if( zOut[i]=='/' ){
      /* Skip over internal "/." directory components */
      
// COR Label 1286
if((zOut[i + 1] == '.' || zOut[i + 2] == '/') != (zOut[i + 1] == '.' && zOut[i + 2] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1286);
}

// ROR Label 1287
if((zOut[i + 1] != '.') != (zOut[i + 1] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1287);
}
// ROR Label 1288
if((zOut[i + 2] != '/') != (zOut[i + 2] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1288);
}

// MCC Label 1289
if(zOut[i + 1] == '.' && zOut[i + 2] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1289);
}
// MCC Label 1290
if(zOut[i + 1] == '.' && !(zOut[i + 2] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1290);
}
// MCC Label 1291
if(!(zOut[i + 1] == '.') && zOut[i + 2] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1291);
}
// MCC Label 1292
if(!(zOut[i + 1] == '.') && !(zOut[i + 2] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1292);
}
if( zOut[i+1]=='.' && zOut[i+2]=='/' ){
        i += 1;
        continue;
      }

      /* If this is a "/.." directory component then back out the
      ** previous term of the directory if it is something other than "..".
      */
      if( zOut[i+1]=='.'
       && zOut[i+2]=='.'
       && zOut[i+3]=='/'
       && unixBackupDir(zOut, &j)
      ){
        i += 2;
        continue;
      }
    }
    
// MCC Label 1293
if(( j >= 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1293);
}
// MCC Label 1294
if(( !(j >= 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1294);
}
if( ALWAYS(j>=0) ) { zOut[j] = zOut[i];
}
    j++;
  };
// ABS Label 1283
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1283);
}
// ABS Label 1284
if(zOut[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1284);
}

  
// MCC Label 1295
if(( j == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1295);
}
// MCC Label 1296
if(( !(j == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1296);
}
if( NEVER(j==0) ) { zOut[j++] = '/';
}
  zOut[j] = 0;
  return SQLITE_OK;
}

/*
** Turn a relative pathname into a full pathname. The relative path
** is stored as a nul-terminated string in the buffer pointed to by
** zPath. 
**
** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes 
** (in this case, MAX_PATHNAME bytes). The full-path is written to
** this buffer before returning.
*/
static int unixFullPathname(
  sqlite3_vfs *pVfs,            /* Pointer to vfs object */
  const char *zPath,            /* Possibly relative input path */
  int nOut,                     /* Size of output buffer in bytes */
  char *zOut                    /* Output buffer */
){
#if !defined(HAVE_READLINK) || !defined(HAVE_LSTAT)
  return mkFullPathname(zPath, zOut, nOut);
#else
  int rc = SQLITE_OK;
  int nByte;
  int nLink = 0;                /* Number of symbolic links followed so far */
  
// ABS Label 1297
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1297);
}
const char *zIn = zPath;      /* Input path for each iteration of loop */
  char *zDel = 0;

  assert( pVfs->mxPathname==MAX_PATHNAME );
  UNUSED_PARAMETER(pVfs);

  /* It's odd to simulate an io-error here, but really this is just
  ** using the io-error infrastructure to test that SQLite handles this
  ** function failing. This function could fail if, for example, the
  ** current working directory has been unlinked.
  */
  SimulateIOError( return SQLITE_ERROR );

  
// ABS Label 1298
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1298);
}

// ROR Label 1299
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1299);
}
do {

    /* Call stat() on path zIn. Set bLink to true if the path is a symbolic
    ** link, or false otherwise.  */
    int bLink = 0;
    struct stat buf;
    if( osLstat(zIn, &buf)!=0 ){
      
// ABS Label 1302
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1302);
}

// ROR Label 1303
if(((*__errno_location()) == 2) != ((*__errno_location()) != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1303);
}
if( errno!=ENOENT ){
        rc = unixLogError(SQLITE_CANTOPEN_BKPT, "lstat", zIn);
      }
    }else{
      bLink = S_ISLNK(buf.st_mode);
    }

    
// ABS Label 1304
if(bLink < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1304);
}
if( bLink ){
      nLink++;
      
// ABS Label 1305
if(zDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1305);
}

// ROR Label 1306
if((zDel != 0) != (zDel == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1306);
}
if( zDel==0 ){
        zDel = sqlite3_malloc(nOut);
        
// ABS Label 1307
if(zDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1307);
}

// ROR Label 1308
if((zDel != 0) != (zDel == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1308);
}
if( zDel==0 ) { rc = SQLITE_NOMEM_BKPT;
}
      }else { 
// ABS Label 1309
if(nLink < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1309);
}

// ROR Label 1310
if((nLink < 100) != (nLink >= 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1310);
}
// ROR Label 1311
if((nLink > 100) != (nLink >= 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1311);
}
// ROR Label 1312
if((nLink <= 100) != (nLink >= 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1312);
}
if( nLink>=SQLITE_MAX_SYMLINKS ){
        rc = SQLITE_CANTOPEN_BKPT;
      };}


      
// ABS Label 1313
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1313);
}

// ROR Label 1314
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1314);
}
if( rc==SQLITE_OK ){
        nByte = osReadlink(zIn, zDel, nOut-1);
        
// ABS Label 1315
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1315);
}

// ROR Label 1316
if((nByte <= 0) != (nByte < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1316);
}
// ROR Label 1317
if((nByte > 0) != (nByte < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1317);
}
// ROR Label 1318
if((nByte >= 0) != (nByte < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1318);
}
if( nByte<0 ){
          rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);
        }else{
          
// ROR Label 1319
if((zDel[0] == '/') != (zDel[0] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1319);
}
if( zDel[0]!='/' ){
            int n;
            n = sqlite3Strlen30(zIn);

// ABS Label 1320
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1320);
}

// COR Label 1321
if((n > 0 || zIn[n - 1] != '/') != (n > 0 && zIn[n - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1321);
}

// ROR Label 1322
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1322);
}
// ROR Label 1323
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1323);
}
// ROR Label 1324
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1324);
}
// ROR Label 1325
if((zIn[n - 1] == '/') != (zIn[n - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1325);
}

// MCC Label 1326
if(n > 0 && zIn[n - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1326);
}
// MCC Label 1327
if(n > 0 && !(zIn[n - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1327);
}
// MCC Label 1328
if(!(n > 0) && zIn[n - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1328);
}
// MCC Label 1329
if(!(n > 0) && !(zIn[n - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1329);
}
for(; n>0 && zIn[n-1]!='/'; n--) {;
};
// ABS Label 1330
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1330);
}

// COR Label 1331
if((n > 0 || zIn[n - 1] != '/') != (n > 0 && zIn[n - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1331);
}

// ROR Label 1332
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1332);
}
// ROR Label 1333
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1333);
}
// ROR Label 1334
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1334);
}
// ROR Label 1335
if((zIn[n - 1] == '/') != (zIn[n - 1] != '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1335);
}

// MCC Label 1336
if(n > 0 && zIn[n - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1336);
}
// MCC Label 1337
if(n > 0 && !(zIn[n - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1337);
}
// MCC Label 1338
if(!(n > 0) && zIn[n - 1] != '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1338);
}
// MCC Label 1339
if(!(n > 0) && !(zIn[n - 1] != '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1339);
}

            
// ABS Label 1340
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1340);
}
// ABS Label 1341
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1341);
}
// ABS Label 1342
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1342);
}

// AOR Label 1343
if(nByte + n - 1 != nByte + n + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1343);
}
// AOR Label 1344
if(nByte + n / 1 != nByte + n + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1344);
}
// AOR Label 1345
if(nByte + n * 1 != nByte + n + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1345);
}
// AOR Label 1346
if(nByte - n != nByte + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1346);
}
// AOR Label 1347
if(nByte / n != nByte + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1347);
}
// AOR Label 1348
if(nByte * n != nByte + n)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1348);
}

// ROR Label 1349
if((nByte + n + 1 <= nOut) != (nByte + n + 1 > nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1349);
}
// ROR Label 1350
if((nByte + n + 1 < nOut) != (nByte + n + 1 > nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1350);
}
// ROR Label 1351
if((nByte + n + 1 >= nOut) != (nByte + n + 1 > nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1351);
}
if( nByte+n+1>nOut ){
              rc = SQLITE_CANTOPEN_BKPT;
            }else{
              memmove(&zDel[n], zDel, nByte+1);
              memcpy(zDel, zIn, n);
              nByte += n;
            }
          }
          zDel[nByte] = '\0';
        }
      }

      zIn = zDel;
    }

    assert( rc!=SQLITE_OK || zIn!=zOut || zIn[0]=='/' );
    
// ABS Label 1352
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}
// ABS Label 1353
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1353);
}

// COR Label 1354
if((rc == 0 || zIn != zOut) != (rc == 0 && zIn != zOut))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1354);
}

// ROR Label 1355
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1355);
}
// ROR Label 1356
if((zIn == zOut) != (zIn != zOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1356);
}

// MCC Label 1357
if(rc == 0 && zIn != zOut ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1357);
}
// MCC Label 1358
if(rc == 0 && !(zIn != zOut) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1358);
}
// MCC Label 1359
if(!(rc == 0) && zIn != zOut ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1359);
}
// MCC Label 1360
if(!(rc == 0) && !(zIn != zOut) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1360);
}
if( rc==SQLITE_OK && zIn!=zOut ){
      rc = mkFullPathname(zIn, zOut, nOut);
    }
    
// ABS Label 1361
if(bLink < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1361);
}

// ROR Label 1362
if((bLink != 0) != (bLink == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1362);
}
if( bLink==0 ) { break;
}
    zIn = zOut;
  }while( rc==SQLITE_OK );
// ABS Label 1300
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1300);
}

// ROR Label 1301
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1301);
}
;

  sqlite3_free(zDel);
  
// ABS Label 1363
if(nLink < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1363);
}
// ABS Label 1364
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1364);
}

// COR Label 1365
if((rc == 0 || nLink) != (rc == 0 && nLink))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1365);
}

// ROR Label 1366
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1366);
}

// MCC Label 1367
if(rc == 0 && nLink ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1367);
}
// MCC Label 1368
if(rc == 0 && !(nLink) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1368);
}
// MCC Label 1369
if(!(rc == 0) && nLink ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1369);
}
// MCC Label 1370
if(!(rc == 0) && !(nLink) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1370);
}
if( rc==SQLITE_OK && nLink ) { rc = SQLITE_OK_SYMLINK;
}
  
// ABS Label 1371
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1371);
}
return rc;
#endif   /* HAVE_READLINK && HAVE_LSTAT */
}


#ifndef SQLITE_OMIT_LOAD_EXTENSION
/*
** Interfaces for opening a shared library, finding entry points
** within the shared library, and closing the shared library.
*/
#include <dlfcn.h>
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){
  UNUSED_PARAMETER(NotUsed);
  return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);
}

/*
** SQLite calls this function immediately after a call to unixDlSym() or
** unixDlOpen() fails (returns a null pointer). If a more detailed error
** message is available, it is written to zBufOut. If no error message
** is available, zBufOut is left unmodified and SQLite uses a default
** error message.
*/
static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){
  const char *zErr;
  UNUSED_PARAMETER(NotUsed);
  unixEnterMutex();
  zErr = dlerror();
  
// ABS Label 1372
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1372);
}
if( zErr ){
    
// ABS Label 1373
if(nBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1373);
}

// ABS Label 1374
if(zBufOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1374);
}

// ABS Label 1375
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1375);
}
sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);
  }
  unixLeaveMutex();
}
static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){
  /* 
  ** GCC with -pedantic-errors says that C90 does not allow a void* to be
  ** cast into a pointer to a function.  And yet the library dlsym() routine
  ** returns a void* which is really a pointer to a function.  So how do we
  ** use dlsym() with -pedantic-errors?
  **
  ** Variable x below is defined to be a pointer to a function taking
  ** parameters void* and const char* and returning a pointer to a function.
  ** We initialize x by assigning it a pointer to the dlsym() function.
  ** (That assignment requires a cast.)  Then we call the function that
  ** x points to.  
  **
  ** This work-around is unlikely to work correctly on any system where
  ** you really cannot cast a function pointer into void*.  But then, on the
  ** other hand, dlsym() will not work on such a system either, so we have
  ** not really lost anything.
  */
  void (*(*x)(void*,const char*))(void);
  UNUSED_PARAMETER(NotUsed);
  x = (void(*(*)(void*,const char*))(void))dlsym;
  return (*x)(p, zSym);
}
static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){
  UNUSED_PARAMETER(NotUsed);
  
// ABS Label 1376
if(pHandle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1376);
}
dlclose(pHandle);
}
#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */
  #define unixDlOpen  0
  #define unixDlError 0
  #define unixDlSym   0
  #define unixDlClose 0
#endif

/*
** Write nBuf bytes of random data to the supplied buffer zBuf.
*/
static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){
  UNUSED_PARAMETER(NotUsed);
  assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int)));

  /* We have to initialize zBuf to prevent valgrind from reporting
  ** errors.  The reports issued by valgrind are incorrect - we would
  ** prefer that the randomness be increased by making use of the
  ** uninitialized space in zBuf - but valgrind errors tend to worry
  ** some users.  Rather than argue, it seems easier just to initialize
  ** the whole array and silence valgrind, even if that means less randomness
  ** in the random seed.
  **
  ** When testing, initializing zBuf[] to zero is all we do.  That means
  ** that we always use the same random number sequence.  This makes the
  ** tests repeatable.
  */
  memset(zBuf, 0, nBuf);
  randomnessPid = osGetpid(0);  
#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)
  {
    int fd, got;
    fd = robust_open("/dev/urandom", O_RDONLY, 0);
    
// ABS Label 1377
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1377);
}

// ROR Label 1378
if((fd <= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1378);
}
// ROR Label 1379
if((fd > 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1379);
}
// ROR Label 1380
if((fd >= 0) != (fd < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1380);
}
if( fd<0 ){
      time_t t;
      time(&t);
      memcpy(zBuf, &t, sizeof(t));
      memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));
      assert( sizeof(t)+sizeof(randomnessPid)<=(size_t)nBuf );
      nBuf = sizeof(t) + sizeof(randomnessPid);
    }else{
      
// ABS Label 1382
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1382);
}
// ABS Label 1383
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1383);
}

// COR Label 1384
if((got < 0 || (*__errno_location()) == 4) != (got < 0 && (*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1384);
}

// ROR Label 1385
if((got <= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1385);
}
// ROR Label 1386
if((got > 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1386);
}
// ROR Label 1387
if((got >= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1387);
}
// ROR Label 1388
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1388);
}

// MCC Label 1389
if(got < 0 && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1389);
}
// MCC Label 1390
if(got < 0 && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1390);
}
// MCC Label 1391
if(!(got < 0) && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1391);
}
// MCC Label 1392
if(!(got < 0) && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1392);
}
do{ got = osRead(fd, zBuf, nBuf); }while( got<0 && errno==EINTR );
// ABS Label 1393
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1393);
}
// ABS Label 1394
if(got < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1394);
}

// COR Label 1395
if((got < 0 || (*__errno_location()) == 4) != (got < 0 && (*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1395);
}

// ROR Label 1396
if((got <= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1396);
}
// ROR Label 1397
if((got > 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1397);
}
// ROR Label 1398
if((got >= 0) != (got < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1398);
}
// ROR Label 1399
if(((*__errno_location()) != 4) != ((*__errno_location()) == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1399);
}

// MCC Label 1400
if(got < 0 && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1400);
}
// MCC Label 1401
if(got < 0 && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1401);
}
// MCC Label 1402
if(!(got < 0) && (*__errno_location()) == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1402);
}
// MCC Label 1403
if(!(got < 0) && !((*__errno_location()) == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1403);
}
;
      
// ABS Label 1381
if(fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1381);
}
robust_close(0, fd, __LINE__);
    }
  }
#endif
  
// ABS Label 1404
if(nBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1404);
}
return nBuf;
}


/*
** Sleep for a little while.  Return the amount of time slept.
** The argument is the number of microseconds we want to sleep.
** The return value is the number of microseconds of sleep actually
** requested from the underlying operating system, a number which
** might be greater than or equal to the argument, but not less
** than the argument.
*/
static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){
#if OS_VXWORKS
  struct timespec sp;

  sp.tv_sec = microseconds / 1000000;
  sp.tv_nsec = (microseconds % 1000000) * 1000;
  nanosleep(&sp, NULL);
  UNUSED_PARAMETER(NotUsed);
  return microseconds;
#elif defined(HAVE_USLEEP) && HAVE_USLEEP
  if( microseconds>=1000000 ) sleep(microseconds/1000000);
  if( microseconds%1000000 ) usleep(microseconds%1000000);
  UNUSED_PARAMETER(NotUsed);
  return microseconds;
#else
  
// AOR Label 1405
if((microseconds + 999999) - 1000000 != (microseconds + 999999) / 1000000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1405);
}
// AOR Label 1406
if((microseconds + 999999) + 1000000 != (microseconds + 999999) / 1000000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1406);
}
// AOR Label 1407
if((microseconds + 999999) * 1000000 != (microseconds + 999999) / 1000000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1407);
}
int seconds = (microseconds+999999)/1000000;
  sleep(seconds);
  UNUSED_PARAMETER(NotUsed);
  
// ABS Label 1408
if(seconds < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1408);
}

// AOR Label 1409
if(seconds - 1000000 != seconds * 1000000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1409);
}
// AOR Label 1410
if(seconds + 1000000 != seconds * 1000000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1410);
}
// AOR Label 1411
if(seconds / 1000000 != seconds * 1000000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1411);
}
return seconds*1000000;
#endif
}

/*
** The following variable, if set to a non-zero value, is interpreted as
** the number of seconds since 1970 and is used to set the result of
** sqlite3OsCurrentTime() during testing.
*/
#ifdef SQLITE_TEST
int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */
#endif

/*
** Find the current time (in Universal Coordinated Time).  Write into *piNow
** the current time and date as a Julian Day number times 86_400_000.  In
** other words, write into *piNow the number of milliseconds since the Julian
** epoch of noon in Greenwich on November 24, 4714 B.C according to the
** proleptic Gregorian calendar.
**
** On success, return SQLITE_OK.  Return SQLITE_ERROR if the time and date 
** cannot be found.
*/
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){
  
// AOR Label 1412
if(24405875 - (sqlite3_int64)8640000 != 24405875 * (sqlite3_int64)8640000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1412);
}
// AOR Label 1413
if(24405875 + (sqlite3_int64)8640000 != 24405875 * (sqlite3_int64)8640000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1413);
}
// AOR Label 1414
if(24405875 / (sqlite3_int64)8640000 != 24405875 * (sqlite3_int64)8640000)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1414);
}
static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;
  int rc = SQLITE_OK;
#if defined(NO_GETTOD)
  time_t t;
  time(&t);
  *piNow = ((sqlite3_int64)t)*1000 + unixEpoch;
#elif OS_VXWORKS
  struct timespec sNow;
  clock_gettime(CLOCK_REALTIME, &sNow);
  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_nsec/1000000;
#else
  struct timeval sNow;
  (void)gettimeofday(&sNow, 0);  /* Cannot fail given valid arguments */
  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;
#endif

#ifdef SQLITE_TEST
  if( sqlite3_current_time ){
    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;
  }
#endif
  UNUSED_PARAMETER(NotUsed);
  
// ABS Label 1415
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1415);
}
return rc;
}

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Find the current time (in Universal Coordinated Time).  Write the
** current time and date as a Julian Day number into *prNow and
** return 0.  Return 1 if the time and date cannot be found.
*/
static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){
  sqlite3_int64 i = 0;
  int rc;
  UNUSED_PARAMETER(NotUsed);
  rc = unixCurrentTimeInt64(0, &i);
  *prNow = i/86400000.0;
  
// ABS Label 1416
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1416);
}
return rc;
}
#else
# define unixCurrentTime 0
#endif

/*
** The xGetLastError() method is designed to return a better
** low-level error message when operating-system problems come up
** during SQLite operation.  Only the integer return code is currently
** used.
*/
static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
  UNUSED_PARAMETER(NotUsed);
  UNUSED_PARAMETER(NotUsed2);
  UNUSED_PARAMETER(NotUsed3);
  
// ABS Label 1417
if((*__errno_location()) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1417);
}
return errno;
}


/*
************************ End of sqlite3_vfs methods ***************************
******************************************************************************/

/******************************************************************************
************************** Begin Proxy Locking ********************************
**
** Proxy locking is a "uber-locking-method" in this sense:  It uses the
** other locking methods on secondary lock files.  Proxy locking is a
** meta-layer over top of the primitive locking implemented above.  For
** this reason, the division that implements of proxy locking is deferred
** until late in the file (here) after all of the other I/O methods have
** been defined - so that the primitive locking methods are available
** as services to help with the implementation of proxy locking.
**
****
**
** The default locking schemes in SQLite use byte-range locks on the
** database file to coordinate safe, concurrent access by multiple readers
** and writers [http://sqlite.org/lockingv3.html].  The five file locking
** states (UNLOCKED, PENDING, SHARED, RESERVED, EXCLUSIVE) are implemented
** as POSIX read & write locks over fixed set of locations (via fsctl),
** on AFP and SMB only exclusive byte-range locks are available via fsctl
** with _IOWR('z', 23, struct ByteRangeLockPB2) to track the same 5 states.
** To simulate a F_RDLCK on the shared range, on AFP a randomly selected
** address in the shared range is taken for a SHARED lock, the entire
** shared range is taken for an EXCLUSIVE lock):
**
**      PENDING_BYTE        0x40000000
**      RESERVED_BYTE       0x40000001
**      SHARED_RANGE        0x40000002 -> 0x40000200
**
** This works well on the local file system, but shows a nearly 100x
** slowdown in read performance on AFP because the AFP client disables
** the read cache when byte-range locks are present.  Enabling the read
** cache exposes a cache coherency problem that is present on all OS X
** supported network file systems.  NFS and AFP both observe the
** close-to-open semantics for ensuring cache coherency
** [http://nfs.sourceforge.net/#faq_a8], which does not effectively
** address the requirements for concurrent database access by multiple
** readers and writers
** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].
**
** To address the performance and cache coherency issues, proxy file locking
** changes the way database access is controlled by limiting access to a
** single host at a time and moving file locks off of the database file
** and onto a proxy file on the local file system.  
**
**
** Using proxy locks
** -----------------
**
** C APIs
**
**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_SET_LOCKPROXYFILE,
**                       <proxy_path> | ":auto:");
**  sqlite3_file_control(db, dbname, SQLITE_FCNTL_GET_LOCKPROXYFILE,
**                       &<proxy_path>);
**
**
** SQL pragmas
**
**  PRAGMA [database.]lock_proxy_file=<proxy_path> | :auto:
**  PRAGMA [database.]lock_proxy_file
**
** Specifying ":auto:" means that if there is a conch file with a matching
** host ID in it, the proxy path in the conch file will be used, otherwise
** a proxy path based on the user's temp dir
** (via confstr(_CS_DARWIN_USER_TEMP_DIR,...)) will be used and the
** actual proxy file name is generated from the name and path of the
** database file.  For example:
**
**       For database path "/Users/me/foo.db" 
**       The lock path will be "<tmpdir>/sqliteplocks/_Users_me_foo.db:auto:")
**
** Once a lock proxy is configured for a database connection, it can not
** be removed, however it may be switched to a different proxy path via
** the above APIs (assuming the conch file is not being held by another
** connection or process). 
**
**
** How proxy locking works
** -----------------------
**
** Proxy file locking relies primarily on two new supporting files: 
**
**   *  conch file to limit access to the database file to a single host
**      at a time
**
**   *  proxy file to act as a proxy for the advisory locks normally
**      taken on the database
**
** The conch file - to use a proxy file, sqlite must first "hold the conch"
** by taking an sqlite-style shared lock on the conch file, reading the
** contents and comparing the host's unique host ID (see below) and lock
** proxy path against the values stored in the conch.  The conch file is
** stored in the same directory as the database file and the file name
** is patterned after the database file name as ".<databasename>-conch".
** If the conch file does not exist, or its contents do not match the
** host ID and/or proxy path, then the lock is escalated to an exclusive
** lock and the conch file contents is updated with the host ID and proxy
** path and the lock is downgraded to a shared lock again.  If the conch
** is held by another process (with a shared lock), the exclusive lock
** will fail and SQLITE_BUSY is returned.
**
** The proxy file - a single-byte file used for all advisory file locks
** normally taken on the database file.   This allows for safe sharing
** of the database file for multiple readers and writers on the same
** host (the conch ensures that they all use the same local lock file).
**
** Requesting the lock proxy does not immediately take the conch, it is
** only taken when the first request to lock database file is made.  
** This matches the semantics of the traditional locking behavior, where
** opening a connection to a database file does not take a lock on it.
** The shared lock and an open file descriptor are maintained until 
** the connection to the database is closed. 
**
** The proxy file and the lock file are never deleted so they only need
** to be created the first time they are used.
**
** Configuration options
** ---------------------
**
**  SQLITE_PREFER_PROXY_LOCKING
**
**       Database files accessed on non-local file systems are
**       automatically configured for proxy locking, lock files are
**       named automatically using the same logic as
**       PRAGMA lock_proxy_file=":auto:"
**    
**  SQLITE_PROXY_DEBUG
**
**       Enables the logging of error messages during host id file
**       retrieval and creation
**
**  LOCKPROXYDIR
**
**       Overrides the default directory used for lock proxy files that
**       are named automatically via the ":auto:" setting
**
**  SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
**
**       Permissions to use when creating a directory for storing the
**       lock proxy files, only used when LOCKPROXYDIR is not set.
**    
**    
** As mentioned above, when compiled with SQLITE_PREFER_PROXY_LOCKING,
** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 will
** force proxy locking to be used for every database file opened, and 0
** will force automatic proxy locking to be disabled for all database
** files (explicitly calling the SQLITE_FCNTL_SET_LOCKPROXYFILE pragma or
** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).
*/

/*
** Proxy locking is only available on MacOSX 
*/
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE

/*
** The proxyLockingContext has the path and file structures for the remote 
** and local proxy files in it
*/
typedef struct proxyLockingContext proxyLockingContext;
struct proxyLockingContext {
  unixFile *conchFile;         /* Open conch file */
  char *conchFilePath;         /* Name of the conch file */
  unixFile *lockProxy;         /* Open proxy lock file */
  char *lockProxyPath;         /* Name of the proxy lock file */
  char *dbPath;                /* Name of the open file */
  int conchHeld;               /* 1 if the conch is held, -1 if lockless */
  int nFails;                  /* Number of conch taking failures */
  void *oldLockingContext;     /* Original lockingcontext to restore on close */
  sqlite3_io_methods const *pOldMethod;     /* Original I/O methods for close */
};

/* 
** The proxy lock file path for the database at dbPath is written into lPath, 
** which must point to valid, writable memory large enough for a maxLen length
** file path. 
*/
static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){
  int len;
  int dbLen;
  int i;

#ifdef LOCKPROXYDIR
  len = strlcpy(lPath, LOCKPROXYDIR, maxLen);
#else
# ifdef _CS_DARWIN_USER_TEMP_DIR
  {
    if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){
      OSTRACE(("GETLOCKPATH  failed %s errno=%d pid=%d\n",
               lPath, errno, osGetpid(0)));
      return SQLITE_IOERR_LOCK;
    }
    len = strlcat(lPath, "sqliteplocks", maxLen);    
  }
# else
  len = strlcpy(lPath, "/tmp/", maxLen);
# endif
#endif

  if( lPath[len-1]!='/' ){
    len = strlcat(lPath, "/", maxLen);
  }
  
  /* transform the db path to a unique cache name */
  dbLen = (int)strlen(dbPath);
  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){
    char c = dbPath[i];
    lPath[i+len] = (c=='/')?'_':c;
  }
  lPath[i+len]='\0';
  strlcat(lPath, ":auto:", maxLen);
  OSTRACE(("GETLOCKPATH  proxy lock path=%s pid=%d\n", lPath, osGetpid(0)));
  return SQLITE_OK;
}

/* 
 ** Creates the lock file and any missing directories in lockPath
 */
static int proxyCreateLockPath(const char *lockPath){
  int i, len;
  char buf[MAXPATHLEN];
  int start = 0;
  
  assert(lockPath!=NULL);
  /* try to create all the intermediate directories */
  len = (int)strlen(lockPath);
  buf[0] = lockPath[0];
  for( i=1; i<len; i++ ){
    if( lockPath[i] == '/' && (i - start > 0) ){
      /* only mkdir if leaf dir != "." or "/" or ".." */
      if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/') 
         || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){
        buf[i]='\0';
        if( osMkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS) ){
          int err=errno;
          if( err!=EEXIST ) {
            OSTRACE(("CREATELOCKPATH  FAILED creating %s, "
                     "'%s' proxy lock path=%s pid=%d\n",
                     buf, strerror(err), lockPath, osGetpid(0)));
            return err;
          }
        }
      }
      start=i+1;
    }
    buf[i] = lockPath[i];
  }
  OSTRACE(("CREATELOCKPATH  proxy lock path=%s pid=%d\n",lockPath,osGetpid(0)));
  return 0;
}

/*
** Create a new VFS file descriptor (stored in memory obtained from
** sqlite3_malloc) and open the file named "path" in the file descriptor.
**
** The caller is responsible not only for closing the file descriptor
** but also for freeing the memory associated with the file descriptor.
*/
static int proxyCreateUnixFile(
    const char *path,        /* path for the new unixFile */
    unixFile **ppFile,       /* unixFile created and returned by ref */
    int islockfile           /* if non zero missing dirs will be created */
) {
  int fd = -1;
  unixFile *pNew;
  int rc = SQLITE_OK;
  int openFlags = O_RDWR | O_CREAT | O_NOFOLLOW;
  sqlite3_vfs dummyVfs;
  int terrno = 0;
  UnixUnusedFd *pUnused = NULL;

  /* 1. first try to open/create the file
  ** 2. if that fails, and this is a lock file (not-conch), try creating
  ** the parent directories and then try again.
  ** 3. if that fails, try to open the file read-only
  ** otherwise return BUSY (if lock file) or CANTOPEN for the conch file
  */
  pUnused = findReusableFd(path, openFlags);
  if( pUnused ){
    fd = pUnused->fd;
  }else{
    pUnused = sqlite3_malloc64(sizeof(*pUnused));
    if( !pUnused ){
      return SQLITE_NOMEM_BKPT;
    }
  }
  if( fd<0 ){
    fd = robust_open(path, openFlags, 0);
    terrno = errno;
    if( fd<0 && errno==ENOENT && islockfile ){
      if( proxyCreateLockPath(path) == SQLITE_OK ){
        fd = robust_open(path, openFlags, 0);
      }
    }
  }
  if( fd<0 ){
    openFlags = O_RDONLY | O_NOFOLLOW;
    fd = robust_open(path, openFlags, 0);
    terrno = errno;
  }
  if( fd<0 ){
    if( islockfile ){
      return SQLITE_BUSY;
    }
    switch (terrno) {
      case EACCES:
        return SQLITE_PERM;
      case EIO: 
        return SQLITE_IOERR_LOCK; /* even though it is the conch */
      default:
        return SQLITE_CANTOPEN_BKPT;
    }
  }
  
  pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));
  if( pNew==NULL ){
    rc = SQLITE_NOMEM_BKPT;
    goto end_create_proxy;
  }
  memset(pNew, 0, sizeof(unixFile));
  pNew->openFlags = openFlags;
  memset(&dummyVfs, 0, sizeof(dummyVfs));
  dummyVfs.pAppData = (void*)&autolockIoFinder;
  dummyVfs.zName = "dummy";
  pUnused->fd = fd;
  pUnused->flags = openFlags;
  pNew->pPreallocatedUnused = pUnused;
  
  rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file*)pNew, path, 0);
  if( rc==SQLITE_OK ){
    *ppFile = pNew;
    return SQLITE_OK;
  }
end_create_proxy:    
  robust_close(pNew, fd, __LINE__);
  sqlite3_free(pNew);
  sqlite3_free(pUnused);
  return rc;
}

#ifdef SQLITE_TEST
/* simulate multiple hosts by creating unique hostid file paths */
int sqlite3_hostid_num = 0;
#endif

#define PROXY_HOSTIDLEN    16  /* conch file host id length */

#if HAVE_GETHOSTUUID
/* Not always defined in the headers as it ought to be */
extern int gethostuuid(uuid_t id, const struct timespec *wait);
#endif

/* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN 
** bytes of writable memory.
*/
static int proxyGetHostID(unsigned char *pHostID, int *pError){
  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));
  memset(pHostID, 0, PROXY_HOSTIDLEN);
#if HAVE_GETHOSTUUID
  {
    struct timespec timeout = {1, 0}; /* 1 sec timeout */
    if( gethostuuid(pHostID, &timeout) ){
      int err = errno;
      if( pError ){
        *pError = err;
      }
      return SQLITE_IOERR;
    }
  }
#else
  UNUSED_PARAMETER(pError);
#endif
#ifdef SQLITE_TEST
  /* simulate multiple hosts by creating unique hostid file paths */
  if( sqlite3_hostid_num != 0){
    pHostID[0] = (char)(pHostID[0] + (char)(sqlite3_hostid_num & 0xFF));
  }
#endif
  
  return SQLITE_OK;
}

/* The conch file contains the header, host id and lock file path
 */
#define PROXY_CONCHVERSION 2   /* 1-byte header, 16-byte host id, path */
#define PROXY_HEADERLEN    1   /* conch file header length */
#define PROXY_PATHINDEX    (PROXY_HEADERLEN+PROXY_HOSTIDLEN)
#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)

/* 
** Takes an open conch file, copies the contents to a new path and then moves 
** it back.  The newly created file's file descriptor is assigned to the
** conch file structure and finally the original conch file descriptor is 
** closed.  Returns zero if successful.
*/
static int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){
  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; 
  unixFile *conchFile = pCtx->conchFile;
  char tPath[MAXPATHLEN];
  char buf[PROXY_MAXCONCHLEN];
  char *cPath = pCtx->conchFilePath;
  size_t readLen = 0;
  size_t pathLen = 0;
  char errmsg[64] = "";
  int fd = -1;
  int rc = -1;
  UNUSED_PARAMETER(myHostID);

  /* create a new path by replace the trailing '-conch' with '-break' */
  pathLen = strlcpy(tPath, cPath, MAXPATHLEN);
  if( pathLen>MAXPATHLEN || pathLen<6 || 
     (strlcpy(&tPath[pathLen-5], "break", 6) != 5) ){
    sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);
    goto end_breaklock;
  }
  /* read the conch content */
  readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);
  if( readLen<PROXY_PATHINDEX ){
    sqlite3_snprintf(sizeof(errmsg),errmsg,"read error (len %d)",(int)readLen);
    goto end_breaklock;
  }
  /* write it out to the temporary break file */
  fd = robust_open(tPath, (O_RDWR|O_CREAT|O_EXCL|O_NOFOLLOW), 0);
  if( fd<0 ){
    sqlite3_snprintf(sizeof(errmsg), errmsg, "create failed (%d)", errno);
    goto end_breaklock;
  }
  if( osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen ){
    sqlite3_snprintf(sizeof(errmsg), errmsg, "write failed (%d)", errno);
    goto end_breaklock;
  }
  if( rename(tPath, cPath) ){
    sqlite3_snprintf(sizeof(errmsg), errmsg, "rename failed (%d)", errno);
    goto end_breaklock;
  }
  rc = 0;
  fprintf(stderr, "broke stale lock on %s\n", cPath);
  robust_close(pFile, conchFile->h, __LINE__);
  conchFile->h = fd;
  conchFile->openFlags = O_RDWR | O_CREAT;

end_breaklock:
  if( rc ){
    if( fd>=0 ){
      osUnlink(tPath);
      robust_close(pFile, fd, __LINE__);
    }
    fprintf(stderr, "failed to break stale lock on %s, %s\n", cPath, errmsg);
  }
  return rc;
}

/* Take the requested lock on the conch file and break a stale lock if the 
** host id matches.
*/
static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){
  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; 
  unixFile *conchFile = pCtx->conchFile;
  int rc = SQLITE_OK;
  int nTries = 0;
  struct timespec conchModTime;
  
  memset(&conchModTime, 0, sizeof(conchModTime));
  do {
    rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
    nTries ++;
    if( rc==SQLITE_BUSY ){
      /* If the lock failed (busy):
       * 1st try: get the mod time of the conch, wait 0.5s and try again. 
       * 2nd try: fail if the mod time changed or host id is different, wait 
       *           10 sec and try again
       * 3rd try: break the lock unless the mod time has changed.
       */
      struct stat buf;
      if( osFstat(conchFile->h, &buf) ){
        storeLastErrno(pFile, errno);
        return SQLITE_IOERR_LOCK;
      }
      
      if( nTries==1 ){
        conchModTime = buf.st_mtimespec;
        unixSleep(0,500000); /* wait 0.5 sec and try the lock again*/
        continue;  
      }

      assert( nTries>1 );
      if( conchModTime.tv_sec != buf.st_mtimespec.tv_sec || 
         conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec ){
        return SQLITE_BUSY;
      }
      
      if( nTries==2 ){  
        char tBuf[PROXY_MAXCONCHLEN];
        int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);
        if( len<0 ){
          storeLastErrno(pFile, errno);
          return SQLITE_IOERR_LOCK;
        }
        if( len>PROXY_PATHINDEX && tBuf[0]==(char)PROXY_CONCHVERSION){
          /* don't break the lock if the host id doesn't match */
          if( 0!=memcmp(&tBuf[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN) ){
            return SQLITE_BUSY;
          }
        }else{
          /* don't break the lock on short read or a version mismatch */
          return SQLITE_BUSY;
        }
        unixSleep(0,10000000); /* wait 10 sec and try the lock again */
        continue; 
      }
      
      assert( nTries==3 );
      if( 0==proxyBreakConchLock(pFile, myHostID) ){
        rc = SQLITE_OK;
        if( lockType==EXCLUSIVE_LOCK ){
          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);
        }
        if( !rc ){
          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
        }
      }
    }
  } while( rc==SQLITE_BUSY && nTries<3 );
  
  return rc;
}

/* Takes the conch by taking a shared lock and read the contents conch, if 
** lockPath is non-NULL, the host ID and lock file path must match.  A NULL 
** lockPath means that the lockPath in the conch file will be used if the 
** host IDs match, or a new lock path will be generated automatically 
** and written to the conch file.
*/
static int proxyTakeConch(unixFile *pFile){
  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; 
  
  if( pCtx->conchHeld!=0 ){
    return SQLITE_OK;
  }else{
    unixFile *conchFile = pCtx->conchFile;
    uuid_t myHostID;
    int pError = 0;
    char readBuf[PROXY_MAXCONCHLEN];
    char lockPath[MAXPATHLEN];
    char *tempLockPath = NULL;
    int rc = SQLITE_OK;
    int createConch = 0;
    int hostIdMatch = 0;
    int readLen = 0;
    int tryOldLockPath = 0;
    int forceNewLockPath = 0;
    
    OSTRACE(("TAKECONCH  %d for %s pid=%d\n", conchFile->h,
             (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),
             osGetpid(0)));

    rc = proxyGetHostID(myHostID, &pError);
    if( (rc&0xff)==SQLITE_IOERR ){
      storeLastErrno(pFile, pError);
      goto end_takeconch;
    }
    rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);
    if( rc!=SQLITE_OK ){
      goto end_takeconch;
    }
    /* read the existing conch file */
    readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);
    if( readLen<0 ){
      /* I/O error: lastErrno set by seekAndRead */
      storeLastErrno(pFile, conchFile->lastErrno);
      rc = SQLITE_IOERR_READ;
      goto end_takeconch;
    }else if( readLen<=(PROXY_HEADERLEN+PROXY_HOSTIDLEN) || 
             readBuf[0]!=(char)PROXY_CONCHVERSION ){
      /* a short read or version format mismatch means we need to create a new 
      ** conch file. 
      */
      createConch = 1;
    }
    /* if the host id matches and the lock path already exists in the conch
    ** we'll try to use the path there, if we can't open that path, we'll 
    ** retry with a new auto-generated path 
    */
    do { /* in case we need to try again for an :auto: named lock file */

      if( !createConch && !forceNewLockPath ){
        hostIdMatch = !memcmp(&readBuf[PROXY_HEADERLEN], myHostID, 
                                  PROXY_HOSTIDLEN);
        /* if the conch has data compare the contents */
        if( !pCtx->lockProxyPath ){
          /* for auto-named local lock file, just check the host ID and we'll
           ** use the local lock file path that's already in there
           */
          if( hostIdMatch ){
            size_t pathLen = (readLen - PROXY_PATHINDEX);
            
            if( pathLen>=MAXPATHLEN ){
              pathLen=MAXPATHLEN-1;
            }
            memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);
            lockPath[pathLen] = 0;
            tempLockPath = lockPath;
            tryOldLockPath = 1;
            /* create a copy of the lock path if the conch is taken */
            goto end_takeconch;
          }
        }else if( hostIdMatch
               && !strncmp(pCtx->lockProxyPath, &readBuf[PROXY_PATHINDEX],
                           readLen-PROXY_PATHINDEX)
        ){
          /* conch host and lock path match */
          goto end_takeconch; 
        }
      }
      
      /* if the conch isn't writable and doesn't match, we can't take it */
      if( (conchFile->openFlags&O_RDWR) == 0 ){
        rc = SQLITE_BUSY;
        goto end_takeconch;
      }
      
      /* either the conch didn't match or we need to create a new one */
      if( !pCtx->lockProxyPath ){
        proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);
        tempLockPath = lockPath;
        /* create a copy of the lock path _only_ if the conch is taken */
      }
      
      /* update conch with host and path (this will fail if other process
      ** has a shared lock already), if the host id matches, use the big
      ** stick.
      */
      futimes(conchFile->h, NULL);
      if( hostIdMatch && !createConch ){
        if( conchFile->pInode && conchFile->pInode->nShared>1 ){
          /* We are trying for an exclusive lock but another thread in this
           ** same process is still holding a shared lock. */
          rc = SQLITE_BUSY;
        } else {          
          rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);
        }
      }else{
        rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);
      }
      if( rc==SQLITE_OK ){
        char writeBuffer[PROXY_MAXCONCHLEN];
        int writeSize = 0;
        
        writeBuffer[0] = (char)PROXY_CONCHVERSION;
        memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);
        if( pCtx->lockProxyPath!=NULL ){
          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath,
                  MAXPATHLEN);
        }else{
          strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);
        }
        writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);
        robust_ftruncate(conchFile->h, writeSize);
        rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);
        full_fsync(conchFile->h,0,0);
        /* If we created a new conch file (not just updated the contents of a 
         ** valid conch file), try to match the permissions of the database 
         */
        if( rc==SQLITE_OK && createConch ){
          struct stat buf;
          int err = osFstat(pFile->h, &buf);
          if( err==0 ){
            mode_t cmode = buf.st_mode&(S_IRUSR|S_IWUSR | S_IRGRP|S_IWGRP |
                                        S_IROTH|S_IWOTH);
            /* try to match the database file R/W permissions, ignore failure */
#ifndef SQLITE_PROXY_DEBUG
            osFchmod(conchFile->h, cmode);
#else
            do{
              rc = osFchmod(conchFile->h, cmode);
            }while( rc==(-1) && errno==EINTR );
            if( rc!=0 ){
              int code = errno;
              fprintf(stderr, "fchmod %o FAILED with %d %s\n",
                      cmode, code, strerror(code));
            } else {
              fprintf(stderr, "fchmod %o SUCCEDED\n",cmode);
            }
          }else{
            int code = errno;
            fprintf(stderr, "STAT FAILED[%d] with %d %s\n", 
                    err, code, strerror(code));
#endif
          }
        }
      }
      conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, SHARED_LOCK);
      
    end_takeconch:
      OSTRACE(("TRANSPROXY: CLOSE  %d\n", pFile->h));
      if( rc==SQLITE_OK && pFile->openFlags ){
        int fd;
        if( pFile->h>=0 ){
          robust_close(pFile, pFile->h, __LINE__);
        }
        pFile->h = -1;
        fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);
        OSTRACE(("TRANSPROXY: OPEN  %d\n", fd));
        if( fd>=0 ){
          pFile->h = fd;
        }else{
          rc=SQLITE_CANTOPEN_BKPT; /* SQLITE_BUSY? proxyTakeConch called
           during locking */
        }
      }
      if( rc==SQLITE_OK && !pCtx->lockProxy ){
        char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;
        rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);
        if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM && tryOldLockPath ){
          /* we couldn't create the proxy lock file with the old lock file path
           ** so try again via auto-naming 
           */
          forceNewLockPath = 1;
          tryOldLockPath = 0;
          continue; /* go back to the do {} while start point, try again */
        }
      }
      if( rc==SQLITE_OK ){
        /* Need to make a copy of path if we extracted the value
         ** from the conch file or the path was allocated on the stack
         */
        if( tempLockPath ){
          pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);
          if( !pCtx->lockProxyPath ){
            rc = SQLITE_NOMEM_BKPT;
          }
        }
      }
      if( rc==SQLITE_OK ){
        pCtx->conchHeld = 1;
        
        if( pCtx->lockProxy->pMethod == &afpIoMethods ){
          afpLockingContext *afpCtx;
          afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;
          afpCtx->dbPath = pCtx->lockProxyPath;
        }
      } else {
        conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);
      }
      OSTRACE(("TAKECONCH  %d %s\n", conchFile->h,
               rc==SQLITE_OK?"ok":"failed"));
      return rc;
    } while (1); /* in case we need to retry the :auto: lock file - 
                 ** we should never get here except via the 'continue' call. */
  }
}

/*
** If pFile holds a lock on a conch file, then release that lock.
*/
static int proxyReleaseConch(unixFile *pFile){
  int rc = SQLITE_OK;         /* Subroutine return code */
  proxyLockingContext *pCtx;  /* The locking context for the proxy lock */
  unixFile *conchFile;        /* Name of the conch file */

  pCtx = (proxyLockingContext *)pFile->lockingContext;
  conchFile = pCtx->conchFile;
  OSTRACE(("RELEASECONCH  %d for %s pid=%d\n", conchFile->h,
           (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"), 
           osGetpid(0)));
  if( pCtx->conchHeld>0 ){
    rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);
  }
  pCtx->conchHeld = 0;
  OSTRACE(("RELEASECONCH  %d %s\n", conchFile->h,
           (rc==SQLITE_OK ? "ok" : "failed")));
  return rc;
}

/*
** Given the name of a database file, compute the name of its conch file.
** Store the conch filename in memory obtained from sqlite3_malloc64().
** Make *pConchPath point to the new name.  Return SQLITE_OK on success
** or SQLITE_NOMEM if unable to obtain memory.
**
** The caller is responsible for ensuring that the allocated memory
** space is eventually freed.
**
** *pConchPath is set to NULL if a memory allocation error occurs.
*/
static int proxyCreateConchPathname(char *dbPath, char **pConchPath){
  int i;                        /* Loop counter */
  int len = (int)strlen(dbPath); /* Length of database filename - dbPath */
  char *conchPath;              /* buffer in which to construct conch name */

  /* Allocate space for the conch filename and initialize the name to
  ** the name of the original database file. */  
  *pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);
  if( conchPath==0 ){
    return SQLITE_NOMEM_BKPT;
  }
  memcpy(conchPath, dbPath, len+1);
  
  /* now insert a "." before the last / character */
  for( i=(len-1); i>=0; i-- ){
    if( conchPath[i]=='/' ){
      i++;
      break;
    }
  }
  conchPath[i]='.';
  while ( i<len ){
    conchPath[i+1]=dbPath[i];
    i++;
  }

  /* append the "-conch" suffix to the file */
  memcpy(&conchPath[i+1], "-conch", 7);
  assert( (int)strlen(conchPath) == len+7 );

  return SQLITE_OK;
}


/* Takes a fully configured proxy locking-style unix file and switches
** the local lock file path 
*/
static int switchLockProxyPath(unixFile *pFile, const char *path) {
  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
  char *oldPath = pCtx->lockProxyPath;
  int rc = SQLITE_OK;

  if( pFile->eFileLock!=NO_LOCK ){
    return SQLITE_BUSY;
  }  

  /* nothing to do if the path is NULL, :auto: or matches the existing path */
  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ||
    (oldPath && !strncmp(oldPath, path, MAXPATHLEN)) ){
    return SQLITE_OK;
  }else{
    unixFile *lockProxy = pCtx->lockProxy;
    pCtx->lockProxy=NULL;
    pCtx->conchHeld = 0;
    if( lockProxy!=NULL ){
      rc=lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);
      if( rc ) return rc;
      sqlite3_free(lockProxy);
    }
    sqlite3_free(oldPath);
    pCtx->lockProxyPath = sqlite3DbStrDup(0, path);
  }
  
  return rc;
}

/*
** pFile is a file that has been opened by a prior xOpen call.  dbPath
** is a string buffer at least MAXPATHLEN+1 characters in size.
**
** This routine find the filename associated with pFile and writes it
** int dbPath.
*/
static int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){
#if defined(__APPLE__)
  if( pFile->pMethod == &afpIoMethods ){
    /* afp style keeps a reference to the db path in the filePath field 
    ** of the struct */
    assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );
    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,
            MAXPATHLEN);
  } else
#endif
  if( pFile->pMethod == &dotlockIoMethods ){
    /* dot lock style uses the locking context to store the dot lock
    ** file path */
    int len = strlen((char *)pFile->lockingContext) - strlen(DOTLOCK_SUFFIX);
    memcpy(dbPath, (char *)pFile->lockingContext, len + 1);
  }else{
    /* all other styles use the locking context to store the db file path */
    assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );
    strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);
  }
  return SQLITE_OK;
}

/*
** Takes an already filled in unix file and alters it so all file locking 
** will be performed on the local proxy lock file.  The following fields
** are preserved in the locking context so that they can be restored and 
** the unix structure properly cleaned up at close time:
**  ->lockingContext
**  ->pMethod
*/
static int proxyTransformUnixFile(unixFile *pFile, const char *path) {
  proxyLockingContext *pCtx;
  char dbPath[MAXPATHLEN+1];       /* Name of the database file */
  char *lockPath=NULL;
  int rc = SQLITE_OK;
  
  if( pFile->eFileLock!=NO_LOCK ){
    return SQLITE_BUSY;
  }
  proxyGetDbPathForUnixFile(pFile, dbPath);
  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ){
    lockPath=NULL;
  }else{
    lockPath=(char *)path;
  }
  
  OSTRACE(("TRANSPROXY  %d for %s pid=%d\n", pFile->h,
           (lockPath ? lockPath : ":auto:"), osGetpid(0)));

  pCtx = sqlite3_malloc64( sizeof(*pCtx) );
  if( pCtx==0 ){
    return SQLITE_NOMEM_BKPT;
  }
  memset(pCtx, 0, sizeof(*pCtx));

  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);
  if( rc==SQLITE_OK ){
    rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);
    if( rc==SQLITE_CANTOPEN && ((pFile->openFlags&O_RDWR) == 0) ){
      /* if (a) the open flags are not O_RDWR, (b) the conch isn't there, and
      ** (c) the file system is read-only, then enable no-locking access.
      ** Ugh, since O_RDONLY==0x0000 we test for !O_RDWR since unixOpen asserts
      ** that openFlags will have only one of O_RDONLY or O_RDWR.
      */
      struct statfs fsInfo;
      struct stat conchInfo;
      int goLockless = 0;

      if( osStat(pCtx->conchFilePath, &conchInfo) == -1 ) {
        int err = errno;
        if( (err==ENOENT) && (statfs(dbPath, &fsInfo) != -1) ){
          goLockless = (fsInfo.f_flags&MNT_RDONLY) == MNT_RDONLY;
        }
      }
      if( goLockless ){
        pCtx->conchHeld = -1; /* read only FS/ lockless */
        rc = SQLITE_OK;
      }
    }
  }  
  if( rc==SQLITE_OK && lockPath ){
    pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);
  }

  if( rc==SQLITE_OK ){
    pCtx->dbPath = sqlite3DbStrDup(0, dbPath);
    if( pCtx->dbPath==NULL ){
      rc = SQLITE_NOMEM_BKPT;
    }
  }
  if( rc==SQLITE_OK ){
    /* all memory is allocated, proxys are created and assigned, 
    ** switch the locking context and pMethod then return.
    */
    pCtx->oldLockingContext = pFile->lockingContext;
    pFile->lockingContext = pCtx;
    pCtx->pOldMethod = pFile->pMethod;
    pFile->pMethod = &proxyIoMethods;
  }else{
    if( pCtx->conchFile ){ 
      pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);
      sqlite3_free(pCtx->conchFile);
    }
    sqlite3DbFree(0, pCtx->lockProxyPath);
    sqlite3_free(pCtx->conchFilePath); 
    sqlite3_free(pCtx);
  }
  OSTRACE(("TRANSPROXY  %d %s\n", pFile->h,
           (rc==SQLITE_OK ? "ok" : "failed")));
  return rc;
}


/*
** This routine handles sqlite3_file_control() calls that are specific
** to proxy locking.
*/
static int proxyFileControl(sqlite3_file *id, int op, void *pArg){
  switch( op ){
    case SQLITE_FCNTL_GET_LOCKPROXYFILE: {
      unixFile *pFile = (unixFile*)id;
      if( pFile->pMethod == &proxyIoMethods ){
        proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
        proxyTakeConch(pFile);
        if( pCtx->lockProxyPath ){
          *(const char **)pArg = pCtx->lockProxyPath;
        }else{
          *(const char **)pArg = ":auto: (not held)";
        }
      } else {
        *(const char **)pArg = NULL;
      }
      return SQLITE_OK;
    }
    case SQLITE_FCNTL_SET_LOCKPROXYFILE: {
      unixFile *pFile = (unixFile*)id;
      int rc = SQLITE_OK;
      int isProxyStyle = (pFile->pMethod == &proxyIoMethods);
      if( pArg==NULL || (const char *)pArg==0 ){
        if( isProxyStyle ){
          /* turn off proxy locking - not supported.  If support is added for
          ** switching proxy locking mode off then it will need to fail if
          ** the journal mode is WAL mode. 
          */
          rc = SQLITE_ERROR /*SQLITE_PROTOCOL? SQLITE_MISUSE?*/;
        }else{
          /* turn off proxy locking - already off - NOOP */
          rc = SQLITE_OK;
        }
      }else{
        const char *proxyPath = (const char *)pArg;
        if( isProxyStyle ){
          proxyLockingContext *pCtx = 
            (proxyLockingContext*)pFile->lockingContext;
          if( !strcmp(pArg, ":auto:") 
           || (pCtx->lockProxyPath &&
               !strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))
          ){
            rc = SQLITE_OK;
          }else{
            rc = switchLockProxyPath(pFile, proxyPath);
          }
        }else{
          /* turn on proxy file locking */
          rc = proxyTransformUnixFile(pFile, proxyPath);
        }
      }
      return rc;
    }
    default: {
      assert( 0 );  /* The call assures that only valid opcodes are sent */
    }
  }
  /*NOTREACHED*/ assert(0);
  return SQLITE_ERROR;
}

/*
** Within this division (the proxying locking implementation) the procedures
** above this point are all utilities.  The lock-related methods of the
** proxy-locking sqlite3_io_method object follow.
*/


/*
** This routine checks if there is a RESERVED lock held on the specified
** file by this or any other process. If such a lock is held, set *pResOut
** to a non-zero value otherwise *pResOut is set to zero.  The return value
** is set to SQLITE_OK unless an I/O error occurs during lock checking.
*/
static int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {
  unixFile *pFile = (unixFile*)id;
  int rc = proxyTakeConch(pFile);
  if( rc==SQLITE_OK ){
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    if( pCtx->conchHeld>0 ){
      unixFile *proxy = pCtx->lockProxy;
      return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);
    }else{ /* conchHeld < 0 is lockless */
      pResOut=0;
    }
  }
  return rc;
}

/*
** Lock the file with the lock specified by parameter eFileLock - one
** of the following:
**
**     (1) SHARED_LOCK
**     (2) RESERVED_LOCK
**     (3) PENDING_LOCK
**     (4) EXCLUSIVE_LOCK
**
** Sometimes when requesting one lock state, additional lock states
** are inserted in between.  The locking might fail on one of the later
** transitions leaving the lock state different from what it started but
** still short of its goal.  The following chart shows the allowed
** transitions and the inserted intermediate states:
**
**    UNLOCKED -> SHARED
**    SHARED -> RESERVED
**    SHARED -> (PENDING) -> EXCLUSIVE
**    RESERVED -> (PENDING) -> EXCLUSIVE
**    PENDING -> EXCLUSIVE
**
** This routine will only increase a lock.  Use the sqlite3OsUnlock()
** routine to lower a locking level.
*/
static int proxyLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  int rc = proxyTakeConch(pFile);
  if( rc==SQLITE_OK ){
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    if( pCtx->conchHeld>0 ){
      unixFile *proxy = pCtx->lockProxy;
      rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);
      pFile->eFileLock = proxy->eFileLock;
    }else{
      /* conchHeld < 0 is lockless */
    }
  }
  return rc;
}


/*
** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock
** must be either NO_LOCK or SHARED_LOCK.
**
** If the locking level of the file descriptor is already at or below
** the requested locking level, this routine is a no-op.
*/
static int proxyUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  int rc = proxyTakeConch(pFile);
  if( rc==SQLITE_OK ){
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    if( pCtx->conchHeld>0 ){
      unixFile *proxy = pCtx->lockProxy;
      rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);
      pFile->eFileLock = proxy->eFileLock;
    }else{
      /* conchHeld < 0 is lockless */
    }
  }
  return rc;
}

/*
** Close a file that uses proxy locks.
*/
static int proxyClose(sqlite3_file *id) {
  if( ALWAYS(id) ){
    unixFile *pFile = (unixFile*)id;
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    unixFile *lockProxy = pCtx->lockProxy;
    unixFile *conchFile = pCtx->conchFile;
    int rc = SQLITE_OK;
    
    if( lockProxy ){
      rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, NO_LOCK);
      if( rc ) return rc;
      rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);
      if( rc ) return rc;
      sqlite3_free(lockProxy);
      pCtx->lockProxy = 0;
    }
    if( conchFile ){
      if( pCtx->conchHeld ){
        rc = proxyReleaseConch(pFile);
        if( rc ) return rc;
      }
      rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);
      if( rc ) return rc;
      sqlite3_free(conchFile);
    }
    sqlite3DbFree(0, pCtx->lockProxyPath);
    sqlite3_free(pCtx->conchFilePath);
    sqlite3DbFree(0, pCtx->dbPath);
    /* restore the original locking context and pMethod then close it */
    pFile->lockingContext = pCtx->oldLockingContext;
    pFile->pMethod = pCtx->pOldMethod;
    sqlite3_free(pCtx);
    return pFile->pMethod->xClose(id);
  }
  return SQLITE_OK;
}



#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */
/*
** The proxy locking style is intended for use with AFP filesystems.
** And since AFP is only supported on MacOSX, the proxy locking is also
** restricted to MacOSX.
** 
**
******************* End of the proxy lock implementation **********************
******************************************************************************/

/*
** Initialize the operating system interface.
**
** This routine registers all VFS implementations for unix-like operating
** systems.  This routine, and the sqlite3_os_end() routine that follows,
** should be the only routines in this file that are visible from other
** files.
**
** This routine is called once during SQLite initialization and by a
** single thread.  The memory allocation and mutex subsystems have not
** necessarily been initialized when this routine is called, and so they
** should not be used.
*/
int sqlite3_os_init(void){ 
  /* 
  ** The following macro defines an initializer for an sqlite3_vfs object.
  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer
  ** to the "finder" function.  (pAppData is a pointer to a pointer because
  ** silly C90 rules prohibit a void* from being cast to a function pointer
  ** and so we have to go through the intermediate pointer to avoid problems
  ** when compiling with -pedantic-errors on GCC.)
  **
  ** The FINDER parameter to this macro is the name of the pointer to the
  ** finder-function.  The finder-function returns a pointer to the
  ** sqlite_io_methods object that implements the desired locking
  ** behaviors.  See the division above that contains the IOMETHODS
  ** macro for addition information on finder-functions.
  **
  ** Most finders simply return a pointer to a fixed sqlite3_io_methods
  ** object.  But the "autolockIoFinder" available on MacOSX does a little
  ** more than that; it looks at the filesystem type that hosts the 
  ** database file and tries to choose an locking method appropriate for
  ** that filesystem time.
  */
  #define UNIXVFS(VFSNAME, FINDER) {                        \
    3,                    /* iVersion */                    \
    sizeof(unixFile),     /* szOsFile */                    \
    MAX_PATHNAME,         /* mxPathname */                  \
    0,                    /* pNext */                       \
    VFSNAME,              /* zName */                       \
    (void*)&FINDER,       /* pAppData */                    \
    unixOpen,             /* xOpen */                       \
    unixDelete,           /* xDelete */                     \
    unixAccess,           /* xAccess */                     \
    unixFullPathname,     /* xFullPathname */               \
    unixDlOpen,           /* xDlOpen */                     \
    unixDlError,          /* xDlError */                    \
    unixDlSym,            /* xDlSym */                      \
    unixDlClose,          /* xDlClose */                    \
    unixRandomness,       /* xRandomness */                 \
    unixSleep,            /* xSleep */                      \
    unixCurrentTime,      /* xCurrentTime */                \
    unixGetLastError,     /* xGetLastError */               \
    unixCurrentTimeInt64, /* xCurrentTimeInt64 */           \
    unixSetSystemCall,    /* xSetSystemCall */              \
    unixGetSystemCall,    /* xGetSystemCall */              \
    unixNextSystemCall,   /* xNextSystemCall */             \
  }

  /*
  ** All default VFSes for unix are contained in the following array.
  **
  ** Note that the sqlite3_vfs.pNext field of the VFS object is modified
  ** by the SQLite core when the VFS is registered.  So the following
  ** array cannot be const.
  */
  static sqlite3_vfs aVfs[] = {
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
    UNIXVFS("unix",          autolockIoFinder ),
#elif OS_VXWORKS
    UNIXVFS("unix",          vxworksIoFinder ),
#else
    UNIXVFS("unix",          posixIoFinder ),
#endif
    UNIXVFS("unix-none",     nolockIoFinder ),
    UNIXVFS("unix-dotfile",  dotlockIoFinder ),
    UNIXVFS("unix-excl",     posixIoFinder ),
#if OS_VXWORKS
    UNIXVFS("unix-namedsem", semIoFinder ),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKS
    UNIXVFS("unix-posix",    posixIoFinder ),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
    UNIXVFS("unix-flock",    flockIoFinder ),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
    UNIXVFS("unix-afp",      afpIoFinder ),
    UNIXVFS("unix-nfs",      nfsIoFinder ),
    UNIXVFS("unix-proxy",    proxyIoFinder ),
#endif
  };
  unsigned int i;          /* Loop counter */

  /* Double-check that the aSyscall[] array has been constructed
  ** correctly.  See ticket [bb3a86e890c8e96ab] */
  assert( ArraySize(aSyscall)==29 );

  /* Register all VFSes defined in the aVfs[] array */
  i = 0;

// ROR Label 1418
if((i <= (sizeof (aVfs) / sizeof(sqlite3_vfs))) != (i < (sizeof (aVfs) / sizeof(sqlite3_vfs))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1418);
}
// ROR Label 1419
if((i > (sizeof (aVfs) / sizeof(sqlite3_vfs))) != (i < (sizeof (aVfs) / sizeof(sqlite3_vfs))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1419);
}
// ROR Label 1420
if((i >= (sizeof (aVfs) / sizeof(sqlite3_vfs))) != (i < (sizeof (aVfs) / sizeof(sqlite3_vfs))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1420);
}
for(; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){
    
// ABS Label 1424
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1424);
}

// ROR Label 1425
if((i != 0) != (i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1425);
}
sqlite3_vfs_register(&aVfs[i], i==0);
  };
// ROR Label 1421
if((i <= (sizeof (aVfs) / sizeof(sqlite3_vfs))) != (i < (sizeof (aVfs) / sizeof(sqlite3_vfs))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1421);
}
// ROR Label 1422
if((i > (sizeof (aVfs) / sizeof(sqlite3_vfs))) != (i < (sizeof (aVfs) / sizeof(sqlite3_vfs))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1422);
}
// ROR Label 1423
if((i >= (sizeof (aVfs) / sizeof(sqlite3_vfs))) != (i < (sizeof (aVfs) / sizeof(sqlite3_vfs))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1423);
}

  unixBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);

#ifndef SQLITE_OMIT_WAL
  /* Validate lock assumptions */
  assert( SQLITE_SHM_NLOCK==8 );  /* Number of available locks */
  assert( UNIX_SHM_BASE==120  );  /* Start of locking area */
  /* Locks:
  **    WRITE       UNIX_SHM_BASE      120
  **    CKPT        UNIX_SHM_BASE+1    121
  **    RECOVER     UNIX_SHM_BASE+2    122
  **    READ-0      UNIX_SHM_BASE+3    123
  **    READ-1      UNIX_SHM_BASE+4    124
  **    READ-2      UNIX_SHM_BASE+5    125
  **    READ-3      UNIX_SHM_BASE+6    126
  **    READ-4      UNIX_SHM_BASE+7    127
  **    DMS         UNIX_SHM_BASE+8    128
  */
  assert( UNIX_SHM_DMS==128   );  /* Byte offset of the deadman-switch */
#endif

  return SQLITE_OK; 
}

/*
** Shutdown the operating system interface.
**
** Some operating systems might need to do some cleanup in this routine,
** to release dynamically allocated objects.  But not on unix.
** This routine is a no-op for unix.
*/
int sqlite3_os_end(void){ 
  unixBigLock = 0;
  return SQLITE_OK; 
}
 
#endif /* SQLITE_OS_UNIX */
