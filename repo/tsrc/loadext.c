/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2006 June 7
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used to dynamically load extensions into
** the SQLite library.
*/

#ifndef SQLITE_CORE
  #define SQLITE_CORE 1  /* Disable the API redefinition in sqlite3ext.h */
#endif
#include "sqlite3ext.h"
#include "sqliteInt.h"

#ifndef SQLITE_OMIT_LOAD_EXTENSION
/*
** Some API routines are omitted when various features are
** excluded from a build of SQLite.  Substitute a NULL pointer
** for any missing APIs.
*/
#ifndef SQLITE_ENABLE_COLUMN_METADATA
# define sqlite3_column_database_name   0
# define sqlite3_column_database_name16 0
# define sqlite3_column_table_name      0
# define sqlite3_column_table_name16    0
# define sqlite3_column_origin_name     0
# define sqlite3_column_origin_name16   0
#endif

#ifdef SQLITE_OMIT_AUTHORIZATION
# define sqlite3_set_authorizer         0
#endif

#ifdef SQLITE_OMIT_UTF16
# define sqlite3_bind_text16            0
# define sqlite3_collation_needed16     0
# define sqlite3_column_decltype16      0
# define sqlite3_column_name16          0
# define sqlite3_column_text16          0
# define sqlite3_complete16             0
# define sqlite3_create_collation16     0
# define sqlite3_create_function16      0
# define sqlite3_errmsg16               0
# define sqlite3_open16                 0
# define sqlite3_prepare16              0
# define sqlite3_prepare16_v2           0
# define sqlite3_prepare16_v3           0
# define sqlite3_result_error16         0
# define sqlite3_result_text16          0
# define sqlite3_result_text16be        0
# define sqlite3_result_text16le        0
# define sqlite3_value_text16           0
# define sqlite3_value_text16be         0
# define sqlite3_value_text16le         0
# define sqlite3_column_database_name16 0
# define sqlite3_column_table_name16    0
# define sqlite3_column_origin_name16   0
#endif

#ifdef SQLITE_OMIT_COMPLETE
# define sqlite3_complete 0
# define sqlite3_complete16 0
#endif

#ifdef SQLITE_OMIT_DECLTYPE
# define sqlite3_column_decltype16      0
# define sqlite3_column_decltype        0
#endif

#ifdef SQLITE_OMIT_PROGRESS_CALLBACK
# define sqlite3_progress_handler 0
#endif

#ifdef SQLITE_OMIT_VIRTUALTABLE
# define sqlite3_create_module 0
# define sqlite3_create_module_v2 0
# define sqlite3_declare_vtab 0
# define sqlite3_vtab_config 0
# define sqlite3_vtab_on_conflict 0
# define sqlite3_vtab_collation 0
#endif

#ifdef SQLITE_OMIT_SHARED_CACHE
# define sqlite3_enable_shared_cache 0
#endif

#if defined(SQLITE_OMIT_TRACE) || defined(SQLITE_OMIT_DEPRECATED)
# define sqlite3_profile       0
# define sqlite3_trace         0
#endif

#ifdef SQLITE_OMIT_GET_TABLE
# define sqlite3_free_table    0
# define sqlite3_get_table     0
#endif

#ifdef SQLITE_OMIT_INCRBLOB
#define sqlite3_bind_zeroblob  0
#define sqlite3_blob_bytes     0
#define sqlite3_blob_close     0
#define sqlite3_blob_open      0
#define sqlite3_blob_read      0
#define sqlite3_blob_write     0
#define sqlite3_blob_reopen    0
#endif

#if defined(SQLITE_OMIT_TRACE)
# define sqlite3_trace_v2      0
#endif

/*
** The following structure contains pointers to all SQLite API routines.
** A pointer to this structure is passed into extensions when they are
** loaded so that the extension can make calls back into the SQLite
** library.
**
** When adding new APIs, add them to the bottom of this structure
** in order to preserve backwards compatibility.
**
** Extensions that use newer APIs should first call the
** sqlite3_libversion_number() to make sure that the API they
** intend to use is supported by the library.  Extensions should
** also check to make sure that the pointer to the function is
** not NULL before calling it.
*/
static const sqlite3_api_routines sqlite3Apis = {
  sqlite3_aggregate_context,
#ifndef SQLITE_OMIT_DEPRECATED
  sqlite3_aggregate_count,
#else
  0,
#endif
  sqlite3_bind_blob,
  sqlite3_bind_double,
  sqlite3_bind_int,
  sqlite3_bind_int64,
  sqlite3_bind_null,
  sqlite3_bind_parameter_count,
  sqlite3_bind_parameter_index,
  sqlite3_bind_parameter_name,
  sqlite3_bind_text,
  sqlite3_bind_text16,
  sqlite3_bind_value,
  sqlite3_busy_handler,
  sqlite3_busy_timeout,
  sqlite3_changes,
  sqlite3_close,
  sqlite3_collation_needed,
  sqlite3_collation_needed16,
  sqlite3_column_blob,
  sqlite3_column_bytes,
  sqlite3_column_bytes16,
  sqlite3_column_count,
  sqlite3_column_database_name,
  sqlite3_column_database_name16,
  sqlite3_column_decltype,
  sqlite3_column_decltype16,
  sqlite3_column_double,
  sqlite3_column_int,
  sqlite3_column_int64,
  sqlite3_column_name,
  sqlite3_column_name16,
  sqlite3_column_origin_name,
  sqlite3_column_origin_name16,
  sqlite3_column_table_name,
  sqlite3_column_table_name16,
  sqlite3_column_text,
  sqlite3_column_text16,
  sqlite3_column_type,
  sqlite3_column_value,
  sqlite3_commit_hook,
  sqlite3_complete,
  sqlite3_complete16,
  sqlite3_create_collation,
  sqlite3_create_collation16,
  sqlite3_create_function,
  sqlite3_create_function16,
  sqlite3_create_module,
  sqlite3_data_count,
  sqlite3_db_handle,
  sqlite3_declare_vtab,
  sqlite3_enable_shared_cache,
  sqlite3_errcode,
  sqlite3_errmsg,
  sqlite3_errmsg16,
  sqlite3_exec,
#ifndef SQLITE_OMIT_DEPRECATED
  sqlite3_expired,
#else
  0,
#endif
  sqlite3_finalize,
  sqlite3_free,
  sqlite3_free_table,
  sqlite3_get_autocommit,
  sqlite3_get_auxdata,
  sqlite3_get_table,
  0,     /* Was sqlite3_global_recover(), but that function is deprecated */
  sqlite3_interrupt,
  sqlite3_last_insert_rowid,
  sqlite3_libversion,
  sqlite3_libversion_number,
  sqlite3_malloc,
  sqlite3_mprintf,
  sqlite3_open,
  sqlite3_open16,
  sqlite3_prepare,
  sqlite3_prepare16,
  sqlite3_profile,
  sqlite3_progress_handler,
  sqlite3_realloc,
  sqlite3_reset,
  sqlite3_result_blob,
  sqlite3_result_double,
  sqlite3_result_error,
  sqlite3_result_error16,
  sqlite3_result_int,
  sqlite3_result_int64,
  sqlite3_result_null,
  sqlite3_result_text,
  sqlite3_result_text16,
  sqlite3_result_text16be,
  sqlite3_result_text16le,
  sqlite3_result_value,
  sqlite3_rollback_hook,
  sqlite3_set_authorizer,
  sqlite3_set_auxdata,
  sqlite3_snprintf,
  sqlite3_step,
  sqlite3_table_column_metadata,
#ifndef SQLITE_OMIT_DEPRECATED
  sqlite3_thread_cleanup,
#else
  0,
#endif
  sqlite3_total_changes,
  sqlite3_trace,
#ifndef SQLITE_OMIT_DEPRECATED
  sqlite3_transfer_bindings,
#else
  0,
#endif
  sqlite3_update_hook,
  sqlite3_user_data,
  sqlite3_value_blob,
  sqlite3_value_bytes,
  sqlite3_value_bytes16,
  sqlite3_value_double,
  sqlite3_value_int,
  sqlite3_value_int64,
  sqlite3_value_numeric_type,
  sqlite3_value_text,
  sqlite3_value_text16,
  sqlite3_value_text16be,
  sqlite3_value_text16le,
  sqlite3_value_type,
  sqlite3_vmprintf,
  /*
  ** The original API set ends here.  All extensions can call any
  ** of the APIs above provided that the pointer is not NULL.  But
  ** before calling APIs that follow, extension should check the
  ** sqlite3_libversion_number() to make sure they are dealing with
  ** a library that is new enough to support that API.
  *************************************************************************
  */
  sqlite3_overload_function,

  /*
  ** Added after 3.3.13
  */
  sqlite3_prepare_v2,
  sqlite3_prepare16_v2,
  sqlite3_clear_bindings,

  /*
  ** Added for 3.4.1
  */
  sqlite3_create_module_v2,

  /*
  ** Added for 3.5.0
  */
  sqlite3_bind_zeroblob,
  sqlite3_blob_bytes,
  sqlite3_blob_close,
  sqlite3_blob_open,
  sqlite3_blob_read,
  sqlite3_blob_write,
  sqlite3_create_collation_v2,
  sqlite3_file_control,
  sqlite3_memory_highwater,
  sqlite3_memory_used,
#ifdef SQLITE_MUTEX_OMIT
  0, 
  0, 
  0,
  0,
  0,
#else
  sqlite3_mutex_alloc,
  sqlite3_mutex_enter,
  sqlite3_mutex_free,
  sqlite3_mutex_leave,
  sqlite3_mutex_try,
#endif
  sqlite3_open_v2,
  sqlite3_release_memory,
  sqlite3_result_error_nomem,
  sqlite3_result_error_toobig,
  sqlite3_sleep,
  sqlite3_soft_heap_limit,
  sqlite3_vfs_find,
  sqlite3_vfs_register,
  sqlite3_vfs_unregister,

  /*
  ** Added for 3.5.8
  */
  sqlite3_threadsafe,
  sqlite3_result_zeroblob,
  sqlite3_result_error_code,
  sqlite3_test_control,
  sqlite3_randomness,
  sqlite3_context_db_handle,

  /*
  ** Added for 3.6.0
  */
  sqlite3_extended_result_codes,
  sqlite3_limit,
  sqlite3_next_stmt,
  sqlite3_sql,
  sqlite3_status,

  /*
  ** Added for 3.7.4
  */
  sqlite3_backup_finish,
  sqlite3_backup_init,
  sqlite3_backup_pagecount,
  sqlite3_backup_remaining,
  sqlite3_backup_step,
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
  sqlite3_compileoption_get,
  sqlite3_compileoption_used,
#else
  0,
  0,
#endif
  sqlite3_create_function_v2,
  sqlite3_db_config,
  sqlite3_db_mutex,
  sqlite3_db_status,
  sqlite3_extended_errcode,
  sqlite3_log,
  sqlite3_soft_heap_limit64,
  sqlite3_sourceid,
  sqlite3_stmt_status,
  sqlite3_strnicmp,
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
  sqlite3_unlock_notify,
#else
  0,
#endif
#ifndef SQLITE_OMIT_WAL
  sqlite3_wal_autocheckpoint,
  sqlite3_wal_checkpoint,
  sqlite3_wal_hook,
#else
  0,
  0,
  0,
#endif
  sqlite3_blob_reopen,
  sqlite3_vtab_config,
  sqlite3_vtab_on_conflict,
  sqlite3_close_v2,
  sqlite3_db_filename,
  sqlite3_db_readonly,
  sqlite3_db_release_memory,
  sqlite3_errstr,
  sqlite3_stmt_busy,
  sqlite3_stmt_readonly,
  sqlite3_stricmp,
  sqlite3_uri_boolean,
  sqlite3_uri_int64,
  sqlite3_uri_parameter,
  sqlite3_vsnprintf,
  sqlite3_wal_checkpoint_v2,
  /* Version 3.8.7 and later */
  sqlite3_auto_extension,
  sqlite3_bind_blob64,
  sqlite3_bind_text64,
  sqlite3_cancel_auto_extension,
  sqlite3_load_extension,
  sqlite3_malloc64,
  sqlite3_msize,
  sqlite3_realloc64,
  sqlite3_reset_auto_extension,
  sqlite3_result_blob64,
  sqlite3_result_text64,
  sqlite3_strglob,
  /* Version 3.8.11 and later */
  (sqlite3_value*(*)(const sqlite3_value*))sqlite3_value_dup,
  sqlite3_value_free,
  sqlite3_result_zeroblob64,
  sqlite3_bind_zeroblob64,
  /* Version 3.9.0 and later */
  sqlite3_value_subtype,
  sqlite3_result_subtype,
  /* Version 3.10.0 and later */
  sqlite3_status64,
  sqlite3_strlike,
  sqlite3_db_cacheflush,
  /* Version 3.12.0 and later */
  sqlite3_system_errno,
  /* Version 3.14.0 and later */
  sqlite3_trace_v2,
  sqlite3_expanded_sql,
  /* Version 3.18.0 and later */
  sqlite3_set_last_insert_rowid,
  /* Version 3.20.0 and later */
  sqlite3_prepare_v3,
  sqlite3_prepare16_v3,
  sqlite3_bind_pointer,
  sqlite3_result_pointer,
  sqlite3_value_pointer,
  /* Version 3.22.0 and later */
  sqlite3_vtab_nochange,
  sqlite3_value_nochange,
  sqlite3_vtab_collation,
  /* Version 3.24.0 and later */
  sqlite3_keyword_count,
  sqlite3_keyword_name,
  sqlite3_keyword_check,
  sqlite3_str_new,
  sqlite3_str_finish,
  sqlite3_str_appendf,
  sqlite3_str_vappendf,
  sqlite3_str_append,
  sqlite3_str_appendall,
  sqlite3_str_appendchar,
  sqlite3_str_reset,
  sqlite3_str_errcode,
  sqlite3_str_length,
  sqlite3_str_value,
  /* Version 3.25.0 and later */
  sqlite3_create_window_function,
  /* Version 3.26.0 and later */
#ifdef SQLITE_ENABLE_NORMALIZE
  sqlite3_normalized_sql,
#else
  0,
#endif
  /* Version 3.28.0 and later */
  sqlite3_stmt_isexplain,
  sqlite3_value_frombind,
  /* Version 3.30.0 and later */
#ifndef SQLITE_OMIT_VIRTUALTABLE
  sqlite3_drop_modules,
#else
  0,
#endif
  /* Version 3.31.0 and later */
  sqlite3_hard_heap_limit64,
  sqlite3_uri_key,
  sqlite3_filename_database,
  sqlite3_filename_journal,
  sqlite3_filename_wal,
  /* Version 3.32.0 and later */
  sqlite3_create_filename,
  sqlite3_free_filename,
  sqlite3_database_file_object,
  /* Version 3.34.0 and later */
  sqlite3_txn_state,
  /* Version 3.36.1 and later */
  sqlite3_changes64,
  sqlite3_total_changes64,
};

/* True if x is the directory separator character
*/
#if SQLITE_OS_WIN
# define DirSep(X)  ((X)=='/'||(X)=='\\')
#else
# define DirSep(X)  ((X)=='/')
#endif

/*
** Attempt to load an SQLite extension library contained in the file
** zFile.  The entry point is zProc.  zProc may be 0 in which case a
** default entry point name (sqlite3_extension_init) is used.  Use
** of the default name is recommended.
**
** Return SQLITE_OK on success and SQLITE_ERROR if something goes wrong.
**
** If an error occurs and pzErrMsg is not 0, then fill *pzErrMsg with 
** error message text.  The calling function should free this memory
** by calling sqlite3DbFree(db, ).
*/
static int sqlite3LoadExtension(
  sqlite3 *db,          /* Load the extension into this database connection */
  const char *zFile,    /* Name of the shared library containing extension */
  const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */
  char **pzErrMsg       /* Put error message here if not 0 */
){
  
// ABS Label 7
if(db->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
sqlite3_vfs *pVfs = db->pVfs;
  void *handle;
  sqlite3_loadext_entry xInit;
  char *zErrmsg = 0;
  const char *zEntry;
  char *zAltEntry = 0;
  void **aHandle;
  u64 nMsg = strlen(zFile);
  int ii;
  int rc;

  /* Shared library endings to try if zFile cannot be loaded as written */
  static const char *azEndings[] = {
#if SQLITE_OS_WIN
     "dll"   
#elif defined(__APPLE__)
     "dylib"
#else
     "so"
#endif
  };


  
// ABS Label 9
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
if( pzErrMsg ) { *pzErrMsg = 0;
}

  /* Ticket #1863.  To avoid a creating security problems for older
  ** applications that relink against newer versions of SQLite, the
  ** ability to run load_extension is turned off by default.  One
  ** must call either sqlite3_enable_load_extension(db) or
  ** sqlite3_db_config(db, SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, 1, 0)
  ** to turn on extension loading.
  */
  
// ROR Label 10
if(((db->flags & 65536) != 0) != ((db->flags & 65536) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( (db->flags & SQLITE_LoadExtension)==0 ){
    
// ABS Label 11
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("not authorized");
    }
    return SQLITE_ERROR;
  }

  zEntry = zProc ? zProc : "sqlite3_extension_init";

  /* tag-20210611-1.  Some dlopen() implementations will segfault if given
  ** an oversize filename.  Most filesystems have a pathname limit of 4K,
  ** so limit the extension filename length to about twice that.
  ** https://sqlite.org/forum/forumpost/08a0d6d9bf */
  
// ABS Label 12
if(nMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ROR Label 13
if((nMsg <= 4096) != (nMsg > 4096))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if((nMsg < 4096) != (nMsg > 4096))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
// ROR Label 15
if((nMsg >= 4096) != (nMsg > 4096))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
if( nMsg>SQLITE_MAX_PATHLEN ) { goto extension_not_found;
}
    
  handle = sqlite3OsDlOpen(pVfs, zFile);
#if SQLITE_OS_UNIX || SQLITE_OS_WIN
  ii = 0;

// ABS Label 16
if(handle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
// ABS Label 17
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// COR Label 18
if((ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) || handle == 0) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 18);
}

// ROR Label 19
if((ii <= ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if((ii > ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}
// ROR Label 21
if((ii >= ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
// ROR Label 22
if((handle != 0) != (handle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}

// MCC Label 23
if(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 23);
}
// MCC Label 24
if(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && !(handle == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 24);
}
// MCC Label 25
if(!(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) && handle == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 25);
}
// MCC Label 26
if(!(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) && !(handle == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}
for(; ii<ArraySize(azEndings) && handle==0; ii++){
    char *zAltFile = sqlite3_mprintf("%s.%s", zFile, azEndings[ii]);
    
// ABS Label 38
if(zAltFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}

// ROR Label 39
if((zAltFile != 0) != (zAltFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
if( zAltFile==0 ) { return SQLITE_NOMEM_BKPT;
}
    handle = sqlite3OsDlOpen(pVfs, zAltFile);
    sqlite3_free(zAltFile);
  };
// ABS Label 27
if(handle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
// ABS Label 28
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// COR Label 29
if((ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) || handle == 0) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 29);
}

// ROR Label 30
if((ii <= ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
// ROR Label 31
if((ii > ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((ii >= ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) != (ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((handle != 0) != (handle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}

// MCC Label 34
if(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && handle == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 34);
}
// MCC Label 35
if(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0]))) && !(handle == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
// MCC Label 36
if(!(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) && handle == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 36);
}
// MCC Label 37
if(!(ii < ((int)(sizeof (azEndings) / sizeof (azEndings[0])))) && !(handle == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 37);
}

#endif
  
// ABS Label 40
if(handle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}

// ROR Label 41
if((handle != 0) != (handle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
if( handle==0 ) { goto extension_not_found;
}
  xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);

  /* If no entry point was specified and the default legacy
  ** entry point name "sqlite3_extension_init" was not found, then
  ** construct an entry point name "sqlite3_X_init" where the X is
  ** replaced by the lowercase value of every ASCII alphabetic 
  ** character in the filename after the last "/" upto the first ".",
  ** and eliding the first three characters if they are "lib".  
  ** Examples:
  **
  **    /usr/local/lib/libExample5.4.3.so ==>  sqlite3_example_init
  **    C:/lib/mathfuncs.dll              ==>  sqlite3_mathfuncs_init
  */
  
// ABS Label 42
if(xInit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}
// ABS Label 43
if(zProc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// COR Label 44
if((xInit == 0 || zProc == 0) != (xInit == 0 && zProc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 44);
}

// ROR Label 45
if((xInit != 0) != (xInit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
// ROR Label 46
if((zProc != 0) != (zProc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}

// MCC Label 47
if(xInit == 0 && zProc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if(xInit == 0 && !(zProc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
// MCC Label 49
if(!(xInit == 0) && zProc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 49);
}
// MCC Label 50
if(!(xInit == 0) && !(zProc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 50);
}
if( xInit==0 && zProc==0 ){
    int iFile, iEntry, c;
    int ncFile = sqlite3Strlen30(zFile);
    zAltEntry = sqlite3_malloc64(ncFile+30);
    
// ABS Label 51
if(zAltEntry < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// ROR Label 52
if((zAltEntry != 0) != (zAltEntry == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}
if( zAltEntry==0 ){
      
// ABS Label 53
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// ABS Label 54
if(handle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}
sqlite3OsDlClose(pVfs, handle);
      return SQLITE_NOMEM_BKPT;
    }
    memcpy(zAltEntry, "sqlite3_", 8);
    iFile = ncFile - 1;

// ABS Label 55
if(iFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}

// COR Label 56
if((iFile >= 0 || !((zFile[iFile]) == '/')) != (iFile >= 0 && !((zFile[iFile]) == '/')))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 56);
}

// ROR Label 57
if((iFile < 0) != (iFile >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if((iFile > 0) != (iFile >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((iFile <= 0) != (iFile >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}

// MCC Label 60
if(iFile >= 0 && !((zFile[iFile]) == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(iFile >= 0 && !(!((zFile[iFile]) == '/')) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(iFile >= 0) && !((zFile[iFile]) == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
// MCC Label 63
if(!(iFile >= 0) && !(!((zFile[iFile]) == '/')) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 63);
}
for(; iFile>=0 && !DirSep(zFile[iFile]); iFile--){};
// ABS Label 64
if(iFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}

// COR Label 65
if((iFile >= 0 || !((zFile[iFile]) == '/')) != (iFile >= 0 && !((zFile[iFile]) == '/')))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 65);
}

// ROR Label 66
if((iFile < 0) != (iFile >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
// ROR Label 67
if((iFile > 0) != (iFile >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
// ROR Label 68
if((iFile <= 0) != (iFile >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}

// MCC Label 69
if(iFile >= 0 && !((zFile[iFile]) == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 69);
}
// MCC Label 70
if(iFile >= 0 && !(!((zFile[iFile]) == '/')) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 70);
}
// MCC Label 71
if(!(iFile >= 0) && !((zFile[iFile]) == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if(!(iFile >= 0) && !(!((zFile[iFile]) == '/')) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}

    iFile++;
    if( sqlite3_strnicmp(zFile+iFile, "lib", 3)==0 ) { iFile += 3;
}
    iEntry = 8;
for(; (c = zFile[iFile])!=0 && c!='.'; iFile++){
      
// MCC Label 73
if(( sqlite3CtypeMap[(unsigned char)(c)] & 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
// MCC Label 74
if(( !(sqlite3CtypeMap[(unsigned char)(c)] & 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 74);
}
if( sqlite3Isalpha(c) ){
        zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];
      }
    };
    memcpy(zAltEntry+iEntry, "_init", 6);
    zEntry = zAltEntry;
    xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);
  }
  
// ABS Label 75
if(xInit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ROR Label 76
if((xInit != 0) != (xInit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
if( xInit==0 ){
    
// ABS Label 79
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}
if( pzErrMsg ){
      nMsg += strlen(zEntry) + 300;
      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
      
// ABS Label 80
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}
if( zErrmsg ){
        assert( nMsg<0x7fffffff );  /* zErrmsg would be NULL if not so */
        
// ABS Label 81
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ABS Label 82
if(zEntry < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}

// ABS Label 83
if(zFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
sqlite3_snprintf((int)nMsg, zErrmsg,
            "no entry point [%s] in shared library [%s]", zEntry, zFile);
        
// ABS Label 84
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ABS Label 85
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
      }
    }
    
// ABS Label 77
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ABS Label 78
if(handle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
sqlite3OsDlClose(pVfs, handle);
    sqlite3_free(zAltEntry);
    return SQLITE_ERROR;
  }
  sqlite3_free(zAltEntry);
  rc = xInit(db, &zErrmsg, &sqlite3Apis);
  
// ABS Label 86
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
if( rc ){
    
// ABS Label 89
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}

// ROR Label 90
if((rc != (0 | (1 << 8))) != (rc == (0 | (1 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( rc==SQLITE_OK_LOAD_PERMANENTLY ) { return SQLITE_OK;
}
    
// ABS Label 91
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
    }
    sqlite3_free(zErrmsg);
    
// ABS Label 87
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// ABS Label 88
if(handle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
sqlite3OsDlClose(pVfs, handle);
    return SQLITE_ERROR;
  }

  /* Append the new shared library handle to the db->aExtension array. */
  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));
  
// ABS Label 92
if(aHandle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// ROR Label 93
if((aHandle != 0) != (aHandle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
if( aHandle==0 ){
    return SQLITE_NOMEM_BKPT;
  }
  
// ABS Label 94
if(db->nExtension < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// ROR Label 95
if((db->nExtension <= 0) != (db->nExtension > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
// ROR Label 96
if((db->nExtension < 0) != (db->nExtension > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
// ROR Label 97
if((db->nExtension >= 0) != (db->nExtension > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
if( db->nExtension>0 ){
    
// AOR Label 98
if(sizeof (handle) - db->nExtension != sizeof (handle) * db->nExtension)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 98);
}
// AOR Label 99
if(sizeof (handle) + db->nExtension != sizeof (handle) * db->nExtension)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 99);
}
// AOR Label 100
if(sizeof (handle) / db->nExtension != sizeof (handle) * db->nExtension)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 100);
}
memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
  }
  
// ABS Label 8
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3DbFree(db, db->aExtension);
  db->aExtension = aHandle;

  db->aExtension[db->nExtension++] = handle;
  return SQLITE_OK;

extension_not_found:
  
// ABS Label 101
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
if( pzErrMsg ){
    nMsg += 300;
    *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
    
// ABS Label 102
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
if( zErrmsg ){
      assert( nMsg<0x7fffffff );  /* zErrmsg would be NULL if not so */
      
// ABS Label 103
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}

// ABS Label 104
if(zFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
sqlite3_snprintf((int)nMsg, zErrmsg,
          "unable to open shared library [%.*s]", SQLITE_MAX_PATHLEN, zFile);
      
// ABS Label 105
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// ABS Label 106
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}
sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
    }
  }
  return SQLITE_ERROR;
}
int sqlite3_load_extension(
  sqlite3 *db,          /* Load the extension into this database connection */
  const char *zFile,    /* Name of the shared library containing extension */
  const char *zProc,    /* Entry point.  Use "sqlite3_extension_init" if 0 */
  char **pzErrMsg       /* Put error message here if not 0 */
){
  int rc;
  
// ABS Label 107
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
sqlite3_mutex_enter(db->mutex);
  rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);
  rc = sqlite3ApiExit(db, rc);
  
// ABS Label 108
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 109
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
return rc;
}

/*
** Call this routine when the database connection is closing in order
** to clean up loaded extensions
*/
void sqlite3CloseExtensions(sqlite3 *db){
  int i;
  assert( sqlite3_mutex_held(db->mutex) );
  i = 0;

// ABS Label 111
if(db->nExtension < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}
// ABS Label 112
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ROR Label 113
if((i <= db->nExtension) != (i < db->nExtension))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
// ROR Label 114
if((i > db->nExtension) != (i < db->nExtension))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}
// ROR Label 115
if((i >= db->nExtension) != (i < db->nExtension))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
for(; i<db->nExtension; i++){
    
// ABS Label 121
if(db->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}

// ABS Label 122
if(db->aExtension[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}
// ABS Label 123
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}
sqlite3OsDlClose(db->pVfs, db->aExtension[i]);
  };
// ABS Label 116
if(db->nExtension < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
// ABS Label 117
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// ROR Label 118
if((i <= db->nExtension) != (i < db->nExtension))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
// ROR Label 119
if((i > db->nExtension) != (i < db->nExtension))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((i >= db->nExtension) != (i < db->nExtension))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}

  
// ABS Label 110
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}
sqlite3DbFree(db, db->aExtension);
}

/*
** Enable or disable extension loading.  Extension loading is disabled by
** default so as not to open security holes in older applications.
*/
int sqlite3_enable_load_extension(sqlite3 *db, int onoff){
  
// ABS Label 124
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}
sqlite3_mutex_enter(db->mutex);
  
// ABS Label 126
if(onoff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}
if( onoff ){
    db->flags |= SQLITE_LoadExtension|SQLITE_LoadExtFunc;
  }else{
    db->flags &= ~(u64)(SQLITE_LoadExtension|SQLITE_LoadExtFunc);
  }
  
// ABS Label 125
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
sqlite3_mutex_leave(db->mutex);
  return SQLITE_OK;
}

#endif /* !defined(SQLITE_OMIT_LOAD_EXTENSION) */

/*
** The following object holds the list of automatically loaded
** extensions.
**
** This list is shared across threads.  The SQLITE_MUTEX_STATIC_MAIN
** mutex must be held while accessing this list.
*/
typedef struct sqlite3AutoExtList sqlite3AutoExtList;
static SQLITE_WSD struct sqlite3AutoExtList {
  u32 nExt;              /* Number of entries in aExt[] */          
  void (**aExt)(void);   /* Pointers to the extension init functions */
} sqlite3Autoext = { 0, 0 };

/* The "wsdAutoext" macro will resolve to the autoextension
** state vector.  If writable static data is unsupported on the target,
** we have to locate the state vector at run-time.  In the more common
** case where writable static data is supported, wsdStat can refer directly
** to the "sqlite3Autoext" state vector declared above.
*/
#ifdef SQLITE_OMIT_WSD
# define wsdAutoextInit \
  sqlite3AutoExtList *x = &GLOBAL(sqlite3AutoExtList,sqlite3Autoext)
# define wsdAutoext x[0]
#else
# define wsdAutoextInit
# define wsdAutoext sqlite3Autoext
#endif


/*
** Register a statically linked extension that is automatically
** loaded by every new database connection.
*/
int sqlite3_auto_extension(
  void (*xInit)(void)
){
  int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_AUTOINIT
  rc = sqlite3_initialize();
  
// ABS Label 127
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}
if( rc ){
    
// ABS Label 128
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}
return rc;
  }else
#endif
  {
    u32 i;
#if SQLITE_THREADSAFE
    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
    wsdAutoextInit;
    
// ABS Label 129
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}
sqlite3_mutex_enter(mutex);
    i = 0;

// ABS Label 131
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}
// ABS Label 132
if(sqlite3Autoext.nExt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}

// ROR Label 133
if((i <= sqlite3Autoext.nExt) != (i < sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
// ROR Label 134
if((i > sqlite3Autoext.nExt) != (i < sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}
// ROR Label 135
if((i >= sqlite3Autoext.nExt) != (i < sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 135);
}
for(; i<wsdAutoext.nExt; i++){
      
// ABS Label 141
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
// ABS Label 142
if(sqlite3Autoext.aExt[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
// ABS Label 143
if(xInit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}

// ROR Label 144
if((sqlite3Autoext.aExt[i] != xInit) != (sqlite3Autoext.aExt[i] == xInit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( wsdAutoext.aExt[i]==xInit ) { break;
}
    };
// ABS Label 136
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
// ABS Label 137
if(sqlite3Autoext.nExt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}

// ROR Label 138
if((i <= sqlite3Autoext.nExt) != (i < sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 138);
}
// ROR Label 139
if((i > sqlite3Autoext.nExt) != (i < sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
// ROR Label 140
if((i >= sqlite3Autoext.nExt) != (i < sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 140);
}

    
// ABS Label 145
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}
// ABS Label 146
if(sqlite3Autoext.nExt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ROR Label 147
if((i != sqlite3Autoext.nExt) != (i == sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 147);
}
if( i==wsdAutoext.nExt ){
      u64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);
      void (**aNew)(void);
      aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);
      
// ABS Label 148
if(aNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}

// ROR Label 149
if((aNew != 0) != (aNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
if( aNew==0 ){
        rc = SQLITE_NOMEM_BKPT;
      }else{
        wsdAutoext.aExt = aNew;
        wsdAutoext.aExt[wsdAutoext.nExt] = xInit;
        wsdAutoext.nExt++;
      }
    }
    
// ABS Label 130
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}
sqlite3_mutex_leave(mutex);
    assert( (rc&0xff)==rc );
    
// ABS Label 150
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
return rc;
  }
}

/*
** Cancel a prior call to sqlite3_auto_extension.  Remove xInit from the
** set of routines that is invoked for each new database connection, if it
** is currently on the list.  If xInit is not on the list, then this
** routine is a no-op.
**
** Return 1 if xInit was found on the list and removed.  Return 0 if xInit
** was not on the list.
*/
int sqlite3_cancel_auto_extension(
  void (*xInit)(void)
){
#if SQLITE_THREADSAFE
  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
  int i;
  int n = 0;
  wsdAutoextInit;
  
// ABS Label 151
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}
sqlite3_mutex_enter(mutex);
  i = (int)sqlite3Autoext.nExt - 1;

// ABS Label 153
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ROR Label 154
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
// ROR Label 155
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 155);
}
// ROR Label 156
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
for(; i>=0; i--){
    
// ABS Label 161
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}
// ABS Label 162
if(sqlite3Autoext.aExt[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}
// ABS Label 163
if(xInit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ROR Label 164
if((sqlite3Autoext.aExt[i] != xInit) != (sqlite3Autoext.aExt[i] == xInit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
if( wsdAutoext.aExt[i]==xInit ){
      wsdAutoext.nExt--;
      wsdAutoext.aExt[i] = wsdAutoext.aExt[wsdAutoext.nExt];
      n++;
      break;
    }
  };
// ABS Label 157
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ROR Label 158
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 158);
}
// ROR Label 159
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 159);
}
// ROR Label 160
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}

  
// ABS Label 152
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}
sqlite3_mutex_leave(mutex);
  
// ABS Label 165
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}
return n;
}

/*
** Reset the automatic extension loading mechanism.
*/
void sqlite3_reset_auto_extension(void){
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize()==SQLITE_OK )
#endif
  {
#if SQLITE_THREADSAFE
    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
    wsdAutoextInit;
    
// ABS Label 166
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}
sqlite3_mutex_enter(mutex);
    sqlite3_free(wsdAutoext.aExt);
    wsdAutoext.aExt = 0;
    wsdAutoext.nExt = 0;
    
// ABS Label 167
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}
sqlite3_mutex_leave(mutex);
  }
}

/*
** Load all automatic extensions.
**
** If anything goes wrong, set an error in the database connection.
*/
void sqlite3AutoLoadExtensions(sqlite3 *db){
  u32 i;
  int go = 1;
  int rc;
  sqlite3_loadext_entry xInit;

  wsdAutoextInit;
  
// ABS Label 168
if(sqlite3Autoext.nExt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}

// ROR Label 169
if((sqlite3Autoext.nExt != 0) != (sqlite3Autoext.nExt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}
if( wsdAutoext.nExt==0 ){
    /* Common case: early out without every having to acquire a mutex */
    return;
  }
  i = 0;

// ABS Label 170
if(go < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}
for(; go; i++){
    char *zErrmsg;
#if SQLITE_THREADSAFE
    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
#ifdef SQLITE_OMIT_LOAD_EXTENSION
    const sqlite3_api_routines *pThunk = 0;
#else
    const sqlite3_api_routines *pThunk = &sqlite3Apis;
#endif
    
// ABS Label 172
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}
sqlite3_mutex_enter(mutex);
    
// ABS Label 174
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}
// ABS Label 175
if(sqlite3Autoext.nExt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}

// ROR Label 176
if((i < sqlite3Autoext.nExt) != (i >= sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
// ROR Label 177
if((i > sqlite3Autoext.nExt) != (i >= sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 177);
}
// ROR Label 178
if((i <= sqlite3Autoext.nExt) != (i >= sqlite3Autoext.nExt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}
if( i>=wsdAutoext.nExt ){
      xInit = 0;
      go = 0;
    }else{
      xInit = (sqlite3_loadext_entry)wsdAutoext.aExt[i];
    }
    
// ABS Label 173
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}
sqlite3_mutex_leave(mutex);
    zErrmsg = 0;
    if( xInit && (rc = xInit(db, &zErrmsg, pThunk))!=0 ){
      
// ABS Label 179
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}

// ABS Label 180
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}

// ABS Label 181
if(zErrmsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
sqlite3ErrorWithMsg(db, rc,
            "automatic extension loading failed: %s", zErrmsg);
      go = 0;
    }
    sqlite3_free(zErrmsg);
  };
// ABS Label 171
if(go < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

}
