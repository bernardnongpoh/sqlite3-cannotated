/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Main file for the SQLite library.  The routines in this file
** implement the programmer interface to the library.  Routines in
** other files are for internal use by SQLite and should not be
** accessed by users of the library.
*/

#include "sqliteInt.h"

/*
** Execute SQL code.  Return one of the SQLITE_ success/failure
** codes.  Also write an error message into memory obtained from
** malloc() and make *pzErrMsg point to that message.
**
** If the SQL is a query, then for each row in the query result
** the xCallback() function is called.  pArg becomes the first
** argument to xCallback().  If xCallback=NULL then no callback
** is invoked, even for queries.
*/
int sqlite3_exec(
  sqlite3 *db,                /* The database on which the SQL executes */
  const char *zSql,           /* The SQL to be executed */
  sqlite3_callback xCallback, /* Invoke this callback routine */
  void *pArg,                 /* First argument to xCallback() */
  char **pzErrMsg             /* Write error messages here */
){
  int rc = SQLITE_OK;         /* Return code */
  const char *zLeftover;      /* Tail of unprocessed SQL */
  sqlite3_stmt *pStmt = 0;    /* The current SQL statement */
  char **azCols = 0;          /* Names of result columns */
  int callbackIsInit;         /* True if callback data is initialized */

  if( !sqlite3SafetyCheckOk(db) ) { return SQLITE_MISUSE_BKPT;
}
  
// ABS Label 11
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ROR Label 12
if((zSql != 0) != (zSql == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
if( zSql==0 ) { zSql = "";
}

  
// ABS Label 7
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
sqlite3_mutex_enter(db->mutex);
  
// ABS Label 8
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3Error(db, SQLITE_OK);
  
// ABS Label 13
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// COR Label 14
if((rc == 0 || zSql[0]) != (rc == 0 && zSql[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 14);
}

// ROR Label 15
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}

// MCC Label 16
if(rc == 0 && zSql[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}
// MCC Label 17
if(rc == 0 && !(zSql[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 17);
}
// MCC Label 18
if(!(rc == 0) && zSql[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 18);
}
// MCC Label 19
if(!(rc == 0) && !(zSql[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 19);
}
while( rc==SQLITE_OK && zSql[0] ){
    int nCol = 0;
    char **azVals = 0;

    pStmt = 0;
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
    assert( rc==SQLITE_OK || pStmt==0 );
    
// ABS Label 28
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ROR Label 29
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
if( rc!=SQLITE_OK ){
      continue;
    }
    if( !pStmt ){
      /* this happens for a comment or white-space */
      zSql = zLeftover;
      continue;
    }
    callbackIsInit = 0;

    while( 1 ){
      int i;
      rc = sqlite3_step(pStmt);

      /* Invoke the callback function if required */
      
// ABS Label 30
if(xCallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// COR Label 31
if((xCallback || (100 == rc || (101 == rc && !callbackIsInit && db->flags & 256))) != (xCallback && (100 == rc || (101 == rc && !callbackIsInit && db->flags & 256))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 31);
}

// MCC Label 32
if(xCallback && ( 100 == rc && ( 101 == rc && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 32);
}
// MCC Label 33
if(xCallback && ( 100 == rc && ( 101 == rc && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 33);
}
// MCC Label 34
if(xCallback && ( 100 == rc && ( 101 == rc && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 34);
}
// MCC Label 35
if(xCallback && ( 100 == rc && ( 101 == rc && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
// MCC Label 36
if(xCallback && ( 100 == rc && ( !(101 == rc) && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 36);
}
// MCC Label 37
if(xCallback && ( 100 == rc && ( !(101 == rc) && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 37);
}
// MCC Label 38
if(xCallback && ( 100 == rc && ( !(101 == rc) && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 38);
}
// MCC Label 39
if(xCallback && ( 100 == rc && ( !(101 == rc) && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 39);
}
// MCC Label 40
if(xCallback && ( !(100 == rc) && ( 101 == rc && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(xCallback && ( !(100 == rc) && ( 101 == rc && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(xCallback && ( !(100 == rc) && ( 101 == rc && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
// MCC Label 43
if(xCallback && ( !(100 == rc) && ( 101 == rc && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 43);
}
// MCC Label 44
if(xCallback && ( !(100 == rc) && ( !(101 == rc) && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 44);
}
// MCC Label 45
if(xCallback && ( !(100 == rc) && ( !(101 == rc) && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 45);
}
// MCC Label 46
if(xCallback && ( !(100 == rc) && ( !(101 == rc) && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 46);
}
// MCC Label 47
if(xCallback && ( !(100 == rc) && ( !(101 == rc) && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if(!(xCallback) && ( 100 == rc && ( 101 == rc && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
// MCC Label 49
if(!(xCallback) && ( 100 == rc && ( 101 == rc && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 49);
}
// MCC Label 50
if(!(xCallback) && ( 100 == rc && ( 101 == rc && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 50);
}
// MCC Label 51
if(!(xCallback) && ( 100 == rc && ( 101 == rc && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 51);
}
// MCC Label 52
if(!(xCallback) && ( 100 == rc && ( !(101 == rc) && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 52);
}
// MCC Label 53
if(!(xCallback) && ( 100 == rc && ( !(101 == rc) && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(!(xCallback) && ( 100 == rc && ( !(101 == rc) && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(!(xCallback) && ( 100 == rc && ( !(101 == rc) && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(xCallback) && ( !(100 == rc) && ( 101 == rc && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
// MCC Label 57
if(!(xCallback) && ( !(100 == rc) && ( 101 == rc && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
// MCC Label 58
if(!(xCallback) && ( !(100 == rc) && ( 101 == rc && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 58);
}
// MCC Label 59
if(!(xCallback) && ( !(100 == rc) && ( 101 == rc && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if(!(xCallback) && ( !(100 == rc) && ( !(101 == rc) && !callbackIsInit && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!(xCallback) && ( !(100 == rc) && ( !(101 == rc) && !callbackIsInit && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(xCallback) && ( !(100 == rc) && ( !(101 == rc) && !(!callbackIsInit) && db->flags & 256 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
// MCC Label 63
if(!(xCallback) && ( !(100 == rc) && ( !(101 == rc) && !(!callbackIsInit) && !(db->flags & 256) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 63);
}
if( xCallback && (SQLITE_ROW==rc || 
          (SQLITE_DONE==rc && !callbackIsInit
                           && db->flags&SQLITE_NullCallback)) ){
        if( !callbackIsInit ){
          nCol = sqlite3_column_count(pStmt);
          azCols = sqlite3DbMallocRaw(db, (2*nCol+1)*sizeof(const char*));
          
// ABS Label 64
if(azCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}

// ROR Label 65
if((azCols != 0) != (azCols == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
if( azCols==0 ){
            goto exec_out;
          }
          i = 0;

// ABS Label 66
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
// ABS Label 67
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}

// ROR Label 68
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
// ROR Label 69
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
for(; i<nCol; i++){
            azCols[i] = (char *)sqlite3_column_name(pStmt, i);
            /* sqlite3VdbeSetColName() installs column names as UTF8
            ** strings so there is no way for sqlite3_column_name() to fail. */
            assert( azCols[i]!=0 );
          };
// ABS Label 71
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}
// ABS Label 72
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}

// ROR Label 73
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
// ROR Label 74
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
// ROR Label 75
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}

          callbackIsInit = 1;
        }
        
// ABS Label 76
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// ROR Label 77
if((rc != 100) != (rc == 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
if( rc==SQLITE_ROW ){
          azVals = &azCols[nCol];
          i = 0;

// ABS Label 78
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
// ABS Label 79
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ROR Label 80
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
// ROR Label 81
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
// ROR Label 82
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
for(; i<nCol; i++){
            azVals[i] = (char *)sqlite3_column_text(pStmt, i);
            if( !azVals[i] && sqlite3_column_type(pStmt, i)!=SQLITE_NULL ){
              
// ABS Label 88
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
sqlite3OomFault(db);
              goto exec_out;
            }
          };
// ABS Label 83
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
// ABS Label 84
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ROR Label 85
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}
// ROR Label 86
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
// ROR Label 87
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}

          azVals[i] = 0;
        }
        if( xCallback(pArg, nCol, azVals, azCols) ){
          /* EVIDENCE-OF: R-38229-40159 If the callback function to
          ** sqlite3_exec() returns non-zero, then sqlite3_exec() will
          ** return SQLITE_ABORT. */
          rc = SQLITE_ABORT;
          sqlite3VdbeFinalize((Vdbe *)pStmt);
          pStmt = 0;
          
// ABS Label 89
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
sqlite3Error(db, SQLITE_ABORT);
          goto exec_out;
        }
      }

      
// ABS Label 90
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ROR Label 91
if((rc == 100) != (rc != 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
if( rc!=SQLITE_ROW ){
        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);
        pStmt = 0;
        zSql = zLeftover;
        
// MCC Label 92
if(( sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 92);
}
// MCC Label 93
if(( !(sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 93);
}
while( sqlite3Isspace(zSql[0]) ) { zSql++;
};
// MCC Label 94
if(( sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(( !(sqlite3CtypeMap[(unsigned char)(zSql[0])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}

        break;
      }
    };

    
// ABS Label 27
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
sqlite3DbFree(db, azCols);
    azCols = 0;
  };
// ABS Label 20
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}

// COR Label 21
if((rc == 0 || zSql[0]) != (rc == 0 && zSql[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 21);
}

// ROR Label 22
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}

// MCC Label 23
if(rc == 0 && zSql[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 23);
}
// MCC Label 24
if(rc == 0 && !(zSql[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 24);
}
// MCC Label 25
if(!(rc == 0) && zSql[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 25);
}
// MCC Label 26
if(!(rc == 0) && !(zSql[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}


exec_out:
  
// ABS Label 96
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}
if( pStmt ) { sqlite3VdbeFinalize((Vdbe *)pStmt);
}
  
// ABS Label 9
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
sqlite3DbFree(db, azCols);

  rc = sqlite3ApiExit(db, rc);
  
// ABS Label 97
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}
// ABS Label 98
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}

// COR Label 99
if((rc != 0 || pzErrMsg) != (rc != 0 && pzErrMsg))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 99);
}

// ROR Label 100
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}

// MCC Label 101
if(rc != 0 && pzErrMsg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(rc != 0 && !(pzErrMsg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
// MCC Label 103
if(!(rc != 0) && pzErrMsg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 103);
}
// MCC Label 104
if(!(rc != 0) && !(pzErrMsg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 104);
}
if( rc!=SQLITE_OK && pzErrMsg ){
    *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));
    
// ABS Label 105
if(*pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// ROR Label 106
if((*pzErrMsg != 0) != (*pzErrMsg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
if( *pzErrMsg==0 ){
      rc = SQLITE_NOMEM_BKPT;
      
// ABS Label 107
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
sqlite3Error(db, SQLITE_NOMEM);
    }
  }else { 
// ABS Label 108
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
if( pzErrMsg ){
    *pzErrMsg = 0;
  };}


  assert( (rc&db->errMask)==rc );
  
// ABS Label 10
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 109
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
return rc;
}
