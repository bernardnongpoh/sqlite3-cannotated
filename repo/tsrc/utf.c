/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2004 April 13
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used to translate between UTF-8, 
** UTF-16, UTF-16BE, and UTF-16LE.
**
** Notes on UTF-8:
**
**   Byte-0    Byte-1    Byte-2    Byte-3    Value
**  0xxxxxxx                                 00000000 00000000 0xxxxxxx
**  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx
**  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx
**  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx
**
**
** Notes on UTF-16:  (with wwww+1==uuuuu)
**
**      Word-0               Word-1          Value
**  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxx
**  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx
**
**
** BOM or Byte Order Mark:
**     0xff 0xfe   little-endian utf-16 follows
**     0xfe 0xff   big-endian utf-16 follows
**
*/
#include "sqliteInt.h"
#include <assert.h>
#include "vdbeInt.h"

#if !defined(SQLITE_AMALGAMATION) && SQLITE_BYTEORDER==0
/*
** The following constant value is used by the SQLITE_BIGENDIAN and
** SQLITE_LITTLEENDIAN macros.
*/
const int sqlite3one = 1;
#endif /* SQLITE_AMALGAMATION && SQLITE_BYTEORDER==0 */

/*
** This lookup table is used to help decode the first byte of
** a multi-byte UTF8 character.
*/
static const unsigned char sqlite3Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};


#define WRITE_UTF8(zOut, c) {                          \
  if( c<0x00080 ){                                     \
    *zOut++ = (u8)(c&0xFF);                            \
  }                                                    \
  else if( c<0x00800 ){                                \
    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
  else if( c<0x10000 ){                                \
    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }else{                                               \
    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \
    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \
    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \
    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \
  }                                                    \
}

#define WRITE_UTF16LE(zOut, c) {                                    \
  if( c<=0xFFFF ){                                                  \
    *zOut++ = (u8)(c&0x00FF);                                       \
    *zOut++ = (u8)((c>>8)&0x00FF);                                  \
  }else{                                                            \
    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \
    *zOut++ = (u8)(c&0x00FF);                                       \
    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \
  }                                                                 \
}

#define WRITE_UTF16BE(zOut, c) {                                    \
  if( c<=0xFFFF ){                                                  \
    *zOut++ = (u8)((c>>8)&0x00FF);                                  \
    *zOut++ = (u8)(c&0x00FF);                                       \
  }else{                                                            \
    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \
    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \
    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \
    *zOut++ = (u8)(c&0x00FF);                                       \
  }                                                                 \
}

/*
** Translate a single UTF-8 character.  Return the unicode value.
**
** During translation, assume that the byte that zTerm points
** is a 0x00.
**
** Write a pointer to the next unread byte back into *pzNext.
**
** Notes On Invalid UTF-8:
**
**  *  This routine never allows a 7-bit character (0x00 through 0x7f) to
**     be encoded as a multi-byte character.  Any multi-byte character that
**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.
**
**  *  This routine never allows a UTF16 surrogate value to be encoded.
**     If a multi-byte character attempts to encode a value between
**     0xd800 and 0xe000 then it is rendered as 0xfffd.
**
**  *  Bytes in the range of 0x80 through 0xbf which occur as the first
**     byte of a character are interpreted as single-byte characters
**     and rendered as themselves even though they are technically
**     invalid characters.
**
**  *  This routine accepts over-length UTF8 encodings
**     for unicode values 0x80 and greater.  It does not change over-length
**     encodings to 0xfffd as some systems recommend.
*/
#define READ_UTF8(zIn, zTerm, c)                           \
  c = *(zIn++);                                            \
  if( c>=0xc0 ){                                           \
    c = sqlite3Utf8Trans1[c-0xc0];                         \
    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
      c = (c<<6) + (0x3f & *(zIn++));                      \
    }                                                      \
    if( c<0x80                                             \
        || (c&0xFFFFF800)==0xD800                          \
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
  }
u32 sqlite3Utf8Read(
  const unsigned char **pz    /* Pointer to string from which to read char */
){
  unsigned int c;

  /* Same as READ_UTF8() above but without the zTerm parameter.
  ** For this routine, we assume the UTF8 string is always zero-terminated.
  */
  c = *((*pz)++);
  
// ABS Label 7
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ROR Label 8
if((c < 192) != (c >= 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
// ROR Label 9
if((c > 192) != (c >= 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 9);
}
// ROR Label 10
if((c <= 192) != (c >= 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( c>=0xc0 ){
    c = sqlite3Utf8Trans1[c-0xc0];
    
// ROR Label 11
if(((*(*pz) & 192) != 128) != ((*(*pz) & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 11);
}
while( (*(*pz) & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & *((*pz)++));
    };
// ROR Label 12
if(((*(*pz) & 192) != 128) != ((*(*pz) & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}

    
// ABS Label 13
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// COR Label 14
if((c < 128 || (c & 4294965248U) == 55296 && (c & 4294967294U) == 65534) != (c < 128 || (c & 4294965248U) == 55296 || (c & 4294967294U) == 65534))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 14);
}
// COR Label 15
if((c < 128 && (c & 4294965248U) == 55296) != (c < 128 || (c & 4294965248U) == 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 15);
}

// ROR Label 16
if((c <= 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
// ROR Label 17
if((c > 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
// ROR Label 18
if((c >= 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
// ROR Label 19
if(((c & 4294965248U) != 55296) != ((c & 4294965248U) == 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if(((c & 4294967294U) != 65534) != ((c & 4294967294U) == 65534))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}

// MCC Label 21
if(c < 128 && (c & 4294965248U) == 55296 && (c & 4294967294U) == 65534 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 21);
}
// MCC Label 22
if(c < 128 && (c & 4294965248U) == 55296 && !((c & 4294967294U) == 65534) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 22);
}
// MCC Label 23
if(c < 128 && !((c & 4294965248U) == 55296) && (c & 4294967294U) == 65534 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 23);
}
// MCC Label 24
if(c < 128 && !((c & 4294965248U) == 55296) && !((c & 4294967294U) == 65534) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 24);
}
// MCC Label 25
if(!(c < 128) && (c & 4294965248U) == 55296 && (c & 4294967294U) == 65534 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 25);
}
// MCC Label 26
if(!(c < 128) && (c & 4294965248U) == 55296 && !((c & 4294967294U) == 65534) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}
// MCC Label 27
if(!(c < 128) && !((c & 4294965248U) == 55296) && (c & 4294967294U) == 65534 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 27);
}
// MCC Label 28
if(!(c < 128) && !((c & 4294965248U) == 55296) && !((c & 4294967294U) == 65534) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
if( c<0x80
        || (c&0xFFFFF800)==0xD800
        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }
  }
  
// ABS Label 29
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
return c;
}




/*
** If the TRANSLATE_TRACE macro is defined, the value of each Mem is
** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().
*/ 
/* #define TRANSLATE_TRACE 1 */

#ifndef SQLITE_OMIT_UTF16
/*
** This routine transforms the internal text encoding used by pMem to
** desiredEnc. It is an error if the string is already of the desired
** encoding, or if *pMem does not contain a string value.
*/
SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){
  sqlite3_int64 len;          /* Maximum length of output string in bytes */
  unsigned char *zOut;        /* Output buffer */
  unsigned char *zIn;         /* Input iterator */
  unsigned char *zTerm;       /* End of input */
  unsigned char *z;           /* Output iterator */
  unsigned int c;

  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( pMem->flags&MEM_Str );
  assert( pMem->enc!=desiredEnc );
  assert( pMem->enc!=0 );
  assert( pMem->n>=0 );

#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)
  {
    StrAccum acc;
    char zBuf[1000];
    sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  
    sqlite3VdbeMemPrettyPrint(pMem, &acc);
    fprintf(stderr, "INPUT:  %s\n", sqlite3StrAccumFinish(&acc));
  }
#endif

  /* If the translation is between UTF-16 little and big endian, then 
  ** all that is required is to swap the byte order. This case is handled
  ** differently from the others.
  */
  
// COR Label 31
if((pMem->enc != 1 || desiredEnc != 1) != (pMem->enc != 1 && desiredEnc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 31);
}

// ROR Label 32
if((pMem->enc == 1) != (pMem->enc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((desiredEnc == 1) != (desiredEnc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}

// MCC Label 34
if(pMem->enc != 1 && desiredEnc != 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 34);
}
// MCC Label 35
if(pMem->enc != 1 && !(desiredEnc != 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
// MCC Label 36
if(!(pMem->enc != 1) && desiredEnc != 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 36);
}
// MCC Label 37
if(!(pMem->enc != 1) && !(desiredEnc != 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 37);
}
if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){
    u8 temp;
    int rc;
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    
// ABS Label 38
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}

// ROR Label 39
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
if( rc!=SQLITE_OK ){
      assert( rc==SQLITE_NOMEM );
      return SQLITE_NOMEM_BKPT;
    }
    zIn = (u8*)pMem->z;
    zTerm = &zIn[pMem->n&~1];
    
// ABS Label 40
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
// ABS Label 41
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// ROR Label 42
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
while( zIn<zTerm ){
      temp = *zIn;
      *zIn = *(zIn+1);
      zIn++;
      *zIn++ = temp;
    };
// ABS Label 45
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
// ABS Label 46
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}

// ROR Label 47
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
// ROR Label 48
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
// ROR Label 49
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}

    pMem->enc = desiredEnc;
    goto translate_out;
  }

  /* Set len to the maximum number of bytes required in the output buffer. */
  
// ROR Label 50
if((desiredEnc != 1) != (desiredEnc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
if( desiredEnc==SQLITE_UTF8 ){
    /* When converting from UTF-16, the maximum growth results from
    ** translating a 2-byte character to a 4-byte UTF-8 character.
    ** A single byte is required for the output string
    ** nul-terminator.
    */
    pMem->n &= ~1;
    len = 2 * (sqlite3_int64)pMem->n + 1;
  }else{
    /* When converting from UTF-8 to UTF-16 the maximum growth is caused
    ** when a 1-byte UTF-8 character is translated into a 2-byte UTF-16
    ** character. Two bytes are required in the output buffer for the
    ** nul-terminator.
    */
    len = 2 * (sqlite3_int64)pMem->n + 2;
  }

  /* Set zIn to point at the start of the input buffer and zTerm to point 1
  ** byte past the end.
  **
  ** Variable zOut is set to point at the output buffer, space obtained
  ** from sqlite3_malloc().
  */
  zIn = (u8*)pMem->z;
  zTerm = &zIn[pMem->n];
  zOut = sqlite3DbMallocRaw(pMem->db, len);
  if( !zOut ){
    return SQLITE_NOMEM_BKPT;
  }
  z = zOut;

  
// ROR Label 51
if((pMem->enc != 1) != (pMem->enc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
if( pMem->enc==SQLITE_UTF8 ){
    
// ROR Label 52
if((desiredEnc != 2) != (desiredEnc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}
if( desiredEnc==SQLITE_UTF16LE ){
      /* UTF-8 -> UTF-16 Little-endian */
      
// ABS Label 53
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
// ABS Label 54
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// ROR Label 55
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
// ROR Label 56
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
// ROR Label 57
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
while( zIn<zTerm ){
        READ_UTF8(zIn, zTerm, c);
        WRITE_UTF16LE(z, c);
      };
// ABS Label 58
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
// ABS Label 59
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}

// ROR Label 60
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
// ROR Label 61
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
// ROR Label 62
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}

    }else{
      assert( desiredEnc==SQLITE_UTF16BE );
      /* UTF-8 -> UTF-16 Big-endian */
      
// ABS Label 105
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}
// ABS Label 106
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// ROR Label 107
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
// ROR Label 108
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 108);
}
// ROR Label 109
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}
while( zIn<zTerm ){
        READ_UTF8(zIn, zTerm, c);
        WRITE_UTF16BE(z, c);
      };
// ABS Label 110
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}
// ABS Label 111
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}

// ROR Label 112
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 112);
}
// ROR Label 113
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
// ROR Label 114
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}

    }
    pMem->n = (int)(z - zOut);
    *z++ = 0;
  }else{
    assert( desiredEnc==SQLITE_UTF8 );
    
// ROR Label 157
if((pMem->enc != 2) != (pMem->enc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 157);
}
if( pMem->enc==SQLITE_UTF16LE ){
      /* UTF-16 Little-endian -> UTF-8 */
      
// ABS Label 158
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}
// ABS Label 159
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}

// ROR Label 160
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
while( zIn<zTerm ){
        c = *(zIn++);
        c += (*(zIn++))<<8;
        
// ABS Label 168
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}

// COR Label 169
if((c >= 55296 || c < 57344) != (c >= 55296 && c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 169);
}

// ROR Label 170
if((c < 55296) != (c >= 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 170);
}
// ROR Label 171
if((c > 55296) != (c >= 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 171);
}
// ROR Label 172
if((c <= 55296) != (c >= 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 172);
}
// ROR Label 173
if((c <= 57344) != (c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
// ROR Label 174
if((c > 57344) != (c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((c >= 57344) != (c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}

// MCC Label 176
if(c >= 55296 && c < 57344 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if(c >= 55296 && !(c < 57344) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(!(c >= 55296) && c < 57344 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(!(c >= 55296) && !(c < 57344) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
if( c>=0xd800 && c<0xe000 ){
#ifdef SQLITE_REPLACE_INVALID_UTF
          if( c>=0xdc00 || zIn>=zTerm ){
            c = 0xfffd;
          }else{
            int c2 = *(zIn++);
            c2 += (*(zIn++))<<8;
            if( c2<0xdc00 || c2>=0xe000 ){
              zIn -= 2;
              c = 0xfffd;
            }else{
              c = ((c&0x3ff)<<10) + (c2&0x3ff) + 0x10000;
            }
          }
#else
          
// ABS Label 180
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
// ABS Label 181
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}

// ROR Label 182
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 182);
}
// ROR Label 183
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
if( zIn<zTerm ){
            int c2 = (*zIn++);
            c2 += ((*zIn++)<<8);
            c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);
          }
#endif
        }
        WRITE_UTF8(z, c);
      };
// ABS Label 163
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}
// ABS Label 164
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}

// ROR Label 165
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}

    }else{
      /* UTF-16 Big-endian -> UTF-8 */
      
// ABS Label 197
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
// ABS Label 198
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}

// ROR Label 199
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
// ROR Label 200
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
// ROR Label 201
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
while( zIn<zTerm ){
        c = (*(zIn++))<<8;
        c += *(zIn++);
        
// ABS Label 207
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// COR Label 208
if((c >= 55296 || c < 57344) != (c >= 55296 && c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 208);
}

// ROR Label 209
if((c < 55296) != (c >= 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((c > 55296) != (c >= 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
// ROR Label 211
if((c <= 55296) != (c >= 55296))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
// ROR Label 212
if((c <= 57344) != (c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 212);
}
// ROR Label 213
if((c > 57344) != (c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 213);
}
// ROR Label 214
if((c >= 57344) != (c < 57344))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 214);
}

// MCC Label 215
if(c >= 55296 && c < 57344 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(c >= 55296 && !(c < 57344) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(!(c >= 55296) && c < 57344 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(!(c >= 55296) && !(c < 57344) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
if( c>=0xd800 && c<0xe000 ){
#ifdef SQLITE_REPLACE_INVALID_UTF
          if( c>=0xdc00 || zIn>=zTerm ){
            c = 0xfffd;
          }else{
            int c2 = (*(zIn++))<<8;
            c2 += *(zIn++);
            if( c2<0xdc00 || c2>=0xe000 ){
              zIn -= 2;
              c = 0xfffd;
            }else{
              c = ((c&0x3ff)<<10) + (c2&0x3ff) + 0x10000;
            }
          }
#else
          
// ABS Label 219
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
// ABS Label 220
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}

// ROR Label 221
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 221);
}
// ROR Label 222
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
// ROR Label 223
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
if( zIn<zTerm ){
            int c2 = ((*zIn++)<<8);
            c2 += (*zIn++);
            c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);
          }
#endif
        }
        WRITE_UTF8(z, c);
      };
// ABS Label 202
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}
// ABS Label 203
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}

// ROR Label 204
if((zIn <= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((zIn > zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((zIn >= zTerm) != (zIn < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}

    }
    pMem->n = (int)(z - zOut);
  }
  *z = 0;
  assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len );

  c = MEM_Str|MEM_Term|(pMem->flags&(MEM_AffMask|MEM_Subtype));
  
// ABS Label 30
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
sqlite3VdbeMemRelease(pMem);
  pMem->flags = c;
  pMem->enc = desiredEnc;
  pMem->z = (char*)zOut;
  pMem->zMalloc = pMem->z;
  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);

translate_out:
#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)
  {
    StrAccum acc;
    char zBuf[1000];
    sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  
    sqlite3VdbeMemPrettyPrint(pMem, &acc);
    fprintf(stderr, "OUTPUT: %s\n", sqlite3StrAccumFinish(&acc));
  }
#endif
  return SQLITE_OK;
}
#endif /* SQLITE_OMIT_UTF16 */

#ifndef SQLITE_OMIT_UTF16
/*
** This routine checks for a byte-order mark at the beginning of the 
** UTF-16 string stored in *pMem. If one is present, it is removed and
** the encoding of the Mem adjusted. This routine does not do any
** byte-swapping, it just sets Mem.enc appropriately.
**
** The allocation (static, dynamic etc.) and encoding of the Mem may be
** changed by this function.
*/
int sqlite3VdbeMemHandleBom(Mem *pMem){
  int rc = SQLITE_OK;
  u8 bom = 0;

  assert( pMem->n>=0 );
  
// ABS Label 236
if(pMem->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}

// ROR Label 237
if((pMem->n <= 1) != (pMem->n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
// ROR Label 238
if((pMem->n < 1) != (pMem->n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
// ROR Label 239
if((pMem->n >= 1) != (pMem->n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 239);
}
if( pMem->n>1 ){
    
// ABS Label 240
if(*(u8 *)pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}
u8 b1 = *(u8 *)pMem->z;
    
// ABS Label 241
if(*(((u8 *)pMem->z) + 1) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}
u8 b2 = *(((u8 *)pMem->z) + 1);
    
// COR Label 242
if((b1 == 254 || b2 == 255) != (b1 == 254 && b2 == 255))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 242);
}

// ROR Label 243
if((b1 != 254) != (b1 == 254))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
// ROR Label 244
if((b2 != 255) != (b2 == 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}

// MCC Label 245
if(b1 == 254 && b2 == 255 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(b1 == 254 && !(b2 == 255) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
// MCC Label 247
if(!(b1 == 254) && b2 == 255 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(!(b1 == 254) && !(b2 == 255) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
if( b1==0xFE && b2==0xFF ){
      bom = SQLITE_UTF16BE;
    }
    
// COR Label 249
if((b1 == 255 || b2 == 254) != (b1 == 255 && b2 == 254))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 249);
}

// ROR Label 250
if((b1 != 255) != (b1 == 255))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((b2 != 254) != (b2 == 254))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}

// MCC Label 252
if(b1 == 255 && b2 == 254 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 252);
}
// MCC Label 253
if(b1 == 255 && !(b2 == 254) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 253);
}
// MCC Label 254
if(!(b1 == 255) && b2 == 254 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 254);
}
// MCC Label 255
if(!(b1 == 255) && !(b2 == 254) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
if( b1==0xFF && b2==0xFE ){
      bom = SQLITE_UTF16LE;
    }
  }
  
  
// ABS Label 256
if(bom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}
if( bom ){
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    
// ABS Label 257
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}

// ROR Label 258
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}
if( rc==SQLITE_OK ){
      pMem->n -= 2;
      memmove(pMem->z, &pMem->z[2], pMem->n);
      pMem->z[pMem->n] = '\0';
      pMem->z[pMem->n+1] = '\0';
      pMem->flags |= MEM_Term;
      pMem->enc = bom;
    }
  }
  
// ABS Label 259
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}
return rc;
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,
** return the number of unicode characters in pZ up to (but not including)
** the first 0x00 byte. If nByte is not less than zero, return the
** number of unicode characters in the first nByte of pZ (or up to 
** the first 0x00, whichever comes first).
*/
int sqlite3Utf8CharLen(const char *zIn, int nByte){
  int r = 0;
  const u8 *z = (const u8*)zIn;
  const u8 *zTerm;
  
// ABS Label 260
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}

// ROR Label 261
if((nByte < 0) != (nByte >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 261);
}
// ROR Label 262
if((nByte > 0) != (nByte >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((nByte <= 0) != (nByte >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}
if( nByte>=0 ){
    zTerm = &z[nByte];
  }else{
    zTerm = (const u8*)(-1);
  }
  assert( z<=zTerm );
  
// ABS Label 264
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
// ABS Label 265
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}

// COR Label 266
if((*z != 0 || z < zTerm) != (*z != 0 && z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 266);
}

// ROR Label 267
if((*z == 0) != (*z != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((z <= zTerm) != (z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}
// ROR Label 269
if((z > zTerm) != (z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}
// ROR Label 270
if((z >= zTerm) != (z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 270);
}

// MCC Label 271
if(*z != 0 && z < zTerm ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 271);
}
// MCC Label 272
if(*z != 0 && !(z < zTerm) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 272);
}
// MCC Label 273
if(!(*z != 0) && z < zTerm ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 273);
}
// MCC Label 274
if(!(*z != 0) && !(z < zTerm) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 274);
}
while( *z!=0 && z<zTerm ){
    SQLITE_SKIP_UTF8(z);
    r++;
  };
// ABS Label 275
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
// ABS Label 276
if(zTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}

// COR Label 277
if((*z != 0 || z < zTerm) != (*z != 0 && z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 277);
}

// ROR Label 278
if((*z == 0) != (*z != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 278);
}
// ROR Label 279
if((z <= zTerm) != (z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((z > zTerm) != (z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((z >= zTerm) != (z < zTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}

// MCC Label 282
if(*z != 0 && z < zTerm ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 282);
}
// MCC Label 283
if(*z != 0 && !(z < zTerm) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}
// MCC Label 284
if(!(*z != 0) && z < zTerm ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 284);
}
// MCC Label 285
if(!(*z != 0) && !(z < zTerm) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 285);
}

  
// ABS Label 288
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}
return r;
}

/* This test function is not currently used by the automated test-suite. 
** Hence it is only available in debug builds.
*/
#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
/*
** Translate UTF-8 to UTF-8.
**
** This has the effect of making sure that the string is well-formed
** UTF-8.  Miscoded characters are removed.
**
** The translation is done in-place and aborted if the output
** overruns the input.
*/
int sqlite3Utf8To8(unsigned char *zIn){
  unsigned char *zOut = zIn;
  unsigned char *zStart = zIn;
  u32 c;

  while( zIn[0] && zOut<=zIn ){
    c = sqlite3Utf8Read((const u8**)&zIn);
    if( c!=0xfffd ){
      WRITE_UTF8(zOut, c);
    }
  }
  *zOut = 0;
  return (int)(zOut - zStart);
}
#endif

#ifndef SQLITE_OMIT_UTF16
/*
** Convert a UTF-16 string in the native encoding into a UTF-8 string.
** Memory to hold the UTF-8 string is obtained from sqlite3_malloc and must
** be freed by the calling function.
**
** NULL is returned if there is an allocation error.
*/
char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){
  Mem m;
  memset(&m, 0, sizeof(m));
  m.db = db;
  
// ABS Label 289
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}
sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);
  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);
  
// ABS Label 290
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}
if( db->mallocFailed ){
    sqlite3VdbeMemRelease(&m);
    m.z = 0;
  }
  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );
  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );
  assert( m.z || db->mallocFailed );
  
// ABS Label 291
if(m.z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}
return m.z;
}

/*
** zIn is a UTF-16 encoded unicode string at least nChar characters long.
** Return the number of bytes in the first nChar unicode characters
** in pZ.  nChar must be non-negative.
*/
int sqlite3Utf16ByteLen(const void *zIn, int nChar){
  int c;
  unsigned char const *z = zIn;
  int n = 0;
  
  
// ROR Label 292
if((2 != 2) != (2 == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}
if( SQLITE_UTF16NATIVE==SQLITE_UTF16LE ) { z++;
}
  
// ABS Label 293
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
// ABS Label 294
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}

// ROR Label 295
if((n <= nChar) != (n < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}
// ROR Label 296
if((n > nChar) != (n < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
// ROR Label 297
if((n >= nChar) != (n < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}
while( n<nChar ){
    c = z[0];
    z += 2;
    
// ABS Label 303
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// COR Label 304
if((c >= 216 && c < 220 && z[0] >= 220 || z[0] < 224) != (c >= 216 && c < 220 && z[0] >= 220 && z[0] < 224))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 304);
}
// COR Label 305
if((c >= 216 && c < 220 || z[0] >= 220) != (c >= 216 && c < 220 && z[0] >= 220))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 305);
}
// COR Label 306
if((c >= 216 || c < 220) != (c >= 216 && c < 220))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 306);
}

// ROR Label 307
if((c < 216) != (c >= 216))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 307);
}
// ROR Label 308
if((c > 216) != (c >= 216))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 308);
}
// ROR Label 309
if((c <= 216) != (c >= 216))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
// ROR Label 310
if((c <= 220) != (c < 220))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((c > 220) != (c < 220))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
// ROR Label 312
if((c >= 220) != (c < 220))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 312);
}
// ROR Label 313
if((z[0] < 220) != (z[0] >= 220))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 313);
}
// ROR Label 314
if((z[0] > 220) != (z[0] >= 220))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
// ROR Label 315
if((z[0] <= 220) != (z[0] >= 220))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}
// ROR Label 316
if((z[0] <= 224) != (z[0] < 224))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
// ROR Label 317
if((z[0] > 224) != (z[0] < 224))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}
// ROR Label 318
if((z[0] >= 224) != (z[0] < 224))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}

// MCC Label 319
if(c >= 216 && c < 220 && z[0] >= 220 && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 319);
}
// MCC Label 320
if(c >= 216 && c < 220 && z[0] >= 220 && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 320);
}
// MCC Label 321
if(c >= 216 && c < 220 && !(z[0] >= 220) && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 321);
}
// MCC Label 322
if(c >= 216 && c < 220 && !(z[0] >= 220) && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
// MCC Label 323
if(c >= 216 && !(c < 220) && z[0] >= 220 && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
// MCC Label 324
if(c >= 216 && !(c < 220) && z[0] >= 220 && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 324);
}
// MCC Label 325
if(c >= 216 && !(c < 220) && !(z[0] >= 220) && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 325);
}
// MCC Label 326
if(c >= 216 && !(c < 220) && !(z[0] >= 220) && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 326);
}
// MCC Label 327
if(!(c >= 216) && c < 220 && z[0] >= 220 && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 327);
}
// MCC Label 328
if(!(c >= 216) && c < 220 && z[0] >= 220 && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 328);
}
// MCC Label 329
if(!(c >= 216) && c < 220 && !(z[0] >= 220) && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 329);
}
// MCC Label 330
if(!(c >= 216) && c < 220 && !(z[0] >= 220) && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 330);
}
// MCC Label 331
if(!(c >= 216) && !(c < 220) && z[0] >= 220 && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 331);
}
// MCC Label 332
if(!(c >= 216) && !(c < 220) && z[0] >= 220 && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 332);
}
// MCC Label 333
if(!(c >= 216) && !(c < 220) && !(z[0] >= 220) && z[0] < 224 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 333);
}
// MCC Label 334
if(!(c >= 216) && !(c < 220) && !(z[0] >= 220) && !(z[0] < 224) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 334);
}
if( c>=0xd8 && c<0xdc && z[0]>=0xdc && z[0]<0xe0 ) { z += 2;
}
    n++;
  };
// ABS Label 298
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
// ABS Label 299
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}

// ROR Label 300
if((n <= nChar) != (n < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
// ROR Label 301
if((n > nChar) != (n < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}
// ROR Label 302
if((n >= nChar) != (n < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}

  
// AOR Label 335
if((int)(z - (const unsigned char *)zIn) / (2 == 2) != (int)(z - (const unsigned char *)zIn) - (2 == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 335);
}
// AOR Label 336
if((int)(z - (const unsigned char *)zIn) + (2 == 2) != (int)(z - (const unsigned char *)zIn) - (2 == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 336);
}
// AOR Label 337
if((int)(z - (const unsigned char *)zIn) * (2 == 2) != (int)(z - (const unsigned char *)zIn) - (2 == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 337);
}
return (int)(z-(unsigned char const *)zIn) 
              - (SQLITE_UTF16NATIVE==SQLITE_UTF16LE);
}

#if defined(SQLITE_TEST)
/*
** This routine is called from the TCL test function "translate_selftest".
** It checks that the primitives for serializing and deserializing
** characters in each encoding are inverses of each other.
*/
void sqlite3UtfSelfTest(void){
  unsigned int i, t;
  unsigned char zBuf[20];
  unsigned char *z;
  int n;
  unsigned int c;

  for(i=0; i<0x00110000; i++){
    z = zBuf;
    WRITE_UTF8(z, i);
    n = (int)(z-zBuf);
    assert( n>0 && n<=4 );
    z[0] = 0;
    z = zBuf;
    c = sqlite3Utf8Read((const u8**)&z);
    t = i;
    if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;
    if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;
    assert( c==t );
    assert( (z-zBuf)==n );
  }
}
#endif /* SQLITE_TEST */
#endif /* SQLITE_OMIT_UTF16 */
