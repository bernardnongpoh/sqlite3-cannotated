/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement a pseudo-random number
** generator (PRNG) for SQLite.
**
** Random numbers are used by some of the database backends in order
** to generate random integer keys for tables or random filenames.
*/
#include "sqliteInt.h"


/* All threads share a single random number generator.
** This structure is the current state of the generator.
*/
static SQLITE_WSD struct sqlite3PrngType {
  unsigned char isInit;          /* True if initialized */
  unsigned char i, j;            /* State variables */
  unsigned char s[256];          /* State variables */
} sqlite3Prng;

/*
** Return N random bytes.
*/
void sqlite3_randomness(int N, void *pBuf){
  unsigned char t;
  unsigned char *zBuf = pBuf;

  /* The "wsdPrng" macro will resolve to the pseudo-random number generator
  ** state vector.  If writable static data is unsupported on the target,
  ** we have to locate the state vector at run-time.  In the more common
  ** case where writable static data is supported, wsdPrng can refer directly
  ** to the "sqlite3Prng" state vector declared above.
  */
#ifdef SQLITE_OMIT_WSD
  struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);
# define wsdPrng p[0]
#else
# define wsdPrng sqlite3Prng
#endif

#if SQLITE_THREADSAFE
  sqlite3_mutex *mutex;
#endif

#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return;
}
#endif

#if SQLITE_THREADSAFE
  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);
#endif

  
// ABS Label 7
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
sqlite3_mutex_enter(mutex);
  
// ABS Label 9
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
// ABS Label 10
if(pBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}

// COR Label 11
if((N <= 0 && pBuf == 0) != (N <= 0 || pBuf == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 11);
}

// ROR Label 12
if((N < 0) != (N <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
// ROR Label 13
if((N > 0) != (N <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if((N >= 0) != (N <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
// ROR Label 15
if((pBuf != 0) != (pBuf == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}

// MCC Label 16
if(N <= 0 && pBuf == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}
// MCC Label 17
if(N <= 0 && !(pBuf == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 17);
}
// MCC Label 18
if(!(N <= 0) && pBuf == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 18);
}
// MCC Label 19
if(!(N <= 0) && !(pBuf == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 19);
}
if( N<=0 || pBuf==0 ){
    wsdPrng.isInit = 0;
    
// ABS Label 20
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
sqlite3_mutex_leave(mutex);
    return;
  }

  /* Initialize the state of the random number generator once,
  ** the first time this routine is called.  The seed value does
  ** not need to contain a lot of randomness since we are not
  ** trying to do secure encryption or anything like that...
  **
  ** Nothing in this file or anywhere else in SQLite does any kind of
  ** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random
  ** number generator) not as an encryption device.
  */
  if( !wsdPrng.isInit ){
    sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
    int i;
    char k[256];
    wsdPrng.j = 0;
    wsdPrng.i = 0;
    
// MCC Label 21
if(( pVfs == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 21);
}
// MCC Label 22
if(( !(pVfs == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 22);
}
if( NEVER(pVfs==0) ){
      memset(k, 0, sizeof(k));
    }else{
      
// ABS Label 23
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3OsRandomness(pVfs, 256, k);
    }
    i = 0;

// ABS Label 24
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// ROR Label 25
if((i <= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
// ROR Label 26
if((i > 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
// ROR Label 27
if((i >= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
for(; i<256; i++){
      wsdPrng.s[i] = (u8)i;
    };
// ABS Label 28
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ROR Label 29
if((i <= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((i > 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
// ROR Label 31
if((i >= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}

    i = 0;

// ABS Label 32
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}

// ROR Label 33
if((i <= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}
// ROR Label 34
if((i > 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
// ROR Label 35
if((i >= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
for(; i<256; i++){
      wsdPrng.j += wsdPrng.s[i] + k[i];
      t = wsdPrng.s[wsdPrng.j];
      wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];
      wsdPrng.s[i] = t;
    };
// ABS Label 36
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ROR Label 37
if((i <= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
// ROR Label 38
if((i > 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((i >= 256) != (i < 256))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}

    wsdPrng.isInit = 1;
  }

  assert( N>0 );
  do{
    wsdPrng.i++;
    t = wsdPrng.s[wsdPrng.i];
    wsdPrng.j += t;
    wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];
    wsdPrng.s[wsdPrng.j] = t;
    t += wsdPrng.s[wsdPrng.i];
    *(zBuf++) = wsdPrng.s[t];
  }while( --N );;
  
// ABS Label 8
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3_mutex_leave(mutex);
}

#ifndef SQLITE_UNTESTABLE
/*
** For testing purposes, we sometimes want to preserve the state of
** PRNG and restore the PRNG to its saved state at a later time, or
** to reset the PRNG to its initial state.  These routines accomplish
** those tasks.
**
** The sqlite3_test_control() interface calls these routines to
** control the PRNG.
*/
static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;
void sqlite3PrngSaveState(void){
  memcpy(
    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),
    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),
    sizeof(sqlite3Prng)
  );
}
void sqlite3PrngRestoreState(void){
  memcpy(
    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),
    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),
    sizeof(sqlite3Prng)
  );
}
#endif /* SQLITE_UNTESTABLE */
