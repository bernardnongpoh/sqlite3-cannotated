/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2007 May 1
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code used to implement incremental BLOB I/O.
*/

#include "sqliteInt.h"
#include "vdbeInt.h"

#ifndef SQLITE_OMIT_INCRBLOB

/*
** Valid sqlite3_blob* handles point to Incrblob structures.
*/
typedef struct Incrblob Incrblob;
struct Incrblob {
  int nByte;              /* Size of open blob, in bytes */
  int iOffset;            /* Byte offset of blob in cursor data */
  u16 iCol;               /* Table column this handle is open on */
  BtCursor *pCsr;         /* Cursor pointing at blob row */
  sqlite3_stmt *pStmt;    /* Statement holding cursor open */
  sqlite3 *db;            /* The associated database */
  char *zDb;              /* Database name */
  Table *pTab;            /* Table object */
};


/*
** This function is used by both blob_open() and blob_reopen(). It seeks
** the b-tree cursor associated with blob handle p to point to row iRow.
** If successful, SQLITE_OK is returned and subsequent calls to
** sqlite3_blob_read() or sqlite3_blob_write() access the specified row.
**
** If an error occurs, or if the specified row does not exist or does not
** contain a value of type TEXT or BLOB in the column nominated when the
** blob handle was opened, then an error code is returned and *pzErr may
** be set to point to a buffer containing an error message. It is the
** responsibility of the caller to free the error message buffer using
** sqlite3DbFree().
**
** If an error does occur, then the b-tree cursor is closed. All subsequent
** calls to sqlite3_blob_read(), blob_write() or blob_reopen() will 
** immediately return SQLITE_ABORT.
*/
static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){
  int rc;                         /* Error code */
  char *zErr = 0;                 /* Error message */
  Vdbe *v = (Vdbe *)p->pStmt;

  /* Set the value of register r[1] in the SQL statement to integer iRow. 
  ** This is done directly as a performance optimization
  */
  v->aMem[1].flags = MEM_Int;
  v->aMem[1].u.i = iRow;

  /* If the statement has been run before (and is paused at the OP_ResultRow)
  ** then back it up to the point where it does the OP_NotExists.  This could
  ** have been down with an extra OP_Goto, but simply setting the program
  ** counter is faster. */
  
// ABS Label 7
if(v->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ROR Label 8
if((v->pc <= 4) != (v->pc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
// ROR Label 9
if((v->pc < 4) != (v->pc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 9);
}
// ROR Label 10
if((v->pc >= 4) != (v->pc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( v->pc>4 ){
    v->pc = 4;
    assert( v->aOp[v->pc].opcode==OP_NotExists );
    rc = sqlite3VdbeExec(v);
  }else{
    rc = sqlite3_step(p->pStmt);
  }
  
// ABS Label 11
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ROR Label 12
if((rc != 100) != (rc == 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
if( rc==SQLITE_ROW ){
    
// ABS Label 13
if(v->apCsr[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
VdbeCursor *pC = v->apCsr[0];
    u32 type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;
    testcase( pC->nHdrParsed==p->iCol );
    testcase( pC->nHdrParsed==p->iCol+1 );
    
// ABS Label 14
if(type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ROR Label 15
if((type <= 12) != (type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
// ROR Label 16
if((type > 12) != (type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
// ROR Label 17
if((type >= 12) != (type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
if( type<12 ){
      zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",
          type==0?"null": type==7?"real": "integer"
      );
      rc = SQLITE_ERROR;
      
// ABS Label 18
if(p->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
sqlite3_finalize(p->pStmt);
      p->pStmt = 0;
    }else{
      p->iOffset = pC->aType[p->iCol + pC->nField];
      p->nByte = sqlite3VdbeSerialTypeLen(type);
      p->pCsr =  pC->uc.pCursor;
      
// ABS Label 19
if(p->pCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3BtreeIncrblobCursor(p->pCsr);
    }
  }

  
// ABS Label 20
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}

// ROR Label 21
if((rc != 100) != (rc == 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
if( rc==SQLITE_ROW ){
    rc = SQLITE_OK;
  }else { 
// ABS Label 22
if(p->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
if( p->pStmt ){
    rc = sqlite3_finalize(p->pStmt);
    p->pStmt = 0;
    
// ABS Label 23
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}

// ROR Label 24
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
if( rc==SQLITE_OK ){
      zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);
      rc = SQLITE_ERROR;
    }else{
      zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));
    }
  };}


  assert( rc!=SQLITE_OK || zErr==0 );
  assert( rc!=SQLITE_ROW && rc!=SQLITE_DONE );

  *pzErr = zErr;
  
// ABS Label 25
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
return rc;
}

/*
** Open a blob handle.
*/
int sqlite3_blob_open(
  sqlite3* db,            /* The database connection */
  const char *zDb,        /* The attached database containing the blob */
  const char *zTable,     /* The table containing the blob */
  const char *zColumn,    /* The column containing the blob */
  sqlite_int64 iRow,      /* The row containing the glob */
  int wrFlag,             /* True -> read/write access, false -> read-only */
  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */
){
  int nAttempt = 0;
  int iCol;               /* Index of zColumn in row-record */
  int rc = SQLITE_OK;
  char *zErr = 0;
  Table *pTab;
  Incrblob *pBlob = 0;
  Parse sParse;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( ppBlob==0 ){
    return SQLITE_MISUSE_BKPT;
  }
#endif
  *ppBlob = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(db) || zTable==0 ){
    return SQLITE_MISUSE_BKPT;
  }
#endif
  wrFlag = !!wrFlag;                /* wrFlag = (wrFlag ? 1 : 0); */

  
// ABS Label 26
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3_mutex_enter(db->mutex);

  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));
  do {
    memset(&sParse, 0, sizeof(Parse));
    if( !pBlob ) { goto blob_open_out;
}
    sParse.db = db;
    
// ABS Label 32
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
sqlite3DbFree(db, zErr);
    zErr = 0;

    
// ABS Label 33
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3BtreeEnterAll(db);
    pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);
    
// ABS Label 35
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
// ABS Label 36
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// COR Label 37
if((pTab || ((pTab)->nModuleArg)) != (pTab && ((pTab)->nModuleArg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 37);
}

// MCC Label 38
if(pTab && ((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 38);
}
// MCC Label 39
if(pTab && !(((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 39);
}
// MCC Label 40
if(!(pTab) && ((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(!(pTab) && !(((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
if( pTab && IsVirtual(pTab) ){
      pTab = 0;
      
// ABS Label 42
if(zTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}
sqlite3ErrorMsg(&sParse, "cannot open virtual table: %s", zTable);
    }
    
// ABS Label 43
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// COR Label 44
if((pTab || !(((pTab)->tabFlags & 128) == 0)) != (pTab && !(((pTab)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 44);
}

// MCC Label 45
if(pTab && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 45);
}
// MCC Label 46
if(pTab && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 46);
}
// MCC Label 47
if(!(pTab) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if(!(pTab) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
if( pTab && !HasRowid(pTab) ){
      pTab = 0;
      
// ABS Label 49
if(zTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
sqlite3ErrorMsg(&sParse, "cannot open table without rowid: %s", zTable);
    }
#ifndef SQLITE_OMIT_VIEW
    
// ABS Label 50
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
// ABS Label 51
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// COR Label 52
if((pTab || pTab->pSelect) != (pTab && pTab->pSelect))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 52);
}

// MCC Label 53
if(pTab && pTab->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(pTab && !(pTab->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(!(pTab) && pTab->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(pTab) && !(pTab->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
if( pTab && pTab->pSelect ){
      pTab = 0;
      
// ABS Label 57
if(zTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
sqlite3ErrorMsg(&sParse, "cannot open view: %s", zTable);
    }
#endif
    if( !pTab ){
      
// ABS Label 59
if(sParse.zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
if( sParse.zErrMsg ){
        
// ABS Label 60
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
sqlite3DbFree(db, zErr);
        zErr = sParse.zErrMsg;
        sParse.zErrMsg = 0;
      }
      rc = SQLITE_ERROR;
      
// ABS Label 58
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
sqlite3BtreeLeaveAll(db);
      goto blob_open_out;
    }
    pBlob->pTab = pTab;
    pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;

    /* Now search pTab for the exact column. */
    iCol = 0;

// ABS Label 61
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}

// ROR Label 62
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}
// ROR Label 63
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
for(; iCol<pTab->nCol; iCol++) {
      if( sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn)==0 ){
        break;
      }
    };
// ABS Label 65
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}

// ROR Label 66
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
// ROR Label 67
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
// ROR Label 68
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}

    
// ABS Label 69
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}

// ROR Label 70
if((iCol != pTab->nCol) != (iCol == pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
if( iCol==pTab->nCol ){
      
// ABS Label 71
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}
sqlite3DbFree(db, zErr);
      zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
      rc = SQLITE_ERROR;
      
// ABS Label 72
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
sqlite3BtreeLeaveAll(db);
      goto blob_open_out;
    }

    /* If the value is being opened for writing, check that the
    ** column is not indexed, and that it is not part of a foreign key. 
    */
    
// ABS Label 73
if(wrFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
if( wrFlag ){
      const char *zFault = 0;
      Index *pIdx;
#ifndef SQLITE_OMIT_FOREIGN_KEY
      
// ABS Label 74
if(db->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}

// AOR Label 75
if(db->flags | 16384 != db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 75);
}
// AOR Label 76
if(db->flags ^ 16384 != db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 76);
}
if( db->flags&SQLITE_ForeignKeys ){
        /* Check that the column is not part of an FK child key definition. It
        ** is not necessary to check if it is part of a parent key, as parent
        ** key columns must be indexed. The check below will pick up this 
        ** case.  */
        FKey *pFKey;
        pFKey = pTab->pFKey;

// ABS Label 77
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}
for(; pFKey; pFKey=pFKey->pNextFrom){
          int j;
          j = 0;

// ABS Label 79
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}
// ABS Label 80
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}

// ROR Label 81
if((j <= pFKey->nCol) != (j < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
// ROR Label 82
if((j > pFKey->nCol) != (j < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
// ROR Label 83
if((j >= pFKey->nCol) != (j < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
for(; j<pFKey->nCol; j++){
            
// ABS Label 89
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
// ABS Label 90
if(pFKey->aCol[j].iFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ROR Label 91
if((pFKey->aCol[j].iFrom != iCol) != (pFKey->aCol[j].iFrom == iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
if( pFKey->aCol[j].iFrom==iCol ){
              zFault = "foreign key";
            }
          };
// ABS Label 84
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
// ABS Label 85
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}

// ROR Label 86
if((j <= pFKey->nCol) != (j < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
// ROR Label 87
if((j > pFKey->nCol) != (j < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}
// ROR Label 88
if((j >= pFKey->nCol) != (j < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 88);
}

        };
// ABS Label 78
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}

      }
#endif
      pIdx = pTab->pIndex;

// ABS Label 92
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}
for(; pIdx; pIdx=pIdx->pNext){
        int j;
        j = 0;

// ABS Label 94
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// ROR Label 95
if((j <= pIdx->nKeyCol) != (j < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
// ROR Label 96
if((j > pIdx->nKeyCol) != (j < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
// ROR Label 97
if((j >= pIdx->nKeyCol) != (j < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
for(; j<pIdx->nKeyCol; j++){
          /* FIXME: Be smarter about indexes that use expressions */
          
// ABS Label 102
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}

// COR Label 103
if((pIdx->aiColumn[j] == iCol && pIdx->aiColumn[j] == (-2)) != (pIdx->aiColumn[j] == iCol || pIdx->aiColumn[j] == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 103);
}

// ROR Label 104
if((pIdx->aiColumn[j] != iCol) != (pIdx->aiColumn[j] == iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
// ROR Label 105
if((pIdx->aiColumn[j] != (-2)) != (pIdx->aiColumn[j] == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}

// MCC Label 106
if(pIdx->aiColumn[j] == iCol && pIdx->aiColumn[j] == (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 106);
}
// MCC Label 107
if(pIdx->aiColumn[j] == iCol && !(pIdx->aiColumn[j] == (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 107);
}
// MCC Label 108
if(!(pIdx->aiColumn[j] == iCol) && pIdx->aiColumn[j] == (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
// MCC Label 109
if(!(pIdx->aiColumn[j] == iCol) && !(pIdx->aiColumn[j] == (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 109);
}
if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==XN_EXPR ){
            zFault = "indexed";
          }
        };
// ABS Label 98
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}

// ROR Label 99
if((j <= pIdx->nKeyCol) != (j < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
// ROR Label 100
if((j > pIdx->nKeyCol) != (j < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}
// ROR Label 101
if((j >= pIdx->nKeyCol) != (j < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 101);
}

      };
// ABS Label 93
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}

      
// ABS Label 110
if(zFault < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}
if( zFault ){
        
// ABS Label 111
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}
sqlite3DbFree(db, zErr);
        zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
        rc = SQLITE_ERROR;
        
// ABS Label 112
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}
sqlite3BtreeLeaveAll(db);
        goto blob_open_out;
      }
    }

    pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);
    assert( pBlob->pStmt || db->mallocFailed );
    
// ABS Label 113
if(pBlob->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
if( pBlob->pStmt ){
      
      /* This VDBE program seeks a btree cursor to the identified 
      ** db/table/row entry. The reason for using a vdbe program instead
      ** of writing code to use the b-tree layer directly is that the
      ** vdbe program will take advantage of the various transaction,
      ** locking and error handling infrastructure built into the vdbe.
      **
      ** After seeking the cursor, the vdbe executes an OP_ResultRow.
      ** Code external to the Vdbe then "borrows" the b-tree cursor and
      ** uses it to implement the blob_read(), blob_write() and 
      ** blob_bytes() functions.
      **
      ** The sqlite3_blob_close() function finalizes the vdbe program,
      ** which closes the b-tree cursor and (possibly) commits the 
      ** transaction.
      */
      static const int iLn = VDBE_OFFSET_LINENO(2);
      static const VdbeOpList openBlob[] = {
        {OP_TableLock,      0, 0, 0},  /* 0: Acquire a read or write lock */
        {OP_OpenRead,       0, 0, 0},  /* 1: Open a cursor */
        /* blobSeekToRow() will initialize r[1] to the desired rowid */
        {OP_NotExists,      0, 5, 1},  /* 2: Seek the cursor to rowid=r[1] */
        {OP_Column,         0, 0, 1},  /* 3  */
        {OP_ResultRow,      1, 0, 0},  /* 4  */
        {OP_Halt,           0, 0, 0},  /* 5  */
      };
      Vdbe *v = (Vdbe *)pBlob->pStmt;
      int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      VdbeOp *aOp;

      
// ABS Label 114
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// ABS Label 115
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// ABS Label 116
if(wrFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ABS Label 117
if(pTab->pSchema->schema_cookie < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// ABS Label 118
if(pTab->pSchema->iGeneration < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}
sqlite3VdbeAddOp4Int(v, OP_Transaction, iDb, wrFlag, 
                           pTab->pSchema->schema_cookie,
                           pTab->pSchema->iGeneration);
      
// ABS Label 119
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}
sqlite3VdbeChangeP5(v, 1);
      assert( sqlite3VdbeCurrentAddr(v)==2 || db->mallocFailed );
      aOp = sqlite3VdbeAddOpList(v, ArraySize(openBlob), openBlob, iLn);

      /* Make sure a mutex is held on the table to be accessed */
      
// ABS Label 120
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// ABS Label 121
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}
sqlite3VdbeUsesBtree(v, iDb); 

      
// ROR Label 122
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
if( db->mallocFailed==0 ){
        assert( aOp!=0 );
        /* Configure the OP_TableLock instruction */
#ifdef SQLITE_OMIT_SHARED_CACHE
        aOp[0].opcode = OP_Noop;
#else
        aOp[0].p1 = iDb;
        aOp[0].p2 = pTab->tnum;
        aOp[0].p3 = wrFlag;
        
// ABS Label 123
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}
sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT);
      }
      
// ROR Label 124
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}
if( db->mallocFailed==0 ){
#endif

        /* Remove either the OP_OpenWrite or OpenRead. Set the P2 
        ** parameter of the other to pTab->tnum.  */
        
// ABS Label 126
if(wrFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}
if( wrFlag ) { aOp[1].opcode = OP_OpenWrite;
}
        aOp[1].p2 = pTab->tnum;
        aOp[1].p3 = iDb;   

        /* Configure the number of columns. Configure the cursor to
        ** think that the table has one more column than it really
        ** does. An OP_Column to retrieve this imaginary column will
        ** always return an SQL NULL. This is useful because it means
        ** we can invoke OP_Column to fill in the vdbe cursors type 
        ** and offset cache without causing any IO.
        */
        aOp[1].p4type = P4_INT32;
        aOp[1].p4.i = pTab->nCol+1;
        aOp[3].p2 = pTab->nCol;

        sParse.nVar = 0;
        sParse.nMem = 1;
        sParse.nTab = 1;
        
// ABS Label 125
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
sqlite3VdbeMakeReady(v, &sParse);
      }
    }
   
    pBlob->iCol = iCol;
    pBlob->db = db;
    
// ABS Label 34
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
sqlite3BtreeLeaveAll(db);
    
// ABS Label 127
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}
if( db->mallocFailed ){
      goto blob_open_out;
    }
    rc = blobSeekToRow(pBlob, iRow, &zErr);
  } while( (++nAttempt)<SQLITE_MAX_SCHEMA_RETRY && rc==SQLITE_SCHEMA );;

blob_open_out:
  
// ABS Label 128
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}

// COR Label 129
if((rc == 0 || db->mallocFailed == 0) != (rc == 0 && db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 129);
}

// ROR Label 130
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}

// MCC Label 132
if(rc == 0 && db->mallocFailed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
// MCC Label 133
if(rc == 0 && !(db->mallocFailed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 133);
}
// MCC Label 134
if(!(rc == 0) && db->mallocFailed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 134);
}
// MCC Label 135
if(!(rc == 0) && !(db->mallocFailed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
if( rc==SQLITE_OK && db->mallocFailed==0 ){
    *ppBlob = (sqlite3_blob *)pBlob;
  }else{
    
// ABS Label 137
if(pBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
// ABS Label 138
if(pBlob->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// COR Label 139
if((pBlob || pBlob->pStmt) != (pBlob && pBlob->pStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 139);
}

// MCC Label 140
if(pBlob && pBlob->pStmt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 140);
}
// MCC Label 141
if(pBlob && !(pBlob->pStmt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 141);
}
// MCC Label 142
if(!(pBlob) && pBlob->pStmt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 142);
}
// MCC Label 143
if(!(pBlob) && !(pBlob->pStmt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 143);
}
if( pBlob && pBlob->pStmt ) { sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);
}
    
// ABS Label 136
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
sqlite3DbFree(db, pBlob);
  }
  
// ABS Label 27
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}

// ABS Label 28
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ABS Label 29
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);
  
// ABS Label 30
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
sqlite3DbFree(db, zErr);
  sqlite3ParserReset(&sParse);
  rc = sqlite3ApiExit(db, rc);
  
// ABS Label 31
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 144
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}
return rc;
}

/*
** Close a blob handle that was previously created using
** sqlite3_blob_open().
*/
int sqlite3_blob_close(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  int rc;
  sqlite3 *db;

  
// ABS Label 145
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}
if( p ){
    
// ABS Label 146
if(p->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
sqlite3_stmt *pStmt = p->pStmt;
    db = p->db;
    
// ABS Label 147
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
sqlite3_mutex_enter(db->mutex);
    
// ABS Label 148
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
sqlite3DbFree(db, p);
    
// ABS Label 149
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3_mutex_leave(db->mutex);
    rc = sqlite3_finalize(pStmt);
  }else{
    rc = SQLITE_OK;
  }
  
// ABS Label 150
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
return rc;
}

/*
** Perform a read or write operation on a blob
*/
static int blobReadWrite(
  sqlite3_blob *pBlob, 
  void *z, 
  int n, 
  int iOffset, 
  int (*xCall)(BtCursor*, u32, u32, void*)
){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  Vdbe *v;
  sqlite3 *db;

  
// ABS Label 155
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}

// ROR Label 156
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
if( p==0 ) { return SQLITE_MISUSE_BKPT;
}
  db = p->db;
  
// ABS Label 151
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}
sqlite3_mutex_enter(db->mutex);
  v = (Vdbe*)p->pStmt;

  
// ABS Label 157
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
// ABS Label 158
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// COR Label 159
if((n < 0 || iOffset < 0 && ((sqlite3_int64)iOffset + n) > p->nByte) != (n < 0 || iOffset < 0 || ((sqlite3_int64)iOffset + n) > p->nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 159);
}
// COR Label 160
if((n < 0 && iOffset < 0) != (n < 0 || iOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 160);
}

// ROR Label 161
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
// ROR Label 164
if((iOffset <= 0) != (iOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
// ROR Label 165
if((iOffset > 0) != (iOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((iOffset >= 0) != (iOffset < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((((sqlite3_int64)iOffset + n) <= p->nByte) != (((sqlite3_int64)iOffset + n) > p->nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((((sqlite3_int64)iOffset + n) < p->nByte) != (((sqlite3_int64)iOffset + n) > p->nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
// ROR Label 169
if((((sqlite3_int64)iOffset + n) >= p->nByte) != (((sqlite3_int64)iOffset + n) > p->nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}

// MCC Label 170
if(n < 0 && iOffset < 0 && ((sqlite3_int64)iOffset + n) > p->nByte ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
// MCC Label 171
if(n < 0 && iOffset < 0 && !(((sqlite3_int64)iOffset + n) > p->nByte) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 171);
}
// MCC Label 172
if(n < 0 && !(iOffset < 0) && ((sqlite3_int64)iOffset + n) > p->nByte ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}
// MCC Label 173
if(n < 0 && !(iOffset < 0) && !(((sqlite3_int64)iOffset + n) > p->nByte) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 173);
}
// MCC Label 174
if(!(n < 0) && iOffset < 0 && ((sqlite3_int64)iOffset + n) > p->nByte ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 174);
}
// MCC Label 175
if(!(n < 0) && iOffset < 0 && !(((sqlite3_int64)iOffset + n) > p->nByte) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 175);
}
// MCC Label 176
if(!(n < 0) && !(iOffset < 0) && ((sqlite3_int64)iOffset + n) > p->nByte ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if(!(n < 0) && !(iOffset < 0) && !(((sqlite3_int64)iOffset + n) > p->nByte) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){
    /* Request is out of range. Return a transient error. */
    rc = SQLITE_ERROR;
  }else { 
// ABS Label 178
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}

// ROR Label 179
if((v != 0) != (v == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}
if( v==0 ){
    /* If there is no statement handle, then the blob-handle has
    ** already been invalidated. Return SQLITE_ABORT in this case.
    */
    rc = SQLITE_ABORT;
  }else{
    /* Call either BtreeData() or BtreePutData(). If SQLITE_ABORT is
    ** returned, clean-up the statement handle.
    */
    assert( db == v->db );
    
// ABS Label 180
if(p->pCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
sqlite3BtreeEnterCursor(p->pCsr);

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
    if( xCall==sqlite3BtreePutData && db->xPreUpdateCallback ){
      /* If a pre-update hook is registered and this is a write cursor, 
      ** invoke it here. 
      ** 
      ** TODO: The preupdate-hook is passed SQLITE_DELETE, even though this
      ** operation should really be an SQLITE_UPDATE. This is probably
      ** incorrect, but is convenient because at this point the new.* values 
      ** are not easily obtainable. And for the sessions module, an 
      ** SQLITE_UPDATE where the PK columns do not change is handled in the 
      ** same way as an SQLITE_DELETE (the SQLITE_DELETE code is actually
      ** slightly more efficient). Since you cannot write to a PK column
      ** using the incremental-blob API, this works. For the sessions module
      ** anyhow.
      */
      sqlite3_int64 iKey;
      iKey = sqlite3BtreeIntegerKey(p->pCsr);
      sqlite3VdbePreUpdateHook(
          v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1, p->iCol
      );
    }
#endif

    rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);
    
// ABS Label 181
if(p->pCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
sqlite3BtreeLeaveCursor(p->pCsr);
    
// ABS Label 182
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}

// ROR Label 183
if((rc != 4) != (rc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
if( rc==SQLITE_ABORT ){
      
// ABS Label 184
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}
sqlite3VdbeFinalize(v);
      p->pStmt = 0;
    }else{
      v->rc = rc;
    }
  };}

  
// ABS Label 152
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// ABS Label 153
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}
sqlite3Error(db, rc);
  rc = sqlite3ApiExit(db, rc);
  
// ABS Label 154
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 185
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
return rc;
}

/*
** Read data from a blob handle.
*/
int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked);
}

/*
** Write data to a blob handle.
*/
int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);
}

/*
** Query a blob handle for the size of the data.
**
** The Incrblob.nByte field is fixed for the lifetime of the Incrblob
** so no mutex is required for access.
*/
int sqlite3_blob_bytes(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  return (p && p->pStmt) ? p->nByte : 0;
}

/*
** Move an existing blob handle to point to a different row of the same
** database table.
**
** If an error occurs, or if the specified row does not exist or does not
** contain a blob or text value, then an error code is returned and the
** database handle error code and message set. If this happens, then all 
** subsequent calls to sqlite3_blob_xxx() functions (except blob_close()) 
** immediately return SQLITE_ABORT.
*/
int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  sqlite3 *db;

  
// ABS Label 188
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// ROR Label 189
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
if( p==0 ) { return SQLITE_MISUSE_BKPT;
}
  db = p->db;
  
// ABS Label 186
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
sqlite3_mutex_enter(db->mutex);

  
// ABS Label 190
if(p->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}

// ROR Label 191
if((p->pStmt != 0) != (p->pStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
if( p->pStmt==0 ){
    /* If there is no statement handle, then the blob-handle has
    ** already been invalidated. Return SQLITE_ABORT in this case.
    */
    rc = SQLITE_ABORT;
  }else{
    char *zErr;
    ((Vdbe*)p->pStmt)->rc = SQLITE_OK;
    rc = blobSeekToRow(p, iRow, &zErr);
    
// ABS Label 192
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}

// ROR Label 193
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 194
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}

// ABS Label 195
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}

// ABS Label 196
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}
sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);
      
// ABS Label 197
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
sqlite3DbFree(db, zErr);
    }
    assert( rc!=SQLITE_SCHEMA );
  }

  rc = sqlite3ApiExit(db, rc);
  assert( rc==SQLITE_OK || p->pStmt==0 );
  
// ABS Label 187
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 198
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
return rc;
}

#endif /* #ifndef SQLITE_OMIT_INCRBLOB */
