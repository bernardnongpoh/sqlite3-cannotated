/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used by the compiler to add foreign key
** support to compiled SQL statements.
*/
#include "sqliteInt.h"

#ifndef SQLITE_OMIT_FOREIGN_KEY
#ifndef SQLITE_OMIT_TRIGGER

/*
** Deferred and Immediate FKs
** --------------------------
**
** Foreign keys in SQLite come in two flavours: deferred and immediate.
** If an immediate foreign key constraint is violated,
** SQLITE_CONSTRAINT_FOREIGNKEY is returned and the current
** statement transaction rolled back. If a 
** deferred foreign key constraint is violated, no action is taken 
** immediately. However if the application attempts to commit the 
** transaction before fixing the constraint violation, the attempt fails.
**
** Deferred constraints are implemented using a simple counter associated
** with the database handle. The counter is set to zero each time a 
** database transaction is opened. Each time a statement is executed 
** that causes a foreign key violation, the counter is incremented. Each
** time a statement is executed that removes an existing violation from
** the database, the counter is decremented. When the transaction is
** committed, the commit fails if the current value of the counter is
** greater than zero. This scheme has two big drawbacks:
**
**   * When a commit fails due to a deferred foreign key constraint, 
**     there is no way to tell which foreign constraint is not satisfied,
**     or which row it is not satisfied for.
**
**   * If the database contains foreign key violations when the 
**     transaction is opened, this may cause the mechanism to malfunction.
**
** Despite these problems, this approach is adopted as it seems simpler
** than the alternatives.
**
** INSERT operations:
**
**   I.1) For each FK for which the table is the child table, search
**        the parent table for a match. If none is found increment the
**        constraint counter.
**
**   I.2) For each FK for which the table is the parent table, 
**        search the child table for rows that correspond to the new
**        row in the parent table. Decrement the counter for each row
**        found (as the constraint is now satisfied).
**
** DELETE operations:
**
**   D.1) For each FK for which the table is the child table, 
**        search the parent table for a row that corresponds to the 
**        deleted row in the child table. If such a row is not found, 
**        decrement the counter.
**
**   D.2) For each FK for which the table is the parent table, search 
**        the child table for rows that correspond to the deleted row 
**        in the parent table. For each found increment the counter.
**
** UPDATE operations:
**
**   An UPDATE command requires that all 4 steps above are taken, but only
**   for FK constraints for which the affected columns are actually 
**   modified (values must be compared at runtime).
**
** Note that I.1 and D.1 are very similar operations, as are I.2 and D.2.
** This simplifies the implementation a bit.
**
** For the purposes of immediate FK constraints, the OR REPLACE conflict
** resolution is considered to delete rows before the new row is inserted.
** If a delete caused by OR REPLACE violates an FK constraint, an exception
** is thrown, even if the FK constraint would be satisfied after the new 
** row is inserted.
**
** Immediate constraints are usually handled similarly. The only difference 
** is that the counter used is stored as part of each individual statement
** object (struct Vdbe). If, after the statement has run, its immediate
** constraint counter is greater than zero,
** it returns SQLITE_CONSTRAINT_FOREIGNKEY
** and the statement transaction is rolled back. An exception is an INSERT
** statement that inserts a single row only (no triggers). In this case,
** instead of using a counter, an exception is thrown immediately if the
** INSERT violates a foreign key constraint. This is necessary as such
** an INSERT does not open a statement transaction.
**
** TODO: How should dropping a table be handled? How should renaming a 
** table be handled?
**
**
** Query API Notes
** ---------------
**
** Before coding an UPDATE or DELETE row operation, the code-generator
** for those two operations needs to know whether or not the operation
** requires any FK processing and, if so, which columns of the original
** row are required by the FK processing VDBE code (i.e. if FKs were
** implemented using triggers, which of the old.* columns would be 
** accessed). No information is required by the code-generator before
** coding an INSERT operation. The functions used by the UPDATE/DELETE
** generation code to query for this information are:
**
**   sqlite3FkRequired() - Test to see if FK processing is required.
**   sqlite3FkOldmask()  - Query for the set of required old.* columns.
**
**
** Externally accessible module functions
** --------------------------------------
**
**   sqlite3FkCheck()    - Check for foreign key violations.
**   sqlite3FkActions()  - Code triggers for ON UPDATE/ON DELETE actions.
**   sqlite3FkDelete()   - Delete an FKey structure.
*/

/*
** VDBE Calling Convention
** -----------------------
**
** Example:
**
**   For the following INSERT statement:
**
**     CREATE TABLE t1(a, b INTEGER PRIMARY KEY, c);
**     INSERT INTO t1 VALUES(1, 2, 3.1);
**
**   Register (x):        2    (type integer)
**   Register (x+1):      1    (type integer)
**   Register (x+2):      NULL (type NULL)
**   Register (x+3):      3.1  (type real)
*/

/*
** A foreign key constraint requires that the key columns in the parent
** table are collectively subject to a UNIQUE or PRIMARY KEY constraint.
** Given that pParent is the parent table for foreign key constraint pFKey, 
** search the schema for a unique index on the parent key columns. 
**
** If successful, zero is returned. If the parent key is an INTEGER PRIMARY 
** KEY column, then output variable *ppIdx is set to NULL. Otherwise, *ppIdx 
** is set to point to the unique index. 
** 
** If the parent key consists of a single column (the foreign key constraint
** is not a composite foreign key), output variable *paiCol is set to NULL.
** Otherwise, it is set to point to an allocated array of size N, where
** N is the number of columns in the parent key. The first element of the
** array is the index of the child table column that is mapped by the FK
** constraint to the parent table column stored in the left-most column
** of index *ppIdx. The second element of the array is the index of the
** child table column that corresponds to the second left-most column of
** *ppIdx, and so on.
**
** If the required index cannot be found, either because:
**
**   1) The named parent key columns do not exist, or
**
**   2) The named parent key columns do exist, but are not subject to a
**      UNIQUE or PRIMARY KEY constraint, or
**
**   3) No parent key columns were provided explicitly as part of the
**      foreign key definition, and the parent table does not have a
**      PRIMARY KEY, or
**
**   4) No parent key columns were provided explicitly as part of the
**      foreign key definition, and the PRIMARY KEY of the parent table 
**      consists of a different number of columns to the child key in 
**      the child table.
**
** then non-zero is returned, and a "foreign key mismatch" error loaded
** into pParse. If an OOM error occurs, non-zero is returned and the
** pParse->db->mallocFailed flag is set.
*/
int sqlite3FkLocateIndex(
  Parse *pParse,                  /* Parse context to store any error in */
  Table *pParent,                 /* Parent table of FK constraint pFKey */
  FKey *pFKey,                    /* Foreign key to find index for */
  Index **ppIdx,                  /* OUT: Unique index on parent table */
  int **paiCol                    /* OUT: Map of index columns in pFKey */
){
  Index *pIdx = 0;                    /* Value to return via *ppIdx */
  int *aiCol = 0;                     /* Value to return via *paiCol */
  
// ABS Label 7
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
int nCol = pFKey->nCol;             /* Number of columns in parent key */
  
// ABS Label 8
if(pFKey->aCol[0].zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
char *zKey = pFKey->aCol[0].zCol;   /* Name of left-most parent key column */

  /* The caller is responsible for zeroing output parameters. */
  assert( ppIdx && *ppIdx==0 );
  assert( !paiCol || *paiCol==0 );
  assert( pParse );

  /* If this is a non-composite (single column) foreign key, check if it 
  ** maps to the INTEGER PRIMARY KEY of table pParent. If so, leave *ppIdx 
  ** and *paiCol set to zero and return early. 
  **
  ** Otherwise, for a composite foreign key (more than one column), allocate
  ** space for the aiCol array (returned via output parameter *paiCol).
  ** Non-composite foreign keys do not require the aiCol array.
  */
  
// ABS Label 9
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

// ROR Label 10
if((nCol != 1) != (nCol == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( nCol==1 ){
    /* The FK maps to the IPK if any of the following are true:
    **
    **   1) There is an INTEGER PRIMARY KEY column and the FK is implicitly 
    **      mapped to the primary key of table pParent, or
    **   2) The FK is explicitly mapped to a column declared as INTEGER
    **      PRIMARY KEY.
    */
    
// ROR Label 11
if((pParent->iPKey < 0) != (pParent->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 11);
}
// ROR Label 12
if((pParent->iPKey > 0) != (pParent->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
// ROR Label 13
if((pParent->iPKey <= 0) != (pParent->iPKey >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
if( pParent->iPKey>=0 ){
      if( !zKey ) { return 0;
}
      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zName, zKey) ) { return 0;
}
    }
  }else { 
// ABS Label 14
if(paiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
if( paiCol ){
    assert( nCol>1 );
    aiCol = (int *)sqlite3DbMallocRawNN(pParse->db, nCol*sizeof(int));
    if( !aiCol ) { return 1;
}
    *paiCol = aiCol;
  };}


  pIdx = pParent->pIndex;

// ABS Label 15
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
for(; pIdx; pIdx=pIdx->pNext){
    
// ABS Label 17
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
// ABS Label 18
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// COR Label 19
if((pIdx->nKeyCol == nCol && ((pIdx)->onError != 0) || pIdx->pPartIdxWhere == 0) != (pIdx->nKeyCol == nCol && ((pIdx)->onError != 0) && pIdx->pPartIdxWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 19);
}
// COR Label 20
if((pIdx->nKeyCol == nCol || ((pIdx)->onError != 0)) != (pIdx->nKeyCol == nCol && ((pIdx)->onError != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 20);
}

// ROR Label 21
if((pIdx->nKeyCol != nCol) != (pIdx->nKeyCol == nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
// ROR Label 22
if((pIdx->pPartIdxWhere != 0) != (pIdx->pPartIdxWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}

// MCC Label 23
if(pIdx->nKeyCol == nCol && ( (pIdx)->onError != 0 ) && pIdx->pPartIdxWhere == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 23);
}
// MCC Label 24
if(pIdx->nKeyCol == nCol && ( (pIdx)->onError != 0 ) && !(pIdx->pPartIdxWhere == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 24);
}
// MCC Label 25
if(pIdx->nKeyCol == nCol && ( !((pIdx)->onError != 0) ) && pIdx->pPartIdxWhere == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 25);
}
// MCC Label 26
if(pIdx->nKeyCol == nCol && ( !((pIdx)->onError != 0) ) && !(pIdx->pPartIdxWhere == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}
// MCC Label 27
if(!(pIdx->nKeyCol == nCol) && ( (pIdx)->onError != 0 ) && pIdx->pPartIdxWhere == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 27);
}
// MCC Label 28
if(!(pIdx->nKeyCol == nCol) && ( (pIdx)->onError != 0 ) && !(pIdx->pPartIdxWhere == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
// MCC Label 29
if(!(pIdx->nKeyCol == nCol) && ( !((pIdx)->onError != 0) ) && pIdx->pPartIdxWhere == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 29);
}
// MCC Label 30
if(!(pIdx->nKeyCol == nCol) && ( !((pIdx)->onError != 0) ) && !(pIdx->pPartIdxWhere == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 30);
}
if( pIdx->nKeyCol==nCol && IsUniqueIndex(pIdx) && pIdx->pPartIdxWhere==0 ){ 
      /* pIdx is a UNIQUE index (or a PRIMARY KEY) and has the right number
      ** of columns. If each indexed column corresponds to a foreign key
      ** column of pFKey, then this index is a winner.  */

      
// ABS Label 31
if(zKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// ROR Label 32
if((zKey != 0) != (zKey == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
if( zKey==0 ){
        /* If zKey is NULL, then this foreign key is implicitly mapped to 
        ** the PRIMARY KEY of table pParent. The PRIMARY KEY index may be 
        ** identified by the test.  */
        
// MCC Label 33
if(( (pIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 33);
}
// MCC Label 34
if(( !((pIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 34);
}
if( IsPrimaryKeyIndex(pIdx) ){
          
// ABS Label 35
if(aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
if( aiCol ){
            int i;
            i = 0;

// ABS Label 36
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}
// ABS Label 37
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}

// ROR Label 38
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
// ROR Label 40
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
for(; i<nCol; i++) { aiCol[i] = pFKey->aCol[i].iFrom;
};
// ABS Label 41
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
// ABS Label 42
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}

// ROR Label 43
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
// ROR Label 45
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}

          }
          break;
        }
      }else{
        /* If zKey is non-NULL, then this foreign key was declared to
        ** map to an explicit list of columns in table pParent. Check if this
        ** index matches those columns. Also, check that the index uses
        ** the default collation sequences for each column. */
        int i, j;
        i = 0;

// ABS Label 46
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
// ABS Label 47
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ROR Label 48
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
// ROR Label 49
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
// ROR Label 50
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
for(; i<nCol; i++){
          
// ABS Label 56
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}
// ABS Label 57
if(pIdx->aiColumn[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
i16 iCol = pIdx->aiColumn[i];     /* Index of column in parent tbl */
          const char *zDfltColl;            /* Def. collation for column */
          char *zIdxCol;                    /* Name of indexed column */

          
// ROR Label 58
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
// ROR Label 60
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
if( iCol<0 ) { break; /* No foreign keys against expression indexes */
}

          /* If the index uses a collation sequence that is different from
          ** the default collation sequence for the column, this index is
          ** unusable. Bail out early in this case.  */
          zDfltColl = pParent->aCol[iCol].zColl;
          if( !zDfltColl ) { zDfltColl = sqlite3StrBINARY;
}
          if( sqlite3StrICmp(pIdx->azColl[i], zDfltColl) ) { break;
}

          zIdxCol = pParent->aCol[iCol].zName;
          j = 0;

// ABS Label 61
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
// ABS Label 62
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// ROR Label 63
if((j <= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((j > nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((j >= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
for(; j<nCol; j++){
            if( sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol)==0 ){
              
// ABS Label 71
if(aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}
if( aiCol ) { aiCol[i] = pFKey->aCol[j].iFrom;
}
              break;
            }
          };
// ABS Label 66
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
// ABS Label 67
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}

// ROR Label 68
if((j <= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
// ROR Label 69
if((j > nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((j >= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}

          
// ABS Label 72
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
// ABS Label 73
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// ROR Label 74
if((j != nCol) != (j == nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
if( j==nCol ) { break;
}
        };
// ABS Label 51
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
// ABS Label 52
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}

// ROR Label 53
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}
// ROR Label 54
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
// ROR Label 55
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}

        
// ABS Label 75
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}
// ABS Label 76
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// ROR Label 77
if((i != nCol) != (i == nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
if( i==nCol ) { break;      /* pIdx is usable */
}
      }
    }
  };
// ABS Label 16
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}


  if( !pIdx ){
    if( !pParse->disableTriggers ){
      
// ABS Label 79
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ABS Label 80
if(pFKey->pFrom->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}

// ABS Label 81
if(pFKey->zTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
sqlite3ErrorMsg(pParse,
           "foreign key mismatch - \"%w\" referencing \"%w\"",
           pFKey->pFrom->zName, pFKey->zTo);
    }
    
// ABS Label 78
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
sqlite3DbFree(pParse->db, aiCol);
    return 1;
  }

  *ppIdx = pIdx;
  return 0;
}

/*
** This function is called when a row is inserted into or deleted from the 
** child table of foreign key constraint pFKey. If an SQL UPDATE is executed 
** on the child table of pFKey, this function is invoked twice for each row
** affected - once to "delete" the old row, and then again to "insert" the
** new row.
**
** Each time it is called, this function generates VDBE code to locate the
** row in the parent table that corresponds to the row being inserted into 
** or deleted from the child table. If the parent row can be found, no 
** special action is taken. Otherwise, if the parent row can *not* be
** found in the parent table:
**
**   Operation | FK type   | Action taken
**   --------------------------------------------------------------------------
**   INSERT      immediate   Increment the "immediate constraint counter".
**
**   DELETE      immediate   Decrement the "immediate constraint counter".
**
**   INSERT      deferred    Increment the "deferred constraint counter".
**
**   DELETE      deferred    Decrement the "deferred constraint counter".
**
** These operations are identified in the comment at the top of this file 
** (fkey.c) as "I.1" and "D.1".
*/
static void fkLookupParent(
  Parse *pParse,        /* Parse context */
  int iDb,              /* Index of database housing pTab */
  Table *pTab,          /* Parent table of FK pFKey */
  Index *pIdx,          /* Unique index on parent key columns in pTab */
  FKey *pFKey,          /* Foreign key constraint */
  int *aiCol,           /* Map from parent key columns to child table columns */
  int regData,          /* Address of array containing child table row */
  int nIncr,            /* Increment constraint counter by this */
  int isIgnore          /* If true, pretend pTab contains all NULL values */
){
  int i;                                    /* Iterator variable */
  Vdbe *v = sqlite3GetVdbe(pParse);         /* Vdbe to add code to */
  
// ABS Label 82
if(pParse->nTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}

// AOR Label 83
if(pParse->nTab / 1 != pParse->nTab - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 83);
}
// AOR Label 84
if(pParse->nTab + 1 != pParse->nTab - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 84);
}
// AOR Label 85
if(pParse->nTab * 1 != pParse->nTab - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 85);
}
int iCur = pParse->nTab - 1;              /* Cursor number to use */
  int iOk = sqlite3VdbeMakeLabel(pParse);   /* jump here if parent key found */

  sqlite3VdbeVerifyAbortable(v,
    (!pFKey->isDeferred
      && !(pParse->db->flags & SQLITE_DeferFKs)
      && !pParse->pToplevel 
      && !pParse->isMultiWrite) ? OE_Abort : OE_Ignore);

  /* If nIncr is less than zero, then check at runtime if there are any
  ** outstanding constraints to resolve. If there are not, there is no need
  ** to check if deleting this row resolves any outstanding violations.
  **
  ** Check if any of the key columns in the child table row are NULL. If 
  ** any are, then the constraint is considered satisfied. No need to 
  ** search for a matching row in the parent table.  */
  
// ABS Label 90
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ROR Label 91
if((nIncr <= 0) != (nIncr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((nIncr > 0) != (nIncr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((nIncr >= 0) != (nIncr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
if( nIncr<0 ){
    
// ABS Label 94
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// ABS Label 95
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}
sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, iOk);
    VdbeCoverage(v);
  }
  i = 0;

// ABS Label 96
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}
// ABS Label 97
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// ROR Label 98
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
// ROR Label 99
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
// ROR Label 100
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}
for(; i<pFKey->nCol; i++){
    int iReg = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i]) + regData + 1;
    
// ABS Label 106
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// ABS Label 107
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}

// ABS Label 108
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iOk); VdbeCoverage(v);
  };
// ABS Label 101
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
// ABS Label 102
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}

// ROR Label 103
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 103);
}
// ROR Label 104
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
// ROR Label 105
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}


  
// ABS Label 109
if(isIgnore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}

// ROR Label 110
if((isIgnore != 0) != (isIgnore == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
if( isIgnore==0 ){
    
// ABS Label 111
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}

// ROR Label 112
if((pIdx != 0) != (pIdx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 112);
}
if( pIdx==0 ){
      /* If pIdx is NULL, then the parent key is the INTEGER PRIMARY KEY
      ** column of the parent table (table pTab).  */
      int iMustBeInt;               /* Address of MustBeInt instruction */
      int regTemp = sqlite3GetTempReg(pParse);
  
      /* Invoke MustBeInt to coerce the child key value to an integer (i.e. 
      ** apply the affinity of the parent key). If this fails, then there
      ** is no matching parent key. Before using MustBeInt, make a copy of
      ** the value. Otherwise, the value inserted into the child key column
      ** will have INTEGER affinity applied to it, which may not be correct.  */
      
// ABS Label 113
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}

// ABS Label 114
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
sqlite3VdbeAddOp2(v, OP_SCopy, 
        sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[0])+1+regData, regTemp);
      iMustBeInt = sqlite3VdbeAddOp2(v, OP_MustBeInt, regTemp, 0);
      VdbeCoverage(v);
  
      /* If the parent table is the same as the child table, and we are about
      ** to increment the constraint-counter (i.e. this is an INSERT operation),
      ** then check if the row being inserted matches itself. If so, do not
      ** increment the constraint-counter.  */
      
// ABS Label 129
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}
// ABS Label 130
if(pFKey->pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}
// ABS Label 131
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}

// COR Label 132
if((pTab == pFKey->pFrom || nIncr == 1) != (pTab == pFKey->pFrom && nIncr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 132);
}

// ROR Label 133
if((pTab != pFKey->pFrom) != (pTab == pFKey->pFrom))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
// ROR Label 134
if((nIncr != 1) != (nIncr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}

// MCC Label 135
if(pTab == pFKey->pFrom && nIncr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
// MCC Label 136
if(pTab == pFKey->pFrom && !(nIncr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 136);
}
// MCC Label 137
if(!(pTab == pFKey->pFrom) && nIncr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
// MCC Label 138
if(!(pTab == pFKey->pFrom) && !(nIncr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
if( pTab==pFKey->pFrom && nIncr==1 ){
        
// ABS Label 139
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}

// ABS Label 140
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ABS Label 141
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ABS Label 142
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
sqlite3VdbeAddOp3(v, OP_Eq, regData, iOk, regTemp); VdbeCoverage(v);
        
// ABS Label 143
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);
      }
  
      
// ABS Label 115
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// ABS Label 116
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ABS Label 117
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// ABS Label 118
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}
sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenRead);
      
// ABS Label 119
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}

// ABS Label 120
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// ABS Label 121
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}
sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regTemp); VdbeCoverage(v);
      
// ABS Label 122
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// ABS Label 123
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}
sqlite3VdbeGoto(v, iOk);
      
// ABS Label 124
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}
sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      
// ABS Label 125
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}

// ABS Label 126
if(iMustBeInt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}
sqlite3VdbeJumpHere(v, iMustBeInt);
      
// ABS Label 127
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}

// ABS Label 128
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}
sqlite3ReleaseTempReg(pParse, regTemp);
    }else{
      
// ABS Label 144
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}
int nCol = pFKey->nCol;
      int regTemp = sqlite3GetTempRange(pParse, nCol);
      int regRec = sqlite3GetTempReg(pParse);
  
      
// ABS Label 145
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}

// ABS Label 146
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ABS Label 147
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
sqlite3VdbeAddOp3(v, OP_OpenRead, iCur, pIdx->tnum, iDb);
      
// ABS Label 148
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}

// ABS Label 149
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      i = 0;

// ABS Label 164
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}
// ABS Label 165
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}

// ROR Label 166
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
for(; i<nCol; i++){
        
// ABS Label 174
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ABS Label 175
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}
// ABS Label 176
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// AOR Label 177
if(regTemp - i != regTemp + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 177);
}
// AOR Label 178
if(regTemp / i != regTemp + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 178);
}
// AOR Label 179
if(regTemp * i != regTemp + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 179);
}
sqlite3VdbeAddOp2(v, OP_Copy, 
               sqlite3TableColumnToStorage(pFKey->pFrom, aiCol[i])+1+regData,
               regTemp+i);
      };
// ABS Label 169
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
// ABS Label 170
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// ROR Label 171
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 171);
}
// ROR Label 172
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 172);
}
// ROR Label 173
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}

  
      /* If the parent table is the same as the child table, and we are about
      ** to increment the constraint-counter (i.e. this is an INSERT operation),
      ** then check if the row being inserted matches itself. If so, do not
      ** increment the constraint-counter. 
      **
      ** If any of the parent-key values are NULL, then the row cannot match 
      ** itself. So set JUMPIFNULL to make sure we do the OP_Found if any
      ** of the parent-key values are NULL (at this point it is known that
      ** none of the child key values are).
      */
      
// ABS Label 180
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
// ABS Label 181
if(pFKey->pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
// ABS Label 182
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}

// COR Label 183
if((pTab == pFKey->pFrom || nIncr == 1) != (pTab == pFKey->pFrom && nIncr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 183);
}

// ROR Label 184
if((pTab != pFKey->pFrom) != (pTab == pFKey->pFrom))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
// ROR Label 185
if((nIncr != 1) != (nIncr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}

// MCC Label 186
if(pTab == pFKey->pFrom && nIncr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 186);
}
// MCC Label 187
if(pTab == pFKey->pFrom && !(nIncr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}
// MCC Label 188
if(!(pTab == pFKey->pFrom) && nIncr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 188);
}
// MCC Label 189
if(!(pTab == pFKey->pFrom) && !(nIncr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 189);
}
if( pTab==pFKey->pFrom && nIncr==1 ){
        int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;
        i = 0;

// ABS Label 192
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
// ABS Label 193
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}

// ROR Label 194
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
// ROR Label 195
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}
// ROR Label 196
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}
for(; i<nCol; i++){
          int iChild = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i])
                              +1+regData;
          
// ABS Label 202
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}

// AOR Label 203
if(1 - regData != 1 + regData)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 203);
}
// AOR Label 204
if(1 / regData != 1 + regData)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 204);
}
// AOR Label 205
if(1 * regData != 1 + regData)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 205);
}
int iParent = 1+regData;
          iParent += sqlite3TableColumnToStorage(pIdx->pTable,
                                                 pIdx->aiColumn[i]);
          assert( pIdx->aiColumn[i]>=0 );
          assert( aiCol[i]!=pTab->iPKey );
          
// ROR Label 211
if((pIdx->aiColumn[i] != pTab->iPKey) != (pIdx->aiColumn[i] == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
if( pIdx->aiColumn[i]==pTab->iPKey ){
            /* The parent key is a composite key that includes the IPK column */
            iParent = regData;
          }
          
// ABS Label 206
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}

// ABS Label 207
if(iChild < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ABS Label 208
if(iJump < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 208);
}

// ABS Label 209
if(iParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 209);
}
sqlite3VdbeAddOp3(v, OP_Ne, iChild, iJump, iParent); VdbeCoverage(v);
          
// ABS Label 210
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 210);
}
sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);
        };
// ABS Label 197
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
// ABS Label 198
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}

// ROR Label 199
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
// ROR Label 200
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
// ROR Label 201
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}

        
// ABS Label 190
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}

// ABS Label 191
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
sqlite3VdbeGoto(v, iOk);
      }
  
      
// ABS Label 150
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ABS Label 151
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// ABS Label 152
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// ABS Label 153
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ABS Label 154
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, regTemp, nCol, regRec,
                        sqlite3IndexAffinityStr(pParse->db,pIdx), nCol);
      
// ABS Label 155
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}

// ABS Label 156
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}

// ABS Label 157
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ABS Label 158
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}
sqlite3VdbeAddOp4Int(v, OP_Found, iCur, iOk, regRec, 0); VdbeCoverage(v);
  
      
// ABS Label 159
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}

// ABS Label 160
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
sqlite3ReleaseTempReg(pParse, regRec);
      
// ABS Label 161
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}

// ABS Label 162
if(regTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}

// ABS Label 163
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}
sqlite3ReleaseTempRange(pParse, regTemp, nCol);
    }
  }

  
// COR Label 212
if((!pFKey->isDeferred && !(pParse->db->flags & 524288) && !pParse->pToplevel || !pParse->isMultiWrite) != (!pFKey->isDeferred && !(pParse->db->flags & 524288) && !pParse->pToplevel && !pParse->isMultiWrite))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 212);
}
// COR Label 213
if((!pFKey->isDeferred && !(pParse->db->flags & 524288) || !pParse->pToplevel) != (!pFKey->isDeferred && !(pParse->db->flags & 524288) && !pParse->pToplevel))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 213);
}
// COR Label 214
if((!pFKey->isDeferred || !(pParse->db->flags & 524288)) != (!pFKey->isDeferred && !(pParse->db->flags & 524288)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 214);
}

// MCC Label 215
if(!pFKey->isDeferred && !(pParse->db->flags & 524288) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(!pFKey->isDeferred && !(pParse->db->flags & 524288) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(!pFKey->isDeferred && !(pParse->db->flags & 524288) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(!pFKey->isDeferred && !(pParse->db->flags & 524288) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
// MCC Label 219
if(!pFKey->isDeferred && !(!(pParse->db->flags & 524288)) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(!pFKey->isDeferred && !(!(pParse->db->flags & 524288)) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(!pFKey->isDeferred && !(!(pParse->db->flags & 524288)) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
// MCC Label 222
if(!pFKey->isDeferred && !(!(pParse->db->flags & 524288)) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
// MCC Label 223
if(!(!pFKey->isDeferred) && !(pParse->db->flags & 524288) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(!(!pFKey->isDeferred) && !(pParse->db->flags & 524288) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(!(!pFKey->isDeferred) && !(pParse->db->flags & 524288) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(!(!pFKey->isDeferred) && !(pParse->db->flags & 524288) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(!(!pFKey->isDeferred) && !(!(pParse->db->flags & 524288)) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(!(!pFKey->isDeferred) && !(!(pParse->db->flags & 524288)) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(!(!pFKey->isDeferred) && !(!(pParse->db->flags & 524288)) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(!(!pFKey->isDeferred) && !(!(pParse->db->flags & 524288)) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
if( !pFKey->isDeferred && !(pParse->db->flags & SQLITE_DeferFKs)
   && !pParse->pToplevel 
   && !pParse->isMultiWrite 
  ){
    /* Special case: If this is an INSERT statement that will insert exactly
    ** one row into the table, raise a constraint immediately instead of
    ** incrementing a counter. This is necessary as the VM code is being
    ** generated for will not open a statement transaction.  */
    assert( nIncr==1 );
    
// ABS Label 231
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}
sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,
        OE_Abort, 0, P4_STATIC, P5_ConstraintFK);
  }else{
    
// ABS Label 234
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}

// COR Label 235
if((nIncr > 0 || pFKey->isDeferred == 0) != (nIncr > 0 && pFKey->isDeferred == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 235);
}

// ROR Label 236
if((nIncr <= 0) != (nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
// ROR Label 237
if((nIncr < 0) != (nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
// ROR Label 238
if((nIncr >= 0) != (nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
// ROR Label 239
if((pFKey->isDeferred != 0) != (pFKey->isDeferred == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 239);
}

// MCC Label 240
if(nIncr > 0 && pFKey->isDeferred == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(nIncr > 0 && !(pFKey->isDeferred == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}
// MCC Label 242
if(!(nIncr > 0) && pFKey->isDeferred == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 242);
}
// MCC Label 243
if(!(nIncr > 0) && !(pFKey->isDeferred == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 243);
}
if( nIncr>0 && pFKey->isDeferred==0 ){
      
// ABS Label 244
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}
sqlite3MayAbort(pParse);
    }
    
// ABS Label 232
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}

// ABS Label 233
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}
sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);
  }

  
// ABS Label 86
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// ABS Label 87
if(iOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
sqlite3VdbeResolveLabel(v, iOk);
  
// ABS Label 88
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// ABS Label 89
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
sqlite3VdbeAddOp1(v, OP_Close, iCur);
}


/*
** Return an Expr object that refers to a memory register corresponding
** to column iCol of table pTab.
**
** regBase is the first of an array of register that contains the data
** for pTab.  regBase itself holds the rowid.  regBase+1 holds the first
** column.  regBase+2 holds the second column, and so forth.
*/
static Expr *exprTableRegister(
  Parse *pParse,     /* Parsing and code generating context */
  Table *pTab,       /* The table whose content is at r[regBase]... */
  int regBase,       /* Contents of table pTab */
  i16 iCol           /* Which column of pTab is desired */
){
  Expr *pExpr;
  Column *pCol;
  const char *zColl;
  
// ABS Label 245
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}
sqlite3 *db = pParse->db;

  pExpr = sqlite3Expr(db, TK_REGISTER, 0);
  
// ABS Label 246
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}
if( pExpr ){
    
// COR Label 247
if((iCol >= 0 || iCol != pTab->iPKey) != (iCol >= 0 && iCol != pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 247);
}

// ROR Label 248
if((iCol < 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 248);
}
// ROR Label 249
if((iCol > 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 249);
}
// ROR Label 250
if((iCol <= 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((iCol == pTab->iPKey) != (iCol != pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}

// MCC Label 252
if(iCol >= 0 && iCol != pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 252);
}
// MCC Label 253
if(iCol >= 0 && !(iCol != pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 253);
}
// MCC Label 254
if(!(iCol >= 0) && iCol != pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 254);
}
// MCC Label 255
if(!(iCol >= 0) && !(iCol != pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
if( iCol>=0 && iCol!=pTab->iPKey ){
      pCol = &pTab->aCol[iCol];
      pExpr->iTable = regBase + sqlite3TableColumnToStorage(pTab,iCol) + 1;
      pExpr->affExpr = pCol->affinity;
      zColl = pCol->zColl;
      
// ABS Label 256
if(zColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ROR Label 257
if((zColl != 0) != (zColl == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
if( zColl==0 ) { zColl = db->pDfltColl->zName;
}
      pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
    }else{
      pExpr->iTable = regBase;
      pExpr->affExpr = SQLITE_AFF_INTEGER;
    }
  }
  
// ABS Label 258
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}
return pExpr;
}

/*
** Return an Expr object that refers to column iCol of table pTab which
** has cursor iCur.
*/
static Expr *exprTableColumn(
  sqlite3 *db,      /* The database connection */
  Table *pTab,      /* The table whose column is desired */
  int iCursor,      /* The open cursor on the table */
  i16 iCol          /* The column that is wanted */
){
  Expr *pExpr = sqlite3Expr(db, TK_COLUMN, 0);
  
// ABS Label 259
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}
if( pExpr ){
    pExpr->y.pTab = pTab;
    pExpr->iTable = iCursor;
    pExpr->iColumn = iCol;
  }
  
// ABS Label 260
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
return pExpr;
}

/*
** This function is called to generate code executed when a row is deleted
** from the parent table of foreign key constraint pFKey and, if pFKey is 
** deferred, when a row is inserted into the same table. When generating
** code for an SQL UPDATE operation, this function may be called twice -
** once to "delete" the old row and once to "insert" the new row.
**
** Parameter nIncr is passed -1 when inserting a row (as this may decrease
** the number of FK violations in the db) or +1 when deleting one (as this
** may increase the number of FK constraint problems).
**
** The code generated by this function scans through the rows in the child
** table that correspond to the parent table row being deleted or inserted.
** For each child row found, one of the following actions is taken:
**
**   Operation | FK type   | Action taken
**   --------------------------------------------------------------------------
**   DELETE      immediate   Increment the "immediate constraint counter".
**                           Or, if the ON (UPDATE|DELETE) action is RESTRICT,
**                           throw a "FOREIGN KEY constraint failed" exception.
**
**   INSERT      immediate   Decrement the "immediate constraint counter".
**
**   DELETE      deferred    Increment the "deferred constraint counter".
**                           Or, if the ON (UPDATE|DELETE) action is RESTRICT,
**                           throw a "FOREIGN KEY constraint failed" exception.
**
**   INSERT      deferred    Decrement the "deferred constraint counter".
**
** These operations are identified in the comment at the top of this file 
** (fkey.c) as "I.2" and "D.2".
*/
static void fkScanChildren(
  Parse *pParse,                  /* Parse context */
  SrcList *pSrc,                  /* The child table to be scanned */
  Table *pTab,                    /* The parent table */
  Index *pIdx,                    /* Index on parent covering the foreign key */
  FKey *pFKey,                    /* The foreign key linking pSrc to pTab */
  int *aiCol,                     /* Map from pIdx cols to child table cols */
  int regData,                    /* Parent row data starts here */
  int nIncr                       /* Amount to increment deferred counter by */
){
  
// ABS Label 261
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}
sqlite3 *db = pParse->db;       /* Database handle */
  int i;                          /* Iterator variable */
  Expr *pWhere = 0;               /* WHERE clause to scan with */
  NameContext sNameContext;       /* Context used to resolve WHERE clause */
  WhereInfo *pWInfo;              /* Context used by sqlite3WhereXXX() */
  int iFkIfZero = 0;              /* Address of OP_FkIfZero */
  Vdbe *v = sqlite3GetVdbe(pParse);

  assert( pIdx==0 || pIdx->pTable==pTab );
  assert( pIdx==0 || pIdx->nKeyCol==pFKey->nCol );
  assert( pIdx!=0 || pFKey->nCol==1 );
  assert( pIdx!=0 || HasRowid(pTab) );

  
// ABS Label 265
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}

// ROR Label 266
if((nIncr <= 0) != (nIncr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}
// ROR Label 267
if((nIncr > 0) != (nIncr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((nIncr >= 0) != (nIncr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}
if( nIncr<0 ){
    iFkIfZero = sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, 0);
    VdbeCoverage(v);
  }

  /* Create an Expr object representing an SQL expression like:
  **
  **   <parent-key1> = <child-key1> AND <parent-key2> = <child-key2> ...
  **
  ** The collation sequence used for the comparison should be that of
  ** the parent key columns. The affinity of the parent key column should
  ** be applied to each child key value before the comparison takes place.
  */
  i = 0;

// ABS Label 269
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
// ABS Label 270
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}

// ROR Label 271
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 271);
}
// ROR Label 272
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 272);
}
// ROR Label 273
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
for(; i<pFKey->nCol; i++){
    Expr *pLeft;                  /* Value from parent table row */
    Expr *pRight;                 /* Column ref to child table */
    Expr *pEq;                    /* Expression (pLeft = pRight) */
    i16 iCol;                     /* Index of column in child table */ 
    const char *zCol;             /* Name of column in child table */

    iCol = pIdx ? pIdx->aiColumn[i] : -1;
    pLeft = exprTableRegister(pParse, pTab, regData, iCol);
    iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
    assert( iCol>=0 );
    zCol = pFKey->pFrom->aCol[iCol].zName;
    pRight = sqlite3Expr(db, TK_ID, zCol);
    pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight);
    pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
  };
// ABS Label 274
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
// ABS Label 275
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}

// ROR Label 276
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 276);
}
// ROR Label 277
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 277);
}
// ROR Label 278
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 278);
}


  /* If the child table is the same as the parent table, then add terms
  ** to the WHERE clause that prevent this entry from being scanned.
  ** The added WHERE clause terms are like this:
  **
  **     $current_rowid!=rowid
  **     NOT( $current_a==a AND $current_b==b AND ... )
  **
  ** The first form is used for rowid tables.  The second form is used
  ** for WITHOUT ROWID tables. In the second form, the *parent* key is
  ** (a,b,...). Either the parent or primary key could be used to 
  ** uniquely identify the current row, but the parent key is more convenient
  ** as the required values have already been loaded into registers
  ** by the caller.
  */
  
// ABS Label 279
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}
// ABS Label 280
if(pFKey->pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
// ABS Label 281
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// COR Label 282
if((pTab == pFKey->pFrom || nIncr > 0) != (pTab == pFKey->pFrom && nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 282);
}

// ROR Label 283
if((pTab != pFKey->pFrom) != (pTab == pFKey->pFrom))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 283);
}
// ROR Label 284
if((nIncr <= 0) != (nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
// ROR Label 285
if((nIncr < 0) != (nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 285);
}
// ROR Label 286
if((nIncr >= 0) != (nIncr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}

// MCC Label 287
if(pTab == pFKey->pFrom && nIncr > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 287);
}
// MCC Label 288
if(pTab == pFKey->pFrom && !(nIncr > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 288);
}
// MCC Label 289
if(!(pTab == pFKey->pFrom) && nIncr > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 289);
}
// MCC Label 290
if(!(pTab == pFKey->pFrom) && !(nIncr > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 290);
}
if( pTab==pFKey->pFrom && nIncr>0 ){
    Expr *pNe;                    /* Expression (pLeft != pRight) */
    Expr *pLeft;                  /* Value from parent table row */
    Expr *pRight;                 /* Column ref to child table */
    
// MCC Label 291
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 291);
}
// MCC Label 292
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 292);
}
if( HasRowid(pTab) ){
      pLeft = exprTableRegister(pParse, pTab, regData, -1);
      pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);
      pNe = sqlite3PExpr(pParse, TK_NE, pLeft, pRight);
    }else{
      Expr *pEq, *pAll = 0;
      assert( pIdx!=0 );
      i = 0;

// ABS Label 293
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ROR Label 294
if((i <= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}
// ROR Label 295
if((i > pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}
// ROR Label 296
if((i >= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
for(; i<pIdx->nKeyCol; i++){
        
// ABS Label 301
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}
// ABS Label 302
if(pIdx->aiColumn[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
i16 iCol = pIdx->aiColumn[i];
        assert( iCol>=0 );
        pLeft = exprTableRegister(pParse, pTab, regData, iCol);
        pRight = sqlite3Expr(db, TK_ID, pTab->aCol[iCol].zName);
        pEq = sqlite3PExpr(pParse, TK_IS, pLeft, pRight);
        pAll = sqlite3ExprAnd(pParse, pAll, pEq);
      };
// ABS Label 297
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ROR Label 298
if((i <= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
// ROR Label 299
if((i > pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 299);
}
// ROR Label 300
if((i >= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}

      pNe = sqlite3PExpr(pParse, TK_NOT, pAll, 0);
    }
    pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
  }

  /* Resolve the references in the WHERE clause. */
  memset(&sNameContext, 0, sizeof(NameContext));
  sNameContext.pSrcList = pSrc;
  sNameContext.pParse = pParse;
  
// ABS Label 262
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}
sqlite3ResolveExprNames(&sNameContext, pWhere);

  /* Create VDBE to loop through the entries in pSrc that match the WHERE
  ** clause. For each row found, increment either the deferred or immediate
  ** foreign key constraint counter. */
  
// ABS Label 303
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ROR Label 304
if((pParse->nErr != 0) != (pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
if( pParse->nErr==0 ){
    pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0);
    
// ABS Label 305
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}

// ABS Label 306
if(nIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);
    
// ABS Label 307
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
if( pWInfo ){
      
// ABS Label 308
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}
sqlite3WhereEnd(pWInfo);
    }
  }

  /* Clean up the WHERE clause constructed above. */
  
// ABS Label 263
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}

// ABS Label 264
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
sqlite3ExprDelete(db, pWhere);
  
// ABS Label 309
if(iFkIfZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}
if( iFkIfZero ){
    
// ABS Label 310
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}

// ABS Label 311
if(iFkIfZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
sqlite3VdbeJumpHereOrPopInst(v, iFkIfZero);
  }
}

/*
** This function returns a linked list of FKey objects (connected by
** FKey.pNextTo) holding all children of table pTab.  For example,
** given the following schema:
**
**   CREATE TABLE t1(a PRIMARY KEY);
**   CREATE TABLE t2(b REFERENCES t1(a);
**
** Calling this function with table "t1" as an argument returns a pointer
** to the FKey structure representing the foreign key constraint on table
** "t2". Calling this function with "t2" as the argument would return a
** NULL pointer (as there are no FK constraints for which t2 is the parent
** table).
*/
FKey *sqlite3FkReferences(Table *pTab){
  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName);
}

/*
** The second argument is a Trigger structure allocated by the 
** fkActionTrigger() routine. This function deletes the Trigger structure
** and all of its sub-components.
**
** The Trigger structure or any of its sub-components may be allocated from
** the lookaside buffer belonging to database handle dbMem.
*/
static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){
  
// ABS Label 312
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
if( p ){
    
// ABS Label 313
if(p->step_list < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
TriggerStep *pStep = p->step_list;
    
// ABS Label 314
if(dbMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}

// ABS Label 315
if(pStep->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
sqlite3ExprDelete(dbMem, pStep->pWhere);
    
// ABS Label 316
if(dbMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}

// ABS Label 317
if(pStep->pExprList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
sqlite3ExprListDelete(dbMem, pStep->pExprList);
    
// ABS Label 318
if(dbMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}

// ABS Label 319
if(pStep->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
sqlite3SelectDelete(dbMem, pStep->pSelect);
    
// ABS Label 320
if(dbMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}

// ABS Label 321
if(p->pWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
sqlite3ExprDelete(dbMem, p->pWhen);
    
// ABS Label 322
if(dbMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
sqlite3DbFree(dbMem, p);
  }
}

/*
** This function is called to generate code that runs when table pTab is
** being dropped from the database. The SrcList passed as the second argument
** to this function contains a single entry guaranteed to resolve to
** table pTab.
**
** Normally, no code is required. However, if either
**
**   (a) The table is the parent table of a FK constraint, or
**   (b) The table is the child table of a deferred FK constraint and it is
**       determined at runtime that there are outstanding deferred FK 
**       constraint violations in the database,
**
** then the equivalent of "DELETE FROM <tbl>" is executed before dropping
** the table from the database. Triggers are disabled while running this
** DELETE, but foreign key actions are not.
*/
void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){
  
// ABS Label 323
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
sqlite3 *db = pParse->db;
  
// COR Label 324
if(((db->flags & 16384) || !((pTab)->nModuleArg)) != ((db->flags & 16384) && !((pTab)->nModuleArg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 324);
}

// MCC Label 325
if(( db->flags & 16384 ) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 325);
}
// MCC Label 326
if(( db->flags & 16384 ) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 326);
}
// MCC Label 327
if(( !(db->flags & 16384) ) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 327);
}
// MCC Label 328
if(( !(db->flags & 16384) ) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 328);
}
if( (db->flags&SQLITE_ForeignKeys) && !IsVirtual(pTab) ){
    int iSkip = 0;
    Vdbe *v = sqlite3GetVdbe(pParse);

    assert( v );                  /* VDBE has already been allocated */
    assert( pTab->pSelect==0 );   /* Not a view */
    if( sqlite3FkReferences(pTab)==0 ){
      /* Search for a deferred foreign key constraint for which this table
      ** is the child table. If one cannot be found, return without 
      ** generating any VDBE code. If one can be found, then jump over
      ** the entire DELETE if there are no outstanding deferred constraints
      ** when this statement is run.  */
      FKey *p;
      p = pTab->pFKey;

// ABS Label 332
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}
for(; p; p=p->pNextFrom){
        
// COR Label 334
if((p->isDeferred && (db->flags & 524288)) != (p->isDeferred || (db->flags & 524288)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 334);
}

// MCC Label 335
if(p->isDeferred && ( db->flags & 524288 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 335);
}
// MCC Label 336
if(p->isDeferred && ( !(db->flags & 524288) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 336);
}
// MCC Label 337
if(!(p->isDeferred) && ( db->flags & 524288 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 337);
}
// MCC Label 338
if(!(p->isDeferred) && ( !(db->flags & 524288) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 338);
}
if( p->isDeferred || (db->flags & SQLITE_DeferFKs) ) { break;
}
      };
// ABS Label 333
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}

      if( !p ) { return;
}
      iSkip = sqlite3VdbeMakeLabel(pParse);
      
// ABS Label 330
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ABS Label 331
if(iSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
sqlite3VdbeAddOp2(v, OP_FkIfZero, 1, iSkip); VdbeCoverage(v);
    }

    pParse->disableTriggers = 1;
    
// ABS Label 329
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0, 0, 0);
    pParse->disableTriggers = 0;

    /* If the DELETE has generated immediate foreign key constraint 
    ** violations, halt the VDBE and return an error at this point, before
    ** any modifications to the schema are made. This is because statement
    ** transactions are not able to rollback schema changes.  
    **
    ** If the SQLITE_DeferFKs flag is set, then this is not required, as
    ** the statement transaction will not be rolled back even if FK
    ** constraints are violated.
    */
    
// ROR Label 339
if(((db->flags & 524288) != 0) != ((db->flags & 524288) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
if( (db->flags & SQLITE_DeferFKs)==0 ){
      sqlite3VdbeVerifyAbortable(v, OE_Abort);
      
// ABS Label 340
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}
sqlite3VdbeAddOp2(v, OP_FkIfZero, 0, sqlite3VdbeCurrentAddr(v)+2);
      VdbeCoverage(v);
      
// ABS Label 341
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,
          OE_Abort, 0, P4_STATIC, P5_ConstraintFK);
    }

    
// ABS Label 342
if(iSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}
if( iSkip ){
      
// ABS Label 343
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}

// ABS Label 344
if(iSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
sqlite3VdbeResolveLabel(v, iSkip);
    }
  }
}


/*
** The second argument points to an FKey object representing a foreign key
** for which pTab is the child table. An UPDATE statement against pTab
** is currently being processed. For each column of the table that is 
** actually updated, the corresponding element in the aChange[] array
** is zero or greater (if a column is unmodified the corresponding element
** is set to -1). If the rowid column is modified by the UPDATE statement
** the bChngRowid argument is non-zero.
**
** This function returns true if any of the columns that are part of the
** child key for FK constraint *p are modified.
*/
static int fkChildIsModified(
  Table *pTab,                    /* Table being updated */
  FKey *p,                        /* Foreign key for which pTab is the child */
  int *aChange,                   /* Array indicating modified columns */
  int bChngRowid                  /* True if rowid is modified by this update */
){
  int i;
  i = 0;

// ABS Label 345
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}
// ABS Label 346
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}

// ROR Label 347
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 347);
}
// ROR Label 348
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 348);
}
// ROR Label 349
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 349);
}
for(; i<p->nCol; i++){
    
// ABS Label 355
if(p->aCol[i].iFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
int iChildKey = p->aCol[i].iFrom;
    
// ABS Label 356
if(aChange[iChildKey] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}
// ABS Label 357
if(iChildKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}

// ROR Label 358
if((aChange[iChildKey] < 0) != (aChange[iChildKey] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}
// ROR Label 359
if((aChange[iChildKey] > 0) != (aChange[iChildKey] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}
// ROR Label 360
if((aChange[iChildKey] <= 0) != (aChange[iChildKey] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 360);
}
if( aChange[iChildKey]>=0 ) { return 1;
}
    
// ABS Label 361
if(bChngRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}
// ABS Label 362
if(iChildKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}

// COR Label 363
if((iChildKey == pTab->iPKey || bChngRowid) != (iChildKey == pTab->iPKey && bChngRowid))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 363);
}

// ROR Label 364
if((iChildKey != pTab->iPKey) != (iChildKey == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}

// MCC Label 365
if(iChildKey == pTab->iPKey && bChngRowid ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 365);
}
// MCC Label 366
if(iChildKey == pTab->iPKey && !(bChngRowid) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 366);
}
// MCC Label 367
if(!(iChildKey == pTab->iPKey) && bChngRowid ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 367);
}
// MCC Label 368
if(!(iChildKey == pTab->iPKey) && !(bChngRowid) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
if( iChildKey==pTab->iPKey && bChngRowid ) { return 1;
}
  };
// ABS Label 350
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
// ABS Label 351
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}

// ROR Label 352
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 352);
}
// ROR Label 353
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 353);
}
// ROR Label 354
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}

  return 0;
}

/*
** The second argument points to an FKey object representing a foreign key
** for which pTab is the parent table. An UPDATE statement against pTab
** is currently being processed. For each column of the table that is 
** actually updated, the corresponding element in the aChange[] array
** is zero or greater (if a column is unmodified the corresponding element
** is set to -1). If the rowid column is modified by the UPDATE statement
** the bChngRowid argument is non-zero.
**
** This function returns true if any of the columns that are part of the
** parent key for FK constraint *p are modified.
*/
static int fkParentIsModified(
  Table *pTab, 
  FKey *p, 
  int *aChange, 
  int bChngRowid
){
  int i;
  i = 0;

// ABS Label 369
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
// ABS Label 370
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}

// ROR Label 371
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 371);
}
// ROR Label 372
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 372);
}
// ROR Label 373
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 373);
}
for(; i<p->nCol; i++){
    
// ABS Label 379
if(p->aCol[i].zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}
char *zKey = p->aCol[i].zCol;
    int iKey;
    iKey = 0;

// ABS Label 380
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}

// ROR Label 381
if((iKey <= pTab->nCol) != (iKey < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 381);
}
// ROR Label 382
if((iKey > pTab->nCol) != (iKey < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 382);
}
// ROR Label 383
if((iKey >= pTab->nCol) != (iKey < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 383);
}
for(; iKey<pTab->nCol; iKey++){
      
// ABS Label 388
if(aChange[iKey] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
// ABS Label 389
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}

// COR Label 390
if((aChange[iKey] >= 0 && (iKey == pTab->iPKey && bChngRowid)) != (aChange[iKey] >= 0 || (iKey == pTab->iPKey && bChngRowid)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 390);
}

// ROR Label 391
if((aChange[iKey] < 0) != (aChange[iKey] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}
// ROR Label 392
if((aChange[iKey] > 0) != (aChange[iKey] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 392);
}
// ROR Label 393
if((aChange[iKey] <= 0) != (aChange[iKey] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 393);
}

// MCC Label 394
if(aChange[iKey] >= 0 && ( iKey == pTab->iPKey && bChngRowid ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(aChange[iKey] >= 0 && ( iKey == pTab->iPKey && !(bChngRowid) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(aChange[iKey] >= 0 && ( !(iKey == pTab->iPKey) && bChngRowid ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
// MCC Label 397
if(aChange[iKey] >= 0 && ( !(iKey == pTab->iPKey) && !(bChngRowid) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 397);
}
// MCC Label 398
if(!(aChange[iKey] >= 0) && ( iKey == pTab->iPKey && bChngRowid ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 398);
}
// MCC Label 399
if(!(aChange[iKey] >= 0) && ( iKey == pTab->iPKey && !(bChngRowid) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 399);
}
// MCC Label 400
if(!(aChange[iKey] >= 0) && ( !(iKey == pTab->iPKey) && bChngRowid ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 400);
}
// MCC Label 401
if(!(aChange[iKey] >= 0) && ( !(iKey == pTab->iPKey) && !(bChngRowid) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 401);
}
if( aChange[iKey]>=0 || (iKey==pTab->iPKey && bChngRowid) ){
        Column *pCol = &pTab->aCol[iKey];
        
// ABS Label 402
if(zKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}
if( zKey ){
          if( 0==sqlite3StrICmp(pCol->zName, zKey) ) { return 1;
}
        }else { 
// AOR Label 403
if(pCol->colFlags | 1 != pCol->colFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 403);
}
// AOR Label 404
if(pCol->colFlags ^ 1 != pCol->colFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 404);
}
if( pCol->colFlags & COLFLAG_PRIMKEY ){
          return 1;
        };}

      }
    };
// ABS Label 384
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}

// ROR Label 385
if((iKey <= pTab->nCol) != (iKey < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 385);
}
// ROR Label 386
if((iKey > pTab->nCol) != (iKey < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
// ROR Label 387
if((iKey >= pTab->nCol) != (iKey < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 387);
}

  };
// ABS Label 374
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
// ABS Label 375
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}

// ROR Label 376
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}

  return 0;
}

/*
** Return true if the parser passed as the first argument is being
** used to code a trigger that is really a "SET NULL" action belonging
** to trigger pFKey.
*/
static int isSetNullAction(Parse *pParse, FKey *pFKey){
  Parse *pTop = sqlite3ParseToplevel(pParse);
  
// ABS Label 405
if(pTop->pTriggerPrg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}
if( pTop->pTriggerPrg ){
    
// ABS Label 406
if(pTop->pTriggerPrg->pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
Trigger *p = pTop->pTriggerPrg->pTrigger;
    
// COR Label 407
if(((p == pFKey->apTrigger[0] && pFKey->aAction[0] == 8) && (p == pFKey->apTrigger[1] && pFKey->aAction[1] == 8)) != ((p == pFKey->apTrigger[0] && pFKey->aAction[0] == 8) || (p == pFKey->apTrigger[1] && pFKey->aAction[1] == 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 407);
}

// MCC Label 408
if(( p == pFKey->apTrigger[0] && pFKey->aAction[0] == 8 ) && ( p == pFKey->apTrigger[1] && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 408);
}
// MCC Label 409
if(( p == pFKey->apTrigger[0] && pFKey->aAction[0] == 8 ) && ( p == pFKey->apTrigger[1] && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 409);
}
// MCC Label 410
if(( p == pFKey->apTrigger[0] && pFKey->aAction[0] == 8 ) && ( !(p == pFKey->apTrigger[1]) && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 410);
}
// MCC Label 411
if(( p == pFKey->apTrigger[0] && pFKey->aAction[0] == 8 ) && ( !(p == pFKey->apTrigger[1]) && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
// MCC Label 412
if(( p == pFKey->apTrigger[0] && !(pFKey->aAction[0] == 8) ) && ( p == pFKey->apTrigger[1] && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
// MCC Label 413
if(( p == pFKey->apTrigger[0] && !(pFKey->aAction[0] == 8) ) && ( p == pFKey->apTrigger[1] && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 413);
}
// MCC Label 414
if(( p == pFKey->apTrigger[0] && !(pFKey->aAction[0] == 8) ) && ( !(p == pFKey->apTrigger[1]) && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 414);
}
// MCC Label 415
if(( p == pFKey->apTrigger[0] && !(pFKey->aAction[0] == 8) ) && ( !(p == pFKey->apTrigger[1]) && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 415);
}
// MCC Label 416
if(( !(p == pFKey->apTrigger[0]) && pFKey->aAction[0] == 8 ) && ( p == pFKey->apTrigger[1] && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 416);
}
// MCC Label 417
if(( !(p == pFKey->apTrigger[0]) && pFKey->aAction[0] == 8 ) && ( p == pFKey->apTrigger[1] && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 417);
}
// MCC Label 418
if(( !(p == pFKey->apTrigger[0]) && pFKey->aAction[0] == 8 ) && ( !(p == pFKey->apTrigger[1]) && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 418);
}
// MCC Label 419
if(( !(p == pFKey->apTrigger[0]) && pFKey->aAction[0] == 8 ) && ( !(p == pFKey->apTrigger[1]) && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 419);
}
// MCC Label 420
if(( !(p == pFKey->apTrigger[0]) && !(pFKey->aAction[0] == 8) ) && ( p == pFKey->apTrigger[1] && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 420);
}
// MCC Label 421
if(( !(p == pFKey->apTrigger[0]) && !(pFKey->aAction[0] == 8) ) && ( p == pFKey->apTrigger[1] && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 421);
}
// MCC Label 422
if(( !(p == pFKey->apTrigger[0]) && !(pFKey->aAction[0] == 8) ) && ( !(p == pFKey->apTrigger[1]) && pFKey->aAction[1] == 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 422);
}
// MCC Label 423
if(( !(p == pFKey->apTrigger[0]) && !(pFKey->aAction[0] == 8) ) && ( !(p == pFKey->apTrigger[1]) && !(pFKey->aAction[1] == 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 423);
}
if( (p==pFKey->apTrigger[0] && pFKey->aAction[0]==OE_SetNull)
     || (p==pFKey->apTrigger[1] && pFKey->aAction[1]==OE_SetNull)
    ){
      return 1;
    }
  }
  return 0;
}

/*
** This function is called when inserting, deleting or updating a row of
** table pTab to generate VDBE code to perform foreign key constraint 
** processing for the operation.
**
** For a DELETE operation, parameter regOld is passed the index of the
** first register in an array of (pTab->nCol+1) registers containing the
** rowid of the row being deleted, followed by each of the column values
** of the row being deleted, from left to right. Parameter regNew is passed
** zero in this case.
**
** For an INSERT operation, regOld is passed zero and regNew is passed the
** first register of an array of (pTab->nCol+1) registers containing the new
** row data.
**
** For an UPDATE operation, this function is called twice. Once before
** the original record is deleted from the table using the calling convention
** described for DELETE. Then again after the original record is deleted
** but before the new record is inserted using the INSERT convention. 
*/
void sqlite3FkCheck(
  Parse *pParse,                  /* Parse context */
  Table *pTab,                    /* Row is being deleted from this table */ 
  int regOld,                     /* Previous row data is stored here */
  int regNew,                     /* New row data is stored here */
  int *aChange,                   /* Array indicating UPDATEd columns (or 0) */
  int bChngRowid                  /* True if rowid is UPDATEd */
){
  
// ABS Label 424
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}
sqlite3 *db = pParse->db;       /* Database handle */
  FKey *pFKey;                    /* Used to iterate through FKs */
  int iDb;                        /* Index of database containing pTab */
  const char *zDb;                /* Name of database containing pTab */
  int isIgnoreErrors = pParse->disableTriggers;

  /* Exactly one of regOld and regNew should be non-zero. */
  assert( (regOld==0)!=(regNew==0) );

  /* If foreign-keys are disabled, this function is a no-op. */
  
// ROR Label 425
if(((db->flags & 16384) != 0) != ((db->flags & 16384) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
if( (db->flags&SQLITE_ForeignKeys)==0 ) { return;
}

  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  zDb = db->aDb[iDb].zDbSName;

  /* Loop through all the foreign key constraints for which pTab is the
  ** child table (the table that the foreign key definition is part of).  */
  pFKey = pTab->pFKey;

// ABS Label 426
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}
for(; pFKey; pFKey=pFKey->pNextFrom){
    Table *pTo;                   /* Parent table of foreign key pFKey */
    Index *pIdx = 0;              /* Index on key columns in pTo */
    int *aiFree = 0;
    int *aiCol;
    int iCol;
    int i;
    int bIgnore = 0;

    if( aChange 
     && sqlite3_stricmp(pTab->zName, pFKey->zTo)!=0
     && fkChildIsModified(pTab, pFKey, aChange, bChngRowid)==0 
    ){
      continue;
    }

    /* Find the parent table of this foreign key. Also find a unique index 
    ** on the parent key columns in the parent table. If either of these 
    ** schema items cannot be located, set an error in pParse and return 
    ** early.  */
    
// ABS Label 432
if(pParse->disableTriggers < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}
if( pParse->disableTriggers ){
      pTo = sqlite3FindTable(db, pFKey->zTo, zDb);
    }else{
      pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);
    }
    if( !pTo || sqlite3FkLocateIndex(pParse, pTo, pFKey, &pIdx, &aiFree) ){
      assert( isIgnoreErrors==0 || (regOld!=0 && regNew==0) );
      
// COR Label 433
if((!isIgnoreErrors && db->mallocFailed) != (!isIgnoreErrors || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 433);
}

// MCC Label 434
if(!isIgnoreErrors && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 434);
}
// MCC Label 435
if(!isIgnoreErrors && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 435);
}
// MCC Label 436
if(!(!isIgnoreErrors) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 436);
}
// MCC Label 437
if(!(!isIgnoreErrors) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 437);
}
if( !isIgnoreErrors || db->mallocFailed ) { return;
}
      
// ABS Label 438
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}

// ROR Label 439
if((pTo != 0) != (pTo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 439);
}
if( pTo==0 ){
        /* If isIgnoreErrors is true, then a table is being dropped. In this
        ** case SQLite runs a "DELETE FROM xxx" on the table being dropped
        ** before actually dropping it in order to check FK constraints.
        ** If the parent table of an FK constraint on the current table is
        ** missing, behave as if it is empty. i.e. decrement the relevant
        ** FK counter for each row of the current table with non-NULL keys.
        */
        Vdbe *v = sqlite3GetVdbe(pParse);
        int iJump = sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1;
        i = 0;

// ABS Label 441
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 441);
}
// ABS Label 442
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}

// ROR Label 443
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 443);
}
// ROR Label 444
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 444);
}
// ROR Label 445
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 445);
}
for(; i<pFKey->nCol; i++){
          int iFromCol, iReg;
          iFromCol = pFKey->aCol[i].iFrom;
          iReg = sqlite3TableColumnToStorage(pFKey->pFrom,iFromCol) + regOld+1;
          
// ABS Label 451
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 451);
}

// ABS Label 452
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}

// ABS Label 453
if(iJump < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iJump); VdbeCoverage(v);
        };
// ABS Label 446
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 446);
}
// ABS Label 447
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 447);
}

// ROR Label 448
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
// ROR Label 449
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 449);
}
// ROR Label 450
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 450);
}

        
// ABS Label 440
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 440);
}
sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, -1);
      }
      continue;
    }
    assert( pFKey->nCol==1 || (aiFree && pIdx) );

    
// ABS Label 454
if(aiFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}
if( aiFree ){
      aiCol = aiFree;
    }else{
      iCol = pFKey->aCol[0].iFrom;
      aiCol = &iCol;
    }
    i = 0;

// ABS Label 455
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}
// ABS Label 456
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}

// ROR Label 457
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 457);
}
// ROR Label 458
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 458);
}
// ROR Label 459
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 459);
}
for(; i<pFKey->nCol; i++){
      
// ABS Label 465
if(aiCol[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 465);
}
// ABS Label 466
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}

// ROR Label 467
if((aiCol[i] != pTab->iPKey) != (aiCol[i] == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 467);
}
if( aiCol[i]==pTab->iPKey ){
        aiCol[i] = -1;
      }
      assert( pIdx==0 || pIdx->aiColumn[i]>=0 );
#ifndef SQLITE_OMIT_AUTHORIZATION
      /* Request permission to read the parent key columns. If the 
      ** authorization callback returns SQLITE_IGNORE, behave as if any
      ** values read from the parent table are NULL. */
      
// ABS Label 468
if(db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 468);
}
if( db->xAuth ){
        int rcauth;
        
// ABS Label 469
if(pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 469);
}
char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName;
        rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);
        bIgnore = (rcauth==SQLITE_IGNORE);
      }
#endif
    };
// ABS Label 460
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 460);
}
// ABS Label 461
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 461);
}

// ROR Label 462
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
// ROR Label 463
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 463);
}
// ROR Label 464
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 464);
}


    /* Take a shared-cache advisory read-lock on the parent table. Allocate 
    ** a cursor to use to search the unique index on the parent key columns 
    ** in the parent table.  */
    
// ABS Label 428
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// ABS Label 429
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}

// ABS Label 430
if(pTo->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}
sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);
    pParse->nTab++;

    
// ABS Label 470
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}

// ROR Label 471
if((regOld == 0) != (regOld != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 471);
}
if( regOld!=0 ){
      /* A row is being removed from the child table. Search for the parent.
      ** If the parent does not exist, removing the child row resolves an 
      ** outstanding foreign key constraint violation. */
      
// ABS Label 472
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}

// ABS Label 473
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}

// ABS Label 474
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}

// ABS Label 475
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}

// ABS Label 476
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}

// ABS Label 477
if(aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}

// ABS Label 478
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}

// ABS Label 479
if(bIgnore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}
fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore);
    }
    if( regNew!=0 && !isSetNullAction(pParse, pFKey) ){
      /* A row is being added to the child table. If a parent row cannot
      ** be found, adding the child row has violated the FK constraint. 
      **
      ** If this operation is being performed as part of a trigger program
      ** that is actually a "SET NULL" action belonging to this very 
      ** foreign key, then omit this scan altogether. As all child key
      ** values are guaranteed to be NULL, it is not possible for adding
      ** this row to cause an FK violation.  */
      
// ABS Label 480
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}

// ABS Label 481
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}

// ABS Label 482
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}

// ABS Label 483
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}

// ABS Label 484
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}

// ABS Label 485
if(aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}

// ABS Label 486
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}

// ABS Label 487
if(bIgnore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1, bIgnore);
    }

    
// ABS Label 431
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
sqlite3DbFree(db, aiFree);
  };
// ABS Label 427
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}


  /* Loop through all the foreign key constraints that refer to this table.
  ** (the "child" constraints) */
  pFKey = sqlite3FkReferences(pTab);

// ABS Label 488
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
for(; pFKey; pFKey=pFKey->pNextTo){
    Index *pIdx = 0;              /* Foreign key index for pFKey */
    SrcList *pSrc;
    int *aiCol = 0;

    if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){
      continue;
    }

    
// COR Label 491
if((!pFKey->isDeferred && !(db->flags & 524288) && !pParse->pToplevel || !pParse->isMultiWrite) != (!pFKey->isDeferred && !(db->flags & 524288) && !pParse->pToplevel && !pParse->isMultiWrite))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 491);
}
// COR Label 492
if((!pFKey->isDeferred && !(db->flags & 524288) || !pParse->pToplevel) != (!pFKey->isDeferred && !(db->flags & 524288) && !pParse->pToplevel))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 492);
}
// COR Label 493
if((!pFKey->isDeferred || !(db->flags & 524288)) != (!pFKey->isDeferred && !(db->flags & 524288)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 493);
}

// MCC Label 494
if(!pFKey->isDeferred && !(db->flags & 524288) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
// MCC Label 495
if(!pFKey->isDeferred && !(db->flags & 524288) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 495);
}
// MCC Label 496
if(!pFKey->isDeferred && !(db->flags & 524288) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 496);
}
// MCC Label 497
if(!pFKey->isDeferred && !(db->flags & 524288) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
// MCC Label 498
if(!pFKey->isDeferred && !(!(db->flags & 524288)) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 498);
}
// MCC Label 499
if(!pFKey->isDeferred && !(!(db->flags & 524288)) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
// MCC Label 500
if(!pFKey->isDeferred && !(!(db->flags & 524288)) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(!pFKey->isDeferred && !(!(db->flags & 524288)) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(!(!pFKey->isDeferred) && !(db->flags & 524288) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(!(!pFKey->isDeferred) && !(db->flags & 524288) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
// MCC Label 504
if(!(!pFKey->isDeferred) && !(db->flags & 524288) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
// MCC Label 505
if(!(!pFKey->isDeferred) && !(db->flags & 524288) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(!(!pFKey->isDeferred) && !(!(db->flags & 524288)) && !pParse->pToplevel && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(!(!pFKey->isDeferred) && !(!(db->flags & 524288)) && !pParse->pToplevel && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(!(!pFKey->isDeferred) && !(!(db->flags & 524288)) && !(!pParse->pToplevel) && !pParse->isMultiWrite ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(!(!pFKey->isDeferred) && !(!(db->flags & 524288)) && !(!pParse->pToplevel) && !(!pParse->isMultiWrite) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}
if( !pFKey->isDeferred && !(db->flags & SQLITE_DeferFKs) 
     && !pParse->pToplevel && !pParse->isMultiWrite 
    ){
      assert( regOld==0 && regNew!=0 );
      /* Inserting a single row into a parent table cannot cause (or fix)
      ** an immediate foreign key violation. So do nothing in this case.  */
      continue;
    }

    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
      
// COR Label 510
if((!isIgnoreErrors && db->mallocFailed) != (!isIgnoreErrors || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 510);
}

// MCC Label 511
if(!isIgnoreErrors && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 511);
}
// MCC Label 512
if(!isIgnoreErrors && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 512);
}
// MCC Label 513
if(!(!isIgnoreErrors) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 513);
}
// MCC Label 514
if(!(!isIgnoreErrors) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 514);
}
if( !isIgnoreErrors || db->mallocFailed ) { return;
}
      continue;
    }
    assert( aiCol || pFKey->nCol==1 );

    /* Create a SrcList structure containing the child table.  We need the
    ** child table as a SrcList for sqlite3WhereBegin() */
    pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    
// ABS Label 515
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}
if( pSrc ){
      SrcItem *pItem = pSrc->a;
      pItem->pTab = pFKey->pFrom;
      pItem->zName = pFKey->pFrom->zName;
      pItem->pTab->nTabRef++;
      pItem->iCursor = pParse->nTab++;
  
      
// ABS Label 518
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}

// ROR Label 519
if((regNew == 0) != (regNew != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 519);
}
if( regNew!=0 ){
        
// ABS Label 520
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 520);
}

// ABS Label 521
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}

// ABS Label 522
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 522);
}

// ABS Label 523
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}

// ABS Label 524
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}

// ABS Label 525
if(aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}

// ABS Label 526
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}
fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);
      }
      
// ABS Label 527
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}

// ROR Label 528
if((regOld == 0) != (regOld != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 528);
}
if( regOld!=0 ){
        int eAction = pFKey->aAction[aChange!=0];
        
// ABS Label 529
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// ABS Label 530
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}

// ABS Label 531
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 531);
}

// ABS Label 532
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 532);
}

// ABS Label 533
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}

// ABS Label 534
if(aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}

// ABS Label 535
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}
fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
        /* If this is a deferred FK constraint, or a CASCADE or SET NULL
        ** action applies, then any foreign key violations caused by
        ** removing the parent key will be rectified by the action trigger.
        ** So do not set the "may-abort" flag in this case.
        **
        ** Note 1: If the FK is declared "ON UPDATE CASCADE", then the
        ** may-abort flag will eventually be set on this statement anyway
        ** (when this function is called as part of processing the UPDATE
        ** within the action trigger).
        **
        ** Note 2: At first glance it may seem like SQLite could simply omit
        ** all OP_FkCounter related scans when either CASCADE or SET NULL
        ** applies. The trouble starts if the CASCADE or SET NULL action 
        ** trigger causes other triggers or action rules attached to the 
        ** child table to fire. In these cases the fk constraint counters
        ** might be set incorrectly if any OP_FkCounter related scans are 
        ** omitted.  */
        
// ABS Label 536
if(eAction < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}

// COR Label 537
if((!pFKey->isDeferred && eAction != 10 || eAction != 8) != (!pFKey->isDeferred && eAction != 10 && eAction != 8))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 537);
}
// COR Label 538
if((!pFKey->isDeferred || eAction != 10) != (!pFKey->isDeferred && eAction != 10))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 538);
}

// ROR Label 539
if((eAction == 10) != (eAction != 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 539);
}
// ROR Label 540
if((eAction == 8) != (eAction != 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 540);
}

// MCC Label 541
if(!pFKey->isDeferred && eAction != 10 && eAction != 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
// MCC Label 542
if(!pFKey->isDeferred && eAction != 10 && !(eAction != 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 542);
}
// MCC Label 543
if(!pFKey->isDeferred && !(eAction != 10) && eAction != 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 543);
}
// MCC Label 544
if(!pFKey->isDeferred && !(eAction != 10) && !(eAction != 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 544);
}
// MCC Label 545
if(!(!pFKey->isDeferred) && eAction != 10 && eAction != 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 545);
}
// MCC Label 546
if(!(!pFKey->isDeferred) && eAction != 10 && !(eAction != 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 546);
}
// MCC Label 547
if(!(!pFKey->isDeferred) && !(eAction != 10) && eAction != 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 547);
}
// MCC Label 548
if(!(!pFKey->isDeferred) && !(eAction != 10) && !(eAction != 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 548);
}
if( !pFKey->isDeferred && eAction!=OE_Cascade && eAction!=OE_SetNull ){
          
// ABS Label 549
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}
sqlite3MayAbort(pParse);
        }
      }
      pItem->zName = 0;
      
// ABS Label 516
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}

// ABS Label 517
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}
sqlite3SrcListDelete(db, pSrc);
    }
    
// ABS Label 490
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 490);
}
sqlite3DbFree(db, aiCol);
  };
// ABS Label 489
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}

}

#define COLUMN_MASK(x) (((x)>31) ? 0xffffffff : ((u32)1<<(x)))

/*
** This function is called before generating code to update or delete a 
** row contained in table pTab.
*/
u32 sqlite3FkOldmask(
  Parse *pParse,                  /* Parse context */
  Table *pTab                     /* Table being modified */
){
  u32 mask = 0;
  
// ABS Label 550
if(pParse->db->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}

// AOR Label 551
if(pParse->db->flags | 16384 != pParse->db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 551);
}
// AOR Label 552
if(pParse->db->flags ^ 16384 != pParse->db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 552);
}
if( pParse->db->flags&SQLITE_ForeignKeys ){
    FKey *p;
    int i;
    p = pTab->pFKey;

// ABS Label 553
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}
for(; p; p=p->pNextFrom){
      i = 0;

// ABS Label 555
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 555);
}
// ABS Label 556
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}

// ROR Label 557
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 557);
}
// ROR Label 558
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 558);
}
// ROR Label 559
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 559);
}
for(; i<p->nCol; i++) { mask |= COLUMN_MASK(p->aCol[i].iFrom);
};
// ABS Label 560
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 560);
}
// ABS Label 561
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}

// ROR Label 562
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 562);
}
// ROR Label 563
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 563);
}
// ROR Label 564
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}

    };
// ABS Label 554
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}

    p = sqlite3FkReferences(pTab);

// ABS Label 565
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 565);
}
for(; p; p=p->pNextTo){
      Index *pIdx = 0;
      
// ABS Label 567
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}

// ABS Label 568
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 568);
}

// ABS Label 569
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 569);
}
sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, 0);
      
// ABS Label 570
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 570);
}
if( pIdx ){
        i = 0;

// ABS Label 571
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 571);
}

// ROR Label 572
if((i <= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
// ROR Label 573
if((i > pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 573);
}
// ROR Label 574
if((i >= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 574);
}
for(; i<pIdx->nKeyCol; i++){
          assert( pIdx->aiColumn[i]>=0 );
          mask |= COLUMN_MASK(pIdx->aiColumn[i]);
        };
// ABS Label 575
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 575);
}

// ROR Label 576
if((i <= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 576);
}
// ROR Label 577
if((i > pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 577);
}
// ROR Label 578
if((i >= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 578);
}

      }
    };
// ABS Label 566
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 566);
}

  }
  
// ABS Label 579
if(mask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}
return mask;
}


/*
** This function is called before generating code to update or delete a 
** row contained in table pTab. If the operation is a DELETE, then
** parameter aChange is passed a NULL value. For an UPDATE, aChange points
** to an array of size N, where N is the number of columns in table pTab.
** If the i'th column is not modified by the UPDATE, then the corresponding 
** entry in the aChange[] array is set to -1. If the column is modified,
** the value is 0 or greater. Parameter chngRowid is set to true if the
** UPDATE statement modifies the rowid fields of the table.
**
** If any foreign key processing will be required, this function returns
** non-zero. If there is no foreign key related processing, this function 
** returns zero.
**
** For an UPDATE, this function returns 2 if:
**
**   * There are any FKs for which pTab is the child and the parent table
**     and any FK processing at all is required (even of a different FK), or
**
**   * the UPDATE modifies one or more parent keys for which the action is
**     not "NO ACTION" (i.e. is CASCADE, SET DEFAULT or SET NULL).
**
** Or, assuming some other foreign key processing is required, 1.
*/
int sqlite3FkRequired(
  Parse *pParse,                  /* Parse context */
  Table *pTab,                    /* Table being modified */
  int *aChange,                   /* Non-NULL for UPDATE operations */
  int chngRowid                   /* True for UPDATE that affects rowid */
){
  int eRet = 1;                   /* Value to return if bHaveFK is true */
  int bHaveFK = 0;                /* If FK processing is required */
  
// ABS Label 580
if(pParse->db->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 580);
}

// AOR Label 581
if(pParse->db->flags | 16384 != pParse->db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 581);
}
// AOR Label 582
if(pParse->db->flags ^ 16384 != pParse->db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 582);
}
if( pParse->db->flags&SQLITE_ForeignKeys ){
    if( !aChange ){
      /* A DELETE operation. Foreign key processing is required if the 
      ** table in question is either the child or parent table for any 
      ** foreign key constraint.  */
      bHaveFK = (sqlite3FkReferences(pTab) || pTab->pFKey);
    }else{
      /* This is an UPDATE. Foreign key processing is only required if the
      ** operation modifies one or more child or parent key columns. */
      FKey *p;

      /* Check if any child key columns are being modified. */
      p = pTab->pFKey;

// ABS Label 583
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 583);
}
for(; p; p=p->pNextFrom){
        if( fkChildIsModified(pTab, p, aChange, chngRowid) ){
          if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) { eRet = 2;
}
          bHaveFK = 1;
        }
      };
// ABS Label 584
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 584);
}


      /* Check if any parent key columns are being modified. */
      p = sqlite3FkReferences(pTab);

// ABS Label 585
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 585);
}
for(; p; p=p->pNextTo){
        if( fkParentIsModified(pTab, p, aChange, chngRowid) ){
          
// ROR Label 587
if((p->aAction[1] == 0) != (p->aAction[1] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 587);
}
if( p->aAction[1]!=OE_None ) { return 2;
}
          bHaveFK = 1;
        }
      };
// ABS Label 586
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 586);
}

    }
  }
  return bHaveFK ? eRet : 0;
}

/*
** This function is called when an UPDATE or DELETE operation is being 
** compiled on table pTab, which is the parent table of foreign-key pFKey.
** If the current operation is an UPDATE, then the pChanges parameter is
** passed a pointer to the list of columns being modified. If it is a
** DELETE, pChanges is passed a NULL pointer.
**
** It returns a pointer to a Trigger structure containing a trigger
** equivalent to the ON UPDATE or ON DELETE action specified by pFKey.
** If the action is "NO ACTION" or "RESTRICT", then a NULL pointer is
** returned (these actions require no special handling by the triggers
** sub-system, code for them is created by fkScanChildren()).
**
** For example, if pFKey is the foreign key and pTab is table "p" in 
** the following schema:
**
**   CREATE TABLE p(pk PRIMARY KEY);
**   CREATE TABLE c(ck REFERENCES p ON DELETE CASCADE);
**
** then the returned trigger structure is equivalent to:
**
**   CREATE TRIGGER ... DELETE ON p BEGIN
**     DELETE FROM c WHERE ck = old.pk;
**   END;
**
** The returned pointer is cached as part of the foreign key object. It
** is eventually freed along with the rest of the foreign key object by 
** sqlite3FkDelete().
*/
static Trigger *fkActionTrigger(
  Parse *pParse,                  /* Parse context */
  Table *pTab,                    /* Table being updated or deleted from */
  FKey *pFKey,                    /* Foreign key to get action for */
  ExprList *pChanges              /* Change-list for UPDATE, NULL for DELETE */
){
  
// ABS Label 588
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 588);
}
sqlite3 *db = pParse->db;       /* Database handle */
  int action;                     /* One of OE_None, OE_Cascade etc. */
  Trigger *pTrigger;              /* Trigger definition to return */
  int iAction = (pChanges!=0);    /* 1 for UPDATE, 0 for DELETE */

  action = pFKey->aAction[iAction];
  
// ABS Label 589
if(action < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}

// COR Label 590
if((action == 7 || (db->flags & 524288)) != (action == 7 && (db->flags & 524288)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 590);
}

// ROR Label 591
if((action != 7) != (action == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 591);
}

// MCC Label 592
if(action == 7 && ( db->flags & 524288 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 592);
}
// MCC Label 593
if(action == 7 && ( !(db->flags & 524288) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 593);
}
// MCC Label 594
if(!(action == 7) && ( db->flags & 524288 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 594);
}
// MCC Label 595
if(!(action == 7) && ( !(db->flags & 524288) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
if( action==OE_Restrict && (db->flags & SQLITE_DeferFKs) ){
    return 0;
  }
  pTrigger = pFKey->apTrigger[iAction];

  
// ABS Label 596
if(action < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}

// COR Label 597
if((action != 0 || !pTrigger) != (action != 0 && !pTrigger))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 597);
}

// ROR Label 598
if((action == 0) != (action != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 598);
}

// MCC Label 599
if(action != 0 && !pTrigger ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 599);
}
// MCC Label 600
if(action != 0 && !(!pTrigger) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 600);
}
// MCC Label 601
if(!(action != 0) && !pTrigger ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 601);
}
// MCC Label 602
if(!(action != 0) && !(!pTrigger) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 602);
}
if( action!=OE_None && !pTrigger ){
    char const *zFrom;            /* Name of child table */
    int nFrom;                    /* Length in bytes of zFrom */
    Index *pIdx = 0;              /* Parent key index for this FK */
    int *aiCol = 0;               /* child table cols -> parent key cols */
    TriggerStep *pStep = 0;        /* First (only) step of trigger program */
    Expr *pWhere = 0;             /* WHERE clause of trigger step */
    ExprList *pList = 0;          /* Changes list if ON UPDATE CASCADE */
    Select *pSelect = 0;          /* If RESTRICT, "SELECT RAISE(...)" */
    int i;                        /* Iterator variable */
    Expr *pWhen = 0;              /* WHEN clause for the trigger */

    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) { return 0;
}
    assert( aiCol || pFKey->nCol==1 );

    i = 0;

// ABS Label 612
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}
// ABS Label 613
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}

// ROR Label 614
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 614);
}
// ROR Label 615
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 615);
}
// ROR Label 616
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 616);
}
for(; i<pFKey->nCol; i++){
      Token tOld = { "old", 3 };  /* Literal "old" token */
      Token tNew = { "new", 3 };  /* Literal "new" token */
      Token tFromCol;             /* Name of column in child table */
      Token tToCol;               /* Name of column in parent table */
      int iFromCol;               /* Idx of column in child table */
      Expr *pEq;                  /* tFromCol = OLD.tToCol */

      iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
      assert( iFromCol>=0 );
      assert( pIdx!=0 || (pTab->iPKey>=0 && pTab->iPKey<pTab->nCol) );
      assert( pIdx==0 || pIdx->aiColumn[i]>=0 );
      
// ABS Label 622
if(pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 622);
}
sqlite3TokenInit(&tToCol,
                   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName);
      
// ABS Label 623
if(pFKey->pFrom->aCol[iFromCol].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}
sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zName);

      /* Create the expression "OLD.zToCol = zFromCol". It is important
      ** that the "OLD.zToCol" term is on the LHS of the = operator, so
      ** that the affinity and collation sequence associated with the
      ** parent table are used for the comparison. */
      pEq = sqlite3PExpr(pParse, TK_EQ,
          sqlite3PExpr(pParse, TK_DOT, 
            sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
            sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),
          sqlite3ExprAlloc(db, TK_ID, &tFromCol, 0)
      );
      pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);

      /* For ON UPDATE, construct the next term of the WHEN clause.
      ** The final WHEN clause will be like this:
      **
      **    WHEN NOT(old.col1 IS new.col1 AND ... AND old.colN IS new.colN)
      */
      
// ABS Label 624
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 624);
}
if( pChanges ){
        pEq = sqlite3PExpr(pParse, TK_IS,
            sqlite3PExpr(pParse, TK_DOT, 
              sqlite3ExprAlloc(db, TK_ID, &tOld, 0),
              sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),
            sqlite3PExpr(pParse, TK_DOT, 
              sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
              sqlite3ExprAlloc(db, TK_ID, &tToCol, 0))
            );
        pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
      }
  
      
// ABS Label 625
if(action < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 625);
}

// COR Label 626
if((action != 7 || (action != 10 || pChanges)) != (action != 7 && (action != 10 || pChanges)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 626);
}

// ROR Label 627
if((action == 7) != (action != 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 627);
}

// MCC Label 628
if(action != 7 && ( action != 10 && pChanges ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 628);
}
// MCC Label 629
if(action != 7 && ( action != 10 && !(pChanges) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 629);
}
// MCC Label 630
if(action != 7 && ( !(action != 10) && pChanges ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 630);
}
// MCC Label 631
if(action != 7 && ( !(action != 10) && !(pChanges) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 631);
}
// MCC Label 632
if(!(action != 7) && ( action != 10 && pChanges ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 632);
}
// MCC Label 633
if(!(action != 7) && ( action != 10 && !(pChanges) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 633);
}
// MCC Label 634
if(!(action != 7) && ( !(action != 10) && pChanges ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 634);
}
// MCC Label 635
if(!(action != 7) && ( !(action != 10) && !(pChanges) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 635);
}
if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){
        Expr *pNew;
        
// ABS Label 638
if(action < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 638);
}

// ROR Label 639
if((action != 10) != (action == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 639);
}
if( action==OE_Cascade ){
          pNew = sqlite3PExpr(pParse, TK_DOT, 
            sqlite3ExprAlloc(db, TK_ID, &tNew, 0),
            sqlite3ExprAlloc(db, TK_ID, &tToCol, 0));
        }else { 
// ABS Label 640
if(action < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 640);
}

// ROR Label 641
if((action != 9) != (action == 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 641);
}
if( action==OE_SetDflt ){
          
// ABS Label 642
if(iFromCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 642);
}
// ABS Label 643
if(pFKey->pFrom->aCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}

// AOR Label 644
if(pFKey->pFrom->aCol - iFromCol != pFKey->pFrom->aCol + iFromCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 644);
}
// AOR Label 645
if(pFKey->pFrom->aCol / iFromCol != pFKey->pFrom->aCol + iFromCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 645);
}
// AOR Label 646
if(pFKey->pFrom->aCol * iFromCol != pFKey->pFrom->aCol + iFromCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 646);
}
Column *pCol = pFKey->pFrom->aCol + iFromCol;
          Expr *pDflt;
          
// AOR Label 647
if(pCol->colFlags | 96 != pCol->colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 647);
}
// AOR Label 648
if(pCol->colFlags ^ 96 != pCol->colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 648);
}
if( pCol->colFlags & COLFLAG_GENERATED ){
            testcase( pCol->colFlags & COLFLAG_VIRTUAL );
            testcase( pCol->colFlags & COLFLAG_STORED );
            pDflt = 0;
          }else{
            pDflt = pCol->pDflt;
          }
          
// ABS Label 649
if(pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}
if( pDflt ){
            pNew = sqlite3ExprDup(db, pDflt, 0);
          }else{
            pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);
          }
        }else{
          pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);
        };}

        pList = sqlite3ExprListAppend(pParse, pList, pNew);
        
// ABS Label 636
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 636);
}

// ABS Label 637
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}
sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);
      }
    };
// ABS Label 617
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}
// ABS Label 618
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}

// ROR Label 619
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 619);
}
// ROR Label 620
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
// ROR Label 621
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}

    
// ABS Label 603
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}
sqlite3DbFree(db, aiCol);

    zFrom = pFKey->pFrom->zName;
    nFrom = sqlite3Strlen30(zFrom);

    
// ABS Label 650
if(action < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}

// ROR Label 651
if((action != 7) != (action == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}
if( action==OE_Restrict ){
      Token tFrom;
      Expr *pRaise; 

      tFrom.z = zFrom;
      tFrom.n = nFrom;
      pRaise = sqlite3Expr(db, TK_RAISE, "FOREIGN KEY constraint failed");
      
// ABS Label 652
if(pRaise < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}
if( pRaise ){
        pRaise->affExpr = OE_Abort;
      }
      pSelect = sqlite3SelectNew(pParse, 
          sqlite3ExprListAppend(pParse, 0, pRaise),
          sqlite3SrcListAppend(pParse, 0, &tFrom, 0),
          pWhere,
          0, 0, 0, 0, 0
      );
      pWhere = 0;
    }

    /* Disable lookaside memory allocation */
    DisableLookaside;

    pTrigger = (Trigger *)sqlite3DbMallocZero(db, 
        sizeof(Trigger) +         /* struct Trigger */
        sizeof(TriggerStep) +     /* Single step in trigger program */
        nFrom + 1                 /* Space for pStep->zTarget */
    );
    
// ABS Label 653
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}
if( pTrigger ){
      pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
      pStep->zTarget = (char *)&pStep[1];
      memcpy((char *)pStep->zTarget, zFrom, nFrom);
  
      pStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);
      pStep->pExprList = sqlite3ExprListDup(db, pList, EXPRDUP_REDUCE);
      pStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);
      
// ABS Label 654
if(pWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}
if( pWhen ){
        pWhen = sqlite3PExpr(pParse, TK_NOT, pWhen, 0);
        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);
      }
    }

    /* Re-enable the lookaside buffer, if it was disabled earlier. */
    EnableLookaside;

    
// ABS Label 604
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}

// ABS Label 605
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}
sqlite3ExprDelete(db, pWhere);
    
// ABS Label 606
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}

// ABS Label 607
if(pWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}
sqlite3ExprDelete(db, pWhen);
    
// ABS Label 608
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}

// ABS Label 609
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}
sqlite3ExprListDelete(db, pList);
    
// ABS Label 610
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}

// ABS Label 611
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}
sqlite3SelectDelete(db, pSelect);
    
// ROR Label 655
if((db->mallocFailed != 1) != (db->mallocFailed == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 655);
}
if( db->mallocFailed==1 ){
      
// ABS Label 656
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}

// ABS Label 657
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}
fkTriggerDelete(db, pTrigger);
      return 0;
    }
    assert( pStep!=0 );
    assert( pTrigger!=0 );

    switch( action ){
      case OE_Restrict:
        pStep->op = TK_SELECT;
        break;
      case OE_Cascade: 
        if( !pChanges ){ 
          pStep->op = TK_DELETE; 
          break; 
        }
        /* no break */ deliberate_fall_through
      default:
        pStep->op = TK_UPDATE;
    }
    pStep->pTrig = pTrigger;
    pTrigger->pSchema = pTab->pSchema;
    pTrigger->pTabSchema = pTab->pSchema;
    pFKey->apTrigger[iAction] = pTrigger;
    pTrigger->op = (pChanges ? TK_UPDATE : TK_DELETE);
  }

  
// ABS Label 658
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
return pTrigger;
}

/*
** This function is called when deleting or updating a row to implement
** any required CASCADE, SET NULL or SET DEFAULT actions.
*/
void sqlite3FkActions(
  Parse *pParse,                  /* Parse context */
  Table *pTab,                    /* Table being updated or deleted from */
  ExprList *pChanges,             /* Change-list for UPDATE, NULL for DELETE */
  int regOld,                     /* Address of array containing old row */
  int *aChange,                   /* Array indicating UPDATEd columns (or 0) */
  int bChngRowid                  /* True if rowid is UPDATEd */
){
  /* If foreign-key support is enabled, iterate through all FKs that 
  ** refer to table pTab. If there is an action associated with the FK 
  ** for this operation (either update or delete), invoke the associated 
  ** trigger sub-program.  */
  
// ABS Label 659
if(pParse->db->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}

// AOR Label 660
if(pParse->db->flags | 16384 != pParse->db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 660);
}
// AOR Label 661
if(pParse->db->flags ^ 16384 != pParse->db->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 661);
}
if( pParse->db->flags&SQLITE_ForeignKeys ){
    FKey *pFKey;                  /* Iterator variable */
    pFKey = sqlite3FkReferences(pTab);

// ABS Label 662
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 662);
}
for(; pFKey; pFKey=pFKey->pNextTo){
      if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){
        Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
        
// ABS Label 664
if(pAct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 664);
}
if( pAct ){
          
// ABS Label 665
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 665);
}

// ABS Label 666
if(pAct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ABS Label 667
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}

// ABS Label 668
if(regOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}
sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, OE_Abort, 0);
        }
      }
    };
// ABS Label 663
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}

  }
}

#endif /* ifndef SQLITE_OMIT_TRIGGER */

/*
** Free all memory associated with foreign key definitions attached to
** table pTab. Remove the deleted foreign keys from the Schema.fkeyHash
** hash table.
*/
void sqlite3FkDelete(sqlite3 *db, Table *pTab){
  FKey *pFKey;                    /* Iterator variable */
  FKey *pNext;                    /* Copy of pFKey->pNextFrom */

  assert( db==0 || IsVirtual(pTab)
         || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) );
  pFKey = pTab->pFKey;

// ABS Label 669
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}
for(; pFKey; pFKey=pNext){

    /* Remove the FK from the fkeyHash hash table. */
    
// ABS Label 676
if(db->pnBytesFreed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}

// COR Label 677
if((!db && db->pnBytesFreed == 0) != (!db || db->pnBytesFreed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 677);
}

// ROR Label 678
if((db->pnBytesFreed != 0) != (db->pnBytesFreed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 678);
}

// MCC Label 679
if(!db && db->pnBytesFreed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 679);
}
// MCC Label 680
if(!db && !(db->pnBytesFreed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 680);
}
// MCC Label 681
if(!(!db) && db->pnBytesFreed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 681);
}
// MCC Label 682
if(!(!db) && !(db->pnBytesFreed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 682);
}
if( !db || db->pnBytesFreed==0 ){
      
// ABS Label 683
if(pFKey->pPrevTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}
if( pFKey->pPrevTo ){
        pFKey->pPrevTo->pNextTo = pFKey->pNextTo;
      }else{
        void *p = (void *)pFKey->pNextTo;
        const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);
        
// ABS Label 684
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 684);
}

// ABS Label 685
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}
sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, p);
      }
      
// ABS Label 686
if(pFKey->pNextTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}
if( pFKey->pNextTo ){
        pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;
      }
    }

    /* EV: R-30323-21917 Each foreign key constraint in SQLite is
    ** classified as either immediate or deferred.
    */
    assert( pFKey->isDeferred==0 || pFKey->isDeferred==1 );

    /* Delete any triggers created to implement actions for this FK. */
#ifndef SQLITE_OMIT_TRIGGER
    
// ABS Label 671
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ABS Label 672
if(pFKey->apTrigger[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}
fkTriggerDelete(db, pFKey->apTrigger[0]);
    
// ABS Label 673
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}

// ABS Label 674
if(pFKey->apTrigger[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}
fkTriggerDelete(db, pFKey->apTrigger[1]);
#endif

    pNext = pFKey->pNextFrom;
    
// ABS Label 675
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}
sqlite3DbFree(db, pFKey);
  };
// ABS Label 670
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}

}
#endif /* ifndef SQLITE_OMIT_FOREIGN_KEY */
