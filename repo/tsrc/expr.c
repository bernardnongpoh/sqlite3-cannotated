/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used for analyzing expressions and
** for generating VDBE code that evaluates expressions in SQLite.
*/
#include "sqliteInt.h"

/* Forward declarations */
static void exprCodeBetween(Parse*,Expr*,int,void(*)(Parse*,Expr*,int,int),int);
static int exprCodeVector(Parse *pParse, Expr *p, int *piToFree);

/*
** Return the affinity character for a single column of a table.
*/
char sqlite3TableColumnAffinity(Table *pTab, int iCol){
  assert( iCol<pTab->nCol );
  return iCol>=0 ? pTab->aCol[iCol].affinity : SQLITE_AFF_INTEGER;
}

/*
** Return the 'affinity' of the expression pExpr if any.
**
** If pExpr is a column, a reference to a column via an 'AS' alias,
** or a sub-select with a column as the return value, then the 
** affinity of that column is returned. Otherwise, 0x00 is returned,
** indicating no affinity for the expression.
**
** i.e. the WHERE clause expressions in the following statements all
** have an affinity:
**
** CREATE TABLE t1(a);
** SELECT * FROM t1 WHERE a;
** SELECT a AS b FROM t1 WHERE b;
** SELECT * FROM t1 WHERE (select a from t1);
*/
char sqlite3ExprAffinity(const Expr *pExpr){
  int op;
  
// MCC Label 7
if(( ((pExpr)->flags & (4096 | 131072)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 7);
}
// MCC Label 8
if(( !(((pExpr)->flags & (4096 | 131072)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 8);
}
while( ExprHasProperty(pExpr, EP_Skip|EP_IfNullRow) ){
    assert( pExpr->op==TK_COLLATE
         || pExpr->op==TK_IF_NULL_ROW
         || (pExpr->op==TK_REGISTER && pExpr->op2==TK_IF_NULL_ROW) );
    pExpr = pExpr->pLeft;
    assert( pExpr!=0 );
  };
// MCC Label 9
if(( ((pExpr)->flags & (4096 | 131072)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 9);
}
// MCC Label 10
if(( !(((pExpr)->flags & (4096 | 131072)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 10);
}

  op = pExpr->op;
  
// ABS Label 11
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ROR Label 12
if((op != 175) != (op == 175))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
if( op==TK_REGISTER ) { op = pExpr->op2;
}
  
// ABS Label 13
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// COR Label 14
if(((op == 166 || op == 168) || pExpr->y.pTab) != ((op == 166 || op == 168) && pExpr->y.pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 14);
}

// MCC Label 15
if(( op == 166 && op == 168 ) && pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 15);
}
// MCC Label 16
if(( op == 166 && op == 168 ) && !(pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}
// MCC Label 17
if(( op == 166 && !(op == 168) ) && pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 17);
}
// MCC Label 18
if(( op == 166 && !(op == 168) ) && !(pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 18);
}
// MCC Label 19
if(( !(op == 166) && op == 168 ) && pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 19);
}
// MCC Label 20
if(( !(op == 166) && op == 168 ) && !(pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 20);
}
// MCC Label 21
if(( !(op == 166) && !(op == 168) ) && pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 21);
}
// MCC Label 22
if(( !(op == 166) && !(op == 168) ) && !(pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 22);
}
if( (op==TK_COLUMN || op==TK_AGG_COLUMN) && pExpr->y.pTab ){
    return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
  }
  
// ABS Label 23
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}

// ROR Label 24
if((op != 137) != (op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
if( op==TK_SELECT ){
    assert( pExpr->flags&EP_xIsSelect );
    assert( pExpr->x.pSelect!=0 );
    assert( pExpr->x.pSelect->pEList!=0 );
    assert( pExpr->x.pSelect->pEList->a[0].pExpr!=0 );
    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
  }
#ifndef SQLITE_OMIT_CAST
  
// ABS Label 25
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}

// ROR Label 26
if((op != 36) != (op == 36))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
if( op==TK_CAST ){
    assert( !ExprHasProperty(pExpr, EP_IntValue) );
    return sqlite3AffinityType(pExpr->u.zToken, 0);
  }
#endif
  
// ABS Label 27
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}

// ROR Label 28
if((op != 177) != (op == 177))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
if( op==TK_SELECT_COLUMN ){
    assert( pExpr->pLeft->flags&EP_xIsSelect );
    assert( pExpr->iColumn < pExpr->iTable );
    assert( pExpr->iTable==pExpr->pLeft->x.pSelect->pEList->nExpr );
    return sqlite3ExprAffinity(
        pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr
    );
  }
  
// ABS Label 29
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}

// ROR Label 30
if((op != 176) != (op == 176))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
if( op==TK_VECTOR ){
    return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);
  }
  
// ABS Label 31
if(pExpr->affExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
return pExpr->affExpr;
}

/*
** Set the collating sequence for expression pExpr to be the collating
** sequence named by pToken.   Return a pointer to a new Expr node that
** implements the COLLATE operator.
**
** If a memory allocation error occurs, that fact is recorded in pParse->db
** and the pExpr parameter is returned unchanged.
*/
Expr *sqlite3ExprAddCollateToken(
  Parse *pParse,           /* Parsing context */
  Expr *pExpr,             /* Add the "COLLATE" clause to this expression */
  const Token *pCollName,  /* Name of collating sequence */
  int dequote              /* True to dequote pCollName */
){
  
// ABS Label 32
if(pCollName->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}

// ROR Label 33
if((pCollName->n <= 0) != (pCollName->n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}
// ROR Label 34
if((pCollName->n < 0) != (pCollName->n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
// ROR Label 35
if((pCollName->n >= 0) != (pCollName->n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
if( pCollName->n>0 ){
#ifdef MAGMA_ENABLE_FIXES
    Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);
#else
#ifdef MAGMA_ENABLE_CANARIES
    MAGMA_LOG("SQL018", dequote==0);
#endif
    Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, 1);
#endif
    
// ABS Label 36
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}
if( pNew ){
      pNew->pLeft = pExpr;
      pNew->flags |= EP_Collate|EP_Skip;
      pExpr = pNew;
    }
  }
  
// ABS Label 37
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
return pExpr;
}
Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){
  Token s;
  assert( zC!=0 );
  sqlite3TokenInit(&s, (char*)zC);
  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
}

/*
** Skip over any TK_COLLATE operators.
*/
Expr *sqlite3ExprSkipCollate(Expr *pExpr){
  
// ABS Label 38
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}

// COR Label 39
if((pExpr || (((pExpr)->flags & (4096)) != 0)) != (pExpr && (((pExpr)->flags & (4096)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 39);
}

// MCC Label 40
if(pExpr && ( ((pExpr)->flags & (4096)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(pExpr && ( !(((pExpr)->flags & (4096)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(!(pExpr) && ( ((pExpr)->flags & (4096)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
// MCC Label 43
if(!(pExpr) && ( !(((pExpr)->flags & (4096)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 43);
}
while( pExpr && ExprHasProperty(pExpr, EP_Skip) ){
    assert( pExpr->op==TK_COLLATE );
    pExpr = pExpr->pLeft;
  };
// ABS Label 44
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// COR Label 45
if((pExpr || (((pExpr)->flags & (4096)) != 0)) != (pExpr && (((pExpr)->flags & (4096)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 45);
}

// MCC Label 46
if(pExpr && ( ((pExpr)->flags & (4096)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 46);
}
// MCC Label 47
if(pExpr && ( !(((pExpr)->flags & (4096)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if(!(pExpr) && ( ((pExpr)->flags & (4096)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
// MCC Label 49
if(!(pExpr) && ( !(((pExpr)->flags & (4096)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 49);
}
   
  
// ABS Label 50
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
return pExpr;
}

/*
** Skip over any TK_COLLATE operators and/or any unlikely()
** or likelihood() or likely() functions at the root of an
** expression.
*/
Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){
  
// ABS Label 51
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// COR Label 52
if((pExpr || (((pExpr)->flags & (4096 | 262144)) != 0)) != (pExpr && (((pExpr)->flags & (4096 | 262144)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 52);
}

// MCC Label 53
if(pExpr && ( ((pExpr)->flags & (4096 | 262144)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(pExpr && ( !(((pExpr)->flags & (4096 | 262144)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(!(pExpr) && ( ((pExpr)->flags & (4096 | 262144)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(pExpr) && ( !(((pExpr)->flags & (4096 | 262144)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
while( pExpr && ExprHasProperty(pExpr, EP_Skip|EP_Unlikely) ){
    
// MCC Label 63
if(( ((pExpr)->flags & (262144)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 63);
}
// MCC Label 64
if(( !(((pExpr)->flags & (262144)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 64);
}
if( ExprHasProperty(pExpr, EP_Unlikely) ){
      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
      assert( pExpr->x.pList->nExpr>0 );
      assert( pExpr->op==TK_FUNCTION );
      pExpr = pExpr->x.pList->a[0].pExpr;
    }else{
      assert( pExpr->op==TK_COLLATE );
      pExpr = pExpr->pLeft;
    }
  };
// ABS Label 57
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}

// COR Label 58
if((pExpr || (((pExpr)->flags & (4096 | 262144)) != 0)) != (pExpr && (((pExpr)->flags & (4096 | 262144)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 58);
}

// MCC Label 59
if(pExpr && ( ((pExpr)->flags & (4096 | 262144)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if(pExpr && ( !(((pExpr)->flags & (4096 | 262144)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!(pExpr) && ( ((pExpr)->flags & (4096 | 262144)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(pExpr) && ( !(((pExpr)->flags & (4096 | 262144)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
   
  
// ABS Label 65
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
return pExpr;
}

/*
** Return the collation sequence for the expression pExpr. If
** there is no defined collating sequence, return NULL.
**
** See also: sqlite3ExprNNCollSeq()
**
** The sqlite3ExprNNCollSeq() works the same exact that it returns the
** default collation if pExpr has no defined collation.
**
** The collating sequence might be determined by a COLLATE operator
** or by the presence of a column with a defined collating sequence.
** COLLATE operators take first precedence.  Left operands take
** precedence over right operands.
*/
CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr){
  
// ABS Label 66
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
sqlite3 *db = pParse->db;
  CollSeq *pColl = 0;
  
// ABS Label 67
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
const Expr *p = pExpr;
  
// ABS Label 68
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}
while( p ){
    int op = p->op;
    
// ABS Label 70
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((op != 175) != (op == 175))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
if( op==TK_REGISTER ) { op = p->op2;
}
    
// ABS Label 72
if(p->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}

// COR Label 73
if(((op == 168 || op == 166 || op == 77) || p->y.pTab != 0) != ((op == 168 || op == 166 || op == 77) && p->y.pTab != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 73);
}

// ROR Label 74
if((p->y.pTab == 0) != (p->y.pTab != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}

// MCC Label 75
if(( op == 168 && op == 166 && op == 77 ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 75);
}
// MCC Label 76
if(( op == 168 && op == 166 && op == 77 ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 76);
}
// MCC Label 77
if(( op == 168 && op == 166 && !(op == 77) ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 77);
}
// MCC Label 78
if(( op == 168 && op == 166 && !(op == 77) ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 78);
}
// MCC Label 79
if(( op == 168 && !(op == 166) && op == 77 ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 79);
}
// MCC Label 80
if(( op == 168 && !(op == 166) && op == 77 ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 80);
}
// MCC Label 81
if(( op == 168 && !(op == 166) && !(op == 77) ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 81);
}
// MCC Label 82
if(( op == 168 && !(op == 166) && !(op == 77) ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
// MCC Label 83
if(( !(op == 168) && op == 166 && op == 77 ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
// MCC Label 84
if(( !(op == 168) && op == 166 && op == 77 ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 84);
}
// MCC Label 85
if(( !(op == 168) && op == 166 && !(op == 77) ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 85);
}
// MCC Label 86
if(( !(op == 168) && op == 166 && !(op == 77) ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 86);
}
// MCC Label 87
if(( !(op == 168) && !(op == 166) && op == 77 ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 87);
}
// MCC Label 88
if(( !(op == 168) && !(op == 166) && op == 77 ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 88);
}
// MCC Label 89
if(( !(op == 168) && !(op == 166) && !(op == 77) ) && p->y.pTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 89);
}
// MCC Label 90
if(( !(op == 168) && !(op == 166) && !(op == 77) ) && !(p->y.pTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}
if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER)
     && p->y.pTab!=0
    ){
      /* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally
      ** a TK_COLUMN but was previously evaluated and cached in a register */
      int j = p->iColumn;
      
// ABS Label 91
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}

// ROR Label 92
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
// ROR Label 94
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 94);
}
if( j>=0 ){
        const char *zColl = p->y.pTab->aCol[j].zColl;
        pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);
      }
      break;
    }
    
// ABS Label 95
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}

// COR Label 96
if((op == 36 && op == 173) != (op == 36 || op == 173))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 96);
}

// ROR Label 97
if((op != 36) != (op == 36))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
// ROR Label 98
if((op != 173) != (op == 173))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}

// MCC Label 99
if(op == 36 && op == 173 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 99);
}
// MCC Label 100
if(op == 36 && !(op == 173) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 100);
}
// MCC Label 101
if(!(op == 36) && op == 173 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(!(op == 36) && !(op == 173) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
if( op==TK_CAST || op==TK_UPLUS ){
      p = p->pLeft;
      continue;
    }
    
// ABS Label 103
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}

// ROR Label 104
if((op != 176) != (op == 176))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
if( op==TK_VECTOR ){
      p = p->x.pList->a[0].pExpr;
      continue;
    }
    
// ABS Label 105
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// ROR Label 106
if((op != 112) != (op == 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
if( op==TK_COLLATE ){
      pColl = sqlite3GetCollSeq(pParse, ENC(db), 0, p->u.zToken);
      break;
    }
    
// ABS Label 107
if(p->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}

// AOR Label 108
if(p->flags | 256 != p->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 108);
}
// AOR Label 109
if(p->flags ^ 256 != p->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 109);
}
if( p->flags & EP_Collate ){
      
// ABS Label 110
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// COR Label 111
if((p->pLeft || (p->pLeft->flags & 256) != 0) != (p->pLeft && (p->pLeft->flags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 111);
}

// ROR Label 112
if(((p->pLeft->flags & 256) == 0) != ((p->pLeft->flags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 112);
}

// MCC Label 113
if(p->pLeft && (p->pLeft->flags & 256) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
// MCC Label 114
if(p->pLeft && !((p->pLeft->flags & 256) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 114);
}
// MCC Label 115
if(!(p->pLeft) && (p->pLeft->flags & 256) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 115);
}
// MCC Label 116
if(!(p->pLeft) && !((p->pLeft->flags & 256) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 116);
}
if( p->pLeft && (p->pLeft->flags & EP_Collate)!=0 ){
        p = p->pLeft;
      }else{
        
// ABS Label 117
if(p->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
Expr *pNext  = p->pRight;
        /* The Expr.x union is never used at the same time as Expr.pRight */
        assert( p->x.pList==0 || p->pRight==0 );
        
// ABS Label 118
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// COR Label 119
if((p->x.pList != 0 && !db->mallocFailed || (!(((p)->flags & (2048)) != 0))) != (p->x.pList != 0 && !db->mallocFailed && (!(((p)->flags & (2048)) != 0))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 119);
}
// COR Label 120
if((p->x.pList != 0 || !db->mallocFailed) != (p->x.pList != 0 && !db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 120);
}

// ROR Label 121
if((p->x.pList == 0) != (p->x.pList != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}

// MCC Label 122
if(p->x.pList != 0 && !db->mallocFailed && ( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(p->x.pList != 0 && !db->mallocFailed && ( !(!(((p)->flags & (2048)) != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
// MCC Label 124
if(p->x.pList != 0 && !(!db->mallocFailed) && ( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 124);
}
// MCC Label 125
if(p->x.pList != 0 && !(!db->mallocFailed) && ( !(!(((p)->flags & (2048)) != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 125);
}
// MCC Label 126
if(!(p->x.pList != 0) && !db->mallocFailed && ( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 126);
}
// MCC Label 127
if(!(p->x.pList != 0) && !db->mallocFailed && ( !(!(((p)->flags & (2048)) != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 127);
}
// MCC Label 128
if(!(p->x.pList != 0) && !(!db->mallocFailed) && ( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 128);
}
// MCC Label 129
if(!(p->x.pList != 0) && !(!db->mallocFailed) && ( !(!(((p)->flags & (2048)) != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
if( p->x.pList!=0 
         && !db->mallocFailed
         && ALWAYS(!ExprHasProperty(p, EP_xIsSelect))
        ){
          int i;
          i = 0;

// MCC Label 130
if(( i < p->x.pList->nExpr ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
// MCC Label 131
if(( !(i < p->x.pList->nExpr) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 131);
}
for(; ALWAYS(i<p->x.pList->nExpr); i++){
            
// MCC Label 134
if(( ((p->x.pList->a[i].pExpr)->flags & (256)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 134);
}
// MCC Label 135
if(( !(((p->x.pList->a[i].pExpr)->flags & (256)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
if( ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate) ){
              pNext = p->x.pList->a[i].pExpr;
              break;
            }
          };
// MCC Label 132
if(( i < p->x.pList->nExpr ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
// MCC Label 133
if(( !(i < p->x.pList->nExpr) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 133);
}

        }
        p = pNext;
      }
    }else{
      break;
    }
  };
// ABS Label 69
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}

  if( sqlite3CheckCollSeq(pParse, pColl) ){ 
    pColl = 0;
  }
  
// ABS Label 136
if(pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
return pColl;
}

/*
** Return the collation sequence for the expression pExpr. If
** there is no defined collating sequence, return a pointer to the
** defautl collation sequence.
**
** See also: sqlite3ExprCollSeq()
**
** The sqlite3ExprCollSeq() routine works the same except that it
** returns NULL if there is no defined collation.
*/
CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr){
  CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);
  
// ABS Label 137
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}

// ROR Label 138
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 138);
}
if( p==0 ) { p = pParse->db->pDfltColl;
}
  assert( p!=0 );
  
// ABS Label 139
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
return p;
}

/*
** Return TRUE if the two expressions have equivalent collating sequences.
*/
int sqlite3ExprCollSeqMatch(Parse *pParse, const Expr *pE1, const Expr *pE2){
  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
  CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
  return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0;
}

/*
** pExpr is an operand of a comparison operator.  aff2 is the
** type affinity of the other operand.  This routine returns the
** type affinity that should be used for the comparison operator.
*/
char sqlite3CompareAffinity(const Expr *pExpr, char aff2){
  char aff1 = sqlite3ExprAffinity(pExpr);
  
// COR Label 140
if((aff1 > 64 || aff2 > 64) != (aff1 > 64 && aff2 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 140);
}

// ROR Label 141
if((aff1 <= 64) != (aff1 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 141);
}
// ROR Label 142
if((aff1 < 64) != (aff1 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((aff1 >= 64) != (aff1 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}
// ROR Label 144
if((aff2 <= 64) != (aff2 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
// ROR Label 145
if((aff2 < 64) != (aff2 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
// ROR Label 146
if((aff2 >= 64) != (aff2 > 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 146);
}

// MCC Label 147
if(aff1 > 64 && aff2 > 64 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(aff1 > 64 && !(aff2 > 64) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
// MCC Label 149
if(!(aff1 > 64) && aff2 > 64 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 149);
}
// MCC Label 150
if(!(aff1 > 64) && !(aff2 > 64) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 150);
}
if( aff1>SQLITE_AFF_NONE && aff2>SQLITE_AFF_NONE ){
    /* Both sides of the comparison are columns. If one has numeric
    ** affinity, use that. Otherwise use no affinity.
    */
    
// COR Label 151
if((((aff1) >= 67) && ((aff2) >= 67)) != (((aff1) >= 67) || ((aff2) >= 67)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 151);
}

// MCC Label 152
if(( (aff1) >= 67 ) && ( (aff2) >= 67 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 152);
}
// MCC Label 153
if(( (aff1) >= 67 ) && ( !((aff2) >= 67) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 153);
}
// MCC Label 154
if(( !((aff1) >= 67) ) && ( (aff2) >= 67 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 154);
}
// MCC Label 155
if(( !((aff1) >= 67) ) && ( !((aff2) >= 67) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 155);
}
if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){
      return SQLITE_AFF_NUMERIC;
    }else{
      return SQLITE_AFF_BLOB;
    }
  }else{
    /* One side is a column, the other is not. Use the columns affinity. */
    assert( aff1<=SQLITE_AFF_NONE || aff2<=SQLITE_AFF_NONE );
    return (aff1<=SQLITE_AFF_NONE ? aff2 : aff1) | SQLITE_AFF_NONE;
  }
}

/*
** pExpr is a comparison operator.  Return the type affinity that should
** be applied to both operands prior to doing the comparison.
*/
static char comparisonAffinity(const Expr *pExpr){
  char aff;
  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||
          pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||
          pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );
  assert( pExpr->pLeft );
  aff = sqlite3ExprAffinity(pExpr->pLeft);
  
// ABS Label 156
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
if( pExpr->pRight ){
    aff = sqlite3CompareAffinity(pExpr->pRight, aff);
  }else { 
// MCC Label 157
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
// MCC Label 158
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);
  }else { 
// ROR Label 159
if((aff != 0) != (aff == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 159);
}
if( aff==0 ){
    aff = SQLITE_AFF_BLOB;
  };}
;}

  
// ABS Label 160
if(aff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
return aff;
}

/*
** pExpr is a comparison expression, eg. '=', '<', IN(...) etc.
** idx_affinity is the affinity of an indexed column. Return true
** if the index with affinity idx_affinity may be used to implement
** the comparison in pExpr.
*/
int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity){
  char aff = comparisonAffinity(pExpr);
  
// ROR Label 161
if((aff <= 66) != (aff < 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((aff > 66) != (aff < 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((aff >= 66) != (aff < 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
if( aff<SQLITE_AFF_TEXT ){
    return 1;
  }
  
// ROR Label 164
if((aff != 66) != (aff == 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
if( aff==SQLITE_AFF_TEXT ){
    
// ROR Label 165
if((idx_affinity != 66) != (idx_affinity == 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
return idx_affinity==SQLITE_AFF_TEXT;
  }
  
// MCC Label 166
if(( (idx_affinity) >= 67 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(( !((idx_affinity) >= 67) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
return sqlite3IsNumericAffinity(idx_affinity);
}

/*
** Return the P5 value that should be used for a binary comparison
** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.
*/
static u8 binaryCompareP5(
  const Expr *pExpr1,   /* Left operand */
  const Expr *pExpr2,   /* Right operand */
  int jumpIfNull        /* Extra flags added to P5 */
){
  u8 aff = (char)sqlite3ExprAffinity(pExpr2);
  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;
  
// ABS Label 168
if(aff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}
return aff;
}

/*
** Return a pointer to the collation sequence that should be used by
** a binary comparison operator comparing pLeft and pRight.
**
** If the left hand expression has a collating sequence type, then it is
** used. Otherwise the collation sequence for the right hand expression
** is used, or the default (BINARY) if neither expression has a collating
** type.
**
** Argument pRight (but not pLeft) may be a null pointer. In this case,
** it is not considered.
*/
CollSeq *sqlite3BinaryCompareCollSeq(
  Parse *pParse, 
  const Expr *pLeft, 
  const Expr *pRight
){
  CollSeq *pColl;
  assert( pLeft );
  
// ABS Label 169
if(pLeft->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}

// AOR Label 170
if(pLeft->flags | 256 != pLeft->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 170);
}
// AOR Label 171
if(pLeft->flags ^ 256 != pLeft->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 171);
}
if( pLeft->flags & EP_Collate ){
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
  }else { 
// ABS Label 172
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}

// COR Label 173
if((pRight || (pRight->flags & 256) != 0) != (pRight && (pRight->flags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 173);
}

// ROR Label 174
if(((pRight->flags & 256) == 0) != ((pRight->flags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}

// MCC Label 175
if(pRight && (pRight->flags & 256) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 175);
}
// MCC Label 176
if(pRight && !((pRight->flags & 256) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if(!(pRight) && (pRight->flags & 256) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(!(pRight) && !((pRight->flags & 256) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
if( pRight && (pRight->flags & EP_Collate)!=0 ){
    pColl = sqlite3ExprCollSeq(pParse, pRight);
  }else{
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
    if( !pColl ){
      pColl = sqlite3ExprCollSeq(pParse, pRight);
    }
  };}

  
// ABS Label 179
if(pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}
return pColl;
}

/* Expresssion p is a comparison operator.  Return a collation sequence
** appropriate for the comparison operator.
**
** This is normally just a wrapper around sqlite3BinaryCompareCollSeq().
** However, if the OP_Commuted flag is set, then the order of the operands
** is reversed in the sqlite3BinaryCompareCollSeq() call so that the
** correct collating sequence is found.
*/
CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, const Expr *p){
  
// MCC Label 180
if(( ((p)->flags & (512)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(( !(((p)->flags & (512)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
if( ExprHasProperty(p, EP_Commuted) ){
    return sqlite3BinaryCompareCollSeq(pParse, p->pRight, p->pLeft);
  }else{
    return sqlite3BinaryCompareCollSeq(pParse, p->pLeft, p->pRight);
  }
}

/*
** Generate code for a comparison operator.
*/
static int codeCompare(
  Parse *pParse,    /* The parsing (and code generating) context */
  Expr *pLeft,      /* The left operand */
  Expr *pRight,     /* The right operand */
  int opcode,       /* The comparison opcode */
  int in1, int in2, /* Register holding operands */
  int dest,         /* Jump here if true.  */
  int jumpIfNull,   /* If true, jump if either operand is NULL */
  int isCommuted    /* The comparison has been commuted */
){
  int p5;
  int addr;
  CollSeq *p4;

  
// ABS Label 183
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
if( pParse->nErr ) { return 0;
}
  
// ABS Label 184
if(isCommuted < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}
if( isCommuted ){
    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
  }else{
    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
  }
  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                           (void*)p4, P4_COLLSEQ);
  
// ABS Label 182
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
  
// ABS Label 185
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
return addr;
}

/*
** Return true if expression pExpr is a vector, or false otherwise.
**
** A vector is defined as any expression that results in two or more
** columns of result.  Every TK_VECTOR node is an vector because the
** parser will not generate a TK_VECTOR with fewer than two entries.
** But a TK_SELECT might be either a vector or a scalar. It is only
** considered a vector if it has two or more result columns.
*/
int sqlite3ExprIsVector(Expr *pExpr){
  return sqlite3ExprVectorSize(pExpr)>1;
}

/*
** If the expression passed as the only argument is of type TK_VECTOR 
** return the number of expressions in the vector. Or, if the expression
** is a sub-select, return the number of columns in the sub-select. For
** any other type of expression, return 1.
*/
int sqlite3ExprVectorSize(Expr *pExpr){
  
// ABS Label 186
if(pExpr->op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
u8 op = pExpr->op;
  
// ROR Label 187
if((op != 175) != (op == 175))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
if( op==TK_REGISTER ) { op = pExpr->op2;
}
  
// ROR Label 188
if((op != 176) != (op == 176))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
if( op==TK_VECTOR ){
    
// ABS Label 189
if(pExpr->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}
return pExpr->x.pList->nExpr;
  }else { 
// ROR Label 190
if((op != 137) != (op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}
if( op==TK_SELECT ){
    
// ABS Label 191
if(pExpr->x.pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
return pExpr->x.pSelect->pEList->nExpr;
  }else{
    return 1;
  };}

}

/*
** Return a pointer to a subexpression of pVector that is the i-th
** column of the vector (numbered starting with 0).  The caller must
** ensure that i is within range.
**
** If pVector is really a scalar (and "scalar" here includes subqueries
** that return a single column!) then return pVector unmodified.
**
** pVector retains ownership of the returned subexpression.
**
** If the vector is a (SELECT ...) then the expression returned is
** just the expression for the i-th term of the result set, and may
** not be ready for evaluation because the table cursor has not yet
** been positioned.
*/
Expr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){
  assert( i<sqlite3ExprVectorSize(pVector) || pVector->op==TK_ERROR );
  if( sqlite3ExprIsVector(pVector) ){
    assert( pVector->op2==0 || pVector->op==TK_REGISTER );
    
// COR Label 192
if((pVector->op == 137 && pVector->op2 == 137) != (pVector->op == 137 || pVector->op2 == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 192);
}

// ROR Label 193
if((pVector->op != 137) != (pVector->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
// ROR Label 194
if((pVector->op2 != 137) != (pVector->op2 == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}

// MCC Label 195
if(pVector->op == 137 && pVector->op2 == 137 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(pVector->op == 137 && !(pVector->op2 == 137) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(!(pVector->op == 137) && pVector->op2 == 137 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
// MCC Label 198
if(!(pVector->op == 137) && !(pVector->op2 == 137) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 198);
}
if( pVector->op==TK_SELECT || pVector->op2==TK_SELECT ){
      
// ABS Label 199
if(pVector->x.pSelect->pEList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}
return pVector->x.pSelect->pEList->a[i].pExpr;
    }else{
      
// ABS Label 200
if(pVector->x.pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
return pVector->x.pList->a[i].pExpr;
    }
  }
  
// ABS Label 201
if(pVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}
return pVector;
}

/*
** Compute and return a new Expr object which when passed to
** sqlite3ExprCode() will generate all necessary code to compute
** the iField-th column of the vector expression pVector.
**
** It is ok for pVector to be a scalar (as long as iField==0).  
** In that case, this routine works like sqlite3ExprDup().
**
** The caller owns the returned Expr object and is responsible for
** ensuring that the returned value eventually gets freed.
**
** The caller retains ownership of pVector.  If pVector is a TK_SELECT,
** then the returned object will reference pVector and so pVector must remain
** valid for the life of the returned object.  If pVector is a TK_VECTOR
** or a scalar expression, then it can be deleted as soon as this routine
** returns.
**
** A trick to cause a TK_SELECT pVector to be deleted together with
** the returned Expr object is to attach the pVector to the pRight field
** of the returned TK_SELECT_COLUMN Expr object.
*/
Expr *sqlite3ExprForVectorField(
  Parse *pParse,       /* Parsing context */
  Expr *pVector,       /* The vector.  List of expressions or a sub-SELECT */
  int iField,          /* Which column of the vector to return */
  int nField           /* Total number of columns in the vector */
){
  Expr *pRet;
  
// ROR Label 202
if((pVector->op != 137) != (pVector->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
if( pVector->op==TK_SELECT ){
    assert( pVector->flags & EP_xIsSelect );
    /* The TK_SELECT_COLUMN Expr node:
    **
    ** pLeft:           pVector containing TK_SELECT.  Not deleted.
    ** pRight:          not used.  But recursively deleted.
    ** iColumn:         Index of a column in pVector
    ** iTable:          0 or the number of columns on the LHS of an assignment
    ** pLeft->iTable:   First in an array of register holding result, or 0
    **                  if the result is not yet computed.
    **
    ** sqlite3ExprDelete() specifically skips the recursive delete of
    ** pLeft on TK_SELECT_COLUMN nodes.  But pRight is followed, so pVector
    ** can be attached to pRight to cause this node to take ownership of
    ** pVector.  Typically there will be multiple TK_SELECT_COLUMN nodes
    ** with the same pLeft pointer to the pVector, but only one of them
    ** will own the pVector.
    */
    pRet = sqlite3PExpr(pParse, TK_SELECT_COLUMN, 0, 0);
    
// ABS Label 203
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}
if( pRet ){
      pRet->iTable = nField;
      pRet->iColumn = iField;
      pRet->pLeft = pVector;
    }
  }else{
    
// ROR Label 205
if((pVector->op != 176) != (pVector->op == 176))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
if( pVector->op==TK_VECTOR ) { pVector = pVector->x.pList->a[iField].pExpr;
}
    pRet = sqlite3ExprDup(pParse->db, pVector, 0);
    
// ABS Label 204
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}
sqlite3RenameTokenRemap(pParse, pRet, pVector);
  }
  
// ABS Label 206
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
return pRet;
}

/*
** If expression pExpr is of type TK_SELECT, generate code to evaluate
** it. Return the register in which the result is stored (or, if the 
** sub-select returns more than one column, the first in an array
** of registers in which the result is stored).
**
** If pExpr is not a TK_SELECT expression, return 0.
*/
static int exprCodeSubselect(Parse *pParse, Expr *pExpr){
  int reg = 0;
#ifndef SQLITE_OMIT_SUBQUERY
  
// ROR Label 207
if((pExpr->op != 137) != (pExpr->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
if( pExpr->op==TK_SELECT ){
    reg = sqlite3CodeSubselect(pParse, pExpr);
  }
#endif
  
// ABS Label 208
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 208);
}
return reg;
}

/*
** Argument pVector points to a vector expression - either a TK_VECTOR
** or TK_SELECT that returns more than one column. This function returns
** the register number of a register that contains the value of
** element iField of the vector.
**
** If pVector is a TK_SELECT expression, then code for it must have 
** already been generated using the exprCodeSubselect() routine. In this
** case parameter regSelect should be the first in an array of registers
** containing the results of the sub-select. 
**
** If pVector is of type TK_VECTOR, then code for the requested field
** is generated. In this case (*pRegFree) may be set to the number of
** a temporary register to be freed by the caller before returning.
**
** Before returning, output parameter (*ppExpr) is set to point to the
** Expr object corresponding to element iElem of the vector.
*/
static int exprVectorRegister(
  Parse *pParse,                  /* Parse context */
  Expr *pVector,                  /* Vector to extract element from */
  int iField,                     /* Field to extract from pVector */
  int regSelect,                  /* First in array of registers */
  Expr **ppExpr,                  /* OUT: Expression element */
  int *pRegFree                   /* OUT: Temp register to free */
){
  
// ABS Label 209
if(pVector->op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 209);
}
u8 op = pVector->op;
  assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT || op==TK_ERROR );
  
// ROR Label 210
if((op != 175) != (op == 175))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
if( op==TK_REGISTER ){
    *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);
    
// ABS Label 211
if(iField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}
// ABS Label 212
if(pVector->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// AOR Label 213
if(pVector->iTable - iField != pVector->iTable + iField)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 213);
}
// AOR Label 214
if(pVector->iTable / iField != pVector->iTable + iField)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 214);
}
// AOR Label 215
if(pVector->iTable * iField != pVector->iTable + iField)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 215);
}
return pVector->iTable+iField;
  }
  
// ROR Label 216
if((op != 137) != (op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 216);
}
if( op==TK_SELECT ){
    *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;
     
// ABS Label 217
if(iField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}
// ABS Label 218
if(regSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}

// AOR Label 219
if(regSelect - iField != regSelect + iField)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 219);
}
// AOR Label 220
if(regSelect / iField != regSelect + iField)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 220);
}
// AOR Label 221
if(regSelect * iField != regSelect + iField)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 221);
}
return regSelect+iField;
  }
  
// ROR Label 222
if((op != 176) != (op == 176))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
if( op==TK_VECTOR ){
    *ppExpr = pVector->x.pList->a[iField].pExpr;
    return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);
  }
  return 0;
}

/*
** Expression pExpr is a comparison between two vector values. Compute
** the result of the comparison (1, 0, or NULL) and write that
** result into register dest.
**
** The caller must satisfy the following preconditions:
**
**    if pExpr->op==TK_IS:      op==TK_EQ and p5==SQLITE_NULLEQ
**    if pExpr->op==TK_ISNOT:   op==TK_NE and p5==SQLITE_NULLEQ
**    otherwise:                op==pExpr->op and p5==0
*/
static void codeVectorCompare(
  Parse *pParse,        /* Code generator context */
  Expr *pExpr,          /* The comparison operation */
  int dest,             /* Write results into this register */
  u8 op,                /* Comparison operator */
  u8 p5                 /* SQLITE_NULLEQ or zero */
){
  
// ABS Label 223
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}
Vdbe *v = pParse->pVdbe;
  
// ABS Label 224
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
Expr *pLeft = pExpr->pLeft;
  
// ABS Label 225
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}
Expr *pRight = pExpr->pRight;
  int nLeft = sqlite3ExprVectorSize(pLeft);
  int i;
  int regLeft = 0;
  int regRight = 0;
  
// ABS Label 226
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
u8 opx = op;
  int addrCmp = 0;
  int addrDone = sqlite3VdbeMakeLabel(pParse);
  int isCommuted = ExprHasProperty(pExpr,EP_Commuted);

  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );
  
// ABS Label 233
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}
if( pParse->nErr ) { return;
}
  if( nLeft!=sqlite3ExprVectorSize(pRight) ){
    
// ABS Label 234
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}
sqlite3ErrorMsg(pParse, "row value misused");
    return;
  }
  assert( pExpr->op==TK_EQ || pExpr->op==TK_NE 
       || pExpr->op==TK_IS || pExpr->op==TK_ISNOT 
       || pExpr->op==TK_LT || pExpr->op==TK_GT 
       || pExpr->op==TK_LE || pExpr->op==TK_GE 
  );
  assert( pExpr->op==op || (pExpr->op==TK_IS && op==TK_EQ)
            || (pExpr->op==TK_ISNOT && op==TK_NE) );
  assert( p5==0 || pExpr->op!=op );
  assert( p5==SQLITE_NULLEQ || pExpr->op==op );

  
// ROR Label 235
if((op != 55) != (op == 55))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
if( op==TK_LE ) { opx = TK_LT;
}
  
// ROR Label 236
if((op != 57) != (op == 57))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
if( op==TK_GE ) { opx = TK_GT;
}
  
// ROR Label 237
if((op != 52) != (op == 52))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
if( op==TK_NE ) { opx = TK_EQ;
}

  regLeft = exprCodeSubselect(pParse, pLeft);
  regRight = exprCodeSubselect(pParse, pRight);

  
// ABS Label 227
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}

// ABS Label 228
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, dest);
  i = 0;
for(; 1 /*Loop exits by "break"*/; i++){
    int regFree1 = 0, regFree2 = 0;
    Expr *pL = 0, *pR = 0; 
    int r1, r2;
    assert( i>=0 && i<nLeft );
    
// ABS Label 249
if(addrCmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
if( addrCmp ) { 
// ABS Label 250
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

// ABS Label 251
if(addrCmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}
sqlite3VdbeJumpHere(v, addrCmp);
}
    r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);
    r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);
    addrCmp = sqlite3VdbeCurrentAddr(v);
    
// ABS Label 238
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ABS Label 239
if(pL < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// ABS Label 240
if(pR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ABS Label 241
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}

// ABS Label 242
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}

// ABS Label 243
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}

// ABS Label 244
if(isCommuted < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}
codeCompare(pParse, pL, pR, opx, r1, r2, addrDone, p5, isCommuted);
    testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);
    testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);
    testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);
    testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);
    testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);
    testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);
    
// ABS Label 245
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}

// ABS Label 246
if(regFree1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}
sqlite3ReleaseTempReg(pParse, regFree1);
    
// ABS Label 247
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}

// ABS Label 248
if(regFree2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
sqlite3ReleaseTempReg(pParse, regFree2);
    
// ABS Label 252
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}
// ABS Label 253
if(nLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}

// AOR Label 254
if(nLeft / 1 != nLeft - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 254);
}
// AOR Label 255
if(nLeft + 1 != nLeft - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 255);
}
// AOR Label 256
if(nLeft * 1 != nLeft - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 256);
}

// COR Label 257
if(((opx == 56 || opx == 54) || i < nLeft - 1) != ((opx == 56 || opx == 54) && i < nLeft - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 257);
}

// ROR Label 258
if((i <= nLeft - 1) != (i < nLeft - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}
// ROR Label 259
if((i > nLeft - 1) != (i < nLeft - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}
// ROR Label 260
if((i >= nLeft - 1) != (i < nLeft - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 260);
}

// MCC Label 261
if(( opx == 56 && opx == 54 ) && i < nLeft - 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(( opx == 56 && opx == 54 ) && !(i < nLeft - 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(( opx == 56 && !(opx == 54) ) && i < nLeft - 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
// MCC Label 264
if(( opx == 56 && !(opx == 54) ) && !(i < nLeft - 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(( !(opx == 56) && opx == 54 ) && i < nLeft - 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(( !(opx == 56) && opx == 54 ) && !(i < nLeft - 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(( !(opx == 56) && !(opx == 54) ) && i < nLeft - 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(( !(opx == 56) && !(opx == 54) ) && !(i < nLeft - 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
if( (opx==TK_LT || opx==TK_GT) && i<nLeft-1 ){
      addrCmp = sqlite3VdbeAddOp0(v, OP_ElseEq);
      testcase(opx==TK_LT); VdbeCoverageIf(v,opx==TK_LT);
      testcase(opx==TK_GT); VdbeCoverageIf(v,opx==TK_GT);
    }
    
// ROR Label 269
if((p5 != 128) != (p5 == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}
if( p5==SQLITE_NULLEQ ){
      
// ABS Label 270
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}

// ABS Label 271
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, dest);
    }else{
      
// ABS Label 272
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}

// ABS Label 273
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

// ABS Label 274
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}

// ABS Label 275
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, dest, r2);
    }
    
// ABS Label 276
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
// ABS Label 277
if(nLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}

// AOR Label 278
if(nLeft / 1 != nLeft - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 278);
}
// AOR Label 279
if(nLeft + 1 != nLeft - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 279);
}
// AOR Label 280
if(nLeft * 1 != nLeft - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 280);
}

// ROR Label 281
if((i != nLeft - 1) != (i == nLeft - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}
if( i==nLeft-1 ){
      break;
    }
    
// ROR Label 282
if((opx != 53) != (opx == 53))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
if( opx==TK_EQ ){
      
// ABS Label 283
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ABS Label 284
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}

// ABS Label 285
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
sqlite3VdbeAddOp2(v, OP_NotNull, dest, addrDone); VdbeCoverage(v);
    }else{
      assert( op==TK_LT || op==TK_GT || op==TK_LE || op==TK_GE );
      
// ABS Label 286
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ABS Label 287
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);
      
// ABS Label 288
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}
// ABS Label 289
if(nLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// AOR Label 290
if(nLeft / 2 != nLeft - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 290);
}
// AOR Label 291
if(nLeft + 2 != nLeft - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 291);
}
// AOR Label 292
if(nLeft * 2 != nLeft - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 292);
}

// ROR Label 293
if((i != nLeft - 2) != (i == nLeft - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 293);
}
if( i==nLeft-2 ) { opx = op;
}
    }
  };
  
// ABS Label 229
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}

// ABS Label 230
if(addrCmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}
sqlite3VdbeJumpHere(v, addrCmp);
  
// ABS Label 231
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ABS Label 232
if(addrDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}
sqlite3VdbeResolveLabel(v, addrDone);
  
// ROR Label 294
if((op != 52) != (op == 52))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}
if( op==TK_NE ){
    
// ABS Label 295
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// ABS Label 297
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
sqlite3VdbeAddOp2(v, OP_Not, dest, dest);
  }
}

#if SQLITE_MAX_EXPR_DEPTH>0
/*
** Check that argument nHeight is less than or equal to the maximum
** expression depth allowed. If it is not, leave an error message in
** pParse.
*/
int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){
  int rc = SQLITE_OK;
  
// ABS Label 298
if(pParse->db->aLimit[3] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH];
  
// ABS Label 299
if(mxHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
// ABS Label 300
if(nHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}

// ROR Label 301
if((nHeight <= mxHeight) != (nHeight > mxHeight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}
// ROR Label 302
if((nHeight < mxHeight) != (nHeight > mxHeight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}
// ROR Label 303
if((nHeight >= mxHeight) != (nHeight > mxHeight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 303);
}
if( nHeight>mxHeight ){
    
// ABS Label 304
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}

// ABS Label 305
if(mxHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
sqlite3ErrorMsg(pParse, 
       "Expression tree is too large (maximum depth %d)", mxHeight
    );
    rc = SQLITE_ERROR;
  }
  
// ABS Label 306
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
return rc;
}

/* The following three functions, heightOfExpr(), heightOfExprList()
** and heightOfSelect(), are used to determine the maximum height
** of any expression tree referenced by the structure passed as the
** first argument.
**
** If this maximum height is greater than the current value pointed
** to by pnHeight, the second parameter, then set *pnHeight to that
** value.
*/
static void heightOfExpr(Expr *p, int *pnHeight){
  
// ABS Label 307
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
if( p ){
    
// ABS Label 308
if(*pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}
// ABS Label 309
if(p->nHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}

// ROR Label 310
if((p->nHeight <= *pnHeight) != (p->nHeight > *pnHeight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((p->nHeight < *pnHeight) != (p->nHeight > *pnHeight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
// ROR Label 312
if((p->nHeight >= *pnHeight) != (p->nHeight > *pnHeight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 312);
}
if( p->nHeight>*pnHeight ){
      *pnHeight = p->nHeight;
    }
  }
}
static void heightOfExprList(ExprList *p, int *pnHeight){
  
// ABS Label 313
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
if( p ){
    int i;
    i = 0;

// ABS Label 314
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
// ABS Label 315
if(p->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}

// ROR Label 316
if((i <= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
// ROR Label 317
if((i > p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}
// ROR Label 318
if((i >= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
for(; i<p->nExpr; i++){
      
// ABS Label 324
if(p->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ABS Label 325
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
heightOfExpr(p->a[i].pExpr, pnHeight);
    };
// ABS Label 319
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
// ABS Label 320
if(p->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}

// ROR Label 321
if((i <= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 321);
}
// ROR Label 322
if((i > p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}
// ROR Label 323
if((i >= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 323);
}

  }
}
static void heightOfSelect(Select *pSelect, int *pnHeight){
  Select *p;
  p = pSelect;

// ABS Label 326
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
for(; p; p=p->pPrior){
    
// ABS Label 328
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ABS Label 329
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
heightOfExpr(p->pWhere, pnHeight);
    
// ABS Label 330
if(p->pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ABS Label 331
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
heightOfExpr(p->pHaving, pnHeight);
    
// ABS Label 332
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// ABS Label 333
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
heightOfExpr(p->pLimit, pnHeight);
    
// ABS Label 334
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}

// ABS Label 335
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
heightOfExprList(p->pEList, pnHeight);
    
// ABS Label 336
if(p->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ABS Label 337
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
heightOfExprList(p->pGroupBy, pnHeight);
    
// ABS Label 338
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}

// ABS Label 339
if(pnHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}
heightOfExprList(p->pOrderBy, pnHeight);
  };
// ABS Label 327
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}

}

/*
** Set the Expr.nHeight variable in the structure passed as an 
** argument. An expression with no children, Expr.pList or 
** Expr.pSelect member has a height of 1. Any other expression
** has a height equal to the maximum height of any other 
** referenced Expr plus one.
**
** Also propagate EP_Propagate flags up from Expr.x.pList to Expr.flags,
** if appropriate.
*/
static void exprSetHeight(Expr *p){
  int nHeight = 0;
  
// ABS Label 340
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}
heightOfExpr(p->pLeft, &nHeight);
  
// ABS Label 341
if(p->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
heightOfExpr(p->pRight, &nHeight);
  
// MCC Label 342
if(( ((p)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 342);
}
// MCC Label 343
if(( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 343);
}
if( ExprHasProperty(p, EP_xIsSelect) ){
    
// ABS Label 344
if(p->x.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
heightOfSelect(p->x.pSelect, &nHeight);
  }else { 
// ABS Label 345
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}
if( p->x.pList ){
    
// ABS Label 346
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}
heightOfExprList(p->x.pList, &nHeight);
    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);
  };}

  p->nHeight = nHeight + 1;
}

/*
** Set the Expr.nHeight variable using the exprSetHeight() function. If
** the height is greater than the maximum allowed expression depth,
** leave an error in pParse.
**
** Also propagate all EP_Propagate flags from the Expr.x.pList into
** Expr.flags. 
*/
void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
  
// ABS Label 350
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
if( pParse->nErr ) { return;
}
  
// ABS Label 347
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}
exprSetHeight(p);
  
// ABS Label 348
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}

// ABS Label 349
if(p->nHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
sqlite3ExprCheckHeight(pParse, p->nHeight);
}

/*
** Return the maximum height of any expression tree referenced
** by the select statement passed as an argument.
*/
int sqlite3SelectExprHeight(Select *p){
  int nHeight = 0;
  
// ABS Label 351
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
heightOfSelect(p, &nHeight);
  
// ABS Label 352
if(nHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}
return nHeight;
}
#else /* ABOVE:  Height enforcement enabled.  BELOW: Height enforcement off */
/*
** Propagate all EP_Propagate flags from the Expr.x.pList into
** Expr.flags. 
*/
void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
  if( pParse->nErr ) return;
  if( p && p->x.pList && !ExprHasProperty(p, EP_xIsSelect) ){
    p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);
  }
}
#define exprSetHeight(y)
#endif /* SQLITE_MAX_EXPR_DEPTH>0 */

/*
** This routine is the core allocator for Expr nodes.
**
** Construct a new expression node and return a pointer to it.  Memory
** for this node and for the pToken argument is a single allocation
** obtained from sqlite3DbMalloc().  The calling function
** is responsible for making sure the node eventually gets freed.
**
** If dequote is true, then the token (if it exists) is dequoted.
** If dequote is false, no dequoting is performed.  The deQuote
** parameter is ignored if pToken is NULL or if the token does not
** appear to be quoted.  If the quotes were of the form "..." (double-quotes)
** then the EP_DblQuoted flag is set on the expression node.
**
** Special case:  If op==TK_INTEGER and pToken points to a string that
** can be translated into a 32-bit integer, then the token is not
** stored in u.zToken.  Instead, the integer values is written
** into u.iValue and the EP_IntValue flag is set.  No extra storage
** is allocated to hold the integer text and the dequote flag is ignored.
*/
Expr *sqlite3ExprAlloc(
  sqlite3 *db,            /* Handle for sqlite3DbMallocRawNN() */
  int op,                 /* Expression opcode */
  const Token *pToken,    /* Token argument.  Might be NULL */
  int dequote             /* True to dequote */
){
  Expr *pNew;
  int nExtra = 0;
  int iValue = 0;

  assert( db!=0 );
  
// ABS Label 353
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}
if( pToken ){
    if( op!=TK_INTEGER || pToken->z==0
          || sqlite3GetInt32(pToken->z, &iValue)==0 ){
      nExtra = pToken->n+1;
      assert( iValue>=0 );
    }
  }
  pNew = sqlite3DbMallocRawNN(db, sizeof(Expr)+nExtra);
  
// ABS Label 354
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
if( pNew ){
    memset(pNew, 0, sizeof(Expr));
    pNew->op = (u8)op;
    pNew->iAgg = -1;
    
// ABS Label 355
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
if( pToken ){
      
// ABS Label 356
if(nExtra < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ROR Label 357
if((nExtra != 0) != (nExtra == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
if( nExtra==0 ){
        pNew->flags |= EP_IntValue|EP_Leaf|(iValue?EP_IsTrue:EP_IsFalse);
        pNew->u.iValue = iValue;
      }else{
        pNew->u.zToken = (char*)&pNew[1];
        assert( pToken->z!=0 || pToken->n==0 );
        
// ABS Label 358
if(pToken->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}
if( pToken->n ) { memcpy(pNew->u.zToken, pToken->z, pToken->n);
}
        pNew->u.zToken[pToken->n] = 0;
        
// ABS Label 359
if(dequote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}

// COR Label 360
if((dequote || (sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])] & 128)) != (dequote && (sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])] & 128)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 360);
}

// MCC Label 361
if(dequote && ( sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])] & 128 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
// MCC Label 362
if(dequote && ( !(sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])] & 128) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 362);
}
// MCC Label 363
if(!(dequote) && ( sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])] & 128 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
// MCC Label 364
if(!(dequote) && ( !(sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])] & 128) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 364);
}
if( dequote && sqlite3Isquote(pNew->u.zToken[0]) ){
          
// ABS Label 365
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
sqlite3DequoteExpr(pNew);
        }
      }
    }
#if SQLITE_MAX_EXPR_DEPTH>0
    pNew->nHeight = 1;
#endif  
  }
  
// ABS Label 366
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}
return pNew;
}

/*
** Allocate a new expression node from a zero-terminated token that has
** already been dequoted.
*/
Expr *sqlite3Expr(
  sqlite3 *db,            /* Handle for sqlite3DbMallocZero() (may be null) */
  int op,                 /* Expression opcode */
  const char *zToken      /* Token argument.  Might be NULL */
){
  Token x;
  x.z = zToken;
  x.n = sqlite3Strlen30(zToken);
  return sqlite3ExprAlloc(db, op, &x, 0);
}

/*
** Attach subtrees pLeft and pRight to the Expr node pRoot.
**
** If pRoot==NULL that means that a memory allocation error has occurred.
** In that case, delete the subtrees pLeft and pRight.
*/
void sqlite3ExprAttachSubtrees(
  sqlite3 *db,
  Expr *pRoot,
  Expr *pLeft,
  Expr *pRight
){
  
// ABS Label 367
if(pRoot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}

// ROR Label 368
if((pRoot != 0) != (pRoot == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}
if( pRoot==0 ){
    assert( db->mallocFailed );
    
// ABS Label 369
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}

// ABS Label 370
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}
sqlite3ExprDelete(db, pLeft);
    
// ABS Label 371
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}

// ABS Label 372
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
sqlite3ExprDelete(db, pRight);
  }else{
    
// ABS Label 374
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
if( pRight ){
      pRoot->pRight = pRight;
      pRoot->flags |= EP_Propagate & pRight->flags;
    }
    
// ABS Label 375
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}
if( pLeft ){
      pRoot->pLeft = pLeft;
      pRoot->flags |= EP_Propagate & pLeft->flags;
    }
    
// ABS Label 373
if(pRoot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}
exprSetHeight(pRoot);
  }
}

/*
** Allocate an Expr node which joins as many as two subtrees.
**
** One or both of the subtrees can be NULL.  Return a pointer to the new
** Expr node.  Or, if an OOM error occurs, set pParse->db->mallocFailed,
** free the subtrees and return NULL.
*/
Expr *sqlite3PExpr(
  Parse *pParse,          /* Parsing context */
  int op,                 /* Expression opcode */
  Expr *pLeft,            /* Left operand */
  Expr *pRight            /* Right operand */
){
  Expr *p;
  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
  
// ABS Label 376
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 376);
}
if( p ){
    memset(p, 0, sizeof(Expr));
    p->op = op & 0xff;
    p->iAgg = -1;
    
// ABS Label 377
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}

// ABS Label 378
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 378);
}

// ABS Label 379
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// ABS Label 380
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}
sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
    
// ABS Label 381
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 381);
}

// ABS Label 382
if(p->nHeight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}
sqlite3ExprCheckHeight(pParse, p->nHeight);
  }else{
    
// ABS Label 383
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}

// ABS Label 384
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}
sqlite3ExprDelete(pParse->db, pLeft);
    
// ABS Label 385
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}

// ABS Label 386
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
sqlite3ExprDelete(pParse->db, pRight);
  }
  
// ABS Label 387
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}
return p;
}

/*
** Add pSelect to the Expr.x.pSelect field.  Or, if pExpr is NULL (due
** do a memory allocation failure) then delete the pSelect object.
*/
void sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect){
  
// ABS Label 388
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
if( pExpr ){
    pExpr->x.pSelect = pSelect;
    ExprSetProperty(pExpr, EP_xIsSelect|EP_Subquery);
    
// ABS Label 389
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}

// ABS Label 390
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}
sqlite3ExprSetHeightAndFlags(pParse, pExpr);
  }else{
    assert( pParse->db->mallocFailed );
    
// ABS Label 391
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}

// ABS Label 392
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}
sqlite3SelectDelete(pParse->db, pSelect);
  }
}

/*
** Expression list pEList is a list of vector values. This function
** converts the contents of pEList to a VALUES(...) Select statement
** returning 1 row for each element of the list. For example, the 
** expression list:
**
**   ( (1,2), (3,4) (5,6) )
**
** is translated to the equivalent of:
**
**   VALUES(1,2), (3,4), (5,6)
**
** Each of the vector values in pEList must contain exactly nElem terms.
** If a list element that is not a vector or does not contain nElem terms,
** an error message is left in pParse.
**
** This is used as part of processing IN(...) expressions with a list
** of vectors on the RHS. e.g. "... IN ((1,2), (3,4), (5,6))".
*/
Select *sqlite3ExprListToValues(Parse *pParse, int nElem, ExprList *pEList){
  int ii;
  Select *pRet = 0;
  assert( nElem>1 );
  ii = 0;

// ABS Label 395
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 395);
}
// ABS Label 396
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}

// ROR Label 397
if((ii <= pEList->nExpr) != (ii < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 397);
}
// ROR Label 398
if((ii > pEList->nExpr) != (ii < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 398);
}
// ROR Label 399
if((ii >= pEList->nExpr) != (ii < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 399);
}
for(; ii<pEList->nExpr; ii++){
    Select *pSel;
    
// ABS Label 405
if(pEList->a[ii].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}
Expr *pExpr = pEList->a[ii].pExpr;
    int nExprElem = (pExpr->op==TK_VECTOR ? pExpr->x.pList->nExpr : 1);
    
// ABS Label 406
if(nElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
// ABS Label 407
if(nExprElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// ROR Label 408
if((nExprElem == nElem) != (nExprElem != nElem))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}
if( nExprElem!=nElem ){
      
// ABS Label 409
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}

// ABS Label 410
if(nExprElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ABS Label 411
if(nElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}
sqlite3ErrorMsg(pParse, "IN(...) element has %d term%s - expected %d", 
          nExprElem, nExprElem>1?"s":"", nElem
      );
      break;
    }
    pSel = sqlite3SelectNew(pParse, pExpr->x.pList, 0, 0, 0, 0, 0, SF_Values,0);
    pExpr->x.pList = 0;
    
// ABS Label 412
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}
if( pSel ){
      
// ABS Label 413
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
if( pRet ){
        pSel->op = TK_ALL;
        pSel->pPrior = pRet;
      }
      pRet = pSel;
    }
  };
// ABS Label 400
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
// ABS Label 401
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}

// ROR Label 402
if((ii <= pEList->nExpr) != (ii < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 402);
}
// ROR Label 403
if((ii > pEList->nExpr) != (ii < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
// ROR Label 404
if((ii >= pEList->nExpr) != (ii < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 404);
}


  
// ABS Label 414
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}
// ABS Label 415
if(pRet->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}

// COR Label 416
if((pRet || pRet->pPrior) != (pRet && pRet->pPrior))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 416);
}

// MCC Label 417
if(pRet && pRet->pPrior ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 417);
}
// MCC Label 418
if(pRet && !(pRet->pPrior) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 418);
}
// MCC Label 419
if(!(pRet) && pRet->pPrior ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 419);
}
// MCC Label 420
if(!(pRet) && !(pRet->pPrior) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 420);
}
if( pRet && pRet->pPrior ){
    pRet->selFlags |= SF_MultiValue;
  }
  
// ABS Label 393
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}

// ABS Label 394
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}
sqlite3ExprListDelete(pParse->db, pEList);
  
// ABS Label 421
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}
return pRet;
}

/*
** Join two expressions using an AND operator.  If either expression is
** NULL, then just return the other expression.
**
** If one side or the other of the AND is known to be false, then instead
** of returning an AND expression, just return a constant expression with
** a value of false.
*/
Expr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){
  
// ABS Label 422
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}
sqlite3 *db = pParse->db;
  
// ABS Label 423
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}

// ROR Label 424
if((pLeft != 0) != (pLeft == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 424);
}
if( pLeft==0  ){
    
// ABS Label 425
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}
return pRight;
  }else { 
// ABS Label 426
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}

// ROR Label 427
if((pRight != 0) != (pRight == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
if( pRight==0 ){
    
// ABS Label 428
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}
return pLeft;
  }else { 
// COR Label 429
if((((((pLeft)->flags & (1 | 536870912)) == 536870912) || (((pRight)->flags & (1 | 536870912)) == 536870912)) || !(pParse->eParseMode >= 2)) != (((((pLeft)->flags & (1 | 536870912)) == 536870912) || (((pRight)->flags & (1 | 536870912)) == 536870912)) && !(pParse->eParseMode >= 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 429);
}

// MCC Label 430
if(( ( ((pLeft)->flags & (1 | 536870912)) == 536870912 ) && ( ((pRight)->flags & (1 | 536870912)) == 536870912 ) ) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 430);
}
// MCC Label 431
if(( ( ((pLeft)->flags & (1 | 536870912)) == 536870912 ) && ( ((pRight)->flags & (1 | 536870912)) == 536870912 ) ) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 431);
}
// MCC Label 432
if(( ( ((pLeft)->flags & (1 | 536870912)) == 536870912 ) && ( !(((pRight)->flags & (1 | 536870912)) == 536870912) ) ) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 432);
}
// MCC Label 433
if(( ( ((pLeft)->flags & (1 | 536870912)) == 536870912 ) && ( !(((pRight)->flags & (1 | 536870912)) == 536870912) ) ) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 433);
}
// MCC Label 434
if(( ( !(((pLeft)->flags & (1 | 536870912)) == 536870912) ) && ( ((pRight)->flags & (1 | 536870912)) == 536870912 ) ) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 434);
}
// MCC Label 435
if(( ( !(((pLeft)->flags & (1 | 536870912)) == 536870912) ) && ( ((pRight)->flags & (1 | 536870912)) == 536870912 ) ) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 435);
}
// MCC Label 436
if(( ( !(((pLeft)->flags & (1 | 536870912)) == 536870912) ) && ( !(((pRight)->flags & (1 | 536870912)) == 536870912) ) ) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 436);
}
// MCC Label 437
if(( ( !(((pLeft)->flags & (1 | 536870912)) == 536870912) ) && ( !(((pRight)->flags & (1 | 536870912)) == 536870912) ) ) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 437);
}
if( (ExprAlwaysFalse(pLeft) || ExprAlwaysFalse(pRight)) 
         && !IN_RENAME_OBJECT
  ){
    
// ABS Label 438
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}

// ABS Label 439
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 439);
}
sqlite3ExprDeferredDelete(pParse, pLeft);
    
// ABS Label 440
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 440);
}

// ABS Label 441
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 441);
}
sqlite3ExprDeferredDelete(pParse, pRight);
    return sqlite3Expr(db, TK_INTEGER, "0");
  }else{
    return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);
  };}
;}

}

/*
** Construct a new expression node for a function with multiple
** arguments.
*/
Expr *sqlite3ExprFunction(
  Parse *pParse,        /* Parsing context */
  ExprList *pList,      /* Argument list */
  Token *pToken,        /* Name of the function */
  int eDistinct         /* SF_Distinct or SF_ALL or 0 */
){
  Expr *pNew;
  
// ABS Label 442
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}
sqlite3 *db = pParse->db;
  assert( pToken );
  pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);
  
// ABS Label 445
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// ROR Label 446
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 446);
}
if( pNew==0 ){
    
// ABS Label 447
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 447);
}

// ABS Label 448
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 448);
}
sqlite3ExprListDelete(db, pList); /* Avoid memory leak when malloc fails */
    return 0;
  }
  
// ABS Label 449
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}
// ABS Label 450
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}
// ABS Label 451
if(pParse->db->aLimit[6] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 451);
}

// COR Label 452
if((pList && pList->nExpr > pParse->db->aLimit[6] || !pParse->nested) != (pList && pList->nExpr > pParse->db->aLimit[6] && !pParse->nested))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 452);
}
// COR Label 453
if((pList || pList->nExpr > pParse->db->aLimit[6]) != (pList && pList->nExpr > pParse->db->aLimit[6]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 453);
}

// ROR Label 454
if((pList->nExpr <= pParse->db->aLimit[6]) != (pList->nExpr > pParse->db->aLimit[6]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 454);
}
// ROR Label 455
if((pList->nExpr < pParse->db->aLimit[6]) != (pList->nExpr > pParse->db->aLimit[6]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}
// ROR Label 456
if((pList->nExpr >= pParse->db->aLimit[6]) != (pList->nExpr > pParse->db->aLimit[6]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 456);
}

// MCC Label 457
if(pList && pList->nExpr > pParse->db->aLimit[6] && !pParse->nested ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 457);
}
// MCC Label 458
if(pList && pList->nExpr > pParse->db->aLimit[6] && !(!pParse->nested) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 458);
}
// MCC Label 459
if(pList && !(pList->nExpr > pParse->db->aLimit[6]) && !pParse->nested ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 459);
}
// MCC Label 460
if(pList && !(pList->nExpr > pParse->db->aLimit[6]) && !(!pParse->nested) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 460);
}
// MCC Label 461
if(!(pList) && pList->nExpr > pParse->db->aLimit[6] && !pParse->nested ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 461);
}
// MCC Label 462
if(!(pList) && pList->nExpr > pParse->db->aLimit[6] && !(!pParse->nested) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 462);
}
// MCC Label 463
if(!(pList) && !(pList->nExpr > pParse->db->aLimit[6]) && !pParse->nested ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 463);
}
// MCC Label 464
if(!(pList) && !(pList->nExpr > pParse->db->aLimit[6]) && !(!pParse->nested) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
if( pList 
   && pList->nExpr > pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG]
   && !pParse->nested
  ){
    
// ABS Label 465
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 465);
}

// ABS Label 466
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}
sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
  }
  pNew->x.pList = pList;
  ExprSetProperty(pNew, EP_HasFunc);
  assert( !ExprHasProperty(pNew, EP_xIsSelect) );
  
// ABS Label 443
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}

// ABS Label 444
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
sqlite3ExprSetHeightAndFlags(pParse, pNew);
  
// ABS Label 467
if(eDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 467);
}

// ROR Label 468
if((eDistinct != 1) != (eDistinct == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 468);
}
if( eDistinct==SF_Distinct ) { ExprSetProperty(pNew, EP_Distinct);
}
  
// ABS Label 469
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 469);
}
return pNew;
}

/*
** Check to see if a function is usable according to current access
** rules:
**
**    SQLITE_FUNC_DIRECT    -     Only usable from top-level SQL
**
**    SQLITE_FUNC_UNSAFE    -     Usable if TRUSTED_SCHEMA or from
**                                top-level SQL
**
** If the function is not usable, create an error.
*/
void sqlite3ExprFunctionUsable(
  Parse *pParse,         /* Parsing and code generating context */
  Expr *pExpr,           /* The function invocation */
  FuncDef *pDef          /* The function being invoked */
){
  assert( !IN_RENAME_OBJECT );
  assert( (pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE))!=0 );
  
// MCC Label 470
if(( ((pExpr)->flags & (1073741824)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 470);
}
// MCC Label 471
if(( !(((pExpr)->flags & (1073741824)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 471);
}
if( ExprHasProperty(pExpr, EP_FromDDL) ){
    
// COR Label 472
if(((pDef->funcFlags & 524288) != 0 && (pParse->db->flags & 128) == 0) != ((pDef->funcFlags & 524288) != 0 || (pParse->db->flags & 128) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 472);
}

// ROR Label 473
if(((pDef->funcFlags & 524288) == 0) != ((pDef->funcFlags & 524288) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 473);
}
// ROR Label 474
if(((pParse->db->flags & 128) != 0) != ((pParse->db->flags & 128) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 474);
}

// MCC Label 475
if((pDef->funcFlags & 524288) != 0 && (pParse->db->flags & 128) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 475);
}
// MCC Label 476
if((pDef->funcFlags & 524288) != 0 && !((pParse->db->flags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 476);
}
// MCC Label 477
if(!((pDef->funcFlags & 524288) != 0) && (pParse->db->flags & 128) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 477);
}
// MCC Label 478
if(!((pDef->funcFlags & 524288) != 0) && !((pParse->db->flags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 478);
}
if( (pDef->funcFlags & SQLITE_FUNC_DIRECT)!=0
     || (pParse->db->flags & SQLITE_TrustedSchema)==0
    ){
      /* Functions prohibited in triggers and views if:
      **     (1) tagged with SQLITE_DIRECTONLY
      **     (2) not tagged with SQLITE_INNOCUOUS (which means it
      **         is tagged with SQLITE_FUNC_UNSAFE) and 
      **         SQLITE_DBCONFIG_TRUSTED_SCHEMA is off (meaning
      **         that the schema is possibly tainted).
      */
      
// ABS Label 479
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// ABS Label 480
if(pDef->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}
sqlite3ErrorMsg(pParse, "unsafe use of %s()", pDef->zName);
    }
  }
}

/*
** Assign a variable number to an expression that encodes a wildcard
** in the original SQL statement.  
**
** Wildcards consisting of a single "?" are assigned the next sequential
** variable number.
**
** Wildcards of the form "?nnn" are assigned the number "nnn".  We make
** sure "nnn" is not too big to avoid a denial of service attack when
** the SQL statement comes from an external source.
**
** Wildcards of the form ":aaa", "@aaa", or "$aaa" are assigned the same number
** as the previous instance of the same wildcard.  Or if this is the first
** instance of the wildcard, the next sequential variable number is
** assigned.
*/
void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){
  
// ABS Label 481
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}
sqlite3 *db = pParse->db;
  const char *z;
  ynVar x;

  
// ABS Label 482
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}

// ROR Label 483
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 483);
}
if( pExpr==0 ) { return;
}
  assert( !ExprHasProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );
  z = pExpr->u.zToken;
  assert( z!=0 );
  assert( z[0]!=0 );
  assert( n==(u32)sqlite3Strlen30(z) );
  
// ROR Label 484
if((z[1] != 0) != (z[1] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 484);
}
if( z[1]==0 ){
    /* Wildcard of the form "?".  Assign the next variable number */
    assert( z[0]=='?' );
    x = (ynVar)(++pParse->nVar);
  }else{
    int doAdd = 0;
    
// ROR Label 485
if((z[0] != '?') != (z[0] == '?'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 485);
}
if( z[0]=='?' ){
      /* Wildcard of the form "?nnn".  Convert "nnn" to an integer and
      ** use it as the variable number */
      i64 i;
      int bOk;
      
// ABS Label 486
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}

// ROR Label 487
if((n != 2) != (n == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 487);
}
if( n==2 ){ /*OPTIMIZATION-IF-TRUE*/
        i = z[1]-'0';  /* The common case of ?N for a single digit N */
        bOk = 1;
      }else{
        bOk = 0==sqlite3Atoi64(&z[1], &i, n-1, SQLITE_UTF8);
      }
      testcase( i==0 );
      testcase( i==1 );
      testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]-1 );
      testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );
      
// ABS Label 488
if(bOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
// ABS Label 489
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}

// COR Label 490
if((bOk == 0 || i < 1 && i > db->aLimit[9]) != (bOk == 0 || i < 1 || i > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 490);
}
// COR Label 491
if((bOk == 0 && i < 1) != (bOk == 0 || i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 491);
}

// ROR Label 492
if((bOk != 0) != (bOk == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 492);
}
// ROR Label 493
if((i <= 1) != (i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}
// ROR Label 494
if((i > 1) != (i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
// ROR Label 495
if((i >= 1) != (i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}
// ROR Label 496
if((i <= db->aLimit[9]) != (i > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 496);
}
// ROR Label 497
if((i < db->aLimit[9]) != (i > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 497);
}
// ROR Label 498
if((i >= db->aLimit[9]) != (i > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}

// MCC Label 499
if(bOk == 0 && i < 1 && i > db->aLimit[9] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
// MCC Label 500
if(bOk == 0 && i < 1 && !(i > db->aLimit[9]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(bOk == 0 && !(i < 1) && i > db->aLimit[9] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(bOk == 0 && !(i < 1) && !(i > db->aLimit[9]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(!(bOk == 0) && i < 1 && i > db->aLimit[9] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
// MCC Label 504
if(!(bOk == 0) && i < 1 && !(i > db->aLimit[9]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
// MCC Label 505
if(!(bOk == 0) && !(i < 1) && i > db->aLimit[9] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(!(bOk == 0) && !(i < 1) && !(i > db->aLimit[9]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
if( bOk==0 || i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){
        
// ABS Label 507
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 507);
}

// ABS Label 508
if(db->aLimit[9] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}
sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d",
            db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);
        return;
      }
      x = (ynVar)i;
      
// ROR Label 509
if((x <= pParse->nVar) != (x > pParse->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 509);
}
// ROR Label 510
if((x < pParse->nVar) != (x > pParse->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 510);
}
// ROR Label 511
if((x >= pParse->nVar) != (x > pParse->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 511);
}
if( x>pParse->nVar ){
        pParse->nVar = (int)x;
        doAdd = 1;
      }else { if( sqlite3VListNumToName(pParse->pVList, x)==0 ){
        doAdd = 1;
      };}

    }else{
      /* Wildcards like ":aaa", "$aaa" or "@aaa".  Reuse the same variable
      ** number as the prior appearance of the same name, or if the name
      ** has never appeared before, reuse the same variable number
      */
      x = (ynVar)sqlite3VListNameToNum(pParse->pVList, z, n);
      
// ROR Label 512
if((x != 0) != (x == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 512);
}
if( x==0 ){
        x = (ynVar)(++pParse->nVar);
        doAdd = 1;
      }
    }
    
// ABS Label 513
if(doAdd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}
if( doAdd ){
      pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, n, x);
    }
  }
  pExpr->iColumn = x;
  
// ABS Label 514
if(db->aLimit[9] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}

// ROR Label 515
if((x <= db->aLimit[9]) != (x > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 515);
}
// ROR Label 516
if((x < db->aLimit[9]) != (x > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 516);
}
// ROR Label 517
if((x >= db->aLimit[9]) != (x > db->aLimit[9]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 517);
}
if( x>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){
    
// ABS Label 518
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}
sqlite3ErrorMsg(pParse, "too many SQL variables");
  }
}

/*
** Recursively delete an expression tree.
*/
static SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){
  assert( p!=0 );
  /* Sanity check: Assert that the IntValue is non-negative if it exists */
  assert( !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 );

  assert( !ExprHasProperty(p, EP_WinFunc) || p->y.pWin!=0 || db->mallocFailed );
  assert( p->op!=TK_FUNCTION || ExprHasProperty(p, EP_TokenOnly|EP_Reduced)
          || p->y.pWin==0 || ExprHasProperty(p, EP_WinFunc) );
#ifdef SQLITE_DEBUG
  if( ExprHasProperty(p, EP_Leaf) && !ExprHasProperty(p, EP_TokenOnly) ){
    assert( p->pLeft==0 );
    assert( p->pRight==0 );
    assert( p->x.pSelect==0 );
  }
#endif
  if( !ExprHasProperty(p, (EP_TokenOnly|EP_Leaf)) ){
    /* The Expr.x union is never used at the same time as Expr.pRight */
    assert( p->x.pList==0 || p->pRight==0 );
    
// ABS Label 519
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}

// COR Label 520
if((p->pLeft || p->op != 177) != (p->pLeft && p->op != 177))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 520);
}

// ROR Label 521
if((p->op == 177) != (p->op != 177))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 521);
}

// MCC Label 522
if(p->pLeft && p->op != 177 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 522);
}
// MCC Label 523
if(p->pLeft && !(p->op != 177) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 523);
}
// MCC Label 524
if(!(p->pLeft) && p->op != 177 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 524);
}
// MCC Label 525
if(!(p->pLeft) && !(p->op != 177) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 525);
}
if( p->pLeft && p->op!=TK_SELECT_COLUMN ) { 
// ABS Label 526
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// ABS Label 527
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}
sqlite3ExprDeleteNN(db, p->pLeft);
}
    
// ABS Label 528
if(p->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}
if( p->pRight ){
      assert( !ExprHasProperty(p, EP_WinFunc) );
      
// ABS Label 529
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// ABS Label 530
if(p->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}
sqlite3ExprDeleteNN(db, p->pRight);
    }else { 
// MCC Label 531
if(( ((p)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 531);
}
// MCC Label 532
if(( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 532);
}
if( ExprHasProperty(p, EP_xIsSelect) ){
      assert( !ExprHasProperty(p, EP_WinFunc) );
      
// ABS Label 533
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}

// ABS Label 534
if(p->x.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}
sqlite3SelectDelete(db, p->x.pSelect);
    }else{
      
// ABS Label 535
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}

// ABS Label 536
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}
sqlite3ExprListDelete(db, p->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
      
// MCC Label 537
if(( ((p)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 537);
}
// MCC Label 538
if(( !(((p)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 538);
}
if( ExprHasProperty(p, EP_WinFunc) ){
        
// ABS Label 539
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}

// ABS Label 540
if(p->y.pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}
sqlite3WindowDelete(db, p->y.pWin);
      }
#endif
    };}

  }
  
// MCC Label 541
if(( ((p)->flags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
// MCC Label 542
if(( !(((p)->flags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 542);
}
if( ExprHasProperty(p, EP_MemToken) ) { 
// ABS Label 543
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}
sqlite3DbFree(db, p->u.zToken);
}
  if( !ExprHasProperty(p, EP_Static) ){
    
// ABS Label 544
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 544);
}
sqlite3DbFreeNN(db, p);
  }
}
void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  
// ABS Label 545
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}
if( p ) { 
// ABS Label 546
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}

// ABS Label 547
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}
sqlite3ExprDeleteNN(db, p);
}
}


/*
** Arrange to cause pExpr to be deleted when the pParse is deleted.
** This is similar to sqlite3ExprDelete() except that the delete is
** deferred untilthe pParse is deleted.
**
** The pExpr might be deleted immediately on an OOM error.
**
** The deferred delete is (currently) implemented by adding the
** pExpr to the pParse->pConstExpr list with a register number of 0.
*/
void sqlite3ExprDeferredDelete(Parse *pParse, Expr *pExpr){
  pParse->pConstExpr = 
      sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);
}

/* Invoke sqlite3RenameExprUnmap() and sqlite3ExprDelete() on the
** expression.
*/
void sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){
  
// ABS Label 548
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}
if( p ){
    
// MCC Label 551
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 551);
}
// MCC Label 552
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 552);
}
if( IN_RENAME_OBJECT ){
      
// ABS Label 553
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}

// ABS Label 554
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}
sqlite3RenameExprUnmap(pParse, p);
    }
    
// ABS Label 549
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}

// ABS Label 550
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}
sqlite3ExprDeleteNN(pParse->db, p);
  }
}

/*
** Return the number of bytes allocated for the expression structure 
** passed as the first argument. This is always one of EXPR_FULLSIZE,
** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.
*/
static int exprStructSize(Expr *p){
  
// MCC Label 555
if(( ((p)->flags & (16384)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 555);
}
// MCC Label 556
if(( !(((p)->flags & (16384)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 556);
}
if( ExprHasProperty(p, EP_TokenOnly) ) { return EXPR_TOKENONLYSIZE;
}
  
// MCC Label 557
if(( ((p)->flags & (8192)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 557);
}
// MCC Label 558
if(( !(((p)->flags & (8192)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 558);
}
if( ExprHasProperty(p, EP_Reduced) ) { return EXPR_REDUCEDSIZE;
}
  return EXPR_FULLSIZE;
}

/*
** The dupedExpr*Size() routines each return the number of bytes required
** to store a copy of an expression or expression tree.  They differ in
** how much of the tree is measured.
**
**     dupedExprStructSize()     Size of only the Expr structure 
**     dupedExprNodeSize()       Size of Expr + space for token
**     dupedExprSize()           Expr + token + subtree components
**
***************************************************************************
**
** The dupedExprStructSize() function returns two values OR-ed together:  
** (1) the space required for a copy of the Expr structure only and 
** (2) the EP_xxx flags that indicate what the structure size should be.
** The return values is always one of:
**
**      EXPR_FULLSIZE
**      EXPR_REDUCEDSIZE   | EP_Reduced
**      EXPR_TOKENONLYSIZE | EP_TokenOnly
**
** The size of the structure can be found by masking the return value
** of this routine with 0xfff.  The flags can be found by masking the
** return value with EP_Reduced|EP_TokenOnly.
**
** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size
** (unreduced) Expr objects as they or originally constructed by the parser.
** During expression analysis, extra information is computed and moved into
** later parts of the Expr object and that extra information might get chopped
** off if the expression is reduced.  Note also that it does not work to
** make an EXPRDUP_REDUCE copy of a reduced expression.  It is only legal
** to reduce a pristine expression tree from the parser.  The implementation
** of dupedExprStructSize() contain multiple assert() statements that attempt
** to enforce this constraint.
*/
static int dupedExprStructSize(Expr *p, int flags){
  int nSize;
  assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */
  assert( EXPR_FULLSIZE<=0xfff );
  assert( (0xfff & (EP_Reduced|EP_TokenOnly))==0 );
  
// ABS Label 559
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 559);
}

// COR Label 560
if((0 == flags || p->op == 177 && (((p)->flags & (16777216)) != 0)) != (0 == flags || p->op == 177 || (((p)->flags & (16777216)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 560);
}
// COR Label 561
if((0 == flags && p->op == 177) != (0 == flags || p->op == 177))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 561);
}

// ROR Label 562
if((0 != flags) != (0 == flags))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 562);
}
// ROR Label 563
if((p->op != 177) != (p->op == 177))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 563);
}

// MCC Label 564
if(0 == flags && p->op == 177 && ( ((p)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 564);
}
// MCC Label 565
if(0 == flags && p->op == 177 && ( !(((p)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 565);
}
// MCC Label 566
if(0 == flags && !(p->op == 177) && ( ((p)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 566);
}
// MCC Label 567
if(0 == flags && !(p->op == 177) && ( !(((p)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 567);
}
// MCC Label 568
if(!(0 == flags) && p->op == 177 && ( ((p)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 568);
}
// MCC Label 569
if(!(0 == flags) && p->op == 177 && ( !(((p)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 569);
}
// MCC Label 570
if(!(0 == flags) && !(p->op == 177) && ( ((p)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 570);
}
// MCC Label 571
if(!(0 == flags) && !(p->op == 177) && ( !(((p)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 571);
}
if( 0==flags || p->op==TK_SELECT_COLUMN 
#ifndef SQLITE_OMIT_WINDOWFUNC
   || ExprHasProperty(p, EP_WinFunc)
#endif
  ){
    nSize = EXPR_FULLSIZE;
  }else{
    assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );
    assert( !ExprHasProperty(p, EP_FromJoin) ); 
    assert( !ExprHasProperty(p, EP_MemToken) );
    assert( !ExprHasVVAProperty(p, EP_NoReduce) );
    
// ABS Label 572
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 572);
}
// ABS Label 573
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}

// COR Label 574
if((p->pLeft && p->x.pList) != (p->pLeft || p->x.pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 574);
}

// MCC Label 575
if(p->pLeft && p->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(p->pLeft && !(p->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
// MCC Label 577
if(!(p->pLeft) && p->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 577);
}
// MCC Label 578
if(!(p->pLeft) && !(p->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
if( p->pLeft || p->x.pList ){
      nSize = EXPR_REDUCEDSIZE | EP_Reduced;
    }else{
      assert( p->pRight==0 );
      nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;
    }
  }
  
// ABS Label 579
if(nSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}
return nSize;
}

/*
** This function returns the space in bytes required to store the copy 
** of the Expr structure and a copy of the Expr.u.zToken string (if that
** string is defined.)
*/
static int dupedExprNodeSize(Expr *p, int flags){
  int nByte = dupedExprStructSize(p, flags) & 0xfff;
  
// ABS Label 580
if(p->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 580);
}

// COR Label 581
if((!(((p)->flags & (1024)) != 0) || p->u.zToken) != (!(((p)->flags & (1024)) != 0) && p->u.zToken))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 581);
}

// MCC Label 582
if(!(((p)->flags & (1024)) != 0) && p->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(!(((p)->flags & (1024)) != 0) && !(p->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(!(!(((p)->flags & (1024)) != 0)) && p->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(!(!(((p)->flags & (1024)) != 0)) && !(p->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){
    nByte += sqlite3Strlen30NN(p->u.zToken)+1;
  }
  
// MCC Label 586
if(( ((nByte) + 7) & ~7 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 586);
}
// MCC Label 587
if(( !(((nByte) + 7) & ~7) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 587);
}
return ROUND8(nByte);
}

/*
** Return the number of bytes required to create a duplicate of the 
** expression passed as the first argument. The second argument is a
** mask containing EXPRDUP_XXX flags.
**
** The value returned includes space to create a copy of the Expr struct
** itself and the buffer referred to by Expr.u.zToken, if any.
**
** If the EXPRDUP_REDUCE flag is set, then the return value includes 
** space to duplicate all Expr nodes in the tree formed by Expr.pLeft 
** and Expr.pRight variables (but not for any structures pointed to or 
** descended from the Expr.x.pList or Expr.x.pSelect variables).
*/
static int dupedExprSize(Expr *p, int flags){
  int nByte = 0;
  
// ABS Label 588
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 588);
}
if( p ){
    nByte = dupedExprNodeSize(p, flags);
    
// ABS Label 589
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}

// AOR Label 590
if(flags | 1 != flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 590);
}
// AOR Label 591
if(flags ^ 1 != flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 591);
}
if( flags&EXPRDUP_REDUCE ){
      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);
    }
  }
  
// ABS Label 592
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 592);
}
return nByte;
}

/*
** This function is similar to sqlite3ExprDup(), except that if pzBuffer 
** is not NULL then *pzBuffer is assumed to point to a buffer large enough 
** to store the copy of expression p, the copies of p->u.zToken
** (if applicable), and the copies of the p->pLeft and p->pRight expressions,
** if any. Before returning, *pzBuffer is set to the first byte past the
** portion of the buffer copied into by this function.
*/
static Expr *exprDup(sqlite3 *db, Expr *p, int dupFlags, u8 **pzBuffer){
  Expr *pNew;           /* Value to return */
  u8 *zAlloc;           /* Memory space from which to build Expr object */
  u32 staticFlag;       /* EP_Static if space not obtained from malloc */

  assert( db!=0 );
  assert( p );
  assert( dupFlags==0 || dupFlags==EXPRDUP_REDUCE );
  assert( pzBuffer==0 || dupFlags==EXPRDUP_REDUCE );

  /* Figure out where to write the new Expr structure. */
  
// ABS Label 593
if(pzBuffer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 593);
}
if( pzBuffer ){
    zAlloc = *pzBuffer;
    staticFlag = EP_Static;
    assert( zAlloc!=0 );
  }else{
    zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));
    staticFlag = 0;
  }
  pNew = (Expr *)zAlloc;

  
// ABS Label 594
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 594);
}
if( pNew ){
    /* Set nNewSize to the size allocated for the structure pointed to
    ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or
    ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed
    ** by the copy of the p->u.zToken string (if any).
    */
    const unsigned nStructSize = dupedExprStructSize(p, dupFlags);
    const int nNewSize = nStructSize & 0xfff;
    int nToken;
    
// ABS Label 595
if(p->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 595);
}

// COR Label 596
if((!(((p)->flags & (1024)) != 0) || p->u.zToken) != (!(((p)->flags & (1024)) != 0) && p->u.zToken))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 596);
}

// MCC Label 597
if(!(((p)->flags & (1024)) != 0) && p->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(!(((p)->flags & (1024)) != 0) && !(p->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}
// MCC Label 599
if(!(!(((p)->flags & (1024)) != 0)) && p->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 599);
}
// MCC Label 600
if(!(!(((p)->flags & (1024)) != 0)) && !(p->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 600);
}
if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){
      nToken = sqlite3Strlen30(p->u.zToken) + 1;
    }else{
      nToken = 0;
    }
    
// ABS Label 601
if(dupFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 601);
}
if( dupFlags ){
      assert( ExprHasProperty(p, EP_Reduced)==0 );
      memcpy(zAlloc, p, nNewSize);
    }else{
      u32 nSize = (u32)exprStructSize(p);
      memcpy(zAlloc, p, nSize);
      
// ROR Label 602
if((nSize <= sizeof(Expr)) != (nSize < sizeof(Expr)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 602);
}
// ROR Label 603
if((nSize > sizeof(Expr)) != (nSize < sizeof(Expr)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 603);
}
// ROR Label 604
if((nSize >= sizeof(Expr)) != (nSize < sizeof(Expr)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 604);
}
if( nSize<EXPR_FULLSIZE ){ 
        
// AOR Label 605
if(sizeof(Expr) / nSize != sizeof(Expr) - nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 605);
}
// AOR Label 606
if(sizeof(Expr) + nSize != sizeof(Expr) - nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 606);
}
// AOR Label 607
if(sizeof(Expr) * nSize != sizeof(Expr) - nSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 607);
}
memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);
      }
    }

    /* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */
    pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);
    pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);
    pNew->flags |= staticFlag;
    ExprClearVVAProperties(pNew);
    
// ABS Label 608
if(dupFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}
if( dupFlags ){
      ExprSetVVAProperty(pNew, EP_Immutable);
    }

    /* Copy the p->u.zToken string, if any. */
    
// ABS Label 609
if(nToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}
if( nToken ){
      char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];
      memcpy(zToken, p->u.zToken, nToken);
    }

    
// ROR Label 610
if((0 != ((p->flags | pNew->flags) & (16384 | 8388608))) != (0 == ((p->flags | pNew->flags) & (16384 | 8388608))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}
if( 0==((p->flags|pNew->flags) & (EP_TokenOnly|EP_Leaf)) ){
      /* Fill in the pNew->x.pSelect or pNew->x.pList member. */
      
// MCC Label 611
if(( ((p)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 611);
}
// MCC Label 612
if(( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 612);
}
if( ExprHasProperty(p, EP_xIsSelect) ){
        pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);
      }else{
        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);
      }
    }

    /* Fill in pNew->pLeft and pNew->pRight. */
    
// MCC Label 613
if(( ((pNew)->flags & (8192 | 16384 | 16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 613);
}
// MCC Label 614
if(( !(((pNew)->flags & (8192 | 16384 | 16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 614);
}
if( ExprHasProperty(pNew, EP_Reduced|EP_TokenOnly|EP_WinFunc) ){
      zAlloc += dupedExprNodeSize(p, dupFlags);
      if( !ExprHasProperty(pNew, EP_TokenOnly|EP_Leaf) ){
        pNew->pLeft = p->pLeft ?
                      exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc) : 0;
        pNew->pRight = p->pRight ?
                       exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc) : 0;
      }
#ifndef SQLITE_OMIT_WINDOWFUNC
      
// MCC Label 615
if(( ((p)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 615);
}
// MCC Label 616
if(( !(((p)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 616);
}
if( ExprHasProperty(p, EP_WinFunc) ){
        pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);
        assert( ExprHasProperty(pNew, EP_WinFunc) );
      }
#endif /* SQLITE_OMIT_WINDOWFUNC */
      
// ABS Label 617
if(pzBuffer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}
if( pzBuffer ){
        *pzBuffer = zAlloc;
      }
    }else{
      if( !ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){
        
// ROR Label 618
if((pNew->op != 177) != (pNew->op == 177))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 618);
}
if( pNew->op==TK_SELECT_COLUMN ){
          pNew->pLeft = p->pLeft;
          assert( p->pRight==0  || p->pRight==p->pLeft
                                || ExprHasProperty(p->pLeft, EP_Subquery) );
        }else{
          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);
        }
        pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);
      }
    }
  }
  
// ABS Label 619
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}
return pNew;
}

/*
** Create and return a deep copy of the object passed as the second 
** argument. If an OOM condition is encountered, NULL is returned
** and the db->mallocFailed flag set.
*/
#ifndef SQLITE_OMIT_CTE
With *sqlite3WithDup(sqlite3 *db, With *p){
  With *pRet = 0;
  
// ABS Label 620
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 620);
}
if( p ){
    sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);
    pRet = sqlite3DbMallocZero(db, nByte);
    
// ABS Label 621
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 621);
}
if( pRet ){
      int i;
      pRet->nCte = p->nCte;
      i = 0;

// ABS Label 622
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 622);
}
// ABS Label 623
if(p->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}

// ROR Label 624
if((i <= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 624);
}
// ROR Label 625
if((i > p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}
// ROR Label 626
if((i >= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 626);
}
for(; i<p->nCte; i++){
        pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);
        pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);
        pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);
      };
// ABS Label 627
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 627);
}
// ABS Label 628
if(p->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}

// ROR Label 629
if((i <= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 629);
}
// ROR Label 630
if((i > p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 630);
}
// ROR Label 631
if((i >= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}

    }
  }
  
// ABS Label 632
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 632);
}
return pRet;
}
#else
# define sqlite3WithDup(x,y) 0
#endif

#ifndef SQLITE_OMIT_WINDOWFUNC
/*
** The gatherSelectWindows() procedure and its helper routine
** gatherSelectWindowsCallback() are used to scan all the expressions
** an a newly duplicated SELECT statement and gather all of the Window
** objects found there, assembling them onto the linked list at Select->pWin.
*/
static int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){
  
// COR Label 633
if((pExpr->op == 171 || (((pExpr)->flags & (16777216)) != 0)) != (pExpr->op == 171 && (((pExpr)->flags & (16777216)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 633);
}

// ROR Label 634
if((pExpr->op != 171) != (pExpr->op == 171))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 634);
}

// MCC Label 635
if(pExpr->op == 171 && ( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 635);
}
// MCC Label 636
if(pExpr->op == 171 && ( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 636);
}
// MCC Label 637
if(!(pExpr->op == 171) && ( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 637);
}
// MCC Label 638
if(!(pExpr->op == 171) && ( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 638);
}
if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_WinFunc) ){
    
// ABS Label 639
if(pWalker->u.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}
Select *pSelect = pWalker->u.pSelect;
    
// ABS Label 640
if(pExpr->y.pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 640);
}
Window *pWin = pExpr->y.pWin;
    assert( pWin );
    assert( IsWindowFunc(pExpr) );
    assert( pWin->ppThis==0 );
    
// ABS Label 641
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}

// ABS Label 642
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 642);
}
sqlite3WindowLink(pSelect, pWin);
  }
  return WRC_Continue;
}
static int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){
  return p==pWalker->u.pSelect ? WRC_Continue : WRC_Prune;
}
static void gatherSelectWindows(Select *p){
  Walker w;
  w.xExprCallback = gatherSelectWindowsCallback;
  w.xSelectCallback = gatherSelectWindowsSelectCallback;
  w.xSelectCallback2 = 0;
  w.pParse = 0;
  w.u.pSelect = p;
  
// ABS Label 643
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}
sqlite3WalkSelect(&w, p);
}
#endif


/*
** The following group of routines make deep copies of expressions,
** expression lists, ID lists, and select statements.  The copies can
** be deleted (by being passed to their respective ...Delete() routines)
** without effecting the originals.
**
** The expression list, ID, and source lists return by sqlite3ExprListDup(),
** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded 
** by subsequent calls to sqlite*ListAppend() routines.
**
** Any tables that the SrcList might point to are not duplicated.
**
** The flags parameter contains a combination of the EXPRDUP_XXX flags.
** If the EXPRDUP_REDUCE flag is set, then the structure returned is a
** truncated version of the usual Expr structure that will be stored as
** part of the in-memory representation of the database schema.
*/
Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){
  assert( flags==0 || flags==EXPRDUP_REDUCE );
  return p ? exprDup(db, p, flags, 0) : 0;
}
ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){
  ExprList *pNew;
  struct ExprList_item *pItem, *pOldItem;
  int i;
  Expr *pPriorSelectColOld = 0;
  Expr *pPriorSelectColNew = 0;
  assert( db!=0 );
  
// ABS Label 644
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}

// ROR Label 645
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 645);
}
if( p==0 ) { return 0;
}
  pNew = sqlite3DbMallocRawNN(db, sqlite3DbMallocSize(db, p));
  
// ABS Label 646
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}

// ROR Label 647
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 647);
}
if( pNew==0 ) { return 0;
}
  pNew->nExpr = p->nExpr;
  pNew->nAlloc = p->nAlloc;
  pItem = pNew->a;
  pOldItem = p->a;
  i = 0;

// ABS Label 648
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}
// ABS Label 649
if(p->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}

// ROR Label 650
if((i <= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 650);
}
// ROR Label 651
if((i > p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}
// ROR Label 652
if((i >= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 652);
}
for(; i<p->nExpr; i++, pItem++, pOldItem++){
    
// ABS Label 658
if(pOldItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
Expr *pOldExpr = pOldItem->pExpr;
    Expr *pNewExpr;
    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);
    if( pOldExpr 
     && pOldExpr->op==TK_SELECT_COLUMN
     && (pNewExpr = pItem->pExpr)!=0 
    ){
      
// ABS Label 659
if(pNewExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}
if( pNewExpr->pRight ){
        pPriorSelectColOld = pOldExpr->pRight;
        pPriorSelectColNew = pNewExpr->pRight;
        pNewExpr->pLeft = pNewExpr->pRight;
      }else{
        
// ABS Label 660
if(pOldExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}
// ABS Label 661
if(pPriorSelectColOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}

// ROR Label 662
if((pOldExpr->pLeft == pPriorSelectColOld) != (pOldExpr->pLeft != pPriorSelectColOld))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
if( pOldExpr->pLeft!=pPriorSelectColOld ){
          pPriorSelectColOld = pOldExpr->pLeft;
          pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, flags);
          pNewExpr->pRight = pPriorSelectColNew;
        }
        pNewExpr->pLeft = pPriorSelectColNew;
      }
    }
    pItem->zEName = sqlite3DbStrDup(db, pOldItem->zEName);
    pItem->sortFlags = pOldItem->sortFlags;
    pItem->eEName = pOldItem->eEName;
    pItem->done = 0;
    pItem->bNulls = pOldItem->bNulls;
    pItem->bSorterRef = pOldItem->bSorterRef;
    pItem->u = pOldItem->u;
  };
// ABS Label 653
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}
// ABS Label 654
if(p->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}

// ROR Label 655
if((i <= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 655);
}
// ROR Label 656
if((i > p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 656);
}
// ROR Label 657
if((i >= p->nExpr) != (i < p->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 657);
}

  
// ABS Label 663
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}
return pNew;
}

/*
** If cursors, triggers, views and subqueries are all omitted from
** the build, then none of the following routines, except for 
** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes
** called with a NULL argument.
*/
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) \
 || !defined(SQLITE_OMIT_SUBQUERY)
SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){
  SrcList *pNew;
  int i;
  int nByte;
  assert( db!=0 );
  
// ABS Label 664
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 664);
}

// ROR Label 665
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 665);
}
if( p==0 ) { return 0;
}
  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);
  pNew = sqlite3DbMallocRawNN(db, nByte );
  
// ABS Label 666
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ROR Label 667
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
if( pNew==0 ) { return 0;
}
  pNew->nSrc = pNew->nAlloc = p->nSrc;
  i = 0;

// ABS Label 668
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}
// ABS Label 669
if(p->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}

// ROR Label 670
if((i <= p->nSrc) != (i < p->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 670);
}
// ROR Label 671
if((i > p->nSrc) != (i < p->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 671);
}
// ROR Label 672
if((i >= p->nSrc) != (i < p->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 672);
}
for(; i<p->nSrc; i++){
    SrcItem *pNewItem = &pNew->a[i];
    SrcItem *pOldItem = &p->a[i];
    Table *pTab;
    pNewItem->pSchema = pOldItem->pSchema;
    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);
    pNewItem->fg = pOldItem->fg;
    pNewItem->iCursor = pOldItem->iCursor;
    pNewItem->addrFillSub = pOldItem->addrFillSub;
    pNewItem->regReturn = pOldItem->regReturn;
    
// ABS Label 678
if(pNewItem->fg.isIndexedBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
if( pNewItem->fg.isIndexedBy ){
      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);
    }
    pNewItem->u2 = pOldItem->u2;
    
// ABS Label 679
if(pNewItem->fg.isCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}
if( pNewItem->fg.isCte ){
      pNewItem->u2.pCteUse->nUse++;
    }
    
// ABS Label 680
if(pNewItem->fg.isTabFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}
if( pNewItem->fg.isTabFunc ){
      pNewItem->u1.pFuncArg = 
          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);
    }
    pTab = pNewItem->pTab = pOldItem->pTab;
    
// ABS Label 681
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}
if( pTab ){
      pTab->nTabRef++;
    }
    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);
    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);
    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);
    pNewItem->colUsed = pOldItem->colUsed;
  };
// ABS Label 673
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}
// ABS Label 674
if(p->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}

// ROR Label 675
if((i <= p->nSrc) != (i < p->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 675);
}
// ROR Label 676
if((i > p->nSrc) != (i < p->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 676);
}
// ROR Label 677
if((i >= p->nSrc) != (i < p->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 677);
}

  
// ABS Label 682
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 682);
}
return pNew;
}
IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){
  IdList *pNew;
  int i;
  assert( db!=0 );
  
// ABS Label 683
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}

// ROR Label 684
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 684);
}
if( p==0 ) { return 0;
}
  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );
  
// ABS Label 685
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}

// ROR Label 686
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 686);
}
if( pNew==0 ) { return 0;
}
  pNew->nId = p->nId;
  pNew->a = sqlite3DbMallocRawNN(db, p->nId*sizeof(p->a[0]) );
  
// ABS Label 687
if(pNew->a < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}

// ROR Label 688
if((pNew->a != 0) != (pNew->a == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 688);
}
if( pNew->a==0 ){
    
// ABS Label 689
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}
sqlite3DbFreeNN(db, pNew);
    return 0;
  }
  /* Note that because the size of the allocation for p->a[] is not
  ** necessarily a power of two, sqlite3IdListAppend() may not be called
  ** on the duplicate created by this function. */
  i = 0;

// ABS Label 690
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}
// ABS Label 691
if(p->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}

// ROR Label 692
if((i <= p->nId) != (i < p->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 692);
}
// ROR Label 693
if((i > p->nId) != (i < p->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 693);
}
// ROR Label 694
if((i >= p->nId) != (i < p->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 694);
}
for(; i<p->nId; i++){
    struct IdList_item *pNewItem = &pNew->a[i];
    struct IdList_item *pOldItem = &p->a[i];
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->idx = pOldItem->idx;
  };
// ABS Label 695
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}
// ABS Label 696
if(p->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}

// ROR Label 697
if((i <= p->nId) != (i < p->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 697);
}
// ROR Label 698
if((i > p->nId) != (i < p->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 698);
}
// ROR Label 699
if((i >= p->nId) != (i < p->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}

  
// ABS Label 700
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}
return pNew;
}
Select *sqlite3SelectDup(sqlite3 *db, Select *pDup, int flags){
  Select *pRet = 0;
  Select *pNext = 0;
  Select **pp = &pRet;
  Select *p;

  assert( db!=0 );
  p = pDup;

// ABS Label 701
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}
for(; p; p=p->pPrior){
    Select *pNew = sqlite3DbMallocRawNN(db, sizeof(*p) );
    
// ABS Label 703
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 703);
}

// ROR Label 704
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 704);
}
if( pNew==0 ) { break;
}
    pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);
    pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);
    pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);
    pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);
    pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);
    pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);
    pNew->op = p->op;
    pNew->pNext = pNext;
    pNew->pPrior = 0;
    pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);
    pNew->iLimit = 0;
    pNew->iOffset = 0;
    pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;
    pNew->addrOpenEphm[0] = -1;
    pNew->addrOpenEphm[1] = -1;
    pNew->nSelectRow = p->nSelectRow;
    pNew->pWith = sqlite3WithDup(db, p->pWith);
#ifndef SQLITE_OMIT_WINDOWFUNC
    pNew->pWin = 0;
    pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);
    
// ABS Label 705
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}

// COR Label 706
if((p->pWin || db->mallocFailed == 0) != (p->pWin && db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 706);
}

// ROR Label 707
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 707);
}

// MCC Label 708
if(p->pWin && db->mallocFailed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 708);
}
// MCC Label 709
if(p->pWin && !(db->mallocFailed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 709);
}
// MCC Label 710
if(!(p->pWin) && db->mallocFailed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 710);
}
// MCC Label 711
if(!(p->pWin) && !(db->mallocFailed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 711);
}
if( p->pWin && db->mallocFailed==0 ) { 
// ABS Label 712
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}
gatherSelectWindows(pNew);
}
#endif
    pNew->selId = p->selId;
    
// ABS Label 713
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 713);
}
if( db->mallocFailed ){
      /* Any prior OOM might have left the Select object incomplete.
      ** Delete the whole thing rather than allow an incomplete Select
      ** to be used by the code generator. */
      pNew->pNext = 0;
      
// ABS Label 714
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}

// ABS Label 715
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 715);
}
sqlite3SelectDelete(db, pNew);
      break;
    }
    *pp = pNew;
    pp = &pNew->pPrior;
    pNext = pNew;
  };
// ABS Label 702
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}


  
// ABS Label 716
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}
return pRet;
}
#else
Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){
  assert( p==0 );
  return 0;
}
#endif


/*
** Add a new element to the end of an expression list.  If pList is
** initially NULL, then create a new expression list.
**
** The pList argument must be either NULL or a pointer to an ExprList
** obtained from a prior call to sqlite3ExprListAppend().  This routine
** may not be used with an ExprList obtained from sqlite3ExprListDup().
** Reason:  This routine assumes that the number of slots in pList->a[]
** is a power of two.  That is true for sqlite3ExprListAppend() returns
** but is not necessarily true from the return value of sqlite3ExprListDup().
**
** If a memory allocation error occurs, the entire list is freed and
** NULL is returned.  If non-NULL is returned, then it is guaranteed
** that the new entry was successfully appended.
*/
static const struct ExprList_item zeroItem = {0};
SQLITE_NOINLINE ExprList *sqlite3ExprListAppendNew(
  sqlite3 *db,            /* Database handle.  Used for memory allocation */
  Expr *pExpr             /* Expression to be appended. Might be NULL */
){
  struct ExprList_item *pItem;
  ExprList *pList;

  pList = sqlite3DbMallocRawNN(db, sizeof(ExprList)+sizeof(pList->a[0])*4 );
  
// ABS Label 717
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}

// ROR Label 718
if((pList != 0) != (pList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 718);
}
if( pList==0 ){
    
// ABS Label 719
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}

// ABS Label 720
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 720);
}
sqlite3ExprDelete(db, pExpr);
    return 0;
  }
  pList->nAlloc = 4;
  pList->nExpr = 1;
  pItem = &pList->a[0];
  *pItem = zeroItem;
  pItem->pExpr = pExpr;
  
// ABS Label 721
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}
return pList;
}
SQLITE_NOINLINE ExprList *sqlite3ExprListAppendGrow(
  sqlite3 *db,            /* Database handle.  Used for memory allocation */
  ExprList *pList,        /* List to which to append. Might be NULL */
  Expr *pExpr             /* Expression to be appended. Might be NULL */
){
  struct ExprList_item *pItem;
  ExprList *pNew;
  pList->nAlloc *= 2;
  pNew = sqlite3DbRealloc(db, pList, 
       sizeof(*pList)+(pList->nAlloc-1)*sizeof(pList->a[0]));
  
// ABS Label 722
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 722);
}

// ROR Label 723
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}
if( pNew==0 ){
    
// ABS Label 724
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 724);
}

// ABS Label 725
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 725);
}
sqlite3ExprListDelete(db, pList);
    
// ABS Label 726
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}

// ABS Label 727
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}
sqlite3ExprDelete(db, pExpr);
    return 0;
  }else{
    pList = pNew;
  }
  pItem = &pList->a[pList->nExpr++];
  *pItem = zeroItem;
  pItem->pExpr = pExpr;
  
// ABS Label 728
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}
return pList;
}
ExprList *sqlite3ExprListAppend(
  Parse *pParse,          /* Parsing context */
  ExprList *pList,        /* List to which to append. Might be NULL */
  Expr *pExpr             /* Expression to be appended. Might be NULL */
){
  struct ExprList_item *pItem;
  
// ABS Label 729
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}

// ROR Label 730
if((pList != 0) != (pList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 730);
}
if( pList==0 ){
    return sqlite3ExprListAppendNew(pParse->db,pExpr);
  }
  
// ABS Label 731
if(pList->nAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}
// ABS Label 732
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}

// AOR Label 733
if(pList->nExpr - 1 != pList->nExpr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 733);
}
// AOR Label 734
if(pList->nExpr / 1 != pList->nExpr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 734);
}
// AOR Label 735
if(pList->nExpr * 1 != pList->nExpr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 735);
}

// ROR Label 736
if((pList->nAlloc <= pList->nExpr + 1) != (pList->nAlloc < pList->nExpr + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 736);
}
// ROR Label 737
if((pList->nAlloc > pList->nExpr + 1) != (pList->nAlloc < pList->nExpr + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 737);
}
// ROR Label 738
if((pList->nAlloc >= pList->nExpr + 1) != (pList->nAlloc < pList->nExpr + 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 738);
}
if( pList->nAlloc<pList->nExpr+1 ){
    return sqlite3ExprListAppendGrow(pParse->db,pList,pExpr);
  }
  pItem = &pList->a[pList->nExpr++];
  *pItem = zeroItem;
  pItem->pExpr = pExpr;
  
// ABS Label 739
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 739);
}
return pList;
}

/*
** pColumns and pExpr form a vector assignment which is part of the SET
** clause of an UPDATE statement.  Like this:
**
**        (a,b,c) = (expr1,expr2,expr3)
** Or:    (a,b,c) = (SELECT x,y,z FROM ....)
**
** For each term of the vector assignment, append new entries to the
** expression list pList.  In the case of a subquery on the RHS, append
** TK_SELECT_COLUMN expressions.
*/
ExprList *sqlite3ExprListAppendVector(
  Parse *pParse,         /* Parsing context */
  ExprList *pList,       /* List to which to append. Might be NULL */
  IdList *pColumns,      /* List of names of LHS of the assignment */
  Expr *pExpr            /* Vector expression to be appended. Might be NULL */
){
  
// ABS Label 740
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}
sqlite3 *db = pParse->db;
  int n;
  int i;
  int iFirst = pList ? pList->nExpr : 0;
  /* pColumns can only be NULL due to an OOM but an OOM will cause an
  ** exit prior to this routine being invoked */
  
// MCC Label 743
if(( pColumns == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 743);
}
// MCC Label 744
if(( !(pColumns == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 744);
}
if( NEVER(pColumns==0) ) { goto vector_append_error;
}
  
// ABS Label 745
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}

// ROR Label 746
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 746);
}
if( pExpr==0 ) { goto vector_append_error;
}

  /* If the RHS is a vector, then we can immediately check to see that 
  ** the size of the RHS and LHS match.  But if the RHS is a SELECT, 
  ** wildcards ("*") in the result set of the SELECT must be expanded before
  ** we can do the size check, so defer the size check until code generation.
  */
  if( pExpr->op!=TK_SELECT && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){
    
// ABS Label 747
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// ABS Label 748
if(pColumns->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// ABS Label 749
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}
sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                    pColumns->nId, n);
    goto vector_append_error;
  }

  i = 0;

// ABS Label 750
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 750);
}
// ABS Label 751
if(pColumns->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 751);
}

// ROR Label 752
if((i <= pColumns->nId) != (i < pColumns->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 752);
}
// ROR Label 753
if((i > pColumns->nId) != (i < pColumns->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 753);
}
// ROR Label 754
if((i >= pColumns->nId) != (i < pColumns->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 754);
}
for(; i<pColumns->nId; i++){
    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);
    assert( pSubExpr!=0 || db->mallocFailed );
    
// ABS Label 760
if(pSubExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}

// ROR Label 761
if((pSubExpr != 0) != (pSubExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 761);
}
if( pSubExpr==0 ) { continue;
}
    pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
    
// ABS Label 762
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}
if( pList ){
      assert( pList->nExpr==iFirst+i+1 );
      pList->a[pList->nExpr-1].zEName = pColumns->a[i].zName;
      pColumns->a[i].zName = 0;
    }
  };
// ABS Label 755
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}
// ABS Label 756
if(pColumns->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}

// ROR Label 757
if((i <= pColumns->nId) != (i < pColumns->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 757);
}
// ROR Label 758
if((i > pColumns->nId) != (i < pColumns->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 758);
}
// ROR Label 759
if((i >= pColumns->nId) != (i < pColumns->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 759);
}


  
// COR Label 763
if((!db->mallocFailed && pExpr->op == 137 || (pList != 0)) != (!db->mallocFailed && pExpr->op == 137 && (pList != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 763);
}
// COR Label 764
if((!db->mallocFailed || pExpr->op == 137) != (!db->mallocFailed && pExpr->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 764);
}

// ROR Label 765
if((pExpr->op != 137) != (pExpr->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 765);
}

// MCC Label 766
if(!db->mallocFailed && pExpr->op == 137 && ( pList != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 766);
}
// MCC Label 767
if(!db->mallocFailed && pExpr->op == 137 && ( !(pList != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 767);
}
// MCC Label 768
if(!db->mallocFailed && !(pExpr->op == 137) && ( pList != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 768);
}
// MCC Label 769
if(!db->mallocFailed && !(pExpr->op == 137) && ( !(pList != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 769);
}
// MCC Label 770
if(!(!db->mallocFailed) && pExpr->op == 137 && ( pList != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
// MCC Label 771
if(!(!db->mallocFailed) && pExpr->op == 137 && ( !(pList != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 771);
}
// MCC Label 772
if(!(!db->mallocFailed) && !(pExpr->op == 137) && ( pList != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 772);
}
// MCC Label 773
if(!(!db->mallocFailed) && !(pExpr->op == 137) && ( !(pList != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 773);
}
if( !db->mallocFailed && pExpr->op==TK_SELECT && ALWAYS(pList!=0) ){
    
// ABS Label 774
if(pList->a[iFirst].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}
Expr *pFirst = pList->a[iFirst].pExpr;
    assert( pFirst!=0 );
    assert( pFirst->op==TK_SELECT_COLUMN );
     
    /* Store the SELECT statement in pRight so it will be deleted when
    ** sqlite3ExprListDelete() is called */
    pFirst->pRight = pExpr;
    pExpr = 0;

    /* Remember the size of the LHS in iTable so that we can check that
    ** the RHS and LHS sizes match during code generation. */
    pFirst->iTable = pColumns->nId;
  }

vector_append_error:
  sqlite3ExprUnmapAndDelete(pParse, pExpr);
  
// ABS Label 741
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}

// ABS Label 742
if(pColumns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}
sqlite3IdListDelete(db, pColumns);
  
// ABS Label 775
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}
return pList;
}

/*
** Set the sort order for the last element on the given ExprList.
*/
void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){
  struct ExprList_item *pItem;
  
// ABS Label 776
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}

// ROR Label 777
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 777);
}
if( p==0 ) { return;
}
  assert( p->nExpr>0 );

  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC==0 && SQLITE_SO_DESC>0 );
  assert( iSortOrder==SQLITE_SO_UNDEFINED 
       || iSortOrder==SQLITE_SO_ASC 
       || iSortOrder==SQLITE_SO_DESC 
  );
  assert( eNulls==SQLITE_SO_UNDEFINED 
       || eNulls==SQLITE_SO_ASC 
       || eNulls==SQLITE_SO_DESC 
  );

  pItem = &p->a[p->nExpr-1];
  assert( pItem->bNulls==0 );
  
// ABS Label 778
if(iSortOrder < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}

// ROR Label 779
if((iSortOrder != -1) != (iSortOrder == -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 779);
}
if( iSortOrder==SQLITE_SO_UNDEFINED ){
    iSortOrder = SQLITE_SO_ASC;
  }
  pItem->sortFlags = (u8)iSortOrder;

  
// ABS Label 780
if(eNulls < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}

// ROR Label 781
if((eNulls == -1) != (eNulls != -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 781);
}
if( eNulls!=SQLITE_SO_UNDEFINED ){
    pItem->bNulls = 1;
    
// ABS Label 782
if(eNulls < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}
// ABS Label 783
if(iSortOrder < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}

// ROR Label 784
if((iSortOrder == eNulls) != (iSortOrder != eNulls))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 784);
}
if( iSortOrder!=eNulls ){
      pItem->sortFlags |= KEYINFO_ORDER_BIGNULL;
    }
  }
}

/*
** Set the ExprList.a[].zEName element of the most recently added item
** on the expression list.
**
** pList might be NULL following an OOM error.  But pName should never be
** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag
** is set.
*/
void sqlite3ExprListSetName(
  Parse *pParse,          /* Parsing context */
  ExprList *pList,        /* List to which to add the span. */
  Token *pName,           /* Name to be added */
  int dequote             /* True to cause the name to be dequoted */
){
  assert( pList!=0 || pParse->db->mallocFailed!=0 );
  assert( pParse->eParseMode!=PARSE_MODE_UNMAP || dequote==0 );
  
// ABS Label 785
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}
if( pList ){
    struct ExprList_item *pItem;
    assert( pList->nExpr>0 );
    pItem = &pList->a[pList->nExpr-1];
    assert( pItem->zEName==0 );
    assert( pItem->eEName==ENAME_NAME );
    pItem->zEName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);
    
// ABS Label 786
if(dequote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}
if( dequote ){
      /* If dequote==0, then pName->z does not point to part of a DDL
      ** statement handled by the parser. And so no token need be added
      ** to the token-map.  */
      
// ABS Label 787
if(pItem->zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}
sqlite3Dequote(pItem->zEName);
      
// MCC Label 788
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 788);
}
// MCC Label 789
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 789);
}
if( IN_RENAME_OBJECT ){
        
// ABS Label 790
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}

// ABS Label 791
if(pName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}
sqlite3RenameTokenMap(pParse, (void*)pItem->zEName, pName);
      }
    }
  }
}

/*
** Set the ExprList.a[].zSpan element of the most recently added item
** on the expression list.
**
** pList might be NULL following an OOM error.  But pSpan should never be
** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag
** is set.
*/
void sqlite3ExprListSetSpan(
  Parse *pParse,          /* Parsing context */
  ExprList *pList,        /* List to which to add the span. */
  const char *zStart,     /* Start of the span */
  const char *zEnd        /* End of the span */
){
  
// ABS Label 792
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}
sqlite3 *db = pParse->db;
  assert( pList!=0 || db->mallocFailed!=0 );
  
// ABS Label 793
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}
if( pList ){
    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];
    assert( pList->nExpr>0 );
    
// ABS Label 794
if(pItem->zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}

// ROR Label 795
if((pItem->zEName != 0) != (pItem->zEName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 795);
}
if( pItem->zEName==0 ){
      pItem->zEName = sqlite3DbSpanDup(db, zStart, zEnd);
      pItem->eEName = ENAME_SPAN;
    }
  }
}

/*
** If the expression list pEList contains more than iLimit elements,
** leave an error message in pParse.
*/
void sqlite3ExprListCheckLength(
  Parse *pParse,
  ExprList *pEList,
  const char *zObject
){
  
// ABS Label 796
if(pParse->db->aLimit[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}
int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];
  testcase( pEList && pEList->nExpr==mx );
  testcase( pEList && pEList->nExpr==mx+1 );
  
// ABS Label 797
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}
// ABS Label 798
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}
// ABS Label 799
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}

// COR Label 800
if((pEList || pEList->nExpr > mx) != (pEList && pEList->nExpr > mx))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 800);
}

// ROR Label 801
if((pEList->nExpr <= mx) != (pEList->nExpr > mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 801);
}
// ROR Label 802
if((pEList->nExpr < mx) != (pEList->nExpr > mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 802);
}
// ROR Label 803
if((pEList->nExpr >= mx) != (pEList->nExpr > mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 803);
}

// MCC Label 804
if(pEList && pEList->nExpr > mx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 804);
}
// MCC Label 805
if(pEList && !(pEList->nExpr > mx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 805);
}
// MCC Label 806
if(!(pEList) && pEList->nExpr > mx ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 806);
}
// MCC Label 807
if(!(pEList) && !(pEList->nExpr > mx) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 807);
}
if( pEList && pEList->nExpr>mx ){
    
// ABS Label 808
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}

// ABS Label 809
if(zObject < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}
sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
  }
}

/*
** Delete an entire expression list.
*/
static SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList){
  
// ABS Label 810
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}
int i = pList->nExpr;
  struct ExprList_item *pItem =  pList->a;
  assert( pList->nExpr>0 );
  do{
    
// ABS Label 812
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}

// ABS Label 813
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}
sqlite3ExprDelete(db, pItem->pExpr);
    
// ABS Label 814
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}
sqlite3DbFree(db, pItem->zEName);
    pItem++;
  }while( --i>0 );;
  
// ABS Label 811
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
sqlite3DbFreeNN(db, pList);
}
void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){
  
// ABS Label 815
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}
if( pList ) { 
// ABS Label 816
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// ABS Label 817
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}
exprListDeleteNN(db, pList);
}
}

/*
** Return the bitwise-OR of all Expr.flags fields in the given
** ExprList.
*/
u32 sqlite3ExprListFlags(const ExprList *pList){
  int i;
  u32 m = 0;
  assert( pList!=0 );
  i = 0;

// ABS Label 818
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}
// ABS Label 819
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}

// ROR Label 820
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 820);
}
// ROR Label 821
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 821);
}
// ROR Label 822
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 822);
}
for(; i<pList->nExpr; i++){
     
// ABS Label 828
if(pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}
Expr *pExpr = pList->a[i].pExpr;
     assert( pExpr!=0 );
     m |= pExpr->flags;
  };
// ABS Label 823
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}
// ABS Label 824
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ROR Label 825
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 825);
}
// ROR Label 826
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 826);
}
// ROR Label 827
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 827);
}

  
// ABS Label 829
if(m < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}
return m;
}

/*
** This is a SELECT-node callback for the expression walker that
** always "fails".  By "fail" in this case, we mean set
** pWalker->eCode to zero and abort.
**
** This callback is used by multiple expression walkers.
*/
int sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){
  UNUSED_PARAMETER(NotUsed);
  pWalker->eCode = 0;
  return WRC_Abort;
}

/*
** Check the input string to see if it is "true" or "false" (in any case).
**
**       If the string is....           Return
**         "true"                         EP_IsTrue
**         "false"                        EP_IsFalse
**         anything else                  0
*/
u32 sqlite3IsTrueOrFalse(const char *zIn){
  if( sqlite3StrICmp(zIn, "true")==0  ) { return EP_IsTrue;
}
  if( sqlite3StrICmp(zIn, "false")==0 ) { return EP_IsFalse;
}
  return 0;
}


/*
** If the input expression is an ID with the name "true" or "false"
** then convert it into an TK_TRUEFALSE term.  Return non-zero if
** the conversion happened, and zero if the expression is unaltered.
*/
int sqlite3ExprIdToTrueFalse(Expr *pExpr){
  u32 v;
  assert( pExpr->op==TK_ID || pExpr->op==TK_STRING );
  if( !ExprHasProperty(pExpr, EP_Quoted)
   && (v = sqlite3IsTrueOrFalse(pExpr->u.zToken))!=0
  ){
    pExpr->op = TK_TRUEFALSE;
    ExprSetProperty(pExpr, v);
    return 1;
  }
  return 0;
}

/*
** The argument must be a TK_TRUEFALSE Expr node.  Return 1 if it is TRUE
** and 0 if it is FALSE.
*/
int sqlite3ExprTruthValue(const Expr *pExpr){
  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);
  assert( pExpr->op==TK_TRUEFALSE );
  assert( sqlite3StrICmp(pExpr->u.zToken,"true")==0
       || sqlite3StrICmp(pExpr->u.zToken,"false")==0 );
  
// ROR Label 830
if((pExpr->u.zToken[4] != 0) != (pExpr->u.zToken[4] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}
return pExpr->u.zToken[4]==0;
}

/*
** If pExpr is an AND or OR expression, try to simplify it by eliminating
** terms that are always true or false.  Return the simplified expression.
** Or return the original expression if no simplification is possible.
**
** Examples:
**
**     (x<10) AND true                =>   (x<10)
**     (x<10) AND false               =>   false
**     (x<10) AND (y=22 OR false)     =>   (x<10) AND (y=22)
**     (x<10) AND (y=22 OR true)      =>   (x<10)
**     (y=22) OR true                 =>   true
*/
Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){
  assert( pExpr!=0 );
  
// COR Label 831
if((pExpr->op == 44 && pExpr->op == 43) != (pExpr->op == 44 || pExpr->op == 43))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 831);
}

// ROR Label 832
if((pExpr->op != 44) != (pExpr->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}
// ROR Label 833
if((pExpr->op != 43) != (pExpr->op == 43))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 833);
}

// MCC Label 834
if(pExpr->op == 44 && pExpr->op == 43 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 834);
}
// MCC Label 835
if(pExpr->op == 44 && !(pExpr->op == 43) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 835);
}
// MCC Label 836
if(!(pExpr->op == 44) && pExpr->op == 43 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 836);
}
// MCC Label 837
if(!(pExpr->op == 44) && !(pExpr->op == 43) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 837);
}
if( pExpr->op==TK_AND || pExpr->op==TK_OR ){
    Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);
    Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);
    
// COR Label 838
if(((((pLeft)->flags & (1 | 268435456)) == 268435456) && (((pRight)->flags & (1 | 536870912)) == 536870912)) != ((((pLeft)->flags & (1 | 268435456)) == 268435456) || (((pRight)->flags & (1 | 536870912)) == 536870912)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 838);
}

// MCC Label 839
if(( ((pLeft)->flags & (1 | 268435456)) == 268435456 ) && ( ((pRight)->flags & (1 | 536870912)) == 536870912 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 839);
}
// MCC Label 840
if(( ((pLeft)->flags & (1 | 268435456)) == 268435456 ) && ( !(((pRight)->flags & (1 | 536870912)) == 536870912) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 840);
}
// MCC Label 841
if(( !(((pLeft)->flags & (1 | 268435456)) == 268435456) ) && ( ((pRight)->flags & (1 | 536870912)) == 536870912 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 841);
}
// MCC Label 842
if(( !(((pLeft)->flags & (1 | 268435456)) == 268435456) ) && ( !(((pRight)->flags & (1 | 536870912)) == 536870912) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 842);
}
if( ExprAlwaysTrue(pLeft) || ExprAlwaysFalse(pRight) ){
      pExpr = pExpr->op==TK_AND ? pRight : pLeft;
    }else { 
// COR Label 843
if(((((pRight)->flags & (1 | 268435456)) == 268435456) && (((pLeft)->flags & (1 | 536870912)) == 536870912)) != ((((pRight)->flags & (1 | 268435456)) == 268435456) || (((pLeft)->flags & (1 | 536870912)) == 536870912)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 843);
}

// MCC Label 844
if(( ((pRight)->flags & (1 | 268435456)) == 268435456 ) && ( ((pLeft)->flags & (1 | 536870912)) == 536870912 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 844);
}
// MCC Label 845
if(( ((pRight)->flags & (1 | 268435456)) == 268435456 ) && ( !(((pLeft)->flags & (1 | 536870912)) == 536870912) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 845);
}
// MCC Label 846
if(( !(((pRight)->flags & (1 | 268435456)) == 268435456) ) && ( ((pLeft)->flags & (1 | 536870912)) == 536870912 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 846);
}
// MCC Label 847
if(( !(((pRight)->flags & (1 | 268435456)) == 268435456) ) && ( !(((pLeft)->flags & (1 | 536870912)) == 536870912) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 847);
}
if( ExprAlwaysTrue(pRight) || ExprAlwaysFalse(pLeft) ){
      pExpr = pExpr->op==TK_AND ? pLeft : pRight;
    };}

  }
  
// ABS Label 848
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}
return pExpr;
}


/*
** These routines are Walker callbacks used to check expressions to
** see if they are "constant" for some definition of constant.  The
** Walker.eCode value determines the type of "constant" we are looking
** for.
**
** These callback routines are used to implement the following:
**
**     sqlite3ExprIsConstant()                  pWalker->eCode==1
**     sqlite3ExprIsConstantNotJoin()           pWalker->eCode==2
**     sqlite3ExprIsTableConstant()             pWalker->eCode==3
**     sqlite3ExprIsConstantOrFunction()        pWalker->eCode==4 or 5
**
** In all cases, the callbacks set Walker.eCode=0 and abort if the expression
** is found to not be a constant.
**
** The sqlite3ExprIsConstantOrFunction() is used for evaluating DEFAULT
** expressions in a CREATE TABLE statement.  The Walker.eCode value is 5
** when parsing an existing schema out of the sqlite_schema table and 4
** when processing a new CREATE TABLE statement.  A bound parameter raises
** an error for new statements, but is silently converted
** to NULL for existing schemas.  This allows sqlite_schema tables that 
** contain a bound parameter because they were generated by older versions
** of SQLite to be parsed by newer versions of SQLite without raising a
** malformed schema error.
*/
static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){

  /* If pWalker->eCode is 2 then any term of the expression that comes from
  ** the ON or USING clauses of a left join disqualifies the expression
  ** from being considered constant. */
  
// COR Label 849
if((pWalker->eCode == 2 || (((pExpr)->flags & (1)) != 0)) != (pWalker->eCode == 2 && (((pExpr)->flags & (1)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 849);
}

// ROR Label 850
if((pWalker->eCode != 2) != (pWalker->eCode == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 850);
}

// MCC Label 851
if(pWalker->eCode == 2 && ( ((pExpr)->flags & (1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 851);
}
// MCC Label 852
if(pWalker->eCode == 2 && ( !(((pExpr)->flags & (1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 852);
}
// MCC Label 853
if(!(pWalker->eCode == 2) && ( ((pExpr)->flags & (1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 853);
}
// MCC Label 854
if(!(pWalker->eCode == 2) && ( !(((pExpr)->flags & (1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 854);
}
if( pWalker->eCode==2 && ExprHasProperty(pExpr, EP_FromJoin) ){
    pWalker->eCode = 0;
    return WRC_Abort;
  }

  switch( pExpr->op ){
    /* Consider functions to be constant if all their arguments are constant
    ** and either pWalker->eCode==4 or 5 or the function has the
    ** SQLITE_FUNC_CONST flag. */
    case TK_FUNCTION:
      
// COR Label 855
if(((pWalker->eCode >= 4 || (((pExpr)->flags & (524288)) != 0)) || !(((pExpr)->flags & (16777216)) != 0)) != ((pWalker->eCode >= 4 || (((pExpr)->flags & (524288)) != 0)) && !(((pExpr)->flags & (16777216)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 855);
}

// MCC Label 856
if(( pWalker->eCode >= 4 && ( ((pExpr)->flags & (524288)) != 0 ) ) && !(((pExpr)->flags & (16777216)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 856);
}
// MCC Label 857
if(( pWalker->eCode >= 4 && ( ((pExpr)->flags & (524288)) != 0 ) ) && !(!(((pExpr)->flags & (16777216)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 857);
}
// MCC Label 858
if(( pWalker->eCode >= 4 && ( !(((pExpr)->flags & (524288)) != 0) ) ) && !(((pExpr)->flags & (16777216)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 858);
}
// MCC Label 859
if(( pWalker->eCode >= 4 && ( !(((pExpr)->flags & (524288)) != 0) ) ) && !(!(((pExpr)->flags & (16777216)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 859);
}
// MCC Label 860
if(( !(pWalker->eCode >= 4) && ( ((pExpr)->flags & (524288)) != 0 ) ) && !(((pExpr)->flags & (16777216)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 860);
}
// MCC Label 861
if(( !(pWalker->eCode >= 4) && ( ((pExpr)->flags & (524288)) != 0 ) ) && !(!(((pExpr)->flags & (16777216)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 861);
}
// MCC Label 862
if(( !(pWalker->eCode >= 4) && ( !(((pExpr)->flags & (524288)) != 0) ) ) && !(((pExpr)->flags & (16777216)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 862);
}
// MCC Label 863
if(( !(pWalker->eCode >= 4) && ( !(((pExpr)->flags & (524288)) != 0) ) ) && !(!(((pExpr)->flags & (16777216)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 863);
}
if( (pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc))
       && !ExprHasProperty(pExpr, EP_WinFunc)
      ){
        
// ROR Label 864
if((pWalker->eCode != 5) != (pWalker->eCode == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}
if( pWalker->eCode==5 ) { ExprSetProperty(pExpr, EP_FromDDL);
}
        return WRC_Continue;
      }else{
        pWalker->eCode = 0;
        return WRC_Abort;
      }
    case TK_ID:
      /* Convert "true" or "false" in a DEFAULT clause into the
      ** appropriate TK_TRUEFALSE operator */
      if( sqlite3ExprIdToTrueFalse(pExpr) ){
        return WRC_Prune;
      }
      /* no break */ deliberate_fall_through
    case TK_COLUMN:
    case TK_AGG_FUNCTION:
    case TK_AGG_COLUMN:
      testcase( pExpr->op==TK_ID );
      testcase( pExpr->op==TK_COLUMN );
      testcase( pExpr->op==TK_AGG_FUNCTION );
      testcase( pExpr->op==TK_AGG_COLUMN );
      
// COR Label 865
if(((((pExpr)->flags & (8)) != 0) || pWalker->eCode != 2) != ((((pExpr)->flags & (8)) != 0) && pWalker->eCode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 865);
}

// ROR Label 866
if((pWalker->eCode == 2) != (pWalker->eCode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}

// MCC Label 867
if(( ((pExpr)->flags & (8)) != 0 ) && pWalker->eCode != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 867);
}
// MCC Label 868
if(( ((pExpr)->flags & (8)) != 0 ) && !(pWalker->eCode != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 868);
}
// MCC Label 869
if(( !(((pExpr)->flags & (8)) != 0) ) && pWalker->eCode != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 869);
}
// MCC Label 870
if(( !(((pExpr)->flags & (8)) != 0) ) && !(pWalker->eCode != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 870);
}
if( ExprHasProperty(pExpr, EP_FixedCol) && pWalker->eCode!=2 ){
        return WRC_Continue;
      }
      
// ABS Label 871
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}
// ABS Label 872
if(pWalker->u.iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}

// COR Label 873
if((pWalker->eCode == 3 || pExpr->iTable == pWalker->u.iCur) != (pWalker->eCode == 3 && pExpr->iTable == pWalker->u.iCur))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 873);
}

// ROR Label 874
if((pWalker->eCode != 3) != (pWalker->eCode == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 874);
}
// ROR Label 875
if((pExpr->iTable != pWalker->u.iCur) != (pExpr->iTable == pWalker->u.iCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}

// MCC Label 876
if(pWalker->eCode == 3 && pExpr->iTable == pWalker->u.iCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 876);
}
// MCC Label 877
if(pWalker->eCode == 3 && !(pExpr->iTable == pWalker->u.iCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 877);
}
// MCC Label 878
if(!(pWalker->eCode == 3) && pExpr->iTable == pWalker->u.iCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 878);
}
// MCC Label 879
if(!(pWalker->eCode == 3) && !(pExpr->iTable == pWalker->u.iCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 879);
}
if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){
        return WRC_Continue;
      }
      /* no break */ deliberate_fall_through
    case TK_IF_NULL_ROW:
    case TK_REGISTER:
    case TK_DOT:
      testcase( pExpr->op==TK_REGISTER );
      testcase( pExpr->op==TK_IF_NULL_ROW );
      testcase( pExpr->op==TK_DOT );
      pWalker->eCode = 0;
      return WRC_Abort;
    case TK_VARIABLE:
      
// ROR Label 880
if((pWalker->eCode != 5) != (pWalker->eCode == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 880);
}
if( pWalker->eCode==5 ){
        /* Silently convert bound parameters that appear inside of CREATE
        ** statements into a NULL when parsing the CREATE statement text out
        ** of the sqlite_schema table */
        pExpr->op = TK_NULL;
      }else { 
// ROR Label 881
if((pWalker->eCode != 4) != (pWalker->eCode == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 881);
}
if( pWalker->eCode==4 ){
        /* A bound parameter in a CREATE statement that originates from
        ** sqlite3_prepare() causes an error */
        pWalker->eCode = 0;
        return WRC_Abort;
      };}

      /* no break */ deliberate_fall_through
    default:
      testcase( pExpr->op==TK_SELECT ); /* sqlite3SelectWalkFail() disallows */
      testcase( pExpr->op==TK_EXISTS ); /* sqlite3SelectWalkFail() disallows */
      return WRC_Continue;
  }
}
static int exprIsConst(Expr *p, int initFlag, int iCur){
  Walker w;
  w.eCode = initFlag;
  w.xExprCallback = exprNodeIsConstant;
  w.xSelectCallback = sqlite3SelectWalkFail;
#ifdef SQLITE_DEBUG
  w.xSelectCallback2 = sqlite3SelectWalkAssert2;
#endif
  w.u.iCur = iCur;
  
// ABS Label 882
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}
sqlite3WalkExpr(&w, p);
  return w.eCode;
}

/*
** Walk an expression tree.  Return non-zero if the expression is constant
** and 0 if it involves variables or function calls.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/
int sqlite3ExprIsConstant(Expr *p){
  return exprIsConst(p, 1, 0);
}

/*
** Walk an expression tree.  Return non-zero if
**
**   (1) the expression is constant, and
**   (2) the expression does originate in the ON or USING clause
**       of a LEFT JOIN, and
**   (3) the expression does not contain any EP_FixedCol TK_COLUMN
**       operands created by the constant propagation optimization.
**
** When this routine returns true, it indicates that the expression
** can be added to the pParse->pConstExpr list and evaluated once when
** the prepared statement starts up.  See sqlite3ExprCodeRunJustOnce().
*/
int sqlite3ExprIsConstantNotJoin(Expr *p){
  return exprIsConst(p, 2, 0);
}

/*
** Walk an expression tree.  Return non-zero if the expression is constant
** for any single row of the table with cursor iCur.  In other words, the
** expression must not refer to any non-deterministic function nor any
** table other than iCur.
*/
int sqlite3ExprIsTableConstant(Expr *p, int iCur){
  return exprIsConst(p, 3, iCur);
}


/*
** sqlite3WalkExpr() callback used by sqlite3ExprIsConstantOrGroupBy().
*/
static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){
  
// ABS Label 883
if(pWalker->u.pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}
ExprList *pGroupBy = pWalker->u.pGroupBy;
  int i;

  /* Check if pExpr is identical to any GROUP BY term. If so, consider
  ** it constant.  */
  i = 0;

// ABS Label 884
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 884);
}
// ABS Label 885
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 885);
}

// ROR Label 886
if((i <= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}
// ROR Label 887
if((i > pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}
// ROR Label 888
if((i >= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
for(; i<pGroupBy->nExpr; i++){
    
// ABS Label 894
if(pGroupBy->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}
Expr *p = pGroupBy->a[i].pExpr;
    if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){
      CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);
      if( sqlite3IsBinary(pColl) ){
        return WRC_Prune;
      }
    }
  };
// ABS Label 889
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 889);
}
// ABS Label 890
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 890);
}

// ROR Label 891
if((i <= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 891);
}
// ROR Label 892
if((i > pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
// ROR Label 893
if((i >= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 893);
}


  /* Check if pExpr is a sub-select. If so, consider it variable. */
  
// MCC Label 895
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 895);
}
// MCC Label 896
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 896);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
    pWalker->eCode = 0;
    return WRC_Abort;
  }

  return exprNodeIsConstant(pWalker, pExpr);
}

/*
** Walk the expression tree passed as the first argument. Return non-zero
** if the expression consists entirely of constants or copies of terms 
** in pGroupBy that sort with the BINARY collation sequence.
**
** This routine is used to determine if a term of the HAVING clause can
** be promoted into the WHERE clause.  In order for such a promotion to work,
** the value of the HAVING clause term must be the same for all members of
** a "group".  The requirement that the GROUP BY term must be BINARY
** assumes that no other collating sequence will have a finer-grained
** grouping than binary.  In other words (A=B COLLATE binary) implies
** A=B in every other collating sequence.  The requirement that the
** GROUP BY be BINARY is stricter than necessary.  It would also work
** to promote HAVING clauses that use the same alternative collating
** sequence as the GROUP BY term, but that is much harder to check,
** alternative collating sequences are uncommon, and this is only an
** optimization, so we take the easy way out and simply require the
** GROUP BY to use the BINARY collating sequence.
*/
int sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){
  Walker w;
  w.eCode = 1;
  w.xExprCallback = exprNodeIsConstantOrGroupBy;
  w.xSelectCallback = 0;
  w.u.pGroupBy = pGroupBy;
  w.pParse = pParse;
  
// ABS Label 897
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}
sqlite3WalkExpr(&w, p);
  return w.eCode;
}

/*
** Walk an expression tree for the DEFAULT field of a column definition
** in a CREATE TABLE statement.  Return non-zero if the expression is 
** acceptable for use as a DEFAULT.  That is to say, return non-zero if
** the expression is constant or a function call with constant arguments.
** Return and 0 if there are any variables.
**
** isInit is true when parsing from sqlite_schema.  isInit is false when
** processing a new CREATE TABLE statement.  When isInit is true, parameters
** (such as ? or $abc) in the expression are converted into NULL.  When
** isInit is false, parameters raise an error.  Parameters should not be
** allowed in a CREATE TABLE statement, but some legacy versions of SQLite
** allowed it, so we need to support it when reading sqlite_schema for
** backwards compatibility.
**
** If isInit is true, set EP_FromDDL on every TK_FUNCTION node.
**
** For the purposes of this function, a double-quoted string (ex: "abc")
** is considered a variable but a single-quoted string (ex: 'abc') is
** a constant.
*/
int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){
  assert( isInit==0 || isInit==1 );
  return exprIsConst(p, 4+isInit, 0);
}

#ifdef SQLITE_ENABLE_CURSOR_HINTS
/*
** Walk an expression tree.  Return 1 if the expression contains a
** subquery of some kind.  Return 0 if there are no subqueries.
*/
int sqlite3ExprContainsSubquery(Expr *p){
  Walker w;
  w.eCode = 1;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.xSelectCallback = sqlite3SelectWalkFail;
#ifdef SQLITE_DEBUG
  w.xSelectCallback2 = sqlite3SelectWalkAssert2;
#endif
  sqlite3WalkExpr(&w, p);
  return w.eCode==0;
}
#endif

/*
** If the expression p codes a constant integer that is small enough
** to fit in a 32-bit integer, return 1 and put the value of the integer
** in *pValue.  If the expression is not an integer or if it is too big
** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.
*/
int sqlite3ExprIsInteger(Expr *p, int *pValue){
  int rc = 0;
  
// MCC Label 898
if(( p == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 898);
}
// MCC Label 899
if(( !(p == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 899);
}
if( NEVER(p==0) ) { return 0;  /* Used to only happen following on OOM */
}

  /* If an expression is an integer literal that fits in a signed 32-bit
  ** integer, then the EP_IntValue flag will have already been set */
  assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0
           || sqlite3GetInt32(p->u.zToken, &rc)==0 );

  
// ABS Label 900
if(p->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 900);
}

// AOR Label 901
if(p->flags | 1024 != p->flags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 901);
}
// AOR Label 902
if(p->flags ^ 1024 != p->flags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 902);
}
if( p->flags & EP_IntValue ){
    *pValue = p->u.iValue;
    return 1;
  }
  switch( p->op ){
    case TK_UPLUS: {
      rc = sqlite3ExprIsInteger(p->pLeft, pValue);
      break;
    }
    case TK_UMINUS: {
      int v;
      if( sqlite3ExprIsInteger(p->pLeft, &v) ){
        assert( v!=(-2147483647-1) );
        *pValue = -v;
        rc = 1;
      }
      break;
    }
    default: break;
  }
  
// ABS Label 903
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 903);
}
return rc;
}

/*
** Return FALSE if there is no chance that the expression can be NULL.
**
** If the expression might be NULL or if the expression is too complex
** to tell return TRUE.  
**
** This routine is used as an optimization, to skip OP_IsNull opcodes
** when we know that a value cannot be NULL.  Hence, a false positive
** (returning TRUE when in fact the expression can never be NULL) might
** be a small performance hit but is otherwise harmless.  On the other
** hand, a false negative (returning FALSE when the result could be NULL)
** will likely result in an incorrect answer.  So when in doubt, return
** TRUE.
*/
int sqlite3ExprCanBeNull(const Expr *p){
  u8 op;
  assert( p!=0 );
  
// COR Label 904
if((p->op == 173 && p->op == 172) != (p->op == 173 || p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 904);
}

// ROR Label 905
if((p->op != 173) != (p->op == 173))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 905);
}
// ROR Label 906
if((p->op != 172) != (p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 906);
}

// MCC Label 907
if(p->op == 173 && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(p->op == 173 && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
// MCC Label 909
if(!(p->op == 173) && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 909);
}
// MCC Label 910
if(!(p->op == 173) && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 910);
}
while( p->op==TK_UPLUS || p->op==TK_UMINUS ){
    p = p->pLeft;
    assert( p!=0 );
  };
// COR Label 911
if((p->op == 173 && p->op == 172) != (p->op == 173 || p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 911);
}

// ROR Label 912
if((p->op != 173) != (p->op == 173))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 912);
}
// ROR Label 913
if((p->op != 172) != (p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 913);
}

// MCC Label 914
if(p->op == 173 && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(p->op == 173 && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(!(p->op == 173) && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}
// MCC Label 917
if(!(p->op == 173) && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 917);
}

  op = p->op;
  
// ROR Label 918
if((op != 175) != (op == 175))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
if( op==TK_REGISTER ) { op = p->op2;
}
  switch( op ){
    case TK_INTEGER:
    case TK_STRING:
    case TK_FLOAT:
    case TK_BLOB:
      return 0;
    case TK_COLUMN:
      
// ABS Label 919
if(p->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}

// COR Label 920
if(((((p)->flags & (1048576)) != 0) || p->y.pTab == 0 && (p->iColumn >= 0 && (p->y.pTab->aCol != 0) && p->y.pTab->aCol[p->iColumn].notNull == 0)) != ((((p)->flags & (1048576)) != 0) || p->y.pTab == 0 || (p->iColumn >= 0 && (p->y.pTab->aCol != 0) && p->y.pTab->aCol[p->iColumn].notNull == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 920);
}
// COR Label 921
if(((((p)->flags & (1048576)) != 0) && p->y.pTab == 0) != ((((p)->flags & (1048576)) != 0) || p->y.pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 921);
}

// ROR Label 922
if((p->y.pTab != 0) != (p->y.pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 922);
}

// MCC Label 923
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 923);
}
// MCC Label 924
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 924);
}
// MCC Label 925
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 925);
}
// MCC Label 926
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 926);
}
// MCC Label 927
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 927);
}
// MCC Label 928
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 928);
}
// MCC Label 929
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 929);
}
// MCC Label 930
if(( ((p)->flags & (1048576)) != 0 ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 930);
}
// MCC Label 931
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 931);
}
// MCC Label 932
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 932);
}
// MCC Label 933
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 933);
}
// MCC Label 934
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 934);
}
// MCC Label 935
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 935);
}
// MCC Label 936
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 936);
}
// MCC Label 937
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 937);
}
// MCC Label 938
if(( ((p)->flags & (1048576)) != 0 ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 938);
}
// MCC Label 939
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 939);
}
// MCC Label 940
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 940);
}
// MCC Label 941
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 941);
}
// MCC Label 942
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 942);
}
// MCC Label 943
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 943);
}
// MCC Label 944
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 944);
}
// MCC Label 945
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 945);
}
// MCC Label 946
if(( !(((p)->flags & (1048576)) != 0) ) && p->y.pTab == 0 && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 946);
}
// MCC Label 947
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 947);
}
// MCC Label 948
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 948);
}
// MCC Label 949
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 949);
}
// MCC Label 950
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( p->iColumn >= 0 && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 950);
}
// MCC Label 951
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 951);
}
// MCC Label 952
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( p->y.pTab->aCol != 0 ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 952);
}
// MCC Label 953
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && p->y.pTab->aCol[p->iColumn].notNull == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 953);
}
// MCC Label 954
if(( !(((p)->flags & (1048576)) != 0) ) && !(p->y.pTab == 0) && ( !(p->iColumn >= 0) && ( !(p->y.pTab->aCol != 0) ) && !(p->y.pTab->aCol[p->iColumn].notNull == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 954);
}
return ExprHasProperty(p, EP_CanBeNull) ||
             p->y.pTab==0 ||  /* Reference to column of index on expression */
             (p->iColumn>=0
              && ALWAYS(p->y.pTab->aCol!=0) /* Defense against OOM problems */
              && p->y.pTab->aCol[p->iColumn].notNull==0);
    default:
      return 1;
  }
}

/*
** Return TRUE if the given expression is a constant which would be
** unchanged by OP_Affinity with the affinity given in the second
** argument.
**
** This routine is used to determine if the OP_Affinity operation
** can be omitted.  When in doubt return FALSE.  A false negative
** is harmless.  A false positive, however, can result in the wrong
** answer.
*/
int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){
  u8 op;
  int unaryMinus = 0;
  
// ROR Label 955
if((aff != 65) != (aff == 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 955);
}
if( aff==SQLITE_AFF_BLOB ) { return 1;
}
  
// COR Label 956
if((p->op == 173 && p->op == 172) != (p->op == 173 || p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 956);
}

// ROR Label 957
if((p->op != 173) != (p->op == 173))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 957);
}
// ROR Label 958
if((p->op != 172) != (p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 958);
}

// MCC Label 959
if(p->op == 173 && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 959);
}
// MCC Label 960
if(p->op == 173 && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 960);
}
// MCC Label 961
if(!(p->op == 173) && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 961);
}
// MCC Label 962
if(!(p->op == 173) && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 962);
}
while( p->op==TK_UPLUS || p->op==TK_UMINUS ){
    
// ROR Label 970
if((p->op != 172) != (p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 970);
}
if( p->op==TK_UMINUS ) { unaryMinus = 1;
}
    p = p->pLeft;
  };
// COR Label 963
if((p->op == 173 && p->op == 172) != (p->op == 173 || p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 963);
}

// ROR Label 964
if((p->op != 173) != (p->op == 173))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 964);
}
// ROR Label 965
if((p->op != 172) != (p->op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 965);
}

// MCC Label 966
if(p->op == 173 && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 966);
}
// MCC Label 967
if(p->op == 173 && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 967);
}
// MCC Label 968
if(!(p->op == 173) && p->op == 172 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 968);
}
// MCC Label 969
if(!(p->op == 173) && !(p->op == 172) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 969);
}

  op = p->op;
  
// ROR Label 971
if((op != 175) != (op == 175))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 971);
}
if( op==TK_REGISTER ) { op = p->op2;
}
  switch( op ){
    case TK_INTEGER: {
      
// ROR Label 972
if((aff < 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 972);
}
// ROR Label 973
if((aff > 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 973);
}
// ROR Label 974
if((aff <= 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 974);
}
return aff>=SQLITE_AFF_NUMERIC;
    }
    case TK_FLOAT: {
      
// ROR Label 975
if((aff < 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 975);
}
// ROR Label 976
if((aff > 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 976);
}
// ROR Label 977
if((aff <= 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 977);
}
return aff>=SQLITE_AFF_NUMERIC;
    }
    case TK_STRING: {
      
// COR Label 978
if((!unaryMinus || aff == 66) != (!unaryMinus && aff == 66))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 978);
}

// ROR Label 979
if((aff != 66) != (aff == 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 979);
}

// MCC Label 980
if(!unaryMinus && aff == 66 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 980);
}
// MCC Label 981
if(!unaryMinus && !(aff == 66) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 981);
}
// MCC Label 982
if(!(!unaryMinus) && aff == 66 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 982);
}
// MCC Label 983
if(!(!unaryMinus) && !(aff == 66) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 983);
}
return !unaryMinus && aff==SQLITE_AFF_TEXT;
    }
    case TK_BLOB: {
      return !unaryMinus;
    }
    case TK_COLUMN: {
      assert( p->iTable>=0 );  /* p cannot be part of a CHECK constraint */
      
// COR Label 984
if((aff >= 67 || p->iColumn < 0) != (aff >= 67 && p->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 984);
}

// ROR Label 985
if((aff < 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 985);
}
// ROR Label 986
if((aff > 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 986);
}
// ROR Label 987
if((aff <= 67) != (aff >= 67))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 987);
}
// ROR Label 988
if((p->iColumn <= 0) != (p->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 988);
}
// ROR Label 989
if((p->iColumn > 0) != (p->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 989);
}
// ROR Label 990
if((p->iColumn >= 0) != (p->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 990);
}

// MCC Label 991
if(aff >= 67 && p->iColumn < 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 991);
}
// MCC Label 992
if(aff >= 67 && !(p->iColumn < 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 992);
}
// MCC Label 993
if(!(aff >= 67) && p->iColumn < 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 993);
}
// MCC Label 994
if(!(aff >= 67) && !(p->iColumn < 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 994);
}
return aff>=SQLITE_AFF_NUMERIC && p->iColumn<0;
    }
    default: {
      return 0;
    }
  }
}

/*
** Return TRUE if the given string is a row-id column name.
*/
int sqlite3IsRowid(const char *z){
  if( sqlite3StrICmp(z, "_ROWID_")==0 ) { return 1;
}
  if( sqlite3StrICmp(z, "ROWID")==0 ) { return 1;
}
  if( sqlite3StrICmp(z, "OID")==0 ) { return 1;
}
  return 0;
}

/*
** pX is the RHS of an IN operator.  If pX is a SELECT statement 
** that can be simplified to a direct table access, then return
** a pointer to the SELECT statement.  If pX is not a SELECT statement,
** or if the SELECT statement needs to be manifested into a transient
** table, then return NULL.
*/
#ifndef SQLITE_OMIT_SUBQUERY
static Select *isCandidateForInOpt(Expr *pX){
  Select *p;
  SrcList *pSrc;
  ExprList *pEList;
  Table *pTab;
  int i;
  if( !ExprHasProperty(pX, EP_xIsSelect) ) { return 0;  /* Not a subquery */
}
  
// MCC Label 995
if(( ((pX)->flags & (32)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 995);
}
// MCC Label 996
if(( !(((pX)->flags & (32)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 996);
}
if( ExprHasProperty(pX, EP_VarSelect)  ) { return 0;  /* Correlated subq */
}
  p = pX->x.pSelect;
  
// ABS Label 997
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}
if( p->pPrior ) { return 0;              /* Not a compound SELECT */
}
  
// ABS Label 998
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}

// AOR Label 999
if(p->selFlags | (1 | 8) != p->selFlags & (1 | 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 999);
}
// AOR Label 1000
if(p->selFlags ^ (1 | 8) != p->selFlags & (1 | 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1000);
}
if( p->selFlags & (SF_Distinct|SF_Aggregate) ){
    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );
    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );
    return 0; /* No DISTINCT keyword and no aggregate functions */
  }
  assert( p->pGroupBy==0 );              /* Has no GROUP BY clause */
  
// ABS Label 1001
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1001);
}
if( p->pLimit ) { return 0;              /* Has no LIMIT clause */
}
  
// ABS Label 1002
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}
if( p->pWhere ) { return 0;              /* Has no WHERE clause */
}
  pSrc = p->pSrc;
  assert( pSrc!=0 );
  
// ABS Label 1003
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// ROR Label 1004
if((pSrc->nSrc == 1) != (pSrc->nSrc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1004);
}
if( pSrc->nSrc!=1 ) { return 0;          /* Single term in FROM clause */
}
  
// ABS Label 1005
if(pSrc->a[0].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1005);
}
if( pSrc->a[0].pSelect ) { return 0;     /* FROM is not a subquery or view */
}
  pTab = pSrc->a[0].pTab;
  assert( pTab!=0 );
  assert( pTab->pSelect==0 );            /* FROM clause is not a view */
  
// ABS Label 1006
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}
if( IsVirtual(pTab) ) { return 0;        /* FROM clause not a virtual table */
}
  pEList = p->pEList;
  assert( pEList!=0 );
  /* All SELECT results must be columns. */
  i = 0;

// ABS Label 1007
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1007);
}
// ABS Label 1008
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1008);
}

// ROR Label 1009
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1009);
}
// ROR Label 1010
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1010);
}
// ROR Label 1011
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1011);
}
for(; i<pEList->nExpr; i++){
    
// ABS Label 1017
if(pEList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}
Expr *pRes = pEList->a[i].pExpr;
    
// ROR Label 1018
if((pRes->op == 166) != (pRes->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1018);
}
if( pRes->op!=TK_COLUMN ) { return 0;
}
    assert( pRes->iTable==pSrc->a[0].iCursor );  /* Not a correlated subquery */
  };
// ABS Label 1012
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1012);
}
// ABS Label 1013
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1013);
}

// ROR Label 1014
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1014);
}
// ROR Label 1015
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1015);
}
// ROR Label 1016
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1016);
}

  
// ABS Label 1019
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}
return p;
}
#endif /* SQLITE_OMIT_SUBQUERY */

#ifndef SQLITE_OMIT_SUBQUERY
/*
** Generate code that checks the left-most column of index table iCur to see if
** it contains any NULL entries.  Cause the register at regHasNull to be set
** to a non-NULL value if iCur contains no NULLs.  Cause register regHasNull
** to be set to NULL if iCur contains one or more NULL values.
*/
static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){
  int addr1;
  
// ABS Label 1020
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1020);
}

// ABS Label 1021
if(regHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1021);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);
  addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);
  
// ABS Label 1022
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1022);
}

// ABS Label 1023
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}

// ABS Label 1024
if(regHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1024);
}
sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);
  
// ABS Label 1025
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1025);
}
sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);
  VdbeComment((v, "first_entry_in(%d)", iCur));
  
// ABS Label 1026
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1026);
}

// ABS Label 1027
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1027);
}
sqlite3VdbeJumpHere(v, addr1);
}
#endif


#ifndef SQLITE_OMIT_SUBQUERY
/*
** The argument is an IN operator with a list (not a subquery) on the 
** right-hand side.  Return TRUE if that list is constant.
*/
static int sqlite3InRhsIsConstant(Expr *pIn){
  Expr *pLHS;
  int res;
  assert( !ExprHasProperty(pIn, EP_xIsSelect) );
  pLHS = pIn->pLeft;
  pIn->pLeft = 0;
  res = sqlite3ExprIsConstant(pIn);
  pIn->pLeft = pLHS;
  
// ABS Label 1028
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1028);
}
return res;
}
#endif

/*
** This function is used by the implementation of the IN (...) operator.
** The pX parameter is the expression on the RHS of the IN operator, which
** might be either a list of expressions or a subquery.
**
** The job of this routine is to find or create a b-tree object that can
** be used either to test for membership in the RHS set or to iterate through
** all members of the RHS set, skipping duplicates.
**
** A cursor is opened on the b-tree object that is the RHS of the IN operator
** and pX->iTable is set to the index of that cursor.
**
** The returned value of this function indicates the b-tree type, as follows:
**
**   IN_INDEX_ROWID      - The cursor was opened on a database table.
**   IN_INDEX_INDEX_ASC  - The cursor was opened on an ascending index.
**   IN_INDEX_INDEX_DESC - The cursor was opened on a descending index.
**   IN_INDEX_EPH        - The cursor was opened on a specially created and
**                         populated epheremal table.
**   IN_INDEX_NOOP       - No cursor was allocated.  The IN operator must be
**                         implemented as a sequence of comparisons.
**
** An existing b-tree might be used if the RHS expression pX is a simple
** subquery such as:
**
**     SELECT <column1>, <column2>... FROM <table>
**
** If the RHS of the IN operator is a list or a more complex subquery, then
** an ephemeral table might need to be generated from the RHS and then
** pX->iTable made to point to the ephemeral table instead of an
** existing table.
**
** The inFlags parameter must contain, at a minimum, one of the bits
** IN_INDEX_MEMBERSHIP or IN_INDEX_LOOP but not both.  If inFlags contains
** IN_INDEX_MEMBERSHIP, then the generated table will be used for a fast
** membership test.  When the IN_INDEX_LOOP bit is set, the IN index will
** be used to loop over all values of the RHS of the IN operator.
**
** When IN_INDEX_LOOP is used (and the b-tree will be used to iterate
** through the set members) then the b-tree must not contain duplicates.
** An epheremal table will be created unless the selected columns are guaranteed
** to be unique - either because it is an INTEGER PRIMARY KEY or due to
** a UNIQUE constraint or index.
**
** When IN_INDEX_MEMBERSHIP is used (and the b-tree will be used 
** for fast set membership tests) then an epheremal table must 
** be used unless <columns> is a single INTEGER PRIMARY KEY column or an 
** index can be found with the specified <columns> as its left-most.
**
** If the IN_INDEX_NOOP_OK and IN_INDEX_MEMBERSHIP are both set and
** if the RHS of the IN operator is a list (not a subquery) then this
** routine might decide that creating an ephemeral b-tree for membership
** testing is too expensive and return IN_INDEX_NOOP.  In that case, the
** calling routine should implement the IN operator using a sequence
** of Eq or Ne comparison operations.
**
** When the b-tree is being used for membership tests, the calling function
** might need to know whether or not the RHS side of the IN operator
** contains a NULL.  If prRhsHasNull is not a NULL pointer and 
** if there is any chance that the (...) might contain a NULL value at
** runtime, then a register is allocated and the register number written
** to *prRhsHasNull. If there is no chance that the (...) contains a
** NULL value, then *prRhsHasNull is left unchanged.
**
** If a register is allocated and its location stored in *prRhsHasNull, then
** the value in that register will be NULL if the b-tree contains one or more
** NULL values, and it will be some non-NULL value if the b-tree contains no
** NULL values.
**
** If the aiMap parameter is not NULL, it must point to an array containing
** one element for each column returned by the SELECT statement on the RHS
** of the IN(...) operator. The i'th entry of the array is populated with the
** offset of the index column that matches the i'th column returned by the
** SELECT. For example, if the expression and selected index are:
**
**   (?,?,?) IN (SELECT a, b, c FROM t1)
**   CREATE INDEX i1 ON t1(b, c, a);
**
** then aiMap[] is populated with {2, 0, 1}.
*/
#ifndef SQLITE_OMIT_SUBQUERY
int sqlite3FindInIndex(
  Parse *pParse,             /* Parsing context */
  Expr *pX,                  /* The IN expression */
  u32 inFlags,               /* IN_INDEX_LOOP, _MEMBERSHIP, and/or _NOOP_OK */
  int *prRhsHasNull,         /* Register holding NULL status.  See notes */
  int *aiMap,                /* Mapping from Index fields to RHS fields */
  int *piTab                 /* OUT: index to use */
){
  Select *p;                            /* SELECT to the right of IN operator */
  int eType = 0;                        /* Type of RHS table. IN_INDEX_* */
  int iTab = pParse->nTab++;            /* Cursor of the RHS table */
  int mustBeUnique;                     /* True if RHS must be unique */
  Vdbe *v = sqlite3GetVdbe(pParse);     /* Virtual machine being coded */

  assert( pX->op==TK_IN );
  mustBeUnique = (inFlags & IN_INDEX_LOOP)!=0;

  /* If the RHS of this IN(...) operator is a SELECT, and if it matters 
  ** whether or not the SELECT result contains NULL values, check whether
  ** or not NULL is actually possible (it may not be, for example, due 
  ** to NOT NULL constraints in the schema). If no NULL values are possible,
  ** set prRhsHasNull to 0 before continuing.  */
  
// ABS Label 1029
if(prRhsHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}

// COR Label 1030
if((prRhsHasNull || (pX->flags & 2048)) != (prRhsHasNull && (pX->flags & 2048)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1030);
}

// MCC Label 1031
if(prRhsHasNull && ( pX->flags & 2048 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1031);
}
// MCC Label 1032
if(prRhsHasNull && ( !(pX->flags & 2048) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1032);
}
// MCC Label 1033
if(!(prRhsHasNull) && ( pX->flags & 2048 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1033);
}
// MCC Label 1034
if(!(prRhsHasNull) && ( !(pX->flags & 2048) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1034);
}
if( prRhsHasNull && (pX->flags & EP_xIsSelect) ){
    int i;
    
// ABS Label 1035
if(pX->x.pSelect->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1035);
}
ExprList *pEList = pX->x.pSelect->pEList;
    i = 0;

// ABS Label 1036
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1036);
}
// ABS Label 1037
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1037);
}

// ROR Label 1038
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1038);
}
// ROR Label 1039
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1039);
}
// ROR Label 1040
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1040);
}
for(; i<pEList->nExpr; i++){
      if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) { break;
}
    };
// ABS Label 1041
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}
// ABS Label 1042
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}

// ROR Label 1043
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1043);
}
// ROR Label 1044
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1044);
}
// ROR Label 1045
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1045);
}

    
// ABS Label 1046
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1046);
}
// ABS Label 1047
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1047);
}

// ROR Label 1048
if((i != pEList->nExpr) != (i == pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1048);
}
if( i==pEList->nExpr ){
      prRhsHasNull = 0;
    }
  }

  /* Check to see if an existing table or index can be used to
  ** satisfy the query.  This is preferable to generating a new 
  ** ephemeral table.  */
  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
    
// ABS Label 1049
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}
sqlite3 *db = pParse->db;              /* Database connection */
    Table *pTab;                           /* Table <table>. */
    int iDb;                               /* Database idx for pTab */
    
// ABS Label 1050
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1050);
}
ExprList *pEList = p->pEList;
    
// ABS Label 1051
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}
int nExpr = pEList->nExpr;

    assert( p->pEList!=0 );             /* Because of isCandidateForInOpt(p) */
    assert( p->pEList->a[0].pExpr!=0 ); /* Because of isCandidateForInOpt(p) */
    assert( p->pSrc!=0 );               /* Because of isCandidateForInOpt(p) */
    pTab = p->pSrc->a[0].pTab;

    /* Code an OP_Transaction and OP_TableLock for <table>. */
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    assert( iDb>=0 && iDb<SQLITE_MAX_DB );
    
// ABS Label 1052
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}

// ABS Label 1053
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
sqlite3CodeVerifySchema(pParse, iDb);
    
// ABS Label 1054
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}

// ABS Label 1055
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}

// ABS Label 1056
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1056);
}
sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

    assert(v);  /* sqlite3GetVdbe() has always been previously called */
    
// ABS Label 1057
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}

// COR Label 1058
if((nExpr == 1 || pEList->a[0].pExpr->iColumn < 0) != (nExpr == 1 && pEList->a[0].pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1058);
}

// ROR Label 1059
if((nExpr != 1) != (nExpr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1059);
}
// ROR Label 1060
if((pEList->a[0].pExpr->iColumn <= 0) != (pEList->a[0].pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1060);
}
// ROR Label 1061
if((pEList->a[0].pExpr->iColumn > 0) != (pEList->a[0].pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1061);
}
// ROR Label 1062
if((pEList->a[0].pExpr->iColumn >= 0) != (pEList->a[0].pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1062);
}

// MCC Label 1063
if(nExpr == 1 && pEList->a[0].pExpr->iColumn < 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1063);
}
// MCC Label 1064
if(nExpr == 1 && !(pEList->a[0].pExpr->iColumn < 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1064);
}
// MCC Label 1065
if(!(nExpr == 1) && pEList->a[0].pExpr->iColumn < 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1065);
}
// MCC Label 1066
if(!(nExpr == 1) && !(pEList->a[0].pExpr->iColumn < 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1066);
}
if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){
      /* The "x IN (SELECT rowid FROM table)" case */
      int iAddr = sqlite3VdbeAddOp0(v, OP_Once);
      VdbeCoverage(v);

      
// ABS Label 1067
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}

// ABS Label 1068
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1068);
}

// ABS Label 1069
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1069);
}

// ABS Label 1070
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1070);
}
sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);
      eType = IN_INDEX_ROWID;
      ExplainQueryPlan((pParse, 0,
            "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR",pTab->zName));
      
// ABS Label 1073
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1073);
}

// ABS Label 1074
if(iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1074);
}
sqlite3VdbeJumpHere(v, iAddr);
    }else{
      Index *pIdx;                         /* Iterator variable */
      int affinity_ok = 1;
      int i;

      /* Check that the affinity that will be used to perform each 
      ** comparison is the same as the affinity of each column in table
      ** on the RHS of the IN operator.  If it not, it is not possible to
      ** use any index of the RHS table.  */
      i = 0;

// ABS Label 1075
if(affinity_ok < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1075);
}
// ABS Label 1076
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1076);
}
// ABS Label 1077
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1077);
}

// COR Label 1078
if((i < nExpr || affinity_ok) != (i < nExpr && affinity_ok))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1078);
}

// ROR Label 1079
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1079);
}
// ROR Label 1080
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1080);
}
// ROR Label 1081
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1081);
}

// MCC Label 1082
if(i < nExpr && affinity_ok ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1082);
}
// MCC Label 1083
if(i < nExpr && !(affinity_ok) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1083);
}
// MCC Label 1084
if(!(i < nExpr) && affinity_ok ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1084);
}
// MCC Label 1085
if(!(i < nExpr) && !(affinity_ok) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1085);
}
for(; i<nExpr && affinity_ok; i++){
        Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
        int iCol = pEList->a[i].pExpr->iColumn;
        char idxaff = sqlite3TableColumnAffinity(pTab,iCol); /* RHS table */
        char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);
        testcase( cmpaff==SQLITE_AFF_BLOB );
        testcase( cmpaff==SQLITE_AFF_TEXT );
        switch( cmpaff ){
          case SQLITE_AFF_BLOB:
            break;
          case SQLITE_AFF_TEXT:
            /* sqlite3CompareAffinity() only returns TEXT if one side or the
            ** other has no affinity and the other side is TEXT.  Hence,
            ** the only way for cmpaff to be TEXT is for idxaff to be TEXT
            ** and for the term on the LHS of the IN to have no affinity. */
            assert( idxaff==SQLITE_AFF_TEXT );
            break;
          default:
            affinity_ok = sqlite3IsNumericAffinity(idxaff);
        }
      };
// ABS Label 1086
if(affinity_ok < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1086);
}
// ABS Label 1087
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1087);
}
// ABS Label 1088
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}

// COR Label 1089
if((i < nExpr || affinity_ok) != (i < nExpr && affinity_ok))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1089);
}

// ROR Label 1090
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1090);
}
// ROR Label 1091
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1091);
}
// ROR Label 1092
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1092);
}

// MCC Label 1093
if(i < nExpr && affinity_ok ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1093);
}
// MCC Label 1094
if(i < nExpr && !(affinity_ok) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1094);
}
// MCC Label 1095
if(!(i < nExpr) && affinity_ok ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1095);
}
// MCC Label 1096
if(!(i < nExpr) && !(affinity_ok) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1096);
}


      
// ABS Label 1097
if(affinity_ok < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1097);
}
if( affinity_ok ){
        /* Search for an existing index that will work for this IN operator */
        pIdx = pTab->pIndex;

// ABS Label 1098
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1098);
}
// ABS Label 1099
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}

// COR Label 1100
if((pIdx || eType == 0) != (pIdx && eType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1100);
}

// ROR Label 1101
if((eType != 0) != (eType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1101);
}

// MCC Label 1102
if(pIdx && eType == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1102);
}
// MCC Label 1103
if(pIdx && !(eType == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1103);
}
// MCC Label 1104
if(!(pIdx) && eType == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1104);
}
// MCC Label 1105
if(!(pIdx) && !(eType == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1105);
}
for(; pIdx && eType==0; pIdx=pIdx->pNext){
          Bitmask colUsed;      /* Columns of the index used */
          Bitmask mCol;         /* Mask for the current column */
          
// ABS Label 1114
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1114);
}

// ROR Label 1115
if((pIdx->nColumn <= nExpr) != (pIdx->nColumn < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1115);
}
// ROR Label 1116
if((pIdx->nColumn > nExpr) != (pIdx->nColumn < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1116);
}
// ROR Label 1117
if((pIdx->nColumn >= nExpr) != (pIdx->nColumn < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1117);
}
if( pIdx->nColumn<nExpr ) { continue;
}
          
// ABS Label 1118
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1118);
}

// ROR Label 1119
if((pIdx->pPartIdxWhere == 0) != (pIdx->pPartIdxWhere != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1119);
}
if( pIdx->pPartIdxWhere!=0 ) { continue;
}
          /* Maximum nColumn is BMS-2, not BMS-1, so that we can compute
          ** BITMASK(nExpr) without overflowing */
          testcase( pIdx->nColumn==BMS-2 );
          testcase( pIdx->nColumn==BMS-1 );
          
// AOR Label 1120
if(((int)(sizeof(Bitmask) * 8)) / 1 != ((int)(sizeof(Bitmask) * 8)) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1120);
}
// AOR Label 1121
if(((int)(sizeof(Bitmask) * 8)) + 1 != ((int)(sizeof(Bitmask) * 8)) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1121);
}
// AOR Label 1122
if(((int)(sizeof(Bitmask) * 8)) * 1 != ((int)(sizeof(Bitmask) * 8)) - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1122);
}

// ROR Label 1123
if((pIdx->nColumn < ((int)(sizeof(Bitmask) * 8)) - 1) != (pIdx->nColumn >= ((int)(sizeof(Bitmask) * 8)) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1123);
}
// ROR Label 1124
if((pIdx->nColumn > ((int)(sizeof(Bitmask) * 8)) - 1) != (pIdx->nColumn >= ((int)(sizeof(Bitmask) * 8)) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1124);
}
// ROR Label 1125
if((pIdx->nColumn <= ((int)(sizeof(Bitmask) * 8)) - 1) != (pIdx->nColumn >= ((int)(sizeof(Bitmask) * 8)) - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1125);
}
if( pIdx->nColumn>=BMS-1 ) { continue;
}
          
// ABS Label 1126
if(mustBeUnique < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1126);
}
if( mustBeUnique ){
            
// ABS Label 1127
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}

// COR Label 1128
if((pIdx->nKeyCol > nExpr && (pIdx->nColumn > nExpr && !((pIdx)->onError != 0))) != (pIdx->nKeyCol > nExpr || (pIdx->nColumn > nExpr && !((pIdx)->onError != 0))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1128);
}

// ROR Label 1129
if((pIdx->nKeyCol <= nExpr) != (pIdx->nKeyCol > nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1129);
}
// ROR Label 1130
if((pIdx->nKeyCol < nExpr) != (pIdx->nKeyCol > nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1130);
}
// ROR Label 1131
if((pIdx->nKeyCol >= nExpr) != (pIdx->nKeyCol > nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1131);
}

// MCC Label 1132
if(pIdx->nKeyCol > nExpr && ( pIdx->nColumn > nExpr && !((pIdx)->onError != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1132);
}
// MCC Label 1133
if(pIdx->nKeyCol > nExpr && ( pIdx->nColumn > nExpr && !(!((pIdx)->onError != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1133);
}
// MCC Label 1134
if(pIdx->nKeyCol > nExpr && ( !(pIdx->nColumn > nExpr) && !((pIdx)->onError != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1134);
}
// MCC Label 1135
if(pIdx->nKeyCol > nExpr && ( !(pIdx->nColumn > nExpr) && !(!((pIdx)->onError != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1135);
}
// MCC Label 1136
if(!(pIdx->nKeyCol > nExpr) && ( pIdx->nColumn > nExpr && !((pIdx)->onError != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1136);
}
// MCC Label 1137
if(!(pIdx->nKeyCol > nExpr) && ( pIdx->nColumn > nExpr && !(!((pIdx)->onError != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1137);
}
// MCC Label 1138
if(!(pIdx->nKeyCol > nExpr) && ( !(pIdx->nColumn > nExpr) && !((pIdx)->onError != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1138);
}
// MCC Label 1139
if(!(pIdx->nKeyCol > nExpr) && ( !(pIdx->nColumn > nExpr) && !(!((pIdx)->onError != 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1139);
}
if( pIdx->nKeyCol>nExpr
             ||(pIdx->nColumn>nExpr && !IsUniqueIndex(pIdx))
            ){
              continue;  /* This index is not unique over the IN RHS columns */
            }
          }
  
          colUsed = 0;   /* Columns of index used so far */
          i = 0;

// ABS Label 1140
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1140);
}
// ABS Label 1141
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1141);
}

// ROR Label 1142
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1142);
}
// ROR Label 1143
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1143);
}
// ROR Label 1144
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1144);
}
for(; i<nExpr; i++){
            Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
            
// ABS Label 1150
if(pEList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1150);
}
Expr *pRhs = pEList->a[i].pExpr;
            CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
            int j;
  
            assert( pReq!=0 || pRhs->iColumn==XN_ROWID || pParse->nErr );
            j = 0;

// ABS Label 1151
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1151);
}
// ABS Label 1152
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}

// ROR Label 1153
if((j <= nExpr) != (j < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1153);
}
// ROR Label 1154
if((j > nExpr) != (j < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1154);
}
// ROR Label 1155
if((j >= nExpr) != (j < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1155);
}
for(; j<nExpr; j++){
              
// ROR Label 1161
if((pIdx->aiColumn[j] == pRhs->iColumn) != (pIdx->aiColumn[j] != pRhs->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1161);
}
if( pIdx->aiColumn[j]!=pRhs->iColumn ) { continue;
}
              assert( pIdx->azColl[j] );
              if( pReq!=0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j])!=0 ){
                continue;
              }
              break;
            };
// ABS Label 1156
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}
// ABS Label 1157
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}

// ROR Label 1158
if((j <= nExpr) != (j < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1158);
}
// ROR Label 1159
if((j > nExpr) != (j < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1159);
}
// ROR Label 1160
if((j >= nExpr) != (j < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1160);
}

            
// ABS Label 1162
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1162);
}
// ABS Label 1163
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}

// ROR Label 1164
if((j != nExpr) != (j == nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1164);
}
if( j==nExpr ) { break;
}
            mCol = MASKBIT(j);
            
// ABS Label 1165
if(colUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1165);
}
// ABS Label 1166
if(mCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1166);
}

// AOR Label 1167
if(mCol | colUsed != mCol & colUsed)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1167);
}
// AOR Label 1168
if(mCol ^ colUsed != mCol & colUsed)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1168);
}
if( mCol & colUsed ) { break; /* Each column used only once */
}
            colUsed |= mCol;
            
// ABS Label 1169
if(aiMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1169);
}
if( aiMap ) { aiMap[i] = j;
}
          };
// ABS Label 1145
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1145);
}
// ABS Label 1146
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1146);
}

// ROR Label 1147
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1147);
}
// ROR Label 1148
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1148);
}
// ROR Label 1149
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1149);
}

  
          assert( i==nExpr || colUsed!=(MASKBIT(nExpr)-1) );
          
// ABS Label 1170
if(colUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1170);
}

// ROR Label 1171
if((colUsed != ((((Bitmask)1) << (nExpr)) - 1)) != (colUsed == ((((Bitmask)1) << (nExpr)) - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1171);
}
if( colUsed==(MASKBIT(nExpr)-1) ){
            /* If we reach this point, that means the index pIdx is usable */
            int iAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
            ExplainQueryPlan((pParse, 0,
                              "USING INDEX %s FOR IN-OPERATOR",pIdx->zName));
            
// ABS Label 1174
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1174);
}

// ABS Label 1175
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}

// ABS Label 1176
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1176);
}
sqlite3VdbeAddOp3(v, OP_OpenRead, iTab, pIdx->tnum, iDb);
            
// ABS Label 1177
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1177);
}

// ABS Label 1178
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1178);
}
sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
            VdbeComment((v, "%s", pIdx->zName));
            assert( IN_INDEX_INDEX_DESC == IN_INDEX_INDEX_ASC+1 );
            eType = IN_INDEX_INDEX_ASC + pIdx->aSortOrder[0];
  
            
// ABS Label 1181
if(prRhsHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1181);
}
if( prRhsHasNull ){
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
              i64 mask = (1<<nExpr)-1;
              sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, 
                  iTab, 0, 0, (u8*)&mask, P4_INT64);
#endif
              *prRhsHasNull = ++pParse->nMem;
              
// ABS Label 1182
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1182);
}

// ROR Label 1183
if((nExpr != 1) != (nExpr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1183);
}
if( nExpr==1 ){
                
// ABS Label 1184
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1184);
}

// ABS Label 1185
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}

// ABS Label 1186
if(*prRhsHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1186);
}
sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);
              }
            }
            
// ABS Label 1179
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1179);
}

// ABS Label 1180
if(iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1180);
}
sqlite3VdbeJumpHere(v, iAddr);
          }
        };
// ABS Label 1106
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1106);
}
// ABS Label 1107
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1107);
}

// COR Label 1108
if((pIdx || eType == 0) != (pIdx && eType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1108);
}

// ROR Label 1109
if((eType != 0) != (eType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1109);
}

// MCC Label 1110
if(pIdx && eType == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1110);
}
// MCC Label 1111
if(pIdx && !(eType == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1111);
}
// MCC Label 1112
if(!(pIdx) && eType == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1112);
}
// MCC Label 1113
if(!(pIdx) && !(eType == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1113);
}
 /* End loop over indexes */
      } /* End if( affinity_ok ) */
    } /* End if not an rowid index */
  } /* End attempt to optimize using an index */

  /* If no preexisting index is available for the IN clause
  ** and IN_INDEX_NOOP is an allowed reply
  ** and the RHS of the IN operator is a list, not a subquery
  ** and the RHS is not constant or has two or fewer terms,
  ** then it is not worth creating an ephemeral table to evaluate
  ** the IN operator so return IN_INDEX_NOOP.
  */
  if( eType==0
   && (inFlags & IN_INDEX_NOOP_OK)
   && !ExprHasProperty(pX, EP_xIsSelect)
   && (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr<=2)
  ){
    eType = IN_INDEX_NOOP;
  }

  
// ABS Label 1187
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}

// ROR Label 1188
if((eType != 0) != (eType == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1188);
}
if( eType==0 ){
    /* Could not find an existing table or index to use as the RHS b-tree.
    ** We will have to generate an ephemeral table to do the job.
    */
    
// ABS Label 1189
if(pParse->nQueryLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1189);
}
u32 savedNQueryLoop = pParse->nQueryLoop;
    int rMayHaveNull = 0;
    eType = IN_INDEX_EPH;
    
// ABS Label 1193
if(inFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1193);
}

// AOR Label 1194
if(inFlags | 4 != inFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1194);
}
// AOR Label 1195
if(inFlags ^ 4 != inFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1195);
}
if( inFlags & IN_INDEX_LOOP ){
      pParse->nQueryLoop = 0;
    }else { 
// ABS Label 1196
if(prRhsHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1196);
}
if( prRhsHasNull ){
      *prRhsHasNull = rMayHaveNull = ++pParse->nMem;
    };}

    assert( pX->op==TK_IN );
    
// ABS Label 1190
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}

// ABS Label 1191
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}

// ABS Label 1192
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1192);
}
sqlite3CodeRhsOfIN(pParse, pX, iTab);
    
// ABS Label 1197
if(rMayHaveNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1197);
}
if( rMayHaveNull ){
      
// ABS Label 1198
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1198);
}

// ABS Label 1199
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}

// ABS Label 1200
if(rMayHaveNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1200);
}
sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);
    }
    pParse->nQueryLoop = savedNQueryLoop;
  }

  
// ABS Label 1201
if(aiMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1201);
}
// ABS Label 1202
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1202);
}

// COR Label 1203
if((aiMap && eType != 3 || eType != 4) != (aiMap && eType != 3 && eType != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1203);
}
// COR Label 1204
if((aiMap || eType != 3) != (aiMap && eType != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1204);
}

// ROR Label 1205
if((eType == 3) != (eType != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1205);
}
// ROR Label 1206
if((eType == 4) != (eType != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1206);
}

// MCC Label 1207
if(aiMap && eType != 3 && eType != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1207);
}
// MCC Label 1208
if(aiMap && eType != 3 && !(eType != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1208);
}
// MCC Label 1209
if(aiMap && !(eType != 3) && eType != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1209);
}
// MCC Label 1210
if(aiMap && !(eType != 3) && !(eType != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1210);
}
// MCC Label 1211
if(!(aiMap) && eType != 3 && eType != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1211);
}
// MCC Label 1212
if(!(aiMap) && eType != 3 && !(eType != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1212);
}
// MCC Label 1213
if(!(aiMap) && !(eType != 3) && eType != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1213);
}
// MCC Label 1214
if(!(aiMap) && !(eType != 3) && !(eType != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1214);
}
if( aiMap && eType!=IN_INDEX_INDEX_ASC && eType!=IN_INDEX_INDEX_DESC ){
    int i, n;
    n = sqlite3ExprVectorSize(pX->pLeft);
    i = 0;

// ABS Label 1215
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1215);
}
// ABS Label 1216
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1216);
}

// ROR Label 1217
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1217);
}
// ROR Label 1218
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1218);
}
// ROR Label 1219
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1219);
}
for(; i<n; i++) { aiMap[i] = i;
};
// ABS Label 1220
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1220);
}
// ABS Label 1221
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1221);
}

// ROR Label 1222
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1222);
}
// ROR Label 1223
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1223);
}
// ROR Label 1224
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1224);
}

  }
  *piTab = iTab;
  
// ABS Label 1225
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1225);
}
return eType;
}
#endif

#ifndef SQLITE_OMIT_SUBQUERY
/*
** Argument pExpr is an (?, ?...) IN(...) expression. This 
** function allocates and returns a nul-terminated string containing 
** the affinities to be used for each column of the comparison.
**
** It is the responsibility of the caller to ensure that the returned
** string is eventually freed using sqlite3DbFree().
*/
static char *exprINAffinity(Parse *pParse, Expr *pExpr){
  
// ABS Label 1226
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1226);
}
Expr *pLeft = pExpr->pLeft;
  int nVal = sqlite3ExprVectorSize(pLeft);
  Select *pSelect = (pExpr->flags & EP_xIsSelect) ? pExpr->x.pSelect : 0;
  char *zRet;

  assert( pExpr->op==TK_IN );
  zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);
  
// ABS Label 1227
if(zRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1227);
}
if( zRet ){
    int i;
    i = 0;

// ABS Label 1228
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1228);
}
// ABS Label 1229
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1229);
}

// ROR Label 1230
if((i <= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1230);
}
// ROR Label 1231
if((i > nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1231);
}
// ROR Label 1232
if((i >= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1232);
}
for(; i<nVal; i++){
      Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);
      char a = sqlite3ExprAffinity(pA);
      
// ABS Label 1238
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1238);
}
if( pSelect ){
        zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);
      }else{
        zRet[i] = a;
      }
    };
// ABS Label 1233
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1233);
}
// ABS Label 1234
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1234);
}

// ROR Label 1235
if((i <= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1235);
}
// ROR Label 1236
if((i > nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1236);
}
// ROR Label 1237
if((i >= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1237);
}

    zRet[nVal] = '\0';
  }
  
// ABS Label 1239
if(zRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1239);
}
return zRet;
}
#endif

#ifndef SQLITE_OMIT_SUBQUERY
/*
** Load the Parse object passed as the first argument with an error 
** message of the form:
**
**   "sub-select returns N columns - expected M"
*/   
void sqlite3SubselectError(Parse *pParse, int nActual, int nExpect){
  
// ABS Label 1240
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1240);
}

// ROR Label 1241
if((pParse->nErr != 0) != (pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1241);
}
if( pParse->nErr==0 ){
    const char *zFmt = "sub-select returns %d columns - expected %d";
    
// ABS Label 1242
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1242);
}

// ABS Label 1243
if(zFmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1243);
}

// ABS Label 1244
if(nActual < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1244);
}

// ABS Label 1245
if(nExpect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1245);
}
sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);
  }
}
#endif

/*
** Expression pExpr is a vector that has been used in a context where
** it is not permitted. If pExpr is a sub-select vector, this routine 
** loads the Parse object with a message of the form:
**
**   "sub-select returns N columns - expected 1"
**
** Or, if it is a regular scalar vector:
**
**   "row value misused"
*/   
void sqlite3VectorErrorMsg(Parse *pParse, Expr *pExpr){
#ifndef SQLITE_OMIT_SUBQUERY
  
// ABS Label 1246
if(pExpr->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1246);
}

// AOR Label 1247
if(pExpr->flags | 2048 != pExpr->flags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1247);
}
// AOR Label 1248
if(pExpr->flags ^ 2048 != pExpr->flags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1248);
}
if( pExpr->flags & EP_xIsSelect ){
    
// ABS Label 1249
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1249);
}

// ABS Label 1250
if(pExpr->x.pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1250);
}
sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);
  }else
#endif
  {
    
// ABS Label 1251
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1251);
}
sqlite3ErrorMsg(pParse, "row value misused");
  }
}

#ifndef SQLITE_OMIT_SUBQUERY
/*
** Generate code that will construct an ephemeral table containing all terms
** in the RHS of an IN operator.  The IN operator can be in either of two
** forms:
**
**     x IN (4,5,11)              -- IN operator with list on right-hand side
**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right
**
** The pExpr parameter is the IN operator.  The cursor number for the
** constructed ephermeral table is returned.  The first time the ephemeral
** table is computed, the cursor number is also stored in pExpr->iTable,
** however the cursor number returned might not be the same, as it might
** have been duplicated using OP_OpenDup.
**
** If the LHS expression ("x" in the examples) is a column value, or
** the SELECT statement returns a column value, then the affinity of that
** column is used to build the index keys. If both 'x' and the
** SELECT... statement are columns, then numeric affinity is used
** if either column has NUMERIC or INTEGER affinity. If neither
** 'x' nor the SELECT... statement are columns, then numeric affinity
** is used.
*/
void sqlite3CodeRhsOfIN(
  Parse *pParse,          /* Parsing context */
  Expr *pExpr,            /* The IN operator */
  int iTab                /* Use this cursor number */
){
  int addrOnce = 0;           /* Address of the OP_Once instruction at top */
  int addr;                   /* Address of OP_OpenEphemeral instruction */
  Expr *pLeft;                /* the LHS of the IN operator */
  KeyInfo *pKeyInfo = 0;      /* Key information */
  int nVal;                   /* Size of vector pLeft */
  Vdbe *v;                    /* The prepared statement under construction */

  v = pParse->pVdbe;
  assert( v!=0 );

  /* The evaluation of the IN must be repeated every time it
  ** is encountered if any of the following is true:
  **
  **    *  The right-hand side is a correlated subquery
  **    *  The right-hand side is an expression list containing variables
  **    *  We are inside a trigger
  **
  ** If all of the above are false, then we can compute the RHS just once
  ** and reuse it many names.
  */
  
// ABS Label 1252
if(pParse->iSelfTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1252);
}

// COR Label 1253
if((!(((pExpr)->flags & (32)) != 0) || pParse->iSelfTab == 0) != (!(((pExpr)->flags & (32)) != 0) && pParse->iSelfTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1253);
}

// ROR Label 1254
if((pParse->iSelfTab != 0) != (pParse->iSelfTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1254);
}

// MCC Label 1255
if(!(((pExpr)->flags & (32)) != 0) && pParse->iSelfTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1255);
}
// MCC Label 1256
if(!(((pExpr)->flags & (32)) != 0) && !(pParse->iSelfTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1256);
}
// MCC Label 1257
if(!(!(((pExpr)->flags & (32)) != 0)) && pParse->iSelfTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1257);
}
// MCC Label 1258
if(!(!(((pExpr)->flags & (32)) != 0)) && !(pParse->iSelfTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1258);
}
if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){
    /* Reuse of the RHS is allowed */
    /* If this routine has already been coded, but the previous code
    ** might not have been invoked yet, so invoke it now as a subroutine. 
    */
    
// MCC Label 1259
if(( ((pExpr)->flags & (33554432)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1259);
}
// MCC Label 1260
if(( !(((pExpr)->flags & (33554432)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1260);
}
if( ExprHasProperty(pExpr, EP_Subrtn) ){
      addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
      
// MCC Label 1269
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1269);
}
// MCC Label 1270
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1270);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
        ExplainQueryPlan((pParse, 0, "REUSE LIST SUBQUERY %d",
              pExpr->x.pSelect->selId));
      }
      
// ABS Label 1261
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1261);
}

// ABS Label 1262
if(pExpr->y.sub.regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1262);
}

// ABS Label 1263
if(pExpr->y.sub.iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1263);
}
sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,
                        pExpr->y.sub.iAddr);
      
// ABS Label 1264
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1264);
}

// ABS Label 1265
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1265);
}

// ABS Label 1266
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1266);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, iTab, pExpr->iTable);
      
// ABS Label 1267
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1267);
}

// ABS Label 1268
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1268);
}
sqlite3VdbeJumpHere(v, addrOnce);
      return;
    }

    /* Begin coding the subroutine */
    ExprSetProperty(pExpr, EP_Subrtn);
    assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
    pExpr->y.sub.regReturn = ++pParse->nMem;
    pExpr->y.sub.iAddr =
      sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;
    VdbeComment((v, "return address"));

    addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
  }

  /* Check to see if this is a vector IN operator */
  pLeft = pExpr->pLeft;
  nVal = sqlite3ExprVectorSize(pLeft);

  /* Construct the ephemeral table that will contain the content of
  ** RHS of the IN operator.
  */
  pExpr->iTable = iTab;
  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pExpr->iTable, nVal);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
  if( ExprHasProperty(pExpr, EP_xIsSelect) ){
    VdbeComment((v, "Result of SELECT %u", pExpr->x.pSelect->selId));
  }else{
    VdbeComment((v, "RHS of IN operator"));
  }
#endif
  pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);

  
// MCC Label 1273
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1273);
}
// MCC Label 1274
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1274);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
    /* Case 1:     expr IN (SELECT ...)
    **
    ** Generate code to write the results of the select into the temporary
    ** table allocated and opened above.
    */
    
// ABS Label 1275
if(pExpr->x.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1275);
}
Select *pSelect = pExpr->x.pSelect;
    
// ABS Label 1276
if(pSelect->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1276);
}
ExprList *pEList = pSelect->pEList;

    ExplainQueryPlan((pParse, 1, "%sLIST SUBQUERY %d",
        addrOnce?"":"CORRELATED ", pSelect->selId
    ));
    /* If the LHS and RHS of the IN operator do not match, that
    ** error will have been caught long before we reach this point. */
    
// MCC Label 1279
if(( pEList->nExpr == nVal ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1279);
}
// MCC Label 1280
if(( !(pEList->nExpr == nVal) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1280);
}
if( ALWAYS(pEList->nExpr==nVal) ){
      Select *pCopy;
      SelectDest dest;
      int i;
      int rc;
      
// ABS Label 1281
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1281);
}
sqlite3SelectDestInit(&dest, SRT_Set, iTab);
      dest.zAffSdst = exprINAffinity(pParse, pExpr);
      pSelect->iLimit = 0;
      testcase( pSelect->selFlags & SF_Distinct );
      testcase( pKeyInfo==0 ); /* Caused by OOM in sqlite3KeyInfoAlloc() */
      pCopy = sqlite3SelectDup(pParse->db, pSelect, 0);
      rc = pParse->db->mallocFailed ? 1 :sqlite3Select(pParse, pCopy, &dest);
      
// ABS Label 1282
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1282);
}

// ABS Label 1283
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1283);
}
sqlite3SelectDelete(pParse->db, pCopy);
      
// ABS Label 1284
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1284);
}
sqlite3DbFree(pParse->db, dest.zAffSdst);
      
// ABS Label 1285
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1285);
}
if( rc ){
        
// ABS Label 1286
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1286);
}
sqlite3KeyInfoUnref(pKeyInfo);
        return;
      }      
      assert( pKeyInfo!=0 ); /* OOM will cause exit after sqlite3Select() */
      assert( pEList!=0 );
      assert( pEList->nExpr>0 );
      assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );
      i = 0;

// ABS Label 1287
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1287);
}
// ABS Label 1288
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1288);
}

// ROR Label 1289
if((i <= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1289);
}
// ROR Label 1290
if((i > nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1290);
}
// ROR Label 1291
if((i >= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1291);
}
for(; i<nVal; i++){
        Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);
        pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(
            pParse, p, pEList->a[i].pExpr
        );
      };
// ABS Label 1292
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1292);
}
// ABS Label 1293
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1293);
}

// ROR Label 1294
if((i <= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1294);
}
// ROR Label 1295
if((i > nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1295);
}
// ROR Label 1296
if((i >= nVal) != (i < nVal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1296);
}

    }
  }else { 
// MCC Label 1297
if(( pExpr->x.pList != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1297);
}
// MCC Label 1298
if(( !(pExpr->x.pList != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1298);
}
if( ALWAYS(pExpr->x.pList!=0) ){
    /* Case 2:     expr IN (exprlist)
    **
    ** For each expression, build an index key from the evaluation and
    ** store it in the temporary table. If <expr> is a column, then use
    ** that columns affinity when building index keys. If <expr> is not
    ** a column, use numeric affinity.
    */
    char affinity;            /* Affinity of the LHS of the IN */
    int i;
    
// ABS Label 1299
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1299);
}
ExprList *pList = pExpr->x.pList;
    struct ExprList_item *pItem;
    int r1, r2;
    affinity = sqlite3ExprAffinity(pLeft);
    
// ROR Label 1304
if((affinity < 64) != (affinity <= 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1304);
}
// ROR Label 1305
if((affinity > 64) != (affinity <= 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1305);
}
// ROR Label 1306
if((affinity >= 64) != (affinity <= 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1306);
}
if( affinity<=SQLITE_AFF_NONE ){
      affinity = SQLITE_AFF_BLOB;
    }else { 
// ROR Label 1307
if((affinity != 69) != (affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1307);
}
if( affinity==SQLITE_AFF_REAL ){
      affinity = SQLITE_AFF_NUMERIC;
    };}

    
// ABS Label 1308
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1308);
}
if( pKeyInfo ){
      assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );
      pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    }

    /* Loop through each expression in <exprlist>. */
    r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3GetTempReg(pParse);
    i = pList->nExpr , pItem = pList->a;

// ABS Label 1309
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1309);
}

// ROR Label 1310
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1310);
}
// ROR Label 1311
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1311);
}
// ROR Label 1312
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1312);
}
for(; i>0; i--, pItem++){
      
// ABS Label 1317
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1317);
}
Expr *pE2 = pItem->pExpr;

      /* If the expression is not constant then we will need to
      ** disable the test that was generated above that makes sure
      ** this code only executes once.  Because for a non-constant
      ** expression we need to rerun this code each time.
      */
      if( addrOnce && !sqlite3ExprIsConstant(pE2) ){
        
// ABS Label 1328
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1328);
}

// ABS Label 1329
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1329);
}
sqlite3VdbeChangeToNoop(v, addrOnce);
        ExprClearProperty(pExpr, EP_Subrtn);
        addrOnce = 0;
      }

      /* Evaluate the expression and insert it into the temp table */
      
// ABS Label 1318
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1318);
}

// ABS Label 1319
if(pE2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1319);
}

// ABS Label 1320
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1320);
}
sqlite3ExprCode(pParse, pE2, r1);
      
// ABS Label 1321
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1321);
}

// ABS Label 1322
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1322);
}

// ABS Label 1323
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1323);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, r1, 1, r2, &affinity, 1);
      
// ABS Label 1324
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1324);
}

// ABS Label 1325
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1325);
}

// ABS Label 1326
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1326);
}

// ABS Label 1327
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1327);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r2, r1, 1);
    };
// ABS Label 1313
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1313);
}

// ROR Label 1314
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1314);
}
// ROR Label 1315
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1315);
}
// ROR Label 1316
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1316);
}

    
// ABS Label 1300
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1300);
}

// ABS Label 1301
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1301);
}
sqlite3ReleaseTempReg(pParse, r1);
    
// ABS Label 1302
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1302);
}

// ABS Label 1303
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1303);
}
sqlite3ReleaseTempReg(pParse, r2);
  };}

  
// ABS Label 1330
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1330);
}
if( pKeyInfo ){
    
// ABS Label 1331
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1331);
}

// ABS Label 1332
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1332);
}
sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);
  }
  
// ABS Label 1333
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1333);
}
if( addrOnce ){
    
// ABS Label 1334
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1334);
}

// ABS Label 1335
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1335);
}
sqlite3VdbeJumpHere(v, addrOnce);
    /* Subroutine return */
    
// ABS Label 1336
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1336);
}

// ABS Label 1337
if(pExpr->y.sub.regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1337);
}
sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);
    
// ABS Label 1338
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1338);
}

// ABS Label 1339
if(pExpr->y.sub.iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1339);
}

// AOR Label 1340
if(pExpr->y.sub.iAddr / 1 != pExpr->y.sub.iAddr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1340);
}
// AOR Label 1341
if(pExpr->y.sub.iAddr + 1 != pExpr->y.sub.iAddr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1341);
}
// AOR Label 1342
if(pExpr->y.sub.iAddr * 1 != pExpr->y.sub.iAddr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1342);
}
sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);
    
// ABS Label 1343
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1343);
}
sqlite3ClearTempRegCache(pParse);
  }
}
#endif /* SQLITE_OMIT_SUBQUERY */

/*
** Generate code for scalar subqueries used as a subquery expression
** or EXISTS operator:
**
**     (SELECT a FROM b)          -- subquery
**     EXISTS (SELECT a FROM b)   -- EXISTS subquery
**
** The pExpr parameter is the SELECT or EXISTS operator to be coded.
**
** Return the register that holds the result.  For a multi-column SELECT, 
** the result is stored in a contiguous array of registers and the
** return value is the register of the left-most result column.
** Return 0 if an error occurs.
*/
#ifndef SQLITE_OMIT_SUBQUERY
int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){
  int addrOnce = 0;           /* Address of OP_Once at top of subroutine */
  int rReg = 0;               /* Register storing resulting */
  Select *pSel;               /* SELECT statement to encode */
  SelectDest dest;            /* How to deal with SELECT result */
  int nReg;                   /* Registers to allocate */
  Expr *pLimit;               /* New limit expression */

  
// ABS Label 1344
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1344);
}
Vdbe *v = pParse->pVdbe;
  assert( v!=0 );
  
// ABS Label 1359
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1359);
}
if( pParse->nErr ) { return 0;
}
  testcase( pExpr->op==TK_EXISTS );
  testcase( pExpr->op==TK_SELECT );
  assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );
  assert( ExprHasProperty(pExpr, EP_xIsSelect) );
  pSel = pExpr->x.pSelect;

  /* If this routine has already been coded, then invoke it as a
  ** subroutine. */
  
// MCC Label 1360
if(( ((pExpr)->flags & (33554432)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1360);
}
// MCC Label 1361
if(( !(((pExpr)->flags & (33554432)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1361);
}
if( ExprHasProperty(pExpr, EP_Subrtn) ){
    ExplainQueryPlan((pParse, 0, "REUSE SUBQUERY %d", pSel->selId));
    
// ABS Label 1364
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1364);
}

// ABS Label 1365
if(pExpr->y.sub.regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1365);
}

// ABS Label 1366
if(pExpr->y.sub.iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1366);
}
sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,
                      pExpr->y.sub.iAddr);
    
// ABS Label 1367
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1367);
}
return pExpr->iTable;
  }

  /* Begin coding the subroutine */
  ExprSetProperty(pExpr, EP_Subrtn);
  pExpr->y.sub.regReturn = ++pParse->nMem;
  pExpr->y.sub.iAddr =
    sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;
  VdbeComment((v, "return address"));


  /* The evaluation of the EXISTS/SELECT must be repeated every time it
  ** is encountered if any of the following is true:
  **
  **    *  The right-hand side is a correlated subquery
  **    *  The right-hand side is an expression list containing variables
  **    *  We are inside a trigger
  **
  ** If all of the above are false, then we can run this code just once
  ** save the results, and reuse the same result on subsequent invocations.
  */
  if( !ExprHasProperty(pExpr, EP_VarSelect) ){
    addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
  }
  
  /* For a SELECT, generate code to put the values for all columns of
  ** the first row into an array of registers and return the index of
  ** the first register.
  **
  ** If this is an EXISTS, write an integer 0 (not exists) or 1 (exists)
  ** into a register and return that register number.
  **
  ** In both cases, the query is augmented with "LIMIT 1".  Any 
  ** preexisting limit is discarded in place of the new LIMIT 1.
  */
  ExplainQueryPlan((pParse, 1, "%sSCALAR SUBQUERY %d",
        addrOnce?"":"CORRELATED ", pSel->selId));
  nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;
  
// ABS Label 1347
if(pParse->nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1347);
}

// AOR Label 1348
if(pParse->nMem - 1 != pParse->nMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1348);
}
// AOR Label 1349
if(pParse->nMem / 1 != pParse->nMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1349);
}
// AOR Label 1350
if(pParse->nMem * 1 != pParse->nMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1350);
}
sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);
  pParse->nMem += nReg;
  
// ROR Label 1368
if((pExpr->op != 137) != (pExpr->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1368);
}
if( pExpr->op==TK_SELECT ){
    dest.eDest = SRT_Mem;
    dest.iSdst = dest.iSDParm;
    dest.nSdst = nReg;
    
// ABS Label 1369
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1369);
}

// ABS Label 1370
if(dest.iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1370);
}

// ABS Label 1371
if(dest.iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1371);
}
// ABS Label 1372
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1372);
}

// AOR Label 1373
if(dest.iSDParm + nReg / 1 != dest.iSDParm + nReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1373);
}
// AOR Label 1374
if(dest.iSDParm + nReg + 1 != dest.iSDParm + nReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1374);
}
// AOR Label 1375
if(dest.iSDParm + nReg * 1 != dest.iSDParm + nReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1375);
}
// AOR Label 1376
if(dest.iSDParm - nReg != dest.iSDParm + nReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1376);
}
// AOR Label 1377
if(dest.iSDParm / nReg != dest.iSDParm + nReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1377);
}
// AOR Label 1378
if(dest.iSDParm * nReg != dest.iSDParm + nReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1378);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);
    VdbeComment((v, "Init subquery result"));
  }else{
    dest.eDest = SRT_Exists;
    
// ABS Label 1379
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1379);
}

// ABS Label 1380
if(dest.iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1380);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);
    VdbeComment((v, "Init EXISTS result"));
  }
  
// ABS Label 1381
if(pSel->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1381);
}
if( pSel->pLimit ){
    /* The subquery already has a limit.  If the pre-existing limit is X
    ** then make the new limit X<>0 so that the new limit is either 1 or 0 */
    
// ABS Label 1382
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1382);
}
sqlite3 *db = pParse->db;
    pLimit = sqlite3Expr(db, TK_INTEGER, "0");
    
// ABS Label 1385
if(pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1385);
}
if( pLimit ){
      pLimit->affExpr = SQLITE_AFF_NUMERIC;
      pLimit = sqlite3PExpr(pParse, TK_NE,
                            sqlite3ExprDup(db, pSel->pLimit->pLeft, 0), pLimit);
    }
    
// ABS Label 1383
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1383);
}

// ABS Label 1384
if(pSel->pLimit->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1384);
}
sqlite3ExprDelete(db, pSel->pLimit->pLeft);
    pSel->pLimit->pLeft = pLimit;
  }else{
    /* If there is no pre-existing limit add a limit of 1 */
    pLimit = sqlite3Expr(pParse->db, TK_INTEGER, "1");
    pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);
  }
  pSel->iLimit = 0;
  if( sqlite3Select(pParse, pSel, &dest) ){
    
// ABS Label 1386
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1386);
}
if( pParse->nErr ){
      pExpr->op2 = pExpr->op;
      pExpr->op = TK_ERROR;
    }
    return 0;
  }
  pExpr->iTable = rReg = dest.iSDParm;
  ExprSetVVAProperty(pExpr, EP_NoReduce);
  
// ABS Label 1387
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1387);
}
if( addrOnce ){
    
// ABS Label 1388
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1388);
}

// ABS Label 1389
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1389);
}
sqlite3VdbeJumpHere(v, addrOnce);
  }

  /* Subroutine return */
  
// ABS Label 1351
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1351);
}

// ABS Label 1352
if(pExpr->y.sub.regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}
sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);
  
// ABS Label 1353
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1353);
}

// ABS Label 1354
if(pExpr->y.sub.iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1354);
}

// AOR Label 1355
if(pExpr->y.sub.iAddr / 1 != pExpr->y.sub.iAddr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1355);
}
// AOR Label 1356
if(pExpr->y.sub.iAddr + 1 != pExpr->y.sub.iAddr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1356);
}
// AOR Label 1357
if(pExpr->y.sub.iAddr * 1 != pExpr->y.sub.iAddr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1357);
}
sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);
  
// ABS Label 1358
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1358);
}
sqlite3ClearTempRegCache(pParse);
  
// ABS Label 1390
if(rReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1390);
}
return rReg;
}
#endif /* SQLITE_OMIT_SUBQUERY */

#ifndef SQLITE_OMIT_SUBQUERY
/*
** Expr pIn is an IN(...) expression. This function checks that the 
** sub-select on the RHS of the IN() operator has the same number of 
** columns as the vector on the LHS. Or, if the RHS of the IN() is not 
** a sub-query, that the LHS is a vector of size 1.
*/
int sqlite3ExprCheckIN(Parse *pParse, Expr *pIn){
  int nVector = sqlite3ExprVectorSize(pIn->pLeft);
  
// COR Label 1391
if(((pIn->flags & 2048) != 0 || !pParse->db->mallocFailed) != ((pIn->flags & 2048) != 0 && !pParse->db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1391);
}

// ROR Label 1392
if(((pIn->flags & 2048) == 0) != ((pIn->flags & 2048) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1392);
}

// MCC Label 1393
if((pIn->flags & 2048) != 0 && !pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1393);
}
// MCC Label 1394
if((pIn->flags & 2048) != 0 && !(!pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1394);
}
// MCC Label 1395
if(!((pIn->flags & 2048) != 0) && !pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1395);
}
// MCC Label 1396
if(!((pIn->flags & 2048) != 0) && !(!pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1396);
}
if( (pIn->flags & EP_xIsSelect)!=0 && !pParse->db->mallocFailed ){
    
// ABS Label 1397
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1397);
}
// ABS Label 1398
if(pIn->x.pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1398);
}

// ROR Label 1399
if((nVector == pIn->x.pSelect->pEList->nExpr) != (nVector != pIn->x.pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1399);
}
if( nVector!=pIn->x.pSelect->pEList->nExpr ){
      
// ABS Label 1400
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1400);
}

// ABS Label 1401
if(pIn->x.pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1401);
}

// ABS Label 1402
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1402);
}
sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);
      return 1;
    }
  }else { 
// ABS Label 1403
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1403);
}

// ROR Label 1404
if((nVector == 1) != (nVector != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1404);
}
if( nVector!=1 ){
    
// ABS Label 1405
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1405);
}

// ABS Label 1406
if(pIn->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1406);
}
sqlite3VectorErrorMsg(pParse, pIn->pLeft);
    return 1;
  };}

  return 0;
}
#endif

#ifndef SQLITE_OMIT_SUBQUERY
/*
** Generate code for an IN expression.
**
**      x IN (SELECT ...)
**      x IN (value, value, ...)
**
** The left-hand side (LHS) is a scalar or vector expression.  The 
** right-hand side (RHS) is an array of zero or more scalar values, or a
** subquery.  If the RHS is a subquery, the number of result columns must
** match the number of columns in the vector on the LHS.  If the RHS is
** a list of values, the LHS must be a scalar. 
**
** The IN operator is true if the LHS value is contained within the RHS.
** The result is false if the LHS is definitely not in the RHS.  The 
** result is NULL if the presence of the LHS in the RHS cannot be 
** determined due to NULLs.
**
** This routine generates code that jumps to destIfFalse if the LHS is not 
** contained within the RHS.  If due to NULLs we cannot determine if the LHS
** is contained in the RHS then jump to destIfNull.  If the LHS is contained
** within the RHS then fall through.
**
** See the separate in-operator.md documentation file in the canonical
** SQLite source tree for additional information.
*/
static void sqlite3ExprCodeIN(
  Parse *pParse,        /* Parsing and code generating context */
  Expr *pExpr,          /* The IN expression */
  int destIfFalse,      /* Jump here if LHS is not contained in the RHS */
  int destIfNull        /* Jump here if the results are unknown due to NULLs */
){
  int rRhsHasNull = 0;  /* Register that is true if RHS contains NULL values */
  int eType;            /* Type of the RHS */
  int rLhs;             /* Register(s) holding the LHS values */
  int rLhsOrig;         /* LHS values prior to reordering by aiMap[] */
  Vdbe *v;              /* Statement under construction */
  int *aiMap = 0;       /* Map from vector field to index column */
  char *zAff = 0;       /* Affinity string for comparisons */
  int nVector;          /* Size of vectors for this IN operator */
  int iDummy;           /* Dummy parameter to exprCodeVector() */
  Expr *pLeft;          /* The LHS of the IN operator */
  int i;                /* loop counter */
  int destStep2;        /* Where to jump when NULLs seen in step 2 */
  int destStep6 = 0;    /* Start of code for Step 6 */
  int addrTruthOp;      /* Address of opcode that determines the IN is true */
  int destNotNull;      /* Jump here if a comparison is not true in step 6 */
  int addrTop;          /* Top of the step-6 loop */ 
  int iTab = 0;         /* Index to use */
  
// ABS Label 1407
if(pParse->okConstFactor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1407);
}
u8 okConstFactor = pParse->okConstFactor;

  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );
  pLeft = pExpr->pLeft;
  if( sqlite3ExprCheckIN(pParse, pExpr) ) { return;
}
  zAff = exprINAffinity(pParse, pExpr);
  nVector = sqlite3ExprVectorSize(pExpr->pLeft);
  aiMap = (int*)sqlite3DbMallocZero(
      pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1
  );
  
// ABS Label 1413
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1413);
}
if( pParse->db->mallocFailed ) { goto sqlite3ExprCodeIN_oom_error;
}

  /* Attempt to compute the RHS. After this step, if anything other than
  ** IN_INDEX_NOOP is returned, the table opened with cursor iTab
  ** contains the values that make up the RHS. If IN_INDEX_NOOP is returned,
  ** the RHS has not yet been coded.  */
  v = pParse->pVdbe;
  assert( v!=0 );       /* OOM detected prior to this routine */
  VdbeNoopComment((v, "begin IN expr"));
  eType = sqlite3FindInIndex(pParse, pExpr,
                             IN_INDEX_MEMBERSHIP | IN_INDEX_NOOP_OK,
                             destIfFalse==destIfNull ? 0 : &rRhsHasNull,
                             aiMap, &iTab);

  assert( pParse->nErr || nVector==1 || eType==IN_INDEX_EPH
       || eType==IN_INDEX_INDEX_ASC || eType==IN_INDEX_INDEX_DESC 
  );
#ifdef SQLITE_DEBUG
  /* Confirm that aiMap[] contains nVector integer values between 0 and
  ** nVector-1. */
  for(i=0; i<nVector; i++){
    int j, cnt;
    for(cnt=j=0; j<nVector; j++) if( aiMap[j]==i ) cnt++;
    assert( cnt==1 );
  }
#endif

  /* Code the LHS, the <expr> from "<expr> IN (...)". If the LHS is a 
  ** vector, then it is stored in an array of nVector registers starting 
  ** at r1.
  **
  ** sqlite3FindInIndex() might have reordered the fields of the LHS vector
  ** so that the fields are in the same order as an existing index.   The
  ** aiMap[] array contains a mapping from the original LHS field order to
  ** the field order that matches the RHS index.
  **
  ** Avoid factoring the LHS of the IN(...) expression out of the loop,
  ** even if it is constant, as OP_Affinity may be used on the register
  ** by code generated below.  */
  assert( pParse->okConstFactor==okConstFactor );
  pParse->okConstFactor = 0;
  rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);
  pParse->okConstFactor = okConstFactor;
  i = 0;

// ABS Label 1414
if(aiMap[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1414);
}
// ABS Label 1415
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1415);
}
// ABS Label 1416
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1416);
}

// COR Label 1417
if((i < nVector || aiMap[i] == i) != (i < nVector && aiMap[i] == i))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1417);
}

// ROR Label 1418
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1418);
}
// ROR Label 1419
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1419);
}
// ROR Label 1420
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1420);
}
// ROR Label 1421
if((aiMap[i] != i) != (aiMap[i] == i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1421);
}

// MCC Label 1422
if(i < nVector && aiMap[i] == i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1422);
}
// MCC Label 1423
if(i < nVector && !(aiMap[i] == i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1423);
}
// MCC Label 1424
if(!(i < nVector) && aiMap[i] == i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1424);
}
// MCC Label 1425
if(!(i < nVector) && !(aiMap[i] == i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1425);
}
for(; i<nVector && aiMap[i]==i; i++){};
// ABS Label 1426
if(aiMap[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1426);
}
// ABS Label 1427
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1427);
}
// ABS Label 1428
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1428);
}

// COR Label 1429
if((i < nVector || aiMap[i] == i) != (i < nVector && aiMap[i] == i))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1429);
}

// ROR Label 1430
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1430);
}
// ROR Label 1431
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1431);
}
// ROR Label 1432
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1432);
}
// ROR Label 1433
if((aiMap[i] != i) != (aiMap[i] == i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1433);
}

// MCC Label 1434
if(i < nVector && aiMap[i] == i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1434);
}
// MCC Label 1435
if(i < nVector && !(aiMap[i] == i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1435);
}
// MCC Label 1436
if(!(i < nVector) && aiMap[i] == i ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1436);
}
// MCC Label 1437
if(!(i < nVector) && !(aiMap[i] == i) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1437);
}
 /* Are LHS fields reordered? */
  
// ABS Label 1438
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1438);
}
// ABS Label 1439
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1439);
}

// ROR Label 1440
if((i != nVector) != (i == nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1440);
}
if( i==nVector ){
    /* LHS fields are not reordered */
    rLhs = rLhsOrig;
  }else{
    /* Need to reorder the LHS fields according to aiMap */
    rLhs = sqlite3GetTempRange(pParse, nVector);
    i = 0;

// ABS Label 1441
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1441);
}
// ABS Label 1442
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1442);
}

// ROR Label 1443
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1443);
}
// ROR Label 1444
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1444);
}
// ROR Label 1445
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1445);
}
for(; i<nVector; i++){
      
// ABS Label 1451
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1451);
}

// ABS Label 1452
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1452);
}
// ABS Label 1453
if(rLhsOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1453);
}

// AOR Label 1454
if(rLhsOrig - i != rLhsOrig + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1454);
}
// AOR Label 1455
if(rLhsOrig / i != rLhsOrig + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1455);
}
// AOR Label 1456
if(rLhsOrig * i != rLhsOrig + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1456);
}

// ABS Label 1457
if(aiMap[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1457);
}
// ABS Label 1458
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1458);
}
// ABS Label 1459
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1459);
}

// AOR Label 1460
if(rLhs - aiMap[i] != rLhs + aiMap[i])  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1460);
}
// AOR Label 1461
if(rLhs / aiMap[i] != rLhs + aiMap[i])  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1461);
}
// AOR Label 1462
if(rLhs * aiMap[i] != rLhs + aiMap[i])  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1462);
}
sqlite3VdbeAddOp3(v, OP_Copy, rLhsOrig+i, rLhs+aiMap[i], 0);
    };
// ABS Label 1446
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1446);
}
// ABS Label 1447
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1447);
}

// ROR Label 1448
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1448);
}
// ROR Label 1449
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1449);
}
// ROR Label 1450
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1450);
}

  }

  /* If sqlite3FindInIndex() did not find or create an index that is
  ** suitable for evaluating the IN operator, then evaluate using a
  ** sequence of comparisons.
  **
  ** This is step (1) in the in-operator.md optimized algorithm.
  */
  
// ABS Label 1463
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1463);
}

// ROR Label 1464
if((eType != 5) != (eType == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1464);
}
if( eType==IN_INDEX_NOOP ){
    
// ABS Label 1465
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1465);
}
ExprList *pList = pExpr->x.pList;
    CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    int labelOk = sqlite3VdbeMakeLabel(pParse);
    int r2, regToFree;
    int regCkNull = 0;
    int ii;
    assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
    
// ABS Label 1470
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1470);
}
// ABS Label 1471
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1471);
}

// ROR Label 1472
if((destIfNull == destIfFalse) != (destIfNull != destIfFalse))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1472);
}
if( destIfNull!=destIfFalse ){
      regCkNull = sqlite3GetTempReg(pParse);
      
// ABS Label 1473
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1473);
}

// ABS Label 1474
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1474);
}

// ABS Label 1475
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1475);
}

// ABS Label 1476
if(regCkNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1476);
}
sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);
    }
    ii = 0;

// ABS Label 1477
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1477);
}
// ABS Label 1478
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1478);
}

// ROR Label 1479
if((ii <= pList->nExpr) != (ii < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1479);
}
// ROR Label 1480
if((ii > pList->nExpr) != (ii < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1480);
}
// ROR Label 1481
if((ii >= pList->nExpr) != (ii < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1481);
}
for(; ii<pList->nExpr; ii++){
      r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);
      if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){
        
// ABS Label 1489
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1489);
}

// ABS Label 1490
if(regCkNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1490);
}

// ABS Label 1491
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1491);
}

// ABS Label 1492
if(regCkNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1492);
}
sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);
      }
      
// ABS Label 1487
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1487);
}

// ABS Label 1488
if(regToFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1488);
}
sqlite3ReleaseTempReg(pParse, regToFree);
      
// ABS Label 1493
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1493);
}
// ABS Label 1494
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1494);
}
// ABS Label 1495
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1495);
}
// ABS Label 1496
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1496);
}

// AOR Label 1497
if(pList->nExpr / 1 != pList->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1497);
}
// AOR Label 1498
if(pList->nExpr + 1 != pList->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1498);
}
// AOR Label 1499
if(pList->nExpr * 1 != pList->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1499);
}

// COR Label 1500
if((ii < pList->nExpr - 1 && destIfNull != destIfFalse) != (ii < pList->nExpr - 1 || destIfNull != destIfFalse))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1500);
}

// ROR Label 1501
if((ii <= pList->nExpr - 1) != (ii < pList->nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1501);
}
// ROR Label 1502
if((ii > pList->nExpr - 1) != (ii < pList->nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1502);
}
// ROR Label 1503
if((ii >= pList->nExpr - 1) != (ii < pList->nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1503);
}
// ROR Label 1504
if((destIfNull == destIfFalse) != (destIfNull != destIfFalse))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1504);
}

// MCC Label 1505
if(ii < pList->nExpr - 1 && destIfNull != destIfFalse ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1505);
}
// MCC Label 1506
if(ii < pList->nExpr - 1 && !(destIfNull != destIfFalse) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1506);
}
// MCC Label 1507
if(!(ii < pList->nExpr - 1) && destIfNull != destIfFalse ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1507);
}
// MCC Label 1508
if(!(ii < pList->nExpr - 1) && !(destIfNull != destIfFalse) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1508);
}
if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){
        int op = rLhs!=r2 ? OP_Eq : OP_NotNull;
        
// ABS Label 1509
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1509);
}

// ABS Label 1510
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1510);
}

// ABS Label 1511
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1511);
}

// ABS Label 1512
if(labelOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1512);
}

// ABS Label 1513
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1513);
}
sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2,
                          (void*)pColl, P4_COLLSEQ);
        VdbeCoverageIf(v, ii<pList->nExpr-1 && op==OP_Eq);
        VdbeCoverageIf(v, ii==pList->nExpr-1 && op==OP_Eq);
        VdbeCoverageIf(v, ii<pList->nExpr-1 && op==OP_NotNull);
        VdbeCoverageIf(v, ii==pList->nExpr-1 && op==OP_NotNull);
        
// ABS Label 1514
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1514);
}
sqlite3VdbeChangeP5(v, zAff[0]);
      }else{
        int op = rLhs!=r2 ? OP_Ne : OP_IsNull;
        assert( destIfNull==destIfFalse );
        
// ABS Label 1515
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1515);
}

// ABS Label 1516
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1516);
}

// ABS Label 1517
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1517);
}

// ABS Label 1518
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1518);
}

// ABS Label 1519
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1519);
}
sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2,
                          (void*)pColl, P4_COLLSEQ);
        VdbeCoverageIf(v, op==OP_Ne);
        VdbeCoverageIf(v, op==OP_IsNull);
        
// ABS Label 1520
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1520);
}
sqlite3VdbeChangeP5(v, zAff[0] | SQLITE_JUMPIFNULL);
      }
    };
// ABS Label 1482
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1482);
}
// ABS Label 1483
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1483);
}

// ROR Label 1484
if((ii <= pList->nExpr) != (ii < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1484);
}
// ROR Label 1485
if((ii > pList->nExpr) != (ii < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1485);
}
// ROR Label 1486
if((ii >= pList->nExpr) != (ii < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1486);
}

    
// ABS Label 1521
if(regCkNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1521);
}
if( regCkNull ){
      
// ABS Label 1522
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1522);
}

// ABS Label 1523
if(regCkNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1523);
}

// ABS Label 1524
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1524);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);
      
// ABS Label 1525
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1525);
}

// ABS Label 1526
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1526);
}
sqlite3VdbeGoto(v, destIfFalse);
    }
    
// ABS Label 1466
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1466);
}

// ABS Label 1467
if(labelOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1467);
}
sqlite3VdbeResolveLabel(v, labelOk);
    
// ABS Label 1468
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1468);
}

// ABS Label 1469
if(regCkNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1469);
}
sqlite3ReleaseTempReg(pParse, regCkNull);
    goto sqlite3ExprCodeIN_finished;
  }

  /* Step 2: Check to see if the LHS contains any NULL columns.  If the
  ** LHS does contain NULLs then the result must be either FALSE or NULL.
  ** We will then skip the binary search of the RHS.
  */
  
// ABS Label 1527
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1527);
}
// ABS Label 1528
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1528);
}

// ROR Label 1529
if((destIfNull != destIfFalse) != (destIfNull == destIfFalse))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1529);
}
if( destIfNull==destIfFalse ){
    destStep2 = destIfFalse;
  }else{
    destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);
  }
  
// ABS Label 1530
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1530);
}
if( pParse->nErr ) { goto sqlite3ExprCodeIN_finished;
}
  i = 0;

// ABS Label 1531
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1531);
}
// ABS Label 1532
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1532);
}

// ROR Label 1533
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1533);
}
// ROR Label 1534
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1534);
}
// ROR Label 1535
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1535);
}
for(; i<nVector; i++){
    Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);
    
// ABS Label 1541
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1541);
}
if( pParse->db->mallocFailed ) { goto sqlite3ExprCodeIN_oom_error;
}
    if( sqlite3ExprCanBeNull(p) ){
      
// ABS Label 1542
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1542);
}

// ABS Label 1543
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1543);
}
// ABS Label 1544
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1544);
}

// AOR Label 1545
if(rLhs - i != rLhs + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1545);
}
// AOR Label 1546
if(rLhs / i != rLhs + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1546);
}
// AOR Label 1547
if(rLhs * i != rLhs + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1547);
}

// ABS Label 1548
if(destStep2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1548);
}
sqlite3VdbeAddOp2(v, OP_IsNull, rLhs+i, destStep2);
      VdbeCoverage(v);
    }
  };
// ABS Label 1536
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1536);
}
// ABS Label 1537
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1537);
}

// ROR Label 1538
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1538);
}
// ROR Label 1539
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1539);
}
// ROR Label 1540
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1540);
}


  /* Step 3.  The LHS is now known to be non-NULL.  Do the binary search
  ** of the RHS using the LHS as a probe.  If found, the result is
  ** true.
  */
  
// ABS Label 1549
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1549);
}

// ROR Label 1550
if((eType != 1) != (eType == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1550);
}
if( eType==IN_INDEX_ROWID ){
    /* In this case, the RHS is the ROWID of table b-tree and so we also
    ** know that the RHS is non-NULL.  Hence, we combine steps 3 and 4
    ** into a single opcode. */
    
// ABS Label 1551
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1551);
}

// ABS Label 1552
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1552);
}

// ABS Label 1553
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1553);
}

// ABS Label 1554
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1554);
}
sqlite3VdbeAddOp3(v, OP_SeekRowid, iTab, destIfFalse, rLhs);
    VdbeCoverage(v);
    addrTruthOp = sqlite3VdbeAddOp0(v, OP_Goto);  /* Return True */
  }else{
    
// ABS Label 1555
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1555);
}

// ABS Label 1556
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1556);
}

// ABS Label 1557
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1557);
}

// ABS Label 1558
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1558);
}
sqlite3VdbeAddOp4(v, OP_Affinity, rLhs, nVector, 0, zAff, nVector);
    
// ABS Label 1559
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1559);
}
// ABS Label 1560
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1560);
}

// ROR Label 1561
if((destIfFalse != destIfNull) != (destIfFalse == destIfNull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1561);
}
if( destIfFalse==destIfNull ){
      /* Combine Step 3 and Step 5 into a single opcode */
      
// ABS Label 1562
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1562);
}

// ABS Label 1563
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1563);
}

// ABS Label 1564
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1564);
}

// ABS Label 1565
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1565);
}

// ABS Label 1566
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1566);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound, iTab, destIfFalse,
                           rLhs, nVector); VdbeCoverage(v);
      goto sqlite3ExprCodeIN_finished;
    }
    /* Ordinary Step 3, for the case where FALSE and NULL are distinct */
    addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, iTab, 0,
                                      rLhs, nVector); VdbeCoverage(v);
  }

  /* Step 4.  If the RHS is known to be non-NULL and we did not find
  ** an match on the search above, then the result must be FALSE.
  */
  
// ABS Label 1567
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1567);
}
// ABS Label 1568
if(rRhsHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1568);
}

// COR Label 1569
if((rRhsHasNull || nVector == 1) != (rRhsHasNull && nVector == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1569);
}

// ROR Label 1570
if((nVector != 1) != (nVector == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1570);
}

// MCC Label 1571
if(rRhsHasNull && nVector == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1571);
}
// MCC Label 1572
if(rRhsHasNull && !(nVector == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1572);
}
// MCC Label 1573
if(!(rRhsHasNull) && nVector == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1573);
}
// MCC Label 1574
if(!(rRhsHasNull) && !(nVector == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1574);
}
if( rRhsHasNull && nVector==1 ){
    
// ABS Label 1575
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1575);
}

// ABS Label 1576
if(rRhsHasNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1576);
}

// ABS Label 1577
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1577);
}
sqlite3VdbeAddOp2(v, OP_NotNull, rRhsHasNull, destIfFalse);
    VdbeCoverage(v);
  }

  /* Step 5.  If we do not care about the difference between NULL and
  ** FALSE, then just return false. 
  */
  
// ABS Label 1578
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1578);
}
// ABS Label 1579
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1579);
}

// ROR Label 1580
if((destIfFalse != destIfNull) != (destIfFalse == destIfNull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1580);
}
if( destIfFalse==destIfNull ) { 
// ABS Label 1581
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1581);
}

// ABS Label 1582
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1582);
}
sqlite3VdbeGoto(v, destIfFalse);
}

  /* Step 6: Loop through rows of the RHS.  Compare each row to the LHS.
  ** If any comparison is NULL, then the result is NULL.  If all
  ** comparisons are FALSE then the final result is FALSE.
  **
  ** For a scalar LHS, it is sufficient to check just the first row
  ** of the RHS.
  */
  
// ABS Label 1583
if(destStep6 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1583);
}
if( destStep6 ) { 
// ABS Label 1584
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1584);
}

// ABS Label 1585
if(destStep6 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1585);
}
sqlite3VdbeResolveLabel(v, destStep6);
}
  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, destIfFalse);
  VdbeCoverage(v);
  
// ABS Label 1586
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1586);
}

// ROR Label 1587
if((nVector <= 1) != (nVector > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1587);
}
// ROR Label 1588
if((nVector < 1) != (nVector > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1588);
}
// ROR Label 1589
if((nVector >= 1) != (nVector > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1589);
}
if( nVector>1 ){
    destNotNull = sqlite3VdbeMakeLabel(pParse);
  }else{
    /* For nVector==1, combine steps 6 and 7 by immediately returning
    ** FALSE if the first comparison is not NULL */
    destNotNull = destIfFalse;
  }
  i = 0;

// ABS Label 1590
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1590);
}
// ABS Label 1591
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1591);
}

// ROR Label 1592
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1592);
}
// ROR Label 1593
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1593);
}
// ROR Label 1594
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1594);
}
for(; i<nVector; i++){
    Expr *p;
    CollSeq *pColl;
    int r3 = sqlite3GetTempReg(pParse);
    p = sqlite3VectorFieldSubexpr(pLeft, i);
    pColl = sqlite3ExprCollSeq(pParse, p);
    
// ABS Label 1600
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1600);
}

// ABS Label 1601
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1601);
}

// ABS Label 1602
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1602);
}

// ABS Label 1603
if(r3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1603);
}
sqlite3VdbeAddOp3(v, OP_Column, iTab, i, r3);
    
// ABS Label 1604
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1604);
}

// ABS Label 1605
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1605);
}
// ABS Label 1606
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1606);
}

// AOR Label 1607
if(rLhs - i != rLhs + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1607);
}
// AOR Label 1608
if(rLhs / i != rLhs + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1608);
}
// AOR Label 1609
if(rLhs * i != rLhs + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1609);
}

// ABS Label 1610
if(destNotNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1610);
}

// ABS Label 1611
if(r3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1611);
}
sqlite3VdbeAddOp4(v, OP_Ne, rLhs+i, destNotNull, r3,
                      (void*)pColl, P4_COLLSEQ);
    VdbeCoverage(v);
    
// ABS Label 1612
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1612);
}

// ABS Label 1613
if(r3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1613);
}
sqlite3ReleaseTempReg(pParse, r3);
  };
// ABS Label 1595
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1595);
}
// ABS Label 1596
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1596);
}

// ROR Label 1597
if((i <= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1597);
}
// ROR Label 1598
if((i > nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1598);
}
// ROR Label 1599
if((i >= nVector) != (i < nVector))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1599);
}

  
// ABS Label 1408
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1408);
}

// ABS Label 1409
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1409);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);
  
// ABS Label 1614
if(nVector < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1614);
}

// ROR Label 1615
if((nVector <= 1) != (nVector > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1615);
}
// ROR Label 1616
if((nVector < 1) != (nVector > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1616);
}
// ROR Label 1617
if((nVector >= 1) != (nVector > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1617);
}
if( nVector>1 ){
    
// ABS Label 1618
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1618);
}

// ABS Label 1619
if(destNotNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1619);
}
sqlite3VdbeResolveLabel(v, destNotNull);
    
// ABS Label 1620
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1620);
}

// ABS Label 1621
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1621);
}

// ABS Label 1622
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1622);
}

// AOR Label 1623
if(addrTop - 1 != addrTop + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1623);
}
// AOR Label 1624
if(addrTop / 1 != addrTop + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1624);
}
// AOR Label 1625
if(addrTop * 1 != addrTop + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1625);
}
sqlite3VdbeAddOp2(v, OP_Next, iTab, addrTop+1);
    VdbeCoverage(v);

    /* Step 7:  If we reach this point, we know that the result must
    ** be false. */
    
// ABS Label 1626
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1626);
}

// ABS Label 1627
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1627);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);
  }

  /* Jumps here in order to return true. */
  
// ABS Label 1410
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1410);
}

// ABS Label 1411
if(addrTruthOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1411);
}
sqlite3VdbeJumpHere(v, addrTruthOp);

sqlite3ExprCodeIN_finished:
  
// ABS Label 1628
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1628);
}
// ABS Label 1629
if(rLhsOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1629);
}

// ROR Label 1630
if((rLhs == rLhsOrig) != (rLhs != rLhsOrig))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1630);
}
if( rLhs!=rLhsOrig ) { 
// ABS Label 1631
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1631);
}

// ABS Label 1632
if(rLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1632);
}
sqlite3ReleaseTempReg(pParse, rLhs);
}
  VdbeComment((v, "end IN expr"));
sqlite3ExprCodeIN_oom_error:
  sqlite3DbFree(pParse->db, aiMap);
  
// ABS Label 1412
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1412);
}
sqlite3DbFree(pParse->db, zAff);
}
#endif /* SQLITE_OMIT_SUBQUERY */

#ifndef SQLITE_OMIT_FLOATING_POINT
/*
** Generate an instruction that will put the floating point
** value described by z[0..n-1] into register iMem.
**
** The z[] string will probably not be zero-terminated.  But the 
** z[n] character is guaranteed to be something that does not look
** like the continuation of the number.
*/
static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){
  
// MCC Label 1633
if(( z != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1633);
}
// MCC Label 1634
if(( !(z != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1634);
}
if( ALWAYS(z!=0) ){
    double value;
    
// ABS Label 1635
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1635);
}
sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);
    assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */
    
// ABS Label 1638
if(negateFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1638);
}
if( negateFlag ) { value = -value;
}
    
// ABS Label 1636
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1636);
}

// ABS Label 1637
if(iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1637);
}
sqlite3VdbeAddOp4Dup8(v, OP_Real, 0, iMem, 0, (u8*)&value, P4_REAL);
  }
}
#endif


/*
** Generate an instruction that will put the integer describe by
** text z[0..n-1] into register iMem.
**
** Expr.u.zToken is always UTF8 and zero-terminated.
*/
static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){
  
// ABS Label 1639
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1639);
}
Vdbe *v = pParse->pVdbe;
  
// ABS Label 1640
if(pExpr->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1640);
}

// AOR Label 1641
if(pExpr->flags | 1024 != pExpr->flags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1641);
}
// AOR Label 1642
if(pExpr->flags ^ 1024 != pExpr->flags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1642);
}
if( pExpr->flags & EP_IntValue ){
    
// ABS Label 1643
if(pExpr->u.iValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1643);
}
int i = pExpr->u.iValue;
    assert( i>=0 );
    
// ABS Label 1647
if(negFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1647);
}
if( negFlag ) { i = -i;
}
    
// ABS Label 1644
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1644);
}

// ABS Label 1645
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1645);
}

// ABS Label 1646
if(iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1646);
}
sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);
  }else{
    int c;
    i64 value;
    const char *z = pExpr->u.zToken;
    assert( z!=0 );
    c = sqlite3DecOrHexToI64(z, &value);
    
// COR Label 1648
if(((c == 3 && !negFlag) || (c == 2) && (negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))) != ((c == 3 && !negFlag) || (c == 2) || (negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1648);
}
// COR Label 1649
if(((c == 3 && !negFlag) && (c == 2)) != ((c == 3 && !negFlag) || (c == 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1649);
}

// MCC Label 1650
if(( c == 3 && !negFlag ) && ( c == 2 ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1650);
}
// MCC Label 1651
if(( c == 3 && !negFlag ) && ( c == 2 ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1651);
}
// MCC Label 1652
if(( c == 3 && !negFlag ) && ( c == 2 ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1652);
}
// MCC Label 1653
if(( c == 3 && !negFlag ) && ( c == 2 ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1653);
}
// MCC Label 1654
if(( c == 3 && !negFlag ) && ( !(c == 2) ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1654);
}
// MCC Label 1655
if(( c == 3 && !negFlag ) && ( !(c == 2) ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1655);
}
// MCC Label 1656
if(( c == 3 && !negFlag ) && ( !(c == 2) ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1656);
}
// MCC Label 1657
if(( c == 3 && !negFlag ) && ( !(c == 2) ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1657);
}
// MCC Label 1658
if(( c == 3 && !(!negFlag) ) && ( c == 2 ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1658);
}
// MCC Label 1659
if(( c == 3 && !(!negFlag) ) && ( c == 2 ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1659);
}
// MCC Label 1660
if(( c == 3 && !(!negFlag) ) && ( c == 2 ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1660);
}
// MCC Label 1661
if(( c == 3 && !(!negFlag) ) && ( c == 2 ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1661);
}
// MCC Label 1662
if(( c == 3 && !(!negFlag) ) && ( !(c == 2) ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1662);
}
// MCC Label 1663
if(( c == 3 && !(!negFlag) ) && ( !(c == 2) ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1663);
}
// MCC Label 1664
if(( c == 3 && !(!negFlag) ) && ( !(c == 2) ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1664);
}
// MCC Label 1665
if(( c == 3 && !(!negFlag) ) && ( !(c == 2) ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1665);
}
// MCC Label 1666
if(( !(c == 3) && !negFlag ) && ( c == 2 ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1666);
}
// MCC Label 1667
if(( !(c == 3) && !negFlag ) && ( c == 2 ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1667);
}
// MCC Label 1668
if(( !(c == 3) && !negFlag ) && ( c == 2 ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1668);
}
// MCC Label 1669
if(( !(c == 3) && !negFlag ) && ( c == 2 ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1669);
}
// MCC Label 1670
if(( !(c == 3) && !negFlag ) && ( !(c == 2) ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1670);
}
// MCC Label 1671
if(( !(c == 3) && !negFlag ) && ( !(c == 2) ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1671);
}
// MCC Label 1672
if(( !(c == 3) && !negFlag ) && ( !(c == 2) ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1672);
}
// MCC Label 1673
if(( !(c == 3) && !negFlag ) && ( !(c == 2) ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1673);
}
// MCC Label 1674
if(( !(c == 3) && !(!negFlag) ) && ( c == 2 ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1674);
}
// MCC Label 1675
if(( !(c == 3) && !(!negFlag) ) && ( c == 2 ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1675);
}
// MCC Label 1676
if(( !(c == 3) && !(!negFlag) ) && ( c == 2 ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1676);
}
// MCC Label 1677
if(( !(c == 3) && !(!negFlag) ) && ( c == 2 ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1677);
}
// MCC Label 1678
if(( !(c == 3) && !(!negFlag) ) && ( !(c == 2) ) && ( negFlag && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1678);
}
// MCC Label 1679
if(( !(c == 3) && !(!negFlag) ) && ( !(c == 2) ) && ( negFlag && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1679);
}
// MCC Label 1680
if(( !(c == 3) && !(!negFlag) ) && ( !(c == 2) ) && ( !(negFlag) && value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1680);
}
// MCC Label 1681
if(( !(c == 3) && !(!negFlag) ) && ( !(c == 2) ) && ( !(negFlag) && !(value == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1681);
}
if( (c==3 && !negFlag) || (c==2) || (negFlag && value==SMALLEST_INT64)){
#ifdef SQLITE_OMIT_FLOATING_POINT
      sqlite3ErrorMsg(pParse, "oversized integer: %s%s", negFlag ? "-" : "", z);
#else
#ifndef SQLITE_OMIT_HEX_INTEGER
      if( sqlite3_strnicmp(z,"0x",2)==0 ){
        
// ABS Label 1682
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1682);
}

// ABS Label 1683
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1683);
}
sqlite3ErrorMsg(pParse, "hex literal too big: %s%s", negFlag?"-":"",z);
      }else
#endif
      {
        
// ABS Label 1684
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1684);
}

// ABS Label 1685
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1685);
}

// ABS Label 1686
if(negFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1686);
}

// ABS Label 1687
if(iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1687);
}
codeReal(v, z, negFlag, iMem);
      }
#endif
    }else{
      
// ABS Label 1690
if(negFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1690);
}
if( negFlag ){ value = c==3 ? SMALLEST_INT64 : -value; }
      
// ABS Label 1688
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1688);
}

// ABS Label 1689
if(iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1689);
}
sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, iMem, 0, (u8*)&value, P4_INT64);
    }
  }
}


/* Generate code that will load into register regOut a value that is
** appropriate for the iIdxCol-th column of index pIdx.
*/
void sqlite3ExprCodeLoadIndexColumn(
  Parse *pParse,  /* The parsing context */
  Index *pIdx,    /* The index whose column is to be loaded */
  int iTabCur,    /* Cursor pointing to a table row */
  int iIdxCol,    /* The column of the index to be loaded */
  int regOut      /* Store the index column value in this register */
){
  
// ABS Label 1691
if(iIdxCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1691);
}
// ABS Label 1692
if(pIdx->aiColumn[iIdxCol] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1692);
}
i16 iTabCol = pIdx->aiColumn[iIdxCol];
  
// ROR Label 1693
if((iTabCol != (-2)) != (iTabCol == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1693);
}
if( iTabCol==XN_EXPR ){
    assert( pIdx->aColExpr );
    assert( pIdx->aColExpr->nExpr>iIdxCol );
    pParse->iSelfTab = iTabCur + 1;
    
// ABS Label 1694
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1694);
}

// ABS Label 1695
if(pIdx->aColExpr->a[iIdxCol].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1695);
}

// ABS Label 1696
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1696);
}
sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
    pParse->iSelfTab = 0;
  }else{
    
// ABS Label 1697
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1697);
}

// ABS Label 1698
if(pIdx->pTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1698);
}

// ABS Label 1699
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1699);
}

// ABS Label 1700
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1700);
}
sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,
                                    iTabCol, regOut);
  }
}

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
/*
** Generate code that will compute the value of generated column pCol
** and store the result in register regOut
*/
void sqlite3ExprCodeGeneratedColumn(
  Parse *pParse,
  Column *pCol,
  int regOut
){
  int iAddr;
  
// ABS Label 1701
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1701);
}
Vdbe *v = pParse->pVdbe;
  assert( v!=0 );
  assert( pParse->iSelfTab!=0 );
  
// ABS Label 1705
if(pParse->iSelfTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1705);
}

// ROR Label 1706
if((pParse->iSelfTab <= 0) != (pParse->iSelfTab > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1706);
}
// ROR Label 1707
if((pParse->iSelfTab < 0) != (pParse->iSelfTab > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1707);
}
// ROR Label 1708
if((pParse->iSelfTab >= 0) != (pParse->iSelfTab > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1708);
}
if( pParse->iSelfTab>0 ){
    iAddr = sqlite3VdbeAddOp3(v, OP_IfNullRow, pParse->iSelfTab-1, 0, regOut);
  }else{
    iAddr = 0;
  }
  
// ABS Label 1702
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1702);
}

// ABS Label 1703
if(pCol->pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1703);
}

// ABS Label 1704
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1704);
}
sqlite3ExprCodeCopy(pParse, pCol->pDflt, regOut);
  
// ROR Label 1709
if((pCol->affinity < 66) != (pCol->affinity >= 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1709);
}
// ROR Label 1710
if((pCol->affinity > 66) != (pCol->affinity >= 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1710);
}
// ROR Label 1711
if((pCol->affinity <= 66) != (pCol->affinity >= 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1711);
}
if( pCol->affinity>=SQLITE_AFF_TEXT ){
    
// ABS Label 1712
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1712);
}

// ABS Label 1713
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1713);
}
sqlite3VdbeAddOp4(v, OP_Affinity, regOut, 1, 0, &pCol->affinity, 1);
  }
  
// ABS Label 1714
if(iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1714);
}
if( iAddr ) { 
// ABS Label 1715
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1715);
}

// ABS Label 1716
if(iAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1716);
}
sqlite3VdbeJumpHere(v, iAddr);
}
}
#endif /* SQLITE_OMIT_GENERATED_COLUMNS */

/*
** Generate code to extract the value of the iCol-th column of a table.
*/
void sqlite3ExprCodeGetColumnOfTable(
  Vdbe *v,        /* Parsing context */
  Table *pTab,    /* The table containing the value */
  int iTabCur,    /* The table cursor.  Or the PK cursor for WITHOUT ROWID */
  int iCol,       /* Index of the column to extract */
  int regOut      /* Extract the value into this register */
){
  Column *pCol;
  assert( v!=0 );
  
// ABS Label 1717
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1717);
}

// ROR Label 1718
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1718);
}
if( pTab==0 ){
    
// ABS Label 1719
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1719);
}

// ABS Label 1720
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1720);
}

// ABS Label 1721
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1721);
}

// ABS Label 1722
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1722);
}
sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);
    return;
  }
  
// ABS Label 1723
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1723);
}

// COR Label 1724
if((iCol < 0 && iCol == pTab->iPKey) != (iCol < 0 || iCol == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1724);
}

// ROR Label 1725
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1725);
}
// ROR Label 1726
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1726);
}
// ROR Label 1727
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1727);
}
// ROR Label 1728
if((iCol != pTab->iPKey) != (iCol == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1728);
}

// MCC Label 1729
if(iCol < 0 && iCol == pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1729);
}
// MCC Label 1730
if(iCol < 0 && !(iCol == pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1730);
}
// MCC Label 1731
if(!(iCol < 0) && iCol == pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1731);
}
// MCC Label 1732
if(!(iCol < 0) && !(iCol == pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1732);
}
if( iCol<0 || iCol==pTab->iPKey ){
    
// ABS Label 1733
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1733);
}

// ABS Label 1734
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1734);
}

// ABS Label 1735
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1735);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);
  }else{
    int op;
    int x;
    
// ABS Label 1745
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1745);
}
if( IsVirtual(pTab) ){
      op = OP_VColumn;
      x = iCol;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
    }else { if( (pCol = &pTab->aCol[iCol])->colFlags & COLFLAG_VIRTUAL ){
      Parse *pParse = sqlite3VdbeParser(v);
      
// AOR Label 1746
if(pCol->colFlags | 256 != pCol->colFlags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1746);
}
// AOR Label 1747
if(pCol->colFlags ^ 256 != pCol->colFlags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1747);
}
if( pCol->colFlags & COLFLAG_BUSY ){
        
// ABS Label 1748
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1748);
}

// ABS Label 1749
if(pCol->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1749);
}
sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pCol->zName);
      }else{
        
// ABS Label 1750
if(pParse->iSelfTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1750);
}
int savedSelfTab = pParse->iSelfTab;
        pCol->colFlags |= COLFLAG_BUSY;
        pParse->iSelfTab = iTabCur+1;
        
// ABS Label 1751
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1751);
}

// ABS Label 1752
if(pCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1752);
}

// ABS Label 1753
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1753);
}
sqlite3ExprCodeGeneratedColumn(pParse, pCol, regOut);
        pParse->iSelfTab = savedSelfTab;
        pCol->colFlags &= ~COLFLAG_BUSY;
      }
      return;
#endif
    }else { if( !HasRowid(pTab) ){
      testcase( iCol!=sqlite3TableColumnToStorage(pTab, iCol) );
      x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);
      op = OP_Column;
    }else{
      x = sqlite3TableColumnToStorage(pTab,iCol);
      testcase( x!=iCol );
      op = OP_Column;
    };}
;}

    
// ABS Label 1736
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1736);
}

// ABS Label 1737
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1737);
}

// ABS Label 1738
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1738);
}

// ABS Label 1739
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1739);
}

// ABS Label 1740
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1740);
}
sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);
    
// ABS Label 1741
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1741);
}

// ABS Label 1742
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1742);
}

// ABS Label 1743
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1743);
}

// ABS Label 1744
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1744);
}
sqlite3ColumnDefault(v, pTab, iCol, regOut);
  }
}

/*
** Generate code that will extract the iColumn-th column from
** table pTab and store the column value in register iReg. 
**
** There must be an open cursor to pTab in iTable when this routine
** is called.  If iColumn<0 then code is generated that extracts the rowid.
*/
int sqlite3ExprCodeGetColumn(
  Parse *pParse,   /* Parsing and code generating context */
  Table *pTab,     /* Description of the table we are reading from */
  int iColumn,     /* Index of the table column */
  int iTable,      /* The cursor pointing to the table */
  int iReg,        /* Store results here */
  u8 p5            /* P5 value for OP_Column + FLAGS */
){
  assert( pParse->pVdbe!=0 );
  
// ABS Label 1754
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1754);
}

// ABS Label 1755
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1755);
}

// ABS Label 1756
if(iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1756);
}

// ABS Label 1757
if(iColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1757);
}

// ABS Label 1758
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1758);
}
sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pTab, iTable, iColumn, iReg);
  
// ABS Label 1759
if(p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1759);
}
if( p5 ){
    VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);
    
// ROR Label 1760
if((pOp->opcode != 91) != (pOp->opcode == 91))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1760);
}
if( pOp->opcode==OP_Column ) { pOp->p5 = p5;
}
  }
  
// ABS Label 1761
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1761);
}
return iReg;
}

/*
** Generate code to move content from registers iFrom...iFrom+nReg-1
** over to iTo..iTo+nReg-1.
*/
void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){
  
// ABS Label 1762
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1762);
}

// ABS Label 1763
if(iFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1763);
}

// ABS Label 1764
if(iTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1764);
}

// ABS Label 1765
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1765);
}
sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);
}

/*
** Convert a scalar expression node to a TK_REGISTER referencing
** register iReg.  The caller must ensure that iReg already contains
** the correct value for the expression.
*/
static void exprToRegister(Expr *pExpr, int iReg){
  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);
  
// MCC Label 1766
if(( p == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1766);
}
// MCC Label 1767
if(( !(p == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1767);
}
if( NEVER(p==0) ) { return;
}
  p->op2 = p->op;
  p->op = TK_REGISTER;
  p->iTable = iReg;
  ExprClearProperty(p, EP_Skip);
}

/*
** Evaluate an expression (either a vector or a scalar expression) and store
** the result in continguous temporary registers.  Return the index of
** the first register used to store the result.
**
** If the returned result register is a temporary scalar, then also write
** that register number into *piFreeable.  If the returned result register
** is not a temporary or if the expression is a vector set *piFreeable
** to 0.
*/
static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){
  int iResult;
  int nResult = sqlite3ExprVectorSize(p);
  
// ABS Label 1768
if(nResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1768);
}

// ROR Label 1769
if((nResult != 1) != (nResult == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1769);
}
if( nResult==1 ){
    iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);
  }else{
    *piFreeable = 0;
    
// ROR Label 1770
if((p->op != 137) != (p->op == 137))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1770);
}
if( p->op==TK_SELECT ){
#if SQLITE_OMIT_SUBQUERY
      iResult = 0;
#else
      iResult = sqlite3CodeSubselect(pParse, p);
#endif
    }else{
      int i;
      iResult = pParse->nMem+1;
      pParse->nMem += nResult;
      i = 0;

// ABS Label 1771
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1771);
}
// ABS Label 1772
if(nResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1772);
}

// ROR Label 1773
if((i <= nResult) != (i < nResult))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1773);
}
// ROR Label 1774
if((i > nResult) != (i < nResult))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1774);
}
// ROR Label 1775
if((i >= nResult) != (i < nResult))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1775);
}
for(; i<nResult; i++){
        
// ABS Label 1781
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1781);
}

// ABS Label 1782
if(p->x.pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1782);
}

// ABS Label 1783
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1783);
}
// ABS Label 1784
if(iResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1784);
}

// AOR Label 1785
if(i - iResult != i + iResult)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1785);
}
// AOR Label 1786
if(i / iResult != i + iResult)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1786);
}
// AOR Label 1787
if(i * iResult != i + iResult)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1787);
}
sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);
      };
// ABS Label 1776
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1776);
}
// ABS Label 1777
if(nResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1777);
}

// ROR Label 1778
if((i <= nResult) != (i < nResult))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1778);
}
// ROR Label 1779
if((i > nResult) != (i < nResult))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1779);
}
// ROR Label 1780
if((i >= nResult) != (i < nResult))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1780);
}

    }
  }
  
// ABS Label 1788
if(iResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1788);
}
return iResult;
}

/*
** If the last opcode is a OP_Copy, then set the do-not-merge flag (p5)
** so that a subsequent copy will not be merged into this one.
*/
static void setDoNotMergeFlagOnCopy(Vdbe *v){
  if( sqlite3VdbeGetOp(v, -1)->opcode==OP_Copy ){
    
// ABS Label 1789
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1789);
}
sqlite3VdbeChangeP5(v, 1);  /* Tag trailing OP_Copy as not mergable */
  }
}

/*
** Generate code to implement special SQL functions that are implemented
** in-line rather than by using the usual callbacks.
*/
static int exprCodeInlineFunction(
  Parse *pParse,        /* Parsing context */
  ExprList *pFarg,      /* List of function arguments */
  int iFuncId,          /* Function ID.  One of the INTFUNC_... values */
  int target            /* Store function result in this register */
){
  int nFarg;
  
// ABS Label 1790
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1790);
}
Vdbe *v = pParse->pVdbe;
  assert( v!=0 );
  assert( pFarg!=0 );
  nFarg = pFarg->nExpr;
  assert( nFarg>0 );  /* All in-line functions have at least one argument */
  switch( iFuncId ){
    case INLINEFUNC_coalesce: {
      /* Attempt a direct implementation of the built-in COALESCE() and
      ** IFNULL() functions.  This avoids unnecessary evaluation of
      ** arguments past the first non-NULL argument.
      */
      int endCoalesce = sqlite3VdbeMakeLabel(pParse);
      int i;
      assert( nFarg>=2 );
      
// ABS Label 1791
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1791);
}

// ABS Label 1792
if(pFarg->a[0].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1792);
}

// ABS Label 1793
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1793);
}
sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
      i = 1;

// ABS Label 1797
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1797);
}
// ABS Label 1798
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1798);
}

// ROR Label 1799
if((i <= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1799);
}
// ROR Label 1800
if((i > nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1800);
}
// ROR Label 1801
if((i >= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1801);
}
for(; i<nFarg; i++){
        
// ABS Label 1807
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1807);
}

// ABS Label 1808
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1808);
}

// ABS Label 1809
if(endCoalesce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1809);
}
sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);
        VdbeCoverage(v);
        
// ABS Label 1810
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1810);
}

// ABS Label 1811
if(pFarg->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1811);
}

// ABS Label 1812
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1812);
}
sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
      };
// ABS Label 1802
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1802);
}
// ABS Label 1803
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1803);
}

// ROR Label 1804
if((i <= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1804);
}
// ROR Label 1805
if((i > nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1805);
}
// ROR Label 1806
if((i >= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1806);
}

      
// ABS Label 1794
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1794);
}
setDoNotMergeFlagOnCopy(v);
      
// ABS Label 1795
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1795);
}

// ABS Label 1796
if(endCoalesce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1796);
}
sqlite3VdbeResolveLabel(v, endCoalesce);
      break;
    }
    case INLINEFUNC_iif: {
      Expr caseExpr;
      memset(&caseExpr, 0, sizeof(caseExpr));
      caseExpr.op = TK_CASE;
      caseExpr.x.pList = pFarg;
      return sqlite3ExprCodeTarget(pParse, &caseExpr, target);
    }

    default: {   
      /* The UNLIKELY() function is a no-op.  The result is the value
      ** of the first argument.
      */
      assert( nFarg==1 || nFarg==2 );
      target = sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);
      break;
    }

  /***********************************************************************
  ** Test-only SQL functions that are only usable if enabled
  ** via SQLITE_TESTCTRL_INTERNAL_FUNCTIONS
  */
    case INLINEFUNC_expr_compare: {
      /* Compare two expressions using sqlite3ExprCompare() */
      assert( nFarg==2 );
      
// ABS Label 1813
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1813);
}

// ABS Label 1814
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1814);
}
sqlite3VdbeAddOp2(v, OP_Integer, 
         sqlite3ExprCompare(0,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),
         target);
      break;
    }

    case INLINEFUNC_expr_implies_expr: {
      /* Compare two expressions using sqlite3ExprImpliesExpr() */
      assert( nFarg==2 );
      
// ABS Label 1815
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1815);
}

// ABS Label 1816
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1816);
}
sqlite3VdbeAddOp2(v, OP_Integer, 
         sqlite3ExprImpliesExpr(pParse,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),
         target);
      break;
    }

    case INLINEFUNC_implies_nonnull_row: {
      /* REsult of sqlite3ExprImpliesNonNullRow() */
      Expr *pA1;
      assert( nFarg==2 );
      pA1 = pFarg->a[1].pExpr;
      
// ROR Label 1817
if((pA1->op != 166) != (pA1->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1817);
}
if( pA1->op==TK_COLUMN ){
        
// ABS Label 1818
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1818);
}

// ABS Label 1819
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1819);
}
sqlite3VdbeAddOp2(v, OP_Integer, 
           sqlite3ExprImpliesNonNullRow(pFarg->a[0].pExpr,pA1->iTable),
           target);
      }else{
        
// ABS Label 1820
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1820);
}

// ABS Label 1821
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1821);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, target);
      }
      break;
    }

#ifdef SQLITE_DEBUG
    case INLINEFUNC_affinity: {
      /* The AFFINITY() function evaluates to a string that describes
      ** the type affinity of the argument.  This is used for testing of
      ** the SQLite type logic.
      */
      const char *azAff[] = { "blob", "text", "numeric", "integer", "real" };
      char aff;
      assert( nFarg==1 );
      aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);
      sqlite3VdbeLoadString(v, target, 
              (aff<=SQLITE_AFF_NONE) ? "none" : azAff[aff-SQLITE_AFF_BLOB]);
      break;
    }
#endif
  }
  
// ABS Label 1822
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1822);
}
return target;
}


/*
** Generate code into the current Vdbe to evaluate the given
** expression.  Attempt to store the results in register "target".
** Return the register where results are stored.
**
** With this routine, there is no guarantee that results will
** be stored in target.  The result might be stored in some other
** register if it is convenient to do so.  The calling function
** must check the return code and move the results to the desired
** register.
*/
int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){
  
// ABS Label 1823
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1823);
}
Vdbe *v = pParse->pVdbe;  /* The VM under construction */
  int op;                   /* The opcode being coded */
  
// ABS Label 1824
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1824);
}
int inReg = target;       /* Results stored in register inReg */
  int regFree1 = 0;         /* If non-zero free this temporary register */
  int regFree2 = 0;         /* If non-zero free this temporary register */
  int r1, r2;               /* Various register numbers */
  Expr tempX;               /* Temporary expression node */
  int p5 = 0;

  assert( target>0 && target<=pParse->nMem );
  assert( v!=0 );

expr_code_doover:
  
// ABS Label 1829
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1829);
}

// ROR Label 1830
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1830);
}
if( pExpr==0 ){
    op = TK_NULL;
  }else{
    assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );
    op = pExpr->op;
  }
  switch( op ){
    case TK_AGG_COLUMN: {
      
// ABS Label 1831
if(pExpr->pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1831);
}
AggInfo *pAggInfo = pExpr->pAggInfo;
      struct AggInfo_col *pCol;
      assert( pAggInfo!=0 );
      assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );
      pCol = &pAggInfo->aCol[pExpr->iAgg];
      if( !pAggInfo->directMode ){
        assert( pCol->iMem>0 );
        
// ABS Label 1832
if(pCol->iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1832);
}
return pCol->iMem;
      }else { 
// ABS Label 1833
if(pAggInfo->useSortingIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1833);
}
if( pAggInfo->useSortingIdx ){
        
// ABS Label 1834
if(pCol->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1834);
}
Table *pTab = pCol->pTab;
        
// ABS Label 1835
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1835);
}

// ABS Label 1836
if(pAggInfo->sortingIdxPTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1836);
}

// ABS Label 1837
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1837);
}
sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,
                              pCol->iSorterColumn, target);
        
// ROR Label 1838
if((pCol->iColumn <= 0) != (pCol->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1838);
}
// ROR Label 1839
if((pCol->iColumn > 0) != (pCol->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1839);
}
// ROR Label 1840
if((pCol->iColumn >= 0) != (pCol->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1840);
}
if( pCol->iColumn<0 ){
          VdbeComment((v,"%s.rowid",pTab->zName));
        }else{
          VdbeComment((v,"%s.%s",pTab->zName,pTab->aCol[pCol->iColumn].zName));
          
// ROR Label 1841
if((pTab->aCol[pCol->iColumn].affinity != 69) != (pTab->aCol[pCol->iColumn].affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1841);
}
if( pTab->aCol[pCol->iColumn].affinity==SQLITE_AFF_REAL ){
            
// ABS Label 1842
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1842);
}

// ABS Label 1843
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1843);
}
sqlite3VdbeAddOp1(v, OP_RealAffinity, target);
          }
        }
        
// ABS Label 1844
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1844);
}
return target;
      };}

      /* Otherwise, fall thru into the TK_COLUMN case */
      /* no break */ deliberate_fall_through
    }
    case TK_COLUMN: {
      
// ABS Label 1845
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1845);
}
int iTab = pExpr->iTable;
      int iReg;
      
// MCC Label 1846
if(( ((pExpr)->flags & (8)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1846);
}
// MCC Label 1847
if(( !(((pExpr)->flags & (8)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1847);
}
if( ExprHasProperty(pExpr, EP_FixedCol) ){
        /* This COLUMN expression is really a constant due to WHERE clause
        ** constraints, and that constant is coded by the pExpr->pLeft
        ** expresssion.  However, make sure the constant has the correct
        ** datatype by applying the Affinity of the table column to the
        ** constant.
        */
        int aff;
        iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);
        
// ABS Label 1848
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1848);
}
if( pExpr->y.pTab ){
          aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
        }else{
          aff = pExpr->affExpr;
        }
        
// ABS Label 1849
if(aff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1849);
}

// ROR Label 1850
if((aff <= 65) != (aff > 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1850);
}
// ROR Label 1851
if((aff < 65) != (aff > 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1851);
}
// ROR Label 1852
if((aff >= 65) != (aff > 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1852);
}
if( aff>SQLITE_AFF_BLOB ){
          static const char zAff[] = "B\000C\000D\000E";
          assert( SQLITE_AFF_BLOB=='A' );
          assert( SQLITE_AFF_TEXT=='B' );
          
// ABS Label 1853
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1853);
}

// ABS Label 1854
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1854);
}
sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,
                            &zAff[(aff-'B')*2], P4_STATIC);
        }
        
// ABS Label 1855
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1855);
}
return iReg;
      }
      
// ABS Label 1856
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1856);
}

// ROR Label 1857
if((iTab <= 0) != (iTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1857);
}
// ROR Label 1858
if((iTab > 0) != (iTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1858);
}
// ROR Label 1859
if((iTab >= 0) != (iTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1859);
}
if( iTab<0 ){
        
// ABS Label 1860
if(pParse->iSelfTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1860);
}

// ROR Label 1861
if((pParse->iSelfTab <= 0) != (pParse->iSelfTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1861);
}
// ROR Label 1862
if((pParse->iSelfTab > 0) != (pParse->iSelfTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1862);
}
// ROR Label 1863
if((pParse->iSelfTab >= 0) != (pParse->iSelfTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1863);
}
if( pParse->iSelfTab<0 ){
          /* Other columns in the same row for CHECK constraints or
          ** generated columns or for inserting into partial index.
          ** The row is unpacked into registers beginning at
          ** 0-(pParse->iSelfTab).  The rowid (if any) is in a register
          ** immediately prior to the first column.
          */
          Column *pCol;
          
// ABS Label 1864
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1864);
}
Table *pTab = pExpr->y.pTab;
          int iSrc;
          int iCol = pExpr->iColumn;
          assert( pTab!=0 );
          assert( iCol>=XN_ROWID );
          assert( iCol<pTab->nCol );
          
// ABS Label 1865
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1865);
}

// ROR Label 1866
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1866);
}
// ROR Label 1867
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1867);
}
// ROR Label 1868
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1868);
}
if( iCol<0 ){
            
// ABS Label 1869
if(pParse->iSelfTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1869);
}

// AOR Label 1870
if(-1 / pParse->iSelfTab != -1 - pParse->iSelfTab)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1870);
}
// AOR Label 1871
if(-1 + pParse->iSelfTab != -1 - pParse->iSelfTab)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1871);
}
// AOR Label 1872
if(-1 * pParse->iSelfTab != -1 - pParse->iSelfTab)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1872);
}
return -1-pParse->iSelfTab;
          }
          pCol = pTab->aCol + iCol;
          testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );
          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
          
// AOR Label 1873
if(pCol->colFlags | 96 != pCol->colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1873);
}
// AOR Label 1874
if(pCol->colFlags ^ 96 != pCol->colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1874);
}
if( pCol->colFlags & COLFLAG_GENERATED ){
            
// AOR Label 1875
if(pCol->colFlags | 256 != pCol->colFlags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1875);
}
// AOR Label 1876
if(pCol->colFlags ^ 256 != pCol->colFlags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1876);
}
if( pCol->colFlags & COLFLAG_BUSY ){
              
// ABS Label 1877
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1877);
}

// ABS Label 1878
if(pCol->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1878);
}
sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"",
                              pCol->zName);
              return 0;
            }
            pCol->colFlags |= COLFLAG_BUSY;
            
// AOR Label 1879
if(pCol->colFlags | 128 != pCol->colFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1879);
}
// AOR Label 1880
if(pCol->colFlags ^ 128 != pCol->colFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1880);
}
if( pCol->colFlags & COLFLAG_NOTAVAIL ){
              
// ABS Label 1881
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1881);
}

// ABS Label 1882
if(pCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1882);
}

// ABS Label 1883
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1883);
}
sqlite3ExprCodeGeneratedColumn(pParse, pCol, iSrc);
            }
            pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);
            
// ABS Label 1884
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1884);
}
return iSrc;
          }else {
#endif /* SQLITE_OMIT_GENERATED_COLUMNS */
          
// ROR Label 1885
if((pCol->affinity != 69) != (pCol->affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1885);
}
if( pCol->affinity==SQLITE_AFF_REAL ){
            
// ABS Label 1886
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1886);
}

// ABS Label 1887
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1887);
}

// ABS Label 1888
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1888);
}
sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);
            
// ABS Label 1889
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1889);
}

// ABS Label 1890
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1890);
}
sqlite3VdbeAddOp1(v, OP_RealAffinity, target);
            
// ABS Label 1891
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1891);
}
return target;
          }else{
            
// ABS Label 1892
if(iSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1892);
}
return iSrc;
          };}

        }else{
          /* Coding an expression that is part of an index where column names
          ** in the index refer to the table to which the index belongs */
          iTab = pParse->iSelfTab - 1;
        }
      }
      iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,
                               pExpr->iColumn, iTab, target,
                               pExpr->op2);
      
// ABS Label 1893
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1893);
}

// COR Label 1894
if((pExpr->y.pTab == 0 || pExpr->affExpr == 69) != (pExpr->y.pTab == 0 && pExpr->affExpr == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1894);
}

// ROR Label 1895
if((pExpr->y.pTab != 0) != (pExpr->y.pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1895);
}
// ROR Label 1896
if((pExpr->affExpr != 69) != (pExpr->affExpr == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1896);
}

// MCC Label 1897
if(pExpr->y.pTab == 0 && pExpr->affExpr == 69 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1897);
}
// MCC Label 1898
if(pExpr->y.pTab == 0 && !(pExpr->affExpr == 69) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1898);
}
// MCC Label 1899
if(!(pExpr->y.pTab == 0) && pExpr->affExpr == 69 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1899);
}
// MCC Label 1900
if(!(pExpr->y.pTab == 0) && !(pExpr->affExpr == 69) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1900);
}
if( pExpr->y.pTab==0 && pExpr->affExpr==SQLITE_AFF_REAL ){
        
// ABS Label 1901
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1901);
}

// ABS Label 1902
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1902);
}
sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);
      }
      
// ABS Label 1903
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1903);
}
return iReg;
    }
    case TK_INTEGER: {
      
// ABS Label 1904
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1904);
}

// ABS Label 1905
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1905);
}

// ABS Label 1906
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1906);
}
codeInteger(pParse, pExpr, 0, target);
      
// ABS Label 1907
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1907);
}
return target;
    }
    case TK_TRUEFALSE: {
      
// ABS Label 1908
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1908);
}

// ABS Label 1909
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1909);
}
sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);
      
// ABS Label 1910
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1910);
}
return target;
    }
#ifndef SQLITE_OMIT_FLOATING_POINT
    case TK_FLOAT: {
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
      
// ABS Label 1911
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1911);
}

// ABS Label 1912
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1912);
}
codeReal(v, pExpr->u.zToken, 0, target);
      
// ABS Label 1913
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1913);
}
return target;
    }
#endif
    case TK_STRING: {
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
      
// ABS Label 1914
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1914);
}

// ABS Label 1915
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1915);
}
sqlite3VdbeLoadString(v, target, pExpr->u.zToken);
      
// ABS Label 1916
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1916);
}
return target;
    }
    default: {
      /* Make NULL the default case so that if a bug causes an illegal
      ** Expr node to be passed into this function, it will be handled
      ** sanely and not crash.  But keep the assert() to bring the problem
      ** to the attention of the developers. */
      assert( op==TK_NULL || op==TK_ERROR || pParse->db->mallocFailed );
      
// ABS Label 1917
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1917);
}

// ABS Label 1918
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1918);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, target);
      
// ABS Label 1919
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1919);
}
return target;
    }
#ifndef SQLITE_OMIT_BLOB_LITERAL
    case TK_BLOB: {
      int n;
      const char *z;
      char *zBlob;
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
      assert( pExpr->u.zToken[1]=='\'' );
      z = &pExpr->u.zToken[2];
      n = sqlite3Strlen30(z) - 1;
      assert( z[n]=='\'' );
      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);
      
// ABS Label 1920
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1920);
}

// ABS Label 1921
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1921);
}

// AOR Label 1922
if(n - 2 != n / 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1922);
}
// AOR Label 1923
if(n + 2 != n / 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1923);
}
// AOR Label 1924
if(n * 2 != n / 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1924);
}

// ABS Label 1925
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1925);
}
sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);
      
// ABS Label 1926
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1926);
}
return target;
    }
#endif
    case TK_VARIABLE: {
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
      assert( pExpr->u.zToken!=0 );
      assert( pExpr->u.zToken[0]!=0 );
      
// ABS Label 1927
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1927);
}

// ABS Label 1928
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1928);
}
sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);
      
// ROR Label 1929
if((pExpr->u.zToken[1] == 0) != (pExpr->u.zToken[1] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1929);
}
if( pExpr->u.zToken[1]!=0 ){
        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);
        assert( pExpr->u.zToken[0]=='?' || (z && !strcmp(pExpr->u.zToken, z)) );
        pParse->pVList[0] = 0; /* Indicate VList may no longer be enlarged */
        
// ABS Label 1930
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1930);
}
sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);
      }
      
// ABS Label 1931
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1931);
}
return target;
    }
    case TK_REGISTER: {
      
// ABS Label 1932
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1932);
}
return pExpr->iTable;
    }
#ifndef SQLITE_OMIT_CAST
    case TK_CAST: {
      /* Expressions of the form:   CAST(pLeft AS token) */
      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      
// ABS Label 1935
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1935);
}
// ABS Label 1936
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1936);
}

// ROR Label 1937
if((inReg == target) != (inReg != target))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1937);
}
if( inReg!=target ){
        
// ABS Label 1938
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1938);
}

// ABS Label 1939
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1939);
}

// ABS Label 1940
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1940);
}
sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);
        inReg = target;
      }
      
// ABS Label 1933
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1933);
}

// ABS Label 1934
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1934);
}
sqlite3VdbeAddOp2(v, OP_Cast, target,
                        sqlite3AffinityType(pExpr->u.zToken, 0));
      
// ABS Label 1941
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1941);
}
return inReg;
    }
#endif /* SQLITE_OMIT_CAST */
    case TK_IS:
    case TK_ISNOT:
      op = (op==TK_IS) ? TK_EQ : TK_NE;
      p5 = SQLITE_NULLEQ;
      /* fall-through */
    case TK_LT:
    case TK_LE:
    case TK_GT:
    case TK_GE:
    case TK_NE:
    case TK_EQ: {
      
// ABS Label 1942
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1942);
}
Expr *pLeft = pExpr->pLeft;
      if( sqlite3ExprIsVector(pLeft) ){
        
// ABS Label 1943
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1943);
}

// ABS Label 1944
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1944);
}

// ABS Label 1945
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1945);
}
codeVectorCompare(pParse, pExpr, target, op, p5);
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
        
// ABS Label 1946
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1946);
}

// ABS Label 1947
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1947);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, inReg);
        
// ABS Label 1948
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1948);
}

// ABS Label 1949
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1949);
}

// ABS Label 1950
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1950);
}

// ABS Label 1951
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1951);
}

// ABS Label 1952
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1952);
}

// ABS Label 1953
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1953);
}

// ABS Label 1954
if(p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1954);
}
codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2,
            sqlite3VdbeCurrentAddr(v)+2, p5,
            ExprHasProperty(pExpr,EP_Commuted));
        assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);
        assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);
        assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);
        assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);
        assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);
        assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);
        
// ABS Label 1955
if(p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1955);
}

// ROR Label 1956
if((p5 != 128) != (p5 == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1956);
}
if( p5==SQLITE_NULLEQ ){
          
// ABS Label 1957
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1957);
}

// ABS Label 1958
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1958);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, inReg);
        }else{
          
// ABS Label 1959
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1959);
}

// ABS Label 1960
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1960);
}

// ABS Label 1961
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1961);
}

// ABS Label 1962
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1962);
}
sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, inReg, r2);
        }
        testcase( regFree1==0 );
        testcase( regFree2==0 );
      }
      break;
    }
    case TK_AND:
    case TK_OR:
    case TK_PLUS:
    case TK_STAR:
    case TK_MINUS:
    case TK_REM:
    case TK_BITAND:
    case TK_BITOR:
    case TK_SLASH:
    case TK_LSHIFT:
    case TK_RSHIFT: 
    case TK_CONCAT: {
      assert( TK_AND==OP_And );            testcase( op==TK_AND );
      assert( TK_OR==OP_Or );              testcase( op==TK_OR );
      assert( TK_PLUS==OP_Add );           testcase( op==TK_PLUS );
      assert( TK_MINUS==OP_Subtract );     testcase( op==TK_MINUS );
      assert( TK_REM==OP_Remainder );      testcase( op==TK_REM );
      assert( TK_BITAND==OP_BitAnd );      testcase( op==TK_BITAND );
      assert( TK_BITOR==OP_BitOr );        testcase( op==TK_BITOR );
      assert( TK_SLASH==OP_Divide );       testcase( op==TK_SLASH );
      assert( TK_LSHIFT==OP_ShiftLeft );   testcase( op==TK_LSHIFT );
      assert( TK_RSHIFT==OP_ShiftRight );  testcase( op==TK_RSHIFT );
      assert( TK_CONCAT==OP_Concat );      testcase( op==TK_CONCAT );
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      
// ABS Label 1963
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1963);
}

// ABS Label 1964
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1964);
}

// ABS Label 1965
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1965);
}

// ABS Label 1966
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1966);
}

// ABS Label 1967
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1967);
}
sqlite3VdbeAddOp3(v, op, r2, r1, target);
      testcase( regFree1==0 );
      testcase( regFree2==0 );
      break;
    }
    case TK_UMINUS: {
      
// ABS Label 1968
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1968);
}
Expr *pLeft = pExpr->pLeft;
      assert( pLeft );
      
// ROR Label 1969
if((pLeft->op != 154) != (pLeft->op == 154))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1969);
}
if( pLeft->op==TK_INTEGER ){
        
// ABS Label 1970
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1970);
}

// ABS Label 1971
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1971);
}

// ABS Label 1972
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1972);
}
codeInteger(pParse, pLeft, 1, target);
        
// ABS Label 1973
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1973);
}
return target;
#ifndef SQLITE_OMIT_FLOATING_POINT
      }else { 
// ROR Label 1974
if((pLeft->op != 152) != (pLeft->op == 152))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1974);
}
if( pLeft->op==TK_FLOAT ){
        assert( !ExprHasProperty(pExpr, EP_IntValue) );
        
// ABS Label 1975
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1975);
}

// ABS Label 1976
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1976);
}
codeReal(v, pLeft->u.zToken, 1, target);
        
// ABS Label 1977
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1977);
}
return target;
#endif
      }else{
        tempX.op = TK_INTEGER;
        tempX.flags = EP_IntValue|EP_TokenOnly;
        tempX.u.iValue = 0;
        ExprClearVVAProperties(&tempX);
        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);
        
// ABS Label 1978
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1978);
}

// ABS Label 1979
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1979);
}

// ABS Label 1980
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1980);
}

// ABS Label 1981
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1981);
}
sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);
        testcase( regFree2==0 );
      };}

      break;
    }
    case TK_BITNOT:
    case TK_NOT: {
      assert( TK_BITNOT==OP_BitNot );   testcase( op==TK_BITNOT );
      assert( TK_NOT==OP_Not );         testcase( op==TK_NOT );
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      testcase( regFree1==0 );
      
// ABS Label 1982
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1982);
}

// ABS Label 1983
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1983);
}

// ABS Label 1984
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1984);
}

// ABS Label 1985
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1985);
}
sqlite3VdbeAddOp2(v, op, r1, inReg);
      break;
    }
    case TK_TRUTH: {
      int isTrue;    /* IS TRUE or IS NOT TRUE */
      int bNormal;   /* IS TRUE or IS FALSE */
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      testcase( regFree1==0 );
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      bNormal = pExpr->op2==TK_IS;
      testcase( isTrue && bNormal);
      testcase( !isTrue && bNormal);
      
// ABS Label 1986
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1986);
}

// ABS Label 1987
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1987);
}

// ABS Label 1988
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1988);
}

// ABS Label 1989
if(bNormal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1989);
}
// ABS Label 1990
if(isTrue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1990);
}

// AOR Label 1991
if(isTrue | bNormal != isTrue ^ bNormal)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1991);
}
// AOR Label 1992
if(isTrue & bNormal != isTrue ^ bNormal)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1992);
}
sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);
      break;
    }
    case TK_ISNULL:
    case TK_NOTNULL: {
      int addr;
      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );
      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );
      
// ABS Label 1993
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1993);
}

// ABS Label 1994
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1994);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, target);
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      testcase( regFree1==0 );
      addr = sqlite3VdbeAddOp1(v, op, r1);
      VdbeCoverageIf(v, op==TK_ISNULL);
      VdbeCoverageIf(v, op==TK_NOTNULL);
      
// ABS Label 1995
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1995);
}

// ABS Label 1996
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1996);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, target);
      
// ABS Label 1997
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1997);
}

// ABS Label 1998
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1998);
}
sqlite3VdbeJumpHere(v, addr);
      break;
    }
    case TK_AGG_FUNCTION: {
      
// ABS Label 1999
if(pExpr->pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1999);
}
AggInfo *pInfo = pExpr->pAggInfo;
      
// ABS Label 2000
if(pInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2000);
}

// COR Label 2001
if((pInfo == 0 || (pExpr->iAgg < 0) && (pExpr->iAgg >= pInfo->nFunc)) != (pInfo == 0 || (pExpr->iAgg < 0) || (pExpr->iAgg >= pInfo->nFunc)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2001);
}
// COR Label 2002
if((pInfo == 0 && (pExpr->iAgg < 0)) != (pInfo == 0 || (pExpr->iAgg < 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2002);
}

// ROR Label 2003
if((pInfo != 0) != (pInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2003);
}

// MCC Label 2004
if(pInfo == 0 && ( pExpr->iAgg < 0 ) && ( pExpr->iAgg >= pInfo->nFunc ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2004);
}
// MCC Label 2005
if(pInfo == 0 && ( pExpr->iAgg < 0 ) && ( !(pExpr->iAgg >= pInfo->nFunc) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2005);
}
// MCC Label 2006
if(pInfo == 0 && ( !(pExpr->iAgg < 0) ) && ( pExpr->iAgg >= pInfo->nFunc ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2006);
}
// MCC Label 2007
if(pInfo == 0 && ( !(pExpr->iAgg < 0) ) && ( !(pExpr->iAgg >= pInfo->nFunc) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2007);
}
// MCC Label 2008
if(!(pInfo == 0) && ( pExpr->iAgg < 0 ) && ( pExpr->iAgg >= pInfo->nFunc ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2008);
}
// MCC Label 2009
if(!(pInfo == 0) && ( pExpr->iAgg < 0 ) && ( !(pExpr->iAgg >= pInfo->nFunc) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2009);
}
// MCC Label 2010
if(!(pInfo == 0) && ( !(pExpr->iAgg < 0) ) && ( pExpr->iAgg >= pInfo->nFunc ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2010);
}
// MCC Label 2011
if(!(pInfo == 0) && ( !(pExpr->iAgg < 0) ) && ( !(pExpr->iAgg >= pInfo->nFunc) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2011);
}
if( pInfo==0
       || NEVER(pExpr->iAgg<0)
       || NEVER(pExpr->iAgg>=pInfo->nFunc)
      ){
        assert( !ExprHasProperty(pExpr, EP_IntValue) );
        
// ABS Label 2012
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2012);
}

// ABS Label 2013
if(pExpr->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2013);
}
sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
      }else{
        
// ABS Label 2014
if(pInfo->aFunc[pExpr->iAgg].iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2014);
}
return pInfo->aFunc[pExpr->iAgg].iMem;
      }
      break;
    }
    case TK_FUNCTION: {
      ExprList *pFarg;       /* List of function arguments */
      int nFarg;             /* Number of function arguments */
      FuncDef *pDef;         /* The function definition object */
      const char *zId;       /* The function name */
      u32 constMask = 0;     /* Mask of function arguments that are constant */
      int i;                 /* Loop counter */
      
// ABS Label 2015
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2015);
}
sqlite3 *db = pParse->db;  /* The database connection */
      
// ABS Label 2016
if(((db)->enc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2016);
}
u8 enc = ENC(db);      /* The text encoding used by this database */
      CollSeq *pColl = 0;    /* A collating sequence */

#ifndef SQLITE_OMIT_WINDOWFUNC
      
// MCC Label 2017
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2017);
}
// MCC Label 2018
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2018);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
        
// ABS Label 2019
if(pExpr->y.pWin->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2019);
}
return pExpr->y.pWin->regResult;
      }
#endif

      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){
        /* SQL functions can be expensive. So try to avoid running them
        ** multiple times if we know they always give the same result */
        return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);
      }
      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
      assert( !ExprHasProperty(pExpr, EP_TokenOnly) );
      pFarg = pExpr->x.pList;
      nFarg = pFarg ? pFarg->nExpr : 0;
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
      zId = pExpr->u.zToken;
      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
      if( pDef==0 && pParse->explain ){
        pDef = sqlite3FindFunction(db, "unknown", nFarg, enc, 0);
      }
#endif
      
// ABS Label 2020
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2020);
}
// ABS Label 2021
if(pDef->xFinalize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2021);
}

// COR Label 2022
if((pDef == 0 && pDef->xFinalize != 0) != (pDef == 0 || pDef->xFinalize != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2022);
}

// ROR Label 2023
if((pDef != 0) != (pDef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2023);
}
// ROR Label 2024
if((pDef->xFinalize == 0) != (pDef->xFinalize != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2024);
}

// MCC Label 2025
if(pDef == 0 && pDef->xFinalize != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2025);
}
// MCC Label 2026
if(pDef == 0 && !(pDef->xFinalize != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2026);
}
// MCC Label 2027
if(!(pDef == 0) && pDef->xFinalize != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2027);
}
// MCC Label 2028
if(!(pDef == 0) && !(pDef->xFinalize != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2028);
}
if( pDef==0 || pDef->xFinalize!=0 ){
        
// ABS Label 2029
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2029);
}

// ABS Label 2030
if(zId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2030);
}
sqlite3ErrorMsg(pParse, "unknown function: %s()", zId);
        break;
      }
      
// ABS Label 2031
if(pDef->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2031);
}

// AOR Label 2032
if(pDef->funcFlags | 4194304 != pDef->funcFlags & 4194304)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2032);
}
// AOR Label 2033
if(pDef->funcFlags ^ 4194304 != pDef->funcFlags & 4194304)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2033);
}
if( pDef->funcFlags & SQLITE_FUNC_INLINE ){
        assert( (pDef->funcFlags & SQLITE_FUNC_UNSAFE)==0 );
        assert( (pDef->funcFlags & SQLITE_FUNC_DIRECT)==0 );
        return exprCodeInlineFunction(pParse, pFarg,
             SQLITE_PTR_TO_INT(pDef->pUserData), target);
      }else { 
// ABS Label 2034
if(pDef->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2034);
}

// AOR Label 2035
if(pDef->funcFlags | (524288 | 2097152) != pDef->funcFlags & (524288 | 2097152))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2035);
}
// AOR Label 2036
if(pDef->funcFlags ^ (524288 | 2097152) != pDef->funcFlags & (524288 | 2097152))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2036);
}
if( pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE) ){
        
// ABS Label 2037
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2037);
}

// ABS Label 2038
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2038);
}

// ABS Label 2039
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2039);
}
sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
      };}


      i = 0;

// ABS Label 2040
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2040);
}
// ABS Label 2041
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2041);
}

// ROR Label 2042
if((i <= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2042);
}
// ROR Label 2043
if((i > nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2043);
}
// ROR Label 2044
if((i >= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2044);
}
for(; i<nFarg; i++){
        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){
          testcase( i==31 );
          constMask |= MASKBIT32(i);
        }
        
// COR Label 2050
if(((pDef->funcFlags & 32) != 0 || !pColl) != ((pDef->funcFlags & 32) != 0 && !pColl))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2050);
}

// ROR Label 2051
if(((pDef->funcFlags & 32) == 0) != ((pDef->funcFlags & 32) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2051);
}

// MCC Label 2052
if((pDef->funcFlags & 32) != 0 && !pColl ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2052);
}
// MCC Label 2053
if((pDef->funcFlags & 32) != 0 && !(!pColl) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2053);
}
// MCC Label 2054
if(!((pDef->funcFlags & 32) != 0) && !pColl ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2054);
}
// MCC Label 2055
if(!((pDef->funcFlags & 32) != 0) && !(!pColl) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2055);
}
if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){
          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);
        }
      };
// ABS Label 2045
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2045);
}
// ABS Label 2046
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2046);
}

// ROR Label 2047
if((i <= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2047);
}
// ROR Label 2048
if((i > nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2048);
}
// ROR Label 2049
if((i >= nFarg) != (i < nFarg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2049);
}

      
// ABS Label 2056
if(pFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2056);
}
if( pFarg ){
        
// ABS Label 2060
if(constMask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2060);
}
if( constMask ){
          r1 = pParse->nMem+1;
          pParse->nMem += nFarg;
        }else{
          r1 = sqlite3GetTempRange(pParse, nFarg);
        }

        /* For length() and typeof() functions with a column argument,
        ** set the P5 parameter to the OP_Column opcode to OPFLAG_LENGTHARG
        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data
        ** loading.
        */
        
// ROR Label 2061
if(((pDef->funcFlags & (64 | 128)) == 0) != ((pDef->funcFlags & (64 | 128)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2061);
}
if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){
          u8 exprOp;
          assert( nFarg==1 );
          assert( pFarg->a[0].pExpr!=0 );
          exprOp = pFarg->a[0].pExpr->op;
          
// COR Label 2062
if((exprOp == 166 && exprOp == 168) != (exprOp == 166 || exprOp == 168))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2062);
}

// ROR Label 2063
if((exprOp != 166) != (exprOp == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2063);
}
// ROR Label 2064
if((exprOp != 168) != (exprOp == 168))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2064);
}

// MCC Label 2065
if(exprOp == 166 && exprOp == 168 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2065);
}
// MCC Label 2066
if(exprOp == 166 && !(exprOp == 168) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2066);
}
// MCC Label 2067
if(!(exprOp == 166) && exprOp == 168 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2067);
}
// MCC Label 2068
if(!(exprOp == 166) && !(exprOp == 168) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2068);
}
if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){
            assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );
            assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );
            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );
            pFarg->a[0].pExpr->op2 = 
                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);
          }
        }

        
// ABS Label 2057
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2057);
}

// ABS Label 2058
if(pFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2058);
}

// ABS Label 2059
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2059);
}
sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,
                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);
      }else{
        r1 = 0;
      }
#ifndef SQLITE_OMIT_VIRTUALTABLE
      /* Possibly overload the function if the first argument is
      ** a virtual table column.
      **
      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the
      ** second argument, not the first, as the argument to test to
      ** see if it is a column in a virtual table.  This is done because
      ** the left operand of infix functions (the operand we want to
      ** control overloading) ends up as the second argument to the
      ** function.  The expression "A glob B" is equivalent to 
      ** "glob(B,A).  We want to use the A in "A glob B" to test
      ** for function overloading.  But we use the B term in "glob(B,A)".
      */
      
// ABS Label 2069
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2069);
}

// COR Label 2070
if((nFarg >= 2 || (((pExpr)->flags & (128)) != 0)) != (nFarg >= 2 && (((pExpr)->flags & (128)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2070);
}

// ROR Label 2071
if((nFarg < 2) != (nFarg >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2071);
}
// ROR Label 2072
if((nFarg > 2) != (nFarg >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2072);
}
// ROR Label 2073
if((nFarg <= 2) != (nFarg >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2073);
}

// MCC Label 2074
if(nFarg >= 2 && ( ((pExpr)->flags & (128)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2074);
}
// MCC Label 2075
if(nFarg >= 2 && ( !(((pExpr)->flags & (128)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2075);
}
// MCC Label 2076
if(!(nFarg >= 2) && ( ((pExpr)->flags & (128)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2076);
}
// MCC Label 2077
if(!(nFarg >= 2) && ( !(((pExpr)->flags & (128)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2077);
}
if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);
      }else { 
// ABS Label 2078
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2078);
}

// ROR Label 2079
if((nFarg <= 0) != (nFarg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2079);
}
// ROR Label 2080
if((nFarg < 0) != (nFarg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2080);
}
// ROR Label 2081
if((nFarg >= 0) != (nFarg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2081);
}
if( nFarg>0 ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);
      };}

#endif
      
// ABS Label 2082
if(pDef->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2082);
}

// AOR Label 2083
if(pDef->funcFlags | 32 != pDef->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2083);
}
// AOR Label 2084
if(pDef->funcFlags ^ 32 != pDef->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2084);
}
if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){
        if( !pColl ) { pColl = db->pDfltColl; 
}
        
// ABS Label 2085
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2085);
}
sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);
      }
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
      if( pDef->funcFlags & SQLITE_FUNC_OFFSET ){
        Expr *pArg = pFarg->a[0].pExpr;
        if( pArg->op==TK_COLUMN ){
          sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);
        }else{
          sqlite3VdbeAddOp2(v, OP_Null, 0, target);
        }
      }else
#endif
      {
        
// ABS Label 2086
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2086);
}

// ABS Label 2087
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2087);
}

// ABS Label 2088
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2088);
}

// ABS Label 2089
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2089);
}
sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,
                                   pDef, pExpr->op2);
      }
      
// ABS Label 2090
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2090);
}
if( nFarg ){
        
// ABS Label 2091
if(constMask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2091);
}

// ROR Label 2092
if((constMask != 0) != (constMask == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2092);
}
if( constMask==0 ){
          
// ABS Label 2093
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2093);
}

// ABS Label 2094
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2094);
}

// ABS Label 2095
if(nFarg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2095);
}
sqlite3ReleaseTempRange(pParse, r1, nFarg);
        }else{
          sqlite3VdbeReleaseRegisters(pParse, r1, nFarg, constMask, 1);
        }
      }
      
// ABS Label 2096
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2096);
}
return target;
    }
#ifndef SQLITE_OMIT_SUBQUERY
    case TK_EXISTS:
    case TK_SELECT: {
      int nCol;
      testcase( op==TK_EXISTS );
      testcase( op==TK_SELECT );
      
// ABS Label 2097
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2097);
}
if( pParse->db->mallocFailed ){
        return 0;
      }else { if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){
        
// ABS Label 2098
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2098);
}

// ABS Label 2099
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2099);
}
sqlite3SubselectError(pParse, nCol, 1);
      }else{
        return sqlite3CodeSubselect(pParse, pExpr);
      };}

      break;
    }
    case TK_SELECT_COLUMN: {
      int n;
      
// ABS Label 2100
if(pExpr->pLeft->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2100);
}

// ROR Label 2101
if((pExpr->pLeft->iTable != 0) != (pExpr->pLeft->iTable == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2101);
}
if( pExpr->pLeft->iTable==0 ){
        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);
      }
      assert( pExpr->pLeft->op==TK_SELECT || pExpr->pLeft->op==TK_ERROR );
      n = sqlite3ExprVectorSize(pExpr->pLeft);
      
// ABS Label 2102
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2102);
}
// ABS Label 2103
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2103);
}

// ROR Label 2104
if((pExpr->iTable == n) != (pExpr->iTable != n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2104);
}
if( pExpr->iTable!=n ){
        
// ABS Label 2105
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2105);
}

// ABS Label 2106
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2106);
}

// ABS Label 2107
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2107);
}
sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                                pExpr->iTable, n);
      }
      
// ABS Label 2108
if(pExpr->pLeft->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2108);
}

// AOR Label 2109
if(pExpr->pLeft->iTable - pExpr->iColumn != pExpr->pLeft->iTable + pExpr->iColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2109);
}
// AOR Label 2110
if(pExpr->pLeft->iTable / pExpr->iColumn != pExpr->pLeft->iTable + pExpr->iColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2110);
}
// AOR Label 2111
if(pExpr->pLeft->iTable * pExpr->iColumn != pExpr->pLeft->iTable + pExpr->iColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2111);
}
return pExpr->pLeft->iTable + pExpr->iColumn;
    }
    case TK_IN: {
      int destIfFalse = sqlite3VdbeMakeLabel(pParse);
      int destIfNull = sqlite3VdbeMakeLabel(pParse);
      
// ABS Label 2112
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2112);
}

// ABS Label 2113
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2113);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, target);
      
// ABS Label 2114
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2114);
}

// ABS Label 2115
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2115);
}

// ABS Label 2116
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2116);
}

// ABS Label 2117
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2117);
}
sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      
// ABS Label 2118
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2118);
}

// ABS Label 2119
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2119);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, target);
      
// ABS Label 2120
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2120);
}

// ABS Label 2121
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2121);
}
sqlite3VdbeResolveLabel(v, destIfFalse);
      
// ABS Label 2122
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2122);
}

// ABS Label 2123
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2123);
}
sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);
      
// ABS Label 2124
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2124);
}

// ABS Label 2125
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2125);
}
sqlite3VdbeResolveLabel(v, destIfNull);
      
// ABS Label 2126
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2126);
}
return target;
    }
#endif /* SQLITE_OMIT_SUBQUERY */


    /*
    **    x BETWEEN y AND z
    **
    ** This is equivalent to
    **
    **    x>=y AND x<=z
    **
    ** X is stored in pExpr->pLeft.
    ** Y is stored in pExpr->pList->a[0].pExpr.
    ** Z is stored in pExpr->pList->a[1].pExpr.
    */
    case TK_BETWEEN: {
      
// ABS Label 2127
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2127);
}

// ABS Label 2128
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2128);
}

// ABS Label 2129
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2129);
}
exprCodeBetween(pParse, pExpr, target, 0, 0);
      
// ABS Label 2130
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2130);
}
return target;
    }
    case TK_SPAN:
    case TK_COLLATE: 
    case TK_UPLUS: {
      pExpr = pExpr->pLeft;
      goto expr_code_doover; /* 2018-04-28: Prevent deep recursion. OSSFuzz. */
    }

    case TK_TRIGGER: {
      /* If the opcode is TK_TRIGGER, then the expression is a reference
      ** to a column in the new.* or old.* pseudo-tables available to
      ** trigger programs. In this case Expr.iTable is set to 1 for the
      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn
      ** is set to the column of the pseudo-table to read, or to -1 to
      ** read the rowid field.
      **
      ** The expression is implemented using an OP_Param opcode. The p1
      ** parameter is set to 0 for an old.rowid reference, or to (i+1)
      ** to reference another column of the old.* pseudo-table, where 
      ** i is the index of the column. For a new.rowid reference, p1 is
      ** set to (n+1), where n is the number of columns in each pseudo-table.
      ** For a reference to any other column in the new.* pseudo-table, p1
      ** is set to (n+2+i), where n and i are as defined previously. For
      ** example, if the table on which triggers are being fired is
      ** declared as:
      **
      **   CREATE TABLE t1(a, b);
      **
      ** Then p1 is interpreted as follows:
      **
      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid
      **   p1==1   ->    old.a         p1==4   ->    new.a
      **   p1==2   ->    old.b         p1==5   ->    new.b       
      */
      
// ABS Label 2131
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2131);
}
Table *pTab = pExpr->y.pTab;
      int iCol = pExpr->iColumn;
      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 
                     + sqlite3TableColumnToStorage(pTab, iCol);

      assert( pExpr->iTable==0 || pExpr->iTable==1 );
      assert( iCol>=-1 && iCol<pTab->nCol );
      assert( pTab->iPKey<0 || iCol!=pTab->iPKey );
      assert( p1>=0 && p1<(pTab->nCol*2+2) );

      
// ABS Label 2132
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2132);
}

// ABS Label 2133
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2133);
}

// ABS Label 2134
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2134);
}
sqlite3VdbeAddOp2(v, OP_Param, p1, target);
      VdbeComment((v, "r[%d]=%s.%s", target,
        (pExpr->iTable ? "new" : "old"),
        (pExpr->iColumn<0 ? "rowid" : pExpr->y.pTab->aCol[iCol].zName)
      ));

#ifndef SQLITE_OMIT_FLOATING_POINT
      /* If the column has REAL affinity, it may currently be stored as an
      ** integer. Use OP_RealAffinity to make sure it is really real.
      **
      ** EVIDENCE-OF: R-60985-57662 SQLite will convert the value back to
      ** floating point when extracting it from the record.  */
      
// ABS Label 2135
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2135);
}

// COR Label 2136
if((iCol >= 0 || pTab->aCol[iCol].affinity == 69) != (iCol >= 0 && pTab->aCol[iCol].affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2136);
}

// ROR Label 2137
if((iCol < 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2137);
}
// ROR Label 2138
if((iCol > 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2138);
}
// ROR Label 2139
if((iCol <= 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2139);
}
// ROR Label 2140
if((pTab->aCol[iCol].affinity != 69) != (pTab->aCol[iCol].affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2140);
}

// MCC Label 2141
if(iCol >= 0 && pTab->aCol[iCol].affinity == 69 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2141);
}
// MCC Label 2142
if(iCol >= 0 && !(pTab->aCol[iCol].affinity == 69) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2142);
}
// MCC Label 2143
if(!(iCol >= 0) && pTab->aCol[iCol].affinity == 69 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2143);
}
// MCC Label 2144
if(!(iCol >= 0) && !(pTab->aCol[iCol].affinity == 69) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2144);
}
if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){
        
// ABS Label 2145
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2145);
}

// ABS Label 2146
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2146);
}
sqlite3VdbeAddOp1(v, OP_RealAffinity, target);
      }
#endif
      break;
    }

    case TK_VECTOR: {
      
// ABS Label 2147
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2147);
}
sqlite3ErrorMsg(pParse, "row value misused");
      break;
    }

    /* TK_IF_NULL_ROW Expr nodes are inserted ahead of expressions
    ** that derive from the right-hand table of a LEFT JOIN.  The
    ** Expr.iTable value is the table number for the right-hand table.
    ** The expression is only evaluated if that table is not currently
    ** on a LEFT JOIN NULL row.
    */
    case TK_IF_NULL_ROW: {
      int addrINR;
      
// ABS Label 2148
if(pParse->okConstFactor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2148);
}
u8 okConstFactor = pParse->okConstFactor;
      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);
      /* Temporarily disable factoring of constant expressions, since
      ** even though expressions may appear to be constant, they are not
      ** really constant because they originate from the right-hand side
      ** of a LEFT JOIN. */
      pParse->okConstFactor = 0;
      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      pParse->okConstFactor = okConstFactor;
      
// ABS Label 2149
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2149);
}

// ABS Label 2150
if(addrINR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2150);
}
sqlite3VdbeJumpHere(v, addrINR);
      
// ABS Label 2151
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2151);
}

// ABS Label 2152
if(addrINR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2152);
}

// ABS Label 2153
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2153);
}
sqlite3VdbeChangeP3(v, addrINR, inReg);
      break;
    }

    /*
    ** Form A:
    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form B:
    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END
    **
    ** Form A is can be transformed into the equivalent form B as follows:
    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...
    **        WHEN x=eN THEN rN ELSE y END
    **
    ** X (if it exists) is in pExpr->pLeft.
    ** Y is in the last element of pExpr->x.pList if pExpr->x.pList->nExpr is
    ** odd.  The Y is also optional.  If the number of elements in x.pList
    ** is even, then Y is omitted and the "otherwise" result is NULL.
    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].
    **
    ** The result of the expression is the Ri for the first matching Ei,
    ** or if there is no matching Ei, the ELSE term Y, or if there is
    ** no ELSE term, NULL.
    */
    case TK_CASE: {
      int endLabel;                     /* GOTO label for end of CASE stmt */
      int nextCase;                     /* GOTO label for next WHEN clause */
      int nExpr;                        /* 2x number of WHEN terms */
      int i;                            /* Loop counter */
      ExprList *pEList;                 /* List of WHEN terms */
      struct ExprList_item *aListelem;  /* Array of WHEN terms */
      Expr opCompare;                   /* The X==Ei expression */
      Expr *pX;                         /* The X expression */
      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */
      Expr *pDel = 0;
      
// ABS Label 2154
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2154);
}
sqlite3 *db = pParse->db;

      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );
      assert(pExpr->x.pList->nExpr > 0);
      pEList = pExpr->x.pList;
      aListelem = pEList->a;
      nExpr = pEList->nExpr;
      endLabel = sqlite3VdbeMakeLabel(pParse);
      if( (pX = pExpr->pLeft)!=0 ){
        pDel = sqlite3ExprDup(db, pX, 0);
        
// ABS Label 2161
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2161);
}
if( db->mallocFailed ){
          
// ABS Label 2162
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2162);
}

// ABS Label 2163
if(pDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2163);
}
sqlite3ExprDelete(db, pDel);
          break;
        }
        testcase( pX->op==TK_COLUMN );
        
// ABS Label 2160
if(pDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2160);
}
exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
        testcase( regFree1==0 );
        memset(&opCompare, 0, sizeof(opCompare));
        opCompare.op = TK_EQ;
        opCompare.pLeft = pDel;
        pTest = &opCompare;
        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:
        ** The value in regFree1 might get SCopy-ed into the file result.
        ** So make sure that the regFree1 register is not reused for other
        ** purposes and possibly overwritten.  */
        regFree1 = 0;
      }
      i = 0;

// ABS Label 2164
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2164);
}
// ABS Label 2165
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2165);
}

// AOR Label 2166
if(nExpr / 1 != nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2166);
}
// AOR Label 2167
if(nExpr + 1 != nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2167);
}
// AOR Label 2168
if(nExpr * 1 != nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2168);
}

// ROR Label 2169
if((i <= nExpr - 1) != (i < nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2169);
}
// ROR Label 2170
if((i > nExpr - 1) != (i < nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2170);
}
// ROR Label 2171
if((i >= nExpr - 1) != (i < nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2171);
}
for(; i<nExpr-1; i=i+2){
        
// ABS Label 2190
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2190);
}
if( pX ){
          assert( pTest!=0 );
          opCompare.pRight = aListelem[i].pExpr;
        }else{
          pTest = aListelem[i].pExpr;
        }
        nextCase = sqlite3VdbeMakeLabel(pParse);
        testcase( pTest->op==TK_COLUMN );
        
// ABS Label 2180
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2180);
}

// ABS Label 2181
if(pTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2181);
}

// ABS Label 2182
if(nextCase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2182);
}
sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);
        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );
        
// ABS Label 2183
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2183);
}

// ABS Label 2184
if(aListelem[i + 1].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2184);
}

// ABS Label 2185
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2185);
}
sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);
        
// ABS Label 2186
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2186);
}

// ABS Label 2187
if(endLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2187);
}
sqlite3VdbeGoto(v, endLabel);
        
// ABS Label 2188
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2188);
}

// ABS Label 2189
if(nextCase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2189);
}
sqlite3VdbeResolveLabel(v, nextCase);
      };
// ABS Label 2172
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2172);
}
// ABS Label 2173
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2173);
}

// AOR Label 2174
if(nExpr / 1 != nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2174);
}
// AOR Label 2175
if(nExpr + 1 != nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2175);
}
// AOR Label 2176
if(nExpr * 1 != nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2176);
}

// ROR Label 2177
if((i <= nExpr - 1) != (i < nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2177);
}
// ROR Label 2178
if((i > nExpr - 1) != (i < nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2178);
}
// ROR Label 2179
if((i >= nExpr - 1) != (i < nExpr - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2179);
}

      
// ROR Label 2191
if(((nExpr & 1) == 0) != ((nExpr & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2191);
}
if( (nExpr&1)!=0 ){
        
// ABS Label 2192
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2192);
}

// ABS Label 2193
if(pEList->a[nExpr - 1].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2193);
}

// ABS Label 2194
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2194);
}
sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);
      }else{
        
// ABS Label 2195
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2195);
}

// ABS Label 2196
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2196);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, target);
      }
      
// ABS Label 2155
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2155);
}

// ABS Label 2156
if(pDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2156);
}
sqlite3ExprDelete(db, pDel);
      
// ABS Label 2157
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2157);
}
setDoNotMergeFlagOnCopy(v);
      
// ABS Label 2158
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2158);
}

// ABS Label 2159
if(endLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2159);
}
sqlite3VdbeResolveLabel(v, endLabel);
      break;
    }
#ifndef SQLITE_OMIT_TRIGGER
    case TK_RAISE: {
      assert( pExpr->affExpr==OE_Rollback 
           || pExpr->affExpr==OE_Abort
           || pExpr->affExpr==OE_Fail
           || pExpr->affExpr==OE_Ignore
      );
      
// COR Label 2197
if((!pParse->pTriggerTab || !pParse->nested) != (!pParse->pTriggerTab && !pParse->nested))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2197);
}

// MCC Label 2198
if(!pParse->pTriggerTab && !pParse->nested ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2198);
}
// MCC Label 2199
if(!pParse->pTriggerTab && !(!pParse->nested) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2199);
}
// MCC Label 2200
if(!(!pParse->pTriggerTab) && !pParse->nested ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2200);
}
// MCC Label 2201
if(!(!pParse->pTriggerTab) && !(!pParse->nested) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2201);
}
if( !pParse->pTriggerTab && !pParse->nested ){
        
// ABS Label 2202
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2202);
}
sqlite3ErrorMsg(pParse,
                       "RAISE() may only be used within a trigger-program");
        return 0;
      }
      
// ROR Label 2203
if((pExpr->affExpr != 2) != (pExpr->affExpr == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2203);
}
if( pExpr->affExpr==OE_Abort ){
        
// ABS Label 2204
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2204);
}
sqlite3MayAbort(pParse);
      }
      assert( !ExprHasProperty(pExpr, EP_IntValue) );
      
// ROR Label 2205
if((pExpr->affExpr != 4) != (pExpr->affExpr == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2205);
}
if( pExpr->affExpr==OE_Ignore ){
        
// ABS Label 2206
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2206);
}
sqlite3VdbeAddOp4(
            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);
        VdbeCoverage(v);
      }else{
        
// ABS Label 2207
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2207);
}

// ABS Label 2208
if(pExpr->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2208);
}
sqlite3HaltConstraint(pParse,
             pParse->pTriggerTab ? SQLITE_CONSTRAINT_TRIGGER : SQLITE_ERROR,
             pExpr->affExpr, pExpr->u.zToken, 0, 0);
      }

      break;
    }
#endif
  }
  
// ABS Label 1825
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1825);
}

// ABS Label 1826
if(regFree1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1826);
}
sqlite3ReleaseTempReg(pParse, regFree1);
  
// ABS Label 1827
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1827);
}

// ABS Label 1828
if(regFree2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1828);
}
sqlite3ReleaseTempReg(pParse, regFree2);
  
// ABS Label 2209
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2209);
}
return inReg;
}

/*
** Generate code that will evaluate expression pExpr just one time
** per prepared statement execution.
**
** If the expression uses functions (that might throw an exception) then
** guard them with an OP_Once opcode to ensure that the code is only executed
** once. If no functions are involved, then factor the code out and put it at
** the end of the prepared statement in the initialization section.
**
** If regDest>=0 then the result is always stored in that register and the
** result is not reusable.  If regDest<0 then this routine is free to 
** store the value whereever it wants.  The register where the expression 
** is stored is returned.  When regDest<0, two identical expressions might
** code to the same register, if they do not contain function calls and hence
** are factored out into the initialization section at the end of the
** prepared statement.
*/
int sqlite3ExprCodeRunJustOnce(
  Parse *pParse,    /* Parsing context */
  Expr *pExpr,      /* The expression to code when the VDBE initializes */
  int regDest       /* Store the value in this register */
){
  ExprList *p;
  assert( ConstFactorOk(pParse) );
  p = pParse->pConstExpr;
  
// ABS Label 2210
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2210);
}
// ABS Label 2211
if(regDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2211);
}

// COR Label 2212
if((regDest < 0 || p) != (regDest < 0 && p))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2212);
}

// ROR Label 2213
if((regDest <= 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2213);
}
// ROR Label 2214
if((regDest > 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2214);
}
// ROR Label 2215
if((regDest >= 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2215);
}

// MCC Label 2216
if(regDest < 0 && p ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2216);
}
// MCC Label 2217
if(regDest < 0 && !(p) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2217);
}
// MCC Label 2218
if(!(regDest < 0) && p ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2218);
}
// MCC Label 2219
if(!(regDest < 0) && !(p) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2219);
}
if( regDest<0 && p ){
    struct ExprList_item *pItem;
    int i;
    pItem = p->a , i = p->nExpr;

// ABS Label 2220
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2220);
}

// ROR Label 2221
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2221);
}
// ROR Label 2222
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2222);
}
// ROR Label 2223
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2223);
}
for(; i>0; pItem++, i--){
      if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){
        
// ABS Label 2228
if(pItem->u.iConstExprReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2228);
}
return pItem->u.iConstExprReg;
      }
    };
// ABS Label 2224
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2224);
}

// ROR Label 2225
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2225);
}
// ROR Label 2226
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2226);
}
// ROR Label 2227
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2227);
}

  }
  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
  
// ABS Label 2229
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2229);
}

// COR Label 2230
if((pExpr != 0 || (((pExpr)->flags & (4)) != 0)) != (pExpr != 0 && (((pExpr)->flags & (4)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2230);
}

// ROR Label 2231
if((pExpr == 0) != (pExpr != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2231);
}

// MCC Label 2232
if(pExpr != 0 && ( ((pExpr)->flags & (4)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2232);
}
// MCC Label 2233
if(pExpr != 0 && ( !(((pExpr)->flags & (4)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2233);
}
// MCC Label 2234
if(!(pExpr != 0) && ( ((pExpr)->flags & (4)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2234);
}
// MCC Label 2235
if(!(pExpr != 0) && ( !(((pExpr)->flags & (4)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2235);
}
if( pExpr!=0 && ExprHasProperty(pExpr, EP_HasFunc) ){
    
// ABS Label 2236
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2236);
}
Vdbe *v = pParse->pVdbe;
    int addr;
    assert( v );
    addr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
    pParse->okConstFactor = 0;
    if( !pParse->db->mallocFailed ){
      
// ABS Label 2244
if(regDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2244);
}

// ROR Label 2245
if((regDest <= 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2245);
}
// ROR Label 2246
if((regDest > 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2246);
}
// ROR Label 2247
if((regDest >= 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2247);
}
if( regDest<0 ) { regDest = ++pParse->nMem;
}
      
// ABS Label 2241
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2241);
}

// ABS Label 2242
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2242);
}

// ABS Label 2243
if(regDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2243);
}
sqlite3ExprCode(pParse, pExpr, regDest);
    }
    pParse->okConstFactor = 1;
    
// ABS Label 2237
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2237);
}

// ABS Label 2238
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2238);
}
sqlite3ExprDelete(pParse->db, pExpr);
    
// ABS Label 2239
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2239);
}

// ABS Label 2240
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2240);
}
sqlite3VdbeJumpHere(v, addr);
  }else{
    p = sqlite3ExprListAppend(pParse, p, pExpr);
    
// ABS Label 2248
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2248);
}
if( p ){
       struct ExprList_item *pItem = &p->a[p->nExpr-1];
       pItem->reusable = regDest<0;
       
// ABS Label 2249
if(regDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2249);
}

// ROR Label 2250
if((regDest <= 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2250);
}
// ROR Label 2251
if((regDest > 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2251);
}
// ROR Label 2252
if((regDest >= 0) != (regDest < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2252);
}
if( regDest<0 ) { regDest = ++pParse->nMem;
}
       pItem->u.iConstExprReg = regDest;
    }
    pParse->pConstExpr = p;
  }
  
// ABS Label 2253
if(regDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2253);
}
return regDest;
}

/*
** Generate code to evaluate an expression and store the results
** into a register.  Return the register number where the results
** are stored.
**
** If the register is a temporary register that can be deallocated,
** then write its number into *pReg.  If the result register is not
** a temporary, then set *pReg to zero.
**
** If pExpr is a constant, then this routine might generate this
** code to fill the register in the initialization section of the
** VDBE program, in order to factor it out of the evaluation loop.
*/
int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){
  int r2;
  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
  if( ConstFactorOk(pParse)
   && ALWAYS(pExpr!=0)
   && pExpr->op!=TK_REGISTER
   && sqlite3ExprIsConstantNotJoin(pExpr)
  ){
    *pReg  = 0;
    r2 = sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);
  }else{
    int r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
    
// ABS Label 2254
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2254);
}
// ABS Label 2255
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2255);
}

// ROR Label 2256
if((r2 != r1) != (r2 == r1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2256);
}
if( r2==r1 ){
      *pReg = r1;
    }else{
      
// ABS Label 2257
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2257);
}

// ABS Label 2258
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2258);
}
sqlite3ReleaseTempReg(pParse, r1);
      *pReg = 0;
    }
  }
  
// ABS Label 2259
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2259);
}
return r2;
}

/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.
*/
void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){
  int inReg;

  assert( pExpr==0 || !ExprHasVVAProperty(pExpr,EP_Immutable) );
  assert( target>0 && target<=pParse->nMem );
  assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );
  
// ABS Label 2260
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2260);
}

// ROR Label 2261
if((pParse->pVdbe != 0) != (pParse->pVdbe == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2261);
}
if( pParse->pVdbe==0 ) { return;
}
  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
  
// ABS Label 2262
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2262);
}
// ABS Label 2263
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2263);
}

// ROR Label 2264
if((inReg == target) != (inReg != target))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2264);
}
if( inReg!=target ){
    u8 op;
    
// MCC Label 2268
if(( ((pExpr)->flags & (2097152)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2268);
}
// MCC Label 2269
if(( !(((pExpr)->flags & (2097152)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2269);
}
if( ExprHasProperty(pExpr,EP_Subquery) ){
      op = OP_Copy;
    }else{
      op = OP_SCopy;
    }
    
// ABS Label 2265
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2265);
}

// ABS Label 2266
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2266);
}

// ABS Label 2267
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2267);
}
sqlite3VdbeAddOp2(pParse->pVdbe, op, inReg, target);
  }
}

/*
** Make a transient copy of expression pExpr and then code it using
** sqlite3ExprCode().  This routine works just like sqlite3ExprCode()
** except that the input expression is guaranteed to be unchanged.
*/
void sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){
  
// ABS Label 2270
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2270);
}
sqlite3 *db = pParse->db;
  pExpr = sqlite3ExprDup(db, pExpr, 0);
  if( !db->mallocFailed ) { 
// ABS Label 2273
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2273);
}

// ABS Label 2274
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2274);
}

// ABS Label 2275
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2275);
}
sqlite3ExprCode(pParse, pExpr, target);
}
  
// ABS Label 2271
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2271);
}

// ABS Label 2272
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2272);
}
sqlite3ExprDelete(db, pExpr);
}

/*
** Generate code that will evaluate expression pExpr and store the
** results in register target.  The results are guaranteed to appear
** in register target.  If the expression is constant, then this routine
** might choose to code the expression at initialization time.
*/
void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){
  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){
    
// ABS Label 2276
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2276);
}

// ABS Label 2277
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2277);
}

// ABS Label 2278
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2278);
}
sqlite3ExprCodeRunJustOnce(pParse, pExpr, target);
  }else{
    
// ABS Label 2279
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2279);
}

// ABS Label 2280
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2280);
}

// ABS Label 2281
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2281);
}
sqlite3ExprCodeCopy(pParse, pExpr, target);
  }
}

/*
** Generate code that pushes the value of every element of the given
** expression list into a sequence of registers beginning at target.
**
** Return the number of elements evaluated.  The number returned will
** usually be pList->nExpr but might be reduced if SQLITE_ECEL_OMITREF
** is defined.
**
** The SQLITE_ECEL_DUP flag prevents the arguments from being
** filled using OP_SCopy.  OP_Copy must be used instead.
**
** The SQLITE_ECEL_FACTOR argument allows constant arguments to be
** factored out into initialization code.
**
** The SQLITE_ECEL_REF flag means that expressions in the list with
** ExprList.a[].u.x.iOrderByCol>0 have already been evaluated and stored
** in registers at srcReg, and so the value can be copied from there.
** If SQLITE_ECEL_OMITREF is also set, then the values with u.x.iOrderByCol>0
** are simply omitted rather than being copied from srcReg.
*/
int sqlite3ExprCodeExprList(
  Parse *pParse,     /* Parsing context */
  ExprList *pList,   /* The expression list to be coded */
  int target,        /* Where to write results */
  int srcReg,        /* Source registers if SQLITE_ECEL_REF */
  u8 flags           /* SQLITE_ECEL_* flags */
){
  struct ExprList_item *pItem;
  int i, j, n;
  u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;
  
// ABS Label 2282
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2282);
}
Vdbe *v = pParse->pVdbe;
  assert( pList!=0 );
  assert( target>0 );
  assert( pParse->pVdbe!=0 );  /* Never gets this far otherwise */
  n = pList->nExpr;
  if( !ConstFactorOk(pParse) ) { flags &= ~SQLITE_ECEL_FACTOR;
}
  pItem = pList->a , i = 0;

// ABS Label 2283
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2283);
}
// ABS Label 2284
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2284);
}

// ROR Label 2285
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2285);
}
// ROR Label 2286
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2286);
}
// ROR Label 2287
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2287);
}
for(; i<n; i++, pItem++){
    
// ABS Label 2293
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2293);
}
Expr *pExpr = pItem->pExpr;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
    if( pItem->bSorterRef ){
      i--;
      n--;
    }else
#endif
    if( (flags & SQLITE_ECEL_REF)!=0 && (j = pItem->u.x.iOrderByCol)>0 ){
      
// AOR Label 2294
if(flags | 8 != flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2294);
}
// AOR Label 2295
if(flags ^ 8 != flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2295);
}
if( flags & SQLITE_ECEL_OMITREF ){
        i--;
        n--;
      }else{
        
// ABS Label 2296
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2296);
}

// ABS Label 2297
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2297);
}
// ABS Label 2298
if(srcReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2298);
}

// AOR Label 2299
if(j + srcReg / 1 != j + srcReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2299);
}
// AOR Label 2300
if(j + srcReg + 1 != j + srcReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2300);
}
// AOR Label 2301
if(j + srcReg * 1 != j + srcReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2301);
}
// AOR Label 2302
if(j - srcReg != j + srcReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2302);
}
// AOR Label 2303
if(j / srcReg != j + srcReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2303);
}
// AOR Label 2304
if(j * srcReg != j + srcReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2304);
}

// ABS Label 2305
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2305);
}
// ABS Label 2306
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2306);
}

// AOR Label 2307
if(target - i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2307);
}
// AOR Label 2308
if(target / i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2308);
}
// AOR Label 2309
if(target * i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2309);
}
sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);
      }
    }else { if( (flags & SQLITE_ECEL_FACTOR)!=0
           && sqlite3ExprIsConstantNotJoin(pExpr)
    ){
      
// ABS Label 2310
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2310);
}

// ABS Label 2311
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2311);
}

// ABS Label 2312
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2312);
}
// ABS Label 2313
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2313);
}

// AOR Label 2314
if(target - i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2314);
}
// AOR Label 2315
if(target / i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2315);
}
// AOR Label 2316
if(target * i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2316);
}
sqlite3ExprCodeRunJustOnce(pParse, pExpr, target+i);
    }else{
      int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
      
// ABS Label 2317
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2317);
}
// ABS Label 2318
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2318);
}
// ABS Label 2319
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2319);
}

// AOR Label 2320
if(target - i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2320);
}
// AOR Label 2321
if(target / i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2321);
}
// AOR Label 2322
if(target * i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2322);
}

// ROR Label 2323
if((inReg == target + i) != (inReg != target + i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2323);
}
if( inReg!=target+i ){
        VdbeOp *pOp;
        if( copyOp==OP_Copy
         && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy
         && pOp->p1+pOp->p3+1==inReg
         && pOp->p2+pOp->p3+1==target+i
         && pOp->p5==0  /* The do-not-merge flag must be clear */
        ){
          pOp->p3++;
        }else{
          
// ABS Label 2324
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2324);
}

// ABS Label 2325
if(inReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2325);
}

// ABS Label 2326
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2326);
}
// ABS Label 2327
if(target < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2327);
}

// AOR Label 2328
if(target - i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2328);
}
// AOR Label 2329
if(target / i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2329);
}
// AOR Label 2330
if(target * i != target + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2330);
}
sqlite3VdbeAddOp2(v, copyOp, inReg, target+i);
        }
      }
    };}

  };
// ABS Label 2288
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2288);
}
// ABS Label 2289
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2289);
}

// ROR Label 2290
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2290);
}
// ROR Label 2291
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2291);
}
// ROR Label 2292
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2292);
}

  
// ABS Label 2331
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2331);
}
return n;
}

/*
** Generate code for a BETWEEN operator.
**
**    x BETWEEN y AND z
**
** The above is equivalent to 
**
**    x>=y AND x<=z
**
** Code it as such, taking care to do the common subexpression
** elimination of x.
**
** The xJumpIf parameter determines details:
**
**    NULL:                   Store the boolean result in reg[dest]
**    sqlite3ExprIfTrue:      Jump to dest if true
**    sqlite3ExprIfFalse:     Jump to dest if false
**
** The jumpIfNull parameter is ignored if xJumpIf is NULL.
*/
static void exprCodeBetween(
  Parse *pParse,    /* Parsing and code generating context */
  Expr *pExpr,      /* The BETWEEN expression */
  int dest,         /* Jump destination or storage location */
  void (*xJump)(Parse*,Expr*,int,int), /* Action to take */
  int jumpIfNull    /* Take the jump if the BETWEEN is NULL */
){
  Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */
  Expr compLeft;    /* The  x>=y  term */
  Expr compRight;   /* The  x<=z  term */
  int regFree1 = 0; /* Temporary use register */
  Expr *pDel = 0;
  
// ABS Label 2332
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2332);
}
sqlite3 *db = pParse->db;

  memset(&compLeft, 0, sizeof(Expr));
  memset(&compRight, 0, sizeof(Expr));
  memset(&exprAnd, 0, sizeof(Expr));

  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);
  
// ROR Label 2335
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2335);
}
if( db->mallocFailed==0 ){
    exprAnd.op = TK_AND;
    exprAnd.pLeft = &compLeft;
    exprAnd.pRight = &compRight;
    compLeft.op = TK_GE;
    compLeft.pLeft = pDel;
    compLeft.pRight = pExpr->x.pList->a[0].pExpr;
    compRight.op = TK_LE;
    compRight.pLeft = pDel;
    compRight.pRight = pExpr->x.pList->a[1].pExpr;
    
// ABS Label 2336
if(pDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2336);
}
exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
    
// ABS Label 2339
if(xJump < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2339);
}
if( xJump ){
      
// ABS Label 2340
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2340);
}

// ABS Label 2341
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2341);
}

// ABS Label 2342
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2342);
}
xJump(pParse, &exprAnd, dest, jumpIfNull);
    }else{
      /* Mark the expression is being from the ON or USING clause of a join
      ** so that the sqlite3ExprCodeTarget() routine will not attempt to move
      ** it into the Parse.pConstExpr list.  We should use a new bit for this,
      ** for clarity, but we are out of bits in the Expr.flags field so we
      ** have to reuse the EP_FromJoin bit.  Bummer. */
      pDel->flags |= EP_FromJoin;
      
// ABS Label 2343
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2343);
}

// ABS Label 2344
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2344);
}
sqlite3ExprCodeTarget(pParse, &exprAnd, dest);
    }
    
// ABS Label 2337
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2337);
}

// ABS Label 2338
if(regFree1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2338);
}
sqlite3ReleaseTempReg(pParse, regFree1);
  }
  
// ABS Label 2333
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2333);
}

// ABS Label 2334
if(pDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2334);
}
sqlite3ExprDelete(db, pDel);

  /* Ensure adequate test coverage */
  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1==0 );
  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull==0 && regFree1!=0 );
  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1==0 );
  testcase( xJump==sqlite3ExprIfTrue  && jumpIfNull!=0 && regFree1!=0 );
  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1==0 );
  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1!=0 );
  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1==0 );
  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1!=0 );
  testcase( xJump==0 );
}

/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is true but execution
** continues straight thru if the expression is false.
**
** If the expression evaluates to NULL (neither true nor false), then
** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.
**
** This code depends on the fact that certain token values (ex: TK_EQ)
** are the same as opcode values (ex: OP_Eq) that implement the corresponding
** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in
** the make process cause these values to align.  Assert()s in the code
** below verify that the numbers are aligned correctly.
*/
void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  
// ABS Label 2345
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2345);
}
Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
  
// MCC Label 2350
if(( v == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2350);
}
// MCC Label 2351
if(( !(v == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2351);
}
if( NEVER(v==0) ) {     return;  /* Existence of VDBE checked by caller */
}
  
// MCC Label 2352
if(( pExpr == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2352);
}
// MCC Label 2353
if(( !(pExpr == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2353);
}
if( NEVER(pExpr==0) ) { return;  /* No way this can happen */
}
  assert( !ExprHasVVAProperty(pExpr, EP_Immutable) );
  op = pExpr->op;
  switch( op ){
    case TK_AND:
    case TK_OR: {
      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
      
// ABS Label 2354
if(pAlt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2354);
}
// ABS Label 2355
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2355);
}

// ROR Label 2356
if((pAlt == pExpr) != (pAlt != pExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2356);
}
if( pAlt!=pExpr ){
        
// ABS Label 2357
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2357);
}

// ABS Label 2358
if(pAlt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2358);
}

// ABS Label 2359
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2359);
}

// ABS Label 2360
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2360);
}
sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);
      }else { 
// ABS Label 2361
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2361);
}

// ROR Label 2362
if((op != 44) != (op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2362);
}
if( op==TK_AND ){
        int d2 = sqlite3VdbeMakeLabel(pParse);
        testcase( jumpIfNull==0 );
        
// ABS Label 2363
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2363);
}

// ABS Label 2364
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2364);
}

// ABS Label 2365
if(d2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2365);
}

// ABS Label 2366
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2366);
}

// AOR Label 2367
if(jumpIfNull | 16 != jumpIfNull ^ 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2367);
}
// AOR Label 2368
if(jumpIfNull & 16 != jumpIfNull ^ 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2368);
}
sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,
                           jumpIfNull^SQLITE_JUMPIFNULL);
        
// ABS Label 2369
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2369);
}

// ABS Label 2370
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2370);
}

// ABS Label 2371
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2371);
}

// ABS Label 2372
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2372);
}
sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
        
// ABS Label 2373
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2373);
}

// ABS Label 2374
if(d2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2374);
}
sqlite3VdbeResolveLabel(v, d2);
      }else{
        testcase( jumpIfNull==0 );
        
// ABS Label 2375
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2375);
}

// ABS Label 2376
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2376);
}

// ABS Label 2377
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2377);
}

// ABS Label 2378
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2378);
}
sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
        
// ABS Label 2379
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2379);
}

// ABS Label 2380
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2380);
}

// ABS Label 2381
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2381);
}

// ABS Label 2382
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2382);
}
sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
      };}

      break;
    }
    case TK_NOT: {
      testcase( jumpIfNull==0 );
      
// ABS Label 2383
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2383);
}

// ABS Label 2384
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2384);
}

// ABS Label 2385
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2385);
}

// ABS Label 2386
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2386);
}
sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case TK_TRUTH: {
      int isNot;      /* IS NOT TRUE or IS NOT FALSE */
      int isTrue;     /* IS TRUE or IS NOT TRUE */
      testcase( jumpIfNull==0 );
      isNot = pExpr->op2==TK_ISNOT;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      testcase( isTrue && isNot );
      testcase( !isTrue && isNot );
      
// ABS Label 2387
if(isNot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2387);
}
// ABS Label 2388
if(isTrue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2388);
}

// AOR Label 2389
if(isTrue | isNot != isTrue ^ isNot)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2389);
}
// AOR Label 2390
if(isTrue & isNot != isTrue ^ isNot)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2390);
}
if( isTrue ^ isNot ){
        
// ABS Label 2391
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2391);
}

// ABS Label 2392
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2392);
}

// ABS Label 2393
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2393);
}
sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
                          isNot ? SQLITE_JUMPIFNULL : 0);
      }else{
        
// ABS Label 2394
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2394);
}

// ABS Label 2395
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2395);
}

// ABS Label 2396
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2396);
}
sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
                           isNot ? SQLITE_JUMPIFNULL : 0);
      }
      break;
    }
    case TK_IS:
    case TK_ISNOT:
      testcase( op==TK_IS );
      testcase( op==TK_ISNOT );
      op = (op==TK_IS) ? TK_EQ : TK_NE;
      jumpIfNull = SQLITE_NULLEQ;
      /* no break */ deliberate_fall_through
    case TK_LT:
    case TK_LE:
    case TK_GT:
    case TK_GE:
    case TK_NE:
    case TK_EQ: {
      if( sqlite3ExprIsVector(pExpr->pLeft) ) { goto default_expr;
}
      testcase( jumpIfNull==0 );
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      
// ABS Label 2397
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2397);
}

// ABS Label 2398
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2398);
}

// ABS Label 2399
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2399);
}

// ABS Label 2400
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2400);
}

// ABS Label 2401
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2401);
}

// ABS Label 2402
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2402);
}

// ABS Label 2403
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2403);
}

// ABS Label 2404
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2404);
}
codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull, ExprHasProperty(pExpr,EP_Commuted));
      assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);
      assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);
      assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);
      assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);
      assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);
      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);
      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);
      assert(TK_NE==OP_Ne); testcase(op==OP_Ne);
      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);
      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);
      testcase( regFree1==0 );
      testcase( regFree2==0 );
      break;
    }
    case TK_ISNULL:
    case TK_NOTNULL: {
      assert( TK_ISNULL==OP_IsNull );   testcase( op==TK_ISNULL );
      assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      
// ABS Label 2405
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2405);
}

// ABS Label 2406
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2406);
}

// ABS Label 2407
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2407);
}

// ABS Label 2408
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2408);
}
sqlite3VdbeAddOp2(v, op, r1, dest);
      VdbeCoverageIf(v, op==TK_ISNULL);
      VdbeCoverageIf(v, op==TK_NOTNULL);
      testcase( regFree1==0 );
      break;
    }
    case TK_BETWEEN: {
      testcase( jumpIfNull==0 );
      
// ABS Label 2409
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2409);
}

// ABS Label 2410
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2410);
}

// ABS Label 2411
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2411);
}

// ABS Label 2412
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2412);
}
exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);
      break;
    }
#ifndef SQLITE_OMIT_SUBQUERY
    case TK_IN: {
      int destIfFalse = sqlite3VdbeMakeLabel(pParse);
      int destIfNull = jumpIfNull ? dest : destIfFalse;
      
// ABS Label 2413
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2413);
}

// ABS Label 2414
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2414);
}

// ABS Label 2415
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2415);
}

// ABS Label 2416
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2416);
}
sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      
// ABS Label 2417
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2417);
}

// ABS Label 2418
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2418);
}
sqlite3VdbeGoto(v, dest);
      
// ABS Label 2419
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2419);
}

// ABS Label 2420
if(destIfFalse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2420);
}
sqlite3VdbeResolveLabel(v, destIfFalse);
      break;
    }
#endif
    default: {
    default_expr:
      
// MCC Label 2421
if(( ((pExpr)->flags & (1 | 268435456)) == 268435456 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2421);
}
// MCC Label 2422
if(( !(((pExpr)->flags & (1 | 268435456)) == 268435456) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2422);
}
if( ExprAlwaysTrue(pExpr) ){
        
// ABS Label 2423
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2423);
}

// ABS Label 2424
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2424);
}
sqlite3VdbeGoto(v, dest);
      }else { 
// MCC Label 2425
if(( ((pExpr)->flags & (1 | 536870912)) == 536870912 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2425);
}
// MCC Label 2426
if(( !(((pExpr)->flags & (1 | 536870912)) == 536870912) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2426);
}
if( ExprAlwaysFalse(pExpr) ){
        /* No-op */
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
        
// ABS Label 2427
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2427);
}

// ABS Label 2428
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2428);
}

// ABS Label 2429
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2429);
}

// ABS Label 2430
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2430);
}

// ROR Label 2431
if((jumpIfNull == 0) != (jumpIfNull != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2431);
}
sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0);
        VdbeCoverage(v);
        testcase( regFree1==0 );
        testcase( jumpIfNull==0 );
      };}

      break;
    }
  }
  
// ABS Label 2346
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2346);
}

// ABS Label 2347
if(regFree1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2347);
}
sqlite3ReleaseTempReg(pParse, regFree1);
  
// ABS Label 2348
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2348);
}

// ABS Label 2349
if(regFree2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2349);
}
sqlite3ReleaseTempReg(pParse, regFree2);  
}

/*
** Generate code for a boolean expression such that a jump is made
** to the label "dest" if the expression is false but execution
** continues straight thru if the expression is true.
**
** If the expression evaluates to NULL (neither true nor false) then
** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull
** is 0.
*/
void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  
// ABS Label 2432
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2432);
}
Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );
  
// MCC Label 2437
if(( v == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2437);
}
// MCC Label 2438
if(( !(v == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2438);
}
if( NEVER(v==0) ) { return; /* Existence of VDBE checked by caller */
}
  
// ABS Label 2439
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2439);
}

// ROR Label 2440
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2440);
}
if( pExpr==0 ) {    return;
}
  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );

  /* The value of pExpr->op and op are related as follows:
  **
  **       pExpr->op            op
  **       ---------          ----------
  **       TK_ISNULL          OP_NotNull
  **       TK_NOTNULL         OP_IsNull
  **       TK_NE              OP_Eq
  **       TK_EQ              OP_Ne
  **       TK_GT              OP_Le
  **       TK_LE              OP_Gt
  **       TK_GE              OP_Lt
  **       TK_LT              OP_Ge
  **
  ** For other values of pExpr->op, op is undefined and unused.
  ** The value of TK_ and OP_ constants are arranged such that we
  ** can compute the mapping above using the following expression.
  ** Assert()s verify that the computation is correct.
  */
  op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1);

  /* Verify correct alignment of TK_ and OP_ constants
  */
  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );
  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );
  assert( pExpr->op!=TK_NE || op==OP_Eq );
  assert( pExpr->op!=TK_EQ || op==OP_Ne );
  assert( pExpr->op!=TK_LT || op==OP_Ge );
  assert( pExpr->op!=TK_LE || op==OP_Gt );
  assert( pExpr->op!=TK_GT || op==OP_Le );
  assert( pExpr->op!=TK_GE || op==OP_Lt );

  switch( pExpr->op ){
    case TK_AND:
    case TK_OR: {
      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
      
// ABS Label 2441
if(pAlt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2441);
}
// ABS Label 2442
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2442);
}

// ROR Label 2443
if((pAlt == pExpr) != (pAlt != pExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2443);
}
if( pAlt!=pExpr ){
        
// ABS Label 2444
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2444);
}

// ABS Label 2445
if(pAlt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2445);
}

// ABS Label 2446
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2446);
}

// ABS Label 2447
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2447);
}
sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);
      }else { 
// ROR Label 2448
if((pExpr->op != 44) != (pExpr->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2448);
}
if( pExpr->op==TK_AND ){
        testcase( jumpIfNull==0 );
        
// ABS Label 2449
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2449);
}

// ABS Label 2450
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2450);
}

// ABS Label 2451
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2451);
}

// ABS Label 2452
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2452);
}
sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
        
// ABS Label 2453
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2453);
}

// ABS Label 2454
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2454);
}

// ABS Label 2455
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2455);
}

// ABS Label 2456
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2456);
}
sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
      }else{
        int d2 = sqlite3VdbeMakeLabel(pParse);
        testcase( jumpIfNull==0 );
        
// ABS Label 2457
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2457);
}

// ABS Label 2458
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2458);
}

// ABS Label 2459
if(d2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2459);
}

// ABS Label 2460
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2460);
}

// AOR Label 2461
if(jumpIfNull | 16 != jumpIfNull ^ 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2461);
}
// AOR Label 2462
if(jumpIfNull & 16 != jumpIfNull ^ 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2462);
}
sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2,
                          jumpIfNull^SQLITE_JUMPIFNULL);
        
// ABS Label 2463
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2463);
}

// ABS Label 2464
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2464);
}

// ABS Label 2465
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2465);
}

// ABS Label 2466
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2466);
}
sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
        
// ABS Label 2467
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2467);
}

// ABS Label 2468
if(d2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2468);
}
sqlite3VdbeResolveLabel(v, d2);
      };}

      break;
    }
    case TK_NOT: {
      testcase( jumpIfNull==0 );
      
// ABS Label 2469
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2469);
}

// ABS Label 2470
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2470);
}

// ABS Label 2471
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2471);
}

// ABS Label 2472
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2472);
}
sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case TK_TRUTH: {
      int isNot;   /* IS NOT TRUE or IS NOT FALSE */
      int isTrue;  /* IS TRUE or IS NOT TRUE */
      testcase( jumpIfNull==0 );
      isNot = pExpr->op2==TK_ISNOT;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      testcase( isTrue && isNot );
      testcase( !isTrue && isNot );
      
// ABS Label 2473
if(isNot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2473);
}
// ABS Label 2474
if(isTrue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2474);
}

// AOR Label 2475
if(isTrue | isNot != isTrue ^ isNot)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2475);
}
// AOR Label 2476
if(isTrue & isNot != isTrue ^ isNot)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2476);
}
if( isTrue ^ isNot ){
        /* IS TRUE and IS NOT FALSE */
        
// ABS Label 2477
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2477);
}

// ABS Label 2478
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2478);
}

// ABS Label 2479
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2479);
}
sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
                           isNot ? 0 : SQLITE_JUMPIFNULL);

      }else{
        /* IS FALSE and IS NOT TRUE */
        
// ABS Label 2480
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2480);
}

// ABS Label 2481
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2481);
}

// ABS Label 2482
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2482);
}
sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
                          isNot ? 0 : SQLITE_JUMPIFNULL);
      }
      break;
    }
    case TK_IS:
    case TK_ISNOT:
      testcase( pExpr->op==TK_IS );
      testcase( pExpr->op==TK_ISNOT );
      op = (pExpr->op==TK_IS) ? TK_NE : TK_EQ;
      jumpIfNull = SQLITE_NULLEQ;
      /* no break */ deliberate_fall_through
    case TK_LT:
    case TK_LE:
    case TK_GT:
    case TK_GE:
    case TK_NE:
    case TK_EQ: {
      if( sqlite3ExprIsVector(pExpr->pLeft) ) { goto default_expr;
}
      testcase( jumpIfNull==0 );
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      
// ABS Label 2483
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2483);
}

// ABS Label 2484
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2484);
}

// ABS Label 2485
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2485);
}

// ABS Label 2486
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2486);
}

// ABS Label 2487
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2487);
}

// ABS Label 2488
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2488);
}

// ABS Label 2489
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2489);
}

// ABS Label 2490
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2490);
}
codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull,ExprHasProperty(pExpr,EP_Commuted));
      assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);
      assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);
      assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);
      assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);
      assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);
      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);
      VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);
      assert(TK_NE==OP_Ne); testcase(op==OP_Ne);
      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);
      VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);
      testcase( regFree1==0 );
      testcase( regFree2==0 );
      break;
    }
    case TK_ISNULL:
    case TK_NOTNULL: {
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      
// ABS Label 2491
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2491);
}

// ABS Label 2492
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2492);
}

// ABS Label 2493
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2493);
}

// ABS Label 2494
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2494);
}
sqlite3VdbeAddOp2(v, op, r1, dest);
      testcase( op==TK_ISNULL );   VdbeCoverageIf(v, op==TK_ISNULL);
      testcase( op==TK_NOTNULL );  VdbeCoverageIf(v, op==TK_NOTNULL);
      testcase( regFree1==0 );
      break;
    }
    case TK_BETWEEN: {
      testcase( jumpIfNull==0 );
      
// ABS Label 2495
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2495);
}

// ABS Label 2496
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2496);
}

// ABS Label 2497
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2497);
}

// ABS Label 2498
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2498);
}
exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);
      break;
    }
#ifndef SQLITE_OMIT_SUBQUERY
    case TK_IN: {
      
// ABS Label 2499
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2499);
}
if( jumpIfNull ){
        
// ABS Label 2500
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2500);
}

// ABS Label 2501
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2501);
}

// ABS Label 2502
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2502);
}

// ABS Label 2503
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2503);
}
sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
      }else{
        int destIfNull = sqlite3VdbeMakeLabel(pParse);
        
// ABS Label 2504
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2504);
}

// ABS Label 2505
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2505);
}

// ABS Label 2506
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2506);
}

// ABS Label 2507
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2507);
}
sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
        
// ABS Label 2508
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2508);
}

// ABS Label 2509
if(destIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2509);
}
sqlite3VdbeResolveLabel(v, destIfNull);
      }
      break;
    }
#endif
    default: {
    default_expr: 
      
// MCC Label 2510
if(( ((pExpr)->flags & (1 | 536870912)) == 536870912 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2510);
}
// MCC Label 2511
if(( !(((pExpr)->flags & (1 | 536870912)) == 536870912) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2511);
}
if( ExprAlwaysFalse(pExpr) ){
        
// ABS Label 2512
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2512);
}

// ABS Label 2513
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2513);
}
sqlite3VdbeGoto(v, dest);
      }else { 
// MCC Label 2514
if(( ((pExpr)->flags & (1 | 268435456)) == 268435456 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2514);
}
// MCC Label 2515
if(( !(((pExpr)->flags & (1 | 268435456)) == 268435456) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2515);
}
if( ExprAlwaysTrue(pExpr) ){
        /* no-op */
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
        
// ABS Label 2516
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2516);
}

// ABS Label 2517
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2517);
}

// ABS Label 2518
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2518);
}

// ABS Label 2519
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2519);
}

// ROR Label 2520
if((jumpIfNull == 0) != (jumpIfNull != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2520);
}
sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0);
        VdbeCoverage(v);
        testcase( regFree1==0 );
        testcase( jumpIfNull==0 );
      };}

      break;
    }
  }
  
// ABS Label 2433
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2433);
}

// ABS Label 2434
if(regFree1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2434);
}
sqlite3ReleaseTempReg(pParse, regFree1);
  
// ABS Label 2435
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2435);
}

// ABS Label 2436
if(regFree2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2436);
}
sqlite3ReleaseTempReg(pParse, regFree2);
}

/*
** Like sqlite3ExprIfFalse() except that a copy is made of pExpr before
** code generation, and that copy is deleted after code generation. This
** ensures that the original pExpr is unchanged.
*/
void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){
  
// ABS Label 2521
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2521);
}
sqlite3 *db = pParse->db;
  Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);
  
// ROR Label 2524
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2524);
}
if( db->mallocFailed==0 ){
    
// ABS Label 2525
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2525);
}

// ABS Label 2526
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2526);
}

// ABS Label 2527
if(dest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2527);
}

// ABS Label 2528
if(jumpIfNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2528);
}
sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);
  }
  
// ABS Label 2522
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2522);
}

// ABS Label 2523
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2523);
}
sqlite3ExprDelete(db, pCopy);
}

/*
** Expression pVar is guaranteed to be an SQL variable. pExpr may be any
** type of expression.
**
** If pExpr is a simple SQL value - an integer, real, string, blob
** or NULL value - then the VDBE currently being prepared is configured
** to re-prepare each time a new value is bound to variable pVar.
**
** Additionally, if pExpr is a simple SQL value and the value is the
** same as that currently bound to variable pVar, non-zero is returned.
** Otherwise, if the values are not the same or if pExpr is not a simple
** SQL value, zero is returned.
*/
static int exprCompareVariable(Parse *pParse, Expr *pVar, Expr *pExpr){
  int res = 0;
  int iVar;
  sqlite3_value *pL, *pR = 0;
  
  
// ABS Label 2529
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2529);
}

// ABS Label 2530
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2530);
}
sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);
  
// ABS Label 2531
if(pR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2531);
}
if( pR ){
    iVar = pVar->iColumn;
    
// ABS Label 2532
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2532);
}

// ABS Label 2533
if(iVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2533);
}
sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);
    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, SQLITE_AFF_BLOB);
    
// ABS Label 2536
if(pL < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2536);
}
if( pL ){
      if( sqlite3_value_type(pL)==SQLITE_TEXT ){
        
// ABS Label 2537
if(pL < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2537);
}
sqlite3_value_text(pL); /* Make sure the encoding is UTF-8 */
      }
      res =  0==sqlite3MemCompare(pL, pR, 0);
    }
    
// ABS Label 2534
if(pR < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2534);
}
sqlite3ValueFree(pR);
    
// ABS Label 2535
if(pL < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2535);
}
sqlite3ValueFree(pL);
  }

  
// ABS Label 2538
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2538);
}
return res;
}

/*
** Do a deep comparison of two expression trees.  Return 0 if the two
** expressions are completely identical.  Return 1 if they differ only
** by a COLLATE operator at the top level.  Return 2 if there are differences
** other than the top-level COLLATE operator.
**
** If any subelement of pB has Expr.iTable==(-1) then it is allowed
** to compare equal to an equivalent element in pA with Expr.iTable==iTab.
**
** The pA side might be using TK_REGISTER.  If that is the case and pB is
** not using TK_REGISTER but is otherwise equivalent, then still return 0.
**
** Sometimes this routine will return 2 even if the two expressions
** really are equivalent.  If we cannot prove that the expressions are
** identical, we return 2 just to be safe.  So if this routine
** returns 2, then you do not really know for certain if the two
** expressions are the same.  But if you get a 0 or 1 return, then you
** can be sure the expressions are the same.  In the places where
** this routine is used, it does not hurt to get an extra 2 - that
** just might result in some slightly slower code.  But returning
** an incorrect 0 or 1 could lead to a malfunction.
**
** If pParse is not NULL then TK_VARIABLE terms in pA with bindings in
** pParse->pReprepare can be matched against literals in pB.  The 
** pParse->pVdbe->expmask bitmask is updated for each variable referenced.
** If pParse is NULL (the normal case) then any TK_VARIABLE term in 
** Argument pParse should normally be NULL. If it is not NULL and pA or
** pB causes a return value of 2.
*/
int sqlite3ExprCompare(Parse *pParse, Expr *pA, Expr *pB, int iTab){
  u32 combinedFlags;
  
// ABS Label 2539
if(pA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2539);
}
// ABS Label 2540
if(pB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2540);
}

// COR Label 2541
if((pA == 0 && pB == 0) != (pA == 0 || pB == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2541);
}

// ROR Label 2542
if((pA != 0) != (pA == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2542);
}
// ROR Label 2543
if((pB != 0) != (pB == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2543);
}

// MCC Label 2544
if(pA == 0 && pB == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2544);
}
// MCC Label 2545
if(pA == 0 && !(pB == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2545);
}
// MCC Label 2546
if(!(pA == 0) && pB == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2546);
}
// MCC Label 2547
if(!(pA == 0) && !(pB == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2547);
}
if( pA==0 || pB==0 ){
    return pB==pA ? 0 : 2;
  }
  if( pParse && pA->op==TK_VARIABLE && exprCompareVariable(pParse, pA, pB) ){
    return 0;
  }
  combinedFlags = pA->flags | pB->flags;
  
// ABS Label 2548
if(combinedFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2548);
}

// AOR Label 2549
if(combinedFlags | 1024 != combinedFlags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2549);
}
// AOR Label 2550
if(combinedFlags ^ 1024 != combinedFlags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2550);
}
if( combinedFlags & EP_IntValue ){
    
// ABS Label 2551
if(pA->u.iValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2551);
}
// ABS Label 2552
if(pB->u.iValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2552);
}

// COR Label 2553
if(((pA->flags & pB->flags & 1024) != 0 || pA->u.iValue == pB->u.iValue) != ((pA->flags & pB->flags & 1024) != 0 && pA->u.iValue == pB->u.iValue))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2553);
}

// ROR Label 2554
if(((pA->flags & pB->flags & 1024) == 0) != ((pA->flags & pB->flags & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2554);
}
// ROR Label 2555
if((pA->u.iValue != pB->u.iValue) != (pA->u.iValue == pB->u.iValue))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2555);
}

// MCC Label 2556
if((pA->flags & pB->flags & 1024) != 0 && pA->u.iValue == pB->u.iValue ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2556);
}
// MCC Label 2557
if((pA->flags & pB->flags & 1024) != 0 && !(pA->u.iValue == pB->u.iValue) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2557);
}
// MCC Label 2558
if(!((pA->flags & pB->flags & 1024) != 0) && pA->u.iValue == pB->u.iValue ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2558);
}
// MCC Label 2559
if(!((pA->flags & pB->flags & 1024) != 0) && !(pA->u.iValue == pB->u.iValue) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2559);
}
if( (pA->flags&pB->flags&EP_IntValue)!=0 && pA->u.iValue==pB->u.iValue ){
      return 0;
    }
    return 2;
  }
  
// COR Label 2560
if((pA->op != pB->op && pA->op == 71) != (pA->op != pB->op || pA->op == 71))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2560);
}

// ROR Label 2561
if((pA->op == pB->op) != (pA->op != pB->op))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2561);
}
// ROR Label 2562
if((pA->op != 71) != (pA->op == 71))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2562);
}

// MCC Label 2563
if(pA->op != pB->op && pA->op == 71 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2563);
}
// MCC Label 2564
if(pA->op != pB->op && !(pA->op == 71) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2564);
}
// MCC Label 2565
if(!(pA->op != pB->op) && pA->op == 71 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2565);
}
// MCC Label 2566
if(!(pA->op != pB->op) && !(pA->op == 71) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2566);
}
if( pA->op!=pB->op || pA->op==TK_RAISE ){
    if( pA->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){
      return 1;
    }
    if( pB->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){
      return 1;
    }
    return 2;
  }
  
// ABS Label 2567
if(pA->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2567);
}

// COR Label 2568
if((pA->op != 166 && pA->op != 168 || pA->u.zToken) != (pA->op != 166 && pA->op != 168 && pA->u.zToken))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2568);
}
// COR Label 2569
if((pA->op != 166 || pA->op != 168) != (pA->op != 166 && pA->op != 168))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2569);
}

// ROR Label 2570
if((pA->op == 166) != (pA->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2570);
}
// ROR Label 2571
if((pA->op == 168) != (pA->op != 168))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2571);
}

// MCC Label 2572
if(pA->op != 166 && pA->op != 168 && pA->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2572);
}
// MCC Label 2573
if(pA->op != 166 && pA->op != 168 && !(pA->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2573);
}
// MCC Label 2574
if(pA->op != 166 && !(pA->op != 168) && pA->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2574);
}
// MCC Label 2575
if(pA->op != 166 && !(pA->op != 168) && !(pA->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2575);
}
// MCC Label 2576
if(!(pA->op != 166) && pA->op != 168 && pA->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2576);
}
// MCC Label 2577
if(!(pA->op != 166) && pA->op != 168 && !(pA->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2577);
}
// MCC Label 2578
if(!(pA->op != 166) && !(pA->op != 168) && pA->u.zToken ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2578);
}
// MCC Label 2579
if(!(pA->op != 166) && !(pA->op != 168) && !(pA->u.zToken) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2579);
}
if( pA->op!=TK_COLUMN && pA->op!=TK_AGG_COLUMN && pA->u.zToken ){
    
// COR Label 2580
if((pA->op == 171 && pA->op == 167) != (pA->op == 171 || pA->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2580);
}

// ROR Label 2581
if((pA->op != 171) != (pA->op == 171))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2581);
}
// ROR Label 2582
if((pA->op != 167) != (pA->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2582);
}

// MCC Label 2583
if(pA->op == 171 && pA->op == 167 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2583);
}
// MCC Label 2584
if(pA->op == 171 && !(pA->op == 167) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2584);
}
// MCC Label 2585
if(!(pA->op == 171) && pA->op == 167 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2585);
}
// MCC Label 2586
if(!(pA->op == 171) && !(pA->op == 167) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2586);
}
if( pA->op==TK_FUNCTION || pA->op==TK_AGG_FUNCTION ){
      if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) { return 2;
}
#ifndef SQLITE_OMIT_WINDOWFUNC
      assert( pA->op==pB->op );
      
// ROR Label 2587
if(((((pA)->flags & (16777216)) != 0) == (((pB)->flags & (16777216)) != 0)) != ((((pA)->flags & (16777216)) != 0) != (((pB)->flags & (16777216)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2587);
}
if( ExprHasProperty(pA,EP_WinFunc)!=ExprHasProperty(pB,EP_WinFunc) ){
        return 2;
      }
      
// MCC Label 2588
if(( ((pA)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2588);
}
// MCC Label 2589
if(( !(((pA)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2589);
}
if( ExprHasProperty(pA,EP_WinFunc) ){
        if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){
          return 2;
        }
      }
#endif
    }else { 
// ROR Label 2590
if((pA->op != 120) != (pA->op == 120))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2590);
}
if( pA->op==TK_NULL ){
      return 0;
    }else { 
// ROR Label 2591
if((pA->op != 112) != (pA->op == 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2591);
}
if( pA->op==TK_COLLATE ){
      if( sqlite3_stricmp(pA->u.zToken,pB->u.zToken)!=0 ) { return 2;
}
    }else { 
// MCC Label 2592
if(( pB->u.zToken != 0 ) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2592);
}
// MCC Label 2593
if(( !(pB->u.zToken != 0) ) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2593);
}
if( ALWAYS(pB->u.zToken!=0) && strcmp(pA->u.zToken,pB->u.zToken)!=0 ){
      return 2;
    };}
;}
;}

  }
  
// ROR Label 2594
if(((pA->flags & (2 | 512)) == (pB->flags & (2 | 512))) != ((pA->flags & (2 | 512)) != (pB->flags & (2 | 512))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2594);
}
if( (pA->flags & (EP_Distinct|EP_Commuted))
     != (pB->flags & (EP_Distinct|EP_Commuted)) ) { return 2;
}
  
// MCC Label 2595
if(( (combinedFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2595);
}
// MCC Label 2596
if(( !((combinedFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2596);
}
if( ALWAYS((combinedFlags & EP_TokenOnly)==0) ){
    
// ABS Label 2597
if(combinedFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2597);
}

// AOR Label 2598
if(combinedFlags | 2048 != combinedFlags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2598);
}
// AOR Label 2599
if(combinedFlags ^ 2048 != combinedFlags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2599);
}
if( combinedFlags & EP_xIsSelect ) { return 2;
}
    if( (combinedFlags & EP_FixedCol)==0
     && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) { return 2;
}
    if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) { return 2;
}
    if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) { return 2;
}
    
// COR Label 2600
if((pA->op != 116 && pA->op != 169 || ((combinedFlags & 8192) == 0)) != (pA->op != 116 && pA->op != 169 && ((combinedFlags & 8192) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2600);
}
// COR Label 2601
if((pA->op != 116 || pA->op != 169) != (pA->op != 116 && pA->op != 169))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2601);
}

// ROR Label 2602
if((pA->op == 116) != (pA->op != 116))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2602);
}
// ROR Label 2603
if((pA->op == 169) != (pA->op != 169))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2603);
}

// MCC Label 2604
if(pA->op != 116 && pA->op != 169 && ( (combinedFlags & 8192) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2604);
}
// MCC Label 2605
if(pA->op != 116 && pA->op != 169 && ( !((combinedFlags & 8192) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2605);
}
// MCC Label 2606
if(pA->op != 116 && !(pA->op != 169) && ( (combinedFlags & 8192) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2606);
}
// MCC Label 2607
if(pA->op != 116 && !(pA->op != 169) && ( !((combinedFlags & 8192) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2607);
}
// MCC Label 2608
if(!(pA->op != 116) && pA->op != 169 && ( (combinedFlags & 8192) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2608);
}
// MCC Label 2609
if(!(pA->op != 116) && pA->op != 169 && ( !((combinedFlags & 8192) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2609);
}
// MCC Label 2610
if(!(pA->op != 116) && !(pA->op != 169) && ( (combinedFlags & 8192) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2610);
}
// MCC Label 2611
if(!(pA->op != 116) && !(pA->op != 169) && ( !((combinedFlags & 8192) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2611);
}
if( pA->op!=TK_STRING
     && pA->op!=TK_TRUEFALSE
     && ALWAYS((combinedFlags & EP_Reduced)==0)
    ){
      
// ROR Label 2612
if((pA->iColumn == pB->iColumn) != (pA->iColumn != pB->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2612);
}
if( pA->iColumn!=pB->iColumn ) { return 2;
}
      
// COR Label 2613
if((pA->op2 != pB->op2 || pA->op == 174) != (pA->op2 != pB->op2 && pA->op == 174))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2613);
}

// ROR Label 2614
if((pA->op2 == pB->op2) != (pA->op2 != pB->op2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2614);
}
// ROR Label 2615
if((pA->op != 174) != (pA->op == 174))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2615);
}

// MCC Label 2616
if(pA->op2 != pB->op2 && pA->op == 174 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2616);
}
// MCC Label 2617
if(pA->op2 != pB->op2 && !(pA->op == 174) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2617);
}
// MCC Label 2618
if(!(pA->op2 != pB->op2) && pA->op == 174 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2618);
}
// MCC Label 2619
if(!(pA->op2 != pB->op2) && !(pA->op == 174) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2619);
}
if( pA->op2!=pB->op2 && pA->op==TK_TRUTH ) { return 2;
}
      
// ABS Label 2620
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2620);
}
// ABS Label 2621
if(pA->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2621);
}
// ABS Label 2622
if(pB->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2622);
}

// COR Label 2623
if((pA->op != 49 && pA->iTable != pB->iTable || pA->iTable != iTab) != (pA->op != 49 && pA->iTable != pB->iTable && pA->iTable != iTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2623);
}
// COR Label 2624
if((pA->op != 49 || pA->iTable != pB->iTable) != (pA->op != 49 && pA->iTable != pB->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2624);
}

// ROR Label 2625
if((pA->op == 49) != (pA->op != 49))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2625);
}
// ROR Label 2626
if((pA->iTable == pB->iTable) != (pA->iTable != pB->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2626);
}
// ROR Label 2627
if((pA->iTable == iTab) != (pA->iTable != iTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2627);
}

// MCC Label 2628
if(pA->op != 49 && pA->iTable != pB->iTable && pA->iTable != iTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2628);
}
// MCC Label 2629
if(pA->op != 49 && pA->iTable != pB->iTable && !(pA->iTable != iTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2629);
}
// MCC Label 2630
if(pA->op != 49 && !(pA->iTable != pB->iTable) && pA->iTable != iTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2630);
}
// MCC Label 2631
if(pA->op != 49 && !(pA->iTable != pB->iTable) && !(pA->iTable != iTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2631);
}
// MCC Label 2632
if(!(pA->op != 49) && pA->iTable != pB->iTable && pA->iTable != iTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2632);
}
// MCC Label 2633
if(!(pA->op != 49) && pA->iTable != pB->iTable && !(pA->iTable != iTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2633);
}
// MCC Label 2634
if(!(pA->op != 49) && !(pA->iTable != pB->iTable) && pA->iTable != iTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2634);
}
// MCC Label 2635
if(!(pA->op != 49) && !(pA->iTable != pB->iTable) && !(pA->iTable != iTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2635);
}
if( pA->op!=TK_IN && pA->iTable!=pB->iTable && pA->iTable!=iTab ){
        return 2;
      }
    }
  }
  return 0;
}

/*
** Compare two ExprList objects.  Return 0 if they are identical, 1
** if they are certainly different, or 2 if it is not possible to 
** determine if they are identical or not.
**
** If any subelement of pB has Expr.iTable==(-1) then it is allowed
** to compare equal to an equivalent element in pA with Expr.iTable==iTab.
**
** This routine might return non-zero for equivalent ExprLists.  The
** only consequence will be disabled optimizations.  But this routine
** must never return 0 if the two ExprList objects are different, or
** a malfunction will result.
**
** Two NULL pointers are considered to be the same.  But a NULL pointer
** always differs from a non-NULL pointer.
*/
int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  
// ABS Label 2636
if(pA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2636);
}
// ABS Label 2637
if(pB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2637);
}

// COR Label 2638
if((pA == 0 || pB == 0) != (pA == 0 && pB == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2638);
}

// ROR Label 2639
if((pA != 0) != (pA == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2639);
}
// ROR Label 2640
if((pB != 0) != (pB == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2640);
}

// MCC Label 2641
if(pA == 0 && pB == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2641);
}
// MCC Label 2642
if(pA == 0 && !(pB == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2642);
}
// MCC Label 2643
if(!(pA == 0) && pB == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2643);
}
// MCC Label 2644
if(!(pA == 0) && !(pB == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2644);
}
if( pA==0 && pB==0 ) { return 0;
}
  
// ABS Label 2645
if(pA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2645);
}
// ABS Label 2646
if(pB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2646);
}

// COR Label 2647
if((pA == 0 && pB == 0) != (pA == 0 || pB == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2647);
}

// ROR Label 2648
if((pA != 0) != (pA == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2648);
}
// ROR Label 2649
if((pB != 0) != (pB == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2649);
}

// MCC Label 2650
if(pA == 0 && pB == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2650);
}
// MCC Label 2651
if(pA == 0 && !(pB == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2651);
}
// MCC Label 2652
if(!(pA == 0) && pB == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2652);
}
// MCC Label 2653
if(!(pA == 0) && !(pB == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2653);
}
if( pA==0 || pB==0 ) { return 1;
}
  
// ABS Label 2654
if(pA->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2654);
}
// ABS Label 2655
if(pB->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2655);
}

// ROR Label 2656
if((pA->nExpr == pB->nExpr) != (pA->nExpr != pB->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2656);
}
if( pA->nExpr!=pB->nExpr ) { return 1;
}
  i = 0;

// ABS Label 2657
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2657);
}
// ABS Label 2658
if(pA->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2658);
}

// ROR Label 2659
if((i <= pA->nExpr) != (i < pA->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2659);
}
// ROR Label 2660
if((i > pA->nExpr) != (i < pA->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2660);
}
// ROR Label 2661
if((i >= pA->nExpr) != (i < pA->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2661);
}
for(; i<pA->nExpr; i++){
    int res;
    
// ABS Label 2667
if(pA->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2667);
}
Expr *pExprA = pA->a[i].pExpr;
    
// ABS Label 2668
if(pB->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2668);
}
Expr *pExprB = pB->a[i].pExpr;
    
// ROR Label 2669
if((pA->a[i].sortFlags == pB->a[i].sortFlags) != (pA->a[i].sortFlags != pB->a[i].sortFlags))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2669);
}
if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) { return 1;
}
    if( (res = sqlite3ExprCompare(0, pExprA, pExprB, iTab)) ) { 
// ABS Label 2670
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2670);
}
return res;
}
  };
// ABS Label 2662
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2662);
}
// ABS Label 2663
if(pA->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2663);
}

// ROR Label 2664
if((i <= pA->nExpr) != (i < pA->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2664);
}
// ROR Label 2665
if((i > pA->nExpr) != (i < pA->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2665);
}
// ROR Label 2666
if((i >= pA->nExpr) != (i < pA->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2666);
}

  return 0;
}

/*
** Like sqlite3ExprCompare() except COLLATE operators at the top-level
** are ignored.
*/
int sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){
  return sqlite3ExprCompare(0,
             sqlite3ExprSkipCollateAndLikely(pA),
             sqlite3ExprSkipCollateAndLikely(pB),
             iTab);
}

/*
** Return non-zero if Expr p can only be true if pNN is not NULL.
**
** Or if seenNot is true, return non-zero if Expr p can only be
** non-NULL if pNN is not NULL
*/
static int exprImpliesNotNull(
  Parse *pParse,      /* Parsing context */
  Expr *p,            /* The expression to be checked */
  Expr *pNN,          /* The expression that is NOT NULL */
  int iTab,           /* Table being evaluated */
  int seenNot         /* Return true only if p can be any non-NULL value */
){
  assert( p );
  assert( pNN );
  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){
    
// ROR Label 2671
if((pNN->op == 120) != (pNN->op != 120))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2671);
}
return pNN->op!=TK_NULL;
  }
  switch( p->op ){
    case TK_IN: {
      
// ABS Label 2672
if(seenNot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2672);
}

// COR Label 2673
if((seenNot || (((p)->flags & (2048)) != 0)) != (seenNot && (((p)->flags & (2048)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2673);
}

// MCC Label 2674
if(seenNot && ( ((p)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2674);
}
// MCC Label 2675
if(seenNot && ( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2675);
}
// MCC Label 2676
if(!(seenNot) && ( ((p)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2676);
}
// MCC Label 2677
if(!(seenNot) && ( !(((p)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2677);
}
if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) { return 0;
}
      assert( ExprHasProperty(p,EP_xIsSelect)
           || (p->x.pList!=0 && p->x.pList->nExpr>0) );
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case TK_BETWEEN: {
      
// ABS Label 2678
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2678);
}
ExprList *pList = p->x.pList;
      assert( pList!=0 );
      assert( pList->nExpr==2 );
      
// ABS Label 2679
if(seenNot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2679);
}
if( seenNot ) { return 0;
}
      if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)
       || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)
      ){
        return 1;
      }
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case TK_EQ:
    case TK_NE:
    case TK_LT:
    case TK_LE:
    case TK_GT:
    case TK_GE:
    case TK_PLUS:
    case TK_MINUS:
    case TK_BITOR:
    case TK_LSHIFT:
    case TK_RSHIFT: 
    case TK_CONCAT: 
      seenNot = 1;
      /* no break */ deliberate_fall_through
    case TK_STAR:
    case TK_REM:
    case TK_BITAND:
    case TK_SLASH: {
      if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) { return 1;
}
      /* no break */ deliberate_fall_through
    }
    case TK_SPAN:
    case TK_COLLATE:
    case TK_UPLUS:
    case TK_UMINUS: {
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);
    }
    case TK_TRUTH: {
      
// ABS Label 2680
if(seenNot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2680);
}
if( seenNot ) { return 0;
}
      
// ROR Label 2681
if((p->op2 == 45) != (p->op2 != 45))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2681);
}
if( p->op2!=TK_IS ) { return 0;
}
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case TK_BITNOT:
    case TK_NOT: {
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
  }
  return 0;
}

/*
** Return true if we can prove the pE2 will always be true if pE1 is
** true.  Return false if we cannot complete the proof or if pE2 might
** be false.  Examples:
**
**     pE1: x==5       pE2: x==5             Result: true
**     pE1: x>0        pE2: x==5             Result: false
**     pE1: x=21       pE2: x=21 OR y=43     Result: true
**     pE1: x!=123     pE2: x IS NOT NULL    Result: true
**     pE1: x!=?1      pE2: x IS NOT NULL    Result: true
**     pE1: x IS NULL  pE2: x IS NOT NULL    Result: false
**     pE1: x IS ?2    pE2: x IS NOT NULL    Reuslt: false
**
** When comparing TK_COLUMN nodes between pE1 and pE2, if pE2 has
** Expr.iTable<0 then assume a table number given by iTab.
**
** If pParse is not NULL, then the values of bound variables in pE1 are 
** compared against literal values in pE2 and pParse->pVdbe->expmask is
** modified to record which bound variables are referenced.  If pParse 
** is NULL, then false will be returned if pE1 contains any bound variables.
**
** When in doubt, return false.  Returning true might give a performance
** improvement.  Returning false might cause a performance reduction, but
** it will always give the correct answer and is hence always safe.
*/
int sqlite3ExprImpliesExpr(Parse *pParse, Expr *pE1, Expr *pE2, int iTab){
  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){
    return 1;
  }
  if( pE2->op==TK_OR
   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)
             || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )
  ){
    return 1;
  }
  if( pE2->op==TK_NOTNULL
   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)
  ){
    return 1;
  }
  return 0;
}

/*
** This is the Expr node callback for sqlite3ExprImpliesNonNullRow().
** If the expression node requires that the table at pWalker->iCur
** have one or more non-NULL column, then set pWalker->eCode to 1 and abort.
**
** This routine controls an optimization.  False positives (setting
** pWalker->eCode to 1 when it should not be) are deadly, but false-negatives
** (never setting pWalker->eCode) is a harmless missed optimization.
*/
static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
  testcase( pExpr->op==TK_AGG_COLUMN );
  testcase( pExpr->op==TK_AGG_FUNCTION );
  
// MCC Label 2682
if(( ((pExpr)->flags & (1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2682);
}
// MCC Label 2683
if(( !(((pExpr)->flags & (1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2683);
}
if( ExprHasProperty(pExpr, EP_FromJoin) ) { return WRC_Prune;
}
  switch( pExpr->op ){
    case TK_ISNOT:
    case TK_ISNULL:
    case TK_NOTNULL:
    case TK_IS:
    case TK_OR:
    case TK_VECTOR:
    case TK_CASE:
    case TK_IN:
    case TK_FUNCTION:
    case TK_TRUTH:
      testcase( pExpr->op==TK_ISNOT );
      testcase( pExpr->op==TK_ISNULL );
      testcase( pExpr->op==TK_NOTNULL );
      testcase( pExpr->op==TK_IS );
      testcase( pExpr->op==TK_OR );
      testcase( pExpr->op==TK_VECTOR );
      testcase( pExpr->op==TK_CASE );
      testcase( pExpr->op==TK_IN );
      testcase( pExpr->op==TK_FUNCTION );
      testcase( pExpr->op==TK_TRUTH );
      return WRC_Prune;
    case TK_COLUMN:
      
// ABS Label 2684
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2684);
}
// ABS Label 2685
if(pWalker->u.iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2685);
}

// ROR Label 2686
if((pWalker->u.iCur != pExpr->iTable) != (pWalker->u.iCur == pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2686);
}
if( pWalker->u.iCur==pExpr->iTable ){
        pWalker->eCode = 1;
        return WRC_Abort;
      }
      return WRC_Prune;

    case TK_AND:
      
// ROR Label 2687
if((pWalker->eCode != 0) != (pWalker->eCode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2687);
}
if( pWalker->eCode==0 ){
        
// ABS Label 2688
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2688);
}

// ABS Label 2689
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2689);
}
sqlite3WalkExpr(pWalker, pExpr->pLeft);
        
// ABS Label 2690
if(pWalker->eCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2690);
}
if( pWalker->eCode ){
          pWalker->eCode = 0;
          
// ABS Label 2691
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2691);
}

// ABS Label 2692
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2692);
}
sqlite3WalkExpr(pWalker, pExpr->pRight);
        }
      }
      return WRC_Prune;

    case TK_BETWEEN:
      if( sqlite3WalkExpr(pWalker, pExpr->pLeft)==WRC_Abort ){
        assert( pWalker->eCode );
        return WRC_Abort;
      }
      return WRC_Prune;

    /* Virtual tables are allowed to use constraints like x=NULL.  So
    ** a term of the form x=y does not prove that y is not null if x
    ** is the column of a virtual table */
    case TK_EQ:
    case TK_NE:
    case TK_LT:
    case TK_LE:
    case TK_GT:
    case TK_GE: {
      
// ABS Label 2693
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2693);
}
Expr *pLeft = pExpr->pLeft;
      
// ABS Label 2694
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2694);
}
Expr *pRight = pExpr->pRight;
      testcase( pExpr->op==TK_EQ );
      testcase( pExpr->op==TK_NE );
      testcase( pExpr->op==TK_LT );
      testcase( pExpr->op==TK_LE );
      testcase( pExpr->op==TK_GT );
      testcase( pExpr->op==TK_GE );
      /* The y.pTab=0 assignment in wherecode.c always happens after the
      ** impliesNotNullRow() test */
#ifdef MAGMA_ENABLE_FIXES
      if( (pLeft->op==TK_COLUMN && ALWAYS(pLeft->y.pTab!=0)
                               && IsVirtual(pLeft->y.pTab))
       || (pRight->op==TK_COLUMN && ALWAYS(pRight->y.pTab!=0)
                               && IsVirtual(pRight->y.pTab))
      )
#else
#ifdef MAGMA_ENABLE_CANARIES
      MAGMA_LOG("SQL017", MAGMA_OR(
                            MAGMA_AND(pLeft->op==TK_COLUMN, pLeft->y.pTab == 0),
                            MAGMA_AND(pLeft->op!=TK_COLUMN,
                              MAGMA_AND(pRight->op==TK_COLUMN, pRight->y.pTab == 0))));
#endif
      
// COR Label 2695
if(((pLeft->op == 166 && ((pLeft->y.pTab)->nModuleArg)) && (pRight->op == 166 && ((pRight->y.pTab)->nModuleArg))) != ((pLeft->op == 166 && ((pLeft->y.pTab)->nModuleArg)) || (pRight->op == 166 && ((pRight->y.pTab)->nModuleArg))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2695);
}

// MCC Label 2696
if(( pLeft->op == 166 && ((pLeft->y.pTab)->nModuleArg) ) && ( pRight->op == 166 && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2696);
}
// MCC Label 2697
if(( pLeft->op == 166 && ((pLeft->y.pTab)->nModuleArg) ) && ( pRight->op == 166 && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2697);
}
// MCC Label 2698
if(( pLeft->op == 166 && ((pLeft->y.pTab)->nModuleArg) ) && ( !(pRight->op == 166) && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2698);
}
// MCC Label 2699
if(( pLeft->op == 166 && ((pLeft->y.pTab)->nModuleArg) ) && ( !(pRight->op == 166) && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2699);
}
// MCC Label 2700
if(( pLeft->op == 166 && !(((pLeft->y.pTab)->nModuleArg)) ) && ( pRight->op == 166 && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2700);
}
// MCC Label 2701
if(( pLeft->op == 166 && !(((pLeft->y.pTab)->nModuleArg)) ) && ( pRight->op == 166 && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2701);
}
// MCC Label 2702
if(( pLeft->op == 166 && !(((pLeft->y.pTab)->nModuleArg)) ) && ( !(pRight->op == 166) && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2702);
}
// MCC Label 2703
if(( pLeft->op == 166 && !(((pLeft->y.pTab)->nModuleArg)) ) && ( !(pRight->op == 166) && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2703);
}
// MCC Label 2704
if(( !(pLeft->op == 166) && ((pLeft->y.pTab)->nModuleArg) ) && ( pRight->op == 166 && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2704);
}
// MCC Label 2705
if(( !(pLeft->op == 166) && ((pLeft->y.pTab)->nModuleArg) ) && ( pRight->op == 166 && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2705);
}
// MCC Label 2706
if(( !(pLeft->op == 166) && ((pLeft->y.pTab)->nModuleArg) ) && ( !(pRight->op == 166) && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2706);
}
// MCC Label 2707
if(( !(pLeft->op == 166) && ((pLeft->y.pTab)->nModuleArg) ) && ( !(pRight->op == 166) && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2707);
}
// MCC Label 2708
if(( !(pLeft->op == 166) && !(((pLeft->y.pTab)->nModuleArg)) ) && ( pRight->op == 166 && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2708);
}
// MCC Label 2709
if(( !(pLeft->op == 166) && !(((pLeft->y.pTab)->nModuleArg)) ) && ( pRight->op == 166 && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2709);
}
// MCC Label 2710
if(( !(pLeft->op == 166) && !(((pLeft->y.pTab)->nModuleArg)) ) && ( !(pRight->op == 166) && ((pRight->y.pTab)->nModuleArg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2710);
}
// MCC Label 2711
if(( !(pLeft->op == 166) && !(((pLeft->y.pTab)->nModuleArg)) ) && ( !(pRight->op == 166) && !(((pRight->y.pTab)->nModuleArg)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2711);
}
if( (pLeft->op==TK_COLUMN && IsVirtual(pLeft->y.pTab))
       || (pRight->op==TK_COLUMN && IsVirtual(pRight->y.pTab))
      )
#endif
      {
        return WRC_Prune;
      }
      /* no break */ deliberate_fall_through
    }
    default:
      return WRC_Continue;
  }
}

/*
** Return true (non-zero) if expression p can only be true if at least
** one column of table iTab is non-null.  In other words, return true
** if expression p will always be NULL or false if every column of iTab
** is NULL.
**
** False negatives are acceptable.  In other words, it is ok to return
** zero even if expression p will never be true of every column of iTab
** is NULL.  A false negative is merely a missed optimization opportunity.
**
** False positives are not allowed, however.  A false positive may result
** in an incorrect answer.
**
** Terms of p that are marked with EP_FromJoin (and hence that come from
** the ON or USING clauses of LEFT JOINS) are excluded from the analysis.
**
** This routine is used to check if a LEFT JOIN can be converted into
** an ordinary JOIN.  The p argument is the WHERE clause.  If the WHERE
** clause requires that some column of the right table of the LEFT JOIN
** be non-NULL, then the LEFT JOIN can be safely converted into an
** ordinary join.
*/
int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){
  Walker w;
  p = sqlite3ExprSkipCollateAndLikely(p);
  
// ABS Label 2713
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2713);
}

// ROR Label 2714
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2714);
}
if( p==0 ) { return 0;
}
  
// ROR Label 2715
if((p->op != 51) != (p->op == 51))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2715);
}
if( p->op==TK_NOTNULL ){
    p = p->pLeft;
  }else{
    
// ROR Label 2716
if((p->op != 44) != (p->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2716);
}
while( p->op==TK_AND ){
      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) { return 1;
}
      p = p->pRight;
    };
// ROR Label 2717
if((p->op != 44) != (p->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2717);
}

  }
  w.xExprCallback = impliesNotNullRow;
  w.xSelectCallback = 0;
  w.xSelectCallback2 = 0;
  w.eCode = 0;
  w.u.iCur = iTab;
  
// ABS Label 2712
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2712);
}
sqlite3WalkExpr(&w, p);
  return w.eCode;
}

/*
** An instance of the following structure is used by the tree walker
** to determine if an expression can be evaluated by reference to the
** index only, without having to do a search for the corresponding
** table entry.  The IdxCover.pIdx field is the index.  IdxCover.iCur
** is the cursor for the table.
*/
struct IdxCover {
  Index *pIdx;     /* The index to be tested for coverage */
  int iCur;        /* Cursor number for the table corresponding to the index */
};

/*
** Check to see if there are references to columns in table 
** pWalker->u.pIdxCover->iCur can be satisfied using the index
** pWalker->u.pIdxCover->pIdx.
*/
static int exprIdxCover(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==TK_COLUMN
   && pExpr->iTable==pWalker->u.pIdxCover->iCur
   && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0
  ){
    pWalker->eCode = 1;
    return WRC_Abort;
  }
  return WRC_Continue;
}

/*
** Determine if an index pIdx on table with cursor iCur contains will
** the expression pExpr.  Return true if the index does cover the
** expression and false if the pExpr expression references table columns
** that are not found in the index pIdx.
**
** An index covering an expression means that the expression can be
** evaluated using only the index and without having to lookup the
** corresponding table entry.
*/
int sqlite3ExprCoveredByIndex(
  Expr *pExpr,        /* The index to be tested */
  int iCur,           /* The cursor number for the corresponding table */
  Index *pIdx         /* The index that might be used for coverage */
){
  Walker w;
  struct IdxCover xcov;
  memset(&w, 0, sizeof(w));
  xcov.iCur = iCur;
  xcov.pIdx = pIdx;
  w.xExprCallback = exprIdxCover;
  w.u.pIdxCover = &xcov;
  
// ABS Label 2718
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2718);
}
sqlite3WalkExpr(&w, pExpr);
  return !w.eCode;
}


/*
** An instance of the following structure is used by the tree walker
** to count references to table columns in the arguments of an 
** aggregate function, in order to implement the
** sqlite3FunctionThisSrc() routine.
*/
struct SrcCount {
  SrcList *pSrc;   /* One particular FROM clause in a nested query */
  int iSrcInner;   /* Smallest cursor number in this context */
  int nThis;       /* Number of references to columns in pSrcList */
  int nOther;      /* Number of references to columns in other FROM clauses */
};

/*
** xSelect callback for sqlite3FunctionUsesThisSrc(). If this is the first
** SELECT with a FROM clause encountered during this iteration, set
** SrcCount.iSrcInner to the cursor number of the leftmost object in
** the FROM cause.
*/
static int selectSrcCount(Walker *pWalker, Select *pSel){
  
// ABS Label 2719
if(pWalker->u.pSrcCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2719);
}
struct SrcCount *p = pWalker->u.pSrcCount;
  
// ABS Label 2720
if((pSel->pSrc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2720);
}
// ABS Label 2721
if(p->iSrcInner < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2721);
}
// ABS Label 2722
if(pSel->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2722);
}

// COR Label 2723
if((p->iSrcInner == 2147483647 && (pSel->pSrc) || pSel->pSrc->nSrc) != (p->iSrcInner == 2147483647 && (pSel->pSrc) && pSel->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2723);
}
// COR Label 2724
if((p->iSrcInner == 2147483647 || (pSel->pSrc)) != (p->iSrcInner == 2147483647 && (pSel->pSrc)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2724);
}

// ROR Label 2725
if((p->iSrcInner != 2147483647) != (p->iSrcInner == 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2725);
}

// MCC Label 2726
if(p->iSrcInner == 2147483647 && (pSel->pSrc) && pSel->pSrc->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2726);
}
// MCC Label 2727
if(p->iSrcInner == 2147483647 && (pSel->pSrc) && !(pSel->pSrc->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2727);
}
// MCC Label 2728
if(p->iSrcInner == 2147483647 && !((pSel->pSrc)) && pSel->pSrc->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2728);
}
// MCC Label 2729
if(p->iSrcInner == 2147483647 && !((pSel->pSrc)) && !(pSel->pSrc->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2729);
}
// MCC Label 2730
if(!(p->iSrcInner == 2147483647) && (pSel->pSrc) && pSel->pSrc->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2730);
}
// MCC Label 2731
if(!(p->iSrcInner == 2147483647) && (pSel->pSrc) && !(pSel->pSrc->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2731);
}
// MCC Label 2732
if(!(p->iSrcInner == 2147483647) && !((pSel->pSrc)) && pSel->pSrc->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2732);
}
// MCC Label 2733
if(!(p->iSrcInner == 2147483647) && !((pSel->pSrc)) && !(pSel->pSrc->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2733);
}
if( p->iSrcInner==0x7FFFFFFF && ALWAYS(pSel->pSrc) && pSel->pSrc->nSrc ){
    pWalker->u.pSrcCount->iSrcInner = pSel->pSrc->a[0].iCursor;
  }
  return WRC_Continue;
}

/*
** Count the number of references to columns.
*/
static int exprSrcCount(Walker *pWalker, Expr *pExpr){
  /* There was once a NEVER() on the second term on the grounds that
  ** sqlite3FunctionUsesThisSrc() was always called before 
  ** sqlite3ExprAnalyzeAggregates() and so the TK_COLUMNs have not yet 
  ** been converted into TK_AGG_COLUMN. But this is no longer true due
  ** to window functions - sqlite3WindowRewrite() may now indirectly call
  ** FunctionUsesThisSrc() when creating a new sub-select. */
  
// COR Label 2734
if((pExpr->op == 166 && pExpr->op == 168) != (pExpr->op == 166 || pExpr->op == 168))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2734);
}

// ROR Label 2735
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2735);
}
// ROR Label 2736
if((pExpr->op != 168) != (pExpr->op == 168))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2736);
}

// MCC Label 2737
if(pExpr->op == 166 && pExpr->op == 168 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2737);
}
// MCC Label 2738
if(pExpr->op == 166 && !(pExpr->op == 168) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2738);
}
// MCC Label 2739
if(!(pExpr->op == 166) && pExpr->op == 168 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2739);
}
// MCC Label 2740
if(!(pExpr->op == 166) && !(pExpr->op == 168) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2740);
}
if( pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN ){
    int i;
    
// ABS Label 2741
if(pWalker->u.pSrcCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2741);
}
struct SrcCount *p = pWalker->u.pSrcCount;
    
// ABS Label 2742
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2742);
}
SrcList *pSrc = p->pSrc;
    int nSrc = pSrc ? pSrc->nSrc : 0;
    i = 0;

// ABS Label 2743
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2743);
}
// ABS Label 2744
if(nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2744);
}

// ROR Label 2745
if((i <= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2745);
}
// ROR Label 2746
if((i > nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2746);
}
// ROR Label 2747
if((i >= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2747);
}
for(; i<nSrc; i++){
      
// ABS Label 2753
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2753);
}
// ABS Label 2754
if(pSrc->a[i].iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2754);
}

// ROR Label 2755
if((pExpr->iTable != pSrc->a[i].iCursor) != (pExpr->iTable == pSrc->a[i].iCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2755);
}
if( pExpr->iTable==pSrc->a[i].iCursor ) { break;
}
    };
// ABS Label 2748
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2748);
}
// ABS Label 2749
if(nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2749);
}

// ROR Label 2750
if((i <= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2750);
}
// ROR Label 2751
if((i > nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2751);
}
// ROR Label 2752
if((i >= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2752);
}

    
// ABS Label 2756
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2756);
}
// ABS Label 2757
if(nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2757);
}

// ROR Label 2758
if((i <= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2758);
}
// ROR Label 2759
if((i > nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2759);
}
// ROR Label 2760
if((i >= nSrc) != (i < nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2760);
}
if( i<nSrc ){
      p->nThis++;
    }else { 
// ABS Label 2761
if(p->iSrcInner < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2761);
}
// ABS Label 2762
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2762);
}

// ROR Label 2763
if((pExpr->iTable <= p->iSrcInner) != (pExpr->iTable < p->iSrcInner))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2763);
}
// ROR Label 2764
if((pExpr->iTable > p->iSrcInner) != (pExpr->iTable < p->iSrcInner))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2764);
}
// ROR Label 2765
if((pExpr->iTable >= p->iSrcInner) != (pExpr->iTable < p->iSrcInner))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2765);
}
if( pExpr->iTable<p->iSrcInner ){
      /* In a well-formed parse tree (no name resolution errors),
      ** TK_COLUMN nodes with smaller Expr.iTable values are in an
      ** outer context.  Those are the only ones to count as "other" */
      p->nOther++;
    };}

  }
  return WRC_Continue;
}

/*
** Determine if any of the arguments to the pExpr Function reference
** pSrcList.  Return true if they do.  Also return true if the function
** has no arguments or has only constant arguments.  Return false if pExpr
** references columns but not columns of tables found in pSrcList.
*/
int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){
  Walker w;
  struct SrcCount cnt;
  assert( pExpr->op==TK_AGG_FUNCTION );
  memset(&w, 0, sizeof(w));
  w.xExprCallback = exprSrcCount;
  w.xSelectCallback = selectSrcCount;
  w.u.pSrcCount = &cnt;
  cnt.pSrc = pSrcList;
  cnt.iSrcInner = (pSrcList&&pSrcList->nSrc)?pSrcList->a[0].iCursor:0x7FFFFFFF;
  cnt.nThis = 0;
  cnt.nOther = 0;
  
// ABS Label 2766
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2766);
}
sqlite3WalkExprList(&w, pExpr->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
  
// MCC Label 2767
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2767);
}
// MCC Label 2768
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2768);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
    
// ABS Label 2769
if(pExpr->y.pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2769);
}
sqlite3WalkExpr(&w, pExpr->y.pWin->pFilter);
  }
#endif
  
// ABS Label 2770
if(cnt.nOther < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2770);
}
// ABS Label 2771
if(cnt.nThis < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2771);
}

// COR Label 2772
if((cnt.nThis > 0 && cnt.nOther == 0) != (cnt.nThis > 0 || cnt.nOther == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2772);
}

// ROR Label 2773
if((cnt.nThis <= 0) != (cnt.nThis > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2773);
}
// ROR Label 2774
if((cnt.nThis < 0) != (cnt.nThis > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2774);
}
// ROR Label 2775
if((cnt.nThis >= 0) != (cnt.nThis > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2775);
}
// ROR Label 2776
if((cnt.nOther != 0) != (cnt.nOther == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2776);
}

// MCC Label 2777
if(cnt.nThis > 0 && cnt.nOther == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2777);
}
// MCC Label 2778
if(cnt.nThis > 0 && !(cnt.nOther == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2778);
}
// MCC Label 2779
if(!(cnt.nThis > 0) && cnt.nOther == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2779);
}
// MCC Label 2780
if(!(cnt.nThis > 0) && !(cnt.nOther == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2780);
}
return cnt.nThis>0 || cnt.nOther==0;
}

/*
** This is a Walker expression node callback.
**
** For Expr nodes that contain pAggInfo pointers, make sure the AggInfo
** object that is referenced does not refer directly to the Expr.  If
** it does, make a copy.  This is done because the pExpr argument is
** subject to change.
**
** The copy is stored on pParse->pConstExpr with a register number of 0.
** This will cause the expression to be deleted automatically when the
** Parse object is destroyed, but the zero register number means that it
** will not generate any code in the preamble.
*/
static int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 2781
if(pExpr->pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2781);
}

// COR Label 2782
if(((!(((pExpr)->flags & (16384 | 8192)) != 0)) || pExpr->pAggInfo != 0) != ((!(((pExpr)->flags & (16384 | 8192)) != 0)) && pExpr->pAggInfo != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2782);
}

// ROR Label 2783
if((pExpr->pAggInfo == 0) != (pExpr->pAggInfo != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2783);
}

// MCC Label 2784
if(( !(((pExpr)->flags & (16384 | 8192)) != 0) ) && pExpr->pAggInfo != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2784);
}
// MCC Label 2785
if(( !(((pExpr)->flags & (16384 | 8192)) != 0) ) && !(pExpr->pAggInfo != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2785);
}
// MCC Label 2786
if(( !(!(((pExpr)->flags & (16384 | 8192)) != 0)) ) && pExpr->pAggInfo != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2786);
}
// MCC Label 2787
if(( !(!(((pExpr)->flags & (16384 | 8192)) != 0)) ) && !(pExpr->pAggInfo != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2787);
}
if( ALWAYS(!ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced))
   && pExpr->pAggInfo!=0
  ){
    
// ABS Label 2788
if(pExpr->pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2788);
}
AggInfo *pAggInfo = pExpr->pAggInfo;
    int iAgg = pExpr->iAgg;
    
// ABS Label 2789
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2789);
}
Parse *pParse = pWalker->pParse;
    
// ABS Label 2790
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2790);
}
sqlite3 *db = pParse->db;
    assert( pExpr->op==TK_AGG_COLUMN || pExpr->op==TK_AGG_FUNCTION );
    
// ROR Label 2791
if((pExpr->op != 168) != (pExpr->op == 168))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2791);
}
if( pExpr->op==TK_AGG_COLUMN ){
      assert( iAgg>=0 && iAgg<pAggInfo->nColumn );
      
// ABS Label 2792
if(pAggInfo->aCol[iAgg].pCExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2792);
}
// ABS Label 2793
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2793);
}

// ROR Label 2794
if((pAggInfo->aCol[iAgg].pCExpr != pExpr) != (pAggInfo->aCol[iAgg].pCExpr == pExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2794);
}
if( pAggInfo->aCol[iAgg].pCExpr==pExpr ){
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        
// ABS Label 2795
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2795);
}
if( pExpr ){
          pAggInfo->aCol[iAgg].pCExpr = pExpr;
          
// ABS Label 2796
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2796);
}

// ABS Label 2797
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2797);
}
sqlite3ExprDeferredDelete(pParse, pExpr);
        }
      }
    }else{
      assert( iAgg>=0 && iAgg<pAggInfo->nFunc );
      
// ABS Label 2798
if(pAggInfo->aFunc[iAgg].pFExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2798);
}
// ABS Label 2799
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2799);
}

// ROR Label 2800
if((pAggInfo->aFunc[iAgg].pFExpr != pExpr) != (pAggInfo->aFunc[iAgg].pFExpr == pExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2800);
}
if( pAggInfo->aFunc[iAgg].pFExpr==pExpr ){
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        
// ABS Label 2801
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2801);
}
if( pExpr ){
          pAggInfo->aFunc[iAgg].pFExpr = pExpr;
          
// ABS Label 2802
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2802);
}

// ABS Label 2803
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2803);
}
sqlite3ExprDeferredDelete(pParse, pExpr);
        }
      }
    }
  }
  return WRC_Continue;
}

/*
** Initialize a Walker object so that will persist AggInfo entries referenced
** by the tree that is walked.
*/
void sqlite3AggInfoPersistWalkerInit(Walker *pWalker, Parse *pParse){
  memset(pWalker, 0, sizeof(*pWalker));
  pWalker->pParse = pParse;
  pWalker->xExprCallback = agginfoPersistExprCb;
  pWalker->xSelectCallback = sqlite3SelectWalkNoop;
}

/*
** Add a new element to the pAggInfo->aCol[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/
static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aCol = sqlite3ArrayAllocate(
       db,
       pInfo->aCol,
       sizeof(pInfo->aCol[0]),
       &pInfo->nColumn,
       &i
  );
  
// ABS Label 2804
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2804);
}
return i;
}    

/*
** Add a new element to the pAggInfo->aFunc[] array.  Return the index of
** the new element.  Return a negative number if malloc fails.
*/
static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aFunc = sqlite3ArrayAllocate(
       db, 
       pInfo->aFunc,
       sizeof(pInfo->aFunc[0]),
       &pInfo->nFunc,
       &i
  );
  
// ABS Label 2805
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2805);
}
return i;
}

/*
** This is the xExprCallback for a tree walker.  It is used to
** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates
** for additional information.
*/
static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
  int i;
  
// ABS Label 2806
if(pWalker->u.pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2806);
}
NameContext *pNC = pWalker->u.pNC;
  
// ABS Label 2807
if(pNC->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2807);
}
Parse *pParse = pNC->pParse;
  
// ABS Label 2808
if(pNC->pSrcList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2808);
}
SrcList *pSrcList = pNC->pSrcList;
  
// ABS Label 2809
if(pNC->uNC.pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2809);
}
AggInfo *pAggInfo = pNC->uNC.pAggInfo;

  assert( pNC->ncFlags & NC_UAggInfo );
  switch( pExpr->op ){
    case TK_AGG_COLUMN:
    case TK_COLUMN: {
      testcase( pExpr->op==TK_AGG_COLUMN );
      testcase( pExpr->op==TK_COLUMN );
      /* Check to see if the column is in one of the tables in the FROM
      ** clause of the aggregate query */
      
// MCC Label 2810
if(( pSrcList != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2810);
}
// MCC Label 2811
if(( !(pSrcList != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2811);
}
if( ALWAYS(pSrcList!=0) ){
        SrcItem *pItem = pSrcList->a;
        i = 0;

// ABS Label 2812
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2812);
}
// ABS Label 2813
if(pSrcList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2813);
}

// ROR Label 2814
if((i <= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2814);
}
// ROR Label 2815
if((i > pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2815);
}
// ROR Label 2816
if((i >= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2816);
}
for(; i<pSrcList->nSrc; i++, pItem++){
          struct AggInfo_col *pCol;
          assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
          
// ABS Label 2822
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2822);
}
// ABS Label 2823
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2823);
}

// ROR Label 2824
if((pExpr->iTable != pItem->iCursor) != (pExpr->iTable == pItem->iCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2824);
}
if( pExpr->iTable==pItem->iCursor ){
            /* If we reach this point, it means that pExpr refers to a table
            ** that is in the FROM clause of the aggregate query.  
            **
            ** Make an entry for the column in pAggInfo->aCol[] if there
            ** is not an entry there already.
            */
            int k;
            pCol = pAggInfo->aCol;
            k = 0;

// ABS Label 2825
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2825);
}
// ABS Label 2826
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2826);
}

// ROR Label 2827
if((k <= pAggInfo->nColumn) != (k < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2827);
}
// ROR Label 2828
if((k > pAggInfo->nColumn) != (k < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2828);
}
// ROR Label 2829
if((k >= pAggInfo->nColumn) != (k < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2829);
}
for(; k<pAggInfo->nColumn; k++, pCol++){
              
// ABS Label 2835
if(pCol->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2835);
}
// ABS Label 2836
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2836);
}

// COR Label 2837
if((pCol->iTable == pExpr->iTable || pCol->iColumn == pExpr->iColumn) != (pCol->iTable == pExpr->iTable && pCol->iColumn == pExpr->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2837);
}

// ROR Label 2838
if((pCol->iTable != pExpr->iTable) != (pCol->iTable == pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2838);
}
// ROR Label 2839
if((pCol->iColumn != pExpr->iColumn) != (pCol->iColumn == pExpr->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2839);
}

// MCC Label 2840
if(pCol->iTable == pExpr->iTable && pCol->iColumn == pExpr->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2840);
}
// MCC Label 2841
if(pCol->iTable == pExpr->iTable && !(pCol->iColumn == pExpr->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2841);
}
// MCC Label 2842
if(!(pCol->iTable == pExpr->iTable) && pCol->iColumn == pExpr->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2842);
}
// MCC Label 2843
if(!(pCol->iTable == pExpr->iTable) && !(pCol->iColumn == pExpr->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2843);
}
if( pCol->iTable==pExpr->iTable &&
                  pCol->iColumn==pExpr->iColumn ){
                break;
              }
            };
// ABS Label 2830
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2830);
}
// ABS Label 2831
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2831);
}

// ROR Label 2832
if((k <= pAggInfo->nColumn) != (k < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2832);
}
// ROR Label 2833
if((k > pAggInfo->nColumn) != (k < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2833);
}
// ROR Label 2834
if((k >= pAggInfo->nColumn) != (k < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2834);
}

            if( (k>=pAggInfo->nColumn)
             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 
            ){
              pCol = &pAggInfo->aCol[k];
              pCol->pTab = pExpr->y.pTab;
              pCol->iTable = pExpr->iTable;
              pCol->iColumn = pExpr->iColumn;
              pCol->iMem = ++pParse->nMem;
              pCol->iSorterColumn = -1;
              pCol->pCExpr = pExpr;
              
// ABS Label 2844
if(pAggInfo->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2844);
}
if( pAggInfo->pGroupBy ){
                int j, n;
                
// ABS Label 2845
if(pAggInfo->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2845);
}
ExprList *pGB = pAggInfo->pGroupBy;
                struct ExprList_item *pTerm = pGB->a;
                n = pGB->nExpr;
                j = 0;

// ABS Label 2846
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2846);
}
// ABS Label 2847
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2847);
}

// ROR Label 2848
if((j <= n) != (j < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2848);
}
// ROR Label 2849
if((j > n) != (j < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2849);
}
// ROR Label 2850
if((j >= n) != (j < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2850);
}
for(; j<n; j++, pTerm++){
                  
// ABS Label 2856
if(pTerm->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2856);
}
Expr *pE = pTerm->pExpr;
                  
// ABS Label 2857
if(pE->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2857);
}
// ABS Label 2858
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2858);
}

// COR Label 2859
if((pE->op == 166 && pE->iTable == pExpr->iTable || pE->iColumn == pExpr->iColumn) != (pE->op == 166 && pE->iTable == pExpr->iTable && pE->iColumn == pExpr->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2859);
}
// COR Label 2860
if((pE->op == 166 || pE->iTable == pExpr->iTable) != (pE->op == 166 && pE->iTable == pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2860);
}

// ROR Label 2861
if((pE->op != 166) != (pE->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2861);
}
// ROR Label 2862
if((pE->iTable != pExpr->iTable) != (pE->iTable == pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2862);
}
// ROR Label 2863
if((pE->iColumn != pExpr->iColumn) != (pE->iColumn == pExpr->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2863);
}

// MCC Label 2864
if(pE->op == 166 && pE->iTable == pExpr->iTable && pE->iColumn == pExpr->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2864);
}
// MCC Label 2865
if(pE->op == 166 && pE->iTable == pExpr->iTable && !(pE->iColumn == pExpr->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2865);
}
// MCC Label 2866
if(pE->op == 166 && !(pE->iTable == pExpr->iTable) && pE->iColumn == pExpr->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2866);
}
// MCC Label 2867
if(pE->op == 166 && !(pE->iTable == pExpr->iTable) && !(pE->iColumn == pExpr->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2867);
}
// MCC Label 2868
if(!(pE->op == 166) && pE->iTable == pExpr->iTable && pE->iColumn == pExpr->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2868);
}
// MCC Label 2869
if(!(pE->op == 166) && pE->iTable == pExpr->iTable && !(pE->iColumn == pExpr->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2869);
}
// MCC Label 2870
if(!(pE->op == 166) && !(pE->iTable == pExpr->iTable) && pE->iColumn == pExpr->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2870);
}
// MCC Label 2871
if(!(pE->op == 166) && !(pE->iTable == pExpr->iTable) && !(pE->iColumn == pExpr->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2871);
}
if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&
                      pE->iColumn==pExpr->iColumn ){
                    pCol->iSorterColumn = j;
                    break;
                  }
                };
// ABS Label 2851
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2851);
}
// ABS Label 2852
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2852);
}

// ROR Label 2853
if((j <= n) != (j < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2853);
}
// ROR Label 2854
if((j > n) != (j < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2854);
}
// ROR Label 2855
if((j >= n) != (j < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2855);
}

              }
              
// ROR Label 2872
if((pCol->iSorterColumn <= 0) != (pCol->iSorterColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2872);
}
// ROR Label 2873
if((pCol->iSorterColumn > 0) != (pCol->iSorterColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2873);
}
// ROR Label 2874
if((pCol->iSorterColumn >= 0) != (pCol->iSorterColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2874);
}
if( pCol->iSorterColumn<0 ){
                pCol->iSorterColumn = pAggInfo->nSortingColumn++;
              }
            }
            /* There is now an entry for pExpr in pAggInfo->aCol[] (either
            ** because it was there before or because we just created it).
            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that
            ** pAggInfo->aCol[] entry.
            */
            ExprSetVVAProperty(pExpr, EP_NoReduce);
            pExpr->pAggInfo = pAggInfo;
            pExpr->op = TK_AGG_COLUMN;
            pExpr->iAgg = (i16)k;
            break;
          } /* endif pExpr->iTable==pItem->iCursor */
        };
// ABS Label 2817
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2817);
}
// ABS Label 2818
if(pSrcList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2818);
}

// ROR Label 2819
if((i <= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2819);
}
// ROR Label 2820
if((i > pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2820);
}
// ROR Label 2821
if((i >= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2821);
}
 /* end loop over pSrcList */
      }
      return WRC_Prune;
    }
    case TK_AGG_FUNCTION: {
      
// ABS Label 2875
if(pWalker->walkerDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2875);
}

// COR Label 2876
if(((pNC->ncFlags & 131072) == 0 || pWalker->walkerDepth == pExpr->op2) != ((pNC->ncFlags & 131072) == 0 && pWalker->walkerDepth == pExpr->op2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2876);
}

// ROR Label 2877
if(((pNC->ncFlags & 131072) != 0) != ((pNC->ncFlags & 131072) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2877);
}
// ROR Label 2878
if((pWalker->walkerDepth != pExpr->op2) != (pWalker->walkerDepth == pExpr->op2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2878);
}

// MCC Label 2879
if((pNC->ncFlags & 131072) == 0 && pWalker->walkerDepth == pExpr->op2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2879);
}
// MCC Label 2880
if((pNC->ncFlags & 131072) == 0 && !(pWalker->walkerDepth == pExpr->op2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2880);
}
// MCC Label 2881
if(!((pNC->ncFlags & 131072) == 0) && pWalker->walkerDepth == pExpr->op2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2881);
}
// MCC Label 2882
if(!((pNC->ncFlags & 131072) == 0) && !(pWalker->walkerDepth == pExpr->op2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2882);
}
if( (pNC->ncFlags & NC_InAggFunc)==0
       && pWalker->walkerDepth==pExpr->op2
      ){
        /* Check to see if pExpr is a duplicate of another aggregate 
        ** function that is already in the pAggInfo structure
        */
        
// ABS Label 2883
if(pAggInfo->aFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2883);
}
struct AggInfo_func *pItem = pAggInfo->aFunc;
        i = 0;

// ABS Label 2884
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2884);
}
// ABS Label 2885
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2885);
}

// ROR Label 2886
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2886);
}
// ROR Label 2887
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2887);
}
// ROR Label 2888
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2888);
}
for(; i<pAggInfo->nFunc; i++, pItem++){
          
// ABS Label 2894
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2894);
}
// ABS Label 2895
if(pItem->pFExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2895);
}

// ROR Label 2896
if((pItem->pFExpr != pExpr) != (pItem->pFExpr == pExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2896);
}
if( pItem->pFExpr==pExpr ) { break;
}
          if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){
            break;
          }
        };
// ABS Label 2889
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2889);
}
// ABS Label 2890
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2890);
}

// ROR Label 2891
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2891);
}
// ROR Label 2892
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2892);
}
// ROR Label 2893
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2893);
}

        
// ABS Label 2897
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2897);
}
// ABS Label 2898
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2898);
}

// ROR Label 2899
if((i < pAggInfo->nFunc) != (i >= pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2899);
}
// ROR Label 2900
if((i > pAggInfo->nFunc) != (i >= pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2900);
}
// ROR Label 2901
if((i <= pAggInfo->nFunc) != (i >= pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2901);
}
if( i>=pAggInfo->nFunc ){
          /* pExpr is original.  Make a new entry in pAggInfo->aFunc[]
          */
          
// ABS Label 2902
if(((pParse->db)->enc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2902);
}
u8 enc = ENC(pParse->db);
          i = addAggInfoFunc(pParse->db, pAggInfo);
          
// ABS Label 2903
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2903);
}

// ROR Label 2904
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2904);
}
// ROR Label 2905
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2905);
}
// ROR Label 2906
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2906);
}
if( i>=0 ){
            assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
            pItem = &pAggInfo->aFunc[i];
            pItem->pFExpr = pExpr;
            pItem->iMem = ++pParse->nMem;
            assert( !ExprHasProperty(pExpr, EP_IntValue) );
            pItem->pFunc = sqlite3FindFunction(pParse->db,
                   pExpr->u.zToken, 
                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);
            
// ABS Label 2907
if(pExpr->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2907);
}

// AOR Label 2908
if(pExpr->flags | 2 != pExpr->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2908);
}
// AOR Label 2909
if(pExpr->flags ^ 2 != pExpr->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2909);
}
if( pExpr->flags & EP_Distinct ){
              pItem->iDistinct = pParse->nTab++;
            }else{
              pItem->iDistinct = -1;
            }
          }
        }
        /* Make pExpr point to the appropriate pAggInfo->aFunc[] entry
        */
        assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );
        ExprSetVVAProperty(pExpr, EP_NoReduce);
        pExpr->iAgg = (i16)i;
        pExpr->pAggInfo = pAggInfo;
        return WRC_Prune;
      }else{
        return WRC_Continue;
      }
    }
  }
  return WRC_Continue;
}

/*
** Analyze the pExpr expression looking for aggregate functions and
** for variables that need to be added to AggInfo object that pNC->pAggInfo
** points to.  Additional entries are made on the AggInfo object as
** necessary.
**
** This routine should only be called after the expression has been
** analyzed by sqlite3ResolveExprNames().
*/
void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){
  Walker w;
  w.xExprCallback = analyzeAggregate;
  w.xSelectCallback = sqlite3WalkerDepthIncrease;
  w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
  w.walkerDepth = 0;
  w.u.pNC = pNC;
  w.pParse = 0;
  assert( pNC->pSrcList!=0 );
  
// ABS Label 2910
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2910);
}
sqlite3WalkExpr(&w, pExpr);
}

/*
** Call sqlite3ExprAnalyzeAggregates() for every expression in an
** expression list.  Return the number of errors.
**
** If an error is found, the analysis is cut short.
*/
void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){
  struct ExprList_item *pItem;
  int i;
  
// ABS Label 2911
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2911);
}
if( pList ){
    pItem = pList->a , i = 0;

// ABS Label 2912
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2912);
}
// ABS Label 2913
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2913);
}

// ROR Label 2914
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2914);
}
// ROR Label 2915
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2915);
}
// ROR Label 2916
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2916);
}
for(; i<pList->nExpr; i++, pItem++){
      
// ABS Label 2922
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2922);
}

// ABS Label 2923
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2923);
}
sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
    };
// ABS Label 2917
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2917);
}
// ABS Label 2918
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2918);
}

// ROR Label 2919
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2919);
}
// ROR Label 2920
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2920);
}
// ROR Label 2921
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2921);
}

  }
}

/*
** Allocate a single new register for use to hold some intermediate result.
*/
int sqlite3GetTempReg(Parse *pParse){
  
// ROR Label 2924
if((pParse->nTempReg != 0) != (pParse->nTempReg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2924);
}
if( pParse->nTempReg==0 ){
    return ++pParse->nMem;
  }
  return pParse->aTempReg[--pParse->nTempReg];
}

/*
** Deallocate a register, making available for reuse for some other
** purpose.
*/
void sqlite3ReleaseTempReg(Parse *pParse, int iReg){
  
// ABS Label 2925
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2925);
}
if( iReg ){
    sqlite3VdbeReleaseRegisters(pParse, iReg, 1, 0, 0);
    
// ROR Label 2926
if((pParse->nTempReg <= ((int)(sizeof (pParse->aTempReg) / sizeof (pParse->aTempReg[0])))) != (pParse->nTempReg < ((int)(sizeof (pParse->aTempReg) / sizeof (pParse->aTempReg[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2926);
}
// ROR Label 2927
if((pParse->nTempReg > ((int)(sizeof (pParse->aTempReg) / sizeof (pParse->aTempReg[0])))) != (pParse->nTempReg < ((int)(sizeof (pParse->aTempReg) / sizeof (pParse->aTempReg[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2927);
}
// ROR Label 2928
if((pParse->nTempReg >= ((int)(sizeof (pParse->aTempReg) / sizeof (pParse->aTempReg[0])))) != (pParse->nTempReg < ((int)(sizeof (pParse->aTempReg) / sizeof (pParse->aTempReg[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2928);
}
if( pParse->nTempReg<ArraySize(pParse->aTempReg) ){
      pParse->aTempReg[pParse->nTempReg++] = iReg;
    }
  }
}

/*
** Allocate or deallocate a block of nReg consecutive registers.
*/
int sqlite3GetTempRange(Parse *pParse, int nReg){
  int i, n;
  
// ABS Label 2929
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2929);
}

// ROR Label 2930
if((nReg != 1) != (nReg == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2930);
}
if( nReg==1 ) { return sqlite3GetTempReg(pParse);
}
  i = pParse->iRangeReg;
  n = pParse->nRangeReg;
  
// ABS Label 2931
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2931);
}
// ABS Label 2932
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2932);
}

// ROR Label 2933
if((nReg < n) != (nReg <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2933);
}
// ROR Label 2934
if((nReg > n) != (nReg <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2934);
}
// ROR Label 2935
if((nReg >= n) != (nReg <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2935);
}
if( nReg<=n ){
    pParse->iRangeReg += nReg;
    pParse->nRangeReg -= nReg;
  }else{
    i = pParse->nMem+1;
    pParse->nMem += nReg;
  }
  
// ABS Label 2936
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2936);
}
return i;
}
void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){
  
// ABS Label 2937
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2937);
}

// ROR Label 2938
if((nReg != 1) != (nReg == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2938);
}
if( nReg==1 ){
    
// ABS Label 2939
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2939);
}

// ABS Label 2940
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2940);
}
sqlite3ReleaseTempReg(pParse, iReg);
    return;
  }
  sqlite3VdbeReleaseRegisters(pParse, iReg, nReg, 0, 0);
  
// ABS Label 2941
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2941);
}
// ABS Label 2942
if(pParse->nRangeReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2942);
}

// ROR Label 2943
if((nReg <= pParse->nRangeReg) != (nReg > pParse->nRangeReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2943);
}
// ROR Label 2944
if((nReg < pParse->nRangeReg) != (nReg > pParse->nRangeReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2944);
}
// ROR Label 2945
if((nReg >= pParse->nRangeReg) != (nReg > pParse->nRangeReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2945);
}
if( nReg>pParse->nRangeReg ){
    pParse->nRangeReg = nReg;
    pParse->iRangeReg = iReg;
  }
}

/*
** Mark all temporary registers as being unavailable for reuse.
**
** Always invoke this procedure after coding a subroutine or co-routine
** that might be invoked from other parts of the code, to ensure that
** the sub/co-routine does not use registers in common with the code that
** invokes the sub/co-routine.
*/
void sqlite3ClearTempRegCache(Parse *pParse){
  pParse->nTempReg = 0;
  pParse->nRangeReg = 0;
}

/*
** Validate that no temporary register falls within the range of
** iFirst..iLast, inclusive.  This routine is only call from within assert()
** statements.
*/
#ifdef SQLITE_DEBUG
int sqlite3NoTempsInRange(Parse *pParse, int iFirst, int iLast){
  int i;
  if( pParse->nRangeReg>0
   && pParse->iRangeReg+pParse->nRangeReg > iFirst
   && pParse->iRangeReg <= iLast
  ){
     return 0;
  }
  for(i=0; i<pParse->nTempReg; i++){
    if( pParse->aTempReg[i]>=iFirst && pParse->aTempReg[i]<=iLast ){
      return 0;
    }
  }
  return 1;
}
#endif /* SQLITE_DEBUG */
