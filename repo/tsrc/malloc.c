/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** Memory allocation functions used throughout sqlite.
*/
#include "sqliteInt.h"
#include <stdarg.h>

/*
** Attempt to release up to n bytes of non-essential memory currently
** held by SQLite. An example of non-essential memory is memory used to
** cache database pages that are not currently in use.
*/
int sqlite3_release_memory(int n){
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
  return sqlite3PcacheReleaseMemory(n);
#else
  /* IMPLEMENTATION-OF: R-34391-24921 The sqlite3_release_memory() routine
  ** is a no-op returning zero if SQLite is not compiled with
  ** SQLITE_ENABLE_MEMORY_MANAGEMENT. */
  UNUSED_PARAMETER(n);
  return 0;
#endif
}

/*
** Default value of the hard heap limit.  0 means "no limit".
*/
#ifndef SQLITE_MAX_MEMORY
# define SQLITE_MAX_MEMORY 0
#endif

/*
** State information local to the memory allocation subsystem.
*/
static SQLITE_WSD struct Mem0Global {
  sqlite3_mutex *mutex;         /* Mutex to serialize access */
  sqlite3_int64 alarmThreshold; /* The soft heap limit */
  sqlite3_int64 hardLimit;      /* The hard upper bound on memory */

  /*
  ** True if heap is nearly "full" where "full" is defined by the
  ** sqlite3_soft_heap_limit() setting.
  */
  int nearlyFull;
} mem0 = { 0, SQLITE_MAX_MEMORY, SQLITE_MAX_MEMORY, 0 };

#define mem0 GLOBAL(struct Mem0Global, mem0)

/*
** Return the memory allocator mutex. sqlite3_status() needs it.
*/
sqlite3_mutex *sqlite3MallocMutex(void){
  
// ABS Label 7
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
return mem0.mutex;
}

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Deprecated external interface.  It used to set an alarm callback
** that was invoked when memory usage grew too large.  Now it is a
** no-op.
*/
int sqlite3_memory_alarm(
  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
  void *pArg,
  sqlite3_int64 iThreshold
){
  (void)xCallback;
  (void)pArg;
  (void)iThreshold;
  return SQLITE_OK;
}
#endif

/*
** Set the soft heap-size limit for the library.  An argument of
** zero disables the limit.  A negative argument is a no-op used to
** obtain the return value.
**
** The return value is the value of the heap limit just before this
** interface was called.
**
** If the hard heap limit is enabled, then the soft heap limit cannot
** be disabled nor raised above the hard heap limit.
*/
sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;
  sqlite3_int64 nUsed;
#ifndef SQLITE_OMIT_AUTOINIT
  int rc = sqlite3_initialize();
  
// ABS Label 10
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
if( rc ) { return -1;
}
#endif
  
// ABS Label 8
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.alarmThreshold;
  
// ABS Label 11
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ROR Label 12
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
// ROR Label 13
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
if( n<0 ){
    
// ABS Label 15
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
sqlite3_mutex_leave(mem0.mutex);
    
// ABS Label 16
if(priorLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
return priorLimit;
  }
  
// ABS Label 17
if(mem0.hardLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// COR Label 18
if((mem0.hardLimit > 0 || (n > mem0.hardLimit || n == 0)) != (mem0.hardLimit > 0 && (n > mem0.hardLimit || n == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 18);
}

// ROR Label 19
if((mem0.hardLimit <= 0) != (mem0.hardLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if((mem0.hardLimit < 0) != (mem0.hardLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}
// ROR Label 21
if((mem0.hardLimit >= 0) != (mem0.hardLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}

// MCC Label 22
if(mem0.hardLimit > 0 && ( n > mem0.hardLimit && n == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 22);
}
// MCC Label 23
if(mem0.hardLimit > 0 && ( n > mem0.hardLimit && !(n == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 23);
}
// MCC Label 24
if(mem0.hardLimit > 0 && ( !(n > mem0.hardLimit) && n == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 24);
}
// MCC Label 25
if(mem0.hardLimit > 0 && ( !(n > mem0.hardLimit) && !(n == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 25);
}
// MCC Label 26
if(!(mem0.hardLimit > 0) && ( n > mem0.hardLimit && n == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}
// MCC Label 27
if(!(mem0.hardLimit > 0) && ( n > mem0.hardLimit && !(n == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 27);
}
// MCC Label 28
if(!(mem0.hardLimit > 0) && ( !(n > mem0.hardLimit) && n == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
// MCC Label 29
if(!(mem0.hardLimit > 0) && ( !(n > mem0.hardLimit) && !(n == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 29);
}
if( mem0.hardLimit>0 && (n>mem0.hardLimit || n==0) ){
    n = mem0.hardLimit;
  }
  mem0.alarmThreshold = n;
  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
  AtomicStore(&mem0.nearlyFull, n>0 && n<=nUsed);
  
// ABS Label 9
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
sqlite3_mutex_leave(mem0.mutex);
  excess = sqlite3_memory_used() - n;
  
// ABS Label 30
if(excess < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// ROR Label 31
if((excess <= 0) != (excess > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((excess < 0) != (excess > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((excess >= 0) != (excess > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}
if( excess>0 ) { sqlite3_release_memory((int)(excess & 0x7fffffff));
}
  
// ABS Label 34
if(priorLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
return priorLimit;
}
void sqlite3_soft_heap_limit(int n){
  
// ABS Label 35
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// ROR Label 36
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
// ROR Label 37
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
// ROR Label 38
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
if( n<0 ) { n = 0;
}
  sqlite3_soft_heap_limit64(n);
}

/*
** Set the hard heap-size limit for the library. An argument of zero
** disables the hard heap limit.  A negative argument is a no-op used
** to obtain the return value without affecting the hard heap limit.
**
** The return value is the value of the hard heap limit just prior to
** calling this interface.
**
** Setting the hard heap limit will also activate the soft heap limit
** and constrain the soft heap limit to be no more than the hard heap
** limit.
*/
sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
#ifndef SQLITE_OMIT_AUTOINIT
  int rc = sqlite3_initialize();
  
// ABS Label 41
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
if( rc ) { return -1;
}
#endif
  
// ABS Label 39
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.hardLimit;
  
// ABS Label 42
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}

// ROR Label 43
if((n < 0) != (n >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((n > 0) != (n >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
// ROR Label 45
if((n <= 0) != (n >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
if( n>=0 ){
    mem0.hardLimit = n;
    
// ABS Label 46
if(mem0.alarmThreshold < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
// ABS Label 47
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// COR Label 48
if((n < mem0.alarmThreshold && mem0.alarmThreshold == 0) != (n < mem0.alarmThreshold || mem0.alarmThreshold == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 48);
}

// ROR Label 49
if((n <= mem0.alarmThreshold) != (n < mem0.alarmThreshold))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
// ROR Label 50
if((n > mem0.alarmThreshold) != (n < mem0.alarmThreshold))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
// ROR Label 51
if((n >= mem0.alarmThreshold) != (n < mem0.alarmThreshold))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
// ROR Label 52
if((mem0.alarmThreshold != 0) != (mem0.alarmThreshold == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}

// MCC Label 53
if(n < mem0.alarmThreshold && mem0.alarmThreshold == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(n < mem0.alarmThreshold && !(mem0.alarmThreshold == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(!(n < mem0.alarmThreshold) && mem0.alarmThreshold == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(n < mem0.alarmThreshold) && !(mem0.alarmThreshold == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
if( n<mem0.alarmThreshold || mem0.alarmThreshold==0 ){
      mem0.alarmThreshold = n;
    }
  }
  
// ABS Label 40
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
sqlite3_mutex_leave(mem0.mutex);
  
// ABS Label 57
if(priorLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
return priorLimit;
}


/*
** Initialize the memory allocation subsystem.
*/
int sqlite3MallocInit(void){
  int rc;
  
// ABS Label 58
if(sqlite3Config.m.xMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}

// ROR Label 59
if((sqlite3Config.m.xMalloc != 0) != (sqlite3Config.m.xMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
if( sqlite3GlobalConfig.m.xMalloc==0 ){
    sqlite3MemSetDefault();
  }
  mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);
  
// ABS Label 60
if(sqlite3Config.nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
// ABS Label 61
if(sqlite3Config.pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
// ABS Label 62
if(sqlite3Config.szPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// COR Label 63
if((sqlite3Config.pPage == 0 || sqlite3Config.szPage < 512 && sqlite3Config.nPage <= 0) != (sqlite3Config.pPage == 0 || sqlite3Config.szPage < 512 || sqlite3Config.nPage <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 63);
}
// COR Label 64
if((sqlite3Config.pPage == 0 && sqlite3Config.szPage < 512) != (sqlite3Config.pPage == 0 || sqlite3Config.szPage < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 64);
}

// ROR Label 65
if((sqlite3Config.pPage != 0) != (sqlite3Config.pPage == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
// ROR Label 66
if((sqlite3Config.szPage <= 512) != (sqlite3Config.szPage < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
// ROR Label 67
if((sqlite3Config.szPage > 512) != (sqlite3Config.szPage < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
// ROR Label 68
if((sqlite3Config.szPage >= 512) != (sqlite3Config.szPage < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
// ROR Label 69
if((sqlite3Config.nPage < 0) != (sqlite3Config.nPage <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((sqlite3Config.nPage > 0) != (sqlite3Config.nPage <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
// ROR Label 71
if((sqlite3Config.nPage >= 0) != (sqlite3Config.nPage <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}

// MCC Label 72
if(sqlite3Config.pPage == 0 && sqlite3Config.szPage < 512 && sqlite3Config.nPage <= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
// MCC Label 73
if(sqlite3Config.pPage == 0 && sqlite3Config.szPage < 512 && !(sqlite3Config.nPage <= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
// MCC Label 74
if(sqlite3Config.pPage == 0 && !(sqlite3Config.szPage < 512) && sqlite3Config.nPage <= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 74);
}
// MCC Label 75
if(sqlite3Config.pPage == 0 && !(sqlite3Config.szPage < 512) && !(sqlite3Config.nPage <= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 75);
}
// MCC Label 76
if(!(sqlite3Config.pPage == 0) && sqlite3Config.szPage < 512 && sqlite3Config.nPage <= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 76);
}
// MCC Label 77
if(!(sqlite3Config.pPage == 0) && sqlite3Config.szPage < 512 && !(sqlite3Config.nPage <= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 77);
}
// MCC Label 78
if(!(sqlite3Config.pPage == 0) && !(sqlite3Config.szPage < 512) && sqlite3Config.nPage <= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 78);
}
// MCC Label 79
if(!(sqlite3Config.pPage == 0) && !(sqlite3Config.szPage < 512) && !(sqlite3Config.nPage <= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 79);
}
if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512
      || sqlite3GlobalConfig.nPage<=0 ){
    sqlite3GlobalConfig.pPage = 0;
    sqlite3GlobalConfig.szPage = 0;
  }
  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);
  
// ABS Label 80
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}

// ROR Label 81
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
if( rc!=SQLITE_OK ) { memset(&mem0, 0, sizeof(mem0));
}
  
// ABS Label 82
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
return rc;
}

/*
** Return true if the heap is currently under memory pressure - in other
** words if the amount of heap used is close to the limit set by
** sqlite3_soft_heap_limit().
*/
int sqlite3HeapNearlyFull(void){
  return AtomicLoad(&mem0.nearlyFull);
}

/*
** Deinitialize the memory allocation subsystem.
*/
void sqlite3MallocEnd(void){
  
// ABS Label 83
if(sqlite3Config.m.xShutdown < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
if( sqlite3GlobalConfig.m.xShutdown ){
    sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData);
  }
  memset(&mem0, 0, sizeof(mem0));
}

/*
** Return the amount of memory currently checked out.
*/
sqlite3_int64 sqlite3_memory_used(void){
  sqlite3_int64 res, mx;
  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);
  
// ABS Label 85
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
return res;
}

/*
** Return the maximum amount of memory that has ever been
** checked out since either the beginning of this process
** or since the most recent reset.
*/
sqlite3_int64 sqlite3_memory_highwater(int resetFlag){
  sqlite3_int64 res, mx;
  
// ABS Label 86
if(resetFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);
  
// ABS Label 87
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
return mx;
}

/*
** Trigger the alarm 
*/
static void sqlite3MallocAlarm(int nByte){
  
// ABS Label 91
if(mem0.alarmThreshold < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}

// ROR Label 92
if((mem0.alarmThreshold < 0) != (mem0.alarmThreshold <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((mem0.alarmThreshold > 0) != (mem0.alarmThreshold <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
// ROR Label 94
if((mem0.alarmThreshold >= 0) != (mem0.alarmThreshold <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 94);
}
if( mem0.alarmThreshold<=0 ) { return;
}
  
// ABS Label 88
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
sqlite3_mutex_leave(mem0.mutex);
  
// ABS Label 89
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
sqlite3_release_memory(nByte);
  
// ABS Label 90
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}
sqlite3_mutex_enter(mem0.mutex);
}

/*
** Do a memory allocation with statistics and alarms.  Assume the
** lock is already held.
*/
static void mallocWithAlarm(int n, void **pp){
  void *p;
  int nFull;
  assert( sqlite3_mutex_held(mem0.mutex) );
  assert( n>0 );

  /* In Firefox (circa 2017-02-08), xRoundup() is remapped to an internal
  ** implementation of malloc_good_size(), which must be called in debug
  ** mode and specifically when the DMD "Dark Matter Detector" is enabled
  ** or else a crash results.  Hence, do not attempt to optimize out the
  ** following xRoundup() call. */
  nFull = sqlite3GlobalConfig.m.xRoundup(n);

  
// ABS Label 95
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}
sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);
  
// ABS Label 96
if(mem0.alarmThreshold < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}

// ROR Label 97
if((mem0.alarmThreshold <= 0) != (mem0.alarmThreshold > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
// ROR Label 98
if((mem0.alarmThreshold < 0) != (mem0.alarmThreshold > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
// ROR Label 99
if((mem0.alarmThreshold >= 0) != (mem0.alarmThreshold > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
if( mem0.alarmThreshold>0 ){
    sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
    
// ABS Label 100
if(mem0.alarmThreshold < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
// ABS Label 101
if(nUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}

// AOR Label 102
if(mem0.alarmThreshold / nFull != mem0.alarmThreshold - nFull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 102);
}
// AOR Label 103
if(mem0.alarmThreshold + nFull != mem0.alarmThreshold - nFull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 103);
}
// AOR Label 104
if(mem0.alarmThreshold * nFull != mem0.alarmThreshold - nFull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 104);
}

// ROR Label 105
if((nUsed < mem0.alarmThreshold - nFull) != (nUsed >= mem0.alarmThreshold - nFull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
// ROR Label 106
if((nUsed > mem0.alarmThreshold - nFull) != (nUsed >= mem0.alarmThreshold - nFull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
// ROR Label 107
if((nUsed <= mem0.alarmThreshold - nFull) != (nUsed >= mem0.alarmThreshold - nFull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
if( nUsed >= mem0.alarmThreshold - nFull ){
      AtomicStore(&mem0.nearlyFull, 1);
      
// ABS Label 108
if(nFull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
sqlite3MallocAlarm(nFull);
      
// ABS Label 109
if(mem0.hardLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
if( mem0.hardLimit ){
        nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);
        
// ABS Label 110
if(mem0.hardLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}
// ABS Label 111
if(nUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}

// AOR Label 112
if(mem0.hardLimit / nFull != mem0.hardLimit - nFull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 112);
}
// AOR Label 113
if(mem0.hardLimit + nFull != mem0.hardLimit - nFull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 113);
}
// AOR Label 114
if(mem0.hardLimit * nFull != mem0.hardLimit - nFull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 114);
}

// ROR Label 115
if((nUsed < mem0.hardLimit - nFull) != (nUsed >= mem0.hardLimit - nFull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
// ROR Label 116
if((nUsed > mem0.hardLimit - nFull) != (nUsed >= mem0.hardLimit - nFull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
// ROR Label 117
if((nUsed <= mem0.hardLimit - nFull) != (nUsed >= mem0.hardLimit - nFull))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
if( nUsed >= mem0.hardLimit - nFull ){
          *pp = 0;
          return;
        }
      }
    }else{
      AtomicStore(&mem0.nearlyFull, 0);
    }
  }
  p = sqlite3GlobalConfig.m.xMalloc(nFull);
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
  if( p==0 && mem0.alarmThreshold>0 ){
    sqlite3MallocAlarm(nFull);
    p = sqlite3GlobalConfig.m.xMalloc(nFull);
  }
#endif
  
// ABS Label 118
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}
if( p ){
    nFull = sqlite3MallocSize(p);
    
// ABS Label 119
if(nFull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}
sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);
    sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);
  }
  *pp = p;
}

/*
** Allocate memory.  This routine is like sqlite3_malloc() except that it
** assumes the memory subsystem has already been initialized.
*/
void *sqlite3Malloc(u64 n){
  void *p;
  
// ABS Label 120
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// COR Label 121
if((n == 0 && n >= 2147483392) != (n == 0 || n >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 121);
}

// ROR Label 122
if((n != 0) != (n == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
// ROR Label 123
if((n < 2147483392) != (n >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
// ROR Label 124
if((n > 2147483392) != (n >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}
// ROR Label 125
if((n <= 2147483392) != (n >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}

// MCC Label 126
if(n == 0 && n >= 2147483392 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 126);
}
// MCC Label 127
if(n == 0 && !(n >= 2147483392) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 127);
}
// MCC Label 128
if(!(n == 0) && n >= 2147483392 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 128);
}
// MCC Label 129
if(!(n == 0) && !(n >= 2147483392) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
if( n==0 || n>=0x7fffff00 ){
    /* A memory allocation of a number of bytes which is near the maximum
    ** signed integer value might cause an integer overflow inside of the
    ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, giving
    ** 255 bytes of overhead.  SQLite itself will never use anything near
    ** this amount.  The only way to reach the limit is with sqlite3_malloc() */
    p = 0;
  }else { 
// ABS Label 130
if(sqlite3Config.bMemstat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}
if( sqlite3GlobalConfig.bMemstat ){
    
// ABS Label 131
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}
sqlite3_mutex_enter(mem0.mutex);
    mallocWithAlarm((int)n, &p);
    
// ABS Label 132
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}
sqlite3_mutex_leave(mem0.mutex);
  }else{
    p = sqlite3GlobalConfig.m.xMalloc((int)n);
  };}

  assert( EIGHT_BYTE_ALIGNMENT(p) );  /* IMP: R-11148-40995 */
  
// ABS Label 133
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
return p;
}

/*
** This version of the memory allocation is for use by the application.
** First make sure the memory subsystem is initialized, then do the
** allocation.
*/
void *sqlite3_malloc(int n){
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return 0;
}
#endif
  return n<=0 ? 0 : sqlite3Malloc(n);
}
void *sqlite3_malloc64(sqlite3_uint64 n){
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return 0;
}
#endif
  return sqlite3Malloc(n);
}

/*
** TRUE if p is a lookaside memory allocation from db
*/
#ifndef SQLITE_OMIT_LOOKASIDE
static int isLookaside(sqlite3 *db, void *p){
  
// MCC Label 134
if(( ( (uptr)(p) >= (uptr)(db->lookaside.pStart) ) && ( (uptr)(p) < (uptr)(db->lookaside.pEnd) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 134);
}
// MCC Label 135
if(( ( (uptr)(p) >= (uptr)(db->lookaside.pStart) ) && ( !((uptr)(p) < (uptr)(db->lookaside.pEnd)) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
// MCC Label 136
if(( ( !((uptr)(p) >= (uptr)(db->lookaside.pStart)) ) && ( (uptr)(p) < (uptr)(db->lookaside.pEnd) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 136);
}
// MCC Label 137
if(( ( !((uptr)(p) >= (uptr)(db->lookaside.pStart)) ) && ( !((uptr)(p) < (uptr)(db->lookaside.pEnd)) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pEnd);
}
#else
#define isLookaside(A,B) 0
#endif

/*
** Return the size of a memory allocation previously obtained from
** sqlite3Malloc() or sqlite3_malloc().
*/
int sqlite3MallocSize(void *p){
  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
  return sqlite3GlobalConfig.m.xSize(p);
}
static int lookasideMallocSize(sqlite3 *db, void *p){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE    
  return p<db->lookaside.pMiddle ? db->lookaside.szTrue : LOOKASIDE_SMALL;
#else
  return db->lookaside.szTrue;
#endif  
}
int sqlite3DbMallocSize(sqlite3 *db, void *p){
  assert( p!=0 );
#ifdef SQLITE_DEBUG
  if( db==0 || !isLookaside(db,p) ){
    if( db==0 ){
      assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
      assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
    }else{
      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
    }
  }
#endif
  
// ABS Label 138
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}
if( db ){
    
// ROR Label 139
if((((uptr)p) <= (uptr)(db->lookaside.pEnd)) != (((uptr)p) < (uptr)(db->lookaside.pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
// ROR Label 140
if((((uptr)p) > (uptr)(db->lookaside.pEnd)) != (((uptr)p) < (uptr)(db->lookaside.pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 140);
}
// ROR Label 141
if((((uptr)p) >= (uptr)(db->lookaside.pEnd)) != (((uptr)p) < (uptr)(db->lookaside.pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 141);
}
if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
      
// ROR Label 142
if((((uptr)p) < (uptr)(db->lookaside.pMiddle)) != (((uptr)p) >= (uptr)(db->lookaside.pMiddle)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((((uptr)p) > (uptr)(db->lookaside.pMiddle)) != (((uptr)p) >= (uptr)(db->lookaside.pMiddle)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}
// ROR Label 144
if((((uptr)p) <= (uptr)(db->lookaside.pMiddle)) != (((uptr)p) >= (uptr)(db->lookaside.pMiddle)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){
        assert( sqlite3_mutex_held(db->mutex) );
        return LOOKASIDE_SMALL;
      }
#endif
      
// ROR Label 145
if((((uptr)p) < (uptr)(db->lookaside.pStart)) != (((uptr)p) >= (uptr)(db->lookaside.pStart)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
// ROR Label 146
if((((uptr)p) > (uptr)(db->lookaside.pStart)) != (((uptr)p) >= (uptr)(db->lookaside.pStart)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 146);
}
// ROR Label 147
if((((uptr)p) <= (uptr)(db->lookaside.pStart)) != (((uptr)p) >= (uptr)(db->lookaside.pStart)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 147);
}
if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){
        assert( sqlite3_mutex_held(db->mutex) );
        return db->lookaside.szTrue;
      }
    }
  }
  return sqlite3GlobalConfig.m.xSize(p);
}
sqlite3_uint64 sqlite3_msize(void *p){
  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
  return p ? sqlite3GlobalConfig.m.xSize(p) : 0;
}

/*
** Free memory previously obtained from sqlite3Malloc().
*/
void sqlite3_free(void *p){
  
// ABS Label 148
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}

// ROR Label 149
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
if( p==0 ) { return;  /* IMP: R-49053-54554 */
}
  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
  
// ABS Label 150
if(sqlite3Config.bMemstat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
if( sqlite3GlobalConfig.bMemstat ){
    
// ABS Label 151
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}
sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));
    sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);
    sqlite3GlobalConfig.m.xFree(p);
    
// ABS Label 153
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}
sqlite3_mutex_leave(mem0.mutex);
  }else{
    sqlite3GlobalConfig.m.xFree(p);
  }
}

/*
** Add the size of memory allocation "p" to the count in
** *db->pnBytesFreed.
*/
static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){
  *db->pnBytesFreed += sqlite3DbMallocSize(db,p);
}

/*
** Free memory that might be associated with a particular database
** connection.  Calling sqlite3DbFree(D,X) for X==0 is a harmless no-op.
** The sqlite3DbFreeNN(D,X) version requires that X be non-NULL.
*/
void sqlite3DbFreeNN(sqlite3 *db, void *p){
  assert( db==0 || sqlite3_mutex_held(db->mutex) );
  assert( p!=0 );
  
// ABS Label 156
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
if( db ){
    
// ABS Label 157
if(db->pnBytesFreed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
if( db->pnBytesFreed ){
      
// ABS Label 158
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// ABS Label 159
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
measureAllocationSize(db, p);
      return;
    }
    
// ROR Label 160
if((((uptr)p) <= (uptr)(db->lookaside.pEnd)) != (((uptr)p) < (uptr)(db->lookaside.pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((((uptr)p) > (uptr)(db->lookaside.pEnd)) != (((uptr)p) < (uptr)(db->lookaside.pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((((uptr)p) >= (uptr)(db->lookaside.pEnd)) != (((uptr)p) < (uptr)(db->lookaside.pEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
      
// ROR Label 163
if((((uptr)p) < (uptr)(db->lookaside.pMiddle)) != (((uptr)p) >= (uptr)(db->lookaside.pMiddle)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
// ROR Label 164
if((((uptr)p) > (uptr)(db->lookaside.pMiddle)) != (((uptr)p) >= (uptr)(db->lookaside.pMiddle)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
// ROR Label 165
if((((uptr)p) <= (uptr)(db->lookaside.pMiddle)) != (((uptr)p) >= (uptr)(db->lookaside.pMiddle)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){
        LookasideSlot *pBuf = (LookasideSlot*)p;
#ifdef SQLITE_DEBUG
        memset(p, 0xaa, LOOKASIDE_SMALL);  /* Trash freed content */
#endif
        pBuf->pNext = db->lookaside.pSmallFree;
        db->lookaside.pSmallFree = pBuf;
        return;
      }
#endif /* SQLITE_OMIT_TWOSIZE_LOOKASIDE */
      
// ROR Label 166
if((((uptr)p) < (uptr)(db->lookaside.pStart)) != (((uptr)p) >= (uptr)(db->lookaside.pStart)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((((uptr)p) > (uptr)(db->lookaside.pStart)) != (((uptr)p) >= (uptr)(db->lookaside.pStart)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((((uptr)p) <= (uptr)(db->lookaside.pStart)) != (((uptr)p) >= (uptr)(db->lookaside.pStart)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){
        LookasideSlot *pBuf = (LookasideSlot*)p;
#ifdef SQLITE_DEBUG
        memset(p, 0xaa, db->lookaside.szTrue);  /* Trash freed content */
#endif
        pBuf->pNext = db->lookaside.pFree;
        db->lookaside.pFree = pBuf;
        return;
      }
    }
  }
  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );
  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
  
// ABS Label 155
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}
sqlite3_free(p);
}
void sqlite3DbFree(sqlite3 *db, void *p){
  assert( db==0 || sqlite3_mutex_held(db->mutex) );
  
// ABS Label 169
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
if( p ) { 
// ABS Label 170
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// ABS Label 171
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}
sqlite3DbFreeNN(db, p);
}
}

/*
** Change the size of an existing memory allocation
*/
void *sqlite3Realloc(void *pOld, u64 nBytes){
  int nOld, nNew, nDiff;
  void *pNew;
  assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );
  assert( sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP) );
  
// ABS Label 172
if(pOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}

// ROR Label 173
if((pOld != 0) != (pOld == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
if( pOld==0 ){
    return sqlite3Malloc(nBytes); /* IMP: R-04300-56712 */
  }
  
// ABS Label 174
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ROR Label 175
if((nBytes != 0) != (nBytes == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
if( nBytes==0 ){
    
// ABS Label 176
if(pOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}
sqlite3_free(pOld); /* IMP: R-26507-47431 */
    return 0;
  }
  
// ABS Label 177
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}

// ROR Label 178
if((nBytes < 2147483392) != (nBytes >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}
// ROR Label 179
if((nBytes > 2147483392) != (nBytes >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}
// ROR Label 180
if((nBytes <= 2147483392) != (nBytes >= 2147483392))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 180);
}
if( nBytes>=0x7fffff00 ){
    /* The 0x7ffff00 limit term is explained in comments on sqlite3Malloc() */
    return 0;
  }
  nOld = sqlite3MallocSize(pOld);
  /* IMPLEMENTATION-OF: R-46199-30249 SQLite guarantees that the second
  ** argument to xRealloc is always a value returned by a prior call to
  ** xRoundup. */
  nNew = sqlite3GlobalConfig.m.xRoundup((int)nBytes);
  
// ABS Label 181
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
// ABS Label 182
if(nOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}

// ROR Label 183
if((nOld != nNew) != (nOld == nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
if( nOld==nNew ){
    pNew = pOld;
  }else { 
// ABS Label 184
if(sqlite3Config.bMemstat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}
if( sqlite3GlobalConfig.bMemstat ){
    sqlite3_int64 nUsed;
    
// ABS Label 185
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, (int)nBytes);
    nDiff = nNew - nOld;
    if( nDiff>0 && (nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)) >= 
          mem0.alarmThreshold-nDiff ){
      
// ABS Label 187
if(nDiff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
sqlite3MallocAlarm(nDiff);
      
// ABS Label 188
if(mem0.hardLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}
// ABS Label 189
if(nUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}

// AOR Label 190
if(mem0.hardLimit / nDiff != mem0.hardLimit - nDiff)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 190);
}
// AOR Label 191
if(mem0.hardLimit + nDiff != mem0.hardLimit - nDiff)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 191);
}
// AOR Label 192
if(mem0.hardLimit * nDiff != mem0.hardLimit - nDiff)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 192);
}

// COR Label 193
if((mem0.hardLimit > 0 || nUsed >= mem0.hardLimit - nDiff) != (mem0.hardLimit > 0 && nUsed >= mem0.hardLimit - nDiff))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 193);
}

// ROR Label 194
if((mem0.hardLimit <= 0) != (mem0.hardLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
// ROR Label 195
if((mem0.hardLimit < 0) != (mem0.hardLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}
// ROR Label 196
if((mem0.hardLimit >= 0) != (mem0.hardLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}
// ROR Label 197
if((nUsed < mem0.hardLimit - nDiff) != (nUsed >= mem0.hardLimit - nDiff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 197);
}
// ROR Label 198
if((nUsed > mem0.hardLimit - nDiff) != (nUsed >= mem0.hardLimit - nDiff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 198);
}
// ROR Label 199
if((nUsed <= mem0.hardLimit - nDiff) != (nUsed >= mem0.hardLimit - nDiff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}

// MCC Label 200
if(mem0.hardLimit > 0 && nUsed >= mem0.hardLimit - nDiff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 200);
}
// MCC Label 201
if(mem0.hardLimit > 0 && !(nUsed >= mem0.hardLimit - nDiff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 201);
}
// MCC Label 202
if(!(mem0.hardLimit > 0) && nUsed >= mem0.hardLimit - nDiff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}
// MCC Label 203
if(!(mem0.hardLimit > 0) && !(nUsed >= mem0.hardLimit - nDiff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 203);
}
if( mem0.hardLimit>0 && nUsed >= mem0.hardLimit - nDiff ){
        
// ABS Label 204
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}
sqlite3_mutex_leave(mem0.mutex);
        return 0;
      }
    }
    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
    if( pNew==0 && mem0.alarmThreshold>0 ){
      sqlite3MallocAlarm((int)nBytes);
      pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
    }
#endif
    
// ABS Label 205
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}
if( pNew ){
      nNew = sqlite3MallocSize(pNew);
      
// ABS Label 206
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
// ABS Label 207
if(nOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// AOR Label 208
if(nNew / nOld != nNew - nOld)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 208);
}
// AOR Label 209
if(nNew + nOld != nNew - nOld)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 209);
}
// AOR Label 210
if(nNew * nOld != nNew - nOld)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 210);
}
sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew-nOld);
    }
    
// ABS Label 186
if(mem0.mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
sqlite3_mutex_leave(mem0.mutex);
  }else{
    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
  };}

  assert( EIGHT_BYTE_ALIGNMENT(pNew) ); /* IMP: R-11148-40995 */
  
// ABS Label 211
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}
return pNew;
}

/*
** The public interface to sqlite3Realloc.  Make sure that the memory
** subsystem is initialized prior to invoking sqliteRealloc.
*/
void *sqlite3_realloc(void *pOld, int n){
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return 0;
}
#endif
  
// ABS Label 212
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// ROR Label 213
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 213);
}
// ROR Label 214
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 214);
}
// ROR Label 215
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 215);
}
if( n<0 ) { n = 0;  /* IMP: R-26507-47431 */
}
  return sqlite3Realloc(pOld, n);
}
void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return 0;
}
#endif
  return sqlite3Realloc(pOld, n);
}


/*
** Allocate and zero memory.
*/ 
void *sqlite3MallocZero(u64 n){
  void *p = sqlite3Malloc(n);
  
// ABS Label 216
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}
if( p ){
    
// ABS Label 217
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}
memset(p, 0, (size_t)n);
  }
  
// ABS Label 218
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}
return p;
}

/*
** Allocate and zero memory.  If the allocation fails, make
** the mallocFailed flag in the connection pointer.
*/
void *sqlite3DbMallocZero(sqlite3 *db, u64 n){
  void *p;
  testcase( db==0 );
  p = sqlite3DbMallocRaw(db, n);
  
// ABS Label 219
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
if( p ) { 
// ABS Label 220
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
memset(p, 0, (size_t)n);
}
  
// ABS Label 221
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
return p;
}


/* Finish the work of sqlite3DbMallocRawNN for the unusual and
** slower case when the allocation cannot be fulfilled using lookaside.
*/
static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){
  void *p;
  assert( db!=0 );
  p = sqlite3Malloc(n);
  if( !p ) { 
// ABS Label 222
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}
sqlite3OomFault(db);
}
  sqlite3MemdebugSetType(p, 
         (db->lookaside.bDisable==0) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP);
  
// ABS Label 223
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}
return p;
}

/*
** Allocate memory, either lookaside (if possible) or heap.  
** If the allocation fails, set the mallocFailed flag in
** the connection pointer.
**
** If db!=0 and db->mallocFailed is true (indicating a prior malloc
** failure on the same database connection) then always return 0.
** Hence for a particular database connection, once malloc starts
** failing, it fails consistently until mallocFailed is reset.
** This is an important assumption.  There are many places in the
** code that do things like this:
**
**         int *a = (int*)sqlite3DbMallocRaw(db, 100);
**         int *b = (int*)sqlite3DbMallocRaw(db, 200);
**         if( b ) a[10] = 9;
**
** In other words, if a subsequent malloc (ex: "b") worked, it is assumed
** that all prior mallocs (ex: "a") worked too.
**
** The sqlite3MallocRawNN() variant guarantees that the "db" parameter is
** not a NULL pointer.
*/
void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){
  void *p;
  
// ABS Label 224
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
if( db ) { return sqlite3DbMallocRawNN(db, n);
}
  p = sqlite3Malloc(n);
  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
  
// ABS Label 225
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}
return p;
}
void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){
#ifndef SQLITE_OMIT_LOOKASIDE
  LookasideSlot *pBuf;
  assert( db!=0 );
  assert( sqlite3_mutex_held(db->mutex) );
  assert( db->pnBytesFreed==0 );
  
// ABS Label 226
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}

// ROR Label 227
if((n <= db->lookaside.sz) != (n > db->lookaside.sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 227);
}
// ROR Label 228
if((n < db->lookaside.sz) != (n > db->lookaside.sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 228);
}
// ROR Label 229
if((n >= db->lookaside.sz) != (n > db->lookaside.sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 229);
}
if( n>db->lookaside.sz ){
    if( !db->lookaside.bDisable ){
      db->lookaside.anStat[1]++;      
    }else { 
// ABS Label 230
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}
if( db->mallocFailed ){
      return 0;
    };}

    return dbMallocRawFinish(db, n);
  }
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
  
// ABS Label 231
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ROR Label 232
if((n < 128) != (n <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
// ROR Label 233
if((n > 128) != (n <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 233);
}
// ROR Label 234
if((n >= 128) != (n <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}
if( n<=LOOKASIDE_SMALL ){
    if( (pBuf = db->lookaside.pSmallFree)!=0 ){
      db->lookaside.pSmallFree = pBuf->pNext;
      db->lookaside.anStat[0]++;
      return (void*)pBuf;
    }else { if( (pBuf = db->lookaside.pSmallInit)!=0 ){
      db->lookaside.pSmallInit = pBuf->pNext;
      db->lookaside.anStat[0]++;
      return (void*)pBuf;
    };}

  }
#endif
  if( (pBuf = db->lookaside.pFree)!=0 ){
    db->lookaside.pFree = pBuf->pNext;
    db->lookaside.anStat[0]++;
    return (void*)pBuf;
  }else { if( (pBuf = db->lookaside.pInit)!=0 ){
    db->lookaside.pInit = pBuf->pNext;
    db->lookaside.anStat[0]++;
    return (void*)pBuf;
  }else{
    db->lookaside.anStat[2]++;
  };}

#else
  assert( db!=0 );
  assert( sqlite3_mutex_held(db->mutex) );
  assert( db->pnBytesFreed==0 );
  if( db->mallocFailed ){
    return 0;
  }
#endif
  return dbMallocRawFinish(db, n);
}

/* Forward declaration */
static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n);

/*
** Resize the block of memory pointed to by p to n bytes. If the
** resize fails, set the mallocFailed flag in the connection object.
*/
void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){
  assert( db!=0 );
  
// ABS Label 235
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}

// ROR Label 236
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
if( p==0 ) { return sqlite3DbMallocRawNN(db, n);
}
  assert( sqlite3_mutex_held(db->mutex) );
  
// ROR Label 237
if((((uptr)p) <= (uptr)db->lookaside.pEnd) != (((uptr)p) < (uptr)db->lookaside.pEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
// ROR Label 238
if((((uptr)p) > (uptr)db->lookaside.pEnd) != (((uptr)p) < (uptr)db->lookaside.pEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
// ROR Label 239
if((((uptr)p) >= (uptr)db->lookaside.pEnd) != (((uptr)p) < (uptr)db->lookaside.pEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 239);
}
if( ((uptr)p)<(uptr)db->lookaside.pEnd ){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
    
// ROR Label 240
if((((uptr)p) < (uptr)db->lookaside.pMiddle) != (((uptr)p) >= (uptr)db->lookaside.pMiddle))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 240);
}
// ROR Label 241
if((((uptr)p) > (uptr)db->lookaside.pMiddle) != (((uptr)p) >= (uptr)db->lookaside.pMiddle))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((((uptr)p) <= (uptr)db->lookaside.pMiddle) != (((uptr)p) >= (uptr)db->lookaside.pMiddle))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
if( ((uptr)p)>=(uptr)db->lookaside.pMiddle ){
      
// ABS Label 243
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}

// ROR Label 244
if((n < 128) != (n <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}
// ROR Label 245
if((n > 128) != (n <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 245);
}
// ROR Label 246
if((n >= 128) != (n <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
if( n<=LOOKASIDE_SMALL ) { 
// ABS Label 247
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
return p;
}
    }else {
#endif
    
// ROR Label 248
if((((uptr)p) < (uptr)db->lookaside.pStart) != (((uptr)p) >= (uptr)db->lookaside.pStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 248);
}
// ROR Label 249
if((((uptr)p) > (uptr)db->lookaside.pStart) != (((uptr)p) >= (uptr)db->lookaside.pStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 249);
}
// ROR Label 250
if((((uptr)p) <= (uptr)db->lookaside.pStart) != (((uptr)p) >= (uptr)db->lookaside.pStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
if( ((uptr)p)>=(uptr)db->lookaside.pStart ){
      
// ABS Label 251
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ROR Label 252
if((n < db->lookaside.szTrue) != (n <= db->lookaside.szTrue))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((n > db->lookaside.szTrue) != (n <= db->lookaside.szTrue))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
// ROR Label 254
if((n >= db->lookaside.szTrue) != (n <= db->lookaside.szTrue))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
if( n<=db->lookaside.szTrue ) { 
// ABS Label 255
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}
return p;
}
    };}

  }
  return dbReallocFinish(db, p, n);
}
static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){
  void *pNew = 0;
  assert( db!=0 );
  assert( p!=0 );
  
// ROR Label 256
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 256);
}
if( db->mallocFailed==0 ){
    if( isLookaside(db, p) ){
      pNew = sqlite3DbMallocRawNN(db, n);
      
// ABS Label 257
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}
if( pNew ){
        
// ABS Label 258
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}
memcpy(pNew, p, lookasideMallocSize(db, p));
        
// ABS Label 259
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}

// ABS Label 260
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
sqlite3DbFree(db, p);
      }
    }else{
      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
      sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
      pNew = sqlite3Realloc(p, n);
      if( !pNew ){
        
// ABS Label 261
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}
sqlite3OomFault(db);
      }
      sqlite3MemdebugSetType(pNew,
            (db->lookaside.bDisable==0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));
    }
  }
  
// ABS Label 262
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}
return pNew;
}

/*
** Attempt to reallocate p.  If the reallocation fails, then free p
** and set the mallocFailed flag in the database connection.
*/
void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){
  void *pNew;
  pNew = sqlite3DbRealloc(db, p, n);
  if( !pNew ){
    
// ABS Label 263
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}

// ABS Label 264
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
sqlite3DbFree(db, p);
  }
  
// ABS Label 265
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}
return pNew;
}

/*
** Make a copy of a string in memory obtained from sqliteMalloc(). These 
** functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). This
** is because when memory debugging is turned on, these two functions are 
** called via macros that record the current file and line number in the
** ThreadData structure.
*/
char *sqlite3DbStrDup(sqlite3 *db, const char *z){
  char *zNew;
  size_t n;
  
// ABS Label 266
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}

// ROR Label 267
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
if( z==0 ){
    return 0;
  }
  n = strlen(z) + 1;
  zNew = sqlite3DbMallocRaw(db, n);
  
// ABS Label 268
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}
if( zNew ){
    
// ABS Label 269
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
memcpy(zNew, z, n);
  }
  
// ABS Label 270
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
return zNew;
}
char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){
  char *zNew;
  assert( db!=0 );
  assert( z!=0 || n==0 );
  assert( (n&0x7fffffff)==n );
  zNew = z ? sqlite3DbMallocRawNN(db, n+1) : 0;
  
// ABS Label 271
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
if( zNew ){
    memcpy(zNew, z, (size_t)n);
    zNew[n] = 0;
  }
  
// ABS Label 272
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
return zNew;
}

/*
** The text between zStart and zEnd represents a phrase within a larger
** SQL statement.  Make a copy of this phrase in space obtained form
** sqlite3DbMalloc().  Omit leading and trailing whitespace.
*/
char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
  int n;
  
// MCC Label 273
if(( sqlite3CtypeMap[(unsigned char)(zStart[0])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 273);
}
// MCC Label 274
if(( !(sqlite3CtypeMap[(unsigned char)(zStart[0])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 274);
}
while( sqlite3Isspace(zStart[0]) ) { zStart++;
};
// MCC Label 275
if(( sqlite3CtypeMap[(unsigned char)(zStart[0])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
// MCC Label 276
if(( !(sqlite3CtypeMap[(unsigned char)(zStart[0])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 276);
}

  n = (int)(zEnd - zStart);
  
// COR Label 277
if(((n > 0) || (sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1)) != ((n > 0) && (sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 277);
}

// MCC Label 278
if(( n > 0 ) && ( sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}
// MCC Label 279
if(( n > 0 ) && ( !(sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 279);
}
// MCC Label 280
if(( !(n > 0) ) && ( sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 280);
}
// MCC Label 281
if(( !(n > 0) ) && ( !(sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 281);
}
while( ALWAYS(n>0) && sqlite3Isspace(zStart[n-1]) ) { n--;
};
// COR Label 282
if(((n > 0) || (sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1)) != ((n > 0) && (sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 282);
}

// MCC Label 283
if(( n > 0 ) && ( sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}
// MCC Label 284
if(( n > 0 ) && ( !(sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 284);
}
// MCC Label 285
if(( !(n > 0) ) && ( sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 285);
}
// MCC Label 286
if(( !(n > 0) ) && ( !(sqlite3CtypeMap[(unsigned char)(zStart[n - 1])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 286);
}

  return sqlite3DbStrNDup(db, zStart, n);
}

/*
** Free any prior content in *pz and replace it with a copy of zNew.
*/
void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){
  
// ABS Label 287
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
sqlite3DbFree(db, *pz);
  *pz = sqlite3DbStrDup(db, zNew);
}

/*
** Call this routine to record the fact that an OOM (out-of-memory) error
** has happened.  This routine will set db->mallocFailed, and also
** temporarily disable the lookaside memory allocator and interrupt
** any running VDBEs.
*/
void sqlite3OomFault(sqlite3 *db){
  
// COR Label 288
if((db->mallocFailed == 0 || db->bBenignMalloc == 0) != (db->mallocFailed == 0 && db->bBenignMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 288);
}

// ROR Label 289
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}
// ROR Label 290
if((db->bBenignMalloc != 0) != (db->bBenignMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 290);
}

// MCC Label 291
if(db->mallocFailed == 0 && db->bBenignMalloc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 291);
}
// MCC Label 292
if(db->mallocFailed == 0 && !(db->bBenignMalloc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 292);
}
// MCC Label 293
if(!(db->mallocFailed == 0) && db->bBenignMalloc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 293);
}
// MCC Label 294
if(!(db->mallocFailed == 0) && !(db->bBenignMalloc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 294);
}
if( db->mallocFailed==0 && db->bBenignMalloc==0 ){
    db->mallocFailed = 1;
    
// ABS Label 295
if(db->nVdbeExec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ROR Label 296
if((db->nVdbeExec <= 0) != (db->nVdbeExec > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
// ROR Label 297
if((db->nVdbeExec < 0) != (db->nVdbeExec > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}
// ROR Label 298
if((db->nVdbeExec >= 0) != (db->nVdbeExec > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
if( db->nVdbeExec>0 ){
      AtomicStore(&db->u1.isInterrupted, 1);
    }
    DisableLookaside;
    
// ABS Label 299
if(db->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
if( db->pParse ){
      db->pParse->rc = SQLITE_NOMEM_BKPT;
    }
  }
}

/*
** This routine reactivates the memory allocator and clears the
** db->mallocFailed flag as necessary.
**
** The memory allocator is not restarted if there are running
** VDBEs.
*/
void sqlite3OomClear(sqlite3 *db){
  
// ABS Label 300
if(db->nVdbeExec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}

// COR Label 301
if((db->mallocFailed || db->nVdbeExec == 0) != (db->mallocFailed && db->nVdbeExec == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 301);
}

// ROR Label 302
if((db->nVdbeExec != 0) != (db->nVdbeExec == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}

// MCC Label 303
if(db->mallocFailed && db->nVdbeExec == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 303);
}
// MCC Label 304
if(db->mallocFailed && !(db->nVdbeExec == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 304);
}
// MCC Label 305
if(!(db->mallocFailed) && db->nVdbeExec == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 305);
}
// MCC Label 306
if(!(db->mallocFailed) && !(db->nVdbeExec == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 306);
}
if( db->mallocFailed && db->nVdbeExec==0 ){
    db->mallocFailed = 0;
    AtomicStore(&db->u1.isInterrupted, 0);
    assert( db->lookaside.bDisable>0 );
    EnableLookaside;
  }
}

/*
** Take actions at the end of an API call to deal with error codes.
*/
static SQLITE_NOINLINE int apiHandleError(sqlite3 *db, int rc){
  
// ABS Label 307
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}

// COR Label 308
if((db->mallocFailed && rc == (10 | (12 << 8))) != (db->mallocFailed || rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 308);
}

// ROR Label 309
if((rc != (10 | (12 << 8))) != (rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}

// MCC Label 310
if(db->mallocFailed && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 310);
}
// MCC Label 311
if(db->mallocFailed && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 311);
}
// MCC Label 312
if(!(db->mallocFailed) && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 312);
}
// MCC Label 313
if(!(db->mallocFailed) && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 313);
}
if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){
    
// ABS Label 314
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
sqlite3OomClear(db);
    
// ABS Label 315
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
sqlite3Error(db, SQLITE_NOMEM);
    return SQLITE_NOMEM_BKPT;
  }
  
// ABS Label 316
if(db->errMask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
// ABS Label 317
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}

// AOR Label 318
if(rc | db->errMask != rc & db->errMask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 318);
}
// AOR Label 319
if(rc ^ db->errMask != rc & db->errMask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 319);
}
return rc & db->errMask;
}

/*
** This function must be called before exiting any API function (i.e. 
** returning control to the user) that has called sqlite3_malloc or
** sqlite3_realloc.
**
** The returned value is normally a copy of the second argument to this
** function. However, if a malloc() failure has occurred since the previous
** invocation SQLITE_NOMEM is returned instead. 
**
** If an OOM as occurred, then the connection error-code (the value
** returned by sqlite3_errcode()) is set to SQLITE_NOMEM.
*/
int sqlite3ApiExit(sqlite3* db, int rc){
  /* If the db handle must hold the connection handle mutex here.
  ** Otherwise the read (and possible write) of db->mallocFailed 
  ** is unsafe, as is the call to sqlite3Error().
  */
  assert( db!=0 );
  assert( sqlite3_mutex_held(db->mutex) );
  
// ABS Label 320
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}

// COR Label 321
if((db->mallocFailed && rc) != (db->mallocFailed || rc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 321);
}

// MCC Label 322
if(db->mallocFailed && rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
// MCC Label 323
if(db->mallocFailed && !(rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
// MCC Label 324
if(!(db->mallocFailed) && rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 324);
}
// MCC Label 325
if(!(db->mallocFailed) && !(rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 325);
}
if( db->mallocFailed || rc ){
    return apiHandleError(db, rc);
  }
  
// ABS Label 326
if(db->errMask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
// ABS Label 327
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}

// AOR Label 328
if(rc | db->errMask != rc & db->errMask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 328);
}
// AOR Label 329
if(rc ^ db->errMask != rc & db->errMask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 329);
}
return rc & db->errMask;
}
