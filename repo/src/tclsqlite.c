/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** A TCL Interface to SQLite.  Append this file to sqlite3.c and
** compile the whole thing to build a TCL-enabled version of SQLite.
**
** Compile-time options:
**
**  -DTCLSH         Add a "main()" routine that works as a tclsh.
**
**  -DTCLSH_INIT_PROC=name
**
**                  Invoke name(interp) to initialize the Tcl interpreter.
**                  If name(interp) returns a non-NULL string, then run
**                  that string as a Tcl script to launch the application.
**                  If name(interp) returns NULL, then run the regular
**                  tclsh-emulator code.
*/
#ifdef TCLSH_INIT_PROC
# define TCLSH 1
#endif

/*
** If requested, include the SQLite compiler options file for MSVC.
*/
#if defined(INCLUDE_MSVC_H)
# include "msvc.h"
#endif

#if defined(INCLUDE_SQLITE_TCL_H)
# include "sqlite_tcl.h"
#else
# include "tcl.h"
# ifndef SQLITE_TCLAPI
#  define SQLITE_TCLAPI
# endif
#endif
#include <errno.h>

/*
** Some additional include files are needed if this file is not
** appended to the amalgamation.
*/
#ifndef SQLITE_AMALGAMATION
# include "sqlite3.h"
# include <stdlib.h>
# include <string.h>
# include <assert.h>
  typedef unsigned char u8;
#endif
#include <ctype.h>

/* Used to get the current process ID */
#if !defined(_WIN32)
# include <signal.h>
# include <unistd.h>
# define GETPID getpid
#elif !defined(_WIN32_WCE)
# ifndef SQLITE_AMALGAMATION
#  ifndef WIN32_LEAN_AND_MEAN
#   define WIN32_LEAN_AND_MEAN
#  endif
#  include <windows.h>
# endif
# include <io.h>
# define isatty(h) _isatty(h)
# define GETPID (int)GetCurrentProcessId
#endif

/*
 * Windows needs to know which symbols to export.  Unix does not.
 * BUILD_sqlite should be undefined for Unix.
 */
#ifdef BUILD_sqlite
#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT
#endif /* BUILD_sqlite */

#define NUM_PREPARED_STMTS 10
#define MAX_PREPARED_STMTS 100

/* Forward declaration */
typedef struct SqliteDb SqliteDb;

/*
** New SQL functions can be created as TCL scripts.  Each such function
** is described by an instance of the following structure.
**
** Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
** SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
** attempts to determine the type of the result based on the Tcl object.
** If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
** or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
** or SQLITE_FLOAT, then an attempt is made to return an integer or float
** value, falling back to float and then text if this is not possible.
*/
typedef struct SqlFunc SqlFunc;
struct SqlFunc {
  Tcl_Interp *interp;   /* The TCL interpret to execute the function */
  Tcl_Obj *pScript;     /* The Tcl_Obj representation of the script */
  SqliteDb *pDb;        /* Database connection that owns this function */
  int useEvalObjv;      /* True if it is safe to use Tcl_EvalObjv */
  int eType;            /* Type of value to return */
  char *zName;          /* Name of this function */
  SqlFunc *pNext;       /* Next function on the list of them all */
};

/*
** New collation sequences function can be created as TCL scripts.  Each such
** function is described by an instance of the following structure.
*/
typedef struct SqlCollate SqlCollate;
struct SqlCollate {
  Tcl_Interp *interp;   /* The TCL interpret to execute the function */
  char *zScript;        /* The script to be run */
  SqlCollate *pNext;    /* Next function on the list of them all */
};

/*
** Prepared statements are cached for faster execution.  Each prepared
** statement is described by an instance of the following structure.
*/
typedef struct SqlPreparedStmt SqlPreparedStmt;
struct SqlPreparedStmt {
  SqlPreparedStmt *pNext;  /* Next in linked list */
  SqlPreparedStmt *pPrev;  /* Previous on the list */
  sqlite3_stmt *pStmt;     /* The prepared statement */
  int nSql;                /* chars in zSql[] */
  const char *zSql;        /* Text of the SQL statement */
  int nParm;               /* Size of apParm array */
  Tcl_Obj **apParm;        /* Array of referenced object pointers */
};

typedef struct IncrblobChannel IncrblobChannel;

/*
** There is one instance of this structure for each SQLite database
** that has been opened by the SQLite TCL interface.
**
** If this module is built with SQLITE_TEST defined (to create the SQLite
** testfixture executable), then it may be configured to use either
** sqlite3_prepare_v2() or sqlite3_prepare() to prepare SQL statements.
** If SqliteDb.bLegacyPrepare is true, sqlite3_prepare() is used.
*/
struct SqliteDb {
  sqlite3 *db;               /* The "real" database structure. MUST BE FIRST */
  Tcl_Interp *interp;        /* The interpreter used for this database */
  char *zBusy;               /* The busy callback routine */
  char *zCommit;             /* The commit hook callback routine */
  char *zTrace;              /* The trace callback routine */
  char *zTraceV2;            /* The trace_v2 callback routine */
  char *zProfile;            /* The profile callback routine */
  char *zProgress;           /* The progress callback routine */
  char *zBindFallback;       /* Callback to invoke on a binding miss */
  char *zAuth;               /* The authorization callback routine */
  int disableAuth;           /* Disable the authorizer if it exists */
  char *zNull;               /* Text to substitute for an SQL NULL value */
  SqlFunc *pFunc;            /* List of SQL functions */
  Tcl_Obj *pUpdateHook;      /* Update hook script (if any) */
  Tcl_Obj *pPreUpdateHook;   /* Pre-update hook script (if any) */
  Tcl_Obj *pRollbackHook;    /* Rollback hook script (if any) */
  Tcl_Obj *pWalHook;         /* WAL hook script (if any) */
  Tcl_Obj *pUnlockNotify;    /* Unlock notify script (if any) */
  SqlCollate *pCollate;      /* List of SQL collation functions */
  int rc;                    /* Return code of most recent sqlite3_exec() */
  Tcl_Obj *pCollateNeeded;   /* Collation needed script */
  SqlPreparedStmt *stmtList; /* List of prepared statements*/
  SqlPreparedStmt *stmtLast; /* Last statement in the list */
  int maxStmt;               /* The next maximum number of stmtList */
  int nStmt;                 /* Number of statements in stmtList */
  IncrblobChannel *pIncrblob;/* Linked list of open incrblob channels */
  int nStep, nSort, nIndex;  /* Statistics for most recent operation */
  int nVMStep;               /* Another statistic for most recent operation */
  int nTransaction;          /* Number of nested [transaction] methods */
  int openFlags;             /* Flags used to open.  (SQLITE_OPEN_URI) */
#ifdef SQLITE_TEST
  int bLegacyPrepare;        /* True to use sqlite3_prepare() */
#endif
};

struct IncrblobChannel {
  sqlite3_blob *pBlob;      /* sqlite3 blob handle */
  SqliteDb *pDb;            /* Associated database connection */
  int iSeek;                /* Current seek offset */
  Tcl_Channel channel;      /* Channel identifier */
  IncrblobChannel *pNext;   /* Linked list of all open incrblob channels */
  IncrblobChannel *pPrev;   /* Linked list of all open incrblob channels */
};

/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/
static int strlen30(const char *z){
  
// ABS Label 7
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
const char *z2 = z;
  
// ABS Label 8
if(*z2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
while( *z2 ){ z2++; };
// ABS Label 9
if(*z2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

  
// AOR Label 10
if(1073741823 | (int)(z2 - z) != 1073741823 & (int)(z2 - z))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 10);
}
// AOR Label 11
if(1073741823 ^ (int)(z2 - z) != 1073741823 & (int)(z2 - z))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 11);
}
return 0x3fffffff & (int)(z2 - z);
}


#ifndef SQLITE_OMIT_INCRBLOB
/*
** Close all incrblob channels opened using database connection pDb.
** This is called when shutting down the database connection.
*/
static void closeIncrblobChannels(SqliteDb *pDb){
  IncrblobChannel *p;
  IncrblobChannel *pNext;

  p = pDb->pIncrblob;

// ABS Label 12
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
for(; p; p=pNext){
    pNext = p->pNext;

    /* Note: Calling unregister here call Tcl_Close on the incrblob channel,
    ** which deletes the IncrblobChannel structure at *p. So do not
    ** call Tcl_Free() here.
    */
    Tcl_UnregisterChannel(pDb->interp, p->channel);
  };
// ABS Label 13
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

}

/*
** Close an incremental blob channel.
*/
static int SQLITE_TCLAPI incrblobClose(
  ClientData instanceData,
  Tcl_Interp *interp
){
  IncrblobChannel *p = (IncrblobChannel *)instanceData;
  int rc = sqlite3_blob_close(p->pBlob);
  
// ABS Label 14
if(p->pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
sqlite3 *db = p->pDb->db;

  /* Remove the channel from the SqliteDb.pIncrblob list. */
  
// ABS Label 15
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
if( p->pNext ){
    p->pNext->pPrev = p->pPrev;
  }
  
// ABS Label 16
if(p->pPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
if( p->pPrev ){
    p->pPrev->pNext = p->pNext;
  }
  
// ABS Label 17
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
// ABS Label 18
if(p->pDb->pIncrblob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ROR Label 19
if((p->pDb->pIncrblob != p) != (p->pDb->pIncrblob == p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
if( p->pDb->pIncrblob==p ){
    p->pDb->pIncrblob = p->pNext;
  }

  /* Free the IncrblobChannel structure */
  Tcl_Free((char *)p);

  
// ABS Label 20
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}

// ROR Label 21
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
if( rc!=SQLITE_OK ){
    Tcl_SetResult(interp, (char *)sqlite3_errmsg(db), TCL_VOLATILE);
    return TCL_ERROR;
  }
  return TCL_OK;
}

/*
** Read data from an incremental blob channel.
*/
static int SQLITE_TCLAPI incrblobInput(
  ClientData instanceData,
  char *buf,
  int bufSize,
  int *errorCodePtr
){
  IncrblobChannel *p = (IncrblobChannel *)instanceData;
  
// ABS Label 22
if(bufSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
int nRead = bufSize;         /* Number of bytes to read */
  int nBlob;                   /* Total size of the blob */
  int rc;                      /* sqlite error code */

  nBlob = sqlite3_blob_bytes(p->pBlob);
  
// ABS Label 23
if(nBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}

// ROR Label 24
if(((p->iSeek + nRead) <= nBlob) != ((p->iSeek + nRead) > nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
// ROR Label 25
if(((p->iSeek + nRead) < nBlob) != ((p->iSeek + nRead) > nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
// ROR Label 26
if(((p->iSeek + nRead) >= nBlob) != ((p->iSeek + nRead) > nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
if( (p->iSeek+nRead)>nBlob ){
    nRead = nBlob-p->iSeek;
  }
  
// ABS Label 27
if(nRead < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}

// ROR Label 28
if((nRead < 0) != (nRead <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((nRead > 0) != (nRead <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((nRead >= 0) != (nRead <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
if( nRead<=0 ){
    return 0;
  }

  rc = sqlite3_blob_read(p->pBlob, (void *)buf, nRead, p->iSeek);
  
// ABS Label 31
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// ROR Label 32
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
if( rc!=SQLITE_OK ){
    *errorCodePtr = rc;
    return -1;
  }

  p->iSeek += nRead;
  
// ABS Label 33
if(nRead < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
return nRead;
}

/*
** Write data to an incremental blob channel.
*/
static int SQLITE_TCLAPI incrblobOutput(
  ClientData instanceData,
  CONST char *buf,
  int toWrite,
  int *errorCodePtr
){
  IncrblobChannel *p = (IncrblobChannel *)instanceData;
  
// ABS Label 34
if(toWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
int nWrite = toWrite;        /* Number of bytes to write */
  int nBlob;                   /* Total size of the blob */
  int rc;                      /* sqlite error code */

  nBlob = sqlite3_blob_bytes(p->pBlob);
  
// ABS Label 35
if(nBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// ROR Label 36
if(((p->iSeek + nWrite) <= nBlob) != ((p->iSeek + nWrite) > nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
// ROR Label 37
if(((p->iSeek + nWrite) < nBlob) != ((p->iSeek + nWrite) > nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
// ROR Label 38
if(((p->iSeek + nWrite) >= nBlob) != ((p->iSeek + nWrite) > nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
if( (p->iSeek+nWrite)>nBlob ){
    *errorCodePtr = EINVAL;
    return -1;
  }
  
// ABS Label 39
if(nWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}

// ROR Label 40
if((nWrite < 0) != (nWrite <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
// ROR Label 41
if((nWrite > 0) != (nWrite <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
// ROR Label 42
if((nWrite >= 0) != (nWrite <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
if( nWrite<=0 ){
    return 0;
  }

  rc = sqlite3_blob_write(p->pBlob, (void *)buf, nWrite, p->iSeek);
  
// ABS Label 43
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// ROR Label 44
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
if( rc!=SQLITE_OK ){
    *errorCodePtr = EIO;
    return -1;
  }

  p->iSeek += nWrite;
  
// ABS Label 45
if(nWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
return nWrite;
}

/*
** Seek an incremental blob channel.
*/
static int SQLITE_TCLAPI incrblobSeek(
  ClientData instanceData,
  long offset,
  int seekMode,
  int *errorCodePtr
){
  IncrblobChannel *p = (IncrblobChannel *)instanceData;

  switch( seekMode ){
    case SEEK_SET:
      p->iSeek = offset;
      break;
    case SEEK_CUR:
      p->iSeek += offset;
      break;
    case SEEK_END:
      p->iSeek = sqlite3_blob_bytes(p->pBlob) + offset;
      break;

    default: assert(!"Bad seekMode");
  }

  
// ABS Label 46
if(p->iSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
return p->iSeek;
}


static void SQLITE_TCLAPI incrblobWatch(
  ClientData instanceData,
  int mode
){
  /* NO-OP */
}
static int SQLITE_TCLAPI incrblobHandle(
  ClientData instanceData,
  int dir,
  ClientData *hPtr
){
  return TCL_ERROR;
}

static Tcl_ChannelType IncrblobChannelType = {
  "incrblob",                        /* typeName                             */
  TCL_CHANNEL_VERSION_2,             /* version                              */
  incrblobClose,                     /* closeProc                            */
  incrblobInput,                     /* inputProc                            */
  incrblobOutput,                    /* outputProc                           */
  incrblobSeek,                      /* seekProc                             */
  0,                                 /* setOptionProc                        */
  0,                                 /* getOptionProc                        */
  incrblobWatch,                     /* watchProc (this is a no-op)          */
  incrblobHandle,                    /* getHandleProc (always returns error) */
  0,                                 /* close2Proc                           */
  0,                                 /* blockModeProc                        */
  0,                                 /* flushProc                            */
  0,                                 /* handlerProc                          */
  0,                                 /* wideSeekProc                         */
};

/*
** Create a new incrblob channel.
*/
static int createIncrblobChannel(
  Tcl_Interp *interp,
  SqliteDb *pDb,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite_int64 iRow,
  int isReadonly
){
  IncrblobChannel *p;
  
// ABS Label 47
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}
sqlite3 *db = pDb->db;
  sqlite3_blob *pBlob;
  int rc;
  int flags = TCL_READABLE|(isReadonly ? 0 : TCL_WRITABLE);

  /* This variable is used to name the channels: "incrblob_[incr count]" */
  static int count = 0;
  char zChannel[64];

  rc = sqlite3_blob_open(db, zDb, zTable, zColumn, iRow, !isReadonly, &pBlob);
  
// ABS Label 48
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// ROR Label 49
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
if( rc!=SQLITE_OK ){
    Tcl_SetResult(interp, (char *)sqlite3_errmsg(pDb->db), TCL_VOLATILE);
    return TCL_ERROR;
  }

  p = (IncrblobChannel *)Tcl_Alloc(sizeof(IncrblobChannel));
  p->iSeek = 0;
  p->pBlob = pBlob;

  sqlite3_snprintf(sizeof(zChannel), zChannel, "incrblob_%d", ++count);
  p->channel = Tcl_CreateChannel(&IncrblobChannelType, zChannel, p, flags);
  Tcl_RegisterChannel(interp, p->channel);

  /* Link the new channel into the SqliteDb.pIncrblob list. */
  p->pNext = pDb->pIncrblob;
  p->pPrev = 0;
  
// ABS Label 50
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
if( p->pNext ){
    p->pNext->pPrev = p;
  }
  pDb->pIncrblob = p;
  p->pDb = pDb;

  Tcl_SetResult(interp, (char *)Tcl_GetChannelName(p->channel), TCL_VOLATILE);
  return TCL_OK;
}
#else  /* else clause for "#ifndef SQLITE_OMIT_INCRBLOB" */
  #define closeIncrblobChannels(pDb)
#endif

/*
** Look at the script prefix in pCmd.  We will be executing this script
** after first appending one or more arguments.  This routine analyzes
** the script to see if it is safe to use Tcl_EvalObjv() on the script
** rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much
** faster.
**
** Scripts that are safe to use with Tcl_EvalObjv() consists of a
** command name followed by zero or more arguments with no [...] or $
** or {...} or ; to be seen anywhere.  Most callback scripts consist
** of just a single procedure name and they meet this requirement.
*/
static int safeToUseEvalObjv(Tcl_Interp *interp, Tcl_Obj *pCmd){
  /* We could try to do something with Tcl_Parse().  But we will instead
  ** just do a search for forbidden characters.  If any of the forbidden
  ** characters appear in pCmd, we will report the string as unsafe.
  */
  const char *z;
  int n;
  z = Tcl_GetStringFromObj(pCmd, &n);
  while( n-- > 0 ){
    int c = *(z++);
    
// ABS Label 51
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// COR Label 52
if((c == '$' || c == '[' && c == ';') != (c == '$' || c == '[' || c == ';'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 52);
}
// COR Label 53
if((c == '$' && c == '[') != (c == '$' || c == '['))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 53);
}

// ROR Label 54
if((c != '$') != (c == '$'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
// ROR Label 55
if((c != '[') != (c == '['))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
// ROR Label 56
if((c != ';') != (c == ';'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}

// MCC Label 57
if(c == '$' && c == '[' && c == ';' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
// MCC Label 58
if(c == '$' && c == '[' && !(c == ';') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 58);
}
// MCC Label 59
if(c == '$' && !(c == '[') && c == ';' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if(c == '$' && !(c == '[') && !(c == ';') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!(c == '$') && c == '[' && c == ';' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(c == '$') && c == '[' && !(c == ';') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
// MCC Label 63
if(!(c == '$') && !(c == '[') && c == ';' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 63);
}
// MCC Label 64
if(!(c == '$') && !(c == '[') && !(c == ';') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 64);
}
if( c=='$' || c=='[' || c==';' ) return 0;
  };
  return 1;
}

/*
** Find an SqlFunc structure with the given name.  Or create a new
** one if an existing one cannot be found.  Return a pointer to the
** structure.
*/
static SqlFunc *findSqlFunc(SqliteDb *pDb, const char *zName){
  SqlFunc *p, *pNew;
  int nName = strlen30(zName);
  pNew = (SqlFunc*)Tcl_Alloc( sizeof(*pNew) + nName + 1 );
  pNew->zName = (char*)&pNew[1];
  memcpy(pNew->zName, zName, nName+1);
  p = pDb->pFunc;

// ABS Label 65
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
for(; p; p=p->pNext){
    if( sqlite3_stricmp(p->zName, pNew->zName)==0 ){
      Tcl_Free((char*)pNew);
      
// ABS Label 67
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
return p;
    }
  };
// ABS Label 66
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}

  pNew->interp = pDb->interp;
  pNew->pDb = pDb;
  pNew->pScript = 0;
  pNew->pNext = pDb->pFunc;
  pDb->pFunc = pNew;
  
// ABS Label 68
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}
return pNew;
}

/*
** Free a single SqlPreparedStmt object.
*/
static void dbFreeStmt(SqlPreparedStmt *pStmt){
#ifdef SQLITE_TEST
  if( sqlite3_sql(pStmt->pStmt)==0 ){
    Tcl_Free((char *)pStmt->zSql);
  }
#endif
  
// ABS Label 69
if(pStmt->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}
sqlite3_finalize(pStmt->pStmt);
  Tcl_Free((char *)pStmt);
}

/*
** Finalize and free a list of prepared statements
*/
static void flushStmtCache(SqliteDb *pDb){
  SqlPreparedStmt *pPreStmt;
  SqlPreparedStmt *pNext;

  pPreStmt = pDb->stmtList;

// ABS Label 70
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}
for(; pPreStmt; pPreStmt=pNext){
    pNext = pPreStmt->pNext;
    
// ABS Label 72
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
dbFreeStmt(pPreStmt);
  };
// ABS Label 71
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}

  pDb->nStmt = 0;
  pDb->stmtLast = 0;
  pDb->stmtList = 0;
}

/*
** TCL calls this procedure when an sqlite3 database command is
** deleted.
*/
static void SQLITE_TCLAPI DbDeleteCmd(void *db){
  SqliteDb *pDb = (SqliteDb*)db;
  
// ABS Label 73
if(pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
flushStmtCache(pDb);
  
// ABS Label 74
if(pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}
closeIncrblobChannels(pDb);
  
// ABS Label 75
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}
sqlite3_close(pDb->db);
  
// ABS Label 76
if(pDb->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
while( pDb->pFunc ){
    
// ABS Label 78
if(pDb->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
SqlFunc *pFunc = pDb->pFunc;
    pDb->pFunc = pFunc->pNext;
    assert( pFunc->pDb==pDb );
    Tcl_DecrRefCount(pFunc->pScript);
    Tcl_Free((char*)pFunc);
  };
// ABS Label 77
if(pDb->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

  
// ABS Label 82
if(pDb->pCollate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
while( pDb->pCollate ){
    
// ABS Label 84
if(pDb->pCollate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
SqlCollate *pCollate = pDb->pCollate;
    pDb->pCollate = pCollate->pNext;
    Tcl_Free((char*)pCollate);
  };
// ABS Label 83
if(pDb->pCollate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}

  
// ABS Label 85
if(pDb->zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
if( pDb->zBusy ){
    
// ABS Label 86
if(pDb->zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
Tcl_Free(pDb->zBusy);
  }
  
// ABS Label 87
if(pDb->zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
if( pDb->zTrace ){
    
// ABS Label 88
if(pDb->zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
Tcl_Free(pDb->zTrace);
  }
  
// ABS Label 89
if(pDb->zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
if( pDb->zTraceV2 ){
    
// ABS Label 90
if(pDb->zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}
Tcl_Free(pDb->zTraceV2);
  }
  
// ABS Label 91
if(pDb->zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
if( pDb->zProfile ){
    
// ABS Label 92
if(pDb->zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}
Tcl_Free(pDb->zProfile);
  }
  
// ABS Label 93
if(pDb->zBindFallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
if( pDb->zBindFallback ){
    
// ABS Label 94
if(pDb->zBindFallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}
Tcl_Free(pDb->zBindFallback);
  }
  
// ABS Label 95
if(pDb->zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}
if( pDb->zAuth ){
    
// ABS Label 96
if(pDb->zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}
Tcl_Free(pDb->zAuth);
  }
  
// ABS Label 97
if(pDb->zNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}
if( pDb->zNull ){
    
// ABS Label 98
if(pDb->zNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
Tcl_Free(pDb->zNull);
  }
  if( pDb->pUpdateHook ){
    Tcl_DecrRefCount(pDb->pUpdateHook);
  }
  if( pDb->pPreUpdateHook ){
    Tcl_DecrRefCount(pDb->pPreUpdateHook);
  }
  if( pDb->pRollbackHook ){
    Tcl_DecrRefCount(pDb->pRollbackHook);
  }
  if( pDb->pWalHook ){
    Tcl_DecrRefCount(pDb->pWalHook);
  }
  if( pDb->pCollateNeeded ){
    Tcl_DecrRefCount(pDb->pCollateNeeded);
  }
  Tcl_Free((char*)pDb);
}

/*
** This routine is called when a database file is locked while trying
** to execute SQL.
*/
static int DbBusyHandler(void *cd, int nTries){
  SqliteDb *pDb = (SqliteDb*)cd;
  int rc;
  char zVal[30];

  
// ABS Label 99
if(nTries < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
sqlite3_snprintf(sizeof(zVal), zVal, "%d", nTries);
  rc = Tcl_VarEval(pDb->interp, pDb->zBusy, " ", zVal, (char*)0);
  if( rc!=TCL_OK || atoi(Tcl_GetStringResult(pDb->interp)) ){
    return 0;
  }
  return 1;
}

#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
/*
** This routine is invoked as the 'progress callback' for the database.
*/
static int DbProgressHandler(void *cd){
  SqliteDb *pDb = (SqliteDb*)cd;
  int rc;

  assert( pDb->zProgress );
  rc = Tcl_Eval(pDb->interp, pDb->zProgress);
  if( rc!=TCL_OK || atoi(Tcl_GetStringResult(pDb->interp)) ){
    return 1;
  }
  return 0;
}
#endif

#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT) && \
    !defined(SQLITE_OMIT_DEPRECATED)
/*
** This routine is called by the SQLite trace handler whenever a new
** block of SQL is executed.  The TCL script in pDb->zTrace is executed.
*/
static void DbTraceHandler(void *cd, const char *zSql){
  SqliteDb *pDb = (SqliteDb*)cd;
  Tcl_DString str;

  Tcl_DStringInit(&str);
  Tcl_DStringAppend(&str, pDb->zTrace, -1);
  Tcl_DStringAppendElement(&str, zSql);
  Tcl_Eval(pDb->interp, Tcl_DStringValue(&str));
  Tcl_DStringFree(&str);
  Tcl_ResetResult(pDb->interp);
}
#endif

#ifndef SQLITE_OMIT_TRACE
/*
** This routine is called by the SQLite trace_v2 handler whenever a new
** supported event is generated.  Unsupported event types are ignored.
** The TCL script in pDb->zTraceV2 is executed, with the arguments for
** the event appended to it (as list elements).
*/
static int DbTraceV2Handler(
  unsigned type, /* One of the SQLITE_TRACE_* event types. */
  void *cd,      /* The original context data pointer. */
  void *pd,      /* Primary event data, depends on event type. */
  void *xd       /* Extra event data, depends on event type. */
){
  SqliteDb *pDb = (SqliteDb*)cd;
  Tcl_Obj *pCmd;

  switch( type ){
    case SQLITE_TRACE_STMT: {
      sqlite3_stmt *pStmt = (sqlite3_stmt *)pd;
      char *zSql = (char *)xd;

      pCmd = Tcl_NewStringObj(pDb->zTraceV2, -1);
      Tcl_IncrRefCount(pCmd);
      Tcl_ListObjAppendElement(pDb->interp, pCmd,
                               Tcl_NewWideIntObj((Tcl_WideInt)pStmt));
      Tcl_ListObjAppendElement(pDb->interp, pCmd,
                               Tcl_NewStringObj(zSql, -1));
      Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);
      Tcl_DecrRefCount(pCmd);
      Tcl_ResetResult(pDb->interp);
      break;
    }
    case SQLITE_TRACE_PROFILE: {
      sqlite3_stmt *pStmt = (sqlite3_stmt *)pd;
      
// ABS Label 101
if(*(sqlite3_int64 *)xd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
sqlite3_int64 ns = *(sqlite3_int64*)xd;

      pCmd = Tcl_NewStringObj(pDb->zTraceV2, -1);
      Tcl_IncrRefCount(pCmd);
      Tcl_ListObjAppendElement(pDb->interp, pCmd,
                               Tcl_NewWideIntObj((Tcl_WideInt)pStmt));
      Tcl_ListObjAppendElement(pDb->interp, pCmd,
                               Tcl_NewWideIntObj((Tcl_WideInt)ns));
      Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);
      Tcl_DecrRefCount(pCmd);
      Tcl_ResetResult(pDb->interp);
      break;
    }
    case SQLITE_TRACE_ROW: {
      sqlite3_stmt *pStmt = (sqlite3_stmt *)pd;

      pCmd = Tcl_NewStringObj(pDb->zTraceV2, -1);
      Tcl_IncrRefCount(pCmd);
      Tcl_ListObjAppendElement(pDb->interp, pCmd,
                               Tcl_NewWideIntObj((Tcl_WideInt)pStmt));
      Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);
      Tcl_DecrRefCount(pCmd);
      Tcl_ResetResult(pDb->interp);
      break;
    }
    case SQLITE_TRACE_CLOSE: {
      sqlite3 *db = (sqlite3 *)pd;

      pCmd = Tcl_NewStringObj(pDb->zTraceV2, -1);
      Tcl_IncrRefCount(pCmd);
      Tcl_ListObjAppendElement(pDb->interp, pCmd,
                               Tcl_NewWideIntObj((Tcl_WideInt)db));
      Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);
      Tcl_DecrRefCount(pCmd);
      Tcl_ResetResult(pDb->interp);
      break;
    }
  }
  return SQLITE_OK;
}
#endif

#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT) && \
    !defined(SQLITE_OMIT_DEPRECATED)
/*
** This routine is called by the SQLite profile handler after a statement
** SQL has executed.  The TCL script in pDb->zProfile is evaluated.
*/
static void DbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm){
  SqliteDb *pDb = (SqliteDb*)cd;
  Tcl_DString str;
  char zTm[100];

  
// ABS Label 102
if(tm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
sqlite3_snprintf(sizeof(zTm)-1, zTm, "%lld", tm);
  Tcl_DStringInit(&str);
  Tcl_DStringAppend(&str, pDb->zProfile, -1);
  Tcl_DStringAppendElement(&str, zSql);
  Tcl_DStringAppendElement(&str, zTm);
  Tcl_Eval(pDb->interp, Tcl_DStringValue(&str));
  Tcl_DStringFree(&str);
  Tcl_ResetResult(pDb->interp);
}
#endif

/*
** This routine is called when a transaction is committed.  The
** TCL script in pDb->zCommit is executed.  If it returns non-zero or
** if it throws an exception, the transaction is rolled back instead
** of being committed.
*/
static int DbCommitHandler(void *cd){
  SqliteDb *pDb = (SqliteDb*)cd;
  int rc;

  rc = Tcl_Eval(pDb->interp, pDb->zCommit);
  if( rc!=TCL_OK || atoi(Tcl_GetStringResult(pDb->interp)) ){
    return 1;
  }
  return 0;
}

static void DbRollbackHandler(void *clientData){
  SqliteDb *pDb = (SqliteDb*)clientData;
  assert(pDb->pRollbackHook);
  if( TCL_OK!=Tcl_EvalObjEx(pDb->interp, pDb->pRollbackHook, 0) ){
    Tcl_BackgroundError(pDb->interp);
  }
}

/*
** This procedure handles wal_hook callbacks.
*/
static int DbWalHandler(
  void *clientData,
  sqlite3 *db,
  const char *zDb,
  int nEntry
){
  int ret = SQLITE_OK;
  Tcl_Obj *p;
  SqliteDb *pDb = (SqliteDb*)clientData;
  Tcl_Interp *interp = pDb->interp;
  assert(pDb->pWalHook);

  assert( db==pDb->db );
  p = Tcl_DuplicateObj(pDb->pWalHook);
  Tcl_IncrRefCount(p);
  Tcl_ListObjAppendElement(interp, p, Tcl_NewStringObj(zDb, -1));
  Tcl_ListObjAppendElement(interp, p, Tcl_NewIntObj(nEntry));
  if( TCL_OK!=Tcl_EvalObjEx(interp, p, 0)
   || TCL_OK!=Tcl_GetIntFromObj(interp, Tcl_GetObjResult(interp), &ret)
  ){
    Tcl_BackgroundError(interp);
  }
  Tcl_DecrRefCount(p);

  
// ABS Label 106
if(ret < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}
return ret;
}

#if defined(SQLITE_TEST) && defined(SQLITE_ENABLE_UNLOCK_NOTIFY)
static void setTestUnlockNotifyVars(Tcl_Interp *interp, int iArg, int nArg){
  char zBuf[64];
  sqlite3_snprintf(sizeof(zBuf), zBuf, "%d", iArg);
  Tcl_SetVar(interp, "sqlite_unlock_notify_arg", zBuf, TCL_GLOBAL_ONLY);
  sqlite3_snprintf(sizeof(zBuf), zBuf, "%d", nArg);
  Tcl_SetVar(interp, "sqlite_unlock_notify_argcount", zBuf, TCL_GLOBAL_ONLY);
}
#else
# define setTestUnlockNotifyVars(x,y,z)
#endif

#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
static void DbUnlockNotify(void **apArg, int nArg){
  int i;
  for(i=0; i<nArg; i++){
    const int flags = (TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT);
    SqliteDb *pDb = (SqliteDb *)apArg[i];
    setTestUnlockNotifyVars(pDb->interp, i, nArg);
    assert( pDb->pUnlockNotify);
    Tcl_EvalObjEx(pDb->interp, pDb->pUnlockNotify, flags);
    Tcl_DecrRefCount(pDb->pUnlockNotify);
    pDb->pUnlockNotify = 0;
  }
}
#endif

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** Pre-update hook callback.
*/
static void DbPreUpdateHandler(
  void *p,
  sqlite3 *db,
  int op,
  const char *zDb,
  const char *zTbl,
  sqlite_int64 iKey1,
  sqlite_int64 iKey2
){
  SqliteDb *pDb = (SqliteDb *)p;
  Tcl_Obj *pCmd;
  static const char *azStr[] = {"DELETE", "INSERT", "UPDATE"};

  assert( (SQLITE_DELETE-1)/9 == 0 );
  assert( (SQLITE_INSERT-1)/9 == 1 );
  assert( (SQLITE_UPDATE-1)/9 == 2 );
  assert( pDb->pPreUpdateHook );
  assert( db==pDb->db );
  assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );

  pCmd = Tcl_DuplicateObj(pDb->pPreUpdateHook);
  Tcl_IncrRefCount(pCmd);
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(azStr[(op-1)/9], -1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(zDb, -1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(zTbl, -1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewWideIntObj(iKey1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewWideIntObj(iKey2));
  Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);
  Tcl_DecrRefCount(pCmd);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

static void DbUpdateHandler(
  void *p,
  int op,
  const char *zDb,
  const char *zTbl,
  sqlite_int64 rowid
){
  SqliteDb *pDb = (SqliteDb *)p;
  Tcl_Obj *pCmd;
  static const char *azStr[] = {"DELETE", "INSERT", "UPDATE"};

  assert( (SQLITE_DELETE-1)/9 == 0 );
  assert( (SQLITE_INSERT-1)/9 == 1 );
  assert( (SQLITE_UPDATE-1)/9 == 2 );

  assert( pDb->pUpdateHook );
  assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );

  pCmd = Tcl_DuplicateObj(pDb->pUpdateHook);
  Tcl_IncrRefCount(pCmd);
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(azStr[(op-1)/9], -1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(zDb, -1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewStringObj(zTbl, -1));
  Tcl_ListObjAppendElement(0, pCmd, Tcl_NewWideIntObj(rowid));
  Tcl_EvalObjEx(pDb->interp, pCmd, TCL_EVAL_DIRECT);
  Tcl_DecrRefCount(pCmd);
}

static void tclCollateNeeded(
  void *pCtx,
  sqlite3 *db,
  int enc,
  const char *zName
){
  SqliteDb *pDb = (SqliteDb *)pCtx;
  Tcl_Obj *pScript = Tcl_DuplicateObj(pDb->pCollateNeeded);
  Tcl_IncrRefCount(pScript);
  Tcl_ListObjAppendElement(0, pScript, Tcl_NewStringObj(zName, -1));
  Tcl_EvalObjEx(pDb->interp, pScript, 0);
  Tcl_DecrRefCount(pScript);
}

/*
** This routine is called to evaluate an SQL collation function implemented
** using TCL script.
*/
static int tclSqlCollate(
  void *pCtx,
  int nA,
  const void *zA,
  int nB,
  const void *zB
){
  SqlCollate *p = (SqlCollate *)pCtx;
  Tcl_Obj *pCmd;

  pCmd = Tcl_NewStringObj(p->zScript, -1);
  Tcl_IncrRefCount(pCmd);
  Tcl_ListObjAppendElement(p->interp, pCmd, Tcl_NewStringObj(zA, nA));
  Tcl_ListObjAppendElement(p->interp, pCmd, Tcl_NewStringObj(zB, nB));
  Tcl_EvalObjEx(p->interp, pCmd, TCL_EVAL_DIRECT);
  Tcl_DecrRefCount(pCmd);
  return (atoi(Tcl_GetStringResult(p->interp)));
}

/*
** This routine is called to evaluate an SQL function implemented
** using TCL script.
*/
static void tclSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv){
  SqlFunc *p = sqlite3_user_data(context);
  Tcl_Obj *pCmd;
  int i;
  int rc;

  
// ABS Label 133
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}

// ROR Label 134
if((argc != 0) != (argc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}
if( argc==0 ){
    /* If there are no arguments to the function, call Tcl_EvalObjEx on the
    ** script object directly.  This allows the TCL compiler to generate
    ** bytecode for the command on the first invocation and thus make
    ** subsequent invocations much faster. */
    pCmd = p->pScript;
    Tcl_IncrRefCount(pCmd);
    rc = Tcl_EvalObjEx(p->interp, pCmd, 0);
    Tcl_DecrRefCount(pCmd);
  }else{
    /* If there are arguments to the function, make a shallow copy of the
    ** script object, lappend the arguments, then evaluate the copy.
    **
    ** By "shallow" copy, we mean only the outer list Tcl_Obj is duplicated.
    ** The new Tcl_Obj contains pointers to the original list elements.
    ** That way, when Tcl_EvalObjv() is run and shimmers the first element
    ** of the list to tclCmdNameType, that alternate representation will
    ** be preserved and reused on the next invocation.
    */
    Tcl_Obj **aArg;
    int nArg;
    if( Tcl_ListObjGetElements(p->interp, p->pScript, &nArg, &aArg) ){
      sqlite3_result_error(context, Tcl_GetStringResult(p->interp), -1);
      return;
    }
    pCmd = Tcl_NewListObj(nArg, aArg);
    Tcl_IncrRefCount(pCmd);
    i = 0;

// ABS Label 135
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}
// ABS Label 136
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}

// ROR Label 137
if((i <= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
// ROR Label 138
if((i > argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 138);
}
// ROR Label 139
if((i >= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
for(; i<argc; i++){
      
// ABS Label 145
if(argv[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}
// ABS Label 146
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
sqlite3_value *pIn = argv[i];
      Tcl_Obj *pVal;

      /* Set pVal to contain the i'th column of this row. */
      switch( sqlite3_value_type(pIn) ){
        case SQLITE_BLOB: {
          int bytes = sqlite3_value_bytes(pIn);
          pVal = Tcl_NewByteArrayObj(sqlite3_value_blob(pIn), bytes);
          break;
        }
        case SQLITE_INTEGER: {
          sqlite_int64 v = sqlite3_value_int64(pIn);
          
// ABS Label 147
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}

// COR Label 148
if((v >= -2147483647 || v <= 2147483647) != (v >= -2147483647 && v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 148);
}

// ROR Label 149
if((v < -2147483647) != (v >= -2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
// ROR Label 150
if((v > -2147483647) != (v >= -2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if((v <= -2147483647) != (v >= -2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((v < 2147483647) != (v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
// ROR Label 153
if((v > 2147483647) != (v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 153);
}
// ROR Label 154
if((v >= 2147483647) != (v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}

// MCC Label 155
if(v >= -2147483647 && v <= 2147483647 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 155);
}
// MCC Label 156
if(v >= -2147483647 && !(v <= 2147483647) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 156);
}
// MCC Label 157
if(!(v >= -2147483647) && v <= 2147483647 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
// MCC Label 158
if(!(v >= -2147483647) && !(v <= 2147483647) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
if( v>=-2147483647 && v<=2147483647 ){
            pVal = Tcl_NewIntObj((int)v);
          }else{
            pVal = Tcl_NewWideIntObj(v);
          }
          break;
        }
        case SQLITE_FLOAT: {
          double r = sqlite3_value_double(pIn);
          pVal = Tcl_NewDoubleObj(r);
          break;
        }
        case SQLITE_NULL: {
          pVal = Tcl_NewStringObj(p->pDb->zNull, -1);
          break;
        }
        default: {
          int bytes = sqlite3_value_bytes(pIn);
          pVal = Tcl_NewStringObj((char *)sqlite3_value_text(pIn), bytes);
          break;
        }
      }
      rc = Tcl_ListObjAppendElement(p->interp, pCmd, pVal);
      
// ABS Label 159
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
if( rc ){
        Tcl_DecrRefCount(pCmd);
        sqlite3_result_error(context, Tcl_GetStringResult(p->interp), -1);
        return;
      }
    };
// ABS Label 140
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
// ABS Label 141
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ROR Label 142
if((i <= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((i > argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}
// ROR Label 144
if((i >= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}

    if( !p->useEvalObjv ){
      /* Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd
      ** is a list without a string representation.  To prevent this from
      ** happening, make sure pCmd has a valid string representation */
      Tcl_GetString(pCmd);
    }
    rc = Tcl_EvalObjEx(p->interp, pCmd, TCL_EVAL_DIRECT);
    Tcl_DecrRefCount(pCmd);
  }

  if( rc && rc!=TCL_RETURN ){
    sqlite3_result_error(context, Tcl_GetStringResult(p->interp), -1);
  }else{
    Tcl_Obj *pVar = Tcl_GetObjResult(p->interp);
    int n;
    u8 *data;
    const char *zType = (pVar->typePtr ? pVar->typePtr->name : "");
    
// ABS Label 160
if(zType[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
char c = zType[0];
    
// ABS Label 161
if(p->eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}
int eType = p->eType;

    
// ABS Label 162
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}

// ROR Label 163
if((eType != 5) != (eType == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
if( eType==SQLITE_NULL ){
      if( c=='b' && strcmp(zType,"bytearray")==0 && pVar->bytes==0 ){
        /* Only return a BLOB type if the Tcl variable is a bytearray and
        ** has no string representation. */
        eType = SQLITE_BLOB;
      }else { 
// COR Label 164
if(((c == 'b' && strcmp(zType, "boolean") == 0) || (c == 'w' && strcmp(zType, "wideInt") == 0) && (c == 'i' && strcmp(zType, "int") == 0)) != ((c == 'b' && strcmp(zType, "boolean") == 0) || (c == 'w' && strcmp(zType, "wideInt") == 0) || (c == 'i' && strcmp(zType, "int") == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 164);
}
// COR Label 165
if(((c == 'b' && strcmp(zType, "boolean") == 0) && (c == 'w' && strcmp(zType, "wideInt") == 0)) != ((c == 'b' && strcmp(zType, "boolean") == 0) || (c == 'w' && strcmp(zType, "wideInt") == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 165);
}

// MCC Label 166
if(( c == 'b' && 1 ) && ( c == 'w' && 1 ) && ( c == 'i' && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(( c == 'b' && 1 ) && ( c == 'w' && 1 ) && ( !(c == 'i') && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
// MCC Label 168
if(( c == 'b' && 1 ) && ( !(c == 'w') && 1 ) && ( c == 'i' && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
// MCC Label 169
if(( c == 'b' && 1 ) && ( !(c == 'w') && 1 ) && ( !(c == 'i') && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
// MCC Label 170
if(( !(c == 'b') && 1 ) && ( c == 'w' && 1 ) && ( c == 'i' && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
// MCC Label 171
if(( !(c == 'b') && 1 ) && ( c == 'w' && 1 ) && ( !(c == 'i') && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 171);
}
// MCC Label 172
if(( !(c == 'b') && 1 ) && ( !(c == 'w') && 1 ) && ( c == 'i' && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}
// MCC Label 173
if(( !(c == 'b') && 1 ) && ( !(c == 'w') && 1 ) && ( !(c == 'i') && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 173);
}
if( (c=='b' && strcmp(zType,"boolean")==0)
             || (c=='w' && strcmp(zType,"wideInt")==0)
             || (c=='i' && strcmp(zType,"int")==0) 
      ){
        eType = SQLITE_INTEGER;
      }else { 
// MCC Label 174
if(c == 'd' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 174);
}
// MCC Label 175
if(!(c == 'd') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 175);
}
if( c=='d' && strcmp(zType,"double")==0 ){
        eType = SQLITE_FLOAT;
      }else{
        eType = SQLITE_TEXT;
      };}
;}

    }

    switch( eType ){
      case SQLITE_BLOB: {
        data = Tcl_GetByteArrayFromObj(pVar, &n);
        
// ABS Label 176
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// ABS Label 177
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}
sqlite3_result_blob(context, data, n, SQLITE_TRANSIENT);
        break;
      }
      case SQLITE_INTEGER: {
        Tcl_WideInt v;
        if( TCL_OK==Tcl_GetWideIntFromObj(0, pVar, &v) ){
          sqlite3_result_int64(context, v);
          break;
        }
        /* fall-through */
      }
      case SQLITE_FLOAT: {
        double r;
        if( TCL_OK==Tcl_GetDoubleFromObj(0, pVar, &r) ){
          
// ABS Label 178
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}

// ABS Label 179
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}
sqlite3_result_double(context, r);
          break;
        }
        /* fall-through */
      }
      default: {
        data = (unsigned char *)Tcl_GetStringFromObj(pVar, &n);
        
// ABS Label 180
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}

// ABS Label 181
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
sqlite3_result_text(context, (char *)data, n, SQLITE_TRANSIENT);
        break;
      }
    }

  }
}

#ifndef SQLITE_OMIT_AUTHORIZATION
/*
** This is the authentication function.  It appends the authentication
** type code and the two arguments to zCmd[] then invokes the result
** on the interpreter.  The reply is examined to determine if the
** authentication fails or succeeds.
*/
static int auth_callback(
  void *pArg,
  int code,
  const char *zArg1,
  const char *zArg2,
  const char *zArg3,
  const char *zArg4
#ifdef SQLITE_USER_AUTHENTICATION
  ,const char *zArg5
#endif
){
  const char *zCode;
  Tcl_DString str;
  int rc;
  const char *zReply;
  /* EVIDENCE-OF: R-38590-62769 The first parameter to the authorizer
  ** callback is a copy of the third parameter to the
  ** sqlite3_set_authorizer() interface.
  */
  SqliteDb *pDb = (SqliteDb*)pArg;
  
// ABS Label 182
if(pDb->disableAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
if( pDb->disableAuth ) return SQLITE_OK;

  /* EVIDENCE-OF: R-56518-44310 The second parameter to the callback is an
  ** integer action code that specifies the particular action to be
  ** authorized. */
  switch( code ){
    case SQLITE_COPY              : zCode="SQLITE_COPY"; break;
    case SQLITE_CREATE_INDEX      : zCode="SQLITE_CREATE_INDEX"; break;
    case SQLITE_CREATE_TABLE      : zCode="SQLITE_CREATE_TABLE"; break;
    case SQLITE_CREATE_TEMP_INDEX : zCode="SQLITE_CREATE_TEMP_INDEX"; break;
    case SQLITE_CREATE_TEMP_TABLE : zCode="SQLITE_CREATE_TEMP_TABLE"; break;
    case SQLITE_CREATE_TEMP_TRIGGER: zCode="SQLITE_CREATE_TEMP_TRIGGER"; break;
    case SQLITE_CREATE_TEMP_VIEW  : zCode="SQLITE_CREATE_TEMP_VIEW"; break;
    case SQLITE_CREATE_TRIGGER    : zCode="SQLITE_CREATE_TRIGGER"; break;
    case SQLITE_CREATE_VIEW       : zCode="SQLITE_CREATE_VIEW"; break;
    case SQLITE_DELETE            : zCode="SQLITE_DELETE"; break;
    case SQLITE_DROP_INDEX        : zCode="SQLITE_DROP_INDEX"; break;
    case SQLITE_DROP_TABLE        : zCode="SQLITE_DROP_TABLE"; break;
    case SQLITE_DROP_TEMP_INDEX   : zCode="SQLITE_DROP_TEMP_INDEX"; break;
    case SQLITE_DROP_TEMP_TABLE   : zCode="SQLITE_DROP_TEMP_TABLE"; break;
    case SQLITE_DROP_TEMP_TRIGGER : zCode="SQLITE_DROP_TEMP_TRIGGER"; break;
    case SQLITE_DROP_TEMP_VIEW    : zCode="SQLITE_DROP_TEMP_VIEW"; break;
    case SQLITE_DROP_TRIGGER      : zCode="SQLITE_DROP_TRIGGER"; break;
    case SQLITE_DROP_VIEW         : zCode="SQLITE_DROP_VIEW"; break;
    case SQLITE_INSERT            : zCode="SQLITE_INSERT"; break;
    case SQLITE_PRAGMA            : zCode="SQLITE_PRAGMA"; break;
    case SQLITE_READ              : zCode="SQLITE_READ"; break;
    case SQLITE_SELECT            : zCode="SQLITE_SELECT"; break;
    case SQLITE_TRANSACTION       : zCode="SQLITE_TRANSACTION"; break;
    case SQLITE_UPDATE            : zCode="SQLITE_UPDATE"; break;
    case SQLITE_ATTACH            : zCode="SQLITE_ATTACH"; break;
    case SQLITE_DETACH            : zCode="SQLITE_DETACH"; break;
    case SQLITE_ALTER_TABLE       : zCode="SQLITE_ALTER_TABLE"; break;
    case SQLITE_REINDEX           : zCode="SQLITE_REINDEX"; break;
    case SQLITE_ANALYZE           : zCode="SQLITE_ANALYZE"; break;
    case SQLITE_CREATE_VTABLE     : zCode="SQLITE_CREATE_VTABLE"; break;
    case SQLITE_DROP_VTABLE       : zCode="SQLITE_DROP_VTABLE"; break;
    case SQLITE_FUNCTION          : zCode="SQLITE_FUNCTION"; break;
    case SQLITE_SAVEPOINT         : zCode="SQLITE_SAVEPOINT"; break;
    case SQLITE_RECURSIVE         : zCode="SQLITE_RECURSIVE"; break;
    default                       : zCode="????"; break;
  }
  Tcl_DStringInit(&str);
  Tcl_DStringAppend(&str, pDb->zAuth, -1);
  Tcl_DStringAppendElement(&str, zCode);
  Tcl_DStringAppendElement(&str, zArg1 ? zArg1 : "");
  Tcl_DStringAppendElement(&str, zArg2 ? zArg2 : "");
  Tcl_DStringAppendElement(&str, zArg3 ? zArg3 : "");
  Tcl_DStringAppendElement(&str, zArg4 ? zArg4 : "");
#ifdef SQLITE_USER_AUTHENTICATION
  Tcl_DStringAppendElement(&str, zArg5 ? zArg5 : "");
#endif
  rc = Tcl_GlobalEval(pDb->interp, Tcl_DStringValue(&str));
  Tcl_DStringFree(&str);
  zReply = rc==TCL_OK ? Tcl_GetStringResult(pDb->interp) : "SQLITE_DENY";
  if( strcmp(zReply,"SQLITE_OK")==0 ){
    rc = SQLITE_OK;
  }else { if( strcmp(zReply,"SQLITE_DENY")==0 ){
    rc = SQLITE_DENY;
  }else { if( strcmp(zReply,"SQLITE_IGNORE")==0 ){
    rc = SQLITE_IGNORE;
  }else{
    rc = 999;
  };}
;}

  
// ABS Label 183
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
return rc;
}
#endif /* SQLITE_OMIT_AUTHORIZATION */

/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** The interface is like "readline" but no command-line editing
** is done.
**
** copied from shell.c from '.import' command
*/
static char *local_getline(char *zPrompt, FILE *in){
  char *zLine;
  int nLine;
  int n;

  nLine = 100;
  zLine = malloc( nLine );
  
// ABS Label 184
if(zLine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}

// ROR Label 185
if((zLine != 0) != (zLine == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
if( zLine==0 ) return 0;
  n = 0;
  while( 1 ){
    
// ABS Label 186
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
// ABS Label 187
if(nLine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}

// AOR Label 188
if(n - 100 != n + 100)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 188);
}
// AOR Label 189
if(n / 100 != n + 100)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 189);
}
// AOR Label 190
if(n * 100 != n + 100)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 190);
}

// ROR Label 191
if((n + 100 <= nLine) != (n + 100 > nLine))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
// ROR Label 192
if((n + 100 < nLine) != (n + 100 > nLine))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((n + 100 >= nLine) != (n + 100 > nLine))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
if( n+100>nLine ){
      nLine = nLine*2 + 100;
      zLine = realloc(zLine, nLine);
      
// ABS Label 194
if(zLine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}

// ROR Label 195
if((zLine != 0) != (zLine == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}
if( zLine==0 ) return 0;
    }
    if( fgets(&zLine[n], nLine - n, in)==0 ){
      
// ABS Label 196
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}

// ROR Label 197
if((n != 0) != (n == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 197);
}
if( n==0 ){
        free(zLine);
        return 0;
      }
      zLine[n] = 0;
      break;
    }
    
// ABS Label 198
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
// ABS Label 199
if(zLine[n] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}
while( zLine[n] ){ n++; };
// ABS Label 200
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
// ABS Label 201
if(zLine[n] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}

    
// ABS Label 202
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}

// COR Label 203
if((n > 0 || zLine[n - 1] == '\n') != (n > 0 && zLine[n - 1] == '\n'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 203);
}

// ROR Label 204
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((zLine[n - 1] != '\n') != (zLine[n - 1] == '\n'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}

// MCC Label 208
if(n > 0 && zLine[n - 1] == '\n' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(n > 0 && !(zLine[n - 1] == '\n') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(!(n > 0) && zLine[n - 1] == '\n' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(!(n > 0) && !(zLine[n - 1] == '\n') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
if( n>0 && zLine[n-1]=='\n' ){
      n--;
      zLine[n] = 0;
      break;
    }
  };
  zLine = realloc( zLine, n+1 );
  
// ABS Label 212
if(zLine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}
return zLine;
}


/*
** This function is part of the implementation of the command:
**
**   $db transaction [-deferred|-immediate|-exclusive] SCRIPT
**
** It is invoked after evaluating the script SCRIPT to commit or rollback
** the transaction or savepoint opened by the [transaction] command.
*/
static int SQLITE_TCLAPI DbTransPostCmd(
  ClientData data[],                   /* data[0] is the Sqlite3Db* for $db */
  Tcl_Interp *interp,                  /* Tcl interpreter */
  int result                           /* Result of evaluating SCRIPT */
){
  static const char *const azEnd[] = {
    "RELEASE _tcl_transaction",        /* rc==TCL_ERROR, nTransaction!=0 */
    "COMMIT",                          /* rc!=TCL_ERROR, nTransaction==0 */
    "ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction",
    "ROLLBACK"                         /* rc==TCL_ERROR, nTransaction==0 */
  };
  SqliteDb *pDb = (SqliteDb*)data[0];
  
// ABS Label 213
if(result < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}
int rc = result;
  const char *zEnd;

  pDb->nTransaction--;
  zEnd = azEnd[(rc==TCL_ERROR)*2 + (pDb->nTransaction==0)];

  pDb->disableAuth++;
  if( sqlite3_exec(pDb->db, zEnd, 0, 0, 0) ){
      /* This is a tricky scenario to handle. The most likely cause of an
      ** error is that the exec() above was an attempt to commit the
      ** top-level transaction that returned SQLITE_BUSY. Or, less likely,
      ** that an IO-error has occurred. In either case, throw a Tcl exception
      ** and try to rollback the transaction.
      **
      ** But it could also be that the user executed one or more BEGIN,
      ** COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
      ** this method's logic. Not clear how this would be best handled.
      */
    if( rc!=TCL_ERROR ){
      Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), (char*)0);
      rc = TCL_ERROR;
    }
    
// ABS Label 214
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}
sqlite3_exec(pDb->db, "ROLLBACK", 0, 0, 0);
  }
  pDb->disableAuth--;

  
// ABS Label 215
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
return rc;
}

/*
** Unless SQLITE_TEST is defined, this function is a simple wrapper around
** sqlite3_prepare_v2(). If SQLITE_TEST is defined, then it uses either
** sqlite3_prepare_v2() or legacy interface sqlite3_prepare(), depending
** on whether or not the [db_use_legacy_prepare] command has been used to
** configure the connection.
*/
static int dbPrepare(
  SqliteDb *pDb,                  /* Database object */
  const char *zSql,               /* SQL to compile */
  sqlite3_stmt **ppStmt,          /* OUT: Prepared statement */
  const char **pzOut              /* OUT: Pointer to next SQL statement */
){
  unsigned int prepFlags = 0;
#ifdef SQLITE_TEST
  if( pDb->bLegacyPrepare ){
    return sqlite3_prepare(pDb->db, zSql, -1, ppStmt, pzOut);
  }
#endif
  /* If the statement cache is large, use the SQLITE_PREPARE_PERSISTENT
  ** flags, which uses less lookaside memory.  But if the cache is small,
  ** omit that flag to make full use of lookaside */
  
// ABS Label 216
if(pDb->maxStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// ROR Label 217
if((pDb->maxStmt <= 5) != (pDb->maxStmt > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
// ROR Label 218
if((pDb->maxStmt < 5) != (pDb->maxStmt > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
// ROR Label 219
if((pDb->maxStmt >= 5) != (pDb->maxStmt > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
if( pDb->maxStmt>5 ) prepFlags = SQLITE_PREPARE_PERSISTENT;

  return sqlite3_prepare_v3(pDb->db, zSql, -1, prepFlags, ppStmt, pzOut);
}

/*
** Search the cache for a prepared-statement object that implements the
** first SQL statement in the buffer pointed to by parameter zIn. If
** no such prepared-statement can be found, allocate and prepare a new
** one. In either case, bind the current values of the relevant Tcl
** variables to any $var, :var or @var variables in the statement. Before
** returning, set *ppPreStmt to point to the prepared-statement object.
**
** Output parameter *pzOut is set to point to the next SQL statement in
** buffer zIn, or to the '\0' byte at the end of zIn if there is no
** next statement.
**
** If successful, TCL_OK is returned. Otherwise, TCL_ERROR is returned
** and an error message loaded into interpreter pDb->interp.
*/
static int dbPrepareAndBind(
  SqliteDb *pDb,                  /* Database object */
  char const *zIn,                /* SQL to compile */
  char const **pzOut,             /* OUT: Pointer to next SQL statement */
  SqlPreparedStmt **ppPreStmt     /* OUT: Object used to cache statement */
){
  
// ABS Label 220
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
const char *zSql = zIn;         /* Pointer to first SQL statement in zIn */
  sqlite3_stmt *pStmt = 0;        /* Prepared statement object */
  SqlPreparedStmt *pPreStmt;      /* Pointer to cached statement */
  int nSql;                       /* Length of zSql in bytes */
  int nVar = 0;                   /* Number of variables in statement */
  int iParm = 0;                  /* Next free entry in apParm */
  char c;
  int i;
  int needResultReset = 0;        /* Need to invoke Tcl_ResetResult() */
  int rc = SQLITE_OK;             /* Value to return */
  Tcl_Interp *interp = pDb->interp;

  *ppPreStmt = 0;

  /* Trim spaces from the start of zSql and calculate the remaining length. */
  while( (c = zSql[0])==' ' || c=='\t' || c=='\r' || c=='\n' ){ zSql++; };
  nSql = strlen30(zSql);

  pPreStmt = pDb->stmtList;

// ABS Label 221
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
for(; pPreStmt; pPreStmt=pPreStmt->pNext){
    
// ABS Label 223
if(pPreStmt->nSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}
int n = pPreStmt->nSql;
    
// ABS Label 224
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
// ABS Label 225
if(nSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}

// MCC Label 226
if(nSql >= n && 1 && ( zSql[n] == 0 && zSql[n - 1] == ';' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(nSql >= n && 1 && ( zSql[n] == 0 && !(zSql[n - 1] == ';') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(nSql >= n && 1 && ( !(zSql[n] == 0) && zSql[n - 1] == ';' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(nSql >= n && 1 && ( !(zSql[n] == 0) && !(zSql[n - 1] == ';') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(!(nSql >= n) && 1 && ( zSql[n] == 0 && zSql[n - 1] == ';' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(!(nSql >= n) && 1 && ( zSql[n] == 0 && !(zSql[n - 1] == ';') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(!(nSql >= n) && 1 && ( !(zSql[n] == 0) && zSql[n - 1] == ';' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(!(nSql >= n) && 1 && ( !(zSql[n] == 0) && !(zSql[n - 1] == ';') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
if( nSql>=n
        && memcmp(pPreStmt->zSql, zSql, n)==0
        && (zSql[n]==0 || zSql[n-1]==';')
    ){
      pStmt = pPreStmt->pStmt;
      *pzOut = &zSql[pPreStmt->nSql];

      /* When a prepared statement is found, unlink it from the
      ** cache list.  It will later be added back to the beginning
      ** of the cache list in order to implement LRU replacement.
      */
      
// ABS Label 234
if(pPreStmt->pPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}
if( pPreStmt->pPrev ){
        pPreStmt->pPrev->pNext = pPreStmt->pNext;
      }else{
        pDb->stmtList = pPreStmt->pNext;
      }
      
// ABS Label 235
if(pPreStmt->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}
if( pPreStmt->pNext ){
        pPreStmt->pNext->pPrev = pPreStmt->pPrev;
      }else{
        pDb->stmtLast = pPreStmt->pPrev;
      }
      pDb->nStmt--;
      nVar = sqlite3_bind_parameter_count(pStmt);
      break;
    }
  };
// ABS Label 222
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}


  /* If no prepared statement was found. Compile the SQL text. Also allocate
  ** a new SqlPreparedStmt structure.  */
  
// ABS Label 236
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}

// ROR Label 237
if((pPreStmt != 0) != (pPreStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
if( pPreStmt==0 ){
    int nByte;

    if( SQLITE_OK!=dbPrepare(pDb, zSql, &pStmt, pzOut) ){
      Tcl_SetObjResult(interp, Tcl_NewStringObj(sqlite3_errmsg(pDb->db), -1));
      return TCL_ERROR;
    }
    
// ABS Label 238
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ROR Label 239
if((pStmt != 0) != (pStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 239);
}
if( pStmt==0 ){
      if( SQLITE_OK!=sqlite3_errcode(pDb->db) ){
        /* A compile-time error in the statement. */
        Tcl_SetObjResult(interp, Tcl_NewStringObj(sqlite3_errmsg(pDb->db), -1));
        return TCL_ERROR;
      }else{
        /* The statement was a no-op.  Continue to the next statement
        ** in the SQL string.
        */
        return TCL_OK;
      }
    }

    assert( pPreStmt==0 );
    nVar = sqlite3_bind_parameter_count(pStmt);
    nByte = sizeof(SqlPreparedStmt) + nVar*sizeof(Tcl_Obj *);
    pPreStmt = (SqlPreparedStmt*)Tcl_Alloc(nByte);
    memset(pPreStmt, 0, nByte);

    pPreStmt->pStmt = pStmt;
    pPreStmt->nSql = (int)(*pzOut - zSql);
    pPreStmt->zSql = sqlite3_sql(pStmt);
    pPreStmt->apParm = (Tcl_Obj **)&pPreStmt[1];
#ifdef SQLITE_TEST
    if( pPreStmt->zSql==0 ){
      char *zCopy = Tcl_Alloc(pPreStmt->nSql + 1);
      memcpy(zCopy, zSql, pPreStmt->nSql);
      zCopy[pPreStmt->nSql] = '\0';
      pPreStmt->zSql = zCopy;
    }
#endif
  }
  assert( pPreStmt );
  assert( strlen30(pPreStmt->zSql)==pPreStmt->nSql );
  assert( 0==memcmp(pPreStmt->zSql, zSql, pPreStmt->nSql) );

  /* Bind values to parameters that begin with $ or : */
  i = 1;

// ABS Label 243
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}
// ABS Label 244
if(nVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ROR Label 245
if((i < nVar) != (i <= nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 245);
}
// ROR Label 246
if((i > nVar) != (i <= nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
// ROR Label 247
if((i >= nVar) != (i <= nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 247);
}
for(; i<=nVar; i++){
    const char *zVar = sqlite3_bind_parameter_name(pStmt, i);
    
// ABS Label 253
if(zVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}

// COR Label 254
if((zVar != 0 || (zVar[0] == '$' || zVar[0] == ':' || zVar[0] == '@')) != (zVar != 0 && (zVar[0] == '$' || zVar[0] == ':' || zVar[0] == '@')))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 254);
}

// ROR Label 255
if((zVar == 0) != (zVar != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 255);
}

// MCC Label 256
if(zVar != 0 && ( zVar[0] == '$' && zVar[0] == ':' && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 256);
}
// MCC Label 257
if(zVar != 0 && ( zVar[0] == '$' && zVar[0] == ':' && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 257);
}
// MCC Label 258
if(zVar != 0 && ( zVar[0] == '$' && !(zVar[0] == ':') && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 258);
}
// MCC Label 259
if(zVar != 0 && ( zVar[0] == '$' && !(zVar[0] == ':') && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 259);
}
// MCC Label 260
if(zVar != 0 && ( !(zVar[0] == '$') && zVar[0] == ':' && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if(zVar != 0 && ( !(zVar[0] == '$') && zVar[0] == ':' && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(zVar != 0 && ( !(zVar[0] == '$') && !(zVar[0] == ':') && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(zVar != 0 && ( !(zVar[0] == '$') && !(zVar[0] == ':') && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
// MCC Label 264
if(!(zVar != 0) && ( zVar[0] == '$' && zVar[0] == ':' && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(!(zVar != 0) && ( zVar[0] == '$' && zVar[0] == ':' && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(!(zVar != 0) && ( zVar[0] == '$' && !(zVar[0] == ':') && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(!(zVar != 0) && ( zVar[0] == '$' && !(zVar[0] == ':') && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(!(zVar != 0) && ( !(zVar[0] == '$') && zVar[0] == ':' && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if(!(zVar != 0) && ( !(zVar[0] == '$') && zVar[0] == ':' && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(!(zVar != 0) && ( !(zVar[0] == '$') && !(zVar[0] == ':') && zVar[0] == '@' ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
// MCC Label 271
if(!(zVar != 0) && ( !(zVar[0] == '$') && !(zVar[0] == ':') && !(zVar[0] == '@') ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 271);
}
if( zVar!=0 && (zVar[0]=='$' || zVar[0]==':' || zVar[0]=='@') ){
      Tcl_Obj *pVar = Tcl_GetVar2Ex(interp, &zVar[1], 0, 0);
      if( pVar==0 && pDb->zBindFallback!=0 ){
        Tcl_Obj *pCmd;
        int rx;
        pCmd = Tcl_NewStringObj(pDb->zBindFallback, -1);
        Tcl_IncrRefCount(pCmd);
        Tcl_ListObjAppendElement(interp, pCmd, Tcl_NewStringObj(zVar,-1));
        if( needResultReset ) Tcl_ResetResult(interp);
        needResultReset = 1;
        rx = Tcl_EvalObjEx(interp, pCmd, TCL_EVAL_DIRECT);
        Tcl_DecrRefCount(pCmd);
        if( rx==TCL_OK ){
          pVar = Tcl_GetObjResult(interp);
        }else { if( rx==TCL_ERROR ){
          rc = TCL_ERROR;
          break;
        }else{
          pVar = 0;
        };}

      }
      if( pVar ){
        int n;
        u8 *data;
        const char *zType = (pVar->typePtr ? pVar->typePtr->name : "");
        c = zType[0];
        if( zVar[0]=='@' ||
           (c=='b' && strcmp(zType,"bytearray")==0 && pVar->bytes==0) ){
          /* Load a BLOB type if the Tcl variable is a bytearray and
          ** it has no string representation or the host
          ** parameter name begins with "@". */
          data = Tcl_GetByteArrayFromObj(pVar, &n);
          
// ABS Label 272
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}

// ABS Label 273
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

// ABS Label 274
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
sqlite3_bind_blob(pStmt, i, data, n, SQLITE_STATIC);
          Tcl_IncrRefCount(pVar);
          pPreStmt->apParm[iParm++] = pVar;
        }else { 
// MCC Label 275
if(c == 'b' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
// MCC Label 276
if(!(c == 'b') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 276);
}
if( c=='b' && strcmp(zType,"boolean")==0 ){
          Tcl_GetIntFromObj(interp, pVar, &n);
          
// ABS Label 277
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}

// ABS Label 278
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}

// ABS Label 279
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}
sqlite3_bind_int(pStmt, i, n);
        }else { 
// MCC Label 280
if(c == 'd' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 280);
}
// MCC Label 281
if(!(c == 'd') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 281);
}
if( c=='d' && strcmp(zType,"double")==0 ){
          double r;
          Tcl_GetDoubleFromObj(interp, pVar, &r);
          
// ABS Label 282
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}

// ABS Label 283
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ABS Label 284
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}
sqlite3_bind_double(pStmt, i, r);
        }else { 
// COR Label 285
if(((c == 'w' && strcmp(zType, "wideInt") == 0) && (c == 'i' && strcmp(zType, "int") == 0)) != ((c == 'w' && strcmp(zType, "wideInt") == 0) || (c == 'i' && strcmp(zType, "int") == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 285);
}

// MCC Label 286
if(( c == 'w' && 1 ) && ( c == 'i' && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 286);
}
// MCC Label 287
if(( c == 'w' && 1 ) && ( !(c == 'i') && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 287);
}
// MCC Label 288
if(( !(c == 'w') && 1 ) && ( c == 'i' && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 288);
}
// MCC Label 289
if(( !(c == 'w') && 1 ) && ( !(c == 'i') && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 289);
}
if( (c=='w' && strcmp(zType,"wideInt")==0) ||
              (c=='i' && strcmp(zType,"int")==0) ){
          Tcl_WideInt v;
          Tcl_GetWideIntFromObj(interp, pVar, &v);
          sqlite3_bind_int64(pStmt, i, v);
        }else{
          data = (unsigned char *)Tcl_GetStringFromObj(pVar, &n);
          
// ABS Label 290
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ABS Label 291
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ABS Label 292
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
sqlite3_bind_text(pStmt, i, (char *)data, n, SQLITE_STATIC);
          Tcl_IncrRefCount(pVar);
          pPreStmt->apParm[iParm++] = pVar;
        };}
;}
;}

      }else{
        
// ABS Label 293
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ABS Label 294
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
sqlite3_bind_null(pStmt, i);
      }
      
// ABS Label 295
if(needResultReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
if( needResultReset ) Tcl_ResetResult(pDb->interp);
    }
  };
// ABS Label 248
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
// ABS Label 249
if(nVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}

// ROR Label 250
if((i < nVar) != (i <= nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((i > nVar) != (i <= nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}
// ROR Label 252
if((i >= nVar) != (i <= nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}

  pPreStmt->nParm = iParm;
  *ppPreStmt = pPreStmt;
  if( needResultReset && rc==TCL_OK ) Tcl_ResetResult(pDb->interp);

  
// ABS Label 296
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
return rc;
}

/*
** Release a statement reference obtained by calling dbPrepareAndBind().
** There should be exactly one call to this function for each call to
** dbPrepareAndBind().
**
** If the discard parameter is non-zero, then the statement is deleted
** immediately. Otherwise it is added to the LRU list and may be returned
** by a subsequent call to dbPrepareAndBind().
*/
static void dbReleaseStmt(
  SqliteDb *pDb,                  /* Database handle */
  SqlPreparedStmt *pPreStmt,      /* Prepared statement handle to release */
  int discard                     /* True to delete (not cache) the pPreStmt */
){
  int i;

  /* Free the bound string and blob parameters */
  i = 0;

// ABS Label 297
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
// ABS Label 298
if(pPreStmt->nParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}

// ROR Label 299
if((i <= pPreStmt->nParm) != (i < pPreStmt->nParm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 299);
}
// ROR Label 300
if((i > pPreStmt->nParm) != (i < pPreStmt->nParm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
// ROR Label 301
if((i >= pPreStmt->nParm) != (i < pPreStmt->nParm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}
for(; i<pPreStmt->nParm; i++){
    Tcl_DecrRefCount(pPreStmt->apParm[i]);
  };
// ABS Label 302
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
// ABS Label 303
if(pPreStmt->nParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ROR Label 304
if((i <= pPreStmt->nParm) != (i < pPreStmt->nParm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
// ROR Label 305
if((i > pPreStmt->nParm) != (i < pPreStmt->nParm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}
// ROR Label 306
if((i >= pPreStmt->nParm) != (i < pPreStmt->nParm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 306);
}

  pPreStmt->nParm = 0;

  
// ABS Label 307
if(discard < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
// ABS Label 308
if(pDb->maxStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// COR Label 309
if((pDb->maxStmt <= 0 && discard) != (pDb->maxStmt <= 0 || discard))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 309);
}

// ROR Label 310
if((pDb->maxStmt < 0) != (pDb->maxStmt <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((pDb->maxStmt > 0) != (pDb->maxStmt <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
// ROR Label 312
if((pDb->maxStmt >= 0) != (pDb->maxStmt <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 312);
}

// MCC Label 313
if(pDb->maxStmt <= 0 && discard ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 313);
}
// MCC Label 314
if(pDb->maxStmt <= 0 && !(discard) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 314);
}
// MCC Label 315
if(!(pDb->maxStmt <= 0) && discard ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 315);
}
// MCC Label 316
if(!(pDb->maxStmt <= 0) && !(discard) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 316);
}
if( pDb->maxStmt<=0 || discard ){
    /* If the cache is turned off, deallocated the statement */
    
// ABS Label 317
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
dbFreeStmt(pPreStmt);
  }else{
    /* Add the prepared statement to the beginning of the cache list. */
    pPreStmt->pNext = pDb->stmtList;
    pPreStmt->pPrev = 0;
    
// ABS Label 318
if(pDb->stmtList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
if( pDb->stmtList ){
     pDb->stmtList->pPrev = pPreStmt;
    }
    pDb->stmtList = pPreStmt;
    
// ABS Label 319
if(pDb->stmtLast < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}

// ROR Label 320
if((pDb->stmtLast != 0) != (pDb->stmtLast == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 320);
}
if( pDb->stmtLast==0 ){
      assert( pDb->nStmt==0 );
      pDb->stmtLast = pPreStmt;
    }else{
      assert( pDb->nStmt>0 );
    }
    pDb->nStmt++;

    /* If we have too many statement in cache, remove the surplus from
    ** the end of the cache list.  */
    
// ABS Label 327
if(pDb->maxStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
// ABS Label 328
if(pDb->nStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ROR Label 329
if((pDb->nStmt <= pDb->maxStmt) != (pDb->nStmt > pDb->maxStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 329);
}
// ROR Label 330
if((pDb->nStmt < pDb->maxStmt) != (pDb->nStmt > pDb->maxStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 330);
}
// ROR Label 331
if((pDb->nStmt >= pDb->maxStmt) != (pDb->nStmt > pDb->maxStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 331);
}
while( pDb->nStmt>pDb->maxStmt ){
      
// ABS Label 337
if(pDb->stmtLast < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
SqlPreparedStmt *pLast = pDb->stmtLast;
      pDb->stmtLast = pLast->pPrev;
      pDb->stmtLast->pNext = 0;
      pDb->nStmt--;
      
// ABS Label 338
if(pLast < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
dbFreeStmt(pLast);
    };
// ABS Label 332
if(pDb->maxStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}
// ABS Label 333
if(pDb->nStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}

// ROR Label 334
if((pDb->nStmt <= pDb->maxStmt) != (pDb->nStmt > pDb->maxStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
// ROR Label 335
if((pDb->nStmt < pDb->maxStmt) != (pDb->nStmt > pDb->maxStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 335);
}
// ROR Label 336
if((pDb->nStmt >= pDb->maxStmt) != (pDb->nStmt > pDb->maxStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}

  }
}

/*
** Structure used with dbEvalXXX() functions:
**
**   dbEvalInit()
**   dbEvalStep()
**   dbEvalFinalize()
**   dbEvalRowInfo()
**   dbEvalColumnValue()
*/
typedef struct DbEvalContext DbEvalContext;
struct DbEvalContext {
  SqliteDb *pDb;                  /* Database handle */
  Tcl_Obj *pSql;                  /* Object holding string zSql */
  const char *zSql;               /* Remaining SQL to execute */
  SqlPreparedStmt *pPreStmt;      /* Current statement */
  int nCol;                       /* Number of columns returned by pStmt */
  int evalFlags;                  /* Flags used */
  Tcl_Obj *pArray;                /* Name of array variable */
  Tcl_Obj **apColName;            /* Array of column names */
};

#define SQLITE_EVAL_WITHOUTNULLS  0x00001  /* Unset array(*) for NULL */

/*
** Release any cache of column names currently held as part of
** the DbEvalContext structure passed as the first argument.
*/
static void dbReleaseColumnNames(DbEvalContext *p){
  if( p->apColName ){
    int i;
    i = 0;

// ABS Label 339
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}
// ABS Label 340
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// ROR Label 341
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 341);
}
// ROR Label 342
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}
// ROR Label 343
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 343);
}
for(; i<p->nCol; i++){
      Tcl_DecrRefCount(p->apColName[i]);
    };
// ABS Label 344
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
// ABS Label 345
if(p->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}

// ROR Label 346
if((i <= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 346);
}
// ROR Label 347
if((i > p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 347);
}
// ROR Label 348
if((i >= p->nCol) != (i < p->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 348);
}

    Tcl_Free((char *)p->apColName);
    p->apColName = 0;
  }
  p->nCol = 0;
}

/*
** Initialize a DbEvalContext structure.
**
** If pArray is not NULL, then it contains the name of a Tcl array
** variable. The "*" member of this array is set to a list containing
** the names of the columns returned by the statement as part of each
** call to dbEvalStep(), in order from left to right. e.g. if the names
** of the returned columns are a, b and c, it does the equivalent of the
** tcl command:
**
**     set ${pArray}(*) {a b c}
*/
static void dbEvalInit(
  DbEvalContext *p,               /* Pointer to structure to initialize */
  SqliteDb *pDb,                  /* Database handle */
  Tcl_Obj *pSql,                  /* Object containing SQL script */
  Tcl_Obj *pArray,                /* Name of Tcl array to set (*) element of */
  int evalFlags                   /* Flags controlling evaluation */
){
  memset(p, 0, sizeof(DbEvalContext));
  p->pDb = pDb;
  p->zSql = Tcl_GetString(pSql);
  p->pSql = pSql;
  Tcl_IncrRefCount(pSql);
  if( pArray ){
    p->pArray = pArray;
    Tcl_IncrRefCount(pArray);
  }
  p->evalFlags = evalFlags;
}

/*
** Obtain information about the row that the DbEvalContext passed as the
** first argument currently points to.
*/
static void dbEvalRowInfo(
  DbEvalContext *p,               /* Evaluation context */
  int *pnCol,                     /* OUT: Number of column names */
  Tcl_Obj ***papColName           /* OUT: Array of column names */
){
  /* Compute column names */
  if( 0==p->apColName ){
    
// ABS Label 349
if(p->pPreStmt->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
sqlite3_stmt *pStmt = p->pPreStmt->pStmt;
    int i;                        /* Iterator variable */
    int nCol;                     /* Number of columns returned by pStmt */
    Tcl_Obj **apColName = 0;      /* Array of column names */

    p->nCol = nCol = sqlite3_column_count(pStmt);
    if( nCol>0 && (papColName || p->pArray) ){
      apColName = (Tcl_Obj**)Tcl_Alloc( sizeof(Tcl_Obj*)*nCol );
      i = 0;

// ABS Label 350
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
// ABS Label 351
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}

// ROR Label 352
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 352);
}
// ROR Label 353
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 353);
}
// ROR Label 354
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}
for(; i<nCol; i++){
        apColName[i] = Tcl_NewStringObj(sqlite3_column_name(pStmt,i), -1);
        Tcl_IncrRefCount(apColName[i]);
      };
// ABS Label 355
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
// ABS Label 356
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ROR Label 357
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
// ROR Label 358
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}
// ROR Label 359
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}

      p->apColName = apColName;
    }

    /* If results are being stored in an array variable, then create
    ** the array(*) entry for that array
    */
    if( p->pArray ){
      Tcl_Interp *interp = p->pDb->interp;
      Tcl_Obj *pColList = Tcl_NewObj();
      Tcl_Obj *pStar = Tcl_NewStringObj("*", -1);

      i = 0;

// ABS Label 360
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}
// ABS Label 361
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}

// ROR Label 362
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}
// ROR Label 363
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}
// ROR Label 364
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}
for(; i<nCol; i++){
        Tcl_ListObjAppendElement(interp, pColList, apColName[i]);
      };
// ABS Label 365
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
// ABS Label 366
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}

// ROR Label 367
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}
// ROR Label 368
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}
// ROR Label 369
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}

      Tcl_IncrRefCount(pStar);
      Tcl_ObjSetVar2(interp, p->pArray, pStar, pColList, 0);
      Tcl_DecrRefCount(pStar);
    }
  }

  if( papColName ){
    *papColName = p->apColName;
  }
  
// ABS Label 370
if(pnCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}
if( pnCol ){
    *pnCol = p->nCol;
  }
}

/*
** Return one of TCL_OK, TCL_BREAK or TCL_ERROR. If TCL_ERROR is
** returned, then an error message is stored in the interpreter before
** returning.
**
** A return value of TCL_OK means there is a row of data available. The
** data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This
** is analogous to a return of SQLITE_ROW from sqlite3_step(). If TCL_BREAK
** is returned, then the SQL script has finished executing and there are
** no further rows available. This is similar to SQLITE_DONE.
*/
static int dbEvalStep(DbEvalContext *p){
  const char *zPrevSql = 0;       /* Previous value of p->zSql */

  
// ABS Label 371
if(p->pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}

// COR Label 372
if((p->zSql[0] && p->pPreStmt) != (p->zSql[0] || p->pPreStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 372);
}

// MCC Label 373
if(p->zSql[0] && p->pPreStmt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 373);
}
// MCC Label 374
if(p->zSql[0] && !(p->pPreStmt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 374);
}
// MCC Label 375
if(!(p->zSql[0]) && p->pPreStmt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 375);
}
// MCC Label 376
if(!(p->zSql[0]) && !(p->pPreStmt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 376);
}
while( p->zSql[0] || p->pPreStmt ){
    int rc;
    
// ABS Label 383
if(p->pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}

// ROR Label 384
if((p->pPreStmt != 0) != (p->pPreStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 384);
}
if( p->pPreStmt==0 ){
      zPrevSql = (p->zSql==zPrevSql ? 0 : p->zSql);
      rc = dbPrepareAndBind(p->pDb, p->zSql, &p->zSql, &p->pPreStmt);
      if( rc!=TCL_OK ) 
// ABS Label 385
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
return rc;
    }else{
      int rcs;
      
// ABS Label 386
if(p->pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
SqliteDb *pDb = p->pDb;
      
// ABS Label 387
if(p->pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}
SqlPreparedStmt *pPreStmt = p->pPreStmt;
      
// ABS Label 388
if(pPreStmt->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
sqlite3_stmt *pStmt = pPreStmt->pStmt;

      rcs = sqlite3_step(pStmt);
      
// ABS Label 390
if(rcs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}

// ROR Label 391
if((rcs != 100) != (rcs == 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}
if( rcs==SQLITE_ROW ){
        return TCL_OK;
      }
      if( p->pArray ){
        dbEvalRowInfo(p, 0, 0);
      }
      rcs = sqlite3_reset(pStmt);

      pDb->nStep = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_FULLSCAN_STEP,1);
      pDb->nSort = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_SORT,1);
      pDb->nIndex = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_AUTOINDEX,1);
      pDb->nVMStep = sqlite3_stmt_status(pStmt,SQLITE_STMTSTATUS_VM_STEP,1);
      
// ABS Label 389
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}
dbReleaseColumnNames(p);
      p->pPreStmt = 0;

      
// ABS Label 392
if(rcs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

// ROR Label 393
if((rcs == 0) != (rcs != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 393);
}
if( rcs!=SQLITE_OK ){
        /* If a run-time error occurs, report the error and stop reading
        ** the SQL.  */
        
// ABS Label 394
if(pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}

// ABS Label 395
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 395);
}
dbReleaseStmt(pDb, pPreStmt, 1);
#if SQLITE_TEST
        if( p->pDb->bLegacyPrepare && rcs==SQLITE_SCHEMA && zPrevSql ){
          /* If the runtime error was an SQLITE_SCHEMA, and the database
          ** handle is configured to use the legacy sqlite3_prepare()
          ** interface, retry prepare()/step() on the same SQL statement.
          ** This only happens once. If there is a second SQLITE_SCHEMA
          ** error, the error will be returned to the caller. */
          p->zSql = zPrevSql;
          continue;
        }
#endif
        Tcl_SetObjResult(pDb->interp,
                         Tcl_NewStringObj(sqlite3_errmsg(pDb->db), -1));
        return TCL_ERROR;
      }else{
        
// ABS Label 396
if(pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}

// ABS Label 397
if(pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
dbReleaseStmt(pDb, pPreStmt, 0);
      }
    }
  };
// ABS Label 377
if(p->pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}

// COR Label 378
if((p->zSql[0] && p->pPreStmt) != (p->zSql[0] || p->pPreStmt))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 378);
}

// MCC Label 379
if(p->zSql[0] && p->pPreStmt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(p->zSql[0] && !(p->pPreStmt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(!(p->zSql[0]) && p->pPreStmt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(!(p->zSql[0]) && !(p->pPreStmt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}


  /* Finished */
  return TCL_BREAK;
}

/*
** Free all resources currently held by the DbEvalContext structure passed
** as the first argument. There should be exactly one call to this function
** for each call to dbEvalInit().
*/
static void dbEvalFinalize(DbEvalContext *p){
  
// ABS Label 399
if(p->pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}
if( p->pPreStmt ){
    
// ABS Label 400
if(p->pPreStmt->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
sqlite3_reset(p->pPreStmt->pStmt);
    
// ABS Label 401
if(p->pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}

// ABS Label 402
if(p->pPreStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}
dbReleaseStmt(p->pDb, p->pPreStmt, 0);
    p->pPreStmt = 0;
  }
  if( p->pArray ){
    Tcl_DecrRefCount(p->pArray);
    p->pArray = 0;
  }
  Tcl_DecrRefCount(p->pSql);
  
// ABS Label 398
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}
dbReleaseColumnNames(p);
}

/*
** Return a pointer to a Tcl_Obj structure with ref-count 0 that contains
** the value for the iCol'th column of the row currently pointed to by
** the DbEvalContext structure passed as the first argument.
*/
static Tcl_Obj *dbEvalColumnValue(DbEvalContext *p, int iCol){
  
// ABS Label 403
if(p->pPreStmt->pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}
sqlite3_stmt *pStmt = p->pPreStmt->pStmt;
  switch( sqlite3_column_type(pStmt, iCol) ){
    case SQLITE_BLOB: {
      int bytes = sqlite3_column_bytes(pStmt, iCol);
      const char *zBlob = sqlite3_column_blob(pStmt, iCol);
      if( !zBlob ) bytes = 0;
      return Tcl_NewByteArrayObj((u8*)zBlob, bytes);
    }
    case SQLITE_INTEGER: {
      sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);
      
// ABS Label 404
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}

// COR Label 405
if((v >= -2147483647 || v <= 2147483647) != (v >= -2147483647 && v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 405);
}

// ROR Label 406
if((v < -2147483647) != (v >= -2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 406);
}
// ROR Label 407
if((v > -2147483647) != (v >= -2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 407);
}
// ROR Label 408
if((v <= -2147483647) != (v >= -2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}
// ROR Label 409
if((v < 2147483647) != (v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 409);
}
// ROR Label 410
if((v > 2147483647) != (v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
// ROR Label 411
if((v >= 2147483647) != (v <= 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 411);
}

// MCC Label 412
if(v >= -2147483647 && v <= 2147483647 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
// MCC Label 413
if(v >= -2147483647 && !(v <= 2147483647) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 413);
}
// MCC Label 414
if(!(v >= -2147483647) && v <= 2147483647 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 414);
}
// MCC Label 415
if(!(v >= -2147483647) && !(v <= 2147483647) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 415);
}
if( v>=-2147483647 && v<=2147483647 ){
        return Tcl_NewIntObj((int)v);
      }else{
        return Tcl_NewWideIntObj(v);
      }
    }
    case SQLITE_FLOAT: {
      return Tcl_NewDoubleObj(sqlite3_column_double(pStmt, iCol));
    }
    case SQLITE_NULL: {
      return Tcl_NewStringObj(p->pDb->zNull, -1);
    }
  }

  return Tcl_NewStringObj((char*)sqlite3_column_text(pStmt, iCol), -1);
}

/*
** If using Tcl version 8.6 or greater, use the NR functions to avoid
** recursive evalution of scripts by the [db eval] and [db trans]
** commands. Even if the headers used while compiling the extension
** are 8.6 or newer, the code still tests the Tcl version at runtime.
** This allows stubs-enabled builds to be used with older Tcl libraries.
*/
#if TCL_MAJOR_VERSION>8 || (TCL_MAJOR_VERSION==8 && TCL_MINOR_VERSION>=6)
# define SQLITE_TCL_NRE 1
static int DbUseNre(void){
  int major, minor;
  Tcl_GetVersion(&major, &minor, 0, 0);
  return( (major==8 && minor>=6) || major>8 );
}
#else
/*
** Compiling using headers earlier than 8.6. In this case NR cannot be
** used, so DbUseNre() to always return zero. Add #defines for the other
** Tcl_NRxxx() functions to prevent them from causing compilation errors,
** even though the only invocations of them are within conditional blocks
** of the form:
**
**   if( DbUseNre() ) { ... }
*/
# define SQLITE_TCL_NRE 0
# define DbUseNre() 0
# define Tcl_NRAddCallback(a,b,c,d,e,f) (void)0
# define Tcl_NREvalObj(a,b,c) 0
# define Tcl_NRCreateCommand(a,b,c,d,e,f) (void)0
#endif

/*
** This function is part of the implementation of the command:
**
**   $db eval SQL ?ARRAYNAME? SCRIPT
*/
static int SQLITE_TCLAPI DbEvalNextCmd(
  ClientData data[],                   /* data[0] is the (DbEvalContext*) */
  Tcl_Interp *interp,                  /* Tcl interpreter */
  int result                           /* Result so far */
){
  
// ABS Label 416
if(result < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
int rc = result;                     /* Return code */

  /* The first element of the data[] array is a pointer to a DbEvalContext
  ** structure allocated using Tcl_Alloc(). The second element of data[]
  ** is a pointer to a Tcl_Obj containing the script to run for each row
  ** returned by the queries encapsulated in data[0]. */
  DbEvalContext *p = (DbEvalContext *)data[0];
  Tcl_Obj *pScript = (Tcl_Obj *)data[1];
  Tcl_Obj *pArray = p->pArray;

  while( (rc==TCL_OK || rc==TCL_CONTINUE) && TCL_OK==(rc = dbEvalStep(p)) ){
    int i;
    int nCol;
    Tcl_Obj **apColName;
    dbEvalRowInfo(p, &nCol, &apColName);
    for(i=0; i<nCol; i++){
      if( pArray==0 ){
        Tcl_ObjSetVar2(interp, apColName[i], 0, dbEvalColumnValue(p,i), 0);
      }else if( (p->evalFlags & SQLITE_EVAL_WITHOUTNULLS)!=0
             && sqlite3_column_type(p->pPreStmt->pStmt, i)==SQLITE_NULL 
      ){
        Tcl_UnsetVar2(interp, Tcl_GetString(pArray), 
                      Tcl_GetString(apColName[i]), 0);
      }else{
        Tcl_ObjSetVar2(interp, pArray, apColName[i], dbEvalColumnValue(p,i), 0);
      }
    }

    /* The required interpreter variables are now populated with the data
    ** from the current row. If using NRE, schedule callbacks to evaluate
    ** script pScript, then to invoke this function again to fetch the next
    ** row (or clean up if there is no next row or the script throws an
    ** exception). After scheduling the callbacks, return control to the
    ** caller.
    **
    ** If not using NRE, evaluate pScript directly and continue with the
    ** next iteration of this while(...) loop.  */
    if( DbUseNre() ){
      Tcl_NRAddCallback(interp, DbEvalNextCmd, (void*)p, (void*)pScript, 0, 0);
      return Tcl_NREvalObj(interp, pScript, 0);
    }else{
      rc = Tcl_EvalObjEx(interp, pScript, 0);
    }
  }

  Tcl_DecrRefCount(pScript);
  
// ABS Label 417
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
dbEvalFinalize(p);
  Tcl_Free((char *)p);

  if( rc==TCL_OK || rc==TCL_BREAK ){
    Tcl_ResetResult(interp);
    rc = TCL_OK;
  }
  
// ABS Label 418
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
return rc;
}

/*
** This function is used by the implementations of the following database
** handle sub-commands:
**
**   $db update_hook ?SCRIPT?
**   $db wal_hook ?SCRIPT?
**   $db commit_hook ?SCRIPT?
**   $db preupdate hook ?SCRIPT?
*/
static void DbHookCmd(
  Tcl_Interp *interp,             /* Tcl interpreter */
  SqliteDb *pDb,                  /* Database handle */
  Tcl_Obj *pArg,                  /* SCRIPT argument (or NULL) */
  Tcl_Obj **ppHook                /* Pointer to member of SqliteDb */
){
  
// ABS Label 419
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}
sqlite3 *db = pDb->db;

  if( *ppHook ){
    Tcl_SetObjResult(interp, *ppHook);
    if( pArg ){
      Tcl_DecrRefCount(*ppHook);
      *ppHook = 0;
    }
  }
  if( pArg ){
    assert( !(*ppHook) );
    if( Tcl_GetCharLength(pArg)>0 ){
      *ppHook = pArg;
      Tcl_IncrRefCount(*ppHook);
    }
  }

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
  sqlite3_preupdate_hook(db, (pDb->pPreUpdateHook?DbPreUpdateHandler:0), pDb);
#endif
  sqlite3_update_hook(db, (pDb->pUpdateHook?DbUpdateHandler:0), pDb);
  sqlite3_rollback_hook(db, (pDb->pRollbackHook?DbRollbackHandler:0), pDb);
  sqlite3_wal_hook(db, (pDb->pWalHook?DbWalHandler:0), pDb);
}

/*
** The "sqlite" command below creates a new Tcl command for each
** connection it opens to an SQLite database.  This routine is invoked
** whenever one of those connection-specific commands is executed
** in Tcl.  For example, if you run Tcl code like this:
**
**       sqlite3 db1  "my_database"
**       db1 close
**
** The first command opens a connection to the "my_database" database
** and calls that connection "db1".  The second command causes this
** subroutine to be invoked.
*/
static int SQLITE_TCLAPI DbObjCmd(
  void *cd,
  Tcl_Interp *interp,
  int objc,
  Tcl_Obj *const*objv
){
  SqliteDb *pDb = (SqliteDb*)cd;
  int choice;
  int rc = TCL_OK;
  static const char *DB_strs[] = {
    "authorizer",             "backup",                "bind_fallback",
    "busy",                   "cache",                 "changes",
    "close",                  "collate",               "collation_needed",
    "commit_hook",            "complete",              "config",
    "copy",                   "deserialize",           "enable_load_extension",
    "errorcode",              "eval",                  "exists",
    "function",               "incrblob",              "interrupt",
    "last_insert_rowid",      "nullvalue",             "onecolumn",
    "preupdate",              "profile",               "progress",
    "rekey",                  "restore",               "rollback_hook",
    "serialize",              "status",                "timeout",
    "total_changes",          "trace",                 "trace_v2",
    "transaction",            "unlock_notify",         "update_hook",
    "version",                "wal_hook",              0
  };
  enum DB_enum {
    DB_AUTHORIZER,            DB_BACKUP,               DB_BIND_FALLBACK,
    DB_BUSY,                  DB_CACHE,                DB_CHANGES,
    DB_CLOSE,                 DB_COLLATE,              DB_COLLATION_NEEDED,
    DB_COMMIT_HOOK,           DB_COMPLETE,             DB_CONFIG,
    DB_COPY,                  DB_DESERIALIZE,          DB_ENABLE_LOAD_EXTENSION,
    DB_ERRORCODE,             DB_EVAL,                 DB_EXISTS,
    DB_FUNCTION,              DB_INCRBLOB,             DB_INTERRUPT,
    DB_LAST_INSERT_ROWID,     DB_NULLVALUE,            DB_ONECOLUMN,
    DB_PREUPDATE,             DB_PROFILE,              DB_PROGRESS,
    DB_REKEY,                 DB_RESTORE,              DB_ROLLBACK_HOOK,
    DB_SERIALIZE,             DB_STATUS,               DB_TIMEOUT,
    DB_TOTAL_CHANGES,         DB_TRACE,                DB_TRACE_V2,
    DB_TRANSACTION,           DB_UNLOCK_NOTIFY,        DB_UPDATE_HOOK,
    DB_VERSION,               DB_WAL_HOOK             
  };
  /* don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler */

  
// ABS Label 420
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 420);
}

// ROR Label 421
if((objc <= 2) != (objc < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 421);
}
// ROR Label 422
if((objc > 2) != (objc < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 422);
}
// ROR Label 423
if((objc >= 2) != (objc < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 423);
}
if( objc<2 ){
    Tcl_WrongNumArgs(interp, 1, objv, "SUBCOMMAND ...");
    return TCL_ERROR;
  }
  if( Tcl_GetIndexFromObj(interp, objv[1], DB_strs, "option", 0, &choice) ){
    return TCL_ERROR;
  }

  switch( (enum DB_enum)choice ){

  /*    $db authorizer ?CALLBACK?
  **
  ** Invoke the given callback to authorize each SQL operation as it is
  ** compiled.  5 arguments are appended to the callback before it is
  ** invoked:
  **
  **   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
  **   (2) First descriptive name (depends on authorization type)
  **   (3) Second descriptive name
  **   (4) Name of the database (ex: "main", "temp")
  **   (5) Name of trigger that is doing the access
  **
  ** The callback should return on of the following strings: SQLITE_OK,
  ** SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
  **
  ** If this method is invoked with no arguments, the current authorization
  ** callback string is returned.
  */
  case DB_AUTHORIZER: {
#ifdef SQLITE_OMIT_AUTHORIZATION
    Tcl_AppendResult(interp, "authorization not available in this build",
                     (char*)0);
    return TCL_ERROR;
#else
    
// ABS Label 424
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}

// ROR Label 425
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
// ROR Label 426
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 426);
}
// ROR Label 427
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
if( objc>3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?CALLBACK?");
      return TCL_ERROR;
    }else { 
// ABS Label 428
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// ROR Label 429
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 429);
}
if( objc==2 ){
      
// ABS Label 430
if(pDb->zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}
if( pDb->zAuth ){
        Tcl_AppendResult(interp, pDb->zAuth, (char*)0);
      }
    }else{
      char *zAuth;
      int len;
      
// ABS Label 431
if(pDb->zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
if( pDb->zAuth ){
        
// ABS Label 432
if(pDb->zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}
Tcl_Free(pDb->zAuth);
      }
      zAuth = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 433
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 433);
}
// ABS Label 434
if(zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}

// COR Label 435
if((zAuth || len > 0) != (zAuth && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 435);
}

// ROR Label 436
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
// ROR Label 438
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}

// MCC Label 439
if(zAuth && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 439);
}
// MCC Label 440
if(zAuth && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(!(zAuth) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(!(zAuth) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
if( zAuth && len>0 ){
        pDb->zAuth = Tcl_Alloc( len + 1 );
        memcpy(pDb->zAuth, zAuth, len+1);
      }else{
        pDb->zAuth = 0;
      }
      
// ABS Label 443
if(pDb->zAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}
if( pDb->zAuth ){
        typedef int (*sqlite3_auth_cb)(
           void*,int,const char*,const char*,
           const char*,const char*);
        pDb->interp = interp;
        
// ABS Label 444
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
sqlite3_set_authorizer(pDb->db,(sqlite3_auth_cb)auth_callback,pDb);
      }else{
        
// ABS Label 445
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}
sqlite3_set_authorizer(pDb->db, 0, 0);
      }
    };}

#endif
    break;
  }

  /*    $db backup ?DATABASE? FILENAME
  **
  ** Open or create a database file named FILENAME.  Transfer the
  ** content of local database DATABASE (default: "main") into the
  ** FILENAME database.
  */
  case DB_BACKUP: {
    const char *zDestFile;
    const char *zSrcDb;
    sqlite3 *pDest;
    sqlite3_backup *pBackup;

    
// ABS Label 448
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 448);
}

// ROR Label 449
if((objc != 3) != (objc == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 449);
}
if( objc==3 ){
      zSrcDb = "main";
      zDestFile = Tcl_GetString(objv[2]);
    }else { 
// ABS Label 450
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}

// ROR Label 451
if((objc != 4) != (objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
if( objc==4 ){
      zSrcDb = Tcl_GetString(objv[2]);
      zDestFile = Tcl_GetString(objv[3]);
    }else{
      Tcl_WrongNumArgs(interp, 2, objv, "?DATABASE? FILENAME");
      return TCL_ERROR;
    };}

    rc = sqlite3_open_v2(zDestFile, &pDest,
               SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE| pDb->openFlags, 0);
    
// ABS Label 452
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}

// ROR Label 453
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}
if( rc!=SQLITE_OK ){
      Tcl_AppendResult(interp, "cannot open target database: ",
           sqlite3_errmsg(pDest), (char*)0);
      
// ABS Label 454
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}
sqlite3_close(pDest);
      return TCL_ERROR;
    }
    pBackup = sqlite3_backup_init(pDest, "main", pDb->db, zSrcDb);
    
// ABS Label 455
if(pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}

// ROR Label 456
if((pBackup != 0) != (pBackup == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 456);
}
if( pBackup==0 ){
      Tcl_AppendResult(interp, "backup failed: ",
           sqlite3_errmsg(pDest), (char*)0);
      
// ABS Label 457
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
sqlite3_close(pDest);
      return TCL_ERROR;
    }
    while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK ){};
    
// ABS Label 446
if(pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 446);
}
sqlite3_backup_finish(pBackup);
    
// ABS Label 458
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}

// ROR Label 459
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 459);
}
if( rc==SQLITE_DONE ){
      rc = TCL_OK;
    }else{
      Tcl_AppendResult(interp, "backup failed: ",
           sqlite3_errmsg(pDest), (char*)0);
      rc = TCL_ERROR;
    }
    
// ABS Label 447
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 447);
}
sqlite3_close(pDest);
    break;
  }

  /*    $db bind_fallback ?CALLBACK?
  **
  ** When resolving bind parameters in an SQL statement, if the parameter
  ** cannot be associated with a TCL variable then invoke CALLBACK with a
  ** single argument that is the name of the parameter and use the return
  ** value of the CALLBACK as the binding.  If CALLBACK returns something
  ** other than TCL_OK or TCL_ERROR then bind a NULL.
  **
  ** If CALLBACK is an empty string, then revert to the default behavior 
  ** which is to set the binding to NULL.
  **
  ** If CALLBACK returns an error, that causes the statement execution to
  ** abort.  Hence, to configure a connection so that it throws an error
  ** on an attempt to bind an unknown variable, do something like this:
  **
  **     proc bind_error {name} {error "no such variable: $name"}
  **     db bind_fallback bind_error
  */
  case DB_BIND_FALLBACK: {
    
// ABS Label 460
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 460);
}

// ROR Label 461
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}
// ROR Label 462
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
// ROR Label 463
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 463);
}
if( objc>3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?CALLBACK?");
      return TCL_ERROR;
    }else { 
// ABS Label 464
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 464);
}

// ROR Label 465
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
if( objc==2 ){
      
// ABS Label 466
if(pDb->zBindFallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}
if( pDb->zBindFallback ){
        Tcl_AppendResult(interp, pDb->zBindFallback, (char*)0);
      }
    }else{
      char *zCallback;
      int len;
      
// ABS Label 467
if(pDb->zBindFallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 467);
}
if( pDb->zBindFallback ){
        
// ABS Label 468
if(pDb->zBindFallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 468);
}
Tcl_Free(pDb->zBindFallback);
      }
      zCallback = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 469
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 469);
}
// ABS Label 470
if(zCallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}

// COR Label 471
if((zCallback || len > 0) != (zCallback && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 471);
}

// ROR Label 472
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 472);
}
// ROR Label 473
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 473);
}
// ROR Label 474
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 474);
}

// MCC Label 475
if(zCallback && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 475);
}
// MCC Label 476
if(zCallback && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 476);
}
// MCC Label 477
if(!(zCallback) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 477);
}
// MCC Label 478
if(!(zCallback) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 478);
}
if( zCallback && len>0 ){
        pDb->zBindFallback = Tcl_Alloc( len + 1 );
        memcpy(pDb->zBindFallback, zCallback, len+1);
      }else{
        pDb->zBindFallback = 0;
      }
    };}

    break;
  }

  /*    $db busy ?CALLBACK?
  **
  ** Invoke the given callback if an SQL statement attempts to open
  ** a locked database file.
  */
  case DB_BUSY: {
    
// ABS Label 479
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// ROR Label 480
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
// ROR Label 481
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 481);
}
// ROR Label 482
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 482);
}
if( objc>3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "CALLBACK");
      return TCL_ERROR;
    }else { 
// ABS Label 483
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}

// ROR Label 484
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 484);
}
if( objc==2 ){
      
// ABS Label 485
if(pDb->zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}
if( pDb->zBusy ){
        Tcl_AppendResult(interp, pDb->zBusy, (char*)0);
      }
    }else{
      char *zBusy;
      int len;
      
// ABS Label 486
if(pDb->zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
if( pDb->zBusy ){
        
// ABS Label 487
if(pDb->zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
Tcl_Free(pDb->zBusy);
      }
      zBusy = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 488
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
// ABS Label 489
if(zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}

// COR Label 490
if((zBusy || len > 0) != (zBusy && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 490);
}

// ROR Label 491
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 491);
}
// ROR Label 492
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 492);
}
// ROR Label 493
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}

// MCC Label 494
if(zBusy && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
// MCC Label 495
if(zBusy && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 495);
}
// MCC Label 496
if(!(zBusy) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 496);
}
// MCC Label 497
if(!(zBusy) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
if( zBusy && len>0 ){
        pDb->zBusy = Tcl_Alloc( len + 1 );
        memcpy(pDb->zBusy, zBusy, len+1);
      }else{
        pDb->zBusy = 0;
      }
      
// ABS Label 498
if(pDb->zBusy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 498);
}
if( pDb->zBusy ){
        pDb->interp = interp;
        
// ABS Label 499
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 499);
}
sqlite3_busy_handler(pDb->db, DbBusyHandler, pDb);
      }else{
        
// ABS Label 500
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}
sqlite3_busy_handler(pDb->db, 0, 0);
      }
    };}

    break;
  }

  /*     $db cache flush
  **     $db cache size n
  **
  ** Flush the prepared statement cache, or set the maximum number of
  ** cached statements.
  */
  case DB_CACHE: {
    char *subCmd;
    int n;

    
// ABS Label 501
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}

// ROR Label 502
if((objc < 2) != (objc <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 502);
}
// ROR Label 503
if((objc > 2) != (objc <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 503);
}
// ROR Label 504
if((objc >= 2) != (objc <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 504);
}
if( objc<=2 ){
      Tcl_WrongNumArgs(interp, 1, objv, "cache option ?arg?");
      return TCL_ERROR;
    }
    subCmd = Tcl_GetStringFromObj( objv[2], 0 );
    
// MCC Label 505
if(*subCmd == 'f' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(!(*subCmd == 'f') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
if( *subCmd=='f' && strcmp(subCmd,"flush")==0 ){
      
// ABS Label 507
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 507);
}

// ROR Label 508
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 508);
}
if( objc!=3 ){
        Tcl_WrongNumArgs(interp, 2, objv, "flush");
        return TCL_ERROR;
      }else{
        
// ABS Label 509
if(pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}
flushStmtCache( pDb );
      }
    }else { 
// MCC Label 510
if(*subCmd == 's' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 510);
}
// MCC Label 511
if(!(*subCmd == 's') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 511);
}
if( *subCmd=='s' && strcmp(subCmd,"size")==0 ){
      
// ABS Label 512
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}

// ROR Label 513
if((objc == 4) != (objc != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}
if( objc!=4 ){
        Tcl_WrongNumArgs(interp, 2, objv, "size n");
        return TCL_ERROR;
      }else{
        if( TCL_ERROR==Tcl_GetIntFromObj(interp, objv[3], &n) ){
          Tcl_AppendResult( interp, "cannot convert \"",
               Tcl_GetStringFromObj(objv[3],0), "\" to integer", (char*)0);
          return TCL_ERROR;
        }else{
          
// ABS Label 514
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}

// ROR Label 515
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 515);
}
// ROR Label 516
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 516);
}
// ROR Label 517
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 517);
}
if( n<0 ){
            
// ABS Label 518
if(pDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}
flushStmtCache( pDb );
            n = 0;
          }else { 
// ABS Label 519
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}

// ROR Label 520
if((n <= 100) != (n > 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 520);
}
// ROR Label 521
if((n < 100) != (n > 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 521);
}
// ROR Label 522
if((n >= 100) != (n > 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 522);
}
if( n>MAX_PREPARED_STMTS ){
            n = MAX_PREPARED_STMTS;
          };}

          pDb->maxStmt = n;
        }
      }
    }else{
      Tcl_AppendResult( interp, "bad option \"",
          Tcl_GetStringFromObj(objv[2],0), "\": must be flush or size",
          (char*)0);
      return TCL_ERROR;
    };}

    break;
  }

  /*     $db changes
  **
  ** Return the number of rows that were modified, inserted, or deleted by
  ** the most recent INSERT, UPDATE or DELETE statement, not including
  ** any changes made by trigger programs.
  */
  case DB_CHANGES: {
    Tcl_Obj *pResult;
    
// ABS Label 523
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}

// ROR Label 524
if((objc == 2) != (objc != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
if( objc!=2 ){
      Tcl_WrongNumArgs(interp, 2, objv, "");
      return TCL_ERROR;
    }
    pResult = Tcl_GetObjResult(interp);
    Tcl_SetWideIntObj(pResult, sqlite3_changes64(pDb->db));
    break;
  }

  /*    $db close
  **
  ** Shutdown the database
  */
  case DB_CLOSE: {
    Tcl_DeleteCommand(interp, Tcl_GetStringFromObj(objv[0], 0));
    break;
  }

  /*
  **     $db collate NAME SCRIPT
  **
  ** Create a new SQL collation function called NAME.  Whenever
  ** that function is called, invoke SCRIPT to evaluate the function.
  */
  case DB_COLLATE: {
    SqlCollate *pCollate;
    char *zName;
    char *zScript;
    int nScript;
    
// ABS Label 525
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}

// ROR Label 526
if((objc == 4) != (objc != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 526);
}
if( objc!=4 ){
      Tcl_WrongNumArgs(interp, 2, objv, "NAME SCRIPT");
      return TCL_ERROR;
    }
    zName = Tcl_GetStringFromObj(objv[2], 0);
    zScript = Tcl_GetStringFromObj(objv[3], &nScript);
    pCollate = (SqlCollate*)Tcl_Alloc( sizeof(*pCollate) + nScript + 1 );
    if( pCollate==0 ) return TCL_ERROR;
    pCollate->interp = interp;
    pCollate->pNext = pDb->pCollate;
    pCollate->zScript = (char*)&pCollate[1];
    pDb->pCollate = pCollate;
    memcpy(pCollate->zScript, zScript, nScript+1);
    if( sqlite3_create_collation(pDb->db, zName, SQLITE_UTF8,
        pCollate, tclSqlCollate) ){
      Tcl_SetResult(interp, (char *)sqlite3_errmsg(pDb->db), TCL_VOLATILE);
      return TCL_ERROR;
    }
    break;
  }

  /*
  **     $db collation_needed SCRIPT
  **
  ** Create a new SQL collation function called NAME.  Whenever
  ** that function is called, invoke SCRIPT to evaluate the function.
  */
  case DB_COLLATION_NEEDED: {
    
// ABS Label 528
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}

// ROR Label 529
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 529);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "SCRIPT");
      return TCL_ERROR;
    }
    if( pDb->pCollateNeeded ){
      Tcl_DecrRefCount(pDb->pCollateNeeded);
    }
    pDb->pCollateNeeded = Tcl_DuplicateObj(objv[2]);
    Tcl_IncrRefCount(pDb->pCollateNeeded);
    
// ABS Label 527
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}
sqlite3_collation_needed(pDb->db, pDb, tclCollateNeeded);
    break;
  }

  /*    $db commit_hook ?CALLBACK?
  **
  ** Invoke the given callback just before committing every SQL transaction.
  ** If the callback throws an exception or returns non-zero, then the
  ** transaction is aborted.  If CALLBACK is an empty string, the callback
  ** is disabled.
  */
  case DB_COMMIT_HOOK: {
    
// ABS Label 530
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}

// ROR Label 531
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 531);
}
// ROR Label 532
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 532);
}
// ROR Label 533
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 533);
}
if( objc>3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?CALLBACK?");
      return TCL_ERROR;
    }else { 
// ABS Label 534
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}

// ROR Label 535
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 535);
}
if( objc==2 ){
      
// ABS Label 536
if(pDb->zCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}
if( pDb->zCommit ){
        Tcl_AppendResult(interp, pDb->zCommit, (char*)0);
      }
    }else{
      const char *zCommit;
      int len;
      
// ABS Label 537
if(pDb->zCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}
if( pDb->zCommit ){
        
// ABS Label 538
if(pDb->zCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 538);
}
Tcl_Free(pDb->zCommit);
      }
      zCommit = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 539
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}
// ABS Label 540
if(zCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}

// COR Label 541
if((zCommit || len > 0) != (zCommit && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 541);
}

// ROR Label 542
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 542);
}
// ROR Label 543
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 543);
}
// ROR Label 544
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 544);
}

// MCC Label 545
if(zCommit && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 545);
}
// MCC Label 546
if(zCommit && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 546);
}
// MCC Label 547
if(!(zCommit) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 547);
}
// MCC Label 548
if(!(zCommit) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 548);
}
if( zCommit && len>0 ){
        pDb->zCommit = Tcl_Alloc( len + 1 );
        memcpy(pDb->zCommit, zCommit, len+1);
      }else{
        pDb->zCommit = 0;
      }
      
// ABS Label 549
if(pDb->zCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}
if( pDb->zCommit ){
        pDb->interp = interp;
        
// ABS Label 550
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}
sqlite3_commit_hook(pDb->db, DbCommitHandler, pDb);
      }else{
        
// ABS Label 551
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 551);
}
sqlite3_commit_hook(pDb->db, 0, 0);
      }
    };}

    break;
  }

  /*    $db complete SQL
  **
  ** Return TRUE if SQL is a complete SQL statement.  Return FALSE if
  ** additional lines of input are needed.  This is similar to the
  ** built-in "info complete" command of Tcl.
  */
  case DB_COMPLETE: {
#ifndef SQLITE_OMIT_COMPLETE
    Tcl_Obj *pResult;
    int isComplete;
    
// ABS Label 552
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}

// ROR Label 553
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 553);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "SQL");
      return TCL_ERROR;
    }
    isComplete = sqlite3_complete( Tcl_GetStringFromObj(objv[2], 0) );
    pResult = Tcl_GetObjResult(interp);
    Tcl_SetBooleanObj(pResult, isComplete);
#endif
    break;
  }

  /*    $db config ?OPTION? ?BOOLEAN?
  **
  ** Configure the database connection using the sqlite3_db_config()
  ** interface.
  */
  case DB_CONFIG: {
    static const struct DbConfigChoices {
      const char *zName;
      int op;
    } aDbConfig[] = {
        { "defensive",          SQLITE_DBCONFIG_DEFENSIVE             },
        { "dqs_ddl",            SQLITE_DBCONFIG_DQS_DDL               },
        { "dqs_dml",            SQLITE_DBCONFIG_DQS_DML               },
        { "enable_fkey",        SQLITE_DBCONFIG_ENABLE_FKEY           },
        { "enable_qpsg",        SQLITE_DBCONFIG_ENABLE_QPSG           },
        { "enable_trigger",     SQLITE_DBCONFIG_ENABLE_TRIGGER        },
        { "enable_view",        SQLITE_DBCONFIG_ENABLE_VIEW           },
        { "fts3_tokenizer",     SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER },
        { "legacy_alter_table", SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    },
        { "legacy_file_format", SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    },
        { "load_extension",     SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION },
        { "no_ckpt_on_close",   SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      },
        { "reset_database",     SQLITE_DBCONFIG_RESET_DATABASE        },
        { "trigger_eqp",        SQLITE_DBCONFIG_TRIGGER_EQP           },
        { "trusted_schema",     SQLITE_DBCONFIG_TRUSTED_SCHEMA        },
        { "writable_schema",    SQLITE_DBCONFIG_WRITABLE_SCHEMA       },
    };
    Tcl_Obj *pResult;
    int ii;
    
// ABS Label 554
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}

// ROR Label 555
if((objc <= 4) != (objc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}
// ROR Label 556
if((objc < 4) != (objc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 556);
}
// ROR Label 557
if((objc >= 4) != (objc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 557);
}
if( objc>4 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?OPTION? ?BOOLEAN?");
      return TCL_ERROR;
    }
    
// ABS Label 558
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// ROR Label 559
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 559);
}
if( objc==2 ){
      /* With no arguments, list all configuration options and with the
      ** current value */
      pResult = Tcl_NewListObj(0,0);
      ii = 0;

// AOR Label 560
if(sizeof (aDbConfig) - sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 560);
}
// AOR Label 561
if(sizeof (aDbConfig) + sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 561);
}
// AOR Label 562
if(sizeof (aDbConfig) * sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 562);
}

// ROR Label 563
if((ii <= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 563);
}
// ROR Label 564
if((ii > sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}
// ROR Label 565
if((ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 565);
}
for(; ii<sizeof(aDbConfig)/sizeof(aDbConfig[0]); ii++){
        int v = 0;
        
// ABS Label 572
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 572);
}

// ABS Label 573
if(aDbConfig[ii].op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}
sqlite3_db_config(pDb->db, aDbConfig[ii].op, -1, &v);
        Tcl_ListObjAppendElement(interp, pResult,
           Tcl_NewStringObj(aDbConfig[ii].zName,-1));
        Tcl_ListObjAppendElement(interp, pResult,
           Tcl_NewIntObj(v));
      };
// AOR Label 566
if(sizeof (aDbConfig) - sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 566);
}
// AOR Label 567
if(sizeof (aDbConfig) + sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 567);
}
// AOR Label 568
if(sizeof (aDbConfig) * sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 568);
}

// ROR Label 569
if((ii <= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 569);
}
// ROR Label 570
if((ii > sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 570);
}
// ROR Label 571
if((ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}

    }else{
      const char *zOpt = Tcl_GetString(objv[2]);
      int onoff = -1;
      int v = 0;
      
// ROR Label 577
if((zOpt[0] != '-') != (zOpt[0] == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 577);
}
if( zOpt[0]=='-' ) zOpt++;
      ii = 0;

// AOR Label 578
if(sizeof (aDbConfig) - sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 578);
}
// AOR Label 579
if(sizeof (aDbConfig) + sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 579);
}
// AOR Label 580
if(sizeof (aDbConfig) * sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 580);
}

// ROR Label 581
if((ii <= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 581);
}
// ROR Label 582
if((ii > sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 582);
}
// ROR Label 583
if((ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 583);
}
for(; ii<sizeof(aDbConfig)/sizeof(aDbConfig[0]); ii++){
        if( strcmp(aDbConfig[ii].zName, zOpt)==0 ) break;
      };
// AOR Label 584
if(sizeof (aDbConfig) - sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 584);
}
// AOR Label 585
if(sizeof (aDbConfig) + sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 585);
}
// AOR Label 586
if(sizeof (aDbConfig) * sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 586);
}

// ROR Label 587
if((ii <= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 587);
}
// ROR Label 588
if((ii > sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 588);
}
// ROR Label 589
if((ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 589);
}

      
// AOR Label 590
if(sizeof (aDbConfig) - sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 590);
}
// AOR Label 591
if(sizeof (aDbConfig) + sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 591);
}
// AOR Label 592
if(sizeof (aDbConfig) * sizeof (aDbConfig[0]) != sizeof (aDbConfig) / sizeof (aDbConfig[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 592);
}

// ROR Label 593
if((ii < sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((ii > sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}
// ROR Label 595
if((ii <= sizeof (aDbConfig) / sizeof (aDbConfig[0])) != (ii >= sizeof (aDbConfig) / sizeof (aDbConfig[0])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 595);
}
if( ii>=sizeof(aDbConfig)/sizeof(aDbConfig[0]) ){
        Tcl_AppendResult(interp, "unknown config option: \"", zOpt,
                                "\"", (void*)0);
        return TCL_ERROR;
      }
      
// ABS Label 596
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}

// ROR Label 597
if((objc != 4) != (objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 597);
}
if( objc==4 ){
        if( Tcl_GetBooleanFromObj(interp, objv[3], &onoff) ){
          return TCL_ERROR;
        }
      }
      
// ABS Label 574
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}

// ABS Label 575
if(aDbConfig[ii].op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 575);
}

// ABS Label 576
if(onoff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 576);
}
sqlite3_db_config(pDb->db, aDbConfig[ii].op, onoff, &v);
      pResult = Tcl_NewIntObj(v);
    }
    Tcl_SetObjResult(interp, pResult);
    break;
  }

  /*    $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
  **
  ** Copy data into table from filename, optionally using SEPARATOR
  ** as column separators.  If a column contains a null string, or the
  ** value of NULLINDICATOR, a NULL is inserted for the column.
  ** conflict-algorithm is one of the sqlite conflict algorithms:
  **    rollback, abort, fail, ignore, replace
  ** On success, return the number of lines processed, not necessarily same
  ** as 'db changes' due to conflict-algorithm selected.
  **
  ** This code is basically an implementation/enhancement of
  ** the sqlite3 shell.c ".import" command.
  **
  ** This command usage is equivalent to the sqlite2.x COPY statement,
  ** which imports file data into a table using the PostgreSQL COPY file format:
  **   $db copy $conflit_algo $table_name $filename \t \\N
  */
  case DB_COPY: {
    char *zTable;               /* Insert data into this table */
    char *zFile;                /* The file from which to extract data */
    char *zConflict;            /* The conflict algorithm to use */
    sqlite3_stmt *pStmt;        /* A statement */
    int nCol;                   /* Number of columns in the table */
    int nByte;                  /* Number of bytes in an SQL string */
    int i, j;                   /* Loop counters */
    int nSep;                   /* Number of bytes in zSep[] */
    int nNull;                  /* Number of bytes in zNull[] */
    char *zSql;                 /* An SQL statement */
    char *zLine;                /* A single line of input from the file */
    char **azCol;               /* zLine[] broken up into columns */
    const char *zCommit;        /* How to commit changes */
    FILE *in;                   /* The input file */
    int lineno = 0;             /* Line number of input file */
    char zLineNum[80];          /* Line number print buffer */
    Tcl_Obj *pResult;           /* interp result */

    const char *zSep;
    const char *zNull;
    
// ABS Label 607
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}

// COR Label 608
if((objc < 5 && objc > 7) != (objc < 5 || objc > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 608);
}

// ROR Label 609
if((objc <= 5) != (objc < 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 609);
}
// ROR Label 610
if((objc > 5) != (objc < 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}
// ROR Label 611
if((objc >= 5) != (objc < 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 611);
}
// ROR Label 612
if((objc <= 7) != (objc > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 612);
}
// ROR Label 613
if((objc < 7) != (objc > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 613);
}
// ROR Label 614
if((objc >= 7) != (objc > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 614);
}

// MCC Label 615
if(objc < 5 && objc > 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 615);
}
// MCC Label 616
if(objc < 5 && !(objc > 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 616);
}
// MCC Label 617
if(!(objc < 5) && objc > 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 617);
}
// MCC Label 618
if(!(objc < 5) && !(objc > 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 618);
}
if( objc<5 || objc>7 ){
      Tcl_WrongNumArgs(interp, 2, objv,
         "CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?");
      return TCL_ERROR;
    }
    
// ABS Label 619
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// ROR Label 620
if((objc < 6) != (objc >= 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
// ROR Label 621
if((objc > 6) != (objc >= 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}
// ROR Label 622
if((objc <= 6) != (objc >= 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 622);
}
if( objc>=6 ){
      zSep = Tcl_GetStringFromObj(objv[5], 0);
    }else{
      zSep = "\t";
    }
    
// ABS Label 623
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}

// ROR Label 624
if((objc < 7) != (objc >= 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 624);
}
// ROR Label 625
if((objc > 7) != (objc >= 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}
// ROR Label 626
if((objc <= 7) != (objc >= 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 626);
}
if( objc>=7 ){
      zNull = Tcl_GetStringFromObj(objv[6], 0);
    }else{
      zNull = "";
    }
    zConflict = Tcl_GetStringFromObj(objv[2], 0);
    zTable = Tcl_GetStringFromObj(objv[3], 0);
    zFile = Tcl_GetStringFromObj(objv[4], 0);
    nSep = strlen30(zSep);
    nNull = strlen30(zNull);
    
// ABS Label 627
if(nSep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 627);
}

// ROR Label 628
if((nSep != 0) != (nSep == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 628);
}
if( nSep==0 ){
      Tcl_AppendResult(interp,"Error: non-null separator required for copy",
                       (char*)0);
      return TCL_ERROR;
    }
    
// MCC Label 629
if(1 && 1 && 1 && 1 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 629);
}
if(strcmp(zConflict, "rollback") != 0 &&
       strcmp(zConflict, "abort"   ) != 0 &&
       strcmp(zConflict, "fail"    ) != 0 &&
       strcmp(zConflict, "ignore"  ) != 0 &&
       strcmp(zConflict, "replace" ) != 0 ) {
      Tcl_AppendResult(interp, "Error: \"", zConflict,
            "\", conflict-algorithm must be one of: rollback, "
            "abort, fail, ignore, or replace", (char*)0);
      return TCL_ERROR;
    }
    zSql = sqlite3_mprintf("SELECT * FROM '%q'", zTable);
    
// ABS Label 630
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}

// ROR Label 631
if((zSql != 0) != (zSql == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}
if( zSql==0 ){
      Tcl_AppendResult(interp, "Error: no such table: ", zTable, (char*)0);
      return TCL_ERROR;
    }
    nByte = strlen30(zSql);
    rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);
    sqlite3_free(zSql);
    
// ABS Label 632
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 632);
}
if( rc ){
      Tcl_AppendResult(interp, "Error: ", sqlite3_errmsg(pDb->db), (char*)0);
      nCol = 0;
    }else{
      nCol = sqlite3_column_count(pStmt);
    }
    
// ABS Label 598
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}
sqlite3_finalize(pStmt);
    
// ABS Label 633
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 633);
}

// ROR Label 634
if((nCol != 0) != (nCol == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 634);
}
if( nCol==0 ) {
      return TCL_ERROR;
    }
    zSql = malloc( nByte + 50 + nCol*2 );
    
// ABS Label 635
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}

// ROR Label 636
if((zSql != 0) != (zSql == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
if( zSql==0 ) {
      Tcl_AppendResult(interp, "Error: can't malloc()", (char*)0);
      return TCL_ERROR;
    }
    
// ABS Label 599
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}

// AOR Label 600
if(nByte - 50 != nByte + 50)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 600);
}
// AOR Label 601
if(nByte / 50 != nByte + 50)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 601);
}
// AOR Label 602
if(nByte * 50 != nByte + 50)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 602);
}

// ABS Label 603
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}

// ABS Label 604
if(zConflict < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}

// ABS Label 605
if(zTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}
sqlite3_snprintf(nByte+50, zSql, "INSERT OR %q INTO '%q' VALUES(?",
         zConflict, zTable);
    j = strlen30(zSql);
    i = 1;

// ABS Label 637
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}
// ABS Label 638
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 638);
}

// ROR Label 639
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 639);
}
// ROR Label 640
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 640);
}
// ROR Label 641
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 641);
}
for(; i<nCol; i++){
      zSql[j++] = ',';
      zSql[j++] = '?';
    };
// ABS Label 642
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 642);
}
// ABS Label 643
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}

// ROR Label 644
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 644);
}
// ROR Label 645
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 645);
}
// ROR Label 646
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 646);
}

    zSql[j++] = ')';
    zSql[j] = 0;
    rc = sqlite3_prepare(pDb->db, zSql, -1, &pStmt, 0);
    free(zSql);
    
// ABS Label 647
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}
if( rc ){
      Tcl_AppendResult(interp, "Error: ", sqlite3_errmsg(pDb->db), (char*)0);
      
// ABS Label 648
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}
sqlite3_finalize(pStmt);
      return TCL_ERROR;
    }
    in = fopen(zFile, "rb");
    if( in==0 ){
      Tcl_AppendResult(interp, "Error: cannot open file: ", zFile, (char*)0);
      
// ABS Label 649
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}
sqlite3_finalize(pStmt);
      return TCL_ERROR;
    }
    azCol = malloc( sizeof(azCol[0])*(nCol+1) );
    
// ABS Label 650
if(azCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}

// ROR Label 651
if((azCol != 0) != (azCol == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}
if( azCol==0 ) {
      Tcl_AppendResult(interp, "Error: can't malloc()", (char*)0);
      fclose(in);
      return TCL_ERROR;
    }
    (void)sqlite3_exec(pDb->db, "BEGIN", 0, 0, 0);
    zCommit = "COMMIT";
    while( (zLine = local_getline(0, in))!=0 ){
      char *z;
      lineno++;
      azCol[0] = zLine;
      for(i=0, z=zLine; *z; z++){
        if( *z==zSep[0] && strncmp(z, zSep, nSep)==0 ){
          *z = 0;
          i++;
          if( i<nCol ){
            azCol[i] = &z[nSep];
            z += nSep-1;
          }
        }
      }
      if( i+1!=nCol ){
        char *zErr;
        int nErr = strlen30(zFile) + 200;
        zErr = malloc(nErr);
        if( zErr ){
          sqlite3_snprintf(nErr, zErr,
             "Error: %s line %d: expected %d columns of data but found %d",
             zFile, lineno, nCol, i+1);
          Tcl_AppendResult(interp, zErr, (char*)0);
          free(zErr);
        }
        zCommit = "ROLLBACK";
        break;
      }
      for(i=0; i<nCol; i++){
        /* check for null data, if so, bind as null */
        if( (nNull>0 && strcmp(azCol[i], zNull)==0)
          || strlen30(azCol[i])==0
        ){
          sqlite3_bind_null(pStmt, i+1);
        }else{
          sqlite3_bind_text(pStmt, i+1, azCol[i], -1, SQLITE_STATIC);
        }
      }
      sqlite3_step(pStmt);
      rc = sqlite3_reset(pStmt);
      free(zLine);
      if( rc!=SQLITE_OK ){
        Tcl_AppendResult(interp,"Error: ", sqlite3_errmsg(pDb->db), (char*)0);
        zCommit = "ROLLBACK";
        break;
      }
    }
    free(azCol);
    fclose(in);
    
// ABS Label 606
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}
sqlite3_finalize(pStmt);
    (void)sqlite3_exec(pDb->db, zCommit, 0, 0, 0);

    
// ROR Label 652
if((zCommit[0] != 'C') != (zCommit[0] == 'C'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 652);
}
if( zCommit[0] == 'C' ){
      /* success, set result as number of lines processed */
      pResult = Tcl_GetObjResult(interp);
      Tcl_SetIntObj(pResult, lineno);
      rc = TCL_OK;
    }else{
      /* failure, append lineno where failed */
      
// ABS Label 653
if(lineno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}
sqlite3_snprintf(sizeof(zLineNum), zLineNum,"%d",lineno);
      Tcl_AppendResult(interp,", failed while processing line: ",zLineNum,
                       (char*)0);
      rc = TCL_ERROR;
    }
    break;
  }

  /*
  **     $db deserialize ?-maxsize N? ?-readonly BOOL? ?DATABASE? VALUE
  **
  ** Reopen DATABASE (default "main") using the content in $VALUE
  */
  case DB_DESERIALIZE: {
#ifdef SQLITE_OMIT_DESERIALIZE
    Tcl_AppendResult(interp, "MEMDB not available in this build",
                     (char*)0);
    rc = TCL_ERROR;
#else
    const char *zSchema = 0;
    Tcl_Obj *pValue = 0;
    unsigned char *pBA;
    unsigned char *pData;
    int len, xrc;
    sqlite3_int64 mxSize = 0;
    int i;
    int isReadonly = 0;


    
// ABS Label 654
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}

// ROR Label 655
if((objc <= 3) != (objc < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 655);
}
// ROR Label 656
if((objc > 3) != (objc < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 656);
}
// ROR Label 657
if((objc >= 3) != (objc < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 657);
}
if( objc<3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?DATABASE? VALUE");
      rc = TCL_ERROR;
      break;
    }
    i = 2;

// ABS Label 658
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
// ABS Label 659
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}

// AOR Label 660
if(objc / 1 != objc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 660);
}
// AOR Label 661
if(objc + 1 != objc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 661);
}
// AOR Label 662
if(objc * 1 != objc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 662);
}

// ROR Label 663
if((i <= objc - 1) != (i < objc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 663);
}
// ROR Label 664
if((i > objc - 1) != (i < objc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 664);
}
// ROR Label 665
if((i >= objc - 1) != (i < objc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 665);
}
for(; i<objc-1; i++){
      const char *z = Tcl_GetString(objv[i]);
      
// ABS Label 674
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}
// ABS Label 675
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}

// AOR Label 676
if(objc / 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 676);
}
// AOR Label 677
if(objc + 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 677);
}
// AOR Label 678
if(objc * 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 678);
}

// ROR Label 679
if((i <= objc - 2) != (i < objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 679);
}
// ROR Label 680
if((i > objc - 2) != (i < objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 680);
}
// ROR Label 681
if((i >= objc - 2) != (i < objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 681);
}

// MCC Label 682
if(1 && i < objc - 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 682);
}
// MCC Label 683
if(1 && !(i < objc - 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 683);
}
if( strcmp(z,"-maxsize")==0 && i<objc-2 ){
        rc = Tcl_GetWideIntFromObj(interp, objv[++i], &mxSize);
        
// ABS Label 684
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 684);
}
if( rc ) goto deserialize_error;
        continue;
      }
      
// ABS Label 685
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}
// ABS Label 686
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}

// AOR Label 687
if(objc / 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 687);
}
// AOR Label 688
if(objc + 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 688);
}
// AOR Label 689
if(objc * 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 689);
}

// ROR Label 690
if((i <= objc - 2) != (i < objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 690);
}
// ROR Label 691
if((i > objc - 2) != (i < objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 691);
}
// ROR Label 692
if((i >= objc - 2) != (i < objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 692);
}

// MCC Label 693
if(1 && i < objc - 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 693);
}
// MCC Label 694
if(1 && !(i < objc - 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 694);
}
if( strcmp(z,"-readonly")==0 && i<objc-2 ){
        rc = Tcl_GetBooleanFromObj(interp, objv[++i], &isReadonly);
        
// ABS Label 695
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}
if( rc ) goto deserialize_error;
        continue;
      }
      
// ABS Label 696
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}
// ABS Label 697
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}
// ABS Label 698
if(zSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 698);
}

// AOR Label 699
if(objc / 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 699);
}
// AOR Label 700
if(objc + 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 700);
}
// AOR Label 701
if(objc * 2 != objc - 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 701);
}

// COR Label 702
if((zSchema == 0 && i == objc - 2 || z[0] != '-') != (zSchema == 0 && i == objc - 2 && z[0] != '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 702);
}
// COR Label 703
if((zSchema == 0 || i == objc - 2) != (zSchema == 0 && i == objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 703);
}

// ROR Label 704
if((zSchema != 0) != (zSchema == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 704);
}
// ROR Label 705
if((i != objc - 2) != (i == objc - 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 705);
}
// ROR Label 706
if((z[0] == '-') != (z[0] != '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 706);
}

// MCC Label 707
if(zSchema == 0 && i == objc - 2 && z[0] != '-' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 707);
}
// MCC Label 708
if(zSchema == 0 && i == objc - 2 && !(z[0] != '-') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 708);
}
// MCC Label 709
if(zSchema == 0 && !(i == objc - 2) && z[0] != '-' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 709);
}
// MCC Label 710
if(zSchema == 0 && !(i == objc - 2) && !(z[0] != '-') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 710);
}
// MCC Label 711
if(!(zSchema == 0) && i == objc - 2 && z[0] != '-' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 711);
}
// MCC Label 712
if(!(zSchema == 0) && i == objc - 2 && !(z[0] != '-') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 712);
}
// MCC Label 713
if(!(zSchema == 0) && !(i == objc - 2) && z[0] != '-' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 713);
}
// MCC Label 714
if(!(zSchema == 0) && !(i == objc - 2) && !(z[0] != '-') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 714);
}
if( zSchema==0 && i==objc-2 && z[0]!='-' ){
        zSchema = z;
        continue;
      }
      Tcl_AppendResult(interp, "unknown option: ", z, (char*)0);
      rc = TCL_ERROR;
      goto deserialize_error;
    };
// ABS Label 666
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}
// ABS Label 667
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}

// AOR Label 668
if(objc / 1 != objc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 668);
}
// AOR Label 669
if(objc + 1 != objc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 669);
}
// AOR Label 670
if(objc * 1 != objc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 670);
}

// ROR Label 671
if((i <= objc - 1) != (i < objc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 671);
}
// ROR Label 672
if((i > objc - 1) != (i < objc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 672);
}
// ROR Label 673
if((i >= objc - 1) != (i < objc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 673);
}

    pValue = objv[objc-1];
    pBA = Tcl_GetByteArrayFromObj(pValue, &len);
    pData = sqlite3_malloc64( len );
    
// ABS Label 715
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 715);
}
// ABS Label 716
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}

// COR Label 717
if((pData == 0 || len > 0) != (pData == 0 && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 717);
}

// ROR Label 718
if((pData != 0) != (pData == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 718);
}
// ROR Label 719
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 719);
}
// ROR Label 720
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}
// ROR Label 721
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 721);
}

// MCC Label 722
if(pData == 0 && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 722);
}
// MCC Label 723
if(pData == 0 && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 723);
}
// MCC Label 724
if(!(pData == 0) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 724);
}
// MCC Label 725
if(!(pData == 0) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 725);
}
if( pData==0 && len>0 ){
      Tcl_AppendResult(interp, "out of memory", (char*)0);
      rc = TCL_ERROR;
    }else{
      int flags;
      
// ABS Label 726
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}

// ROR Label 727
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 727);
}
// ROR Label 728
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 728);
}
// ROR Label 729
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 729);
}
if( len>0 ) memcpy(pData, pBA, len);
      
// ABS Label 730
if(isReadonly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
if( isReadonly ){
        flags = SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_READONLY;
      }else{
        flags = SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_RESIZEABLE;
      }
      xrc = sqlite3_deserialize(pDb->db, zSchema, pData, len, len, flags);
      
// ABS Label 731
if(xrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}
if( xrc ){
        Tcl_AppendResult(interp, "unable to set MEMDB content", (char*)0);
        rc = TCL_ERROR;
      }
      
// ABS Label 732
if(mxSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}

// ROR Label 733
if((mxSize <= 0) != (mxSize > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 733);
}
// ROR Label 734
if((mxSize < 0) != (mxSize > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 734);
}
// ROR Label 735
if((mxSize >= 0) != (mxSize > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 735);
}
if( mxSize>0 ){
        
// ABS Label 736
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// ABS Label 737
if(zSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 737);
}
sqlite3_file_control(pDb->db, zSchema,SQLITE_FCNTL_SIZE_LIMIT,&mxSize);
      }
    }
deserialize_error:
#endif
    break; 
  }

  /*
  **    $db enable_load_extension BOOLEAN
  **
  ** Turn the extension loading feature on or off.  It if off by
  ** default.
  */
  case DB_ENABLE_LOAD_EXTENSION: {
#ifndef SQLITE_OMIT_LOAD_EXTENSION
    int onoff;
    
// ABS Label 740
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}

// ROR Label 741
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 741);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "BOOLEAN");
      return TCL_ERROR;
    }
    if( Tcl_GetBooleanFromObj(interp, objv[2], &onoff) ){
      return TCL_ERROR;
    }
    
// ABS Label 738
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 738);
}

// ABS Label 739
if(onoff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 739);
}
sqlite3_enable_load_extension(pDb->db, onoff);
    break;
#else
    Tcl_AppendResult(interp, "extension loading is turned off at compile-time",
                     (char*)0);
    return TCL_ERROR;
#endif
  }

  /*
  **    $db errorcode
  **
  ** Return the numeric error code that was returned by the most recent
  ** call to sqlite3_exec().
  */
  case DB_ERRORCODE: {
    Tcl_SetObjResult(interp, Tcl_NewIntObj(sqlite3_errcode(pDb->db)));
    break;
  }

  /*
  **    $db exists $sql
  **    $db onecolumn $sql
  **
  ** The onecolumn method is the equivalent of:
  **     lindex [$db eval $sql] 0
  */
  case DB_EXISTS:
  case DB_ONECOLUMN: {
    Tcl_Obj *pResult = 0;
    DbEvalContext sEval;
    
// ABS Label 742
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}

// ROR Label 743
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 743);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "SQL");
      return TCL_ERROR;
    }

    dbEvalInit(&sEval, pDb, objv[2], 0, 0);
    rc = dbEvalStep(&sEval);
    
// ABS Label 744
if(choice < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 744);
}

// ROR Label 745
if((choice != DB_ONECOLUMN) != (choice == DB_ONECOLUMN))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 745);
}
if( choice==DB_ONECOLUMN ){
      if( rc==TCL_OK ){
        pResult = dbEvalColumnValue(&sEval, 0);
      }else { if( rc==TCL_BREAK ){
        Tcl_ResetResult(interp);
      };}

    }else { if( rc==TCL_BREAK || rc==TCL_OK ){
      pResult = Tcl_NewBooleanObj(rc==TCL_OK);
    };}

    dbEvalFinalize(&sEval);
    if( pResult ) Tcl_SetObjResult(interp, pResult);

    if( rc==TCL_BREAK ){
      rc = TCL_OK;
    }
    break;
  }

  /*
  **    $db eval ?options? $sql ?array? ?{  ...code... }?
  **
  ** The SQL statement in $sql is evaluated.  For each row, the values are
  ** placed in elements of the array named "array" and ...code... is executed.
  ** If "array" and "code" are omitted, then no callback is every invoked.
  ** If "array" is an empty string, then the values are placed in variables
  ** that have the same name as the fields extracted by the query.
  */
  case DB_EVAL: {
    int evalFlags = 0;
    const char *zOpt;
    while( objc>3 && (zOpt = Tcl_GetString(objv[2]))!=0 && zOpt[0]=='-' ){
      if( strcmp(zOpt, "-withoutnulls")==0 ){
        evalFlags |= SQLITE_EVAL_WITHOUTNULLS;
      }
      else{
        Tcl_AppendResult(interp, "unknown option: \"", zOpt, "\"", (void*)0);
        return TCL_ERROR;
      }
      objc--;
      objv++;
    }
    
// ABS Label 746
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}

// COR Label 747
if((objc < 3 && objc > 5) != (objc < 3 || objc > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 747);
}

// ROR Label 748
if((objc <= 3) != (objc < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 748);
}
// ROR Label 749
if((objc > 3) != (objc < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 749);
}
// ROR Label 750
if((objc >= 3) != (objc < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 750);
}
// ROR Label 751
if((objc <= 5) != (objc > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 751);
}
// ROR Label 752
if((objc < 5) != (objc > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 752);
}
// ROR Label 753
if((objc >= 5) != (objc > 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 753);
}

// MCC Label 754
if(objc < 3 && objc > 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 754);
}
// MCC Label 755
if(objc < 3 && !(objc > 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 755);
}
// MCC Label 756
if(!(objc < 3) && objc > 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 756);
}
// MCC Label 757
if(!(objc < 3) && !(objc > 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 757);
}
if( objc<3 || objc>5 ){
      Tcl_WrongNumArgs(interp, 2, objv, 
          "?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?");
      return TCL_ERROR;
    }

    
// ABS Label 758
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}

// ROR Label 759
if((objc != 3) != (objc == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 759);
}
if( objc==3 ){
      DbEvalContext sEval;
      Tcl_Obj *pRet = Tcl_NewObj();
      Tcl_IncrRefCount(pRet);
      dbEvalInit(&sEval, pDb, objv[2], 0, 0);
      while( TCL_OK==(rc = dbEvalStep(&sEval)) ){
        int i;
        int nCol;
        dbEvalRowInfo(&sEval, &nCol, 0);
        for(i=0; i<nCol; i++){
          Tcl_ListObjAppendElement(interp, pRet, dbEvalColumnValue(&sEval, i));
        }
      }
      dbEvalFinalize(&sEval);
      if( rc==TCL_BREAK ){
        Tcl_SetObjResult(interp, pRet);
        rc = TCL_OK;
      }
      Tcl_DecrRefCount(pRet);
    }else{
      ClientData cd2[2];
      DbEvalContext *p;
      Tcl_Obj *pArray = 0;
      Tcl_Obj *pScript;

      if( objc>=5 && *(char *)Tcl_GetString(objv[3]) ){
        pArray = objv[3];
      }
      pScript = objv[objc-1];
      Tcl_IncrRefCount(pScript);

      p = (DbEvalContext *)Tcl_Alloc(sizeof(DbEvalContext));
      dbEvalInit(p, pDb, objv[2], pArray, evalFlags);

      cd2[0] = (void *)p;
      cd2[1] = (void *)pScript;
      rc = DbEvalNextCmd(cd2, interp, TCL_OK);
    }
    break;
  }

  /*
  **     $db function NAME [OPTIONS] SCRIPT
  **
  ** Create a new SQL function called NAME.  Whenever that function is
  ** called, invoke SCRIPT to evaluate the function.
  **
  ** Options:
  **         --argcount N           Function has exactly N arguments
  **         --deterministic        The function is pure
  **         --directonly           Prohibit use inside triggers and views
  **         --innocuous            Has no side effects or information leaks
  **         --returntype TYPE      Specify the return type of the function
  */
  case DB_FUNCTION: {
    int flags = SQLITE_UTF8;
    SqlFunc *pFunc;
    Tcl_Obj *pScript;
    char *zName;
    int nArg = -1;
    int i;
    int eType = SQLITE_NULL;
    
// ABS Label 760
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}

// ROR Label 761
if((objc <= 4) != (objc < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 761);
}
// ROR Label 762
if((objc > 4) != (objc < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 762);
}
// ROR Label 763
if((objc >= 4) != (objc < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 763);
}
if( objc<4 ){
      Tcl_WrongNumArgs(interp, 2, objv, "NAME ?SWITCHES? SCRIPT");
      return TCL_ERROR;
    }
    i = 3;

// ABS Label 764
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// ROR Label 765
if((i <= (objc - 1)) != (i < (objc - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 765);
}
// ROR Label 766
if((i > (objc - 1)) != (i < (objc - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 766);
}
// ROR Label 767
if((i >= (objc - 1)) != (i < (objc - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 767);
}
for(; i<(objc-1); i++){
      const char *z = Tcl_GetString(objv[i]);
      int n = strlen30(z);
      
// ABS Label 772
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 772);
}

// MCC Label 773
if(n > 1 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 773);
}
// MCC Label 774
if(!(n > 1) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 774);
}
if( n>1 && strncmp(z, "-argcount",n)==0 ){
        
// ABS Label 775
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// ROR Label 776
if((i != (objc - 2)) != (i == (objc - 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 776);
}
if( i==(objc-2) ){
          Tcl_AppendResult(interp, "option requires an argument: ", z,(char*)0);
          return TCL_ERROR;
        }
        if( Tcl_GetIntFromObj(interp, objv[i+1], &nArg) ) return TCL_ERROR;
        
// ABS Label 777
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ROR Label 778
if((nArg <= 0) != (nArg < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 778);
}
// ROR Label 779
if((nArg > 0) != (nArg < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 779);
}
// ROR Label 780
if((nArg >= 0) != (nArg < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 780);
}
if( nArg<0 ){
          Tcl_AppendResult(interp, "number of arguments must be non-negative",
                           (char*)0);
          return TCL_ERROR;
        }
        i++;
      }else {
      
// ABS Label 781
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}

// MCC Label 782
if(n > 1 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 782);
}
// MCC Label 783
if(!(n > 1) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 783);
}
if( n>1 && strncmp(z, "-deterministic",n)==0 ){
        flags |= SQLITE_DETERMINISTIC;
      }else {
      
// ABS Label 784
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}

// MCC Label 785
if(n > 1 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 785);
}
// MCC Label 786
if(!(n > 1) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 786);
}
if( n>1 && strncmp(z, "-directonly",n)==0 ){
        flags |= SQLITE_DIRECTONLY;
      }else {
      
// ABS Label 787
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}

// MCC Label 788
if(n > 1 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 788);
}
// MCC Label 789
if(!(n > 1) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 789);
}
if( n>1 && strncmp(z, "-innocuous",n)==0 ){
        flags |= SQLITE_INNOCUOUS;
      }else {
      
// ABS Label 790
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}

// MCC Label 791
if(n > 1 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 791);
}
// MCC Label 792
if(!(n > 1) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 792);
}
if( n>1 && strncmp(z, "-returntype", n)==0 ){
        const char *azType[] = {"integer", "real", "text", "blob", "any", 0};
        assert( SQLITE_INTEGER==1 && SQLITE_FLOAT==2 && SQLITE_TEXT==3 );
        assert( SQLITE_BLOB==4 && SQLITE_NULL==5 );
        
// ABS Label 813
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}

// ROR Label 814
if((i != (objc - 2)) != (i == (objc - 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 814);
}
if( i==(objc-2) ){
          Tcl_AppendResult(interp, "option requires an argument: ", z,(char*)0);
          return TCL_ERROR;
        }
        i++;
        if( Tcl_GetIndexFromObj(interp, objv[i], azType, "type", 0, &eType) ){
          return TCL_ERROR;
        }
        eType++;
      }else{
        Tcl_AppendResult(interp, "bad option \"", z,
            "\": must be -argcount, -deterministic, -directonly,"
            " -innocuous, or -returntype", (char*)0
        );
        return TCL_ERROR;
      };}
;}
;}
;}

    };
// ABS Label 768
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}

// ROR Label 769
if((i <= (objc - 1)) != (i < (objc - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 769);
}
// ROR Label 770
if((i > (objc - 1)) != (i < (objc - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 770);
}
// ROR Label 771
if((i >= (objc - 1)) != (i < (objc - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 771);
}


    pScript = objv[objc-1];
    zName = Tcl_GetStringFromObj(objv[2], 0);
    pFunc = findSqlFunc(pDb, zName);
    if( pFunc==0 ) return TCL_ERROR;
    if( pFunc->pScript ){
      Tcl_DecrRefCount(pFunc->pScript);
    }
    pFunc->pScript = pScript;
    Tcl_IncrRefCount(pScript);
    pFunc->useEvalObjv = safeToUseEvalObjv(interp, pScript);
    pFunc->eType = eType;
    rc = sqlite3_create_function(pDb->db, zName, nArg, flags,
        pFunc, tclSqlFunc, 0, 0);
    
// ABS Label 815
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}

// ROR Label 816
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 816);
}
if( rc!=SQLITE_OK ){
      rc = TCL_ERROR;
      Tcl_SetResult(interp, (char *)sqlite3_errmsg(pDb->db), TCL_VOLATILE);
    }
    break;
  }

  /*
  **     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
  */
  case DB_INCRBLOB: {
#ifdef SQLITE_OMIT_INCRBLOB
    Tcl_AppendResult(interp, "incrblob not available in this build", (char*)0);
    return TCL_ERROR;
#else
    int isReadonly = 0;
    const char *zDb = "main";
    const char *zTable;
    const char *zColumn;
    Tcl_WideInt iRow;

    /* Check for the -readonly option */
    if( objc>3 && strcmp(Tcl_GetString(objv[2]), "-readonly")==0 ){
      isReadonly = 1;
    }

    
// ABS Label 817
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}

// COR Label 818
if((objc != (5 + isReadonly) || objc != (6 + isReadonly)) != (objc != (5 + isReadonly) && objc != (6 + isReadonly)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 818);
}

// ROR Label 819
if((objc == (5 + isReadonly)) != (objc != (5 + isReadonly)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 819);
}
// ROR Label 820
if((objc == (6 + isReadonly)) != (objc != (6 + isReadonly)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 820);
}

// MCC Label 821
if(objc != (5 + isReadonly) && objc != (6 + isReadonly) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 821);
}
// MCC Label 822
if(objc != (5 + isReadonly) && !(objc != (6 + isReadonly)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 822);
}
// MCC Label 823
if(!(objc != (5 + isReadonly)) && objc != (6 + isReadonly) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 823);
}
// MCC Label 824
if(!(objc != (5 + isReadonly)) && !(objc != (6 + isReadonly)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 824);
}
if( objc!=(5+isReadonly) && objc!=(6+isReadonly) ){
      Tcl_WrongNumArgs(interp, 2, objv, "?-readonly? ?DB? TABLE COLUMN ROWID");
      return TCL_ERROR;
    }

    
// ABS Label 825
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}

// ROR Label 826
if((objc != (6 + isReadonly)) != (objc == (6 + isReadonly)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 826);
}
if( objc==(6+isReadonly) ){
      zDb = Tcl_GetString(objv[2]);
    }
    zTable = Tcl_GetString(objv[objc-3]);
    zColumn = Tcl_GetString(objv[objc-2]);
    rc = Tcl_GetWideIntFromObj(interp, objv[objc-1], &iRow);

    if( rc==TCL_OK ){
      rc = createIncrblobChannel(
          interp, pDb, zDb, zTable, zColumn, (sqlite3_int64)iRow, isReadonly
      );
    }
#endif
    break;
  }

  /*
  **     $db interrupt
  **
  ** Interrupt the execution of the inner-most SQL interpreter.  This
  ** causes the SQL statement to return an error of SQLITE_INTERRUPT.
  */
  case DB_INTERRUPT: {
    
// ABS Label 827
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
sqlite3_interrupt(pDb->db);
    break;
  }

  /*
  **     $db nullvalue ?STRING?
  **
  ** Change text used when a NULL comes back from the database. If ?STRING?
  ** is not present, then the current string used for NULL is returned.
  ** If STRING is present, then STRING is returned.
  **
  */
  case DB_NULLVALUE: {
    
// ABS Label 828
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// COR Label 829
if((objc != 2 || objc != 3) != (objc != 2 && objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 829);
}

// ROR Label 830
if((objc == 2) != (objc != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}
// ROR Label 831
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 831);
}

// MCC Label 832
if(objc != 2 && objc != 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 832);
}
// MCC Label 833
if(objc != 2 && !(objc != 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 833);
}
// MCC Label 834
if(!(objc != 2) && objc != 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 834);
}
// MCC Label 835
if(!(objc != 2) && !(objc != 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 835);
}
if( objc!=2 && objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "NULLVALUE");
      return TCL_ERROR;
    }
    
// ABS Label 836
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 836);
}

// ROR Label 837
if((objc != 3) != (objc == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 837);
}
if( objc==3 ){
      int len;
      char *zNull = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 838
if(pDb->zNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}
if( pDb->zNull ){
        
// ABS Label 839
if(pDb->zNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}
Tcl_Free(pDb->zNull);
      }
      
// ABS Label 840
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 840);
}
// ABS Label 841
if(zNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 841);
}

// COR Label 842
if((zNull || len > 0) != (zNull && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 842);
}

// ROR Label 843
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 843);
}
// ROR Label 844
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 844);
}
// ROR Label 845
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 845);
}

// MCC Label 846
if(zNull && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 846);
}
// MCC Label 847
if(zNull && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 847);
}
// MCC Label 848
if(!(zNull) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 848);
}
// MCC Label 849
if(!(zNull) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 849);
}
if( zNull && len>0 ){
        pDb->zNull = Tcl_Alloc( len + 1 );
        memcpy(pDb->zNull, zNull, len);
        pDb->zNull[len] = '\0';
      }else{
        pDb->zNull = 0;
      }
    }
    Tcl_SetObjResult(interp, Tcl_NewStringObj(pDb->zNull, -1));
    break;
  }

  /*
  **     $db last_insert_rowid
  **
  ** Return an integer which is the ROWID for the most recent insert.
  */
  case DB_LAST_INSERT_ROWID: {
    Tcl_Obj *pResult;
    Tcl_WideInt rowid;
    
// ABS Label 850
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}

// ROR Label 851
if((objc == 2) != (objc != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 851);
}
if( objc!=2 ){
      Tcl_WrongNumArgs(interp, 2, objv, "");
      return TCL_ERROR;
    }
    rowid = sqlite3_last_insert_rowid(pDb->db);
    pResult = Tcl_GetObjResult(interp);
    Tcl_SetWideIntObj(pResult, rowid);
    break;
  }

  /*
  ** The DB_ONECOLUMN method is implemented together with DB_EXISTS.
  */

  /*    $db progress ?N CALLBACK?
  **
  ** Invoke the given callback every N virtual machine opcodes while executing
  ** queries.
  */
  case DB_PROGRESS: {
    
// ABS Label 852
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}

// ROR Label 853
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
if( objc==2 ){
      
// ABS Label 854
if(pDb->zProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}
if( pDb->zProgress ){
        Tcl_AppendResult(interp, pDb->zProgress, (char*)0);
      }
    }else { 
// ABS Label 855
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}

// ROR Label 856
if((objc != 4) != (objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 856);
}
if( objc==4 ){
      char *zProgress;
      int len;
      int N;
      if( TCL_OK!=Tcl_GetIntFromObj(interp, objv[2], &N) ){
        return TCL_ERROR;
      };
      
// ABS Label 857
if(pDb->zProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 857);
}
if( pDb->zProgress ){
        
// ABS Label 858
if(pDb->zProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
Tcl_Free(pDb->zProgress);
      }
      zProgress = Tcl_GetStringFromObj(objv[3], &len);
      
// ABS Label 859
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}
// ABS Label 860
if(zProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}

// COR Label 861
if((zProgress || len > 0) != (zProgress && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 861);
}

// ROR Label 862
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
// ROR Label 863
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 863);
}
// ROR Label 864
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}

// MCC Label 865
if(zProgress && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 865);
}
// MCC Label 866
if(zProgress && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 866);
}
// MCC Label 867
if(!(zProgress) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 867);
}
// MCC Label 868
if(!(zProgress) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 868);
}
if( zProgress && len>0 ){
        pDb->zProgress = Tcl_Alloc( len + 1 );
        memcpy(pDb->zProgress, zProgress, len+1);
      }else{
        pDb->zProgress = 0;
      }
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
      
// ABS Label 869
if(pDb->zProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 869);
}
if( pDb->zProgress ){
        pDb->interp = interp;
        
// ABS Label 870
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}

// ABS Label 871
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}
sqlite3_progress_handler(pDb->db, N, DbProgressHandler, pDb);
      }else{
        
// ABS Label 872
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
sqlite3_progress_handler(pDb->db, 0, 0, 0);
      }
#endif
    }else{
      Tcl_WrongNumArgs(interp, 2, objv, "N CALLBACK");
      return TCL_ERROR;
    };}

    break;
  }

  /*    $db profile ?CALLBACK?
  **
  ** Make arrangements to invoke the CALLBACK routine after each SQL statement
  ** that has run.  The text of the SQL and the amount of elapse time are
  ** appended to CALLBACK before the script is run.
  */
  case DB_PROFILE: {
    
// ABS Label 873
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// ROR Label 874
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 874);
}
// ROR Label 875
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}
// ROR Label 876
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 876);
}
if( objc>3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?CALLBACK?");
      return TCL_ERROR;
    }else { 
// ABS Label 877
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}

// ROR Label 878
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 878);
}
if( objc==2 ){
      
// ABS Label 879
if(pDb->zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 879);
}
if( pDb->zProfile ){
        Tcl_AppendResult(interp, pDb->zProfile, (char*)0);
      }
    }else{
      char *zProfile;
      int len;
      
// ABS Label 880
if(pDb->zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 880);
}
if( pDb->zProfile ){
        
// ABS Label 881
if(pDb->zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 881);
}
Tcl_Free(pDb->zProfile);
      }
      zProfile = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 882
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}
// ABS Label 883
if(zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}

// COR Label 884
if((zProfile || len > 0) != (zProfile && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 884);
}

// ROR Label 885
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 885);
}
// ROR Label 886
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}
// ROR Label 887
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}

// MCC Label 888
if(zProfile && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 888);
}
// MCC Label 889
if(zProfile && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 889);
}
// MCC Label 890
if(!(zProfile) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 890);
}
// MCC Label 891
if(!(zProfile) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 891);
}
if( zProfile && len>0 ){
        pDb->zProfile = Tcl_Alloc( len + 1 );
        memcpy(pDb->zProfile, zProfile, len+1);
      }else{
        pDb->zProfile = 0;
      }
#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT) && \
    !defined(SQLITE_OMIT_DEPRECATED)
      
// ABS Label 892
if(pDb->zProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 892);
}
if( pDb->zProfile ){
        pDb->interp = interp;
        
// ABS Label 893
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}
sqlite3_profile(pDb->db, DbProfileHandler, pDb);
      }else{
        
// ABS Label 894
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}
sqlite3_profile(pDb->db, 0, 0);
      }
#endif
    };}

    break;
  }

  /*
  **     $db rekey KEY
  **
  ** Change the encryption key on the currently open database.
  */
  case DB_REKEY: {
    
// ABS Label 895
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}

// ROR Label 896
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 896);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "KEY");
      return TCL_ERROR;
    }
    break;
  }

  /*    $db restore ?DATABASE? FILENAME
  **
  ** Open a database file named FILENAME.  Transfer the content
  ** of FILENAME into the local database DATABASE (default: "main").
  */
  case DB_RESTORE: {
    const char *zSrcFile;
    const char *zDestDb;
    sqlite3 *pSrc;
    sqlite3_backup *pBackup;
    int nTimeout = 0;

    
// ABS Label 899
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 899);
}

// ROR Label 900
if((objc != 3) != (objc == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 900);
}
if( objc==3 ){
      zDestDb = "main";
      zSrcFile = Tcl_GetString(objv[2]);
    }else { 
// ABS Label 901
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 901);
}

// ROR Label 902
if((objc != 4) != (objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 902);
}
if( objc==4 ){
      zDestDb = Tcl_GetString(objv[2]);
      zSrcFile = Tcl_GetString(objv[3]);
    }else{
      Tcl_WrongNumArgs(interp, 2, objv, "?DATABASE? FILENAME");
      return TCL_ERROR;
    };}

    rc = sqlite3_open_v2(zSrcFile, &pSrc,
                         SQLITE_OPEN_READONLY | pDb->openFlags, 0);
    
// ABS Label 903
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 903);
}

// ROR Label 904
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 904);
}
if( rc!=SQLITE_OK ){
      Tcl_AppendResult(interp, "cannot open source database: ",
           sqlite3_errmsg(pSrc), (char*)0);
      
// ABS Label 905
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}
sqlite3_close(pSrc);
      return TCL_ERROR;
    }
    pBackup = sqlite3_backup_init(pDb->db, zDestDb, pSrc, "main");
    
// ABS Label 906
if(pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 906);
}

// ROR Label 907
if((pBackup != 0) != (pBackup == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 907);
}
if( pBackup==0 ){
      Tcl_AppendResult(interp, "restore failed: ",
           sqlite3_errmsg(pDb->db), (char*)0);
      
// ABS Label 908
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 908);
}
sqlite3_close(pSrc);
      return TCL_ERROR;
    }
    while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
              || rc==SQLITE_BUSY ){
      
// ABS Label 909
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 909);
}

// ROR Label 910
if((rc != 5) != (rc == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 910);
}
if( rc==SQLITE_BUSY ){
        if( nTimeout++ >= 3 ) break;
        sqlite3_sleep(100);
      }
    };
    
// ABS Label 897
if(pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}
sqlite3_backup_finish(pBackup);
    
// ABS Label 911
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}

// ROR Label 912
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 912);
}
if( rc==SQLITE_DONE ){
      rc = TCL_OK;
    }else { 
// ABS Label 913
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 913);
}

// COR Label 914
if((rc == 5 && rc == 6) != (rc == 5 || rc == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 914);
}

// ROR Label 915
if((rc != 5) != (rc == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 915);
}
// ROR Label 916
if((rc != 6) != (rc == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 916);
}

// MCC Label 917
if(rc == 5 && rc == 6 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 917);
}
// MCC Label 918
if(rc == 5 && !(rc == 6) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 918);
}
// MCC Label 919
if(!(rc == 5) && rc == 6 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 919);
}
// MCC Label 920
if(!(rc == 5) && !(rc == 6) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 920);
}
if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED ){
      Tcl_AppendResult(interp, "restore failed: source database busy",
                       (char*)0);
      rc = TCL_ERROR;
    }else{
      Tcl_AppendResult(interp, "restore failed: ",
           sqlite3_errmsg(pDb->db), (char*)0);
      rc = TCL_ERROR;
    };}

    
// ABS Label 898
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 898);
}
sqlite3_close(pSrc);
    break;
  }

  /*
  **     $db serialize ?DATABASE?
  **
  ** Return a serialization of a database.  
  */
  case DB_SERIALIZE: {
#ifdef SQLITE_OMIT_DESERIALIZE
    Tcl_AppendResult(interp, "MEMDB not available in this build",
                     (char*)0);
    rc = TCL_ERROR;
#else
    const char *zSchema = objc>=3 ? Tcl_GetString(objv[2]) : "main";
    sqlite3_int64 sz = 0;
    unsigned char *pData;
    
// ABS Label 921
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}

// COR Label 922
if((objc != 2 || objc != 3) != (objc != 2 && objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 922);
}

// ROR Label 923
if((objc == 2) != (objc != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 923);
}
// ROR Label 924
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 924);
}

// MCC Label 925
if(objc != 2 && objc != 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 925);
}
// MCC Label 926
if(objc != 2 && !(objc != 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 926);
}
// MCC Label 927
if(!(objc != 2) && objc != 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 927);
}
// MCC Label 928
if(!(objc != 2) && !(objc != 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 928);
}
if( objc!=2 && objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?DATABASE?");
      rc = TCL_ERROR;
    }else{
      int needFree;
      pData = sqlite3_serialize(pDb->db, zSchema, &sz, SQLITE_SERIALIZE_NOCOPY);
      
// ABS Label 929
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 929);
}
if( pData ){
        needFree = 0;
      }else{
        pData = sqlite3_serialize(pDb->db, zSchema, &sz, 0);
        needFree = 1;
      }
      Tcl_SetObjResult(interp, Tcl_NewByteArrayObj(pData,sz));
      
// ABS Label 930
if(needFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
if( needFree ) sqlite3_free(pData);
    }
#endif
    break;
  }

  /*
  **     $db status (step|sort|autoindex|vmstep)
  **
  ** Display SQLITE_STMTSTATUS_FULLSCAN_STEP or
  ** SQLITE_STMTSTATUS_SORT for the most recent eval.
  */
  case DB_STATUS: {
    int v;
    const char *zOp;
    
// ABS Label 931
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 931);
}

// ROR Label 932
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 932);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "(step|sort|autoindex)");
      return TCL_ERROR;
    }
    zOp = Tcl_GetString(objv[2]);
    if( strcmp(zOp, "step")==0 ){
      v = pDb->nStep;
    }else { if( strcmp(zOp, "sort")==0 ){
      v = pDb->nSort;
    }else { if( strcmp(zOp, "autoindex")==0 ){
      v = pDb->nIndex;
    }else { if( strcmp(zOp, "vmstep")==0 ){
      v = pDb->nVMStep;
    }else{
      Tcl_AppendResult(interp,
            "bad argument: should be autoindex, step, sort or vmstep",
            (char*)0);
      return TCL_ERROR;
    };}
;}
;}

    Tcl_SetObjResult(interp, Tcl_NewIntObj(v));
    break;
  }

  /*
  **     $db timeout MILLESECONDS
  **
  ** Delay for the number of milliseconds specified when a file is locked.
  */
  case DB_TIMEOUT: {
    int ms;
    
// ABS Label 935
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 935);
}

// ROR Label 936
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 936);
}
if( objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "MILLISECONDS");
      return TCL_ERROR;
    }
    if( Tcl_GetIntFromObj(interp, objv[2], &ms) ) return TCL_ERROR;
    
// ABS Label 933
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}

// ABS Label 934
if(ms < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}
sqlite3_busy_timeout(pDb->db, ms);
    break;
  }

  /*
  **     $db total_changes
  **
  ** Return the number of rows that were modified, inserted, or deleted
  ** since the database handle was created.
  */
  case DB_TOTAL_CHANGES: {
    Tcl_Obj *pResult;
    
// ABS Label 937
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}

// ROR Label 938
if((objc == 2) != (objc != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 938);
}
if( objc!=2 ){
      Tcl_WrongNumArgs(interp, 2, objv, "");
      return TCL_ERROR;
    }
    pResult = Tcl_GetObjResult(interp);
    Tcl_SetWideIntObj(pResult, sqlite3_total_changes64(pDb->db));
    break;
  }

  /*    $db trace ?CALLBACK?
  **
  ** Make arrangements to invoke the CALLBACK routine for each SQL statement
  ** that is executed.  The text of the SQL is appended to CALLBACK before
  ** it is executed.
  */
  case DB_TRACE: {
    
// ABS Label 939
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}

// ROR Label 940
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 940);
}
// ROR Label 941
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 941);
}
// ROR Label 942
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 942);
}
if( objc>3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?CALLBACK?");
      return TCL_ERROR;
    }else { 
// ABS Label 943
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}

// ROR Label 944
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 944);
}
if( objc==2 ){
      
// ABS Label 945
if(pDb->zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}
if( pDb->zTrace ){
        Tcl_AppendResult(interp, pDb->zTrace, (char*)0);
      }
    }else{
      char *zTrace;
      int len;
      
// ABS Label 946
if(pDb->zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}
if( pDb->zTrace ){
        
// ABS Label 947
if(pDb->zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}
Tcl_Free(pDb->zTrace);
      }
      zTrace = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 948
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 948);
}
// ABS Label 949
if(zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 949);
}

// COR Label 950
if((zTrace || len > 0) != (zTrace && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 950);
}

// ROR Label 951
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 951);
}
// ROR Label 952
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 952);
}
// ROR Label 953
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 953);
}

// MCC Label 954
if(zTrace && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 954);
}
// MCC Label 955
if(zTrace && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 955);
}
// MCC Label 956
if(!(zTrace) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 956);
}
// MCC Label 957
if(!(zTrace) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 957);
}
if( zTrace && len>0 ){
        pDb->zTrace = Tcl_Alloc( len + 1 );
        memcpy(pDb->zTrace, zTrace, len+1);
      }else{
        pDb->zTrace = 0;
      }
#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT) && \
    !defined(SQLITE_OMIT_DEPRECATED)
      
// ABS Label 958
if(pDb->zTrace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 958);
}
if( pDb->zTrace ){
        pDb->interp = interp;
        
// ABS Label 959
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 959);
}
sqlite3_trace(pDb->db, DbTraceHandler, pDb);
      }else{
        
// ABS Label 960
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 960);
}
sqlite3_trace(pDb->db, 0, 0);
      }
#endif
    };}

    break;
  }

  /*    $db trace_v2 ?CALLBACK? ?MASK?
  **
  ** Make arrangements to invoke the CALLBACK routine for each trace event
  ** matching the mask that is generated.  The parameters are appended to
  ** CALLBACK before it is executed.
  */
  case DB_TRACE_V2: {
    
// ABS Label 961
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 961);
}

// ROR Label 962
if((objc <= 4) != (objc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 962);
}
// ROR Label 963
if((objc < 4) != (objc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 963);
}
// ROR Label 964
if((objc >= 4) != (objc > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 964);
}
if( objc>4 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?CALLBACK? ?MASK?");
      return TCL_ERROR;
    }else { 
// ABS Label 965
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// ROR Label 966
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 966);
}
if( objc==2 ){
      
// ABS Label 967
if(pDb->zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 967);
}
if( pDb->zTraceV2 ){
        Tcl_AppendResult(interp, pDb->zTraceV2, (char*)0);
      }
    }else{
      char *zTraceV2;
      int len;
      Tcl_WideInt wMask = 0;
      
// ABS Label 968
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 968);
}

// ROR Label 969
if((objc != 4) != (objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 969);
}
if( objc==4 ){
        static const char *TTYPE_strs[] = {
          "statement", "profile", "row", "close", 0
        };
        enum TTYPE_enum {
          TTYPE_STMT, TTYPE_PROFILE, TTYPE_ROW, TTYPE_CLOSE
        };
        int i;
        if( TCL_OK!=Tcl_ListObjLength(interp, objv[3], &len) ){
          return TCL_ERROR;
        }
        i = 0;

// ABS Label 970
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}
// ABS Label 971
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 971);
}

// ROR Label 972
if((i <= len) != (i < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 972);
}
// ROR Label 973
if((i > len) != (i < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 973);
}
// ROR Label 974
if((i >= len) != (i < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 974);
}
for(; i<len; i++){
          Tcl_Obj *pObj;
          int ttype;
          if( TCL_OK!=Tcl_ListObjIndex(interp, objv[3], i, &pObj) ){
            return TCL_ERROR;
          }
          if( Tcl_GetIndexFromObj(interp, pObj, TTYPE_strs, "trace type",
                                  0, &ttype)!=TCL_OK ){
            Tcl_WideInt wType;
            Tcl_Obj *pError = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
            Tcl_IncrRefCount(pError);
            if( TCL_OK==Tcl_GetWideIntFromObj(interp, pObj, &wType) ){
              Tcl_DecrRefCount(pError);
              wMask |= wType;
            }else{
              Tcl_SetObjResult(interp, pError);
              Tcl_DecrRefCount(pError);
              return TCL_ERROR;
            }
          }else{
            switch( (enum TTYPE_enum)ttype ){
              case TTYPE_STMT:    wMask |= SQLITE_TRACE_STMT;    break;
              case TTYPE_PROFILE: wMask |= SQLITE_TRACE_PROFILE; break;
              case TTYPE_ROW:     wMask |= SQLITE_TRACE_ROW;     break;
              case TTYPE_CLOSE:   wMask |= SQLITE_TRACE_CLOSE;   break;
            }
          }
        };
// ABS Label 975
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 975);
}
// ABS Label 976
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}

// ROR Label 977
if((i <= len) != (i < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 977);
}
// ROR Label 978
if((i > len) != (i < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 978);
}
// ROR Label 979
if((i >= len) != (i < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 979);
}

      }else{
        wMask = SQLITE_TRACE_STMT; /* use the "legacy" default */
      }
      
// ABS Label 980
if(pDb->zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}
if( pDb->zTraceV2 ){
        
// ABS Label 981
if(pDb->zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 981);
}
Tcl_Free(pDb->zTraceV2);
      }
      zTraceV2 = Tcl_GetStringFromObj(objv[2], &len);
      
// ABS Label 982
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}
// ABS Label 983
if(zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 983);
}

// COR Label 984
if((zTraceV2 || len > 0) != (zTraceV2 && len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 984);
}

// ROR Label 985
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 985);
}
// ROR Label 986
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 986);
}
// ROR Label 987
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 987);
}

// MCC Label 988
if(zTraceV2 && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 988);
}
// MCC Label 989
if(zTraceV2 && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 989);
}
// MCC Label 990
if(!(zTraceV2) && len > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 990);
}
// MCC Label 991
if(!(zTraceV2) && !(len > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 991);
}
if( zTraceV2 && len>0 ){
        pDb->zTraceV2 = Tcl_Alloc( len + 1 );
        memcpy(pDb->zTraceV2, zTraceV2, len+1);
      }else{
        pDb->zTraceV2 = 0;
      }
#if !defined(SQLITE_OMIT_TRACE) && !defined(SQLITE_OMIT_FLOATING_POINT)
      
// ABS Label 992
if(pDb->zTraceV2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 992);
}
if( pDb->zTraceV2 ){
        pDb->interp = interp;
        sqlite3_trace_v2(pDb->db, (unsigned)wMask, DbTraceV2Handler, pDb);
      }else{
        
// ABS Label 993
if(pDb->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 993);
}
sqlite3_trace_v2(pDb->db, 0, 0, 0);
      }
#endif
    };}

    break;
  }

  /*    $db transaction [-deferred|-immediate|-exclusive] SCRIPT
  **
  ** Start a new transaction (if we are not already in the midst of a
  ** transaction) and execute the TCL script SCRIPT.  After SCRIPT
  ** completes, either commit the transaction or roll it back if SCRIPT
  ** throws an exception.  Or if no new transation was started, do nothing.
  ** pass the exception on up the stack.
  **
  ** This command was inspired by Dave Thomas's talk on Ruby at the
  ** 2005 O'Reilly Open Source Convention (OSCON).
  */
  case DB_TRANSACTION: {
    Tcl_Obj *pScript;
    const char *zBegin = "SAVEPOINT _tcl_transaction";
    
// ABS Label 994
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 994);
}

// COR Label 995
if((objc != 3 || objc != 4) != (objc != 3 && objc != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 995);
}

// ROR Label 996
if((objc == 3) != (objc != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 996);
}
// ROR Label 997
if((objc == 4) != (objc != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 997);
}

// MCC Label 998
if(objc != 3 && objc != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 998);
}
// MCC Label 999
if(objc != 3 && !(objc != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 999);
}
// MCC Label 1000
if(!(objc != 3) && objc != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1000);
}
// MCC Label 1001
if(!(objc != 3) && !(objc != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1001);
}
if( objc!=3 && objc!=4 ){
      Tcl_WrongNumArgs(interp, 2, objv, "[TYPE] SCRIPT");
      return TCL_ERROR;
    }

    
// ABS Label 1002
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}
// ABS Label 1003
if(pDb->nTransaction < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// COR Label 1004
if((pDb->nTransaction == 0 || objc == 4) != (pDb->nTransaction == 0 && objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1004);
}

// ROR Label 1005
if((pDb->nTransaction != 0) != (pDb->nTransaction == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1005);
}
// ROR Label 1006
if((objc != 4) != (objc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1006);
}

// MCC Label 1007
if(pDb->nTransaction == 0 && objc == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1007);
}
// MCC Label 1008
if(pDb->nTransaction == 0 && !(objc == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1008);
}
// MCC Label 1009
if(!(pDb->nTransaction == 0) && objc == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1009);
}
// MCC Label 1010
if(!(pDb->nTransaction == 0) && !(objc == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1010);
}
if( pDb->nTransaction==0 && objc==4 ){
      static const char *TTYPE_strs[] = {
        "deferred",   "exclusive",  "immediate", 0
      };
      enum TTYPE_enum {
        TTYPE_DEFERRED, TTYPE_EXCLUSIVE, TTYPE_IMMEDIATE
      };
      int ttype;
      if( Tcl_GetIndexFromObj(interp, objv[2], TTYPE_strs, "transaction type",
                              0, &ttype) ){
        return TCL_ERROR;
      }
      switch( (enum TTYPE_enum)ttype ){
        case TTYPE_DEFERRED:    /* no-op */;                 break;
        case TTYPE_EXCLUSIVE:   zBegin = "BEGIN EXCLUSIVE";  break;
        case TTYPE_IMMEDIATE:   zBegin = "BEGIN IMMEDIATE";  break;
      }
    }
    pScript = objv[objc-1];

    /* Run the SQLite BEGIN command to open a transaction or savepoint. */
    pDb->disableAuth++;
    rc = sqlite3_exec(pDb->db, zBegin, 0, 0, 0);
    pDb->disableAuth--;
    
// ABS Label 1011
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1011);
}

// ROR Label 1012
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1012);
}
if( rc!=SQLITE_OK ){
      Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), (char*)0);
      return TCL_ERROR;
    }
    pDb->nTransaction++;

    /* If using NRE, schedule a callback to invoke the script pScript, then
    ** a second callback to commit (or rollback) the transaction or savepoint
    ** opened above. If not using NRE, evaluate the script directly, then
    ** call function DbTransPostCmd() to commit (or rollback) the transaction
    ** or savepoint.  */
    if( DbUseNre() ){
      Tcl_NRAddCallback(interp, DbTransPostCmd, cd, 0, 0, 0);
      (void)Tcl_NREvalObj(interp, pScript, 0);
    }else{
      rc = DbTransPostCmd(&cd, interp, Tcl_EvalObjEx(interp, pScript, 0));
    }
    break;
  }

  /*
  **    $db unlock_notify ?script?
  */
  case DB_UNLOCK_NOTIFY: {
#ifndef SQLITE_ENABLE_UNLOCK_NOTIFY
    Tcl_AppendResult(interp, "unlock_notify not available in this build",
                     (char*)0);
    rc = TCL_ERROR;
#else
    if( objc!=2 && objc!=3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "?SCRIPT?");
      rc = TCL_ERROR;
    }else{
      void (*xNotify)(void **, int) = 0;
      void *pNotifyArg = 0;

      if( pDb->pUnlockNotify ){
        Tcl_DecrRefCount(pDb->pUnlockNotify);
        pDb->pUnlockNotify = 0;
      }

      if( objc==3 ){
        xNotify = DbUnlockNotify;
        pNotifyArg = (void *)pDb;
        pDb->pUnlockNotify = objv[2];
        Tcl_IncrRefCount(pDb->pUnlockNotify);
      }

      if( sqlite3_unlock_notify(pDb->db, xNotify, pNotifyArg) ){
        Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), (char*)0);
        rc = TCL_ERROR;
      }
    }
#endif
    break;
  }

  /*
  **    $db preupdate_hook count
  **    $db preupdate_hook hook ?SCRIPT?
  **    $db preupdate_hook new INDEX
  **    $db preupdate_hook old INDEX
  */
  case DB_PREUPDATE: {
#ifndef SQLITE_ENABLE_PREUPDATE_HOOK
    Tcl_AppendResult(interp, "preupdate_hook was omitted at compile-time", 
                     (char*)0);
    rc = TCL_ERROR;
#else
    static const char *azSub[] = {"count", "depth", "hook", "new", "old", 0};
    enum DbPreupdateSubCmd {
      PRE_COUNT, PRE_DEPTH, PRE_HOOK, PRE_NEW, PRE_OLD
    };
    int iSub;

    if( objc<3 ){
      Tcl_WrongNumArgs(interp, 2, objv, "SUB-COMMAND ?ARGS?");
    }
    if( Tcl_GetIndexFromObj(interp, objv[2], azSub, "sub-command", 0, &iSub) ){
      return TCL_ERROR;
    }

    switch( (enum DbPreupdateSubCmd)iSub ){
      case PRE_COUNT: {
        int nCol = sqlite3_preupdate_count(pDb->db);
        Tcl_SetObjResult(interp, Tcl_NewIntObj(nCol));
        break;
      }

      case PRE_HOOK: {
        if( objc>4 ){
          Tcl_WrongNumArgs(interp, 2, objv, "hook ?SCRIPT?");
          return TCL_ERROR;
        }
        DbHookCmd(interp, pDb, (objc==4 ? objv[3] : 0), &pDb->pPreUpdateHook);
        break;
      }

      case PRE_DEPTH: {
        Tcl_Obj *pRet;
        if( objc!=3 ){
          Tcl_WrongNumArgs(interp, 3, objv, "");
          return TCL_ERROR;
        }
        pRet = Tcl_NewIntObj(sqlite3_preupdate_depth(pDb->db));
        Tcl_SetObjResult(interp, pRet);
        break;
      }

      case PRE_NEW:
      case PRE_OLD: {
        int iIdx;
        sqlite3_value *pValue;
        if( objc!=4 ){
          Tcl_WrongNumArgs(interp, 3, objv, "INDEX");
          return TCL_ERROR;
        }
        if( Tcl_GetIntFromObj(interp, objv[3], &iIdx) ){
          return TCL_ERROR;
        }

        if( iSub==PRE_OLD ){
          rc = sqlite3_preupdate_old(pDb->db, iIdx, &pValue);
        }else{
          assert( iSub==PRE_NEW );
          rc = sqlite3_preupdate_new(pDb->db, iIdx, &pValue);
        }

        if( rc==SQLITE_OK ){
          Tcl_Obj *pObj;
          pObj = Tcl_NewStringObj((char*)sqlite3_value_text(pValue), -1);
          Tcl_SetObjResult(interp, pObj);
        }else{
          Tcl_AppendResult(interp, sqlite3_errmsg(pDb->db), (char*)0);
          return TCL_ERROR;
        }
      }
    }
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */
    break;
  }

  /*
  **    $db wal_hook ?script?
  **    $db update_hook ?script?
  **    $db rollback_hook ?script?
  */
  case DB_WAL_HOOK:
  case DB_UPDATE_HOOK:
  case DB_ROLLBACK_HOOK: {
    /* set ppHook to point at pUpdateHook or pRollbackHook, depending on
    ** whether [$db update_hook] or [$db rollback_hook] was invoked.
    */
    Tcl_Obj **ppHook = 0;
    if( choice==DB_WAL_HOOK ) ppHook = &pDb->pWalHook;
    if( choice==DB_UPDATE_HOOK ) ppHook = &pDb->pUpdateHook;
    if( choice==DB_ROLLBACK_HOOK ) ppHook = &pDb->pRollbackHook;
    
// ABS Label 1013
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1013);
}

// ROR Label 1014
if((objc <= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1014);
}
// ROR Label 1015
if((objc < 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1015);
}
// ROR Label 1016
if((objc >= 3) != (objc > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1016);
}
if( objc>3 ){
       Tcl_WrongNumArgs(interp, 2, objv, "?SCRIPT?");
       return TCL_ERROR;
    }

    DbHookCmd(interp, pDb, (objc==3 ? objv[2] : 0), ppHook);
    break;
  }

  /*    $db version
  **
  ** Return the version string for this database.
  */
  case DB_VERSION: {
    int i;
    i = 2;

// ABS Label 1017
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}
// ABS Label 1018
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1018);
}

// ROR Label 1019
if((i <= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1019);
}
// ROR Label 1020
if((i > objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1020);
}
// ROR Label 1021
if((i >= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1021);
}
for(; i<objc; i++){
      const char *zArg = Tcl_GetString(objv[i]);
      /* Optional arguments to $db version are used for testing purpose */
#ifdef SQLITE_TEST
      /* $db version -use-legacy-prepare BOOLEAN
      **
      ** Turn the use of legacy sqlite3_prepare() on or off.
      */
      if( strcmp(zArg, "-use-legacy-prepare")==0 && i+1<objc ){
        i++;
        if( Tcl_GetBooleanFromObj(interp, objv[i], &pDb->bLegacyPrepare) ){
          return TCL_ERROR;
        }
      }else

      /* $db version -last-stmt-ptr
      **
      ** Return a string which is a hex encoding of the pointer to the
      ** most recent sqlite3_stmt in the statement cache.
      */
      if( strcmp(zArg, "-last-stmt-ptr")==0 ){
        char zBuf[100];
        sqlite3_snprintf(sizeof(zBuf), zBuf, "%p",
                         pDb->stmtList ? pDb->stmtList->pStmt: 0);
        Tcl_SetResult(interp, zBuf, TCL_VOLATILE);
      }else
#endif /* SQLITE_TEST */
      {
        Tcl_AppendResult(interp, "unknown argument: ", zArg, (char*)0);
        return TCL_ERROR;
      }
    };
// ABS Label 1022
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1022);
}
// ABS Label 1023
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}

// ROR Label 1024
if((i <= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1024);
}
// ROR Label 1025
if((i > objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1025);
}
// ROR Label 1026
if((i >= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1026);
}

    
// ABS Label 1027
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1027);
}

// ROR Label 1028
if((i != 2) != (i == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1028);
}
if( i==2 ){   
      Tcl_SetResult(interp, (char *)sqlite3_libversion(), TCL_STATIC);
    }
    break;
  }


  } /* End of the SWITCH statement */
  
// ABS Label 1029
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}
return rc;
}

#if SQLITE_TCL_NRE
/*
** Adaptor that provides an objCmd interface to the NRE-enabled
** interface implementation.
*/
static int SQLITE_TCLAPI DbObjCmdAdaptor(
  void *cd,
  Tcl_Interp *interp,
  int objc,
  Tcl_Obj *const*objv
){
  return Tcl_NRCallObjProc(interp, DbObjCmd, cd, objc, objv);
}
#endif /* SQLITE_TCL_NRE */

/*
** Issue the usage message when the "sqlite3" command arguments are
** incorrect.
*/
static int sqliteCmdUsage(
  Tcl_Interp *interp,
  Tcl_Obj *const*objv
){
  Tcl_WrongNumArgs(interp, 1, objv,
    "HANDLE ?FILENAME? ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN?"
    " ?-nofollow BOOLEAN?"
    " ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?"
  );
  return TCL_ERROR;
}

/*
**   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN?
**                           ?-create BOOLEAN? ?-nomutex BOOLEAN?
**                           ?-nofollow BOOLEAN?
**
** This is the main Tcl command.  When the "sqlite" Tcl command is
** invoked, this routine runs to process that command.
**
** The first argument, DBNAME, is an arbitrary name for a new
** database connection.  This command creates a new command named
** DBNAME that is used to control that connection.  The database
** connection is deleted when the DBNAME command is deleted.
**
** The second argument is the name of the database file.
**
*/
static int SQLITE_TCLAPI DbMain(
  void *cd,
  Tcl_Interp *interp,
  int objc,
  Tcl_Obj *const*objv
){
  SqliteDb *p;
  const char *zArg;
  char *zErrMsg;
  int i;
  const char *zFile = 0;
  const char *zVfs = 0;
  int flags;
  int bTranslateFileName = 1;
  Tcl_DString translatedFilename;
  int rc;

  /* In normal use, each TCL interpreter runs in a single thread.  So
  ** by default, we can turn off mutexing on SQLite database connections.
  ** However, for testing purposes it is useful to have mutexes turned
  ** on.  So, by default, mutexes default off.  But if compiled with
  ** SQLITE_TCL_DEFAULT_FULLMUTEX then mutexes default on.
  */
#ifdef SQLITE_TCL_DEFAULT_FULLMUTEX
  flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX;
#else
  flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX;
#endif

  if( objc==1 ) return sqliteCmdUsage(interp, objv);
  
// ABS Label 1030
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1030);
}

// ROR Label 1031
if((objc != 2) != (objc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1031);
}
if( objc==2 ){
    zArg = Tcl_GetStringFromObj(objv[1], 0);
    if( strcmp(zArg,"-version")==0 ){
      Tcl_AppendResult(interp,sqlite3_libversion(), (char*)0);
      return TCL_OK;
    }
    if( strcmp(zArg,"-sourceid")==0 ){
      Tcl_AppendResult(interp,sqlite3_sourceid(), (char*)0);
      return TCL_OK;
    }
    if( strcmp(zArg,"-has-codec")==0 ){
      Tcl_AppendResult(interp,"0",(char*)0);
      return TCL_OK;
    }
    if( zArg[0]=='-' ) return sqliteCmdUsage(interp, objv);
  }
  i = 2;

// ABS Label 1032
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}
// ABS Label 1033
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}

// ROR Label 1034
if((i <= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1034);
}
// ROR Label 1035
if((i > objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1035);
}
// ROR Label 1036
if((i >= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1036);
}
for(; i<objc; i++){
    zArg = Tcl_GetString(objv[i]);
    
// ROR Label 1042
if((zArg[0] == '-') != (zArg[0] != '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1042);
}
if( zArg[0]!='-' ){
      if( zFile!=0 ) return sqliteCmdUsage(interp, objv);
      zFile = zArg;
      continue;
    }
    if( i==objc-1 ) return sqliteCmdUsage(interp, objv);
    i++;
    if( strcmp(zArg,"-key")==0 ){
      /* no-op */
    }else { if( strcmp(zArg, "-vfs")==0 ){
      zVfs = Tcl_GetString(objv[i]);
    }else { if( strcmp(zArg, "-readonly")==0 ){
      int b;
      if( Tcl_GetBooleanFromObj(interp, objv[i], &b) ) return TCL_ERROR;
      
// ABS Label 1043
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}
if( b ){
        flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);
        flags |= SQLITE_OPEN_READONLY;
      }else{
        flags &= ~SQLITE_OPEN_READONLY;
        flags |= SQLITE_OPEN_READWRITE;
      }
    }else { if( strcmp(zArg, "-create")==0 ){
      int b;
      if( Tcl_GetBooleanFromObj(interp, objv[i], &b) ) return TCL_ERROR;
      
// ABS Label 1044
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// COR Label 1045
if((b || (flags & 1) == 0) != (b && (flags & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1045);
}

// ROR Label 1046
if(((flags & 1) != 0) != ((flags & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1046);
}

// MCC Label 1047
if(b && (flags & 1) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1047);
}
// MCC Label 1048
if(b && !((flags & 1) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1048);
}
// MCC Label 1049
if(!(b) && (flags & 1) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1049);
}
// MCC Label 1050
if(!(b) && !((flags & 1) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1050);
}
if( b && (flags & SQLITE_OPEN_READONLY)==0 ){
        flags |= SQLITE_OPEN_CREATE;
      }else{
        flags &= ~SQLITE_OPEN_CREATE;
      }
    }else { if( strcmp(zArg, "-nofollow")==0 ){
      int b;
      if( Tcl_GetBooleanFromObj(interp, objv[i], &b) ) return TCL_ERROR;
      
// ABS Label 1051
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}
if( b ){
        flags |= SQLITE_OPEN_NOFOLLOW;
      }else{
        flags &= ~SQLITE_OPEN_NOFOLLOW;
      }
    }else { if( strcmp(zArg, "-nomutex")==0 ){
      int b;
      if( Tcl_GetBooleanFromObj(interp, objv[i], &b) ) return TCL_ERROR;
      
// ABS Label 1052
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}
if( b ){
        flags |= SQLITE_OPEN_NOMUTEX;
        flags &= ~SQLITE_OPEN_FULLMUTEX;
      }else{
        flags &= ~SQLITE_OPEN_NOMUTEX;
      }
    }else { if( strcmp(zArg, "-fullmutex")==0 ){
      int b;
      if( Tcl_GetBooleanFromObj(interp, objv[i], &b) ) return TCL_ERROR;
      
// ABS Label 1053
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
if( b ){
        flags |= SQLITE_OPEN_FULLMUTEX;
        flags &= ~SQLITE_OPEN_NOMUTEX;
      }else{
        flags &= ~SQLITE_OPEN_FULLMUTEX;
      }
    }else { if( strcmp(zArg, "-uri")==0 ){
      int b;
      if( Tcl_GetBooleanFromObj(interp, objv[i], &b) ) return TCL_ERROR;
      
// ABS Label 1054
if(b < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}
if( b ){
        flags |= SQLITE_OPEN_URI;
      }else{
        flags &= ~SQLITE_OPEN_URI;
      }
    }else { if( strcmp(zArg, "-translatefilename")==0 ){
      if( Tcl_GetBooleanFromObj(interp, objv[i], &bTranslateFileName) ){
        return TCL_ERROR;
      }
    }else{
      Tcl_AppendResult(interp, "unknown option: ", zArg, (char*)0);
      return TCL_ERROR;
    };}
;}
;}
;}
;}
;}
;}
;}

  };
// ABS Label 1037
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1037);
}
// ABS Label 1038
if(objc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1038);
}

// ROR Label 1039
if((i <= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1039);
}
// ROR Label 1040
if((i > objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1040);
}
// ROR Label 1041
if((i >= objc) != (i < objc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1041);
}

  zErrMsg = 0;
  p = (SqliteDb*)Tcl_Alloc( sizeof(*p) );
  memset(p, 0, sizeof(*p));
  
// ABS Label 1055
if(zFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}

// ROR Label 1056
if((zFile != 0) != (zFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1056);
}
if( zFile==0 ) zFile = "";
  
// ABS Label 1057
if(bTranslateFileName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}
if( bTranslateFileName ){
    zFile = Tcl_TranslateFileName(interp, zFile, &translatedFilename);
  }
  rc = sqlite3_open_v2(zFile, &p->db, flags, zVfs);
  
// ABS Label 1058
if(bTranslateFileName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}
if( bTranslateFileName ){
    Tcl_DStringFree(&translatedFilename);
  }
  
// ABS Label 1059
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}
if( p->db ){
    if( SQLITE_OK!=sqlite3_errcode(p->db) ){
      zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(p->db));
      
// ABS Label 1060
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}
sqlite3_close(p->db);
      p->db = 0;
    }
  }else{
    zErrMsg = sqlite3_mprintf("%s", sqlite3_errstr(rc));
  }
  
// ABS Label 1061
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1061);
}

// ROR Label 1062
if((p->db != 0) != (p->db == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1062);
}
if( p->db==0 ){
    Tcl_SetResult(interp, zErrMsg, TCL_VOLATILE);
    Tcl_Free((char*)p);
    sqlite3_free(zErrMsg);
    return TCL_ERROR;
  }
  p->maxStmt = NUM_PREPARED_STMTS;
  p->openFlags = flags & SQLITE_OPEN_URI;
  p->interp = interp;
  zArg = Tcl_GetStringFromObj(objv[1], 0);
  if( DbUseNre() ){
    Tcl_NRCreateCommand(interp, zArg, DbObjCmdAdaptor, DbObjCmd,
                        (char*)p, DbDeleteCmd);
  }else{
    Tcl_CreateObjCommand(interp, zArg, DbObjCmd, (char*)p, DbDeleteCmd);
  }
  return TCL_OK;
}

/*
** Provide a dummy Tcl_InitStubs if we are using this as a static
** library.
*/
#ifndef USE_TCL_STUBS
# undef  Tcl_InitStubs
# define Tcl_InitStubs(a,b,c) TCL_VERSION
#endif

/*
** Make sure we have a PACKAGE_VERSION macro defined.  This will be
** defined automatically by the TEA makefile.  But other makefiles
** do not define it.
*/
#ifndef PACKAGE_VERSION
# define PACKAGE_VERSION SQLITE_VERSION
#endif

/*
** Initialize this module.
**
** This Tcl module contains only a single new Tcl command named "sqlite".
** (Hence there is no namespace.  There is no point in using a namespace
** if the extension only supplies one new name!)  The "sqlite" command is
** used to open a new SQLite database.  See the DbMain() routine above
** for additional information.
**
** The EXTERN macros are required by TCL in order to work on windows.
*/
EXTERN int Sqlite3_Init(Tcl_Interp *interp){
  int rc = Tcl_InitStubs(interp, "8.4", 0) ? TCL_OK : TCL_ERROR;
  if( rc==TCL_OK ){
    Tcl_CreateObjCommand(interp, "sqlite3", (Tcl_ObjCmdProc*)DbMain, 0, 0);
#ifndef SQLITE_3_SUFFIX_ONLY
    /* The "sqlite" alias is undocumented.  It is here only to support
    ** legacy scripts.  All new scripts should use only the "sqlite3"
    ** command. */
    Tcl_CreateObjCommand(interp, "sqlite", (Tcl_ObjCmdProc*)DbMain, 0, 0);
#endif
    rc = Tcl_PkgProvide(interp, "sqlite3", PACKAGE_VERSION);
  }
  
// ABS Label 1063
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1063);
}
return rc;
}
EXTERN int Tclsqlite3_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }
EXTERN int Sqlite3_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }
EXTERN int Tclsqlite3_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }

/* Because it accesses the file-system and uses persistent state, SQLite
** is not considered appropriate for safe interpreters.  Hence, we cause
** the _SafeInit() interfaces return TCL_ERROR.
*/
EXTERN int Sqlite3_SafeInit(Tcl_Interp *interp){ return TCL_ERROR; }
EXTERN int Sqlite3_SafeUnload(Tcl_Interp *interp, int flags){return TCL_ERROR;}



#ifndef SQLITE_3_SUFFIX_ONLY
int Sqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }
int Tclsqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }
int Sqlite_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }
int Tclsqlite_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }
#endif

/*
** If the TCLSH macro is defined, add code to make a stand-alone program.
*/
#if defined(TCLSH)

/* This is the main routine for an ordinary TCL shell.  If there are
** are arguments, run the first argument as a script.  Otherwise,
** read TCL commands from standard input
*/
static const char *tclsh_main_loop(void){
  static const char zMainloop[] =
    "if {[llength $argv]>=1} {\n"
      "set argv0 [lindex $argv 0]\n"
      "set argv [lrange $argv 1 end]\n"
      "source $argv0\n"
    "} else {\n"
      "set line {}\n"
      "while {![eof stdin]} {\n"
        "if {$line!=\"\"} {\n"
          "puts -nonewline \"> \"\n"
        "} else {\n"
          "puts -nonewline \"% \"\n"
        "}\n"
        "flush stdout\n"
        "append line [gets stdin]\n"
        "if {[info complete $line]} {\n"
          "if {[catch {uplevel #0 $line} result]} {\n"
            "puts stderr \"Error: $result\"\n"
          "} elseif {$result!=\"\"} {\n"
            "puts $result\n"
          "}\n"
          "set line {}\n"
        "} else {\n"
          "append line \\n\n"
        "}\n"
      "}\n"
    "}\n"
  ;
  return zMainloop;
}

#define TCLSH_MAIN main   /* Needed to fake out mktclapp */
int SQLITE_CDECL TCLSH_MAIN(int argc, char **argv){
  Tcl_Interp *interp;
  int i;
  const char *zScript = 0;
  char zArgc[32];
#if defined(TCLSH_INIT_PROC)
  extern const char *TCLSH_INIT_PROC(Tcl_Interp*);
#endif

#if !defined(_WIN32_WCE)
  if( getenv("SQLITE_DEBUG_BREAK") ){
    if( isatty(0) && isatty(2) ){
      fprintf(stderr,
          "attach debugger to process %d and press any key to continue.\n",
          GETPID());
      fgetc(stdin);
    }else{
#if defined(_WIN32) || defined(WIN32)
      DebugBreak();
#elif defined(SIGTRAP)
      raise(SIGTRAP);
#endif
    }
  }
#endif

  /* Call sqlite3_shutdown() once before doing anything else. This is to
  ** test that sqlite3_shutdown() can be safely called by a process before
  ** sqlite3_initialize() is. */
  sqlite3_shutdown();

  Tcl_FindExecutable(argv[0]);
  Tcl_SetSystemEncoding(NULL, "utf-8");
  interp = Tcl_CreateInterp();
  Sqlite3_Init(interp);

  sqlite3_snprintf(sizeof(zArgc), zArgc, "%d", argc-1);
  Tcl_SetVar(interp,"argc", zArgc, TCL_GLOBAL_ONLY);
  Tcl_SetVar(interp,"argv0",argv[0],TCL_GLOBAL_ONLY);
  Tcl_SetVar(interp,"argv", "", TCL_GLOBAL_ONLY);
  for(i=1; i<argc; i++){
    Tcl_SetVar(interp, "argv", argv[i],
        TCL_GLOBAL_ONLY | TCL_LIST_ELEMENT | TCL_APPEND_VALUE);
  }
#if defined(TCLSH_INIT_PROC)
  zScript = TCLSH_INIT_PROC(interp);
#endif
  if( zScript==0 ){
    zScript = tclsh_main_loop();
  }
  if( Tcl_GlobalEval(interp, zScript)!=TCL_OK ){
    const char *zInfo = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
    if( zInfo==0 ) zInfo = Tcl_GetStringResult(interp);
    fprintf(stderr,"%s: %s\n", *argv, zInfo);
    return 1;
  }
  return 0;
}
#endif /* TCLSH */
