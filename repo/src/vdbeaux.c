/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2003 September 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used for creating, destroying, and populating
** a VDBE (or an "sqlite3_stmt" as it is known to the outside world.) 
*/
#include "sqliteInt.h"
#include "vdbeInt.h"

/* Forward references */
static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);
static void vdbeFreeOpArray(sqlite3 *, Op *, int);

/*
** Create a new virtual database engine.
*/
Vdbe *sqlite3VdbeCreate(Parse *pParse){
  
// ABS Label 7
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
sqlite3 *db = pParse->db;
  Vdbe *p;
  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );
  
// ABS Label 12
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ROR Label 13
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
if( p==0 ) { return 0;
}
  
// AOR Label 8
if(sizeof(Vdbe) / __builtin_offsetof(Vdbe, aOp) != sizeof(Vdbe) - __builtin_offsetof(Vdbe, aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 8);
}
// AOR Label 9
if(sizeof(Vdbe) + __builtin_offsetof(Vdbe, aOp) != sizeof(Vdbe) - __builtin_offsetof(Vdbe, aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 9);
}
// AOR Label 10
if(sizeof(Vdbe) * __builtin_offsetof(Vdbe, aOp) != sizeof(Vdbe) - __builtin_offsetof(Vdbe, aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 10);
}
memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));
  p->db = db;
  
// ABS Label 14
if(db->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
if( db->pVdbe ){
    db->pVdbe->pPrev = p;
  }
  p->pNext = db->pVdbe;
  p->pPrev = 0;
  db->pVdbe = p;
  p->iVdbeMagic = VDBE_MAGIC_INIT;
  p->pParse = pParse;
  pParse->pVdbe = p;
  assert( pParse->aLabel==0 );
  assert( pParse->nLabel==0 );
  assert( p->nOpAlloc==0 );
  assert( pParse->szOpAlloc==0 );
  
// ABS Label 11
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
sqlite3VdbeAddOp2(p, OP_Init, 0, 1);
  
// ABS Label 15
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
return p;
}

/*
** Return the Parse object that owns a Vdbe object.
*/
Parse *sqlite3VdbeParser(Vdbe *p){
  
// ABS Label 16
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
return p->pParse;
}

/*
** Change the error string stored in Vdbe.zErrMsg
*/
void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){
  va_list ap;
  
// ABS Label 17
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
sqlite3DbFree(p->db, p->zErrMsg);
  va_start(ap, zFormat);
  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);
  va_end(ap);
}

/*
** Remember the SQL string for a prepared statement.
*/
void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){
  
// ABS Label 18
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ROR Label 19
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
if( p==0 ) { return;
}
  p->prepFlags = prepFlags;
  
// ROR Label 20
if(((prepFlags & 128) != 0) != ((prepFlags & 128) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}
if( (prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){
    p->expmask = 0;
  }
  assert( p->zSql==0 );
  p->zSql = sqlite3DbStrNDup(p->db, z, n);
}

#ifdef SQLITE_ENABLE_NORMALIZE
/*
** Add a new element to the Vdbe->pDblStr list.
*/
void sqlite3VdbeAddDblquoteStr(sqlite3 *db, Vdbe *p, const char *z){
  if( p ){
    int n = sqlite3Strlen30(z);
    DblquoteStr *pStr = sqlite3DbMallocRawNN(db,
                            sizeof(*pStr)+n+1-sizeof(pStr->z));
    if( pStr ){
      pStr->pNextStr = p->pDblStr;
      p->pDblStr = pStr;
      memcpy(pStr->z, z, n+1);
    }
  }
}
#endif

#ifdef SQLITE_ENABLE_NORMALIZE
/*
** zId of length nId is a double-quoted identifier.  Check to see if
** that identifier is really used as a string literal.
*/
int sqlite3VdbeUsesDoubleQuotedString(
  Vdbe *pVdbe,            /* The prepared statement */
  const char *zId         /* The double-quoted identifier, already dequoted */
){
  DblquoteStr *pStr;
  assert( zId!=0 );
  if( pVdbe->pDblStr==0 ) return 0;
  for(pStr=pVdbe->pDblStr; pStr; pStr=pStr->pNextStr){
    if( strcmp(zId, pStr->z)==0 ) return 1;
  }
  return 0;
}
#endif

/*
** Swap all content between two VDBE structures.
*/
void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){
  Vdbe tmp, *pTmp;
  char *zTmp;
  assert( pA->db==pB->db );
  tmp = *pA;
  *pA = *pB;
  *pB = tmp;
  pTmp = pA->pNext;
  pA->pNext = pB->pNext;
  pB->pNext = pTmp;
  pTmp = pA->pPrev;
  pA->pPrev = pB->pPrev;
  pB->pPrev = pTmp;
  zTmp = pA->zSql;
  pA->zSql = pB->zSql;
  pB->zSql = zTmp;
#ifdef SQLITE_ENABLE_NORMALIZE
  zTmp = pA->zNormSql;
  pA->zNormSql = pB->zNormSql;
  pB->zNormSql = zTmp;
#endif
  pB->expmask = pA->expmask;
  pB->prepFlags = pA->prepFlags;
  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));
  pB->aCounter[SQLITE_STMTSTATUS_REPREPARE]++;
}

/*
** Resize the Vdbe.aOp array so that it is at least nOp elements larger 
** than its current size. nOp is guaranteed to be less than or equal
** to 1024/sizeof(Op).
**
** If an out-of-memory error occurs while resizing the array, return
** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain 
** unchanged (this is so that any opcodes already allocated can be 
** correctly deallocated along with the rest of the Vdbe).
*/
static int growOpArray(Vdbe *v, int nOp){
  VdbeOp *pNew;
  
// ABS Label 21
if(v->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
Parse *p = v->pParse;

  /* The SQLITE_TEST_REALLOC_STRESS compile-time option is designed to force
  ** more frequent reallocs and hence provide more opportunities for 
  ** simulated OOM faults.  SQLITE_TEST_REALLOC_STRESS is generally used
  ** during testing only.  With SQLITE_TEST_REALLOC_STRESS grow the op array
  ** by the minimum* amount required until the size reaches 512.  Normal
  ** operation (without SQLITE_TEST_REALLOC_STRESS) is to double the current
  ** size of the op array or add 1KB of space, whichever is smaller. */
#ifdef SQLITE_TEST_REALLOC_STRESS
  sqlite3_int64 nNew = (v->nOpAlloc>=512 ? 2*(sqlite3_int64)v->nOpAlloc
                        : (sqlite3_int64)v->nOpAlloc+nOp);
#else
  sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc
                        : (sqlite3_int64)(1024/sizeof(Op)));
  UNUSED_PARAMETER(nOp);
#endif

  /* Ensure that the size of a VDBE does not grow too large */
  
// ABS Label 22
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ROR Label 23
if((nNew <= p->db->aLimit[5]) != (nNew > p->db->aLimit[5]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
// ROR Label 24
if((nNew < p->db->aLimit[5]) != (nNew > p->db->aLimit[5]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
// ROR Label 25
if((nNew >= p->db->aLimit[5]) != (nNew > p->db->aLimit[5]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
if( nNew > p->db->aLimit[SQLITE_LIMIT_VDBE_OP] ){
    
// ABS Label 26
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3OomFault(p->db);
    return SQLITE_NOMEM;
  }

  assert( nOp<=(1024/sizeof(Op)) );
  assert( nNew>=(v->nOpAlloc+nOp) );
  pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));
  
// ABS Label 27
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
if( pNew ){
    p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);
    v->nOpAlloc = p->szOpAlloc/sizeof(Op);
    v->aOp = pNew;
  }
  
// MCC Label 28
if(( ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
return (pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT);
}

#ifdef SQLITE_DEBUG
/* This routine is just a convenient place to set a breakpoint that will
** fire after each opcode is inserted and displayed using
** "PRAGMA vdbe_addoptrace=on".  Parameters "pc" (program counter) and
** pOp are available to make the breakpoint conditional.
**
** Other useful labels for breakpoints include:
**   test_trace_breakpoint(pc,pOp)
**   sqlite3CorruptError(lineno)
**   sqlite3MisuseError(lineno)
**   sqlite3CantopenError(lineno)
*/
static void test_addop_breakpoint(int pc, Op *pOp){
  static int n = 0;
  n++;
}
#endif

/*
** Add a new instruction to the list of instructions current in the
** VDBE.  Return the address of the new instruction.
**
** Parameters:
**
**    p               Pointer to the VDBE
**
**    op              The opcode for this instruction
**
**    p1, p2, p3      Operands
**
** Use the sqlite3VdbeResolveLabel() function to fix an address and
** the sqlite3VdbeChangeP4() function to change the value of the P4
** operand.
*/
static SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){
  assert( p->nOpAlloc<=p->nOp );
  if( growOpArray(p, 1) ) { return 1;
}
  assert( p->nOpAlloc>p->nOp );
  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);
}
int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){
  int i;
  VdbeOp *pOp;

  i = p->nOp;
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
  assert( op>=0 && op<0xff );
  
// ABS Label 29
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
// ABS Label 30
if(p->nOpAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// ROR Label 31
if((p->nOpAlloc < i) != (p->nOpAlloc <= i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((p->nOpAlloc > i) != (p->nOpAlloc <= i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((p->nOpAlloc >= i) != (p->nOpAlloc <= i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}
if( p->nOpAlloc<=i ){
    return growOp3(p, op, p1, p2, p3);
  }
  p->nOp++;
  pOp = &p->aOp[i];
  pOp->opcode = (u8)op;
  pOp->p5 = 0;
  pOp->p1 = p1;
  pOp->p2 = p2;
  pOp->p3 = p3;
  pOp->p4.p = 0;
  pOp->p4type = P4_NOTUSED;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
  pOp->zComment = 0;
#endif
#ifdef SQLITE_DEBUG
  if( p->db->flags & SQLITE_VdbeAddopTrace ){
    sqlite3VdbePrintOp(0, i, &p->aOp[i]);
    test_addop_breakpoint(i, &p->aOp[i]);
  }
#endif
#ifdef VDBE_PROFILE
  pOp->cycles = 0;
  pOp->cnt = 0;
#endif
#ifdef SQLITE_VDBE_COVERAGE
  pOp->iSrcLine = 0;
#endif
  
// ABS Label 34
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
return i;
}
int sqlite3VdbeAddOp0(Vdbe *p, int op){
  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);
}
int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){
  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);
}
int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){
  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
}

/* Generate code for an unconditional jump to instruction iDest
*/
int sqlite3VdbeGoto(Vdbe *p, int iDest){
  return sqlite3VdbeAddOp3(p, OP_Goto, 0, iDest, 0);
}

/* Generate code to cause the string zStr to be loaded into
** register iDest
*/
int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){
  return sqlite3VdbeAddOp4(p, OP_String8, 0, iDest, 0, zStr, 0);
}

/*
** Generate code that initializes multiple registers to string or integer
** constants.  The registers begin with iDest and increase consecutively.
** One register is initialized for each characgter in zTypes[].  For each
** "s" character in zTypes[], the register is a string if the argument is
** not NULL, or OP_Null if the value is a null pointer.  For each "i" character
** in zTypes[], the register is initialized to an integer.
**
** If the input string does not end with "X" then an OP_ResultRow instruction
** is generated for the values inserted.
*/
void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){
  va_list ap;
  int i;
  char c;
  va_start(ap, zTypes);
  i = 0;
for(; (c = zTypes[i])!=0; i++){
    
// ROR Label 38
if((c != 's') != (c == 's'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
if( c=='s' ){
      const char *z = va_arg(ap, const char*);
      
// ABS Label 39
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}

// ABS Label 40
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
// ABS Label 41
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// AOR Label 42
if(iDest - i != iDest + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 42);
}
// AOR Label 43
if(iDest / i != iDest + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 43);
}
// AOR Label 44
if(iDest * i != iDest + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 44);
}

// ABS Label 45
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
sqlite3VdbeAddOp4(p, z==0 ? OP_Null : OP_String8, 0, iDest+i, 0, z, 0);
    }else { 
// ROR Label 46
if((c != 'i') != (c == 'i'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
if( c=='i' ){
      
// ABS Label 47
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ABS Label 48
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}
// ABS Label 49
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}

// AOR Label 50
if(iDest - i != iDest + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 50);
}
// AOR Label 51
if(iDest / i != iDest + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 51);
}
// AOR Label 52
if(iDest * i != iDest + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 52);
}
sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest+i);
    }else{
      goto skip_op_resultrow;
    };}

  };
  
// ABS Label 35
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// ABS Label 36
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ABS Label 37
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
sqlite3VdbeAddOp2(p, OP_ResultRow, iDest, i);
skip_op_resultrow:
  va_end(ap);
}

/*
** Add an opcode that includes the p4 value as a pointer.
*/
int sqlite3VdbeAddOp4(
  Vdbe *p,            /* Add the opcode to this VM */
  int op,             /* The new opcode */
  int p1,             /* The P1 operand */
  int p2,             /* The P2 operand */
  int p3,             /* The P3 operand */
  const char *zP4,    /* The P4 operand */
  int p4type          /* P4 operand type */
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  
// ABS Label 53
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// ABS Label 54
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// ABS Label 55
if(zP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}

// ABS Label 56
if(p4type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}
sqlite3VdbeChangeP4(p, addr, zP4, p4type);
  
// ABS Label 57
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
return addr;
}

/*
** Add an OP_Function or OP_PureFunc opcode.
**
** The eCallCtx argument is information (typically taken from Expr.op2)
** that describes the calling context of the function.  0 means a general
** function call.  NC_IsCheck means called by a check constraint,
** NC_IdxExpr means called as part of an index expression.  NC_PartIdx
** means in the WHERE clause of a partial index.  NC_GenCol means called
** while computing a generated column value.  0 is the usual case.
*/
int sqlite3VdbeAddFunctionCall(
  Parse *pParse,        /* Parsing context */
  int p1,               /* Constant argument mask */
  int p2,               /* First argument register */
  int p3,               /* Register into which results are written */
  int nArg,             /* Number of argument */
  const FuncDef *pFunc, /* The function to be invoked */
  int eCallCtx          /* Calling context */
){
  
// ABS Label 58
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
Vdbe *v = pParse->pVdbe;
  int nByte;
  int addr;
  sqlite3_context *pCtx;
  assert( v );
  nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);
  pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);
  
// ABS Label 60
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}

// ROR Label 61
if((pCtx != 0) != (pCtx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
if( pCtx==0 ){
    assert( pParse->db->mallocFailed );
    
// ABS Label 62
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}
freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);
    return 0;
  }
  pCtx->pOut = 0;
  pCtx->pFunc = (FuncDef*)pFunc;
  pCtx->pVdbe = 0;
  pCtx->isError = 0;
  pCtx->argc = nArg;
  pCtx->iOp = sqlite3VdbeCurrentAddr(v);
  addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,
                           p1, p2, p3, (char*)pCtx, P4_FUNCCTX);
  
// ABS Label 59
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
sqlite3VdbeChangeP5(v, eCallCtx & NC_SelfRef);
  
// ABS Label 63
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}
return addr;
}

/*
** Add an opcode that includes the p4 value with a P4_INT64 or
** P4_REAL type.
*/
int sqlite3VdbeAddOp4Dup8(
  Vdbe *p,            /* Add the opcode to this VM */
  int op,             /* The new opcode */
  int p1,             /* The P1 operand */
  int p2,             /* The P2 operand */
  int p3,             /* The P3 operand */
  const u8 *zP4,      /* The P4 operand */
  int p4type          /* P4 operand type */
){
  char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);
  
// ABS Label 64
if(p4copy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}
if( p4copy ) { memcpy(p4copy, zP4, 8);
}
  return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type);
}

#ifndef SQLITE_OMIT_EXPLAIN
/*
** Return the address of the current EXPLAIN QUERY PLAN baseline.
** 0 means "none".
*/
int sqlite3VdbeExplainParent(Parse *pParse){
  VdbeOp *pOp;
  
// ABS Label 65
if(pParse->addrExplain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}

// ROR Label 66
if((pParse->addrExplain != 0) != (pParse->addrExplain == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
if( pParse->addrExplain==0 ) { return 0;
}
  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);
  
// ABS Label 67
if(pOp->p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
return pOp->p2;
}

/*
** Set a debugger breakpoint on the following routine in order to
** monitor the EXPLAIN QUERY PLAN code generation.
*/
#if defined(SQLITE_DEBUG)
void sqlite3ExplainBreakpoint(const char *z1, const char *z2){
  (void)z1;
  (void)z2;
}
#endif

/*
** Add a new OP_Explain opcode.
**
** If the bPush flag is true, then make this opcode the parent for
** subsequent Explains until sqlite3VdbeExplainPop() is called.
*/
void sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){
#ifndef SQLITE_DEBUG
  /* Always include the OP_Explain opcodes if SQLITE_DEBUG is defined.
  ** But omit them (for performance) during production builds */
  
// ROR Label 68
if((pParse->explain != 2) != (pParse->explain == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
if( pParse->explain==2 )
#endif
  {
    char *zMsg;
    Vdbe *v;
    va_list ap;
    int iThis;
    va_start(ap, zFmt);
    zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);
    va_end(ap);
    v = pParse->pVdbe;
    iThis = v->nOp;
    
// ABS Label 69
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}

// ABS Label 70
if(iThis < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ABS Label 71
if(pParse->addrExplain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}
sqlite3VdbeAddOp4(v, OP_Explain, iThis, pParse->addrExplain, 0,
                      zMsg, P4_DYNAMIC);
    sqlite3ExplainBreakpoint(bPush?"PUSH":"", sqlite3VdbeGetOp(v,-1)->p4.z);
    
// ABS Label 72
if(bPush < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
if( bPush){
      pParse->addrExplain = iThis;
    }
  }
}

/*
** Pop the EXPLAIN QUERY PLAN stack one level.
*/
void sqlite3VdbeExplainPop(Parse *pParse){
  sqlite3ExplainBreakpoint("POP", 0);
  pParse->addrExplain = sqlite3VdbeExplainParent(pParse);
}
#endif /* SQLITE_OMIT_EXPLAIN */

/*
** Add an OP_ParseSchema opcode.  This routine is broken out from
** sqlite3VdbeAddOp4() since it needs to also needs to mark all btrees
** as having been used.
**
** The zWhere string must have been obtained from sqlite3_malloc().
** This routine will take ownership of the allocated memory.
*/
void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere, u16 p5){
  int j;
  
// ABS Label 73
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// ABS Label 74
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}
sqlite3VdbeAddOp4(p, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);
  
// ABS Label 75
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ABS Label 76
if(p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
sqlite3VdbeChangeP5(p, p5);
  j = 0;

// ABS Label 78
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
// ABS Label 79
if(p->db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ROR Label 80
if((j <= p->db->nDb) != (j < p->db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
// ROR Label 81
if((j > p->db->nDb) != (j < p->db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
// ROR Label 82
if((j >= p->db->nDb) != (j < p->db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
for(; j<p->db->nDb; j++) { 
// ABS Label 88
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// ABS Label 89
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
sqlite3VdbeUsesBtree(p, j);
};
// ABS Label 83
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
// ABS Label 84
if(p->db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ROR Label 85
if((j <= p->db->nDb) != (j < p->db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}
// ROR Label 86
if((j > p->db->nDb) != (j < p->db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
// ROR Label 87
if((j >= p->db->nDb) != (j < p->db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}

  
// ABS Label 77
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}
sqlite3MayAbort(p->pParse);
}

/*
** Add an opcode that includes the p4 value as an integer.
*/
int sqlite3VdbeAddOp4Int(
  Vdbe *p,            /* Add the opcode to this VM */
  int op,             /* The new opcode */
  int p1,             /* The P1 operand */
  int p2,             /* The P2 operand */
  int p3,             /* The P3 operand */
  int p4              /* The P4 operand as an integer */
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  
// ROR Label 90
if((p->db->mallocFailed != 0) != (p->db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( p->db->mallocFailed==0 ){
    VdbeOp *pOp = &p->aOp[addr];
    pOp->p4type = P4_INT32;
    pOp->p4.i = p4;
  }
  
// ABS Label 91
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
return addr;
}

/* Insert the end of a co-routine
*/
void sqlite3VdbeEndCoroutine(Vdbe *v, int regYield){
  
// ABS Label 92
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// ABS Label 93
if(regYield < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
sqlite3VdbeAddOp1(v, OP_EndCoroutine, regYield);

  /* Clear the temporary register cache, thereby ensuring that each
  ** co-routine has its own independent set of registers, because co-routines
  ** might expect their registers to be preserved across an OP_Yield, and
  ** that could cause problems if two or more co-routines are using the same
  ** temporary register.
  */
  v->pParse->nTempReg = 0;
  v->pParse->nRangeReg = 0;
}

/*
** Create a new symbolic label for an instruction that has yet to be
** coded.  The symbolic label is really just a negative number.  The
** label can be used as the P2 value of an operation.  Later, when
** the label is resolved to a specific address, the VDBE will scan
** through its operation list and change all values of P2 which match
** the label into the resolved address.
**
** The VDBE knows that a P2 value is a label because labels are
** always negative and P2 values are suppose to be non-negative.
** Hence, a negative P2 value is a label that has yet to be resolved.
** (Later:) This is only true for opcodes that have the OPFLG_JUMP
** property.
**
** Variable usage notes:
**
**     Parse.aLabel[x]     Stores the address that the x-th label resolves
**                         into.  For testing (SQLITE_DEBUG), unresolved
**                         labels stores -1, but that is not required.
**     Parse.nLabelAlloc   Number of slots allocated to Parse.aLabel[]
**     Parse.nLabel        The *negative* of the number of labels that have
**                         been issued.  The negative is stored because
**                         that gives a performance improvement over storing
**                         the equivalent positive value.
*/
int sqlite3VdbeMakeLabel(Parse *pParse){
  return --pParse->nLabel;
}

/*
** Resolve label "x" to be the address of the next instruction to
** be inserted.  The parameter "x" must have been obtained from
** a prior call to sqlite3VdbeMakeLabel().
*/
static SQLITE_NOINLINE void resizeResolveLabel(Parse *p, Vdbe *v, int j){
  
// ABS Label 94
if(p->nLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// AOR Label 95
if(10 / p->nLabel != 10 - p->nLabel)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 95);
}
// AOR Label 96
if(10 + p->nLabel != 10 - p->nLabel)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 96);
}
// AOR Label 97
if(10 * p->nLabel != 10 - p->nLabel)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 97);
}
int nNewSize = 10 - p->nLabel;
  p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,
                     nNewSize*sizeof(p->aLabel[0]));
  
// ABS Label 98
if(p->aLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}

// ROR Label 99
if((p->aLabel != 0) != (p->aLabel == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
if( p->aLabel==0 ){
    p->nLabelAlloc = 0;
  }else{
#ifdef SQLITE_DEBUG
    int i;
    for(i=p->nLabelAlloc; i<nNewSize; i++) p->aLabel[i] = -1;
#endif
    p->nLabelAlloc = nNewSize;
    p->aLabel[j] = v->nOp;
  }
}
void sqlite3VdbeResolveLabel(Vdbe *v, int x){
  
// ABS Label 100
if(v->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
Parse *p = v->pParse;
  int j = ADDR(x);
  assert( v->iVdbeMagic==VDBE_MAGIC_INIT );
  assert( j<-p->nLabel );
  assert( j>=0 );
#ifdef SQLITE_DEBUG
  if( p->db->flags & SQLITE_VdbeAddopTrace ){
    printf("RESOLVE LABEL %d to %d\n", x, v->nOp);
  }
#endif
  
// ABS Label 101
if(p->nLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
// ABS Label 102
if(p->nLabelAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}

// AOR Label 103
if(p->nLabelAlloc - p->nLabel != p->nLabelAlloc + p->nLabel)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 103);
}
// AOR Label 104
if(p->nLabelAlloc / p->nLabel != p->nLabelAlloc + p->nLabel)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 104);
}
// AOR Label 105
if(p->nLabelAlloc * p->nLabel != p->nLabelAlloc + p->nLabel)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 105);
}

// ROR Label 106
if((p->nLabelAlloc + p->nLabel <= 0) != (p->nLabelAlloc + p->nLabel < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
// ROR Label 107
if((p->nLabelAlloc + p->nLabel > 0) != (p->nLabelAlloc + p->nLabel < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
// ROR Label 108
if((p->nLabelAlloc + p->nLabel >= 0) != (p->nLabelAlloc + p->nLabel < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 108);
}
if( p->nLabelAlloc + p->nLabel < 0 ){
    
// ABS Label 109
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}

// ABS Label 110
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// ABS Label 111
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}
resizeResolveLabel(p,v,j);
  }else{
    assert( p->aLabel[j]==(-1) ); /* Labels may only be resolved once */
    p->aLabel[j] = v->nOp;
  }
}

/*
** Mark the VDBE as one that can only be run one time.
*/
void sqlite3VdbeRunOnlyOnce(Vdbe *p){
  p->runOnlyOnce = 1;
}

/*
** Mark the VDBE as one that can only be run multiple times.
*/
void sqlite3VdbeReusable(Vdbe *p){
  p->runOnlyOnce = 0;
}

#ifdef SQLITE_DEBUG /* sqlite3AssertMayAbort() logic */

/*
** The following type and function are used to iterate through all opcodes
** in a Vdbe main program and each of the sub-programs (triggers) it may 
** invoke directly or indirectly. It should be used as follows:
**
**   Op *pOp;
**   VdbeOpIter sIter;
**
**   memset(&sIter, 0, sizeof(sIter));
**   sIter.v = v;                            // v is of type Vdbe* 
**   while( (pOp = opIterNext(&sIter)) ){
**     // Do something with pOp
**   }
**   sqlite3DbFree(v->db, sIter.apSub);
** 
*/
typedef struct VdbeOpIter VdbeOpIter;
struct VdbeOpIter {
  Vdbe *v;                   /* Vdbe to iterate through the opcodes of */
  SubProgram **apSub;        /* Array of subprograms */
  int nSub;                  /* Number of entries in apSub */
  int iAddr;                 /* Address of next instruction to return */
  int iSub;                  /* 0 = main program, 1 = first sub-program etc. */
};
static Op *opIterNext(VdbeOpIter *p){
  Vdbe *v = p->v;
  Op *pRet = 0;
  Op *aOp;
  int nOp;

  if( p->iSub<=p->nSub ){

    if( p->iSub==0 ){
      aOp = v->aOp;
      nOp = v->nOp;
    }else{
      aOp = p->apSub[p->iSub-1]->aOp;
      nOp = p->apSub[p->iSub-1]->nOp;
    }
    assert( p->iAddr<nOp );

    pRet = &aOp[p->iAddr];
    p->iAddr++;
    if( p->iAddr==nOp ){
      p->iSub++;
      p->iAddr = 0;
    }
  
    if( pRet->p4type==P4_SUBPROGRAM ){
      int nByte = (p->nSub+1)*sizeof(SubProgram*);
      int j;
      for(j=0; j<p->nSub; j++){
        if( p->apSub[j]==pRet->p4.pProgram ) break;
      }
      if( j==p->nSub ){
        p->apSub = sqlite3DbReallocOrFree(v->db, p->apSub, nByte);
        if( !p->apSub ){
          pRet = 0;
        }else{
          p->apSub[p->nSub++] = pRet->p4.pProgram;
        }
      }
    }
  }

  return pRet;
}

/*
** Check if the program stored in the VM associated with pParse may
** throw an ABORT exception (causing the statement, but not entire transaction
** to be rolled back). This condition is true if the main program or any
** sub-programs contains any of the following:
**
**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_HaltIfNull with P1=SQLITE_CONSTRAINT and P2=OE_Abort.
**   *  OP_Destroy
**   *  OP_VUpdate
**   *  OP_VCreate
**   *  OP_VRename
**   *  OP_FkCounter with P2==0 (immediate foreign key constraint)
**   *  OP_CreateBtree/BTREE_INTKEY and OP_InitCoroutine 
**      (for CREATE TABLE AS SELECT ...)
**
** Then check that the value of Parse.mayAbort is true if an
** ABORT may be thrown, or false otherwise. Return true if it does
** match, or false otherwise. This function is intended to be used as
** part of an assert statement in the compiler. Similar to:
**
**   assert( sqlite3VdbeAssertMayAbort(pParse->pVdbe, pParse->mayAbort) );
*/
int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){
  int hasAbort = 0;
  int hasFkCounter = 0;
  int hasCreateTable = 0;
  int hasCreateIndex = 0;
  int hasInitCoroutine = 0;
  Op *pOp;
  VdbeOpIter sIter;
  memset(&sIter, 0, sizeof(sIter));
  sIter.v = v;

  while( (pOp = opIterNext(&sIter))!=0 ){
    int opcode = pOp->opcode;
    if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename 
     || opcode==OP_VDestroy
     || opcode==OP_VCreate
     || opcode==OP_ParseSchema
     || ((opcode==OP_Halt || opcode==OP_HaltIfNull) 
      && ((pOp->p1)!=SQLITE_OK && pOp->p2==OE_Abort))
    ){
      hasAbort = 1;
      break;
    }
    if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;
    if( mayAbort ){
      /* hasCreateIndex may also be set for some DELETE statements that use
      ** OP_Clear. So this routine may end up returning true in the case 
      ** where a "DELETE FROM tbl" has a statement-journal but does not
      ** require one. This is not so bad - it is an inefficiency, not a bug. */
      if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;
      if( opcode==OP_Clear ) hasCreateIndex = 1;
    }
    if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;
#ifndef SQLITE_OMIT_FOREIGN_KEY
    if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){
      hasFkCounter = 1;
    }
#endif
  }
  sqlite3DbFree(v->db, sIter.apSub);

  /* Return true if hasAbort==mayAbort. Or if a malloc failure occurred.
  ** If malloc failed, then the while() loop above may not have iterated
  ** through all opcodes and hasAbort may be set incorrectly. Return
  ** true for this case to prevent the assert() in the callers frame
  ** from failing.  */
  return ( v->db->mallocFailed || hasAbort==mayAbort || hasFkCounter
        || (hasCreateTable && hasInitCoroutine) || hasCreateIndex
  );
}
#endif /* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */

#ifdef SQLITE_DEBUG
/*
** Increment the nWrite counter in the VDBE if the cursor is not an
** ephemeral cursor, or if the cursor argument is NULL.
*/
void sqlite3VdbeIncrWriteCounter(Vdbe *p, VdbeCursor *pC){
  if( pC==0
   || (pC->eCurType!=CURTYPE_SORTER
       && pC->eCurType!=CURTYPE_PSEUDO
       && !pC->isEphemeral)
  ){
    p->nWrite++;
  }
}
#endif

#ifdef SQLITE_DEBUG
/*
** Assert if an Abort at this point in time might result in a corrupt
** database.
*/
void sqlite3VdbeAssertAbortable(Vdbe *p){
  assert( p->nWrite==0 || p->usesStmtJournal );
}
#endif

/*
** This routine is called after all opcodes have been inserted.  It loops
** through all the opcodes and fixes up some details.
**
** (1) For each jump instruction with a negative P2 value (a label)
**     resolve the P2 value to an actual address.
**
** (2) Compute the maximum number of arguments used by any SQL function
**     and store that value in *pMaxFuncArgs.
**
** (3) Update the Vdbe.readOnly and Vdbe.bIsReader flags to accurately
**     indicate what the prepared statement actually does.
**
** (4) Initialize the p4.xAdvance pointer on opcodes that use it.
**
** (5) Reclaim the memory allocated for storing labels.
**
** This routine will only function correctly if the mkopcodeh.tcl generator
** script numbers the opcodes correctly.  Changes to this routine must be
** coordinated with changes to mkopcodeh.tcl.
*/
static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){
  
// ABS Label 112
if(*pMaxFuncArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}
int nMaxArgs = *pMaxFuncArgs;
  Op *pOp;
  
// ABS Label 113
if(p->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
Parse *pParse = p->pParse;
  
// ABS Label 114
if(pParse->aLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
int *aLabel = pParse->aLabel;
  p->readOnly = 1;
  p->bIsReader = 0;
  pOp = &p->aOp[p->nOp-1];
  while(1){

    /* Only JUMP opcodes and the short list of special opcodes in the switch
    ** below need to be considered.  The mkopcodeh.tcl generator script groups
    ** all these opcodes together near the front of the opcode list.  Skip
    ** any opcode that does not need processing by virtual of the fact that
    ** it is larger than SQLITE_MX_JUMP_OPCODE, as a performance optimization.
    */
    
// ROR Label 116
if((pOp->opcode < 62) != (pOp->opcode <= 62))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
// ROR Label 117
if((pOp->opcode > 62) != (pOp->opcode <= 62))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
// ROR Label 118
if((pOp->opcode >= 62) != (pOp->opcode <= 62))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
if( pOp->opcode<=SQLITE_MX_JUMP_OPCODE ){
      /* NOTE: Be sure to update mkopcodeh.tcl when adding or removing
      ** cases from this switch! */
      switch( pOp->opcode ){
        case OP_Transaction: {
          
// ABS Label 119
if(pOp->p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}

// ROR Label 120
if((pOp->p2 == 0) != (pOp->p2 != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
if( pOp->p2!=0 ) { p->readOnly = 0;
}
          /* no break */ deliberate_fall_through
        }
        case OP_AutoCommit:
        case OP_Savepoint: {
          p->bIsReader = 1;
          break;
        }
#ifndef SQLITE_OMIT_WAL
        case OP_Checkpoint:
#endif
        case OP_Vacuum:
        case OP_JournalMode: {
          p->readOnly = 0;
          p->bIsReader = 1;
          break;
        }
        case OP_Next:
        case OP_SorterNext: {
          pOp->p4.xAdvance = sqlite3BtreeNext;
          pOp->p4type = P4_ADVANCE;
          /* The code generator never codes any of these opcodes as a jump
          ** to a label.  They are always coded as a jump backwards to a 
          ** known address */
          assert( pOp->p2>=0 );
          break;
        }
        case OP_Prev: {
          pOp->p4.xAdvance = sqlite3BtreePrevious;
          pOp->p4type = P4_ADVANCE;
          /* The code generator never codes any of these opcodes as a jump
          ** to a label.  They are always coded as a jump backwards to a 
          ** known address */
          assert( pOp->p2>=0 );
          break;
        }
#ifndef SQLITE_OMIT_VIRTUALTABLE
        case OP_VUpdate: {
          
// ABS Label 121
if(nMaxArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}
// ABS Label 122
if(pOp->p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// ROR Label 123
if((pOp->p2 <= nMaxArgs) != (pOp->p2 > nMaxArgs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
// ROR Label 124
if((pOp->p2 < nMaxArgs) != (pOp->p2 > nMaxArgs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}
// ROR Label 125
if((pOp->p2 >= nMaxArgs) != (pOp->p2 > nMaxArgs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}
if( pOp->p2>nMaxArgs ) { nMaxArgs = pOp->p2;
}
          break;
        }
        case OP_VFilter: {
          int n;
          assert( (pOp - p->aOp) >= 3 );
          assert( pOp[-1].opcode==OP_Integer );
          n = pOp[-1].p1;
          
// ABS Label 126
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}
// ABS Label 127
if(nMaxArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}

// ROR Label 128
if((n <= nMaxArgs) != (n > nMaxArgs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}
// ROR Label 129
if((n < nMaxArgs) != (n > nMaxArgs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 129);
}
// ROR Label 130
if((n >= nMaxArgs) != (n > nMaxArgs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
if( n>nMaxArgs ) { nMaxArgs = n;
}
          /* Fall through into the default case */
          /* no break */ deliberate_fall_through
        }
#endif
        default: {
          
// ABS Label 131
if(pOp->p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}

// ROR Label 132
if((pOp->p2 <= 0) != (pOp->p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
// ROR Label 133
if((pOp->p2 > 0) != (pOp->p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
// ROR Label 134
if((pOp->p2 >= 0) != (pOp->p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}
if( pOp->p2<0 ){
            /* The mkopcodeh.tcl script has so arranged things that the only
            ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to
            ** have non-negative values for P2. */
            assert( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)!=0 );
            assert( ADDR(pOp->p2)<-pParse->nLabel );
            pOp->p2 = aLabel[ADDR(pOp->p2)];
          }
          break;
        }
      }
      /* The mkopcodeh.tcl script has so arranged things that the only
      ** non-jump opcodes less than SQLITE_MX_JUMP_CODE are guaranteed to
      ** have non-negative values for P2. */
      assert( (sqlite3OpcodeProperty[pOp->opcode]&OPFLG_JUMP)==0 || pOp->p2>=0);
    }
    
// ABS Label 135
if(p->aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}
// ABS Label 136
if(pOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}

// ROR Label 137
if((pOp != p->aOp) != (pOp == p->aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
if( pOp==p->aOp ) { break;
}
    pOp--;
  };
  
// ABS Label 115
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
sqlite3DbFree(p->db, pParse->aLabel);
  pParse->aLabel = 0;
  pParse->nLabel = 0;
  *pMaxFuncArgs = nMaxArgs;
  assert( p->bIsReader!=0 || DbMaskAllZero(p->btreeMask) );
}

/*
** Return the address of the next instruction to be inserted.
*/
int sqlite3VdbeCurrentAddr(Vdbe *p){
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
  
// ABS Label 138
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}
return p->nOp;
}

/*
** Verify that at least N opcode slots are available in p without
** having to malloc for more space (except when compiled using
** SQLITE_TEST_REALLOC_STRESS).  This interface is used during testing
** to verify that certain calls to sqlite3VdbeAddOpList() can never
** fail due to a OOM fault and hence that the return value from
** sqlite3VdbeAddOpList() will always be non-NULL.
*/
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N){
  assert( p->nOp + N <= p->nOpAlloc );
}
#endif

/*
** Verify that the VM passed as the only argument does not contain
** an OP_ResultRow opcode. Fail an assert() if it does. This is used
** by code in pragma.c to ensure that the implementation of certain
** pragmas comports with the flags specified in the mkpragmatab.tcl
** script.
*/
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
void sqlite3VdbeVerifyNoResultRow(Vdbe *p){
  int i;
  for(i=0; i<p->nOp; i++){
    assert( p->aOp[i].opcode!=OP_ResultRow );
  }
}
#endif

/*
** Generate code (a single OP_Abortable opcode) that will
** verify that the VDBE program can safely call Abort in the current
** context.
*/
#if defined(SQLITE_DEBUG)
void sqlite3VdbeVerifyAbortable(Vdbe *p, int onError){
  if( onError==OE_Abort ) sqlite3VdbeAddOp0(p, OP_Abortable);
}
#endif

/*
** This function returns a pointer to the array of opcodes associated with
** the Vdbe passed as the first argument. It is the callers responsibility
** to arrange for the returned array to be eventually freed using the 
** vdbeFreeOpArray() function.
**
** Before returning, *pnOp is set to the number of entries in the returned
** array. Also, *pnMaxArg is set to the larger of its current value and 
** the number of entries in the Vdbe.apArg[] array required to execute the 
** returned program.
*/
VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){
  
// ABS Label 139
if(p->aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
VdbeOp *aOp = p->aOp;
  assert( aOp && !p->db->mallocFailed );

  /* Check that sqlite3VdbeUsesBtree() was not called on this VM */
  assert( DbMaskAllZero(p->btreeMask) );

  
// ABS Label 140
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ABS Label 141
if(pnMaxArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
resolveP2Values(p, pnMaxArg);
  *pnOp = p->nOp;
  p->aOp = 0;
  
// ABS Label 142
if(aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
return aOp;
}

/*
** Add a whole list of operations to the operation stack.  Return a
** pointer to the first operation inserted.
**
** Non-zero P2 arguments to jump instructions are automatically adjusted
** so that the jump target is relative to the first operation inserted.
*/
VdbeOp *sqlite3VdbeAddOpList(
  Vdbe *p,                     /* Add opcodes to the prepared statement */
  int nOp,                     /* Number of opcodes to add */
  VdbeOpList const *aOp,       /* The opcodes to be added */
  int iLineno                  /* Source-file line number of first opcode */
){
  int i;
  VdbeOp *pOut, *pFirst;
  assert( nOp>0 );
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){
    return 0;
  }
  pFirst = pOut = &p->aOp[p->nOp];
  i = 0;

// ABS Label 143
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
// ABS Label 144
if(nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}

// ROR Label 145
if((i <= nOp) != (i < nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
// ROR Label 146
if((i > nOp) != (i < nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 146);
}
// ROR Label 147
if((i >= nOp) != (i < nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 147);
}
for(; i<nOp; i++, aOp++, pOut++){
    pOut->opcode = aOp->opcode;
    pOut->p1 = aOp->p1;
    pOut->p2 = aOp->p2;
    assert( aOp->p2>=0 );
    
// COR Label 153
if(((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0 || aOp->p2 > 0) != ((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0 && aOp->p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 153);
}

// ROR Label 154
if(((sqlite3OpcodeProperty[aOp->opcode] & 1) == 0) != ((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
// ROR Label 155
if((aOp->p2 <= 0) != (aOp->p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 155);
}
// ROR Label 156
if((aOp->p2 < 0) != (aOp->p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
// ROR Label 157
if((aOp->p2 >= 0) != (aOp->p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 157);
}

// MCC Label 158
if((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0 && aOp->p2 > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
// MCC Label 159
if((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0 && !(aOp->p2 > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 159);
}
// MCC Label 160
if(!((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0) && aOp->p2 > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 160);
}
// MCC Label 161
if(!((sqlite3OpcodeProperty[aOp->opcode] & 1) != 0) && !(aOp->p2 > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 161);
}
if( (sqlite3OpcodeProperty[aOp->opcode] & OPFLG_JUMP)!=0 && aOp->p2>0 ){
      pOut->p2 += p->nOp;
    }
    pOut->p3 = aOp->p3;
    pOut->p4type = P4_NOTUSED;
    pOut->p4.p = 0;
    pOut->p5 = 0;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
    pOut->zComment = 0;
#endif
#ifdef SQLITE_VDBE_COVERAGE
    pOut->iSrcLine = iLineno+i;
#else
    (void)iLineno;
#endif
#ifdef SQLITE_DEBUG
    if( p->db->flags & SQLITE_VdbeAddopTrace ){
      sqlite3VdbePrintOp(0, i+p->nOp, &p->aOp[i+p->nOp]);
    }
#endif
  };
// ABS Label 148
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
// ABS Label 149
if(nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}

// ROR Label 150
if((i <= nOp) != (i < nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if((i > nOp) != (i < nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((i >= nOp) != (i < nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}

  p->nOp += nOp;
  
// ABS Label 162
if(pFirst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}
return pFirst;
}

#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)
/*
** Add an entry to the array of counters managed by sqlite3_stmt_scanstatus().
*/
void sqlite3VdbeScanStatus(
  Vdbe *p,                        /* VM to add scanstatus() to */
  int addrExplain,                /* Address of OP_Explain (or 0) */
  int addrLoop,                   /* Address of loop counter */ 
  int addrVisit,                  /* Address of rows visited counter */
  LogEst nEst,                    /* Estimated number of output rows */
  const char *zName               /* Name of table or index being scanned */
){
  sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);
  ScanStatus *aNew;
  aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);
  if( aNew ){
    ScanStatus *pNew = &aNew[p->nScan++];
    pNew->addrExplain = addrExplain;
    pNew->addrLoop = addrLoop;
    pNew->addrVisit = addrVisit;
    pNew->nEst = nEst;
    pNew->zName = sqlite3DbStrDup(p->db, zName);
    p->aScan = aNew;
  }
}
#endif


/*
** Change the value of the opcode, or P1, P2, P3, or P5 operands
** for a specific instruction.
*/
void sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){
  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;
}
void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){
  sqlite3VdbeGetOp(p,addr)->p1 = val;
}
void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){
  sqlite3VdbeGetOp(p,addr)->p2 = val;
}
void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){
  sqlite3VdbeGetOp(p,addr)->p3 = val;
}
void sqlite3VdbeChangeP5(Vdbe *p, u16 p5){
  assert( p->nOp>0 || p->db->mallocFailed );
  
// ABS Label 163
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ROR Label 164
if((p->nOp <= 0) != (p->nOp > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
// ROR Label 165
if((p->nOp < 0) != (p->nOp > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((p->nOp >= 0) != (p->nOp > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
if( p->nOp>0 ) { p->aOp[p->nOp-1].p5 = p5;
}
}

/*
** Change the P2 operand of instruction addr so that it points to
** the address of the next instruction to be coded.
*/
void sqlite3VdbeJumpHere(Vdbe *p, int addr){
  
// ABS Label 167
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}

// ABS Label 168
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}

// ABS Label 169
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
sqlite3VdbeChangeP2(p, addr, p->nOp);
}

/*
** Change the P2 operand of the jump instruction at addr so that
** the jump lands on the next opcode.  Or if the jump instruction was
** the previous opcode (and is thus a no-op) then simply back up
** the next instruction counter by one slot so that the jump is
** overwritten by the next inserted opcode.
**
** This routine is an optimization of sqlite3VdbeJumpHere() that
** strives to omit useless byte-code like this:
**
**        7   Once 0 8 0
**        8   ...
*/
void sqlite3VdbeJumpHereOrPopInst(Vdbe *p, int addr){
  
// ABS Label 170
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}
// ABS Label 171
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

// AOR Label 172
if(p->nOp / 1 != p->nOp - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 172);
}
// AOR Label 173
if(p->nOp + 1 != p->nOp - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 173);
}
// AOR Label 174
if(p->nOp * 1 != p->nOp - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 174);
}

// ROR Label 175
if((addr != p->nOp - 1) != (addr == p->nOp - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
if( addr==p->nOp-1 ){
    assert( p->aOp[addr].opcode==OP_Once
         || p->aOp[addr].opcode==OP_If
         || p->aOp[addr].opcode==OP_FkIfZero );
    assert( p->aOp[addr].p4type==0 );
#ifdef SQLITE_VDBE_COVERAGE
    sqlite3VdbeGetOp(p,-1)->iSrcLine = 0;  /* Erase VdbeCoverage() macros */
#endif
    p->nOp--;
  }else{
    
// ABS Label 176
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// ABS Label 177
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}

// ABS Label 178
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}
sqlite3VdbeChangeP2(p, addr, p->nOp);
  }
}


/*
** If the input FuncDef structure is ephemeral, then free it.  If
** the FuncDef is not ephermal, then do nothing.
*/
static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){
  
// ROR Label 179
if(((pDef->funcFlags & 16) == 0) != ((pDef->funcFlags & 16) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}
if( (pDef->funcFlags & SQLITE_FUNC_EPHEM)!=0 ){
    
// ABS Label 180
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
sqlite3DbFreeNN(db, pDef);
  }
}

/*
** Delete a P4 value if necessary.
*/
static SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p){
  
// ABS Label 182
if(p->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
if( p->szMalloc ) { 
// ABS Label 183
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
sqlite3DbFree(db, p->zMalloc);
}
  
// ABS Label 181
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
sqlite3DbFreeNN(db, p);
}
static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){
  
// ABS Label 184
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}

// ABS Label 185
if(p->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
freeEphemeralFunction(db, p->pFunc);
  
// ABS Label 186
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
sqlite3DbFreeNN(db, p);
}
static void freeP4(sqlite3 *db, int p4type, void *p4){
  assert( db );
  switch( p4type ){
    case P4_FUNCCTX: {
      
// ABS Label 187
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
freeP4FuncCtx(db, (sqlite3_context*)p4);
      break;
    }
    case P4_REAL:
    case P4_INT64:
    case P4_DYNAMIC:
    case P4_DYNBLOB:
    case P4_INTARRAY: {
      
// ABS Label 188
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// ABS Label 189
if(p4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}
sqlite3DbFree(db, p4);
      break;
    }
    case P4_KEYINFO: {
      
// ABS Label 190
if(db->pnBytesFreed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}

// ROR Label 191
if((db->pnBytesFreed != 0) != (db->pnBytesFreed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
if( db->pnBytesFreed==0 ) { sqlite3KeyInfoUnref((KeyInfo*)p4);
}
      break;
    }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
    case P4_EXPR: {
      sqlite3ExprDelete(db, (Expr*)p4);
      break;
    }
#endif
    case P4_FUNCDEF: {
      
// ABS Label 192
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
freeEphemeralFunction(db, (FuncDef*)p4);
      break;
    }
    case P4_MEM: {
      
// ABS Label 193
if(db->pnBytesFreed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}

// ROR Label 194
if((db->pnBytesFreed != 0) != (db->pnBytesFreed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
if( db->pnBytesFreed==0 ){
        sqlite3ValueFree((sqlite3_value*)p4);
      }else{
        
// ABS Label 195
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}
freeP4Mem(db, (Mem*)p4);
      }
      break;
    }
    case P4_VTAB : {
      
// ABS Label 196
if(db->pnBytesFreed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}

// ROR Label 197
if((db->pnBytesFreed != 0) != (db->pnBytesFreed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 197);
}
if( db->pnBytesFreed==0 ) { sqlite3VtabUnlock((VTable *)p4);
}
      break;
    }
  }
}

/*
** Free the space allocated for aOp and any p4 values allocated for the
** opcodes contained within. If aOp is not NULL it is assumed to contain 
** nOp entries. 
*/
static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){
  
// ABS Label 198
if(aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
if( aOp ){
    Op *pOp;
    pOp = &aOp[nOp - 1];

// ABS Label 200
if(aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
// ABS Label 201
if(pOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}

// ROR Label 202
if((pOp < aOp) != (pOp >= aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
// ROR Label 203
if((pOp > aOp) != (pOp >= aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
// ROR Label 204
if((pOp <= aOp) != (pOp >= aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
for(; pOp>=aOp; pOp--){
      
// ROR Label 210
if((pOp->p4type < (-7)) != (pOp->p4type <= (-7)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
// ROR Label 211
if((pOp->p4type > (-7)) != (pOp->p4type <= (-7)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
// ROR Label 212
if((pOp->p4type >= (-7)) != (pOp->p4type <= (-7)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 212);
}
if( pOp->p4type <= P4_FREE_IF_LE ) { 
// ABS Label 213
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}

// ABS Label 214
if(pOp->p4.p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}
freeP4(db, pOp->p4type, pOp->p4.p);
}
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
      sqlite3DbFree(db, pOp->zComment);
#endif     
    };
// ABS Label 205
if(aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}
// ABS Label 206
if(pOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}

// ROR Label 207
if((pOp < aOp) != (pOp >= aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
// ROR Label 208
if((pOp > aOp) != (pOp >= aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((pOp <= aOp) != (pOp >= aOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}

    
// ABS Label 199
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}
sqlite3DbFreeNN(db, aOp);
  }
}

/*
** Link the SubProgram object passed as the second argument into the linked
** list at Vdbe.pSubProgram. This list is used to delete all sub-program
** objects when the VM is no longer required.
*/
void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){
  p->pNext = pVdbe->pProgram;
  pVdbe->pProgram = p;
}

/*
** Return true if the given Vdbe has any SubPrograms.
*/
int sqlite3VdbeHasSubProgram(Vdbe *pVdbe){
  
// ABS Label 215
if(pVdbe->pProgram < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}

// ROR Label 216
if((pVdbe->pProgram == 0) != (pVdbe->pProgram != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 216);
}
return pVdbe->pProgram!=0;
}

/*
** Change the opcode at addr into OP_Noop
*/
int sqlite3VdbeChangeToNoop(Vdbe *p, int addr){
  VdbeOp *pOp;
  
// ABS Label 219
if(p->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
if( p->db->mallocFailed ) { return 0;
}
  assert( addr>=0 && addr<p->nOp );
  pOp = &p->aOp[addr];
  
// ABS Label 217
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}

// ABS Label 218
if(pOp->p4.p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}
freeP4(p->db, pOp->p4type, pOp->p4.p);
  pOp->p4type = P4_NOTUSED;
  pOp->p4.z = 0;
  pOp->opcode = OP_Noop;
  return 1;
}

/*
** If the last opcode is "op" and it is not a jump destination,
** then remove it.  Return true if and only if an opcode was removed.
*/
int sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){
  
// ABS Label 220
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}

// COR Label 221
if((p->nOp > 0 || p->aOp[p->nOp - 1].opcode == op) != (p->nOp > 0 && p->aOp[p->nOp - 1].opcode == op))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 221);
}

// ROR Label 222
if((p->nOp <= 0) != (p->nOp > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
// ROR Label 223
if((p->nOp < 0) != (p->nOp > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
// ROR Label 224
if((p->nOp >= 0) != (p->nOp > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 224);
}
// ROR Label 225
if((p->aOp[p->nOp - 1].opcode != op) != (p->aOp[p->nOp - 1].opcode == op))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 225);
}

// MCC Label 226
if(p->nOp > 0 && p->aOp[p->nOp - 1].opcode == op ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(p->nOp > 0 && !(p->aOp[p->nOp - 1].opcode == op) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(!(p->nOp > 0) && p->aOp[p->nOp - 1].opcode == op ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(!(p->nOp > 0) && !(p->aOp[p->nOp - 1].opcode == op) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
if( p->nOp>0 && p->aOp[p->nOp-1].opcode==op ){
    return sqlite3VdbeChangeToNoop(p, p->nOp-1);
  }else{
    return 0;
  }
}

#ifdef SQLITE_DEBUG
/*
** Generate an OP_ReleaseReg opcode to indicate that a range of
** registers, except any identified by mask, are no longer in use.
*/
void sqlite3VdbeReleaseRegisters(
  Parse *pParse,       /* Parsing context */
  int iFirst,          /* Index of first register to be released */
  int N,               /* Number of registers to release */
  u32 mask,            /* Mask of registers to NOT release */
  int bUndefine        /* If true, mark registers as undefined */
){
  if( N==0 ) return;
  assert( pParse->pVdbe );
  assert( iFirst>=1 );
  assert( iFirst+N-1<=pParse->nMem );
  if( N<=31 && mask!=0 ){
    while( N>0 && (mask&1)!=0 ){
      mask >>= 1;
      iFirst++;
      N--;
    }
    while( N>0 && N<=32 && (mask & MASKBIT32(N-1))!=0 ){
      mask &= ~MASKBIT32(N-1);
      N--;
    }
  }
  if( N>0 ){
    sqlite3VdbeAddOp3(pParse->pVdbe, OP_ReleaseReg, iFirst, N, *(int*)&mask);
    if( bUndefine ) sqlite3VdbeChangeP5(pParse->pVdbe, 1);
  }
}
#endif /* SQLITE_DEBUG */


/*
** Change the value of the P4 operand for a specific instruction.
** This routine is useful when a large program is loaded from a
** static array using sqlite3VdbeAddOpList but we want to make a
** few minor changes to the program.
**
** If n>=0 then the P4 operand is dynamic, meaning that a copy of
** the string is made into memory obtained from sqlite3_malloc().
** A value of n==0 means copy bytes of zP4 up to and including the
** first null byte.  If n>0 then copy n+1 bytes of zP4.
** 
** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points
** to a string or structure that is guaranteed to exist for the lifetime of
** the Vdbe. In these cases we can just copy the pointer.
**
** If addr<0 then change P4 on the most recently inserted instruction.
*/
static void SQLITE_NOINLINE vdbeChangeP4Full(
  Vdbe *p,
  Op *pOp,
  const char *zP4,
  int n
){
  
// ABS Label 230
if(pOp->p4type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}
if( pOp->p4type ){
    
// ABS Label 231
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ABS Label 232
if(pOp->p4.p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}
freeP4(p->db, pOp->p4type, pOp->p4.p);
    pOp->p4type = 0;
    pOp->p4.p = 0;
  }
  
// ABS Label 233
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}

// ROR Label 234
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}
// ROR Label 235
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
// ROR Label 236
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
if( n<0 ){
    
// ABS Label 237
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}

// ABS Label 238
if(zP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ABS Label 239
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}
sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);
  }else{
    
// ABS Label 240
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ROR Label 241
if((n != 0) != (n == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
if( n==0 ) { n = sqlite3Strlen30(zP4);
}
    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);
    pOp->p4type = P4_DYNAMIC;
  }
}
void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){
  Op *pOp;
  sqlite3 *db;
  assert( p!=0 );
  db = p->db;
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
  assert( p->aOp!=0 || db->mallocFailed );
  
// ABS Label 242
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}
if( db->mallocFailed ){
    
// ABS Label 243
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}

// ROR Label 244
if((n == (-12)) != (n != (-12)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}
if( n!=P4_VTAB ) { 
// ABS Label 245
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}

// ABS Label 246
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}
freeP4(db, n, (void*)*(char**)&zP4);
}
    return;
  }
  assert( p->nOp>0 );
  assert( addr<p->nOp );
  
// ABS Label 247
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}

// ROR Label 248
if((addr <= 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 248);
}
// ROR Label 249
if((addr > 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 249);
}
// ROR Label 250
if((addr >= 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
if( addr<0 ){
    addr = p->nOp - 1;
  }
  pOp = &p->aOp[addr];
  
// ABS Label 251
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// COR Label 252
if((n >= 0 && pOp->p4type) != (n >= 0 || pOp->p4type))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 252);
}

// ROR Label 253
if((n < 0) != (n >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
// ROR Label 254
if((n > 0) != (n >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
// ROR Label 255
if((n <= 0) != (n >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 255);
}

// MCC Label 256
if(n >= 0 && pOp->p4type ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 256);
}
// MCC Label 257
if(n >= 0 && !(pOp->p4type) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 257);
}
// MCC Label 258
if(!(n >= 0) && pOp->p4type ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 258);
}
// MCC Label 259
if(!(n >= 0) && !(pOp->p4type) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 259);
}
if( n>=0 || pOp->p4type ){
    
// ABS Label 260
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}

// ABS Label 261
if(pOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}

// ABS Label 262
if(zP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}

// ABS Label 263
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}
vdbeChangeP4Full(p, pOp, zP4, n);
    return;
  }
  
// ABS Label 264
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}

// ROR Label 265
if((n != (-3)) != (n == (-3)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
if( n==P4_INT32 ){
    /* Note: this cast is safe, because the origin data point was an int
    ** that was cast to a (const char *). */
    pOp->p4.i = SQLITE_PTR_TO_INT(zP4);
    pOp->p4type = P4_INT32;
  }else { 
// ABS Label 266
if(zP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}

// ROR Label 267
if((zP4 == 0) != (zP4 != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
if( zP4!=0 ){
    assert( n<0 );
    pOp->p4.p = (void*)zP4;
    pOp->p4type = (signed char)n;
    
// ABS Label 268
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}

// ROR Label 269
if((n != (-12)) != (n == (-12)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}
if( n==P4_VTAB ) { sqlite3VtabLock((VTable*)zP4);
}
  };}

}

/*
** Change the P4 operand of the most recently coded instruction 
** to the value defined by the arguments.  This is a high-speed
** version of sqlite3VdbeChangeP4().
**
** The P4 operand must not have been previously defined.  And the new
** P4 must not be P4_INT32.  Use sqlite3VdbeChangeP4() in either of
** those cases.
*/
void sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){
  VdbeOp *pOp;
  assert( n!=P4_INT32 && n!=P4_VTAB );
  assert( n<=0 );
  
// ABS Label 270
if(p->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
if( p->db->mallocFailed ){
    
// ABS Label 271
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}

// ABS Label 272
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}

// ABS Label 273
if(pP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}
freeP4(p->db, n, pP4);
  }else{
    assert( pP4!=0 );
    assert( p->nOp>0 );
    pOp = &p->aOp[p->nOp-1];
    assert( pOp->p4type==P4_NOTUSED );
    pOp->p4type = n;
    pOp->p4.p = pP4;
  }
}

/*
** Set the P4 on the most recently added opcode to the KeyInfo for the
** index given.
*/
void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){
  
// ABS Label 274
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
Vdbe *v = pParse->pVdbe;
  KeyInfo *pKeyInfo;
  assert( v!=0 );
  assert( pIdx!=0 );
  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
  
// ABS Label 275
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
if( pKeyInfo ) { 
// ABS Label 276
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);
}
}

#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
/*
** Change the comment on the most recently coded instruction.  Or
** insert a No-op and add the comment to that new instruction.  This
** makes the code easier to read during debugging.  None of this happens
** in a production build.
*/
static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){
  assert( p->nOp>0 || p->aOp==0 );
  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed
          || p->pParse->nErr>0 );
  if( p->nOp ){
    assert( p->aOp );
    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);
    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);
  }
}
void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){
  va_list ap;
  if( p ){
    va_start(ap, zFormat);
    vdbeVComment(p, zFormat, ap);
    va_end(ap);
  }
}
void sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){
  va_list ap;
  if( p ){
    sqlite3VdbeAddOp0(p, OP_Noop);
    va_start(ap, zFormat);
    vdbeVComment(p, zFormat, ap);
    va_end(ap);
  }
}
#endif  /* NDEBUG */

#ifdef SQLITE_VDBE_COVERAGE
/*
** Set the value if the iSrcLine field for the previously coded instruction.
*/
void sqlite3VdbeSetLineNumber(Vdbe *v, int iLine){
  sqlite3VdbeGetOp(v,-1)->iSrcLine = iLine;
}
#endif /* SQLITE_VDBE_COVERAGE */

/*
** Return the opcode for a given address.  If the address is -1, then
** return the most recently inserted opcode.
**
** If a memory allocation error has occurred prior to the calling of this
** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode
** is readable but not writable, though it is cast to a writable value.
** The return of a dummy opcode allows the call to continue functioning
** after an OOM fault without having to check to see if the return from 
** this routine is a valid pointer.  But because the dummy.opcode is 0,
** dummy will never be written to.  This is verified by code inspection and
** by running with Valgrind.
*/
VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){
  /* C89 specifies that the constant "dummy" will be initialized to all
  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */
  static VdbeOp dummy;  /* Ignore the MSVC warning about no initializer */
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
  
// ABS Label 277
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}

// ROR Label 278
if((addr <= 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 278);
}
// ROR Label 279
if((addr > 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((addr >= 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
if( addr<0 ){
    addr = p->nOp - 1;
  }
  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );
  
// ABS Label 281
if(p->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}
if( p->db->mallocFailed ){
    return (VdbeOp*)&dummy;
  }else{
    return &p->aOp[addr];
  }
}

#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)
/*
** Return an integer value for one of the parameters to the opcode pOp
** determined by character c.
*/
static int translateP(char c, const Op *pOp){
  if( c=='1' ) return pOp->p1;
  if( c=='2' ) return pOp->p2;
  if( c=='3' ) return pOp->p3;
  if( c=='4' ) return pOp->p4.i;
  return pOp->p5;
}

/*
** Compute a string for the "comment" field of a VDBE opcode listing.
**
** The Synopsis: field in comments in the vdbe.c source file gets converted
** to an extra string that is appended to the sqlite3OpcodeName().  In the
** absence of other comments, this synopsis becomes the comment on the opcode.
** Some translation occurs:
**
**       "PX"      ->  "r[X]"
**       "PX@PY"   ->  "r[X..X+Y-1]"  or "r[x]" if y is 0 or 1
**       "PX@PY+1" ->  "r[X..X+Y]"    or "r[x]" if y is 0
**       "PY..PY"  ->  "r[X..Y]"      or "r[x]" if y<=x
*/
char *sqlite3VdbeDisplayComment(
  sqlite3 *db,       /* Optional - Oom error reporting only */
  const Op *pOp,     /* The opcode to be commented */
  const char *zP4    /* Previously obtained value for P4 */
){
  const char *zOpName;
  const char *zSynopsis;
  int nOpName;
  int ii;
  char zAlt[50];
  StrAccum x;

  sqlite3StrAccumInit(&x, 0, 0, 0, SQLITE_MAX_LENGTH);
  zOpName = sqlite3OpcodeName(pOp->opcode);
  nOpName = sqlite3Strlen30(zOpName);
  if( zOpName[nOpName+1] ){
    int seenCom = 0;
    char c;
    zSynopsis = zOpName += nOpName + 1;
    if( strncmp(zSynopsis,"IF ",3)==0 ){
      sqlite3_snprintf(sizeof(zAlt), zAlt, "if %s goto P2", zSynopsis+3);
      zSynopsis = zAlt;
    }
    for(ii=0; (c = zSynopsis[ii])!=0; ii++){
      if( c=='P' ){
        c = zSynopsis[++ii];
        if( c=='4' ){
          sqlite3_str_appendall(&x, zP4);
        }else if( c=='X' ){
          sqlite3_str_appendall(&x, pOp->zComment);
          seenCom = 1;
        }else{
          int v1 = translateP(c, pOp);
          int v2;
          if( strncmp(zSynopsis+ii+1, "@P", 2)==0 ){
            ii += 3;
            v2 = translateP(zSynopsis[ii], pOp);
            if( strncmp(zSynopsis+ii+1,"+1",2)==0 ){
              ii += 2;
              v2++;
            }
            if( v2<2 ){
              sqlite3_str_appendf(&x, "%d", v1);
            }else{
              sqlite3_str_appendf(&x, "%d..%d", v1, v1+v2-1);
            }
          }else if( strncmp(zSynopsis+ii+1, "@NP", 3)==0 ){
            sqlite3_context *pCtx = pOp->p4.pCtx;
            if( pOp->p4type!=P4_FUNCCTX || pCtx->argc==1 ){
              sqlite3_str_appendf(&x, "%d", v1);
            }else if( pCtx->argc>1 ){
              sqlite3_str_appendf(&x, "%d..%d", v1, v1+pCtx->argc-1);
            }else if( x.accError==0 ){
              assert( x.nChar>2 );
              x.nChar -= 2;
              ii++;
            }
            ii += 3;
          }else{
            sqlite3_str_appendf(&x, "%d", v1);
            if( strncmp(zSynopsis+ii+1, "..P3", 4)==0 && pOp->p3==0 ){
              ii += 4;
            }
          }
        }
      }else{
        sqlite3_str_appendchar(&x, 1, c);
      }
    }
    if( !seenCom && pOp->zComment ){
      sqlite3_str_appendf(&x, "; %s", pOp->zComment);
    }
  }else if( pOp->zComment ){
    sqlite3_str_appendall(&x, pOp->zComment);
  }
  if( (x.accError & SQLITE_NOMEM)!=0 && db!=0 ){
    sqlite3OomFault(db);
  }
  return sqlite3StrAccumFinish(&x);
}
#endif /* SQLITE_ENABLE_EXPLAIN_COMMENTS */

#if VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS)
/*
** Translate the P4.pExpr value for an OP_CursorHint opcode into text
** that can be displayed in the P4 column of EXPLAIN output.
*/
static void displayP4Expr(StrAccum *p, Expr *pExpr){
  const char *zOp = 0;
  switch( pExpr->op ){
    case TK_STRING:
      sqlite3_str_appendf(p, "%Q", pExpr->u.zToken);
      break;
    case TK_INTEGER:
      sqlite3_str_appendf(p, "%d", pExpr->u.iValue);
      break;
    case TK_NULL:
      sqlite3_str_appendf(p, "NULL");
      break;
    case TK_REGISTER: {
      sqlite3_str_appendf(p, "r[%d]", pExpr->iTable);
      break;
    }
    case TK_COLUMN: {
      if( pExpr->iColumn<0 ){
        sqlite3_str_appendf(p, "rowid");
      }else{
        sqlite3_str_appendf(p, "c%d", (int)pExpr->iColumn);
      }
      break;
    }
    case TK_LT:      zOp = "LT";      break;
    case TK_LE:      zOp = "LE";      break;
    case TK_GT:      zOp = "GT";      break;
    case TK_GE:      zOp = "GE";      break;
    case TK_NE:      zOp = "NE";      break;
    case TK_EQ:      zOp = "EQ";      break;
    case TK_IS:      zOp = "IS";      break;
    case TK_ISNOT:   zOp = "ISNOT";   break;
    case TK_AND:     zOp = "AND";     break;
    case TK_OR:      zOp = "OR";      break;
    case TK_PLUS:    zOp = "ADD";     break;
    case TK_STAR:    zOp = "MUL";     break;
    case TK_MINUS:   zOp = "SUB";     break;
    case TK_REM:     zOp = "REM";     break;
    case TK_BITAND:  zOp = "BITAND";  break;
    case TK_BITOR:   zOp = "BITOR";   break;
    case TK_SLASH:   zOp = "DIV";     break;
    case TK_LSHIFT:  zOp = "LSHIFT";  break;
    case TK_RSHIFT:  zOp = "RSHIFT";  break;
    case TK_CONCAT:  zOp = "CONCAT";  break;
    case TK_UMINUS:  zOp = "MINUS";   break;
    case TK_UPLUS:   zOp = "PLUS";    break;
    case TK_BITNOT:  zOp = "BITNOT";  break;
    case TK_NOT:     zOp = "NOT";     break;
    case TK_ISNULL:  zOp = "ISNULL";  break;
    case TK_NOTNULL: zOp = "NOTNULL"; break;

    default:
      sqlite3_str_appendf(p, "%s", "expr");
      break;
  }

  if( zOp ){
    sqlite3_str_appendf(p, "%s(", zOp);
    displayP4Expr(p, pExpr->pLeft);
    if( pExpr->pRight ){
      sqlite3_str_append(p, ",", 1);
      displayP4Expr(p, pExpr->pRight);
    }
    sqlite3_str_append(p, ")", 1);
  }
}
#endif /* VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS) */


#if VDBE_DISPLAY_P4
/*
** Compute a string that describes the P4 parameter for an opcode.
** Use zTemp for any required temporary buffer space.
*/
char *sqlite3VdbeDisplayP4(sqlite3 *db, Op *pOp){
  char *zP4 = 0;
  StrAccum x;

  sqlite3StrAccumInit(&x, 0, 0, 0, SQLITE_MAX_LENGTH);
  switch( pOp->p4type ){
    case P4_KEYINFO: {
      int j;
      
// ABS Label 282
if(pOp->p4.pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
      assert( pKeyInfo->aSortFlags!=0 );
      sqlite3_str_appendf(&x, "k(%d", pKeyInfo->nKeyField);
      j = 0;

// ABS Label 283
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((j <= pKeyInfo->nKeyField) != (j < pKeyInfo->nKeyField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
// ROR Label 285
if((j > pKeyInfo->nKeyField) != (j < pKeyInfo->nKeyField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 285);
}
// ROR Label 286
if((j >= pKeyInfo->nKeyField) != (j < pKeyInfo->nKeyField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
for(; j<pKeyInfo->nKeyField; j++){
        
// ABS Label 291
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}
// ABS Label 292
if(pKeyInfo->aColl[j] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
CollSeq *pColl = pKeyInfo->aColl[j];
        const char *zColl = pColl ? pColl->zName : "";
        if( strcmp(zColl, "BINARY")==0 ) { zColl = "B";
}
        
// ABS Label 293
if(zColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
sqlite3_str_appendf(&x, ",%s%s%s", 
               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_DESC) ? "-" : "", 
               (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_BIGNULL)? "N." : "", 
               zColl);
      };
// ABS Label 287
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}

// ROR Label 288
if((j <= pKeyInfo->nKeyField) != (j < pKeyInfo->nKeyField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
// ROR Label 289
if((j > pKeyInfo->nKeyField) != (j < pKeyInfo->nKeyField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}
// ROR Label 290
if((j >= pKeyInfo->nKeyField) != (j < pKeyInfo->nKeyField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 290);
}

      sqlite3_str_append(&x, ")", 1);
      break;
    }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
    case P4_EXPR: {
      displayP4Expr(&x, pOp->p4.pExpr);
      break;
    }
#endif
    case P4_COLLSEQ: {
      static const char *const encnames[] = {"?", "8", "16LE", "16BE"};
      
// ABS Label 294
if(pOp->p4.pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
CollSeq *pColl = pOp->p4.pColl;
      assert( pColl->enc>=0 && pColl->enc<4 );
      
// ABS Label 295
if(pColl->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if(encnames[pColl->enc] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
// ABS Label 297
if(pColl->enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
sqlite3_str_appendf(&x, "%.18s-%s", pColl->zName,
                          encnames[pColl->enc]);
      break;
    }
    case P4_FUNCDEF: {
      
// ABS Label 298
if(pOp->p4.pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
FuncDef *pDef = pOp->p4.pFunc;
      
// ABS Label 299
if(pDef->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }
    case P4_FUNCCTX: {
      
// ABS Label 300
if(pOp->p4.pCtx->pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
FuncDef *pDef = pOp->p4.pCtx->pFunc;
      
// ABS Label 301
if(pDef->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}
sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }
    case P4_INT64: {
      
// ABS Label 302
if(*pOp->p4.pI64 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
sqlite3_str_appendf(&x, "%lld", *pOp->p4.pI64);
      break;
    }
    case P4_INT32: {
      
// ABS Label 303
if(pOp->p4.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
sqlite3_str_appendf(&x, "%d", pOp->p4.i);
      break;
    }
    case P4_REAL: {
      
// ABS Label 304
if(*pOp->p4.pReal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
sqlite3_str_appendf(&x, "%.16g", *pOp->p4.pReal);
      break;
    }
    case P4_MEM: {
      
// ABS Label 305
if(pOp->p4.pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
Mem *pMem = pOp->p4.pMem;
      
// AOR Label 306
if(pMem->flags | 2 != pMem->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 306);
}
// AOR Label 307
if(pMem->flags ^ 2 != pMem->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 307);
}
if( pMem->flags & MEM_Str ){
        zP4 = pMem->z;
      }else { 
// AOR Label 308
if(pMem->flags | (4 | 32) != pMem->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 308);
}
// AOR Label 309
if(pMem->flags ^ (4 | 32) != pMem->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 309);
}
if( pMem->flags & (MEM_Int|MEM_IntReal) ){
        
// ABS Label 310
if(pMem->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}
sqlite3_str_appendf(&x, "%lld", pMem->u.i);
      }else { 
// AOR Label 311
if(pMem->flags | 8 != pMem->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 311);
}
// AOR Label 312
if(pMem->flags ^ 8 != pMem->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 312);
}
if( pMem->flags & MEM_Real ){
        
// ABS Label 313
if(pMem->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
sqlite3_str_appendf(&x, "%.16g", pMem->u.r);
      }else { 
// AOR Label 314
if(pMem->flags | 1 != pMem->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 314);
}
// AOR Label 315
if(pMem->flags ^ 1 != pMem->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 315);
}
if( pMem->flags & MEM_Null ){
        zP4 = "NULL";
      }else{
        assert( pMem->flags & MEM_Blob );
        zP4 = "(blob)";
      };}
;}
;}

      break;
    }
#ifndef SQLITE_OMIT_VIRTUALTABLE
    case P4_VTAB: {
      
// ABS Label 316
if(pOp->p4.pVtab->pVtab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;
      
// ABS Label 317
if(pVtab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
sqlite3_str_appendf(&x, "vtab:%p", pVtab);
      break;
    }
#endif
    case P4_INTARRAY: {
      u32 i;
      
// ABS Label 318
if(pOp->p4.ai < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
u32 *ai = pOp->p4.ai;
      
// ABS Label 319
if(ai[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
u32 n = ai[0];   /* The first element of an INTARRAY is always the
                       ** count of the number of elements to follow */
      i = 1;

// ABS Label 320
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
// ABS Label 321
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}

// ROR Label 322
if((i < n) != (i <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}
// ROR Label 323
if((i > n) != (i <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 323);
}
// ROR Label 324
if((i >= n) != (i <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 324);
}
for(; i<=n; i++){
        
// ABS Label 330
if(ai[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
// ABS Label 331
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
sqlite3_str_appendf(&x, "%c%u", (i==1 ? '[' : ','), ai[i]);
      };
// ABS Label 325
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
// ABS Label 326
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ROR Label 327
if((i < n) != (i <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
// ROR Label 328
if((i > n) != (i <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 328);
}
// ROR Label 329
if((i >= n) != (i <= n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 329);
}

      sqlite3_str_append(&x, "]", 1);
      break;
    }
    case P4_SUBPROGRAM: {
      zP4 = "program";
      break;
    }
    case P4_DYNBLOB:
    case P4_ADVANCE: {
      break;
    }
    case P4_TABLE: {
      zP4 = pOp->p4.pTab->zName;
      break;
    }
    default: {
      zP4 = pOp->p4.z;
    }
  }
  
// ABS Label 332
if(zP4 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}
if( zP4 ) { sqlite3_str_appendall(&x, zP4);
}
  
// ROR Label 333
if(((x.accError & 7) == 0) != ((x.accError & 7) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 333);
}
if( (x.accError & SQLITE_NOMEM)!=0 ){
    
// ABS Label 334
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
sqlite3OomFault(db);
  }
  return sqlite3StrAccumFinish(&x);
}
#endif /* VDBE_DISPLAY_P4 */

/*
** Declare to the Vdbe that the BTree object at db->aDb[i] is used.
**
** The prepared statements need to know in advance the complete set of
** attached databases that will be use.  A mask of these databases
** is maintained in p->btreeMask.  The p->lockMask value is the subset of
** p->btreeMask of databases that will require a lock.
*/
void sqlite3VdbeUsesBtree(Vdbe *p, int i){
  assert( i>=0 && i<p->db->nDb && i<(int)sizeof(yDbMask)*8 );
  assert( i<(int)sizeof(p->btreeMask)*8 );
  DbMaskSet(p->btreeMask, i);
  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){
    DbMaskSet(p->lockMask, i);
  }
}

#if !defined(SQLITE_OMIT_SHARED_CACHE)
/*
** If SQLite is compiled to support shared-cache mode and to be threadsafe,
** this routine obtains the mutex associated with each BtShared structure
** that may be accessed by the VM passed as an argument. In doing so it also
** sets the BtShared.db member of each of the BtShared structures, ensuring
** that the correct busy-handler callback is invoked if required.
**
** If SQLite is not threadsafe but does support shared-cache mode, then
** sqlite3BtreeEnter() is invoked to set the BtShared.db variables
** of all of BtShared structures accessible via the database handle 
** associated with the VM.
**
** If SQLite is not threadsafe and does not support shared-cache mode, this
** function is a no-op.
**
** The p->btreeMask field is a bitmask of all btrees that the prepared 
** statement p will ever use.  Let N be the number of bits in p->btreeMask
** corresponding to btrees that use shared cache.  Then the runtime of
** this routine is N*N.  But as N is rarely more than 1, this should not
** be a problem.
*/
void sqlite3VdbeEnter(Vdbe *p){
  int i;
  sqlite3 *db;
  Db *aDb;
  int nDb;
  
// ABS Label 335
if((p->lockMask) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}

// ROR Label 336
if(((p->lockMask) != 0) != ((p->lockMask) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}
if( DbMaskAllZero(p->lockMask) ) { return;  /* The common case */
}
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  i = 0;

// ABS Label 337
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
// ABS Label 338
if(nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}

// ROR Label 339
if((i <= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
// ROR Label 340
if((i > nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 340);
}
// ROR Label 341
if((i >= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 341);
}
for(; i<nDb; i++){
    
// ABS Label 347
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}

// COR Label 348
if((i != 1 && (((p->lockMask) & (((yDbMask)1) << (i))) != 0) || (aDb[i].pBt != 0)) != (i != 1 && (((p->lockMask) & (((yDbMask)1) << (i))) != 0) && (aDb[i].pBt != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 348);
}
// COR Label 349
if((i != 1 || (((p->lockMask) & (((yDbMask)1) << (i))) != 0)) != (i != 1 && (((p->lockMask) & (((yDbMask)1) << (i))) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 349);
}

// ROR Label 350
if((i == 1) != (i != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 350);
}

// MCC Label 351
if(i != 1 && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
// MCC Label 352
if(i != 1 && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 352);
}
// MCC Label 353
if(i != 1 && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 353);
}
// MCC Label 354
if(i != 1 && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 354);
}
// MCC Label 355
if(!(i != 1) && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 355);
}
// MCC Label 356
if(!(i != 1) && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 356);
}
// MCC Label 357
if(!(i != 1) && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 357);
}
// MCC Label 358
if(!(i != 1) && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 358);
}
if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){
      
// ABS Label 359
if(aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}
sqlite3BtreeEnter(aDb[i].pBt);
    }
  };
// ABS Label 342
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}
// ABS Label 343
if(nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}

// ROR Label 344
if((i <= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
// ROR Label 345
if((i > nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 345);
}
// ROR Label 346
if((i >= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 346);
}

}
#endif

#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0
/*
** Unlock all of the btrees previously locked by a call to sqlite3VdbeEnter().
*/
static SQLITE_NOINLINE void vdbeLeave(Vdbe *p){
  int i;
  sqlite3 *db;
  Db *aDb;
  int nDb;
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  i = 0;

// ABS Label 360
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}
// ABS Label 361
if(nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}

// ROR Label 362
if((i <= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}
// ROR Label 363
if((i > nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}
// ROR Label 364
if((i >= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}
for(; i<nDb; i++){
    
// ABS Label 370
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}

// COR Label 371
if((i != 1 && (((p->lockMask) & (((yDbMask)1) << (i))) != 0) || (aDb[i].pBt != 0)) != (i != 1 && (((p->lockMask) & (((yDbMask)1) << (i))) != 0) && (aDb[i].pBt != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 371);
}
// COR Label 372
if((i != 1 || (((p->lockMask) & (((yDbMask)1) << (i))) != 0)) != (i != 1 && (((p->lockMask) & (((yDbMask)1) << (i))) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 372);
}

// ROR Label 373
if((i == 1) != (i != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 373);
}

// MCC Label 374
if(i != 1 && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 374);
}
// MCC Label 375
if(i != 1 && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 375);
}
// MCC Label 376
if(i != 1 && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 376);
}
// MCC Label 377
if(i != 1 && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 377);
}
// MCC Label 378
if(!(i != 1) && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 378);
}
// MCC Label 379
if(!(i != 1) && ( ((p->lockMask) & (((yDbMask)1) << (i))) != 0 ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(!(i != 1) && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( aDb[i].pBt != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(!(i != 1) && ( !(((p->lockMask) & (((yDbMask)1) << (i))) != 0) ) && ( !(aDb[i].pBt != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){
      
// ABS Label 382
if(aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}
sqlite3BtreeLeave(aDb[i].pBt);
    }
  };
// ABS Label 365
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
// ABS Label 366
if(nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}

// ROR Label 367
if((i <= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}
// ROR Label 368
if((i > nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}
// ROR Label 369
if((i >= nDb) != (i < nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}

}
void sqlite3VdbeLeave(Vdbe *p){
  
// ABS Label 384
if((p->lockMask) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}

// ROR Label 385
if(((p->lockMask) != 0) != ((p->lockMask) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 385);
}
if( DbMaskAllZero(p->lockMask) ) { return;  /* The common case */
}
  
// ABS Label 383
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}
vdbeLeave(p);
}
#endif

#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)
/*
** Print a single opcode.  This routine is used for debugging only.
*/
void sqlite3VdbePrintOp(FILE *pOut, int pc, VdbeOp *pOp){
  char *zP4;
  char *zCom;
  sqlite3 dummyDb;
  static const char *zFormat1 = "%4d %-13s %4d %4d %4d %-13s %.2X %s\n";
  if( pOut==0 ) pOut = stdout;
  sqlite3BeginBenignMalloc();
  dummyDb.mallocFailed = 1;
  zP4 = sqlite3VdbeDisplayP4(&dummyDb, pOp);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
  zCom = sqlite3VdbeDisplayComment(0, pOp, zP4);
#else
  zCom = 0;
#endif
  /* NB:  The sqlite3OpcodeName() function is implemented by code created
  ** by the mkopcodeh.awk and mkopcodec.awk scripts which extract the
  ** information from the vdbe.c source text */
  fprintf(pOut, zFormat1, pc, 
      sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, 
      zP4 ? zP4 : "", pOp->p5,
      zCom ? zCom : ""
  );
  fflush(pOut);
  sqlite3_free(zP4);
  sqlite3_free(zCom);
  sqlite3EndBenignMalloc();
}
#endif

/*
** Initialize an array of N Mem element.
*/
static void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){
  while( (N--)>0 ){
    p->db = db;
    p->flags = flags;
    p->szMalloc = 0;
#ifdef SQLITE_DEBUG
    p->pScopyFrom = 0;
#endif
    p++;
  };
}

/*
** Release an array of N Mem elements
*/
static void releaseMemArray(Mem *p, int N){
  
// ABS Label 386
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
// ABS Label 387
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// COR Label 388
if((p || N) != (p && N))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 388);
}

// MCC Label 389
if(p && N ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 389);
}
// MCC Label 390
if(p && !(N) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 390);
}
// MCC Label 391
if(!(p) && N ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 391);
}
// MCC Label 392
if(!(p) && !(N) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
if( p && N ){
    Mem *pEnd = &p[N];
    
// ABS Label 393
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}
sqlite3 *db = p->db;
    
// ABS Label 394
if(db->pnBytesFreed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}
if( db->pnBytesFreed ){
      do{
        
// ABS Label 395
if(p->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 395);
}
if( p->szMalloc ) { 
// ABS Label 396
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}
sqlite3DbFree(db, p->zMalloc);
}
      }while( (++p)<pEnd );;
      return;
    }
    do{
      assert( (&p[1])==pEnd || p[0].db==p[1].db );
      assert( sqlite3VdbeCheckMemInvariants(p) );

      /* This block is really an inlined version of sqlite3VdbeMemRelease()
      ** that takes advantage of the fact that the memory cell value is 
      ** being set to NULL after releasing any dynamic resources.
      **
      ** The justification for duplicating code is that according to 
      ** callgrind, this causes a certain test case to hit the CPU 4.7 
      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if 
      ** sqlite3MemRelease() were called from here. With -O2, this jumps
      ** to 6.6 percent. The test case is inserting 1000 rows into a table 
      ** with no indexes using a single prepared INSERT statement, bind() 
      ** and reset(). Inserts are grouped into a transaction.
      */
      testcase( p->flags & MEM_Agg );
      testcase( p->flags & MEM_Dyn );
      testcase( p->xDel==sqlite3VdbeFrameMemDel );
      
// AOR Label 397
if(p->flags | (8192 | 1024) != p->flags & (8192 | 1024))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 397);
}
// AOR Label 398
if(p->flags ^ (8192 | 1024) != p->flags & (8192 | 1024))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 398);
}
if( p->flags&(MEM_Agg|MEM_Dyn) ){
        
// ABS Label 399
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}
sqlite3VdbeMemRelease(p);
      }else { 
// ABS Label 400
if(p->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
if( p->szMalloc ){
        
// ABS Label 401
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}
sqlite3DbFreeNN(db, p->zMalloc);
        p->szMalloc = 0;
      };}


      p->flags = MEM_Undefined;
    }while( (++p)<pEnd );;
  }
}

#ifdef SQLITE_DEBUG
/*
** Verify that pFrame is a valid VdbeFrame pointer.  Return true if it is
** and false if something is wrong.
**
** This routine is intended for use inside of assert() statements only.
*/
int sqlite3VdbeFrameIsValid(VdbeFrame *pFrame){
  if( pFrame->iFrameMagic!=SQLITE_FRAME_MAGIC ) return 0;
  return 1;
}
#endif


/*
** This is a destructor on a Mem object (which is really an sqlite3_value)
** that deletes the Frame object that is attached to it as a blob.
**
** This routine does not delete the Frame right away.  It merely adds the
** frame to a list of frames to be deleted when the Vdbe halts.
*/
void sqlite3VdbeFrameMemDel(void *pArg){
  VdbeFrame *pFrame = (VdbeFrame*)pArg;
  assert( sqlite3VdbeFrameIsValid(pFrame) );
  pFrame->pParent = pFrame->v->pDelFrame;
  pFrame->v->pDelFrame = pFrame;
}

#if defined(SQLITE_ENABLE_BYTECODE_VTAB) || !defined(SQLITE_OMIT_EXPLAIN)
/*
** Locate the next opcode to be displayed in EXPLAIN or EXPLAIN
** QUERY PLAN output.
**
** Return SQLITE_ROW on success.  Return SQLITE_DONE if there are no
** more opcodes to be displayed.
*/
int sqlite3VdbeNextOpcode(
  Vdbe *p,         /* The statement being explained */
  Mem *pSub,       /* Storage for keeping track of subprogram nesting */
  int eMode,       /* 0: normal.  1: EQP.  2:  TablesUsed */
  int *piPc,       /* IN/OUT: Current rowid.  Overwritten with next rowid */
  int *piAddr,     /* OUT: Write index into (*paOp)[] here */
  Op **paOp        /* OUT: Write the opcode array here */
){
  int nRow;                            /* Stop when row count reaches this */
  int nSub = 0;                        /* Number of sub-vdbes seen so far */
  SubProgram **apSub = 0;              /* Array of sub-vdbes */
  int i;                               /* Next instruction address */
  int rc = SQLITE_OK;                  /* Result code */
  Op *aOp = 0;                         /* Opcode array */
  int iPc;                             /* Rowid.  Copy of value in *piPc */

  /* When the number of output rows reaches nRow, that means the
  ** listing has finished and sqlite3_step() should return SQLITE_DONE.
  ** nRow is the sum of the number of rows in the main program, plus
  ** the sum of the number of rows in all trigger subprograms encountered
  ** so far.  The nRow value will increase as new trigger subprograms are
  ** encountered, but p->pc will eventually catch up to nRow.
  */
  nRow = p->nOp;
  
// ABS Label 402
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}

// ROR Label 403
if((pSub == 0) != (pSub != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
if( pSub!=0 ){
    
// AOR Label 404
if(pSub->flags | 16 != pSub->flags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 404);
}
// AOR Label 405
if(pSub->flags ^ 16 != pSub->flags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 405);
}
if( pSub->flags&MEM_Blob ){
      /* pSub is initiallly NULL.  It is initialized to a BLOB by
      ** the P4_SUBPROGRAM processing logic below */
      nSub = pSub->n/sizeof(Vdbe*);
      apSub = (SubProgram **)pSub->z;
    }
    i = 0;

// ABS Label 406
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
// ABS Label 407
if(nSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// ROR Label 408
if((i <= nSub) != (i < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}
// ROR Label 409
if((i > nSub) != (i < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 409);
}
// ROR Label 410
if((i >= nSub) != (i < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
for(; i<nSub; i++){
      nRow += apSub[i]->nOp;
    };
// ABS Label 411
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}
// ABS Label 412
if(nSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}

// ROR Label 413
if((i <= nSub) != (i < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 413);
}
// ROR Label 414
if((i > nSub) != (i < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 414);
}
// ROR Label 415
if((i >= nSub) != (i < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 415);
}

  }
  iPc = *piPc;
  while(1){  /* Loop exits via break */
    i = iPc++;
    
// ABS Label 416
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
// ABS Label 417
if(nRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}

// ROR Label 418
if((i < nRow) != (i >= nRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 418);
}
// ROR Label 419
if((i > nRow) != (i >= nRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}
// ROR Label 420
if((i <= nRow) != (i >= nRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
if( i>=nRow ){
      p->rc = SQLITE_OK;
      rc = SQLITE_DONE;
      break;
    }
    
// ABS Label 421
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}
// ABS Label 422
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}

// ROR Label 423
if((i <= p->nOp) != (i < p->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 423);
}
// ROR Label 424
if((i > p->nOp) != (i < p->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 424);
}
// ROR Label 425
if((i >= p->nOp) != (i < p->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
if( i<p->nOp ){
      /* The rowid is small enough that we are still in the
      ** main program. */
      aOp = p->aOp;
    }else{
      /* We are currently listing subprograms.  Figure out which one and
      ** pick up the appropriate opcode. */
      int j;
      i -= p->nOp;
      assert( apSub!=0 );
      assert( nSub>0 );
      j = 0;

// ABS Label 426
if(apSub[j]->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}
// ABS Label 427
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}

// ROR Label 428
if((i < apSub[j]->nOp) != (i >= apSub[j]->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 428);
}
// ROR Label 429
if((i > apSub[j]->nOp) != (i >= apSub[j]->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 429);
}
// ROR Label 430
if((i <= apSub[j]->nOp) != (i >= apSub[j]->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}
for(; i>=apSub[j]->nOp; j++){
        i -= apSub[j]->nOp;
        assert( i<apSub[j]->nOp || j+1<nSub );
      };
// ABS Label 431
if(apSub[j]->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
// ABS Label 432
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}

// ROR Label 433
if((i < apSub[j]->nOp) != (i >= apSub[j]->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 433);
}
// ROR Label 434
if((i > apSub[j]->nOp) != (i >= apSub[j]->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 434);
}
// ROR Label 435
if((i <= apSub[j]->nOp) != (i >= apSub[j]->nOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 435);
}

      aOp = apSub[j]->aOp;
    }

    /* When an OP_Program opcode is encounter (the only opcode that has
    ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms
    ** kept in p->aMem[9].z to hold the new program - assuming this subprogram
    ** has not already been seen.
    */
    
// ABS Label 436
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 436);
}

// COR Label 437
if((pSub != 0 || aOp[i].p4type == (-4)) != (pSub != 0 && aOp[i].p4type == (-4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 437);
}

// ROR Label 438
if((pSub == 0) != (pSub != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}
// ROR Label 439
if((aOp[i].p4type != (-4)) != (aOp[i].p4type == (-4)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 439);
}

// MCC Label 440
if(pSub != 0 && aOp[i].p4type == (-4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(pSub != 0 && !(aOp[i].p4type == (-4)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(!(pSub != 0) && aOp[i].p4type == (-4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(!(pSub != 0) && !(aOp[i].p4type == (-4)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}
if( pSub!=0 && aOp[i].p4type==P4_SUBPROGRAM ){
      int nByte = (nSub+1)*sizeof(SubProgram*);
      int j;
      j = 0;

// ABS Label 444
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
// ABS Label 445
if(nSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// ROR Label 446
if((j <= nSub) != (j < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 446);
}
// ROR Label 447
if((j > nSub) != (j < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((j >= nSub) != (j < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
for(; j<nSub; j++){
        
// ABS Label 454
if(aOp[i].p4.pProgram < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}
// ABS Label 455
if(apSub[j] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}
// ABS Label 456
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}

// ROR Label 457
if((apSub[j] != aOp[i].p4.pProgram) != (apSub[j] == aOp[i].p4.pProgram))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 457);
}
if( apSub[j]==aOp[i].p4.pProgram ) { break;
}
      };
// ABS Label 449
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}
// ABS Label 450
if(nSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}

// ROR Label 451
if((j <= nSub) != (j < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
// ROR Label 452
if((j > nSub) != (j < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 452);
}
// ROR Label 453
if((j >= nSub) != (j < nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}

      
// ABS Label 458
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
// ABS Label 459
if(nSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// ROR Label 460
if((j != nSub) != (j == nSub))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}
if( j==nSub ){
        p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);
        
// ABS Label 461
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 461);
}

// ROR Label 462
if((p->rc == 0) != (p->rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
if( p->rc!=SQLITE_OK ){
          rc = SQLITE_ERROR;
          break;
        }
        apSub = (SubProgram **)pSub->z;
        apSub[nSub++] = aOp[i].p4.pProgram;
        MemSetTypeFlag(pSub, MEM_Blob);
        pSub->n = nSub*sizeof(SubProgram*);
        nRow += aOp[i].p4.pProgram->nOp;
      }
    }
    
// ABS Label 463
if(eMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}

// ROR Label 464
if((eMode != 0) != (eMode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 464);
}
if( eMode==0 ) { break;
}
#ifdef SQLITE_ENABLE_BYTECODE_VTAB
    if( eMode==2 ){
      Op *pOp = aOp + i;
      if( pOp->opcode==OP_OpenRead ) break;
      if( pOp->opcode==OP_OpenWrite && (pOp->p5 & OPFLAG_P2ISREG)==0 ) break;
      if( pOp->opcode==OP_ReopenIdx ) break;      
    }else
#endif
    {
      assert( eMode==1 );
      
// ROR Label 465
if((aOp[i].opcode != 178) != (aOp[i].opcode == 178))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
if( aOp[i].opcode==OP_Explain ) { break;
}
      
// ABS Label 466
if(iPc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}

// COR Label 467
if((aOp[i].opcode == 62 || iPc > 1) != (aOp[i].opcode == 62 && iPc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 467);
}

// ROR Label 468
if((aOp[i].opcode != 62) != (aOp[i].opcode == 62))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 468);
}
// ROR Label 469
if((iPc <= 1) != (iPc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 469);
}
// ROR Label 470
if((iPc < 1) != (iPc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 470);
}
// ROR Label 471
if((iPc >= 1) != (iPc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 471);
}

// MCC Label 472
if(aOp[i].opcode == 62 && iPc > 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 472);
}
// MCC Label 473
if(aOp[i].opcode == 62 && !(iPc > 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 473);
}
// MCC Label 474
if(!(aOp[i].opcode == 62) && iPc > 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 474);
}
// MCC Label 475
if(!(aOp[i].opcode == 62) && !(iPc > 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 475);
}
if( aOp[i].opcode==OP_Init && iPc>1 ) { break;
}
    }
  };
  *piPc = iPc;
  *piAddr = i;
  *paOp = aOp;
  
// ABS Label 476
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}
return rc;
}
#endif /* SQLITE_ENABLE_BYTECODE_VTAB || !SQLITE_OMIT_EXPLAIN */


/*
** Delete a VdbeFrame object and its contents. VdbeFrame objects are
** allocated by the OP_Program opcode in sqlite3VdbeExec().
*/
void sqlite3VdbeFrameDelete(VdbeFrame *p){
  int i;
  Mem *aMem = VdbeFrameMem(p);
  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];
  assert( sqlite3VdbeFrameIsValid(p) );
  i = 0;

// ABS Label 481
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}
// ABS Label 482
if(p->nChildCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}

// ROR Label 483
if((i <= p->nChildCsr) != (i < p->nChildCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 483);
}
// ROR Label 484
if((i > p->nChildCsr) != (i < p->nChildCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 484);
}
// ROR Label 485
if((i >= p->nChildCsr) != (i < p->nChildCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 485);
}
for(; i<p->nChildCsr; i++){
    
// ABS Label 491
if(p->v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 491);
}

// ABS Label 492
if(apCsr[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}
// ABS Label 493
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}
sqlite3VdbeFreeCursor(p->v, apCsr[i]);
  };
// ABS Label 486
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
// ABS Label 487
if(p->nChildCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}

// ROR Label 488
if((i <= p->nChildCsr) != (i < p->nChildCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 488);
}
// ROR Label 489
if((i > p->nChildCsr) != (i < p->nChildCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 489);
}
// ROR Label 490
if((i >= p->nChildCsr) != (i < p->nChildCsr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 490);
}

  
// ABS Label 477
if(aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}

// ABS Label 478
if(p->nChildMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}
releaseMemArray(aMem, p->nChildMem);
  
// ABS Label 479
if(p->v->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}
sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);
  
// ABS Label 480
if(p->v->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}
sqlite3DbFree(p->v->db, p);
}

#ifndef SQLITE_OMIT_EXPLAIN
/*
** Give a listing of the program in the virtual machine.
**
** The interface is the same as sqlite3VdbeExec().  But instead of
** running the code, it invokes the callback once for each instruction.
** This feature is used to implement "EXPLAIN".
**
** When p->explain==1, each instruction is listed.  When
** p->explain==2, only OP_Explain instructions are listed and these
** are shown in a different format.  p->explain==2 is used to implement
** EXPLAIN QUERY PLAN.
** 2018-04-24:  In p->explain==2 mode, the OP_Init opcodes of triggers
** are also shown, so that the boundaries between the main program and
** each trigger are clear.
**
** When p->explain==1, first the main program is listed, then each of
** the trigger subprograms are listed one by one.
*/
int sqlite3VdbeList(
  Vdbe *p                   /* The VDBE */
){
  Mem *pSub = 0;                       /* Memory cell hold array of subprogs */
  
// ABS Label 494
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 494);
}
sqlite3 *db = p->db;                 /* The database connection */
  int i;                               /* Loop counter */
  int rc = SQLITE_OK;                  /* Return code */
  Mem *pMem = &p->aMem[1];             /* First Mem of result set */
  int bListSubprogs = (p->explain==1 || (db->flags & SQLITE_TriggerEQP)!=0);
  Op *aOp;                             /* Array of opcodes */
  Op *pOp;                             /* Current opcode */

  assert( p->explain );
  assert( p->iVdbeMagic==VDBE_MAGIC_RUN );
  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM );

  /* Even though this opcode does not use dynamic strings for
  ** the result, result columns may become dynamic if the user calls
  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.
  */
  
// ABS Label 495
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 495);
}
releaseMemArray(pMem, 8);
  p->pResultSet = 0;

  
// ABS Label 496
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 496);
}

// ROR Label 497
if((p->rc != 7) != (p->rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 497);
}
if( p->rc==SQLITE_NOMEM ){
    /* This happens if a malloc() inside a call to sqlite3_column_text() or
    ** sqlite3_column_text16() failed.  */
    
// ABS Label 498
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 498);
}
sqlite3OomFault(db);
    return SQLITE_ERROR;
  }

  
// ABS Label 499
if(bListSubprogs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 499);
}
if( bListSubprogs ){
    /* The first 8 memory cells are used for the result set.  So we will
    ** commandeer the 9th cell to use as storage for an array of pointers
    ** to trigger subprograms.  The VDBE is guaranteed to have at least 9
    ** cells.  */
    assert( p->nMem>9 );
    pSub = &p->aMem[9];
  }else{
    pSub = 0;
  }

  /* Figure out which opcode is next to display */
  rc = sqlite3VdbeNextOpcode(p, pSub, p->explain==2, &p->pc, &i, &aOp);

  
// ABS Label 500
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}

// ROR Label 501
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 501);
}
if( rc==SQLITE_OK ){
    pOp = aOp + i;
    if( AtomicLoad(&db->u1.isInterrupted) ){
      p->rc = SQLITE_INTERRUPT;
      rc = SQLITE_ERROR;
      
// ABS Label 502
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 502);
}
sqlite3VdbeError(p, sqlite3ErrStr(p->rc));
    }else{
      char *zP4 = sqlite3VdbeDisplayP4(db, pOp);
      
// ROR Label 503
if((p->explain != 2) != (p->explain == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 503);
}
if( p->explain==2 ){
        
// ABS Label 504
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}
sqlite3VdbeMemSetInt64(pMem, pOp->p1);
        
// ABS Label 505
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 505);
}

// AOR Label 506
if(pMem - 1 != pMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 506);
}
// AOR Label 507
if(pMem / 1 != pMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 507);
}
// AOR Label 508
if(pMem * 1 != pMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 508);
}
sqlite3VdbeMemSetInt64(pMem+1, pOp->p2);
        
// ABS Label 509
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}

// AOR Label 510
if(pMem - 2 != pMem + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 510);
}
// AOR Label 511
if(pMem / 2 != pMem + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 511);
}
// AOR Label 512
if(pMem * 2 != pMem + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 512);
}
sqlite3VdbeMemSetInt64(pMem+2, pOp->p3);
        
// ABS Label 513
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}

// AOR Label 514
if(pMem - 3 != pMem + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 514);
}
// AOR Label 515
if(pMem / 3 != pMem + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 515);
}
// AOR Label 516
if(pMem * 3 != pMem + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 516);
}
sqlite3VdbeMemSetStr(pMem+3, zP4, -1, SQLITE_UTF8, sqlite3_free);     
        p->nResColumn = 4;
      }else{
        
// ABS Label 517
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}

// AOR Label 518
if(pMem - 0 != pMem + 0)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 518);
}
// AOR Label 519
if(pMem / 0 != pMem + 0)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 519);
}
// AOR Label 520
if(pMem * 0 != pMem + 0)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 520);
}
sqlite3VdbeMemSetInt64(pMem+0, i);
        
// ABS Label 521
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}

// AOR Label 522
if(pMem - 1 != pMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 522);
}
// AOR Label 523
if(pMem / 1 != pMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 523);
}
// AOR Label 524
if(pMem * 1 != pMem + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 524);
}
sqlite3VdbeMemSetStr(pMem+1, (char*)sqlite3OpcodeName(pOp->opcode),
                             -1, SQLITE_UTF8, SQLITE_STATIC);
        
// ABS Label 525
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}

// AOR Label 526
if(pMem - 2 != pMem + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 526);
}
// AOR Label 527
if(pMem / 2 != pMem + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 527);
}
// AOR Label 528
if(pMem * 2 != pMem + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 528);
}
sqlite3VdbeMemSetInt64(pMem+2, pOp->p1);
        
// ABS Label 529
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// AOR Label 530
if(pMem - 3 != pMem + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 530);
}
// AOR Label 531
if(pMem / 3 != pMem + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 531);
}
// AOR Label 532
if(pMem * 3 != pMem + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 532);
}
sqlite3VdbeMemSetInt64(pMem+3, pOp->p2);
        
// ABS Label 533
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}

// AOR Label 534
if(pMem - 4 != pMem + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 534);
}
// AOR Label 535
if(pMem / 4 != pMem + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 535);
}
// AOR Label 536
if(pMem * 4 != pMem + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 536);
}
sqlite3VdbeMemSetInt64(pMem+4, pOp->p3);
        /* pMem+5 for p4 is done last */
        
// ABS Label 537
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}

// AOR Label 538
if(pMem - 6 != pMem + 6)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 538);
}
// AOR Label 539
if(pMem / 6 != pMem + 6)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 539);
}
// AOR Label 540
if(pMem * 6 != pMem + 6)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 540);
}
sqlite3VdbeMemSetInt64(pMem+6, pOp->p5);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
        {
          char *zCom = sqlite3VdbeDisplayComment(db, pOp, zP4);
          sqlite3VdbeMemSetStr(pMem+7, zCom, -1, SQLITE_UTF8, sqlite3_free);
        }
#else
        
// ABS Label 541
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}

// AOR Label 542
if(pMem - 7 != pMem + 7)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 542);
}
// AOR Label 543
if(pMem / 7 != pMem + 7)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 543);
}
// AOR Label 544
if(pMem * 7 != pMem + 7)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 544);
}
sqlite3VdbeMemSetNull(pMem+7);
#endif
        
// ABS Label 545
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}

// AOR Label 546
if(pMem - 5 != pMem + 5)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 546);
}
// AOR Label 547
if(pMem / 5 != pMem + 5)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 547);
}
// AOR Label 548
if(pMem * 5 != pMem + 5)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 548);
}
sqlite3VdbeMemSetStr(pMem+5, zP4, -1, SQLITE_UTF8, sqlite3_free);
        p->nResColumn = 8;
      }
      p->pResultSet = pMem;
      
// ABS Label 549
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}
if( db->mallocFailed ){
        p->rc = SQLITE_NOMEM;
        rc = SQLITE_ERROR;
      }else{
        p->rc = SQLITE_OK;
        rc = SQLITE_ROW;
      }
    }
  }
  
// ABS Label 550
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}
return rc;
}
#endif /* SQLITE_OMIT_EXPLAIN */

#ifdef SQLITE_DEBUG
/*
** Print the SQL that was used to generate a VDBE program.
*/
void sqlite3VdbePrintSql(Vdbe *p){
  const char *z = 0;
  if( p->zSql ){
    z = p->zSql;
  }else if( p->nOp>=1 ){
    const VdbeOp *pOp = &p->aOp[0];
    if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){
      z = pOp->p4.z;
      while( sqlite3Isspace(*z) ) z++;
    }
  }
  if( z ) printf("SQL: [%s]\n", z);
}
#endif

#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)
/*
** Print an IOTRACE message showing SQL content.
*/
void sqlite3VdbeIOTraceSql(Vdbe *p){
  int nOp = p->nOp;
  VdbeOp *pOp;
  if( sqlite3IoTrace==0 ) return;
  if( nOp<1 ) return;
  pOp = &p->aOp[0];
  if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){
    int i, j;
    char z[1000];
    sqlite3_snprintf(sizeof(z), z, "%s", pOp->p4.z);
    for(i=0; sqlite3Isspace(z[i]); i++){}
    for(j=0; z[i]; i++){
      if( sqlite3Isspace(z[i]) ){
        if( z[i-1]!=' ' ){
          z[j++] = ' ';
        }
      }else{
        z[j++] = z[i];
      }
    }
    z[j] = 0;
    sqlite3IoTrace("SQL %s\n", z);
  }
}
#endif /* !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE */

/* An instance of this object describes bulk memory available for use
** by subcomponents of a prepared statement.  Space is allocated out
** of a ReusableSpace object by the allocSpace() routine below.
*/
struct ReusableSpace {
  u8 *pSpace;            /* Available memory */
  sqlite3_int64 nFree;   /* Bytes of available memory */
  sqlite3_int64 nNeeded; /* Total bytes that could not be allocated */
};

/* Try to allocate nByte bytes of 8-byte aligned bulk memory for pBuf
** from the ReusableSpace object.  Return a pointer to the allocated
** memory on success.  If insufficient memory is available in the
** ReusableSpace object, increase the ReusableSpace.nNeeded
** value by the amount needed and return NULL.
**
** If pBuf is not initially NULL, that means that the memory has already
** been allocated by a prior call to this routine, so just return a copy
** of pBuf and leave ReusableSpace unchanged.
**
** This allocator is employed to repurpose unused slots at the end of the
** opcode array of prepared state for other memory needs of the prepared
** statement.
*/
static void *allocSpace(
  struct ReusableSpace *p,  /* Bulk memory available for allocation */
  void *pBuf,               /* Pointer to a prior allocation */
  sqlite3_int64 nByte       /* Bytes of memory needed */
){
  assert( EIGHT_BYTE_ALIGNMENT(p->pSpace) );
  
// ABS Label 551
if(pBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 551);
}

// ROR Label 552
if((pBuf != 0) != (pBuf == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 552);
}
if( pBuf==0 ){
    nByte = ROUND8(nByte);
    
// ABS Label 553
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}
// ABS Label 554
if(p->nFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}

// ROR Label 555
if((nByte < p->nFree) != (nByte <= p->nFree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}
// ROR Label 556
if((nByte > p->nFree) != (nByte <= p->nFree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 556);
}
// ROR Label 557
if((nByte >= p->nFree) != (nByte <= p->nFree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 557);
}
if( nByte <= p->nFree ){
      p->nFree -= nByte;
      pBuf = &p->pSpace[p->nFree];
    }else{
      p->nNeeded += nByte;
    }
  }
  assert( EIGHT_BYTE_ALIGNMENT(pBuf) );
  
// ABS Label 558
if(pBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}
return pBuf;
}

/*
** Rewind the VDBE back to the beginning in preparation for
** running it.
*/
void sqlite3VdbeRewind(Vdbe *p){
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
  int i;
#endif
  assert( p!=0 );
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT || p->iVdbeMagic==VDBE_MAGIC_RESET );

  /* There should be at least one opcode.
  */
  assert( p->nOp>0 );

  /* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */
  p->iVdbeMagic = VDBE_MAGIC_RUN;

#ifdef SQLITE_DEBUG
  for(i=0; i<p->nMem; i++){
    assert( p->aMem[i].db==p->db );
  }
#endif
  p->pc = -1;
  p->rc = SQLITE_OK;
  p->errorAction = OE_Abort;
  p->nChange = 0;
  p->cacheCtr = 1;
  p->minWriteFileFormat = 255;
  p->iStatement = 0;
  p->nFkConstraint = 0;
#ifdef VDBE_PROFILE
  for(i=0; i<p->nOp; i++){
    p->aOp[i].cnt = 0;
    p->aOp[i].cycles = 0;
  }
#endif
}

/*
** Prepare a virtual machine for execution for the first time after
** creating the virtual machine.  This involves things such
** as allocating registers and initializing the program counter.
** After the VDBE has be prepped, it can be executed by one or more
** calls to sqlite3VdbeExec().  
**
** This function may be called exactly once on each virtual machine.
** After this routine is called the VM has been "packaged" and is ready
** to run.  After this routine is called, further calls to 
** sqlite3VdbeAddOp() functions are prohibited.  This routine disconnects
** the Vdbe from the Parse object that helped generate it so that the
** the Vdbe becomes an independent entity and the Parse object can be
** destroyed.
**
** Use the sqlite3VdbeRewind() procedure to restore a virtual machine back
** to its initial state after it has been run.
*/
void sqlite3VdbeMakeReady(
  Vdbe *p,                       /* The VDBE */
  Parse *pParse                  /* Parsing context */
){
  sqlite3 *db;                   /* The database connection */
  int nVar;                      /* Number of parameters */
  int nMem;                      /* Number of VM memory registers */
  int nCursor;                   /* Number of cursors required */
  int nArg;                      /* Number of arguments in subprograms */
  int n;                         /* Loop counter */
  struct ReusableSpace x;        /* Reusable bulk memory */

  assert( p!=0 );
  assert( p->nOp>0 );
  assert( pParse!=0 );
  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );
  assert( pParse==p->pParse );
  p->pVList = pParse->pVList;
  pParse->pVList =  0;
  db = p->db;
  assert( db->mallocFailed==0 );
  nVar = pParse->nVar;
  nMem = pParse->nMem;
  nCursor = pParse->nTab;
  nArg = pParse->nMaxArg;
  
  /* Each cursor uses a memory cell.  The first cursor (cursor 0) can
  ** use aMem[0] which is not otherwise used by the VDBE program.  Allocate
  ** space at the end of aMem[] for cursors 1 and greater.
  ** See also: allocateCursor().
  */
  nMem += nCursor;
  
// ABS Label 561
if(nCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}
// ABS Label 562
if(nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}

// COR Label 563
if((nCursor == 0 || nMem > 0) != (nCursor == 0 && nMem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 563);
}

// ROR Label 564
if((nCursor != 0) != (nCursor == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}
// ROR Label 565
if((nMem <= 0) != (nMem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 565);
}
// ROR Label 566
if((nMem < 0) != (nMem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 566);
}
// ROR Label 567
if((nMem >= 0) != (nMem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 567);
}

// MCC Label 568
if(nCursor == 0 && nMem > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 568);
}
// MCC Label 569
if(nCursor == 0 && !(nMem > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 569);
}
// MCC Label 570
if(!(nCursor == 0) && nMem > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 570);
}
// MCC Label 571
if(!(nCursor == 0) && !(nMem > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 571);
}
if( nCursor==0 && nMem>0 ) { nMem++;  /* Space for aMem[0] even if not used */
}

  /* Figure out how much reusable memory is available at the end of the
  ** opcode array.  This extra memory will be reallocated for other elements
  ** of the prepared statement.
  */
  n = ROUND8(sizeof(Op)*p->nOp);              /* Bytes of opcode memory used */
  x.pSpace = &((u8*)p->aOp)[n];               /* Unused opcode memory */
  assert( EIGHT_BYTE_ALIGNMENT(x.pSpace) );
  x.nFree = ROUNDDOWN8(pParse->szOpAlloc - n);  /* Bytes of unused memory */
  assert( x.nFree>=0 );
  assert( EIGHT_BYTE_ALIGNMENT(&x.pSpace[x.nFree]) );

  
// ABS Label 559
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 559);
}
resolveP2Values(p, &nArg);
  p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);
  
// ABS Label 572
if(pParse->explain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 572);
}
if( pParse->explain ){
    static const char * const azColName[] = {
       "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
       "id", "parent", "notused", "detail"
    };
    int iFirst, mx, i;
    
// ABS Label 573
if(nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}

// ROR Label 574
if((nMem <= 10) != (nMem < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 574);
}
// ROR Label 575
if((nMem > 10) != (nMem < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 575);
}
// ROR Label 576
if((nMem >= 10) != (nMem < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 576);
}
if( nMem<10 ) { nMem = 10;
}
    p->explain = pParse->explain;
    
// ROR Label 577
if((pParse->explain != 2) != (pParse->explain == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 577);
}
if( pParse->explain==2 ){
      
// ABS Label 578
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 578);
}
sqlite3VdbeSetNumCols(p, 4);
      iFirst = 8;
      mx = 12;
    }else{
      
// ABS Label 579
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}
sqlite3VdbeSetNumCols(p, 8);
      iFirst = 0;
      mx = 8;
    }
    i = iFirst;

// ABS Label 580
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 580);
}
// ABS Label 581
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 581);
}

// ROR Label 582
if((i <= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 582);
}
// ROR Label 583
if((i > mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 583);
}
// ROR Label 584
if((i >= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 584);
}
for(; i<mx; i++){
      
// ABS Label 590
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 590);
}

// ABS Label 591
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 591);
}
// ABS Label 592
if(iFirst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 592);
}

// AOR Label 593
if(i / iFirst != i - iFirst)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 593);
}
// AOR Label 594
if(i + iFirst != i - iFirst)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 594);
}
// AOR Label 595
if(i * iFirst != i - iFirst)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 595);
}

// ABS Label 596
if(azColName[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}
// ABS Label 597
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 597);
}
sqlite3VdbeSetColName(p, i-iFirst, COLNAME_NAME,
                            azColName[i], SQLITE_STATIC);
    };
// ABS Label 585
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 585);
}
// ABS Label 586
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 586);
}

// ROR Label 587
if((i <= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 587);
}
// ROR Label 588
if((i > mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 588);
}
// ROR Label 589
if((i >= mx) != (i < mx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 589);
}

  }
  p->expired = 0;

  /* Memory for registers, parameters, cursor, etc, is allocated in one or two
  ** passes.  On the first pass, we try to reuse unused memory at the 
  ** end of the opcode array.  If we are unable to satisfy all memory
  ** requirements by reusing the opcode array tail, then the second
  ** pass will fill in the remainder using a fresh memory allocation.  
  **
  ** This two-pass approach that reuses as much memory as possible from
  ** the leftover memory at the end of the opcode array.  This can significantly
  ** reduce the amount of memory held by a prepared statement.
  */
  x.nNeeded = 0;
  p->aMem = allocSpace(&x, 0, nMem*sizeof(Mem));
  p->aVar = allocSpace(&x, 0, nVar*sizeof(Mem));
  p->apArg = allocSpace(&x, 0, nArg*sizeof(Mem*));
  p->apCsr = allocSpace(&x, 0, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
  p->anExec = allocSpace(&x, 0, p->nOp*sizeof(i64));
#endif
  
// ABS Label 598
if(x.nNeeded < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}
if( x.nNeeded ){
    x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);
    x.nFree = x.nNeeded;
    if( !db->mallocFailed ){
      p->aMem = allocSpace(&x, p->aMem, nMem*sizeof(Mem));
      p->aVar = allocSpace(&x, p->aVar, nVar*sizeof(Mem));
      p->apArg = allocSpace(&x, p->apArg, nArg*sizeof(Mem*));
      p->apCsr = allocSpace(&x, p->apCsr, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
      p->anExec = allocSpace(&x, p->anExec, p->nOp*sizeof(i64));
#endif
    }
  }

  
// ABS Label 599
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}
if( db->mallocFailed ){
    p->nVar = 0;
    p->nCursor = 0;
    p->nMem = 0;
  }else{
    p->nCursor = nCursor;
    p->nVar = (ynVar)nVar;
    
// ABS Label 600
if(p->aVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 600);
}

// ABS Label 601
if(nVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 601);
}

// ABS Label 602
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}
initMemArray(p->aVar, nVar, db, MEM_Null);
    p->nMem = nMem;
    
// ABS Label 603
if(p->aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}

// ABS Label 604
if(nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}

// ABS Label 605
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}
initMemArray(p->aMem, nMem, db, MEM_Undefined);
    
// AOR Label 606
if(nCursor - sizeof(VdbeCursor *) != nCursor * sizeof(VdbeCursor *))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 606);
}
// AOR Label 607
if(nCursor + sizeof(VdbeCursor *) != nCursor * sizeof(VdbeCursor *))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 607);
}
// AOR Label 608
if(nCursor / sizeof(VdbeCursor *) != nCursor * sizeof(VdbeCursor *))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 608);
}
memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
    memset(p->anExec, 0, p->nOp*sizeof(i64));
#endif
  }
  
// ABS Label 560
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 560);
}
sqlite3VdbeRewind(p);
}

/*
** Close a VDBE cursor and release all the resources that cursor 
** happens to hold.
*/
void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
  
// ABS Label 609
if(pCx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}

// ROR Label 610
if((pCx != 0) != (pCx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}
if( pCx==0 ){
    return;
  }
  assert( pCx->pBtx==0 || pCx->eCurType==CURTYPE_BTREE );
  assert( pCx->pBtx==0 || pCx->isEphemeral );
  switch( pCx->eCurType ){
    case CURTYPE_SORTER: {
      
// ABS Label 611
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}

// ABS Label 612
if(pCx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}
sqlite3VdbeSorterClose(p->db, pCx);
      break;
    }
    case CURTYPE_BTREE: {
      assert( pCx->uc.pCursor!=0 );
      
// ABS Label 613
if(pCx->uc.pCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}
sqlite3BtreeCloseCursor(pCx->uc.pCursor);
      break;
    }
#ifndef SQLITE_OMIT_VIRTUALTABLE
    case CURTYPE_VTAB: {
      
// ABS Label 614
if(pCx->uc.pVCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 614);
}
sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;
      
// ABS Label 615
if(pVCur->pVtab->pModule < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 615);
}
const sqlite3_module *pModule = pVCur->pVtab->pModule;
      assert( pVCur->pVtab->nRef>0 );
      pVCur->pVtab->nRef--;
      
// ABS Label 616
if(pVCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 616);
}
pModule->xClose(pVCur);
      break;
    }
#endif
  }
}

/*
** Close all cursors in the current frame.
*/
static void closeCursorsInFrame(Vdbe *p){
  
// ABS Label 617
if(p->apCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}
if( p->apCsr ){
    int i;
    i = 0;

// ABS Label 618
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}
// ABS Label 619
if(p->nCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// ROR Label 620
if((i <= p->nCursor) != (i < p->nCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
// ROR Label 621
if((i > p->nCursor) != (i < p->nCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}
// ROR Label 622
if((i >= p->nCursor) != (i < p->nCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 622);
}
for(; i<p->nCursor; i++){
      
// ABS Label 628
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}
// ABS Label 629
if(p->apCsr[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}
VdbeCursor *pC = p->apCsr[i];
      
// ABS Label 630
if(pC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}
if( pC ){
        
// ABS Label 631
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 631);
}

// ABS Label 632
if(pC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 632);
}
sqlite3VdbeFreeCursor(p, pC);
        p->apCsr[i] = 0;
      }
    };
// ABS Label 623
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}
// ABS Label 624
if(p->nCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 624);
}

// ROR Label 625
if((i <= p->nCursor) != (i < p->nCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}
// ROR Label 626
if((i > p->nCursor) != (i < p->nCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 626);
}
// ROR Label 627
if((i >= p->nCursor) != (i < p->nCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 627);
}

  }
}

/*
** Copy the values stored in the VdbeFrame structure to its Vdbe. This
** is used, for example, when a trigger sub-program is halted to restore
** control to the main program.
*/
int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){
  
// ABS Label 633
if(pFrame->v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 633);
}
Vdbe *v = pFrame->v;
  
// ABS Label 634
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}
closeCursorsInFrame(v);
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
  v->anExec = pFrame->anExec;
#endif
  v->aOp = pFrame->aOp;
  v->nOp = pFrame->nOp;
  v->aMem = pFrame->aMem;
  v->nMem = pFrame->nMem;
  v->apCsr = pFrame->apCsr;
  v->nCursor = pFrame->nCursor;
  v->db->lastRowid = pFrame->lastRowid;
  v->nChange = pFrame->nChange;
  v->db->nChange = pFrame->nDbChange;
  
// ABS Label 635
if(v->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}
sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);
  v->pAuxData = pFrame->pAuxData;
  pFrame->pAuxData = 0;
  
// ABS Label 636
if(pFrame->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 636);
}
return pFrame->pc;
}

/*
** Close all cursors.
**
** Also release any dynamic memory held by the VM in the Vdbe.aMem memory 
** cell array. This is necessary as the memory cell array may contain
** pointers to VdbeFrame objects, which may in turn contain pointers to
** open cursors.
*/
static void closeAllCursors(Vdbe *p){
  
// ABS Label 638
if(p->pFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 638);
}
if( p->pFrame ){
    VdbeFrame *pFrame;
    pFrame = p->pFrame;

// ABS Label 640
if(pFrame->pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 640);
}
for(; pFrame->pParent; pFrame=pFrame->pParent) {;
};
// ABS Label 641
if(pFrame->pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}

    
// ABS Label 639
if(pFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}
sqlite3VdbeFrameRestore(pFrame);
    p->pFrame = 0;
    p->nFrame = 0;
  }
  assert( p->nFrame==0 );
  
// ABS Label 637
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}
closeCursorsInFrame(p);
  
// ABS Label 642
if(p->aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 642);
}
if( p->aMem ){
    
// ABS Label 643
if(p->aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}

// ABS Label 644
if(p->nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}
releaseMemArray(p->aMem, p->nMem);
  }
  
// ABS Label 645
if(p->pDelFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}
while( p->pDelFrame ){
    
// ABS Label 647
if(p->pDelFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}
VdbeFrame *pDel = p->pDelFrame;
    p->pDelFrame = pDel->pParent;
    
// ABS Label 648
if(pDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}
sqlite3VdbeFrameDelete(pDel);
  };
// ABS Label 646
if(p->pDelFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}


  /* Delete any auxdata allocations made by the VM */
  
// ABS Label 649
if(p->pAuxData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}
if( p->pAuxData ) { 
// ABS Label 650
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}
sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);
}
  assert( p->pAuxData==0 );
}

/*
** Set the number of result columns that will be returned by this SQL
** statement. This is now set at compile time, rather than during
** execution of the vdbe program so that sqlite3_column_count() can
** be called on an SQL statement before sqlite3_step().
*/
void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){
  int n;
  
// ABS Label 651
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}
sqlite3 *db = p->db;

  
// ABS Label 655
if(p->nResColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 655);
}
if( p->nResColumn ){
    
// ABS Label 656
if(p->aColName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}

// AOR Label 657
if(p->nResColumn - 2 != p->nResColumn * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 657);
}
// AOR Label 658
if(p->nResColumn + 2 != p->nResColumn * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 658);
}
// AOR Label 659
if(p->nResColumn / 2 != p->nResColumn * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 659);
}
releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
    
// ABS Label 660
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}
sqlite3DbFree(db, p->aColName);
  }
  n = nResColumn*COLNAME_N;
  p->nResColumn = (u16)nResColumn;
  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );
  
// ABS Label 661
if(p->aColName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}

// ROR Label 662
if((p->aColName != 0) != (p->aColName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
if( p->aColName==0 ) { return;
}
  
// ABS Label 652
if(p->aColName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}

// ABS Label 653
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}

// ABS Label 654
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}
initMemArray(p->aColName, n, db, MEM_Null);
}

/*
** Set the name of the idx'th column to be returned by the SQL statement.
** zName must be a pointer to a nul terminated string.
**
** This call must be made after a call to sqlite3VdbeSetNumCols().
**
** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC
** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed
** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.
*/
int sqlite3VdbeSetColName(
  Vdbe *p,                         /* Vdbe being configured */
  int idx,                         /* Index of column zName applies to */
  int var,                         /* One of the COLNAME_* constants */
  const char *zName,               /* Pointer to buffer containing name */
  void (*xDel)(void*)              /* Memory management strategy for zName */
){
  int rc;
  Mem *pColName;
  assert( idx<p->nResColumn );
  assert( var<COLNAME_N );
  
// ABS Label 663
if(p->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}
if( p->db->mallocFailed ){
    assert( !zName || xDel!=SQLITE_DYNAMIC );
    return SQLITE_NOMEM_BKPT;
  }
  assert( p->aColName!=0 );
  pColName = &(p->aColName[idx+var*p->nResColumn]);
  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel);
  assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 );
  
// ABS Label 664
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 664);
}
return rc;
}

/*
** A read or write transaction may or may not be active on database handle
** db. If a transaction is active, commit it. If there is a
** write-transaction spanning more than one database file, this routine
** takes care of the super-journal trickery.
*/
static int vdbeCommit(sqlite3 *db, Vdbe *p){
  int i;
  int nTrans = 0;  /* Number of databases with an active write-transaction
                   ** that are candidates for a two-phase commit using a
                   ** super-journal */
  int rc = SQLITE_OK;
  int needXcommit = 0;

#ifdef SQLITE_OMIT_VIRTUALTABLE
  /* With this option, sqlite3VtabSync() is defined to be simply 
  ** SQLITE_OK so p is not used. 
  */
  UNUSED_PARAMETER(p);
#endif

  /* Before doing anything else, call the xSync() callback for any
  ** virtual module tables written in this transaction. This has to
  ** be done before determining whether a super-journal file is 
  ** required, as an xSync() callback may add an attached database
  ** to the transaction.
  */
  rc = sqlite3VtabSync(db, p);

  /* This loop determines (a) if the commit hook should be invoked and
  ** (b) how many database files have open write transactions, not 
  ** including the temp database. (b) is important because if more than 
  ** one database file has an open write transaction, a super-journal
  ** file is required for an atomic commit.
  */ 
  i = 0;

// ABS Label 665
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 665);
}
// ABS Label 666
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}
// ABS Label 667
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}

// COR Label 668
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 668);
}

// ROR Label 669
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 669);
}
// ROR Label 670
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 670);
}
// ROR Label 671
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 671);
}
// ROR Label 672
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 672);
}

// MCC Label 673
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 673);
}
// MCC Label 674
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 674);
}
// MCC Label 675
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 675);
}
// MCC Label 676
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 676);
}
for(; rc==SQLITE_OK && i<db->nDb; i++){ 
    
// ABS Label 689
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}
Btree *pBt = db->aDb[i].pBt;
    if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){
      /* Whether or not a database might need a super-journal depends upon
      ** its journal mode (among other things).  This matrix determines which
      ** journal modes use a super-journal and which do not */
      static const u8 aMJNeeded[] = {
        /* DELETE   */  1,
        /* PERSIST   */ 1,
        /* OFF       */ 0,
        /* TRUNCATE  */ 1,
        /* MEMORY    */ 0,
        /* WAL       */ 0
      };
      Pager *pPager;   /* Pager associated with pBt */
      needXcommit = 1;
      
// ABS Label 690
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}
sqlite3BtreeEnter(pBt);
      pPager = sqlite3BtreePager(pBt);
      if( db->aDb[i].safety_level!=PAGER_SYNCHRONOUS_OFF
       && aMJNeeded[sqlite3PagerGetJournalMode(pPager)]
       && sqlite3PagerIsMemdb(pPager)==0
      ){ 
        assert( i!=1 );
        nTrans++;
      }
      rc = sqlite3PagerExclusiveLock(pPager);
      
// ABS Label 691
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}
sqlite3BtreeLeave(pBt);
    }
  };
// ABS Label 677
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}
// ABS Label 678
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
// ABS Label 679
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}

// COR Label 680
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 680);
}

// ROR Label 681
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 681);
}
// ROR Label 682
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 682);
}
// ROR Label 683
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 683);
}
// ROR Label 684
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 684);
}

// MCC Label 685
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 685);
}
// MCC Label 686
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 686);
}
// MCC Label 687
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 687);
}
// MCC Label 688
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 688);
}

  
// ABS Label 692
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}

// ROR Label 693
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 693);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 694
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}
return rc;
  }

  /* If there are any write-transactions at all, invoke the commit hook */
  
// ABS Label 695
if(db->xCommitCallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}
// ABS Label 696
if(needXcommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}

// COR Label 697
if((needXcommit || db->xCommitCallback) != (needXcommit && db->xCommitCallback))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 697);
}

// MCC Label 698
if(needXcommit && db->xCommitCallback ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 698);
}
// MCC Label 699
if(needXcommit && !(db->xCommitCallback) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 699);
}
// MCC Label 700
if(!(needXcommit) && db->xCommitCallback ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 700);
}
// MCC Label 701
if(!(needXcommit) && !(db->xCommitCallback) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 701);
}
if( needXcommit && db->xCommitCallback ){
    rc = db->xCommitCallback(db->pCommitArg);
    
// ABS Label 702
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}
if( rc ){
      
// MCC Label 703
if(( 19 | (2 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 703);
}
// MCC Label 704
if(( !(19 | (2 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 704);
}
return SQLITE_CONSTRAINT_COMMITHOOK;
    }
  }

  /* The simple case - no more than one database file (not counting the
  ** TEMP database) has a transaction active.   There is no need for the
  ** super-journal.
  **
  ** If the return value of sqlite3BtreeGetFilename() is a zero length
  ** string, it means the main database is :memory: or a temp file.  In 
  ** that case we do not support atomic multi-file commits, so use the 
  ** simple case then too.
  */
  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))
   || nTrans<=1
  ){
    i = 0;

// ABS Label 705
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}
// ABS Label 706
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}
// ABS Label 707
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}

// COR Label 708
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 708);
}

// ROR Label 709
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 709);
}
// ROR Label 710
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 710);
}
// ROR Label 711
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 711);
}
// ROR Label 712
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 712);
}

// MCC Label 713
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 713);
}
// MCC Label 714
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 714);
}
// MCC Label 715
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 715);
}
// MCC Label 716
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 716);
}
for(; rc==SQLITE_OK && i<db->nDb; i++){
      
// ABS Label 729
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}
Btree *pBt = db->aDb[i].pBt;
      
// ABS Label 730
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, 0);
      }
    };
// ABS Label 717
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}
// ABS Label 718
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 718);
}
// ABS Label 719
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}

// COR Label 720
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 720);
}

// ROR Label 721
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 721);
}
// ROR Label 722
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 722);
}
// ROR Label 723
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}
// ROR Label 724
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 724);
}

// MCC Label 725
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 725);
}
// MCC Label 726
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 726);
}
// MCC Label 727
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 727);
}
// MCC Label 728
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 728);
}


    /* Do the commit only if all databases successfully complete phase 1. 
    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an
    ** IO error while deleting or truncating a journal file. It is unlikely,
    ** but could happen. In this case abandon processing and return the error.
    */
    i = 0;

// ABS Label 731
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}
// ABS Label 732
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}
// ABS Label 733
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 733);
}

// COR Label 734
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 734);
}

// ROR Label 735
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 735);
}
// ROR Label 736
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 736);
}
// ROR Label 737
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 737);
}
// ROR Label 738
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 738);
}

// MCC Label 739
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 739);
}
// MCC Label 740
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 740);
}
// MCC Label 741
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 741);
}
// MCC Label 742
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 742);
}
for(; rc==SQLITE_OK && i<db->nDb; i++){
      
// ABS Label 755
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}
Btree *pBt = db->aDb[i].pBt;
      
// ABS Label 756
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}
if( pBt ){
        rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);
      }
    };
// ABS Label 743
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}
// ABS Label 744
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 744);
}
// ABS Label 745
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}

// COR Label 746
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 746);
}

// ROR Label 747
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 747);
}
// ROR Label 748
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 748);
}
// ROR Label 749
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 749);
}
// ROR Label 750
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 750);
}

// MCC Label 751
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 751);
}
// MCC Label 752
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 752);
}
// MCC Label 753
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 753);
}
// MCC Label 754
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 754);
}

    
// ABS Label 757
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}

// ROR Label 758
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 758);
}
if( rc==SQLITE_OK ){
      
// ABS Label 759
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}
sqlite3VtabCommit(db);
    }
  }

  /* The complex case - There is a multi-file write-transaction active.
  ** This requires a super-journal file to ensure the transaction is
  ** committed atomically.
  */
#ifndef SQLITE_OMIT_DISKIO
  else{
    
// ABS Label 760
if(db->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}
sqlite3_vfs *pVfs = db->pVfs;
    char *zSuper = 0;   /* File-name for the super-journal */
    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);
    sqlite3_file *pSuperJrnl = 0;
    i64 offset = 0;
    int res;
    int retryCount = 0;
    int nMainFile;

    /* Select a super-journal file name */
    nMainFile = sqlite3Strlen30(zMainFile);
    zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", 0,zMainFile,0);
    
// ABS Label 764
if(zSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// ROR Label 765
if((zSuper != 0) != (zSuper == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 765);
}
if( zSuper==0 ) { return SQLITE_NOMEM_BKPT;
}
    zSuper += 4;
    
// ABS Label 766
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 766);
}
// ABS Label 767
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 767);
}

// COR Label 768
if((rc == 0 || res) != (rc == 0 && res))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 768);
}

// ROR Label 769
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 769);
}

// MCC Label 770
if(rc == 0 && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
// MCC Label 771
if(rc == 0 && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 771);
}
// MCC Label 772
if(!(rc == 0) && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 772);
}
// MCC Label 773
if(!(rc == 0) && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 773);
}
do {
      u32 iRandom;
      
// ABS Label 787
if(retryCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}
if( retryCount ){
        
// ABS Label 788
if(retryCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}

// ROR Label 789
if((retryCount <= 100) != (retryCount > 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 789);
}
// ROR Label 790
if((retryCount < 100) != (retryCount > 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 790);
}
// ROR Label 791
if((retryCount >= 100) != (retryCount > 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 791);
}
if( retryCount>100 ){
          
// ABS Label 792
if(zSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}
sqlite3_log(SQLITE_FULL, "MJ delete: %s", zSuper);
          
// ABS Label 793
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}
sqlite3OsDelete(pVfs, zSuper, 0);
          break;
        }else { 
// ABS Label 794
if(retryCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}

// ROR Label 795
if((retryCount != 1) != (retryCount == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 795);
}
if( retryCount==1 ){
          
// ABS Label 796
if(zSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}
sqlite3_log(SQLITE_FULL, "MJ collide: %s", zSuper);
        };}

      }
      retryCount++;
      sqlite3_randomness(sizeof(iRandom), &iRandom);
      
// AOR Label 782
if((iRandom >> 8) | 16777215 != (iRandom >> 8) & 16777215)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 782);
}
// AOR Label 783
if((iRandom >> 8) ^ 16777215 != (iRandom >> 8) & 16777215)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 783);
}

// ABS Label 784
if(iRandom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}

// AOR Label 785
if(iRandom | 255 != iRandom & 255)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 785);
}
// AOR Label 786
if(iRandom ^ 255 != iRandom & 255)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 786);
}
sqlite3_snprintf(13, &zSuper[nMainFile], "-mj%06X9%02X",
                               (iRandom>>8)&0xffffff, iRandom&0xff);
      /* The antipenultimate character of the super-journal name must
      ** be "9" to avoid name collisions when using 8+3 filenames. */
      assert( zSuper[sqlite3Strlen30(zSuper)-3]=='9' );
      sqlite3FileSuffix3(zMainFile, zSuper);
      rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);
    }while( rc==SQLITE_OK && res );
// ABS Label 774
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}
// ABS Label 775
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// COR Label 776
if((rc == 0 || res) != (rc == 0 && res))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 776);
}

// ROR Label 777
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 777);
}

// MCC Label 778
if(rc == 0 && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 778);
}
// MCC Label 779
if(rc == 0 && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 779);
}
// MCC Label 780
if(!(rc == 0) && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 780);
}
// MCC Label 781
if(!(rc == 0) && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 781);
}
;
    
// ABS Label 797
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}

// ROR Label 798
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 798);
}
if( rc==SQLITE_OK ){
      /* Open the super-journal. */
      rc = sqlite3OsOpenMalloc(pVfs, zSuper, &pSuperJrnl, 
          SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|
          SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_SUPER_JOURNAL, 0
      );
    }
    
// ABS Label 799
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}

// ROR Label 800
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 800);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 801
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}
sqlite3DbFree(db, zSuper-4);
      
// ABS Label 802
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 802);
}
return rc;
    }
 
    /* Write the name of each database file in the transaction into the new
    ** super-journal file. If an error occurs at this point close
    ** and delete the super-journal file. All the individual journal files
    ** still have 'null' as the super-journal pointer, so they will roll
    ** back independently if a failure occurs.
    */
    i = 0;

// ABS Label 803
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 803);
}
// ABS Label 804
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}

// ROR Label 805
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 805);
}
// ROR Label 806
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 806);
}
// ROR Label 807
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 807);
}
for(; i<db->nDb; i++){
      
// ABS Label 813
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}
Btree *pBt = db->aDb[i].pBt;
      if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){
        char const *zFile = sqlite3BtreeGetJournalname(pBt);
        
// ABS Label 814
if(zFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ROR Label 815
if((zFile != 0) != (zFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 815);
}
if( zFile==0 ){
          continue;  /* Ignore TEMP and :memory: databases */
        }
        assert( zFile[0]!=0 );
        rc = sqlite3OsWrite(pSuperJrnl, zFile, sqlite3Strlen30(zFile)+1,offset);
        offset += sqlite3Strlen30(zFile)+1;
        
// ABS Label 816
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// ROR Label 817
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 817);
}
if( rc!=SQLITE_OK ){
          
// ABS Label 818
if(pSuperJrnl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}
sqlite3OsCloseFree(pSuperJrnl);
          
// ABS Label 819
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}
sqlite3OsDelete(pVfs, zSuper, 0);
          
// ABS Label 820
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
sqlite3DbFree(db, zSuper-4);
          
// ABS Label 821
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}
return rc;
        }
      }
    };
// ABS Label 808
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}
// ABS Label 809
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}

// ROR Label 810
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 810);
}
// ROR Label 811
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 811);
}
// ROR Label 812
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 812);
}


    /* Sync the super-journal file. If the IOCAP_SEQUENTIAL device
    ** flag is set this is not required.
    */
    if( 0==(sqlite3OsDeviceCharacteristics(pSuperJrnl)&SQLITE_IOCAP_SEQUENTIAL)
     && SQLITE_OK!=(rc = sqlite3OsSync(pSuperJrnl, SQLITE_SYNC_NORMAL))
    ){
      
// ABS Label 822
if(pSuperJrnl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}
sqlite3OsCloseFree(pSuperJrnl);
      
// ABS Label 823
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}
sqlite3OsDelete(pVfs, zSuper, 0);
      
// ABS Label 824
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}
sqlite3DbFree(db, zSuper-4);
      
// ABS Label 825
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}
return rc;
    }

    /* Sync all the db files involved in the transaction. The same call
    ** sets the super-journal pointer in each individual journal. If
    ** an error occurs here, do not delete the super-journal file.
    **
    ** If the error occurs during the first call to
    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the
    ** super-journal file will be orphaned. But we cannot delete it,
    ** in case the super-journal file name was written into the journal
    ** file before the failure occurred.
    */
    i = 0;

// ABS Label 826
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}
// ABS Label 827
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
// ABS Label 828
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// COR Label 829
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 829);
}

// ROR Label 830
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}
// ROR Label 831
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 831);
}
// ROR Label 832
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}
// ROR Label 833
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 833);
}

// MCC Label 834
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 834);
}
// MCC Label 835
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 835);
}
// MCC Label 836
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 836);
}
// MCC Label 837
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 837);
}
for(; rc==SQLITE_OK && i<db->nDb; i++){ 
      
// ABS Label 850
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}
Btree *pBt = db->aDb[i].pBt;
      
// ABS Label 851
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}
if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, zSuper);
      }
    };
// ABS Label 838
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}
// ABS Label 839
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}
// ABS Label 840
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 840);
}

// COR Label 841
if((rc == 0 || i < db->nDb) != (rc == 0 && i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 841);
}

// ROR Label 842
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 842);
}
// ROR Label 843
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 843);
}
// ROR Label 844
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 844);
}
// ROR Label 845
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 845);
}

// MCC Label 846
if(rc == 0 && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 846);
}
// MCC Label 847
if(rc == 0 && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 847);
}
// MCC Label 848
if(!(rc == 0) && i < db->nDb ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 848);
}
// MCC Label 849
if(!(rc == 0) && !(i < db->nDb) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 849);
}

    
// ABS Label 761
if(pSuperJrnl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 761);
}
sqlite3OsCloseFree(pSuperJrnl);
    assert( rc!=SQLITE_BUSY );
    
// ABS Label 852
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}

// ROR Label 853
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 854
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}
sqlite3DbFree(db, zSuper-4);
      
// ABS Label 855
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}
return rc;
    }

    /* Delete the super-journal file. This commits the transaction. After
    ** doing this the directory is synced again before any individual
    ** transaction files are deleted.
    */
    rc = sqlite3OsDelete(pVfs, zSuper, 1);
    
// ABS Label 762
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}
sqlite3DbFree(db, zSuper-4);
    zSuper = 0;
    
// ABS Label 856
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}
if( rc ){
      
// ABS Label 857
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 857);
}
return rc;
    }

    /* All files and directories have already been synced, so the following
    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and
    ** deleting or truncating journals. If something goes wrong while
    ** this is happening we don't really care. The integrity of the
    ** transaction is already guaranteed, but some stray 'cold' journals
    ** may be lying around. Returning an error code won't help matters.
    */
    disable_simulated_io_errors();
    sqlite3BeginBenignMalloc();
    i = 0;

// ABS Label 858
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
// ABS Label 859
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}

// ROR Label 860
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 860);
}
// ROR Label 861
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 861);
}
// ROR Label 862
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
for(; i<db->nDb; i++){ 
      
// ABS Label 868
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 868);
}
Btree *pBt = db->aDb[i].pBt;
      
// ABS Label 869
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 869);
}
if( pBt ){
        
// ABS Label 870
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}
sqlite3BtreeCommitPhaseTwo(pBt, 1);
      }
    };
// ABS Label 863
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}
// ABS Label 864
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 864);
}

// ROR Label 865
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 865);
}
// ROR Label 866
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}
// ROR Label 867
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 867);
}

    sqlite3EndBenignMalloc();
    enable_simulated_io_errors();

    
// ABS Label 763
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 763);
}
sqlite3VtabCommit(db);
  }
#endif

  
// ABS Label 871
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}
return rc;
}

/* 
** This routine checks that the sqlite3.nVdbeActive count variable
** matches the number of vdbe's in the list sqlite3.pVdbe that are
** currently active. An assertion fails if the two counts do not match.
** This is an internal self-check only - it is not an essential processing
** step.
**
** This is a no-op if NDEBUG is defined.
*/
#ifndef NDEBUG
static void checkActiveVdbeCnt(sqlite3 *db){
  Vdbe *p;
  int cnt = 0;
  int nWrite = 0;
  int nRead = 0;
  p = db->pVdbe;
  while( p ){
    if( sqlite3_stmt_busy((sqlite3_stmt*)p) ){
      cnt++;
      if( p->readOnly==0 ) nWrite++;
      if( p->bIsReader ) nRead++;
    }
    p = p->pNext;
  }
  assert( cnt==db->nVdbeActive );
  assert( nWrite==db->nVdbeWrite );
  assert( nRead==db->nVdbeRead );
}
#else
#define checkActiveVdbeCnt(x)
#endif

/*
** If the Vdbe passed as the first argument opened a statement-transaction,
** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or
** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement
** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the 
** statement transaction is committed.
**
** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. 
** Otherwise SQLITE_OK.
*/
static SQLITE_NOINLINE int vdbeCloseStatement(Vdbe *p, int eOp){
  
// ABS Label 872
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
sqlite3 *const db = p->db;
  int rc = SQLITE_OK;
  int i;
  
// ABS Label 873
if(p->iStatement < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// AOR Label 874
if(p->iStatement / 1 != p->iStatement - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 874);
}
// AOR Label 875
if(p->iStatement + 1 != p->iStatement - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 875);
}
// AOR Label 876
if(p->iStatement * 1 != p->iStatement - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 876);
}
const int iSavepoint = p->iStatement-1;

  assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);
  assert( db->nStatement>0 );
  assert( p->iStatement==(db->nStatement+db->nSavepoint) );

  i = 0;

// ABS Label 877
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}
// ABS Label 878
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 878);
}

// ROR Label 879
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 879);
}
// ROR Label 880
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 880);
}
// ROR Label 881
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 881);
}
for(; i<db->nDb; i++){ 
    int rc2 = SQLITE_OK;
    
// ABS Label 887
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 887);
}
Btree *pBt = db->aDb[i].pBt;
    
// ABS Label 888
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 888);
}
if( pBt ){
      
// ABS Label 889
if(eOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 889);
}

// ROR Label 890
if((eOp != 2) != (eOp == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 890);
}
if( eOp==SAVEPOINT_ROLLBACK ){
        rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);
      }
      
// ABS Label 891
if(rc2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}

// ROR Label 892
if((rc2 != 0) != (rc2 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
if( rc2==SQLITE_OK ){
        rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);
      }
      
// ABS Label 893
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}

// ROR Label 894
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 894);
}
if( rc==SQLITE_OK ){
        rc = rc2;
      }
    }
  };
// ABS Label 882
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}
// ABS Label 883
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}

// ROR Label 884
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 884);
}
// ROR Label 885
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 885);
}
// ROR Label 886
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}

  db->nStatement--;
  p->iStatement = 0;

  
// ABS Label 895
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}

// ROR Label 896
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 896);
}
if( rc==SQLITE_OK ){
    
// ABS Label 897
if(eOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}

// ROR Label 898
if((eOp != 2) != (eOp == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 898);
}
if( eOp==SAVEPOINT_ROLLBACK ){
      rc = sqlite3VtabSavepoint(db, SAVEPOINT_ROLLBACK, iSavepoint);
    }
    
// ABS Label 899
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 899);
}

// ROR Label 900
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 900);
}
if( rc==SQLITE_OK ){
      rc = sqlite3VtabSavepoint(db, SAVEPOINT_RELEASE, iSavepoint);
    }
  }

  /* If the statement transaction is being rolled back, also restore the 
  ** database handles deferred constraint counter to the value it had when 
  ** the statement transaction was opened.  */
  
// ABS Label 901
if(eOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 901);
}

// ROR Label 902
if((eOp != 2) != (eOp == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 902);
}
if( eOp==SAVEPOINT_ROLLBACK ){
    db->nDeferredCons = p->nStmtDefCons;
    db->nDeferredImmCons = p->nStmtDefImmCons;
  }
  
// ABS Label 903
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 903);
}
return rc;
}
int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){
  
// ABS Label 904
if(p->db->nStatement < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 904);
}
// ABS Label 905
if(p->iStatement < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}

// COR Label 906
if((p->db->nStatement || p->iStatement) != (p->db->nStatement && p->iStatement))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 906);
}

// MCC Label 907
if(p->db->nStatement && p->iStatement ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(p->db->nStatement && !(p->iStatement) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
// MCC Label 909
if(!(p->db->nStatement) && p->iStatement ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 909);
}
// MCC Label 910
if(!(p->db->nStatement) && !(p->iStatement) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 910);
}
if( p->db->nStatement && p->iStatement ){
    return vdbeCloseStatement(p, eOp);
  }
  return SQLITE_OK;
}


/*
** This function is called when a transaction opened by the database 
** handle associated with the VM passed as an argument is about to be 
** committed. If there are outstanding deferred foreign key constraint
** violations, return SQLITE_ERROR. Otherwise, SQLITE_OK.
**
** If there are outstanding FK violations and this function returns 
** SQLITE_ERROR, set the result of the VM to SQLITE_CONSTRAINT_FOREIGNKEY
** and write an error message to it. Then return SQLITE_ERROR.
*/
#ifndef SQLITE_OMIT_FOREIGN_KEY
int sqlite3VdbeCheckFk(Vdbe *p, int deferred){
  
// ABS Label 911
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}
sqlite3 *db = p->db;
  
// COR Label 912
if(((deferred && (db->nDeferredCons + db->nDeferredImmCons) > 0) && (!deferred && p->nFkConstraint > 0)) != ((deferred && (db->nDeferredCons + db->nDeferredImmCons) > 0) || (!deferred && p->nFkConstraint > 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 912);
}

// MCC Label 913
if(( deferred && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !deferred && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 913);
}
// MCC Label 914
if(( deferred && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !deferred && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(( deferred && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !(!deferred) && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(( deferred && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !(!deferred) && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}
// MCC Label 917
if(( deferred && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !deferred && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 917);
}
// MCC Label 918
if(( deferred && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !deferred && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 918);
}
// MCC Label 919
if(( deferred && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !(!deferred) && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 919);
}
// MCC Label 920
if(( deferred && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !(!deferred) && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 920);
}
// MCC Label 921
if(( !(deferred) && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !deferred && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 921);
}
// MCC Label 922
if(( !(deferred) && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !deferred && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 922);
}
// MCC Label 923
if(( !(deferred) && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !(!deferred) && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 923);
}
// MCC Label 924
if(( !(deferred) && (db->nDeferredCons + db->nDeferredImmCons) > 0 ) && ( !(!deferred) && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 924);
}
// MCC Label 925
if(( !(deferred) && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !deferred && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 925);
}
// MCC Label 926
if(( !(deferred) && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !deferred && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 926);
}
// MCC Label 927
if(( !(deferred) && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !(!deferred) && p->nFkConstraint > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 927);
}
// MCC Label 928
if(( !(deferred) && !((db->nDeferredCons + db->nDeferredImmCons) > 0) ) && ( !(!deferred) && !(p->nFkConstraint > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 928);
}
if( (deferred && (db->nDeferredCons+db->nDeferredImmCons)>0) 
   || (!deferred && p->nFkConstraint>0) 
  ){
    p->rc = SQLITE_CONSTRAINT_FOREIGNKEY;
    p->errorAction = OE_Abort;
    
// ABS Label 929
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 929);
}
sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
    return SQLITE_ERROR;
  }
  return SQLITE_OK;
}
#endif

/*
** This routine is called the when a VDBE tries to halt.  If the VDBE
** has made changes and is in autocommit mode, then commit those
** changes.  If a rollback is needed, then do the rollback.
**
** This routine is the only way to move the state of a VM from
** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to
** call this on a VM that is in the SQLITE_MAGIC_HALT state.
**
** Return an error code.  If the commit could not complete because of
** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it
** means the close did not happen and needs to be repeated.
*/
int sqlite3VdbeHalt(Vdbe *p){
  int rc;                         /* Used to store transient return codes */
  
// ABS Label 930
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
sqlite3 *db = p->db;

  /* This function contains the logic that determines if a statement or
  ** transaction will be committed or rolled back as a result of the
  ** execution of this virtual machine. 
  **
  ** If any of the following errors occur:
  **
  **     SQLITE_NOMEM
  **     SQLITE_IOERR
  **     SQLITE_FULL
  **     SQLITE_INTERRUPT
  **
  ** Then the internal cache might have been left in an inconsistent
  ** state.  We need to rollback the statement transaction, if there is
  ** one, or the complete transaction if there is no statement transaction.
  */

  
// ABS Label 932
if(p->iVdbeMagic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 932);
}

// ROR Label 933
if((p->iVdbeMagic == 770837923) != (p->iVdbeMagic != 770837923))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 933);
}
if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){
    return SQLITE_OK;
  }
  
// ABS Label 934
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}
if( db->mallocFailed ){
    p->rc = SQLITE_NOMEM_BKPT;
  }
  
// ABS Label 931
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 931);
}
closeAllCursors(p);
  checkActiveVdbeCnt(db);

  /* No commit or rollback needed if the program never started or if the
  ** SQL statement does not read or write a database file.  */
  
// ABS Label 935
if(p->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 935);
}

// COR Label 936
if((p->pc >= 0 || p->bIsReader) != (p->pc >= 0 && p->bIsReader))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 936);
}

// ROR Label 937
if((p->pc < 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 937);
}
// ROR Label 938
if((p->pc > 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 938);
}
// ROR Label 939
if((p->pc <= 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 939);
}

// MCC Label 940
if(p->pc >= 0 && p->bIsReader ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 940);
}
// MCC Label 941
if(p->pc >= 0 && !(p->bIsReader) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 941);
}
// MCC Label 942
if(!(p->pc >= 0) && p->bIsReader ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 942);
}
// MCC Label 943
if(!(p->pc >= 0) && !(p->bIsReader) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 943);
}
if( p->pc>=0 && p->bIsReader ){
    int mrc;   /* Primary error code from p->rc */
    int eStatementOp = 0;
    int isSpecialError;            /* Set to true if a 'special' error */

    /* Lock all btrees used by the statement */
    
// ABS Label 944
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}
sqlite3VdbeEnter(p);

    /* Check for one of the special errors */
    mrc = p->rc & 0xff;
    isSpecialError = mrc==SQLITE_NOMEM || mrc==SQLITE_IOERR
                     || mrc==SQLITE_INTERRUPT || mrc==SQLITE_FULL;
    
// ABS Label 946
if(isSpecialError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}
if( isSpecialError ){
      /* If the query was read-only and the error code is SQLITE_INTERRUPT, 
      ** no rollback is necessary. Otherwise, at least a savepoint 
      ** transaction must be rolled back to restore the database to a 
      ** consistent state.
      **
      ** Even if the statement is read-only, it is important to perform
      ** a statement or transaction rollback operation. If the error 
      ** occurred while writing to the journal, sub-journal or database
      ** file as part of an effort to free up cache space (see function
      ** pagerStress() in pager.c), the rollback is required to restore 
      ** the pager to a consistent state.
      */
      
// ABS Label 947
if(mrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}

// COR Label 948
if((!p->readOnly && mrc != 9) != (!p->readOnly || mrc != 9))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 948);
}

// ROR Label 949
if((mrc == 9) != (mrc != 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 949);
}

// MCC Label 950
if(!p->readOnly && mrc != 9 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 950);
}
// MCC Label 951
if(!p->readOnly && !(mrc != 9) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 951);
}
// MCC Label 952
if(!(!p->readOnly) && mrc != 9 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 952);
}
// MCC Label 953
if(!(!p->readOnly) && !(mrc != 9) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 953);
}
if( !p->readOnly || mrc!=SQLITE_INTERRUPT ){
        
// COR Label 954
if(((mrc == 7 || mrc == 13) || p->usesStmtJournal) != ((mrc == 7 || mrc == 13) && p->usesStmtJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 954);
}

// MCC Label 955
if(( mrc == 7 && mrc == 13 ) && p->usesStmtJournal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 955);
}
// MCC Label 956
if(( mrc == 7 && mrc == 13 ) && !(p->usesStmtJournal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 956);
}
// MCC Label 957
if(( mrc == 7 && !(mrc == 13) ) && p->usesStmtJournal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 957);
}
// MCC Label 958
if(( mrc == 7 && !(mrc == 13) ) && !(p->usesStmtJournal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 958);
}
// MCC Label 959
if(( !(mrc == 7) && mrc == 13 ) && p->usesStmtJournal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 959);
}
// MCC Label 960
if(( !(mrc == 7) && mrc == 13 ) && !(p->usesStmtJournal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 960);
}
// MCC Label 961
if(( !(mrc == 7) && !(mrc == 13) ) && p->usesStmtJournal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 961);
}
// MCC Label 962
if(( !(mrc == 7) && !(mrc == 13) ) && !(p->usesStmtJournal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 962);
}
if( (mrc==SQLITE_NOMEM || mrc==SQLITE_FULL) && p->usesStmtJournal ){
          eStatementOp = SAVEPOINT_ROLLBACK;
        }else{
          /* We are forced to roll back the active transaction. Before doing
          ** so, abort any other statements this handle currently has active.
          */
          
// ABS Label 963
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}
sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
          
// ABS Label 964
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 964);
}
sqlite3CloseSavepoints(db);
          db->autoCommit = 1;
          p->nChange = 0;
        }
      }
    }

    /* Check for immediate foreign key violations. */
    
// ABS Label 965
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// COR Label 966
if((p->rc == 0 && (p->errorAction == 3 && !isSpecialError)) != (p->rc == 0 || (p->errorAction == 3 && !isSpecialError)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 966);
}

// ROR Label 967
if((p->rc != 0) != (p->rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 967);
}

// MCC Label 968
if(p->rc == 0 && ( p->errorAction == 3 && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 968);
}
// MCC Label 969
if(p->rc == 0 && ( p->errorAction == 3 && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 969);
}
// MCC Label 970
if(p->rc == 0 && ( !(p->errorAction == 3) && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 970);
}
// MCC Label 971
if(p->rc == 0 && ( !(p->errorAction == 3) && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 971);
}
// MCC Label 972
if(!(p->rc == 0) && ( p->errorAction == 3 && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 972);
}
// MCC Label 973
if(!(p->rc == 0) && ( p->errorAction == 3 && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 973);
}
// MCC Label 974
if(!(p->rc == 0) && ( !(p->errorAction == 3) && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 974);
}
// MCC Label 975
if(!(p->rc == 0) && ( !(p->errorAction == 3) && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 975);
}
if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){
      
// ABS Label 976
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}
sqlite3VdbeCheckFk(p, 0);
    }
  
    /* If the auto-commit flag is set and this is the only active writer 
    ** VM, then we do either a commit or rollback of the current transaction. 
    **
    ** Note: This block also runs if one of the special errors handled 
    ** above has occurred. 
    */
    
// ABS Label 977
if(db->nVdbeWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 977);
}

// COR Label 978
if((!((db)->nVTrans > 0 && (db)->aVTrans == 0) && db->autoCommit || db->nVdbeWrite == (p->readOnly == 0)) != (!((db)->nVTrans > 0 && (db)->aVTrans == 0) && db->autoCommit && db->nVdbeWrite == (p->readOnly == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 978);
}
// COR Label 979
if((!((db)->nVTrans > 0 && (db)->aVTrans == 0) || db->autoCommit) != (!((db)->nVTrans > 0 && (db)->aVTrans == 0) && db->autoCommit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 979);
}

// ROR Label 980
if((db->nVdbeWrite != (p->readOnly == 0)) != (db->nVdbeWrite == (p->readOnly == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 980);
}

// MCC Label 981
if(!((db)->nVTrans > 0 && (db)->aVTrans == 0) && db->autoCommit && db->nVdbeWrite == (p->readOnly == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 981);
}
// MCC Label 982
if(!((db)->nVTrans > 0 && (db)->aVTrans == 0) && db->autoCommit && !(db->nVdbeWrite == (p->readOnly == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 982);
}
// MCC Label 983
if(!((db)->nVTrans > 0 && (db)->aVTrans == 0) && !(db->autoCommit) && db->nVdbeWrite == (p->readOnly == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 983);
}
// MCC Label 984
if(!((db)->nVTrans > 0 && (db)->aVTrans == 0) && !(db->autoCommit) && !(db->nVdbeWrite == (p->readOnly == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 984);
}
// MCC Label 985
if(!(!((db)->nVTrans > 0 && (db)->aVTrans == 0)) && db->autoCommit && db->nVdbeWrite == (p->readOnly == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 985);
}
// MCC Label 986
if(!(!((db)->nVTrans > 0 && (db)->aVTrans == 0)) && db->autoCommit && !(db->nVdbeWrite == (p->readOnly == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 986);
}
// MCC Label 987
if(!(!((db)->nVTrans > 0 && (db)->aVTrans == 0)) && !(db->autoCommit) && db->nVdbeWrite == (p->readOnly == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 987);
}
// MCC Label 988
if(!(!((db)->nVTrans > 0 && (db)->aVTrans == 0)) && !(db->autoCommit) && !(db->nVdbeWrite == (p->readOnly == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 988);
}
if( !sqlite3VtabInSync(db) 
     && db->autoCommit 
     && db->nVdbeWrite==(p->readOnly==0) 
    ){
      
// ABS Label 989
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 989);
}

// COR Label 990
if((p->rc == 0 && (p->errorAction == 3 && !isSpecialError)) != (p->rc == 0 || (p->errorAction == 3 && !isSpecialError)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 990);
}

// ROR Label 991
if((p->rc != 0) != (p->rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 991);
}

// MCC Label 992
if(p->rc == 0 && ( p->errorAction == 3 && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 992);
}
// MCC Label 993
if(p->rc == 0 && ( p->errorAction == 3 && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 993);
}
// MCC Label 994
if(p->rc == 0 && ( !(p->errorAction == 3) && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 994);
}
// MCC Label 995
if(p->rc == 0 && ( !(p->errorAction == 3) && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 995);
}
// MCC Label 996
if(!(p->rc == 0) && ( p->errorAction == 3 && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 996);
}
// MCC Label 997
if(!(p->rc == 0) && ( p->errorAction == 3 && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 997);
}
// MCC Label 998
if(!(p->rc == 0) && ( !(p->errorAction == 3) && !isSpecialError ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 998);
}
// MCC Label 999
if(!(p->rc == 0) && ( !(p->errorAction == 3) && !(!isSpecialError) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 999);
}
if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){
        rc = sqlite3VdbeCheckFk(p, 1);
        
// ABS Label 1000
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}

// ROR Label 1001
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1001);
}
if( rc!=SQLITE_OK ){
          
// ABS Label 1002
if((p->readOnly) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}
if( NEVER(p->readOnly) ){
            
// ABS Label 1003
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}
sqlite3VdbeLeave(p);
            return SQLITE_ERROR;
          }
          rc = SQLITE_CONSTRAINT_FOREIGNKEY;
        }else{ 
          /* The auto-commit flag is true, the vdbe program was successful 
          ** or hit an 'OR FAIL' constraint and there are no deferred foreign
          ** key constraints to hold up the transaction. This means a commit 
          ** is required. */
          rc = vdbeCommit(db, p);
        }
        
// ABS Label 1004
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1004);
}

// COR Label 1005
if((rc == 5 || p->readOnly) != (rc == 5 && p->readOnly))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1005);
}

// ROR Label 1006
if((rc != 5) != (rc == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1006);
}

// MCC Label 1007
if(rc == 5 && p->readOnly ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1007);
}
// MCC Label 1008
if(rc == 5 && !(p->readOnly) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1008);
}
// MCC Label 1009
if(!(rc == 5) && p->readOnly ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1009);
}
// MCC Label 1010
if(!(rc == 5) && !(p->readOnly) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1010);
}
if( rc==SQLITE_BUSY && p->readOnly ){
          
// ABS Label 1011
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1011);
}
sqlite3VdbeLeave(p);
          return SQLITE_BUSY;
        }else { 
// ABS Label 1012
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1012);
}

// ROR Label 1013
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1013);
}
if( rc!=SQLITE_OK ){
          p->rc = rc;
          
// ABS Label 1014
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1014);
}
sqlite3RollbackAll(db, SQLITE_OK);
          p->nChange = 0;
        }else{
          db->nDeferredCons = 0;
          db->nDeferredImmCons = 0;
          db->flags &= ~(u64)SQLITE_DeferFKs;
          
// ABS Label 1015
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}
sqlite3CommitInternalChanges(db);
        };}

      }else{
        
// ABS Label 1016
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}
sqlite3RollbackAll(db, SQLITE_OK);
        p->nChange = 0;
      }
      db->nStatement = 0;
    }else { 
// ABS Label 1017
if(eStatementOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}

// ROR Label 1018
if((eStatementOp != 0) != (eStatementOp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1018);
}
if( eStatementOp==0 ){
      
// ABS Label 1019
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}

// COR Label 1020
if((p->rc == 0 && p->errorAction == 3) != (p->rc == 0 || p->errorAction == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1020);
}

// ROR Label 1021
if((p->rc != 0) != (p->rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1021);
}
// ROR Label 1022
if((p->errorAction != 3) != (p->errorAction == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1022);
}

// MCC Label 1023
if(p->rc == 0 && p->errorAction == 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1023);
}
// MCC Label 1024
if(p->rc == 0 && !(p->errorAction == 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1024);
}
// MCC Label 1025
if(!(p->rc == 0) && p->errorAction == 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1025);
}
// MCC Label 1026
if(!(p->rc == 0) && !(p->errorAction == 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1026);
}
if( p->rc==SQLITE_OK || p->errorAction==OE_Fail ){
        eStatementOp = SAVEPOINT_RELEASE;
      }else { 
// ROR Label 1027
if((p->errorAction != 2) != (p->errorAction == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1027);
}
if( p->errorAction==OE_Abort ){
        eStatementOp = SAVEPOINT_ROLLBACK;
      }else{
        
// ABS Label 1028
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1028);
}
sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
        
// ABS Label 1029
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}
sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
        p->nChange = 0;
      };}

    };}

  
    /* If eStatementOp is non-zero, then a statement transaction needs to
    ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to
    ** do so. If this operation returns an error, and the current statement
    ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then promote the
    ** current statement error code.
    */
    
// ABS Label 1030
if(eStatementOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1030);
}
if( eStatementOp ){
      rc = sqlite3VdbeCloseStatement(p, eStatementOp);
      
// ABS Label 1031
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}
if( rc ){
        
// ABS Label 1034
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1034);
}

// COR Label 1035
if((p->rc == 0 && (p->rc & 255) == 19) != (p->rc == 0 || (p->rc & 255) == 19))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1035);
}

// ROR Label 1036
if((p->rc != 0) != (p->rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1036);
}
// ROR Label 1037
if(((p->rc & 255) != 19) != ((p->rc & 255) == 19))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1037);
}

// MCC Label 1038
if(p->rc == 0 && (p->rc & 255) == 19 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1038);
}
// MCC Label 1039
if(p->rc == 0 && !((p->rc & 255) == 19) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1039);
}
// MCC Label 1040
if(!(p->rc == 0) && (p->rc & 255) == 19 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1040);
}
// MCC Label 1041
if(!(p->rc == 0) && !((p->rc & 255) == 19) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1041);
}
if( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT ){
          p->rc = rc;
          
// ABS Label 1042
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}
sqlite3DbFree(db, p->zErrMsg);
          p->zErrMsg = 0;
        }
        
// ABS Label 1032
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}
sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);
        
// ABS Label 1033
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}
sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
        p->nChange = 0;
      }
    }
  
    /* If this was an INSERT, UPDATE or DELETE and no statement transaction
    ** has been rolled back, update the database connection change-counter. 
    */
    
// ABS Label 1043
if(p->changeCntOn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}
if( p->changeCntOn ){
      
// ABS Label 1044
if(eStatementOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// ROR Label 1045
if((eStatementOp == 2) != (eStatementOp != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1045);
}
if( eStatementOp!=SAVEPOINT_ROLLBACK ){
        
// ABS Label 1046
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1046);
}

// ABS Label 1047
if(p->nChange < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1047);
}
sqlite3VdbeSetChanges(db, p->nChange);
      }else{
        
// ABS Label 1048
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}
sqlite3VdbeSetChanges(db, 0);
      }
      p->nChange = 0;
    }

    /* Release the locks */
    
// ABS Label 945
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}
sqlite3VdbeLeave(p);
  }

  /* We have successfully halted and closed the VM.  Record this fact. */
  
// ABS Label 1049
if(p->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}

// ROR Label 1050
if((p->pc < 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1050);
}
// ROR Label 1051
if((p->pc > 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1051);
}
// ROR Label 1052
if((p->pc <= 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1052);
}
if( p->pc>=0 ){
    db->nVdbeActive--;
    if( !p->readOnly ) { db->nVdbeWrite--;
}
    
// ABS Label 1053
if(p->bIsReader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
if( p->bIsReader ) { db->nVdbeRead--;
}
    assert( db->nVdbeActive>=db->nVdbeRead );
    assert( db->nVdbeRead>=db->nVdbeWrite );
    assert( db->nVdbeWrite>=0 );
  }
  p->iVdbeMagic = VDBE_MAGIC_HALT;
  checkActiveVdbeCnt(db);
  
// ABS Label 1054
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}
if( db->mallocFailed ){
    p->rc = SQLITE_NOMEM_BKPT;
  }

  /* If the auto-commit flag is set to true, then any locks that were held
  ** by connection db have now been released. Call sqlite3ConnectionUnlocked() 
  ** to invoke any required unlock-notify callbacks.
  */
  
// ABS Label 1055
if(db->autoCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}
if( db->autoCommit ){
    sqlite3ConnectionUnlocked(db);
  }

  assert( db->nVdbeActive>0 || db->autoCommit==0 || db->nStatement==0 );
  
// MCC Label 1056
if(( ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1056);
}
return (p->rc==SQLITE_BUSY ? SQLITE_BUSY : SQLITE_OK);
}


/*
** Each VDBE holds the result of the most recent sqlite3_step() call
** in p->rc.  This routine sets that result back to SQLITE_OK.
*/
void sqlite3VdbeResetStepResult(Vdbe *p){
  p->rc = SQLITE_OK;
}

/*
** Copy the error code and error message belonging to the VDBE passed
** as the first argument to its database handle (so that they will be 
** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).
**
** This function does not clear the VDBE error code or message, just
** copies them to the database handle.
*/
int sqlite3VdbeTransferError(Vdbe *p){
  
// ABS Label 1057
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}
sqlite3 *db = p->db;
  
// ABS Label 1058
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}
int rc = p->rc;
  
// ABS Label 1059
if(p->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}
if( p->zErrMsg ){
    db->bBenignMalloc++;
    sqlite3BeginBenignMalloc();
    
// ABS Label 1061
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1061);
}

// ROR Label 1062
if((db->pErr != 0) != (db->pErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1062);
}
if( db->pErr==0 ) { db->pErr = sqlite3ValueNew(db);
}
    
// ABS Label 1060
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}
sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);
    sqlite3EndBenignMalloc();
    db->bBenignMalloc--;
  }else { 
// ABS Label 1063
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1063);
}
if( db->pErr ){
    
// ABS Label 1064
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1064);
}
sqlite3ValueSetNull(db->pErr);
  };}

  db->errCode = rc;
  
// ABS Label 1065
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1065);
}
return rc;
}

#ifdef SQLITE_ENABLE_SQLLOG
/*
** If an SQLITE_CONFIG_SQLLOG hook is registered and the VM has been run, 
** invoke it.
*/
static void vdbeInvokeSqllog(Vdbe *v){
  if( sqlite3GlobalConfig.xSqllog && v->rc==SQLITE_OK && v->zSql && v->pc>=0 ){
    char *zExpanded = sqlite3VdbeExpandSql(v, v->zSql);
    assert( v->db->init.busy==0 );
    if( zExpanded ){
      sqlite3GlobalConfig.xSqllog(
          sqlite3GlobalConfig.pSqllogArg, v->db, zExpanded, 1
      );
      sqlite3DbFree(v->db, zExpanded);
    }
  }
}
#else
# define vdbeInvokeSqllog(x)
#endif

/*
** Clean up a VDBE after execution but do not delete the VDBE just yet.
** Write any error messages into *pzErrMsg.  Return the result code.
**
** After this routine is run, the VDBE should be ready to be executed
** again.
**
** To look at it another way, this routine resets the state of the
** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to
** VDBE_MAGIC_INIT.
*/
int sqlite3VdbeReset(Vdbe *p){
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
  int i;
#endif

  sqlite3 *db;
  db = p->db;

  /* If the VM did not run to completion or if it encountered an
  ** error, then it might not have been halted properly.  So halt
  ** it now.
  */
  
// ABS Label 1066
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1066);
}
sqlite3VdbeHalt(p);

  /* If the VDBE has been run even partially, then transfer the error code
  ** and error message from the VDBE into the main database structure.  But
  ** if the VDBE has just been set to run but has not actually executed any
  ** instructions yet, leave the main database error information unchanged.
  */
  
// ABS Label 1067
if(p->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}

// ROR Label 1068
if((p->pc < 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1068);
}
// ROR Label 1069
if((p->pc > 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1069);
}
// ROR Label 1070
if((p->pc <= 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1070);
}
if( p->pc>=0 ){
    vdbeInvokeSqllog(p);
    
// ABS Label 1071
if(db->pErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1071);
}
// ABS Label 1072
if(p->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1072);
}

// COR Label 1073
if((db->pErr && p->zErrMsg) != (db->pErr || p->zErrMsg))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1073);
}

// MCC Label 1074
if(db->pErr && p->zErrMsg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1074);
}
// MCC Label 1075
if(db->pErr && !(p->zErrMsg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1075);
}
// MCC Label 1076
if(!(db->pErr) && p->zErrMsg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1076);
}
// MCC Label 1077
if(!(db->pErr) && !(p->zErrMsg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1077);
}
if( db->pErr || p->zErrMsg ){
      
// ABS Label 1078
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1078);
}
sqlite3VdbeTransferError(p);
    }else{
      db->errCode = p->rc;
    }
    
// ABS Label 1079
if(p->runOnlyOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1079);
}
if( p->runOnlyOnce ) { p->expired = 1;
}
  }else { 
// ABS Label 1080
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}

// COR Label 1081
if((p->rc || p->expired) != (p->rc && p->expired))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1081);
}

// MCC Label 1082
if(p->rc && p->expired ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1082);
}
// MCC Label 1083
if(p->rc && !(p->expired) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1083);
}
// MCC Label 1084
if(!(p->rc) && p->expired ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1084);
}
// MCC Label 1085
if(!(p->rc) && !(p->expired) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1085);
}
if( p->rc && p->expired ){
    /* The expired flag was set on the VDBE before the first call
    ** to sqlite3_step(). For consistency (since sqlite3_step() was
    ** called), set the database error in this case as well.
    */
    
// ABS Label 1086
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1086);
}

// ABS Label 1087
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1087);
}

// ABS Label 1088
if(p->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}
sqlite3ErrorWithMsg(db, p->rc, p->zErrMsg ? "%s" : 0, p->zErrMsg);
  };}


  /* Reset register contents and reclaim error message memory.
  */
#ifdef SQLITE_DEBUG
  /* Execute assert() statements to ensure that the Vdbe.apCsr[] and 
  ** Vdbe.aMem[] arrays have already been cleaned up.  */
  if( p->apCsr ) for(i=0; i<p->nCursor; i++) assert( p->apCsr[i]==0 );
  if( p->aMem ){
    for(i=0; i<p->nMem; i++) assert( p->aMem[i].flags==MEM_Undefined );
  }
#endif
  
// ABS Label 1089
if(p->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}
if( p->zErrMsg ){
    
// ABS Label 1090
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}
sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = 0;
  }
  p->pResultSet = 0;
#ifdef SQLITE_DEBUG
  p->nWrite = 0;
#endif

  /* Save profiling information from this VDBE run.
  */
#ifdef VDBE_PROFILE
  {
    FILE *out = fopen("vdbe_profile.out", "a");
    if( out ){
      fprintf(out, "---- ");
      for(i=0; i<p->nOp; i++){
        fprintf(out, "%02x", p->aOp[i].opcode);
      }
      fprintf(out, "\n");
      if( p->zSql ){
        char c, pc = 0;
        fprintf(out, "-- ");
        for(i=0; (c = p->zSql[i])!=0; i++){
          if( pc=='\n' ) fprintf(out, "-- ");
          putc(c, out);
          pc = c;
        }
        if( pc!='\n' ) fprintf(out, "\n");
      }
      for(i=0; i<p->nOp; i++){
        char zHdr[100];
        sqlite3_snprintf(sizeof(zHdr), zHdr, "%6u %12llu %8llu ",
           p->aOp[i].cnt,
           p->aOp[i].cycles,
           p->aOp[i].cnt>0 ? p->aOp[i].cycles/p->aOp[i].cnt : 0
        );
        fprintf(out, "%s", zHdr);
        sqlite3VdbePrintOp(out, i, &p->aOp[i]);
      }
      fclose(out);
    }
  }
#endif
  p->iVdbeMagic = VDBE_MAGIC_RESET;
  
// ABS Label 1091
if(db->errMask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}
// ABS Label 1092
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// AOR Label 1093
if(p->rc | db->errMask != p->rc & db->errMask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1093);
}
// AOR Label 1094
if(p->rc ^ db->errMask != p->rc & db->errMask)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1094);
}
return p->rc & db->errMask;
}
 
/*
** Clean up and delete a VDBE after execution.  Return an integer which is
** the result code.  Write any error message text into *pzErrMsg.
*/
int sqlite3VdbeFinalize(Vdbe *p){
  int rc = SQLITE_OK;
  
// ABS Label 1096
if(p->iVdbeMagic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1096);
}

// COR Label 1097
if((p->iVdbeMagic == 770837923 && p->iVdbeMagic == 832317811) != (p->iVdbeMagic == 770837923 || p->iVdbeMagic == 832317811))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1097);
}

// ROR Label 1098
if((p->iVdbeMagic != 770837923) != (p->iVdbeMagic == 770837923))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1098);
}
// ROR Label 1099
if((p->iVdbeMagic != 832317811) != (p->iVdbeMagic == 832317811))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1099);
}

// MCC Label 1100
if(p->iVdbeMagic == 770837923 && p->iVdbeMagic == 832317811 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1100);
}
// MCC Label 1101
if(p->iVdbeMagic == 770837923 && !(p->iVdbeMagic == 832317811) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1101);
}
// MCC Label 1102
if(!(p->iVdbeMagic == 770837923) && p->iVdbeMagic == 832317811 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1102);
}
// MCC Label 1103
if(!(p->iVdbeMagic == 770837923) && !(p->iVdbeMagic == 832317811) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1103);
}
if( p->iVdbeMagic==VDBE_MAGIC_RUN || p->iVdbeMagic==VDBE_MAGIC_HALT ){
    rc = sqlite3VdbeReset(p);
    assert( (rc & p->db->errMask)==rc );
  }
  
// ABS Label 1095
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}
sqlite3VdbeDelete(p);
  
// ABS Label 1104
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}
return rc;
}

/*
** If parameter iOp is less than zero, then invoke the destructor for
** all auxiliary data pointers currently cached by the VM passed as
** the first argument.
**
** Or, if iOp is greater than or equal to zero, then the destructor is
** only invoked for those auxiliary data pointers created by the user 
** function invoked by the OP_Function opcode at instruction iOp of 
** VM pVdbe, and only then if:
**
**    * the associated function parameter is the 32nd or later (counting
**      from left to right), or
**
**    * the corresponding bit in argument mask is clear (where the first
**      function parameter corresponds to bit 0 etc.).
*/
void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){
  
// ABS Label 1105
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1105);
}
while( *pp ){
    
// ABS Label 1107
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1107);
}
AuxData *pAux = *pp;
    
// COR Label 1108
if(((iOp < 0) && (pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && (pAux->iAuxArg > 31 || !(mask & (((unsigned int)1) << (pAux->iAuxArg)))))) != ((iOp < 0) || (pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && (pAux->iAuxArg > 31 || !(mask & (((unsigned int)1) << (pAux->iAuxArg)))))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1108);
}

// MCC Label 1109
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1109);
}
// MCC Label 1110
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1110);
}
// MCC Label 1111
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1111);
}
// MCC Label 1112
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1112);
}
// MCC Label 1113
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1113);
}
// MCC Label 1114
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1114);
}
// MCC Label 1115
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1115);
}
// MCC Label 1116
if(( iOp < 0 ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1116);
}
// MCC Label 1117
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1117);
}
// MCC Label 1118
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1118);
}
// MCC Label 1119
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1119);
}
// MCC Label 1120
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1120);
}
// MCC Label 1121
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1121);
}
// MCC Label 1122
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1122);
}
// MCC Label 1123
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1123);
}
// MCC Label 1124
if(( iOp < 0 ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1124);
}
// MCC Label 1125
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1125);
}
// MCC Label 1126
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1126);
}
// MCC Label 1127
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1127);
}
// MCC Label 1128
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1128);
}
// MCC Label 1129
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1129);
}
// MCC Label 1130
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1130);
}
// MCC Label 1131
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1131);
}
// MCC Label 1132
if(( !(iOp < 0) ) && ( pAux->iAuxOp == iOp && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1132);
}
// MCC Label 1133
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1133);
}
// MCC Label 1134
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1134);
}
// MCC Label 1135
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1135);
}
// MCC Label 1136
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && pAux->iAuxArg >= 0 && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1136);
}
// MCC Label 1137
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1137);
}
// MCC Label 1138
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( pAux->iAuxArg > 31 && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1138);
}
// MCC Label 1139
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(mask & (((unsigned int)1) << (pAux->iAuxArg))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1139);
}
// MCC Label 1140
if(( !(iOp < 0) ) && ( !(pAux->iAuxOp == iOp) && !(pAux->iAuxArg >= 0) && ( !(pAux->iAuxArg > 31) && !(!(mask & (((unsigned int)1) << (pAux->iAuxArg)))) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1140);
}
if( (iOp<0)
     || (pAux->iAuxOp==iOp
          && pAux->iAuxArg>=0
          && (pAux->iAuxArg>31 || !(mask & MASKBIT32(pAux->iAuxArg))))
    ){
      testcase( pAux->iAuxArg==31 );
      
// ABS Label 1142
if(pAux->xDeleteAux < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1142);
}
if( pAux->xDeleteAux ){
        
// ABS Label 1143
if(pAux->pAux < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1143);
}
pAux->xDeleteAux(pAux->pAux);
      }
      *pp = pAux->pNextAux;
      
// ABS Label 1141
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1141);
}
sqlite3DbFree(db, pAux);
    }else{
      pp= &pAux->pNextAux;
    }
  };
// ABS Label 1106
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1106);
}

}

/*
** Free all memory associated with the Vdbe passed as the second argument,
** except for object itself, which is preserved.
**
** The difference between this function and sqlite3VdbeDelete() is that
** VdbeDelete() also unlinks the Vdbe from the list of VMs associated with
** the database connection and frees the object itself.
*/
void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){
  SubProgram *pSub, *pNext;
  assert( p->db==0 || p->db==db );
  
// ABS Label 1144
if(p->aColName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1144);
}

// AOR Label 1145
if(p->nResColumn - 2 != p->nResColumn * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1145);
}
// AOR Label 1146
if(p->nResColumn + 2 != p->nResColumn * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1146);
}
// AOR Label 1147
if(p->nResColumn / 2 != p->nResColumn * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1147);
}
releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);
  pSub = p->pProgram;

// ABS Label 1153
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1153);
}
for(; pSub; pSub=pNext){
    pNext = pSub->pNext;
    
// ABS Label 1155
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1155);
}

// ABS Label 1156
if(pSub->aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}

// ABS Label 1157
if(pSub->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}
vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
    
// ABS Label 1158
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1158);
}
sqlite3DbFree(db, pSub);
  };
// ABS Label 1154
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1154);
}

  
// ABS Label 1159
if(p->iVdbeMagic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1159);
}

// ROR Label 1160
if((p->iVdbeMagic == 381479589) != (p->iVdbeMagic != 381479589))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1160);
}
if( p->iVdbeMagic!=VDBE_MAGIC_INIT ){
    
// ABS Label 1161
if(p->aVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1161);
}
releaseMemArray(p->aVar, p->nVar);
    
// ABS Label 1162
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1162);
}
sqlite3DbFree(db, p->pVList);
    
// ABS Label 1163
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}

// ABS Label 1164
if(p->pFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1164);
}
sqlite3DbFree(db, p->pFree);
  }
  
// ABS Label 1148
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1148);
}

// ABS Label 1149
if(p->aOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1149);
}

// ABS Label 1150
if(p->nOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1150);
}
vdbeFreeOpArray(db, p->aOp, p->nOp);
  
// ABS Label 1151
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1151);
}
sqlite3DbFree(db, p->aColName);
  
// ABS Label 1152
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}
sqlite3DbFree(db, p->zSql);
#ifdef SQLITE_ENABLE_NORMALIZE
  sqlite3DbFree(db, p->zNormSql);
  {
    DblquoteStr *pThis, *pNext;
    for(pThis=p->pDblStr; pThis; pThis=pNext){
      pNext = pThis->pNextStr;
      sqlite3DbFree(db, pThis);
    }
  }
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
  {
    int i;
    for(i=0; i<p->nScan; i++){
      sqlite3DbFree(db, p->aScan[i].zName);
    }
    sqlite3DbFree(db, p->aScan);
  }
#endif
}

/*
** Delete an entire VDBE.
*/
void sqlite3VdbeDelete(Vdbe *p){
  sqlite3 *db;

  assert( p!=0 );
  db = p->db;
  assert( sqlite3_mutex_held(db->mutex) );
  
// ABS Label 1165
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1165);
}

// ABS Label 1166
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1166);
}
sqlite3VdbeClearObject(db, p);
  
// ABS Label 1168
if(p->pPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1168);
}
if( p->pPrev ){
    p->pPrev->pNext = p->pNext;
  }else{
    assert( db->pVdbe==p );
    db->pVdbe = p->pNext;
  }
  
// ABS Label 1169
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1169);
}
if( p->pNext ){
    p->pNext->pPrev = p->pPrev;
  }
  p->iVdbeMagic = VDBE_MAGIC_DEAD;
  p->db = 0;
  
// ABS Label 1167
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1167);
}
sqlite3DbFreeNN(db, p);
}

/*
** The cursor "p" has a pending seek operation that has not yet been
** carried out.  Seek the cursor now.  If an error occurs, return
** the appropriate error code.
*/
int SQLITE_NOINLINE sqlite3VdbeFinishMoveto(VdbeCursor *p){
  int res, rc;
#ifdef SQLITE_TEST
  extern int sqlite3_search_count;
#endif
  assert( p->deferredMoveto );
  assert( p->isTable );
  assert( p->eCurType==CURTYPE_BTREE );
  rc = sqlite3BtreeTableMoveto(p->uc.pCursor, p->movetoTarget, 0, &res);
  
// ABS Label 1170
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1170);
}
if( rc ) { 
// ABS Label 1171
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1171);
}
return rc;
}
  
// ABS Label 1172
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1172);
}

// ROR Label 1173
if((res == 0) != (res != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1173);
}
if( res!=0 ) { return SQLITE_CORRUPT_BKPT;
}
#ifdef SQLITE_TEST
  sqlite3_search_count++;
#endif
  p->deferredMoveto = 0;
  p->cacheStatus = CACHE_STALE;
  return SQLITE_OK;
}

/*
** Something has moved cursor "p" out of place.  Maybe the row it was
** pointed to was deleted out from under it.  Or maybe the btree was
** rebalanced.  Whatever the cause, try to restore "p" to the place it
** is supposed to be pointing.  If the row was deleted out from under the
** cursor, set the cursor to point to a NULL row.
*/
static int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p){
  int isDifferentRow, rc;
  assert( p->eCurType==CURTYPE_BTREE );
  assert( p->uc.pCursor!=0 );
  assert( sqlite3BtreeCursorHasMoved(p->uc.pCursor) );
  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);
  p->cacheStatus = CACHE_STALE;
  
// ABS Label 1174
if(isDifferentRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1174);
}
if( isDifferentRow ) { p->nullRow = 1;
}
  
// ABS Label 1175
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}
return rc;
}

/*
** Check to ensure that the cursor is valid.  Restore the cursor
** if need be.  Return any I/O error from the restore operation.
*/
int sqlite3VdbeCursorRestore(VdbeCursor *p){
  assert( p->eCurType==CURTYPE_BTREE );
  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){
    return handleMovedCursor(p);
  }
  return SQLITE_OK;
}

/*
** Make sure the cursor p is ready to read or write the row to which it
** was last positioned.  Return an error code if an OOM fault or I/O error
** prevents us from positioning the cursor to its correct position.
**
** If a MoveTo operation is pending on the given cursor, then do that
** MoveTo now.  If no move is pending, check to see if the row has been
** deleted out from under the cursor and if it has, mark the row as
** a NULL row.
**
** If the cursor is already pointing to the correct row and that row has
** not been deleted out from under the cursor, then this routine is a no-op.
*/
int sqlite3VdbeCursorMoveto(VdbeCursor **pp, u32 *piCol){
  
// ABS Label 1176
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1176);
}
VdbeCursor *p = *pp;
  assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );
  
// ABS Label 1177
if(p->deferredMoveto < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1177);
}
if( p->deferredMoveto ){
    u32 iMap;
    assert( !p->isEphemeral );
    if( p->aAltMap && (iMap = p->aAltMap[1+*piCol])>0 && !p->nullRow ){
      *pp = p->pAltCursor;
      *piCol = iMap - 1;
      return SQLITE_OK;
    }
    return sqlite3VdbeFinishMoveto(p);
  }
  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){
    return handleMovedCursor(p);
  }
  return SQLITE_OK;
}

/*
** The following functions:
**
** sqlite3VdbeSerialType()
** sqlite3VdbeSerialTypeLen()
** sqlite3VdbeSerialLen()
** sqlite3VdbeSerialPut()
** sqlite3VdbeSerialGet()
**
** encapsulate the code that serializes values for storage in SQLite
** data and index records. Each serialized value consists of a
** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned
** integer, stored as a varint.
**
** In an SQLite index record, the serial type is stored directly before
** the blob of data that it corresponds to. In a table record, all serial
** types are stored at the start of the record, and the blobs of data at
** the end. Hence these functions allow the caller to handle the
** serial-type and data blob separately.
**
** The following table describes the various storage classes for data:
**
**   serial type        bytes of data      type
**   --------------     ---------------    ---------------
**      0                     0            NULL
**      1                     1            signed integer
**      2                     2            signed integer
**      3                     3            signed integer
**      4                     4            signed integer
**      5                     6            signed integer
**      6                     8            signed integer
**      7                     8            IEEE float
**      8                     0            Integer constant 0
**      9                     0            Integer constant 1
**     10,11                               reserved for expansion
**    N>=12 and even       (N-12)/2        BLOB
**    N>=13 and odd        (N-13)/2        text
**
** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions
** of SQLite will not understand those serial types.
*/

#if 0 /* Inlined into the OP_MakeRecord opcode */
/*
** Return the serial-type for the value stored in pMem.
**
** This routine might convert a large MEM_IntReal value into MEM_Real.
**
** 2019-07-11:  The primary user of this subroutine was the OP_MakeRecord
** opcode in the byte-code engine.  But by moving this routine in-line, we
** can omit some redundant tests and make that opcode a lot faster.  So
** this routine is now only used by the STAT3 logic and STAT3 support has
** ended.  The code is kept here for historical reference only.
*/
u32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){
  int flags = pMem->flags;
  u32 n;

  assert( pLen!=0 );
  if( flags&MEM_Null ){
    *pLen = 0;
    return 0;
  }
  if( flags&(MEM_Int|MEM_IntReal) ){
    /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */
#   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)
    i64 i = pMem->u.i;
    u64 u;
    testcase( flags & MEM_Int );
    testcase( flags & MEM_IntReal );
    if( i<0 ){
      u = ~i;
    }else{
      u = i;
    }
    if( u<=127 ){
      if( (i&1)==i && file_format>=4 ){
        *pLen = 0;
        return 8+(u32)u;
      }else{
        *pLen = 1;
        return 1;
      }
    }
    if( u<=32767 ){ *pLen = 2; return 2; }
    if( u<=8388607 ){ *pLen = 3; return 3; }
    if( u<=2147483647 ){ *pLen = 4; return 4; }
    if( u<=MAX_6BYTE ){ *pLen = 6; return 5; }
    *pLen = 8;
    if( flags&MEM_IntReal ){
      /* If the value is IntReal and is going to take up 8 bytes to store
      ** as an integer, then we might as well make it an 8-byte floating
      ** point value */
      pMem->u.r = (double)pMem->u.i;
      pMem->flags &= ~MEM_IntReal;
      pMem->flags |= MEM_Real;
      return 7;
    }
    return 6;
  }
  if( flags&MEM_Real ){
    *pLen = 8;
    return 7;
  }
  assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) );
  assert( pMem->n>=0 );
  n = (u32)pMem->n;
  if( flags & MEM_Zero ){
    n += pMem->u.nZero;
  }
  *pLen = n;
  return ((n*2) + 12 + ((flags&MEM_Str)!=0));
}
#endif /* inlined into OP_MakeRecord */

/*
** The sizes for serial types less than 128
*/
static const u8 sqlite3SmallTypeSizes[] = {
        /*  0   1   2   3   4   5   6   7   8   9 */   
/*   0 */   0,  1,  2,  3,  4,  6,  8,  8,  0,  0,
/*  10 */   0,  0,  0,  0,  1,  1,  2,  2,  3,  3,
/*  20 */   4,  4,  5,  5,  6,  6,  7,  7,  8,  8,
/*  30 */   9,  9, 10, 10, 11, 11, 12, 12, 13, 13,
/*  40 */  14, 14, 15, 15, 16, 16, 17, 17, 18, 18,
/*  50 */  19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
/*  60 */  24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
/*  70 */  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,
/*  80 */  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
/*  90 */  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,
/* 100 */  44, 44, 45, 45, 46, 46, 47, 47, 48, 48,
/* 110 */  49, 49, 50, 50, 51, 51, 52, 52, 53, 53,
/* 120 */  54, 54, 55, 55, 56, 56, 57, 57
};

/*
** Return the length of the data corresponding to the supplied serial-type.
*/
u32 sqlite3VdbeSerialTypeLen(u32 serial_type){
  
// ABS Label 1178
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1178);
}

// ROR Label 1179
if((serial_type < 128) != (serial_type >= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1179);
}
// ROR Label 1180
if((serial_type > 128) != (serial_type >= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1180);
}
// ROR Label 1181
if((serial_type <= 128) != (serial_type >= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1181);
}
if( serial_type>=128 ){
    
// AOR Label 1182
if((serial_type - 12) - 2 != (serial_type - 12) / 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1182);
}
// AOR Label 1183
if((serial_type - 12) + 2 != (serial_type - 12) / 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1183);
}
// AOR Label 1184
if((serial_type - 12) * 2 != (serial_type - 12) / 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1184);
}
return (serial_type-12)/2;
  }else{
    assert( serial_type<12 
            || sqlite3SmallTypeSizes[serial_type]==(serial_type - 12)/2 );
    return sqlite3SmallTypeSizes[serial_type];
  }
}
u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){
  assert( serial_type<128 );
  
// ABS Label 1185
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}
// ABS Label 1186
if(sqlite3SmallTypeSizes[serial_type] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1186);
}
return sqlite3SmallTypeSizes[serial_type];  
}

/*
** If we are on an architecture with mixed-endian floating 
** points (ex: ARM7) then swap the lower 4 bytes with the 
** upper 4 bytes.  Return the result.
**
** For most architectures, this is a no-op.
**
** (later):  It is reported to me that the mixed-endian problem
** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems
** that early versions of GCC stored the two words of a 64-bit
** float in the wrong order.  And that error has been propagated
** ever since.  The blame is not necessarily with GCC, though.
** GCC might have just copying the problem from a prior compiler.
** I am also told that newer versions of GCC that follow a different
** ABI get the byte order right.
**
** Developers using SQLite on an ARM7 should compile and run their
** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG
** enabled, some asserts below will ensure that the byte order of
** floating point values is correct.
**
** (2007-08-30)  Frank van Vugt has studied this problem closely
** and has send his findings to the SQLite developers.  Frank
** writes that some Linux kernels offer floating point hardware
** emulation that uses only 32-bit mantissas instead of a full 
** 48-bits as required by the IEEE standard.  (This is the
** CONFIG_FPE_FASTFPE option.)  On such systems, floating point
** byte swapping becomes very complicated.  To avoid problems,
** the necessary byte swapping is carried out using a 64-bit integer
** rather than a 64-bit float.  Frank assures us that the code here
** works for him.  We, the developers, have no way to independently
** verify this, but Frank seems to know what he is talking about
** so we trust him.
*/
#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
static u64 floatSwap(u64 in){
  union {
    u64 r;
    u32 i[2];
  } u;
  u32 t;

  u.r = in;
  t = u.i[0];
  u.i[0] = u.i[1];
  u.i[1] = t;
  return u.r;
}
# define swapMixedEndianFloat(X)  X = floatSwap(X)
#else
# define swapMixedEndianFloat(X)
#endif

/*
** Write the serialized data blob for the value stored in pMem into 
** buf. It is assumed that the caller has allocated sufficient space.
** Return the number of bytes written.
**
** nBuf is the amount of space left in buf[].  The caller is responsible
** for allocating enough space to buf[] to hold the entire field, exclusive
** of the pMem->u.nZero bytes for a MEM_Zero value.
**
** Return the number of bytes actually written into buf[].  The number
** of bytes in the zero-filled tail is included in the return value only
** if those bytes were zeroed in buf[].
*/ 
u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){
  u32 len;

  /* Integer and Real */
  
// ABS Label 1187
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}

// COR Label 1188
if((serial_type <= 7 || serial_type > 0) != (serial_type <= 7 && serial_type > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1188);
}

// ROR Label 1189
if((serial_type < 7) != (serial_type <= 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1189);
}
// ROR Label 1190
if((serial_type > 7) != (serial_type <= 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1190);
}
// ROR Label 1191
if((serial_type >= 7) != (serial_type <= 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1191);
}
// ROR Label 1192
if((serial_type <= 0) != (serial_type > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1192);
}
// ROR Label 1193
if((serial_type < 0) != (serial_type > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1193);
}
// ROR Label 1194
if((serial_type >= 0) != (serial_type > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1194);
}

// MCC Label 1195
if(serial_type <= 7 && serial_type > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1195);
}
// MCC Label 1196
if(serial_type <= 7 && !(serial_type > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1196);
}
// MCC Label 1197
if(!(serial_type <= 7) && serial_type > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1197);
}
// MCC Label 1198
if(!(serial_type <= 7) && !(serial_type > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1198);
}
if( serial_type<=7 && serial_type>0 ){
    u64 v;
    u32 i;
    
// ABS Label 1199
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}

// ROR Label 1200
if((serial_type != 7) != (serial_type == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1200);
}
if( serial_type==7 ){
      assert( sizeof(v)==sizeof(pMem->u.r) );
      memcpy(&v, &pMem->u.r, sizeof(v));
      swapMixedEndianFloat(v);
    }else{
      v = pMem->u.i;
    }
    len = i = sqlite3SmallTypeSizes[serial_type];
    assert( i>0 );
    
// ABS Label 1201
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1201);
}
do{
      buf[--i] = (u8)(v&0xFF);
      v >>= 8;
    }while( i );
// ABS Label 1202
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1202);
}
;
    
// ABS Label 1203
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1203);
}
return len;
  }

  /* String or blob */
  
// ABS Label 1204
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1204);
}

// ROR Label 1205
if((serial_type < 12) != (serial_type >= 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1205);
}
// ROR Label 1206
if((serial_type > 12) != (serial_type >= 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1206);
}
// ROR Label 1207
if((serial_type <= 12) != (serial_type >= 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1207);
}
if( serial_type>=12 ){
    assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0)
             == (int)sqlite3VdbeSerialTypeLen(serial_type) );
    len = pMem->n;
    
// ABS Label 1208
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1208);
}

// ROR Label 1209
if((len <= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1209);
}
// ROR Label 1210
if((len < 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1210);
}
// ROR Label 1211
if((len >= 0) != (len > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1211);
}
if( len>0 ) { memcpy(buf, pMem->z, len);
}
    
// ABS Label 1212
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1212);
}
return len;
  }

  /* NULL or constants 0 or 1 */
  return 0;
}

/* Input "x" is a sequence of unsigned characters that represent a
** big-endian integer.  Return the equivalent native integer
*/
#define ONE_BYTE_INT(x)    ((i8)(x)[0])
#define TWO_BYTE_INT(x)    (256*(i8)((x)[0])|(x)[1])
#define THREE_BYTE_INT(x)  (65536*(i8)((x)[0])|((x)[1]<<8)|(x)[2])
#define FOUR_BYTE_UINT(x)  (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
#define FOUR_BYTE_INT(x) (16777216*(i8)((x)[0])|((x)[1]<<16)|((x)[2]<<8)|(x)[3])

/*
** Deserialize the data blob pointed to by buf as serial type serial_type
** and store the result in pMem.  Return the number of bytes read.
**
** This function is implemented as two separate routines for performance.
** The few cases that require local variables are broken out into a separate
** routine so that in most cases the overhead of moving the stack pointer
** is avoided.
*/ 
static u32 serialGet(
  const unsigned char *buf,     /* Buffer to deserialize from */
  u32 serial_type,              /* Serial type to deserialize */
  Mem *pMem                     /* Memory cell to write value into */
){
  u64 x = FOUR_BYTE_UINT(buf);
  u32 y = FOUR_BYTE_UINT(buf+4);
  x = (x<<32) + y;
  
// ABS Label 1213
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1213);
}

// ROR Label 1214
if((serial_type != 6) != (serial_type == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1214);
}
if( serial_type==6 ){
    /* EVIDENCE-OF: R-29851-52272 Value is a big-endian 64-bit
    ** twos-complement integer. */
    pMem->u.i = *(i64*)&x;
    pMem->flags = MEM_Int;
    testcase( pMem->u.i<0 );
  }else{
    /* EVIDENCE-OF: R-57343-49114 Value is a big-endian IEEE 754-2008 64-bit
    ** floating point number. */
#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)
    /* Verify that integers and floating point values use the same
    ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is
    ** defined that 64-bit floating point values really are mixed
    ** endian.
    */
    static const u64 t1 = ((u64)0x3ff00000)<<32;
    static const double r1 = 1.0;
    u64 t2 = t1;
    swapMixedEndianFloat(t2);
    assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );
#endif
    assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );
    swapMixedEndianFloat(x);
    memcpy(&pMem->u.r, &x, sizeof(x));
    pMem->flags = IsNaN(x) ? MEM_Null : MEM_Real;
  }
  return 8;
}
u32 sqlite3VdbeSerialGet(
  const unsigned char *buf,     /* Buffer to deserialize from */
  u32 serial_type,              /* Serial type to deserialize */
  Mem *pMem                     /* Memory cell to write value into */
){
  switch( serial_type ){
    case 10: { /* Internal use only: NULL with virtual table
               ** UPDATE no-change flag set */
      pMem->flags = MEM_Null|MEM_Zero;
      pMem->n = 0;
      pMem->u.nZero = 0;
      break;
    }
    case 11:   /* Reserved for future use */
    case 0: {  /* Null */
      /* EVIDENCE-OF: R-24078-09375 Value is a NULL. */
      pMem->flags = MEM_Null;
      break;
    }
    case 1: {
      /* EVIDENCE-OF: R-44885-25196 Value is an 8-bit twos-complement
      ** integer. */
      pMem->u.i = ONE_BYTE_INT(buf);
      pMem->flags = MEM_Int;
      testcase( pMem->u.i<0 );
      return 1;
    }
    case 2: { /* 2-byte signed integer */
      /* EVIDENCE-OF: R-49794-35026 Value is a big-endian 16-bit
      ** twos-complement integer. */
      pMem->u.i = TWO_BYTE_INT(buf);
      pMem->flags = MEM_Int;
      testcase( pMem->u.i<0 );
      return 2;
    }
    case 3: { /* 3-byte signed integer */
      /* EVIDENCE-OF: R-37839-54301 Value is a big-endian 24-bit
      ** twos-complement integer. */
      pMem->u.i = THREE_BYTE_INT(buf);
      pMem->flags = MEM_Int;
      testcase( pMem->u.i<0 );
      return 3;
    }
    case 4: { /* 4-byte signed integer */
      /* EVIDENCE-OF: R-01849-26079 Value is a big-endian 32-bit
      ** twos-complement integer. */
      pMem->u.i = FOUR_BYTE_INT(buf);
#ifdef __HP_cc 
      /* Work around a sign-extension bug in the HP compiler for HP/UX */
      if( buf[0]&0x80 ) pMem->u.i |= 0xffffffff80000000LL;
#endif
      pMem->flags = MEM_Int;
      testcase( pMem->u.i<0 );
      return 4;
    }
    case 5: { /* 6-byte signed integer */
      /* EVIDENCE-OF: R-50385-09674 Value is a big-endian 48-bit
      ** twos-complement integer. */
      pMem->u.i = FOUR_BYTE_UINT(buf+2) + (((i64)1)<<32)*TWO_BYTE_INT(buf);
      pMem->flags = MEM_Int;
      testcase( pMem->u.i<0 );
      return 6;
    }
    case 6:   /* 8-byte signed integer */
    case 7: { /* IEEE floating point */
      /* These use local variables, so do them in a separate routine
      ** to avoid having to move the frame pointer in the common case */
      return serialGet(buf,serial_type,pMem);
    }
    case 8:    /* Integer 0 */
    case 9: {  /* Integer 1 */
      /* EVIDENCE-OF: R-12976-22893 Value is the integer 0. */
      /* EVIDENCE-OF: R-18143-12121 Value is the integer 1. */
      pMem->u.i = serial_type-8;
      pMem->flags = MEM_Int;
      return 0;
    }
    default: {
      /* EVIDENCE-OF: R-14606-31564 Value is a BLOB that is (N-12)/2 bytes in
      ** length.
      ** EVIDENCE-OF: R-28401-00140 Value is a string in the text encoding and
      ** (N-13)/2 bytes in length. */
      static const u16 aFlag[] = { MEM_Blob|MEM_Ephem, MEM_Str|MEM_Ephem };
      pMem->z = (char *)buf;
      pMem->n = (serial_type-12)/2;
      pMem->flags = aFlag[serial_type&1];
      return pMem->n;
    }
  }
  return 0;
}
/*
** This routine is used to allocate sufficient space for an UnpackedRecord
** structure large enough to be used with sqlite3VdbeRecordUnpack() if
** the first argument is a pointer to KeyInfo structure pKeyInfo.
**
** The space is either allocated using sqlite3DbMallocRaw() or from within
** the unaligned buffer passed via the second and third arguments (presumably
** stack space). If the former, then *ppFree is set to a pointer that should
** be eventually freed by the caller using sqlite3DbFree(). Or, if the 
** allocation comes from the pSpace/szSpace buffer, *ppFree is set to NULL
** before returning.
**
** If an OOM error occurs, NULL is returned.
*/
UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(
  KeyInfo *pKeyInfo               /* Description of the record */
){
  UnpackedRecord *p;              /* Unpacked record to return */
  int nByte;                      /* Number of bytes required for *p */
  nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);
  p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);
  if( !p ) { return 0;
}
  p->aMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];
  assert( pKeyInfo->aSortFlags!=0 );
  p->pKeyInfo = pKeyInfo;
  p->nField = pKeyInfo->nKeyField + 1;
  
// ABS Label 1215
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1215);
}
return p;
}

/*
** Given the nKey-byte encoding of a record in pKey[], populate the 
** UnpackedRecord structure indicated by the fourth argument with the
** contents of the decoded record.
*/ 
void sqlite3VdbeRecordUnpack(
  KeyInfo *pKeyInfo,     /* Information about the record format */
  int nKey,              /* Size of the binary record */
  const void *pKey,      /* The binary record */
  UnpackedRecord *p      /* Populate this structure before returning. */
){
  const unsigned char *aKey = (const unsigned char *)pKey;
  u32 d; 
  u32 idx;                        /* Offset in aKey[] to read from */
  u16 u;                          /* Unsigned loop counter */
  u32 szHdr;
  
// ABS Label 1216
if(p->aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1216);
}
Mem *pMem = p->aMem;

  p->default_rc = 0;
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );
  idx = getVarint32(aKey, szHdr);
  d = szHdr;
  u = 0;
  
// ABS Label 1217
if(d < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1217);
}
// ABS Label 1218
if(idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1218);
}
// ABS Label 1219
if(szHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1219);
}

// COR Label 1220
if((idx < szHdr || d <= (u32)nKey) != (idx < szHdr && d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1220);
}

// ROR Label 1221
if((idx <= szHdr) != (idx < szHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1221);
}
// ROR Label 1222
if((idx > szHdr) != (idx < szHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1222);
}
// ROR Label 1223
if((idx >= szHdr) != (idx < szHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1223);
}
// ROR Label 1224
if((d < (u32)nKey) != (d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1224);
}
// ROR Label 1225
if((d > (u32)nKey) != (d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1225);
}
// ROR Label 1226
if((d >= (u32)nKey) != (d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1226);
}

// MCC Label 1227
if(idx < szHdr && d <= (u32)nKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1227);
}
// MCC Label 1228
if(idx < szHdr && !(d <= (u32)nKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1228);
}
// MCC Label 1229
if(!(idx < szHdr) && d <= (u32)nKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1229);
}
// MCC Label 1230
if(!(idx < szHdr) && !(d <= (u32)nKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1230);
}
while( idx<szHdr && d<=(u32)nKey ){
    u32 serial_type;

    idx += getVarint32(&aKey[idx], serial_type);
    pMem->enc = pKeyInfo->enc;
    pMem->db = pKeyInfo->db;
    /* pMem->flags = 0; // sqlite3VdbeSerialGet() will set this for us */
    pMem->szMalloc = 0;
    pMem->z = 0;
    d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);
    pMem++;
    if( (++u)>=p->nField ) { break;
}
  };
// ABS Label 1231
if(d < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1231);
}
// ABS Label 1232
if(idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1232);
}
// ABS Label 1233
if(szHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1233);
}

// COR Label 1234
if((idx < szHdr || d <= (u32)nKey) != (idx < szHdr && d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1234);
}

// ROR Label 1235
if((idx <= szHdr) != (idx < szHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1235);
}
// ROR Label 1236
if((idx > szHdr) != (idx < szHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1236);
}
// ROR Label 1237
if((idx >= szHdr) != (idx < szHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1237);
}
// ROR Label 1238
if((d < (u32)nKey) != (d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1238);
}
// ROR Label 1239
if((d > (u32)nKey) != (d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1239);
}
// ROR Label 1240
if((d >= (u32)nKey) != (d <= (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1240);
}

// MCC Label 1241
if(idx < szHdr && d <= (u32)nKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1241);
}
// MCC Label 1242
if(idx < szHdr && !(d <= (u32)nKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1242);
}
// MCC Label 1243
if(!(idx < szHdr) && d <= (u32)nKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1243);
}
// MCC Label 1244
if(!(idx < szHdr) && !(d <= (u32)nKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1244);
}

  
// ABS Label 1245
if(d < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1245);
}

// COR Label 1246
if((d > (u32)nKey || u) != (d > (u32)nKey && u))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1246);
}

// ROR Label 1247
if((d <= (u32)nKey) != (d > (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1247);
}
// ROR Label 1248
if((d < (u32)nKey) != (d > (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1248);
}
// ROR Label 1249
if((d >= (u32)nKey) != (d > (u32)nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1249);
}

// MCC Label 1250
if(d > (u32)nKey && u ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1250);
}
// MCC Label 1251
if(d > (u32)nKey && !(u) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1251);
}
// MCC Label 1252
if(!(d > (u32)nKey) && u ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1252);
}
// MCC Label 1253
if(!(d > (u32)nKey) && !(u) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1253);
}
if( d>(u32)nKey && u ){
    assert( CORRUPT_DB );
    /* In a corrupt record entry, the last pMem might have been set up using 
    ** uninitialized memory. Overwrite its value with NULL, to prevent
    ** warnings from MSAN. */
    
// ABS Label 1254
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1254);
}

// AOR Label 1255
if(pMem / 1 != pMem - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1255);
}
// AOR Label 1256
if(pMem + 1 != pMem - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1256);
}
// AOR Label 1257
if(pMem * 1 != pMem - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1257);
}
sqlite3VdbeMemSetNull(pMem-1);
  }
  assert( u<=pKeyInfo->nKeyField + 1 );
  p->nField = u;
}

#ifdef SQLITE_DEBUG
/*
** This function compares two index or table record keys in the same way
** as the sqlite3VdbeRecordCompare() routine. Unlike VdbeRecordCompare(),
** this function deserializes and compares values using the
** sqlite3VdbeSerialGet() and sqlite3MemCompare() functions. It is used
** in assert() statements to ensure that the optimized code in
** sqlite3VdbeRecordCompare() returns results with these two primitives.
**
** Return true if the result of comparison is equivalent to desiredResult.
** Return false if there is a disagreement.
*/
static int vdbeRecordCompareDebug(
  int nKey1, const void *pKey1, /* Left key */
  const UnpackedRecord *pPKey2, /* Right key */
  int desiredResult             /* Correct answer */
){
  u32 d1;            /* Offset into aKey[] of next data element */
  u32 idx1;          /* Offset into aKey[] of next header element */
  u32 szHdr1;        /* Number of bytes in header */
  int i = 0;
  int rc = 0;
  const unsigned char *aKey1 = (const unsigned char *)pKey1;
  KeyInfo *pKeyInfo;
  Mem mem1;

  pKeyInfo = pPKey2->pKeyInfo;
  if( pKeyInfo->db==0 ) return 1;
  mem1.enc = pKeyInfo->enc;
  mem1.db = pKeyInfo->db;
  /* mem1.flags = 0;  // Will be initialized by sqlite3VdbeSerialGet() */
  VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */

  /* Compilers may complain that mem1.u.i is potentially uninitialized.
  ** We could initialize it, as shown here, to silence those complaints.
  ** But in fact, mem1.u.i will never actually be used uninitialized, and doing 
  ** the unnecessary initialization has a measurable negative performance
  ** impact, since this routine is a very high runner.  And so, we choose
  ** to ignore the compiler warnings and leave this variable uninitialized.
  */
  /*  mem1.u.i = 0;  // not needed, here to silence compiler warning */
  
  idx1 = getVarint32(aKey1, szHdr1);
  if( szHdr1>98307 ) return SQLITE_CORRUPT;
  d1 = szHdr1;
  assert( pKeyInfo->nAllField>=pPKey2->nField || CORRUPT_DB );
  assert( pKeyInfo->aSortFlags!=0 );
  assert( pKeyInfo->nKeyField>0 );
  assert( idx1<=szHdr1 || CORRUPT_DB );
  do{
    u32 serial_type1;

    /* Read the serial types for the next element in each key. */
    idx1 += getVarint32( aKey1+idx1, serial_type1 );

    /* Verify that there is enough key space remaining to avoid
    ** a buffer overread.  The "d1+serial_type1+2" subexpression will
    ** always be greater than or equal to the amount of required key space.
    ** Use that approximation to avoid the more expensive call to
    ** sqlite3VdbeSerialTypeLen() in the common case.
    */
    if( d1+(u64)serial_type1+2>(u64)nKey1
     && d1+(u64)sqlite3VdbeSerialTypeLen(serial_type1)>(u64)nKey1 
    ){
      break;
    }

    /* Extract the values to be compared.
    */
    d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);

    /* Do the comparison
    */
    rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],
                           pKeyInfo->nAllField>i ? pKeyInfo->aColl[i] : 0);
    if( rc!=0 ){
      assert( mem1.szMalloc==0 );  /* See comment below */
      if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)
       && ((mem1.flags & MEM_Null) || (pPKey2->aMem[i].flags & MEM_Null)) 
      ){
        rc = -rc;
      }
      if( pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC ){
        rc = -rc;  /* Invert the result for DESC sort order. */
      }
      goto debugCompareEnd;
    }
    i++;
  }while( idx1<szHdr1 && i<pPKey2->nField );

  /* No memory allocation is ever used on mem1.  Prove this using
  ** the following assert().  If the assert() fails, it indicates a
  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).
  */
  assert( mem1.szMalloc==0 );

  /* rc==0 here means that one of the keys ran out of fields and
  ** all the fields up to that point were equal. Return the default_rc
  ** value.  */
  rc = pPKey2->default_rc;

debugCompareEnd:
  if( desiredResult==0 && rc==0 ) return 1;
  if( desiredResult<0 && rc<0 ) return 1;
  if( desiredResult>0 && rc>0 ) return 1;
  if( CORRUPT_DB ) return 1;
  if( pKeyInfo->db->mallocFailed ) return 1;
  return 0;
}
#endif

#ifdef SQLITE_DEBUG
/*
** Count the number of fields (a.k.a. columns) in the record given by
** pKey,nKey.  The verify that this count is less than or equal to the
** limit given by pKeyInfo->nAllField.
**
** If this constraint is not satisfied, it means that the high-speed
** vdbeRecordCompareInt() and vdbeRecordCompareString() routines will
** not work correctly.  If this assert() ever fires, it probably means
** that the KeyInfo.nKeyField or KeyInfo.nAllField values were computed
** incorrectly.
*/
static void vdbeAssertFieldCountWithinLimits(
  int nKey, const void *pKey,   /* The record to verify */ 
  const KeyInfo *pKeyInfo       /* Compare size with this KeyInfo */
){
  int nField = 0;
  u32 szHdr;
  u32 idx;
  u32 notUsed;
  const unsigned char *aKey = (const unsigned char*)pKey;

  if( CORRUPT_DB ) return;
  idx = getVarint32(aKey, szHdr);
  assert( nKey>=0 );
  assert( szHdr<=(u32)nKey );
  while( idx<szHdr ){
    idx += getVarint32(aKey+idx, notUsed);
    nField++;
  }
  assert( nField <= pKeyInfo->nAllField );
}
#else
# define vdbeAssertFieldCountWithinLimits(A,B,C)
#endif

/*
** Both *pMem1 and *pMem2 contain string values. Compare the two values
** using the collation sequence pColl. As usual, return a negative , zero
** or positive value if *pMem1 is less than, equal to or greater than 
** *pMem2, respectively. Similar in spirit to "rc = (*pMem1) - (*pMem2);".
*/
static int vdbeCompareMemString(
  const Mem *pMem1,
  const Mem *pMem2,
  const CollSeq *pColl,
  u8 *prcErr                      /* If an OOM occurs, set to SQLITE_NOMEM */
){
  
// ROR Label 1258
if((pMem1->enc != pColl->enc) != (pMem1->enc == pColl->enc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1258);
}
if( pMem1->enc==pColl->enc ){
    /* The strings are already in the correct encoding.  Call the
     ** comparison function directly */
    return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);
  }else{
    int rc;
    const void *v1, *v2;
    Mem c1;
    Mem c2;
    
// ABS Label 1259
if(pMem1->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1259);
}
sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);
    
// ABS Label 1260
if(pMem1->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1260);
}
sqlite3VdbeMemInit(&c2, pMem1->db, MEM_Null);
    
// ABS Label 1261
if(pMem1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1261);
}
sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);
    
// ABS Label 1262
if(pMem2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1262);
}
sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);
    v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
    v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
    
// MCC Label 1263
if(( v1 == 0 && v2 == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1263);
}
// MCC Label 1264
if(( v1 == 0 && !(v2 == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1264);
}
// MCC Label 1265
if(( !(v1 == 0) && v2 == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1265);
}
// MCC Label 1266
if(( !(v1 == 0) && !(v2 == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1266);
}
if( (v1==0 || v2==0) ){
      
// ABS Label 1267
if(prcErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1267);
}
if( prcErr ) { *prcErr = SQLITE_NOMEM_BKPT;
}
      rc = 0;
    }else{
      rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);
    }
    sqlite3VdbeMemRelease(&c1);
    sqlite3VdbeMemRelease(&c2);
    
// ABS Label 1268
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1268);
}
return rc;
  }
}

/*
** The input pBlob is guaranteed to be a Blob that is not marked
** with MEM_Zero.  Return true if it could be a zero-blob.
*/
static int isAllZero(const char *z, int n){
  int i;
  i = 0;

// ABS Label 1269
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1269);
}
// ABS Label 1270
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1270);
}

// ROR Label 1271
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1271);
}
// ROR Label 1272
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1272);
}
// ROR Label 1273
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1273);
}
for(; i<n; i++){
    
// ABS Label 1279
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1279);
}
// ABS Label 1280
if(z[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1280);
}
if( z[i] ) { return 0;
}
  };
// ABS Label 1274
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1274);
}
// ABS Label 1275
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1275);
}

// ROR Label 1276
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1276);
}
// ROR Label 1277
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1277);
}
// ROR Label 1278
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1278);
}

  return 1;
}

/*
** Compare two blobs.  Return negative, zero, or positive if the first
** is less than, equal to, or greater than the second, respectively.
** If one blob is a prefix of the other, then the shorter is the lessor.
*/
SQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){
  int c;
  
// ABS Label 1281
if(pB1->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1281);
}
int n1 = pB1->n;
  
// ABS Label 1282
if(pB2->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1282);
}
int n2 = pB2->n;

  /* It is possible to have a Blob value that has some non-zero content
  ** followed by zero content.  But that only comes up for Blobs formed
  ** by the OP_MakeRecord opcode, and such Blobs never get passed into
  ** sqlite3MemCompare(). */
  assert( (pB1->flags & MEM_Zero)==0 || n1==0 );
  assert( (pB2->flags & MEM_Zero)==0 || n2==0 );

  
// AOR Label 1283
if((pB1->flags | pB2->flags) | 16384 != (pB1->flags | pB2->flags) & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1283);
}
// AOR Label 1284
if((pB1->flags | pB2->flags) ^ 16384 != (pB1->flags | pB2->flags) & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1284);
}
if( (pB1->flags|pB2->flags) & MEM_Zero ){
    
// AOR Label 1285
if(pB1->flags & pB2->flags | 16384 != pB1->flags & pB2->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1285);
}
// AOR Label 1286
if(pB1->flags & pB2->flags ^ 16384 != pB1->flags & pB2->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1286);
}
// AOR Label 1287
if(pB1->flags | pB2->flags != pB1->flags & pB2->flags)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1287);
}
// AOR Label 1288
if(pB1->flags ^ pB2->flags != pB1->flags & pB2->flags)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1288);
}
if( pB1->flags & pB2->flags & MEM_Zero ){
      
// ABS Label 1289
if(pB1->u.nZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1289);
}
// ABS Label 1290
if(pB2->u.nZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1290);
}

// AOR Label 1291
if(pB1->u.nZero / pB2->u.nZero != pB1->u.nZero - pB2->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1291);
}
// AOR Label 1292
if(pB1->u.nZero + pB2->u.nZero != pB1->u.nZero - pB2->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1292);
}
// AOR Label 1293
if(pB1->u.nZero * pB2->u.nZero != pB1->u.nZero - pB2->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1293);
}
return pB1->u.nZero - pB2->u.nZero;
    }else { 
// AOR Label 1294
if(pB1->flags | 16384 != pB1->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1294);
}
// AOR Label 1295
if(pB1->flags ^ 16384 != pB1->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1295);
}
if( pB1->flags & MEM_Zero ){
      if( !isAllZero(pB2->z, pB2->n) ) { return -1;
}
      
// ABS Label 1296
if(n2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1296);
}
// ABS Label 1297
if(pB1->u.nZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1297);
}

// AOR Label 1298
if(pB1->u.nZero / n2 != pB1->u.nZero - n2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1298);
}
// AOR Label 1299
if(pB1->u.nZero + n2 != pB1->u.nZero - n2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1299);
}
// AOR Label 1300
if(pB1->u.nZero * n2 != pB1->u.nZero - n2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1300);
}
return pB1->u.nZero - n2;
    }else{
      if( !isAllZero(pB1->z, pB1->n) ) { return +1;
}
      
// ABS Label 1301
if(n1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1301);
}
// ABS Label 1302
if(pB2->u.nZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1302);
}

// AOR Label 1303
if(n1 / pB2->u.nZero != n1 - pB2->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1303);
}
// AOR Label 1304
if(n1 + pB2->u.nZero != n1 - pB2->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1304);
}
// AOR Label 1305
if(n1 * pB2->u.nZero != n1 - pB2->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1305);
}
return n1 - pB2->u.nZero;
    };}

  }
  c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);
  
// ABS Label 1306
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1306);
}
if( c ) { 
// ABS Label 1307
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1307);
}
return c;
}
  
// ABS Label 1308
if(n1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1308);
}
// ABS Label 1309
if(n2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1309);
}

// AOR Label 1310
if(n1 / n2 != n1 - n2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1310);
}
// AOR Label 1311
if(n1 + n2 != n1 - n2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1311);
}
// AOR Label 1312
if(n1 * n2 != n1 - n2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1312);
}
return n1 - n2;
}

/*
** Do a comparison between a 64-bit signed integer and a 64-bit floating-point
** number.  Return negative, zero, or positive if the first (i64) is less than,
** equal to, or greater than the second (double).
*/
static int sqlite3IntFloatCompare(i64 i, double r){
  
// ROR Label 1313
if((sizeof(long double) <= 8) != (sizeof(long double) > 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1313);
}
// ROR Label 1314
if((sizeof(long double) < 8) != (sizeof(long double) > 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1314);
}
// ROR Label 1315
if((sizeof(long double) >= 8) != (sizeof(long double) > 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1315);
}
if( sizeof(LONGDOUBLE_TYPE)>8 ){
    LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;
    testcase( x<r );
    testcase( x>r );
    testcase( x==r );
    
// ABS Label 1316
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1316);
}

// ROR Label 1317
if((x <= r) != (x < r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1317);
}
// ROR Label 1318
if((x > r) != (x < r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1318);
}
// ROR Label 1319
if((x >= r) != (x < r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1319);
}
if( x<r ) { return -1;
}
    
// ABS Label 1320
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1320);
}

// ROR Label 1321
if((x <= r) != (x > r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1321);
}
// ROR Label 1322
if((x < r) != (x > r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1322);
}
// ROR Label 1323
if((x >= r) != (x > r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1323);
}
if( x>r ) { return +1;  /*NO_TEST*/ /* work around bugs in gcov */
}
    return 0;             /*NO_TEST*/ /* work around bugs in gcov */
  }else{
    i64 y;
    double s;
    
// ABS Label 1324
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1324);
}

// ROR Label 1325
if((r <= -9.2233720368547758E+18) != (r < -9.2233720368547758E+18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1325);
}
// ROR Label 1326
if((r > -9.2233720368547758E+18) != (r < -9.2233720368547758E+18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1326);
}
// ROR Label 1327
if((r >= -9.2233720368547758E+18) != (r < -9.2233720368547758E+18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1327);
}
if( r<-9223372036854775808.0 ) { return +1;
}
    
// ABS Label 1328
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1328);
}

// ROR Label 1329
if((r < 9.2233720368547758E+18) != (r >= 9.2233720368547758E+18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1329);
}
// ROR Label 1330
if((r > 9.2233720368547758E+18) != (r >= 9.2233720368547758E+18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1330);
}
// ROR Label 1331
if((r <= 9.2233720368547758E+18) != (r >= 9.2233720368547758E+18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1331);
}
if( r>=9223372036854775808.0 ) { return -1;
}
    y = (i64)r;
    
// ABS Label 1332
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1332);
}
// ABS Label 1333
if(y < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1333);
}

// ROR Label 1334
if((i <= y) != (i < y))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1334);
}
// ROR Label 1335
if((i > y) != (i < y))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1335);
}
// ROR Label 1336
if((i >= y) != (i < y))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1336);
}
if( i<y ) { return -1;
}
    
// ABS Label 1337
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1337);
}
// ABS Label 1338
if(y < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1338);
}

// ROR Label 1339
if((i <= y) != (i > y))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1339);
}
// ROR Label 1340
if((i < y) != (i > y))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1340);
}
// ROR Label 1341
if((i >= y) != (i > y))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1341);
}
if( i>y ) { return +1;
}
    s = (double)i;
    
// ABS Label 1342
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1342);
}
// ABS Label 1343
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1343);
}

// ROR Label 1344
if((s <= r) != (s < r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1344);
}
// ROR Label 1345
if((s > r) != (s < r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1345);
}
// ROR Label 1346
if((s >= r) != (s < r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1346);
}
if( s<r ) { return -1;
}
    
// ABS Label 1347
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1347);
}
// ABS Label 1348
if(s < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1348);
}

// ROR Label 1349
if((s <= r) != (s > r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1349);
}
// ROR Label 1350
if((s < r) != (s > r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1350);
}
// ROR Label 1351
if((s >= r) != (s > r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1351);
}
if( s>r ) { return +1;
}
    return 0;
  }
}

/*
** Compare the values contained by the two memory cells, returning
** negative, zero or positive if pMem1 is less than, equal to, or greater
** than pMem2. Sorting order is NULL's first, followed by numbers (integers
** and reals) sorted numerically, followed by text ordered by the collating
** sequence pColl and finally blob's ordered by memcmp().
**
** Two NULL values are considered equal by this function.
*/
int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){
  int f1, f2;
  int combined_flags;

  f1 = pMem1->flags;
  f2 = pMem2->flags;
  combined_flags = f1|f2;
  assert( !sqlite3VdbeMemIsRowSet(pMem1) && !sqlite3VdbeMemIsRowSet(pMem2) );
 
  /* If one value is NULL, it is less than the other. If both values
  ** are NULL, return 0.
  */
  
// ABS Label 1352
if(combined_flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}

// AOR Label 1353
if(combined_flags | 1 != combined_flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1353);
}
// AOR Label 1354
if(combined_flags ^ 1 != combined_flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1354);
}
if( combined_flags&MEM_Null ){
    
// AOR Label 1355
if((f2 & 1) / (f1 & 1) != (f2 & 1) - (f1 & 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1355);
}
// AOR Label 1356
if((f2 & 1) + (f1 & 1) != (f2 & 1) - (f1 & 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1356);
}
// AOR Label 1357
if((f2 & 1) * (f1 & 1) != (f2 & 1) - (f1 & 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1357);
}
return (f2&MEM_Null) - (f1&MEM_Null);
  }

  /* At least one of the two values is a number
  */
  
// ABS Label 1358
if(combined_flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1358);
}

// AOR Label 1359
if(combined_flags | (4 | 8 | 32) != combined_flags & (4 | 8 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1359);
}
// AOR Label 1360
if(combined_flags ^ (4 | 8 | 32) != combined_flags & (4 | 8 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1360);
}
if( combined_flags&(MEM_Int|MEM_Real|MEM_IntReal) ){
    testcase( combined_flags & MEM_Int );
    testcase( combined_flags & MEM_Real );
    testcase( combined_flags & MEM_IntReal );
    
// ROR Label 1361
if(((f1 & f2 & (4 | 32)) == 0) != ((f1 & f2 & (4 | 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1361);
}
if( (f1 & f2 & (MEM_Int|MEM_IntReal))!=0 ){
      testcase( f1 & f2 & MEM_Int );
      testcase( f1 & f2 & MEM_IntReal );
      
// ABS Label 1362
if(pMem1->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1362);
}
// ABS Label 1363
if(pMem2->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1363);
}

// ROR Label 1364
if((pMem1->u.i <= pMem2->u.i) != (pMem1->u.i < pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1364);
}
// ROR Label 1365
if((pMem1->u.i > pMem2->u.i) != (pMem1->u.i < pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1365);
}
// ROR Label 1366
if((pMem1->u.i >= pMem2->u.i) != (pMem1->u.i < pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1366);
}
if( pMem1->u.i < pMem2->u.i ) { return -1;
}
      
// ABS Label 1367
if(pMem1->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1367);
}
// ABS Label 1368
if(pMem2->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1368);
}

// ROR Label 1369
if((pMem1->u.i <= pMem2->u.i) != (pMem1->u.i > pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1369);
}
// ROR Label 1370
if((pMem1->u.i < pMem2->u.i) != (pMem1->u.i > pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1370);
}
// ROR Label 1371
if((pMem1->u.i >= pMem2->u.i) != (pMem1->u.i > pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1371);
}
if( pMem1->u.i > pMem2->u.i ) { return +1;
}
      return 0;
    }
    
// ROR Label 1372
if(((f1 & f2 & 8) == 0) != ((f1 & f2 & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1372);
}
if( (f1 & f2 & MEM_Real)!=0 ){
      
// ABS Label 1373
if(pMem1->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1373);
}
// ABS Label 1374
if(pMem2->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1374);
}

// ROR Label 1375
if((pMem1->u.r <= pMem2->u.r) != (pMem1->u.r < pMem2->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1375);
}
// ROR Label 1376
if((pMem1->u.r > pMem2->u.r) != (pMem1->u.r < pMem2->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1376);
}
// ROR Label 1377
if((pMem1->u.r >= pMem2->u.r) != (pMem1->u.r < pMem2->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1377);
}
if( pMem1->u.r < pMem2->u.r ) { return -1;
}
      
// ABS Label 1378
if(pMem1->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1378);
}
// ABS Label 1379
if(pMem2->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1379);
}

// ROR Label 1380
if((pMem1->u.r <= pMem2->u.r) != (pMem1->u.r > pMem2->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1380);
}
// ROR Label 1381
if((pMem1->u.r < pMem2->u.r) != (pMem1->u.r > pMem2->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1381);
}
// ROR Label 1382
if((pMem1->u.r >= pMem2->u.r) != (pMem1->u.r > pMem2->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1382);
}
if( pMem1->u.r > pMem2->u.r ) { return +1;
}
      return 0;
    }
    
// ROR Label 1383
if(((f1 & (4 | 32)) == 0) != ((f1 & (4 | 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1383);
}
if( (f1&(MEM_Int|MEM_IntReal))!=0 ){
      testcase( f1 & MEM_Int );
      testcase( f1 & MEM_IntReal );
      
// ROR Label 1384
if(((f2 & 8) == 0) != ((f2 & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1384);
}
if( (f2&MEM_Real)!=0 ){
        return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);
      }else { 
// ROR Label 1385
if(((f2 & (4 | 32)) == 0) != ((f2 & (4 | 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1385);
}
if( (f2&(MEM_Int|MEM_IntReal))!=0 ){
        
// ABS Label 1386
if(pMem1->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1386);
}
// ABS Label 1387
if(pMem2->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1387);
}

// ROR Label 1388
if((pMem1->u.i <= pMem2->u.i) != (pMem1->u.i < pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1388);
}
// ROR Label 1389
if((pMem1->u.i > pMem2->u.i) != (pMem1->u.i < pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1389);
}
// ROR Label 1390
if((pMem1->u.i >= pMem2->u.i) != (pMem1->u.i < pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1390);
}
if( pMem1->u.i < pMem2->u.i ) { return -1;
}
        
// ABS Label 1391
if(pMem1->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1391);
}
// ABS Label 1392
if(pMem2->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1392);
}

// ROR Label 1393
if((pMem1->u.i <= pMem2->u.i) != (pMem1->u.i > pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1393);
}
// ROR Label 1394
if((pMem1->u.i < pMem2->u.i) != (pMem1->u.i > pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1394);
}
// ROR Label 1395
if((pMem1->u.i >= pMem2->u.i) != (pMem1->u.i > pMem2->u.i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1395);
}
if( pMem1->u.i > pMem2->u.i ) { return +1;
}
        return 0;
      }else{
        return -1;
      };}

    }
    
// ROR Label 1396
if(((f1 & 8) == 0) != ((f1 & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1396);
}
if( (f1&MEM_Real)!=0 ){
      
// ROR Label 1397
if(((f2 & (4 | 32)) == 0) != ((f2 & (4 | 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1397);
}
if( (f2&(MEM_Int|MEM_IntReal))!=0 ){
        testcase( f2 & MEM_Int );
        testcase( f2 & MEM_IntReal );
        return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);
      }else{
        return -1;
      }
    }
    return +1;
  }

  /* If one value is a string and the other is a blob, the string is less.
  ** If both are strings, compare using the collating functions.
  */
  
// ABS Label 1398
if(combined_flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1398);
}

// AOR Label 1399
if(combined_flags | 2 != combined_flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1399);
}
// AOR Label 1400
if(combined_flags ^ 2 != combined_flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1400);
}
if( combined_flags&MEM_Str ){
    
// ROR Label 1401
if(((f1 & 2) != 0) != ((f1 & 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1401);
}
if( (f1 & MEM_Str)==0 ){
      return 1;
    }
    
// ROR Label 1402
if(((f2 & 2) != 0) != ((f2 & 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1402);
}
if( (f2 & MEM_Str)==0 ){
      return -1;
    }

    assert( pMem1->enc==pMem2->enc || pMem1->db->mallocFailed );
    assert( pMem1->enc==SQLITE_UTF8 || 
            pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );

    /* The collation sequence must be defined at this point, even if
    ** the user deletes the collation sequence after the vdbe program is
    ** compiled (this was not always the case).
    */
    assert( !pColl || pColl->xCmp );

    
// ABS Label 1403
if(pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1403);
}
if( pColl ){
      return vdbeCompareMemString(pMem1, pMem2, pColl, 0);
    }
    /* If a NULL pointer was passed as the collate function, fall through
    ** to the blob case and use memcmp().  */
  }
 
  /* Both values must be blobs.  Compare using memcmp().  */
  return sqlite3BlobCompare(pMem1, pMem2);
}


/*
** The first argument passed to this function is a serial-type that
** corresponds to an integer - all values between 1 and 9 inclusive 
** except 7. The second points to a buffer containing an integer value
** serialized according to serial_type. This function deserializes
** and returns the value.
*/
static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){
  u32 y;
  assert( CORRUPT_DB || (serial_type>=1 && serial_type<=9 && serial_type!=7) );
  switch( serial_type ){
    case 0:
    case 1:
      testcase( aKey[0]&0x80 );
      return ONE_BYTE_INT(aKey);
    case 2:
      testcase( aKey[0]&0x80 );
      return TWO_BYTE_INT(aKey);
    case 3:
      testcase( aKey[0]&0x80 );
      return THREE_BYTE_INT(aKey);
    case 4: {
      testcase( aKey[0]&0x80 );
      y = FOUR_BYTE_UINT(aKey);
      return (i64)*(int*)&y;
    }
    case 5: {
      testcase( aKey[0]&0x80 );
      
// AOR Label 1404
if((((u32)(aKey + 2)[0] << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) - (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]) != (((u32)(aKey + 2)[0] << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1404);
}
// AOR Label 1405
if((((u32)(aKey + 2)[0] << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) / (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]) != (((u32)(aKey + 2)[0] << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1405);
}
// AOR Label 1406
if((((u32)(aKey + 2)[0] << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) * (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]) != (((u32)(aKey + 2)[0] << 24) | ((aKey + 2)[1] << 16) | ((aKey + 2)[2] << 8) | (aKey + 2)[3]) + (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1406);
}
// AOR Label 1407
if((((i64)1) << 32) - (256 * (i8)((aKey)[0]) | (aKey)[1]) != (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1407);
}
// AOR Label 1408
if((((i64)1) << 32) + (256 * (i8)((aKey)[0]) | (aKey)[1]) != (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1408);
}
// AOR Label 1409
if((((i64)1) << 32) / (256 * (i8)((aKey)[0]) | (aKey)[1]) != (((i64)1) << 32) * (256 * (i8)((aKey)[0]) | (aKey)[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1409);
}
return FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);
    }
    case 6: {
      u64 x = FOUR_BYTE_UINT(aKey);
      testcase( aKey[0]&0x80 );
      x = (x<<32) | FOUR_BYTE_UINT(aKey+4);
      return (i64)*(i64*)&x;
    }
  }

  return (serial_type - 8);
}

/*
** This function compares the two table rows or index records
** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero
** or positive integer if key1 is less than, equal to or 
** greater than key2.  The {nKey1, pKey1} key must be a blob
** created by the OP_MakeRecord opcode of the VDBE.  The pPKey2
** key must be a parsed key such as obtained from
** sqlite3VdbeParseRecord.
**
** If argument bSkip is non-zero, it is assumed that the caller has already
** determined that the first fields of the keys are equal.
**
** Key1 and Key2 do not have to contain the same number of fields. If all 
** fields that appear in both keys are equal, then pPKey2->default_rc is 
** returned.
**
** If database corruption is discovered, set pPKey2->errCode to 
** SQLITE_CORRUPT and return 0. If an OOM error is encountered, 
** pPKey2->errCode is set to SQLITE_NOMEM and, if it is not NULL, the
** malloc-failed flag set on database handle (pPKey2->pKeyInfo->db).
*/
int sqlite3VdbeRecordCompareWithSkip(
  int nKey1, const void *pKey1,   /* Left key */
  UnpackedRecord *pPKey2,         /* Right key */
  int bSkip                       /* If true, skip the first field */
){
  u32 d1;                         /* Offset into aKey[] of next data element */
  int i;                          /* Index of next field to compare */
  u32 szHdr1;                     /* Size of record header in bytes */
  u32 idx1;                       /* Offset of first type in header */
  int rc = 0;                     /* Return value */
  
// ABS Label 1410
if(pPKey2->aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1410);
}
Mem *pRhs = pPKey2->aMem;       /* Next field of pPKey2 to compare */
  KeyInfo *pKeyInfo;
  const unsigned char *aKey1 = (const unsigned char *)pKey1;
  Mem mem1;

  /* If bSkip is true, then the caller has already determined that the first
  ** two elements in the keys are equal. Fix the various stack variables so
  ** that this routine begins comparing at the second field. */
  
// ABS Label 1411
if(bSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1411);
}
if( bSkip ){
    u32 s1;
    idx1 = 1 + getVarint32(&aKey1[1], s1);
    szHdr1 = aKey1[0];
    d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);
    i = 1;
    pRhs++;
  }else{
    idx1 = getVarint32(aKey1, szHdr1);
    d1 = szHdr1;
    i = 0;
  }
  
// ABS Label 1412
if(d1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1412);
}

// ROR Label 1413
if((d1 <= (unsigned int)nKey1) != (d1 > (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1413);
}
// ROR Label 1414
if((d1 < (unsigned int)nKey1) != (d1 > (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1414);
}
// ROR Label 1415
if((d1 >= (unsigned int)nKey1) != (d1 > (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1415);
}
if( d1>(unsigned)nKey1 ){ 
    pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
    return 0;  /* Corruption */
  }

  VVA_ONLY( mem1.szMalloc = 0; ) /* Only needed by assert() statements */
  assert( pPKey2->pKeyInfo->nAllField>=pPKey2->nField 
       || CORRUPT_DB );
  assert( pPKey2->pKeyInfo->aSortFlags!=0 );
  assert( pPKey2->pKeyInfo->nKeyField>0 );
  assert( idx1<=szHdr1 || CORRUPT_DB );
  
// ABS Label 1416
if(d1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1416);
}
// ABS Label 1417
if(idx1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1417);
}

// COR Label 1418
if((idx1 < (unsigned int)szHdr1 || d1 <= (unsigned int)nKey1) != (idx1 < (unsigned int)szHdr1 && d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1418);
}

// ROR Label 1419
if((idx1 <= (unsigned int)szHdr1) != (idx1 < (unsigned int)szHdr1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1419);
}
// ROR Label 1420
if((idx1 > (unsigned int)szHdr1) != (idx1 < (unsigned int)szHdr1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1420);
}
// ROR Label 1421
if((idx1 >= (unsigned int)szHdr1) != (idx1 < (unsigned int)szHdr1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1421);
}
// ROR Label 1422
if((d1 < (unsigned int)nKey1) != (d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1422);
}
// ROR Label 1423
if((d1 > (unsigned int)nKey1) != (d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1423);
}
// ROR Label 1424
if((d1 >= (unsigned int)nKey1) != (d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1424);
}

// MCC Label 1425
if(idx1 < (unsigned int)szHdr1 && d1 <= (unsigned int)nKey1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1425);
}
// MCC Label 1426
if(idx1 < (unsigned int)szHdr1 && !(d1 <= (unsigned int)nKey1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1426);
}
// MCC Label 1427
if(!(idx1 < (unsigned int)szHdr1) && d1 <= (unsigned int)nKey1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1427);
}
// MCC Label 1428
if(!(idx1 < (unsigned int)szHdr1) && !(d1 <= (unsigned int)nKey1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1428);
}
do{
    u32 serial_type;

    /* RHS is an integer */
    
// AOR Label 1442
if(pRhs->flags | (4 | 32) != pRhs->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1442);
}
// AOR Label 1443
if(pRhs->flags ^ (4 | 32) != pRhs->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1443);
}
if( pRhs->flags & (MEM_Int|MEM_IntReal) ){
      testcase( pRhs->flags & MEM_Int );
      testcase( pRhs->flags & MEM_IntReal );
      serial_type = aKey1[idx1];
      testcase( serial_type==12 );
      
// ABS Label 1444
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1444);
}

// ROR Label 1445
if((serial_type < 10) != (serial_type >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1445);
}
// ROR Label 1446
if((serial_type > 10) != (serial_type >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1446);
}
// ROR Label 1447
if((serial_type <= 10) != (serial_type >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1447);
}
if( serial_type>=10 ){
        rc = +1;
      }else { 
// ABS Label 1448
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1448);
}

// ROR Label 1449
if((serial_type != 0) != (serial_type == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1449);
}
if( serial_type==0 ){
        rc = -1;
      }else { 
// ABS Label 1450
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1450);
}

// ROR Label 1451
if((serial_type != 7) != (serial_type == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1451);
}
if( serial_type==7 ){
        
// ABS Label 1452
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1452);
}
sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
        rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);
      }else{
        i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);
        
// ABS Label 1453
if(pRhs->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1453);
}
i64 rhs = pRhs->u.i;
        
// ABS Label 1454
if(lhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1454);
}
// ABS Label 1455
if(rhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1455);
}

// ROR Label 1456
if((lhs <= rhs) != (lhs < rhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1456);
}
// ROR Label 1457
if((lhs > rhs) != (lhs < rhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1457);
}
// ROR Label 1458
if((lhs >= rhs) != (lhs < rhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1458);
}
if( lhs<rhs ){
          rc = -1;
        }else { 
// ABS Label 1459
if(lhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1459);
}
// ABS Label 1460
if(rhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1460);
}

// ROR Label 1461
if((lhs <= rhs) != (lhs > rhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1461);
}
// ROR Label 1462
if((lhs < rhs) != (lhs > rhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1462);
}
// ROR Label 1463
if((lhs >= rhs) != (lhs > rhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1463);
}
if( lhs>rhs ){
          rc = +1;
        };}

      };}
;}

    }

    /* RHS is real */
    else { 
// AOR Label 1464
if(pRhs->flags | 8 != pRhs->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1464);
}
// AOR Label 1465
if(pRhs->flags ^ 8 != pRhs->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1465);
}
if( pRhs->flags & MEM_Real ){
      serial_type = aKey1[idx1];
      
// ABS Label 1466
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1466);
}

// ROR Label 1467
if((serial_type < 10) != (serial_type >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1467);
}
// ROR Label 1468
if((serial_type > 10) != (serial_type >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1468);
}
// ROR Label 1469
if((serial_type <= 10) != (serial_type >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1469);
}
if( serial_type>=10 ){
        /* Serial types 12 or greater are strings and blobs (greater than
        ** numbers). Types 10 and 11 are currently "reserved for future 
        ** use", so it doesn't really matter what the results of comparing
        ** them to numberic values are.  */
        rc = +1;
      }else { 
// ABS Label 1470
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1470);
}

// ROR Label 1471
if((serial_type != 0) != (serial_type == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1471);
}
if( serial_type==0 ){
        rc = -1;
      }else{
        
// ABS Label 1472
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1472);
}
sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
        
// ABS Label 1473
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1473);
}

// ROR Label 1474
if((serial_type != 7) != (serial_type == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1474);
}
if( serial_type==7 ){
          
// ABS Label 1475
if(mem1.u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1475);
}
// ABS Label 1476
if(pRhs->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1476);
}

// ROR Label 1477
if((mem1.u.r <= pRhs->u.r) != (mem1.u.r < pRhs->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1477);
}
// ROR Label 1478
if((mem1.u.r > pRhs->u.r) != (mem1.u.r < pRhs->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1478);
}
// ROR Label 1479
if((mem1.u.r >= pRhs->u.r) != (mem1.u.r < pRhs->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1479);
}
if( mem1.u.r<pRhs->u.r ){
            rc = -1;
          }else { 
// ABS Label 1480
if(mem1.u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1480);
}
// ABS Label 1481
if(pRhs->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1481);
}

// ROR Label 1482
if((mem1.u.r <= pRhs->u.r) != (mem1.u.r > pRhs->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1482);
}
// ROR Label 1483
if((mem1.u.r < pRhs->u.r) != (mem1.u.r > pRhs->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1483);
}
// ROR Label 1484
if((mem1.u.r >= pRhs->u.r) != (mem1.u.r > pRhs->u.r))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1484);
}
if( mem1.u.r>pRhs->u.r ){
            rc = +1;
          };}

        }else{
          rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);
        }
      };}

    }

    /* RHS is a string */
    else { 
// AOR Label 1485
if(pRhs->flags | 2 != pRhs->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1485);
}
// AOR Label 1486
if(pRhs->flags ^ 2 != pRhs->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1486);
}
if( pRhs->flags & MEM_Str ){
      getVarint32NR(&aKey1[idx1], serial_type);
      testcase( serial_type==12 );
      
// ABS Label 1491
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1491);
}

// ROR Label 1492
if((serial_type <= 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1492);
}
// ROR Label 1493
if((serial_type > 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1493);
}
// ROR Label 1494
if((serial_type >= 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1494);
}
if( serial_type<12 ){
        rc = -1;
      }else { if( !(serial_type & 0x01) ){
        rc = +1;
      }else{
        mem1.n = (serial_type - 12) / 2;
        testcase( (d1+mem1.n)==(unsigned)nKey1 );
        testcase( (d1+mem1.n+1)==(unsigned)nKey1 );
        if( (d1+mem1.n) > (unsigned)nKey1
         || (pKeyInfo = pPKey2->pKeyInfo)->nAllField<=i
        ){
          pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
          return 0;                /* Corruption */
        }else { 
// ABS Label 1495
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1495);
}
// ABS Label 1496
if(pKeyInfo->aColl[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1496);
}
if( pKeyInfo->aColl[i] ){
          mem1.enc = pKeyInfo->enc;
          mem1.db = pKeyInfo->db;
          mem1.flags = MEM_Str;
          mem1.z = (char*)&aKey1[d1];
          rc = vdbeCompareMemString(
              &mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode
          );
        }else{
          int nCmp = MIN(mem1.n, pRhs->n);
          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
          
// ABS Label 1497
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1497);
}

// ROR Label 1498
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1498);
}
if( rc==0 ) { rc = mem1.n - pRhs->n; 
}
        };}

      };}

    }

    /* RHS is a blob */
    else { 
// AOR Label 1499
if(pRhs->flags | 16 != pRhs->flags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1499);
}
// AOR Label 1500
if(pRhs->flags ^ 16 != pRhs->flags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1500);
}
if( pRhs->flags & MEM_Blob ){
      assert( (pRhs->flags & MEM_Zero)==0 || pRhs->n==0 );
      getVarint32NR(&aKey1[idx1], serial_type);
      testcase( serial_type==12 );
      
// ABS Label 1505
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1505);
}

// COR Label 1506
if((serial_type < 12 && (serial_type & 1)) != (serial_type < 12 || (serial_type & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1506);
}

// ROR Label 1507
if((serial_type <= 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1507);
}
// ROR Label 1508
if((serial_type > 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1508);
}
// ROR Label 1509
if((serial_type >= 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1509);
}

// MCC Label 1510
if(serial_type < 12 && ( serial_type & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1510);
}
// MCC Label 1511
if(serial_type < 12 && ( !(serial_type & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1511);
}
// MCC Label 1512
if(!(serial_type < 12) && ( serial_type & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1512);
}
// MCC Label 1513
if(!(serial_type < 12) && ( !(serial_type & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1513);
}
if( serial_type<12 || (serial_type & 0x01) ){
        rc = -1;
      }else{
        int nStr = (serial_type - 12) / 2;
        testcase( (d1+nStr)==(unsigned)nKey1 );
        testcase( (d1+nStr+1)==(unsigned)nKey1 );
        
// ROR Label 1514
if(((d1 + nStr) <= (unsigned int)nKey1) != ((d1 + nStr) > (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1514);
}
// ROR Label 1515
if(((d1 + nStr) < (unsigned int)nKey1) != ((d1 + nStr) > (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1515);
}
// ROR Label 1516
if(((d1 + nStr) >= (unsigned int)nKey1) != ((d1 + nStr) > (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1516);
}
if( (d1+nStr) > (unsigned)nKey1 ){
          pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
          return 0;                /* Corruption */
        }else { 
// AOR Label 1517
if(pRhs->flags | 16384 != pRhs->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1517);
}
// AOR Label 1518
if(pRhs->flags ^ 16384 != pRhs->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1518);
}
if( pRhs->flags & MEM_Zero ){
          if( !isAllZero((const char*)&aKey1[d1],nStr) ){
            rc = 1;
          }else{
            rc = nStr - pRhs->u.nZero;
          }
        }else{
          int nCmp = MIN(nStr, pRhs->n);
          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
          
// ABS Label 1519
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1519);
}

// ROR Label 1520
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1520);
}
if( rc==0 ) { rc = nStr - pRhs->n;
}
        };}

      }
    }

    /* RHS is null */
    else{
      serial_type = aKey1[idx1];
      rc = (serial_type!=0);
    };}
;}
;}


    
// ABS Label 1521
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1521);
}

// ROR Label 1522
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1522);
}
if( rc!=0 ){
      int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];
      
// ABS Label 1523
if(sortFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1523);
}
if( sortFlags ){
        
// COR Label 1524
if(((sortFlags & 2) == 0 && ((sortFlags & 1) != (serial_type == 0 || (pRhs->flags & 1)))) != ((sortFlags & 2) == 0 || ((sortFlags & 1) != (serial_type == 0 || (pRhs->flags & 1)))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1524);
}

// ROR Label 1525
if(((sortFlags & 2) != 0) != ((sortFlags & 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1525);
}

// MCC Label 1526
if((sortFlags & 2) == 0 && ( (sortFlags & 1) != (serial_type == 0 || (pRhs->flags & 1)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1526);
}
// MCC Label 1527
if((sortFlags & 2) == 0 && ( !((sortFlags & 1) != (serial_type == 0 || (pRhs->flags & 1))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1527);
}
// MCC Label 1528
if(!((sortFlags & 2) == 0) && ( (sortFlags & 1) != (serial_type == 0 || (pRhs->flags & 1)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1528);
}
// MCC Label 1529
if(!((sortFlags & 2) == 0) && ( !((sortFlags & 1) != (serial_type == 0 || (pRhs->flags & 1))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1529);
}
if( (sortFlags & KEYINFO_ORDER_BIGNULL)==0
         || ((sortFlags & KEYINFO_ORDER_DESC)
           !=(serial_type==0 || (pRhs->flags&MEM_Null)))
        ){
          rc = -rc;
        }
      }
      assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, rc) );
      assert( mem1.szMalloc==0 );  /* See comment below */
      
// ABS Label 1530
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1530);
}
return rc;
    }

    i++;
    
// ABS Label 1531
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1531);
}

// ROR Label 1532
if((i != pPKey2->nField) != (i == pPKey2->nField))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1532);
}
if( i==pPKey2->nField ) { break;
}
    pRhs++;
    d1 += sqlite3VdbeSerialTypeLen(serial_type);
    idx1 += sqlite3VarintLen(serial_type);
  }while( idx1<(unsigned)szHdr1 && d1<=(unsigned)nKey1 );
// ABS Label 1429
if(d1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1429);
}
// ABS Label 1430
if(idx1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1430);
}

// COR Label 1431
if((idx1 < (unsigned int)szHdr1 || d1 <= (unsigned int)nKey1) != (idx1 < (unsigned int)szHdr1 && d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1431);
}

// ROR Label 1432
if((idx1 <= (unsigned int)szHdr1) != (idx1 < (unsigned int)szHdr1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1432);
}
// ROR Label 1433
if((idx1 > (unsigned int)szHdr1) != (idx1 < (unsigned int)szHdr1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1433);
}
// ROR Label 1434
if((idx1 >= (unsigned int)szHdr1) != (idx1 < (unsigned int)szHdr1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1434);
}
// ROR Label 1435
if((d1 < (unsigned int)nKey1) != (d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1435);
}
// ROR Label 1436
if((d1 > (unsigned int)nKey1) != (d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1436);
}
// ROR Label 1437
if((d1 >= (unsigned int)nKey1) != (d1 <= (unsigned int)nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1437);
}

// MCC Label 1438
if(idx1 < (unsigned int)szHdr1 && d1 <= (unsigned int)nKey1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1438);
}
// MCC Label 1439
if(idx1 < (unsigned int)szHdr1 && !(d1 <= (unsigned int)nKey1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1439);
}
// MCC Label 1440
if(!(idx1 < (unsigned int)szHdr1) && d1 <= (unsigned int)nKey1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1440);
}
// MCC Label 1441
if(!(idx1 < (unsigned int)szHdr1) && !(d1 <= (unsigned int)nKey1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1441);
}
;

  /* No memory allocation is ever used on mem1.  Prove this using
  ** the following assert().  If the assert() fails, it indicates a
  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).  */
  assert( mem1.szMalloc==0 );

  /* rc==0 here means that one or both of the keys ran out of fields and
  ** all the fields up to that point were equal. Return the default_rc
  ** value.  */
  assert( CORRUPT_DB 
       || vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, pPKey2->default_rc) 
       || pPKey2->pKeyInfo->db->mallocFailed
  );
  pPKey2->eqSeen = 1;
  return pPKey2->default_rc;
}
int sqlite3VdbeRecordCompare(
  int nKey1, const void *pKey1,   /* Left key */
  UnpackedRecord *pPKey2          /* Right key */
){
  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
}


/*
** This function is an optimized version of sqlite3VdbeRecordCompare() 
** that (a) the first field of pPKey2 is an integer, and (b) the 
** size-of-header varint at the start of (pKey1/nKey1) fits in a single
** byte (i.e. is less than 128).
**
** To avoid concerns about buffer overreads, this routine is only used
** on schemas where the maximum valid header size is 63 bytes or less.
*/
static int vdbeRecordCompareInt(
  int nKey1, const void *pKey1, /* Left key */
  UnpackedRecord *pPKey2        /* Right key */
){
  const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];
  int serial_type = ((const u8*)pKey1)[1];
  int res;
  u32 y;
  u64 x;
  i64 v;
  i64 lhs;

  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);
  assert( (*(u8*)pKey1)<=0x3F || CORRUPT_DB );
  switch( serial_type ){
    case 1: { /* 1-byte signed integer */
      lhs = ONE_BYTE_INT(aKey);
      testcase( lhs<0 );
      break;
    }
    case 2: { /* 2-byte signed integer */
      lhs = TWO_BYTE_INT(aKey);
      testcase( lhs<0 );
      break;
    }
    case 3: { /* 3-byte signed integer */
      lhs = THREE_BYTE_INT(aKey);
      testcase( lhs<0 );
      break;
    }
    case 4: { /* 4-byte signed integer */
      y = FOUR_BYTE_UINT(aKey);
      lhs = (i64)*(int*)&y;
      testcase( lhs<0 );
      break;
    }
    case 5: { /* 6-byte signed integer */
      lhs = FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);
      testcase( lhs<0 );
      break;
    }
    case 6: { /* 8-byte signed integer */
      x = FOUR_BYTE_UINT(aKey);
      x = (x<<32) | FOUR_BYTE_UINT(aKey+4);
      lhs = *(i64*)&x;
      testcase( lhs<0 );
      break;
    }
    case 8: 
      lhs = 0;
      break;
    case 9:
      lhs = 1;
      break;

    /* This case could be removed without changing the results of running
    ** this code. Including it causes gcc to generate a faster switch 
    ** statement (since the range of switch targets now starts at zero and
    ** is contiguous) but does not cause any duplicate code to be generated
    ** (as gcc is clever enough to combine the two like cases). Other 
    ** compilers might be similar.  */ 
    case 0: case 7:
      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);

    default:
      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);
  }

  v = pPKey2->aMem[0].u.i;
  
// ABS Label 1533
if(lhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1533);
}
// ABS Label 1534
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1534);
}

// ROR Label 1535
if((v <= lhs) != (v > lhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1535);
}
// ROR Label 1536
if((v < lhs) != (v > lhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1536);
}
// ROR Label 1537
if((v >= lhs) != (v > lhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1537);
}
if( v>lhs ){
    res = pPKey2->r1;
  }else { 
// ABS Label 1538
if(lhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1538);
}
// ABS Label 1539
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1539);
}

// ROR Label 1540
if((v <= lhs) != (v < lhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1540);
}
// ROR Label 1541
if((v > lhs) != (v < lhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1541);
}
// ROR Label 1542
if((v >= lhs) != (v < lhs))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1542);
}
if( v<lhs ){
    res = pPKey2->r2;
  }else { 
// ROR Label 1543
if((pPKey2->nField <= 1) != (pPKey2->nField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1543);
}
// ROR Label 1544
if((pPKey2->nField < 1) != (pPKey2->nField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1544);
}
// ROR Label 1545
if((pPKey2->nField >= 1) != (pPKey2->nField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1545);
}
if( pPKey2->nField>1 ){
    /* The first fields of the two keys are equal. Compare the trailing 
    ** fields.  */
    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
  }else{
    /* The first fields of the two keys are equal and there are no trailing
    ** fields. Return pPKey2->default_rc in this case. */
    res = pPKey2->default_rc;
    pPKey2->eqSeen = 1;
  };}
;}


  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) );
  
// ABS Label 1546
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1546);
}
return res;
}

/*
** This function is an optimized version of sqlite3VdbeRecordCompare() 
** that (a) the first field of pPKey2 is a string, that (b) the first field
** uses the collation sequence BINARY and (c) that the size-of-header varint 
** at the start of (pKey1/nKey1) fits in a single byte.
*/
static int vdbeRecordCompareString(
  int nKey1, const void *pKey1, /* Left key */
  UnpackedRecord *pPKey2        /* Right key */
){
  const u8 *aKey1 = (const u8*)pKey1;
  int serial_type;
  int res;

  assert( pPKey2->aMem[0].flags & MEM_Str );
  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);
  serial_type = (u8)(aKey1[1]);
  
// ABS Label 1547
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1547);
}

// ROR Label 1548
if((serial_type < 128) != (serial_type >= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1548);
}
// ROR Label 1549
if((serial_type > 128) != (serial_type >= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1549);
}
// ROR Label 1550
if((serial_type <= 128) != (serial_type >= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1550);
}
if( serial_type >= 0x80 ){
    sqlite3GetVarint32(&aKey1[1], (u32*)&serial_type);
  }
  
// ABS Label 1551
if(serial_type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1551);
}

// ROR Label 1552
if((serial_type <= 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1552);
}
// ROR Label 1553
if((serial_type > 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1553);
}
// ROR Label 1554
if((serial_type >= 12) != (serial_type < 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1554);
}
if( serial_type<12 ){
    res = pPKey2->r1;      /* (pKey1/nKey1) is a number or a null */
  }else { if( !(serial_type & 0x01) ){ 
    res = pPKey2->r2;      /* (pKey1/nKey1) is a blob */
  }else{
    int nCmp;
    int nStr;
    int szHdr = aKey1[0];

    nStr = (serial_type-12) / 2;
    
// ABS Label 1555
if(nKey1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1555);
}

// ROR Label 1556
if(((szHdr + nStr) <= nKey1) != ((szHdr + nStr) > nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1556);
}
// ROR Label 1557
if(((szHdr + nStr) < nKey1) != ((szHdr + nStr) > nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1557);
}
// ROR Label 1558
if(((szHdr + nStr) >= nKey1) != ((szHdr + nStr) > nKey1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1558);
}
if( (szHdr + nStr) > nKey1 ){
      pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;
      return 0;    /* Corruption */
    }
    nCmp = MIN( pPKey2->aMem[0].n, nStr );
    res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);

    
// ABS Label 1559
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1559);
}

// ROR Label 1560
if((res <= 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1560);
}
// ROR Label 1561
if((res < 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1561);
}
// ROR Label 1562
if((res >= 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1562);
}
if( res>0 ){
      res = pPKey2->r2;
    }else { 
// ABS Label 1563
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1563);
}

// ROR Label 1564
if((res <= 0) != (res < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1564);
}
// ROR Label 1565
if((res > 0) != (res < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1565);
}
// ROR Label 1566
if((res >= 0) != (res < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1566);
}
if( res<0 ){
      res = pPKey2->r1;
    }else{
      res = nStr - pPKey2->aMem[0].n;
      
// ABS Label 1567
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1567);
}

// ROR Label 1568
if((res != 0) != (res == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1568);
}
if( res==0 ){
        
// ROR Label 1569
if((pPKey2->nField <= 1) != (pPKey2->nField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1569);
}
// ROR Label 1570
if((pPKey2->nField < 1) != (pPKey2->nField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1570);
}
// ROR Label 1571
if((pPKey2->nField >= 1) != (pPKey2->nField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1571);
}
if( pPKey2->nField>1 ){
          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
        }else{
          res = pPKey2->default_rc;
          pPKey2->eqSeen = 1;
        }
      }else { 
// ABS Label 1572
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1572);
}

// ROR Label 1573
if((res <= 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1573);
}
// ROR Label 1574
if((res < 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1574);
}
// ROR Label 1575
if((res >= 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1575);
}
if( res>0 ){
        res = pPKey2->r2;
      }else{
        res = pPKey2->r1;
      };}

    };}

  };}


  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)
       || CORRUPT_DB
       || pPKey2->pKeyInfo->db->mallocFailed
  );
  
// ABS Label 1576
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1576);
}
return res;
}

/*
** Return a pointer to an sqlite3VdbeRecordCompare() compatible function
** suitable for comparing serialized records to the unpacked record passed
** as the only argument.
*/
RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){
  /* varintRecordCompareInt() and varintRecordCompareString() both assume
  ** that the size-of-header varint that occurs at the start of each record
  ** fits in a single byte (i.e. is 127 or less). varintRecordCompareInt()
  ** also assumes that it is safe to overread a buffer by at least the 
  ** maximum possible legal header size plus 8 bytes. Because there is
  ** guaranteed to be at least 74 (but not 136) bytes of padding following each
  ** buffer passed to varintRecordCompareInt() this makes it convenient to
  ** limit the size of the header to 64 bytes in cases where the first field
  ** is an integer.
  **
  ** The easiest way to enforce this limit is to consider only records with
  ** 13 fields or less. If the first field is an integer, the maximum legal
  ** header size is (12*5 + 1 + 1) bytes.  */
  
// ROR Label 1577
if((p->pKeyInfo->nAllField < 13) != (p->pKeyInfo->nAllField <= 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1577);
}
// ROR Label 1578
if((p->pKeyInfo->nAllField > 13) != (p->pKeyInfo->nAllField <= 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1578);
}
// ROR Label 1579
if((p->pKeyInfo->nAllField >= 13) != (p->pKeyInfo->nAllField <= 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1579);
}
if( p->pKeyInfo->nAllField<=13 ){
    int flags = p->aMem[0].flags;
    
// ABS Label 1580
if(p->pKeyInfo->aSortFlags[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1580);
}
if( p->pKeyInfo->aSortFlags[0] ){
      
// AOR Label 1581
if(p->pKeyInfo->aSortFlags[0] | 2 != p->pKeyInfo->aSortFlags[0] & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1581);
}
// AOR Label 1582
if(p->pKeyInfo->aSortFlags[0] ^ 2 != p->pKeyInfo->aSortFlags[0] & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1582);
}
if( p->pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL ){
        return sqlite3VdbeRecordCompare;
      }
      p->r1 = 1;
      p->r2 = -1;
    }else{
      p->r1 = -1;
      p->r2 = 1;
    }
    
// MCC Label 1583
if(( flags & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1583);
}
// MCC Label 1584
if(( !(flags & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1584);
}
if( (flags & MEM_Int) ){
      return vdbeRecordCompareInt;
    }
    testcase( flags & MEM_Real );
    testcase( flags & MEM_Null );
    testcase( flags & MEM_Blob );
    
// ABS Label 1585
if(p->pKeyInfo->aColl[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1585);
}

// COR Label 1586
if(((flags & (8 | 32 | 1 | 16)) == 0 || p->pKeyInfo->aColl[0] == 0) != ((flags & (8 | 32 | 1 | 16)) == 0 && p->pKeyInfo->aColl[0] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1586);
}

// ROR Label 1587
if(((flags & (8 | 32 | 1 | 16)) != 0) != ((flags & (8 | 32 | 1 | 16)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1587);
}
// ROR Label 1588
if((p->pKeyInfo->aColl[0] != 0) != (p->pKeyInfo->aColl[0] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1588);
}

// MCC Label 1589
if((flags & (8 | 32 | 1 | 16)) == 0 && p->pKeyInfo->aColl[0] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1589);
}
// MCC Label 1590
if((flags & (8 | 32 | 1 | 16)) == 0 && !(p->pKeyInfo->aColl[0] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1590);
}
// MCC Label 1591
if(!((flags & (8 | 32 | 1 | 16)) == 0) && p->pKeyInfo->aColl[0] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1591);
}
// MCC Label 1592
if(!((flags & (8 | 32 | 1 | 16)) == 0) && !(p->pKeyInfo->aColl[0] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1592);
}
if( (flags & (MEM_Real|MEM_IntReal|MEM_Null|MEM_Blob))==0
     && p->pKeyInfo->aColl[0]==0
    ){
      assert( flags & MEM_Str );
      return vdbeRecordCompareString;
    }
  }

  return sqlite3VdbeRecordCompare;
}

/*
** pCur points at an index entry created using the OP_MakeRecord opcode.
** Read the rowid (the last field in the record) and store it in *rowid.
** Return SQLITE_OK if everything works, or an error code otherwise.
**
** pCur might be pointing to text obtained from a corrupt database file.
** So the content cannot be trusted.  Do appropriate checks on the content.
*/
int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){
  i64 nCellKey = 0;
  int rc;
  u32 szHdr;        /* Size of the header */
  u32 typeRowid;    /* Serial type of the rowid */
  u32 lenRowid;     /* Size of the rowid */
  Mem m, v;

  /* Get the size of the index entry.  Only indices entries of less
  ** than 2GiB are support - anything large must be database corruption.
  ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so
  ** this code can safely assume that nCellKey is 32-bits  
  */
  assert( sqlite3BtreeCursorIsValid(pCur) );
  nCellKey = sqlite3BtreePayloadSize(pCur);
  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );

  /* Read in the complete content of the index entry */
  
// ABS Label 1593
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1593);
}
sqlite3VdbeMemInit(&m, db, 0);
  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);
  
// ABS Label 1595
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1595);
}
if( rc ){
    
// ABS Label 1596
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1596);
}
return rc;
  }

  /* The index entry must begin with a header size */
  getVarint32NR((u8*)m.z, szHdr);
  testcase( szHdr==3 );
  testcase( szHdr==m.n );
  testcase( szHdr>0x7fffffff );
  assert( m.n>=0 );
  
// MCC Label 1601
if(( szHdr < 3 && szHdr > (unsigned int)m.n ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1601);
}
// MCC Label 1602
if(( szHdr < 3 && !(szHdr > (unsigned int)m.n) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1602);
}
// MCC Label 1603
if(( !(szHdr < 3) && szHdr > (unsigned int)m.n ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1603);
}
// MCC Label 1604
if(( !(szHdr < 3) && !(szHdr > (unsigned int)m.n) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1604);
}
if( unlikely(szHdr<3 || szHdr>(unsigned)m.n) ){
    goto idx_rowid_corruption;
  }

  /* The last field of the index should be an integer - the ROWID.
  ** Verify that the last entry really is an integer. */
  getVarint32NR((u8*)&m.z[szHdr-1], typeRowid);
  testcase( typeRowid==1 );
  testcase( typeRowid==2 );
  testcase( typeRowid==3 );
  testcase( typeRowid==4 );
  testcase( typeRowid==5 );
  testcase( typeRowid==6 );
  testcase( typeRowid==8 );
  testcase( typeRowid==9 );
  
// MCC Label 1609
if(( typeRowid < 1 && typeRowid > 9 && typeRowid == 7 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1609);
}
// MCC Label 1610
if(( typeRowid < 1 && typeRowid > 9 && !(typeRowid == 7) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1610);
}
// MCC Label 1611
if(( typeRowid < 1 && !(typeRowid > 9) && typeRowid == 7 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1611);
}
// MCC Label 1612
if(( typeRowid < 1 && !(typeRowid > 9) && !(typeRowid == 7) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1612);
}
// MCC Label 1613
if(( !(typeRowid < 1) && typeRowid > 9 && typeRowid == 7 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1613);
}
// MCC Label 1614
if(( !(typeRowid < 1) && typeRowid > 9 && !(typeRowid == 7) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1614);
}
// MCC Label 1615
if(( !(typeRowid < 1) && !(typeRowid > 9) && typeRowid == 7 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1615);
}
// MCC Label 1616
if(( !(typeRowid < 1) && !(typeRowid > 9) && !(typeRowid == 7) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1616);
}
if( unlikely(typeRowid<1 || typeRowid>9 || typeRowid==7) ){
    goto idx_rowid_corruption;
  }
  lenRowid = sqlite3SmallTypeSizes[typeRowid];
  testcase( (u32)m.n==szHdr+lenRowid );
  
// MCC Label 1617
if(( (u32)m.n < szHdr + lenRowid ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1617);
}
// MCC Label 1618
if(( !((u32)m.n < szHdr + lenRowid) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1618);
}
if( unlikely((u32)m.n<szHdr+lenRowid) ){
    goto idx_rowid_corruption;
  }

  /* Fetch the integer off the end of the index record */
  
// ABS Label 1594
if(typeRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1594);
}
sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);
  *rowid = v.u.i;
  sqlite3VdbeMemRelease(&m);
  return SQLITE_OK;

  /* Jump here if database corruption is detected after m has been
  ** allocated.  Free the m object and return SQLITE_CORRUPT. */
idx_rowid_corruption:
  testcase( m.szMalloc!=0 );
  sqlite3VdbeMemRelease(&m);
  return SQLITE_CORRUPT_BKPT;
}

/*
** Compare the key of the index entry that cursor pC is pointing to against
** the key string in pUnpacked.  Write into *pRes a number
** that is negative, zero, or positive if pC is less than, equal to,
** or greater than pUnpacked.  Return SQLITE_OK on success.
**
** pUnpacked is either created without a rowid or is truncated so that it
** omits the rowid at the end.  The rowid at the end of the index entry
** is ignored as well.  Hence, this routine only compares the prefixes 
** of the keys prior to the final rowid, not the entire key.
*/
int sqlite3VdbeIdxKeyCompare(
  sqlite3 *db,                     /* Database connection */
  VdbeCursor *pC,                  /* The cursor to compare against */
  UnpackedRecord *pUnpacked,       /* Unpacked version of key */
  int *res                         /* Write the comparison result here */
){
  i64 nCellKey = 0;
  int rc;
  BtCursor *pCur;
  Mem m;

  assert( pC->eCurType==CURTYPE_BTREE );
  pCur = pC->uc.pCursor;
  assert( sqlite3BtreeCursorIsValid(pCur) );
  nCellKey = sqlite3BtreePayloadSize(pCur);
  /* nCellKey will always be between 0 and 0xffffffff because of the way
  ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */
  
// ABS Label 1620
if(nCellKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1620);
}

// COR Label 1621
if((nCellKey <= 0 && nCellKey > 2147483647) != (nCellKey <= 0 || nCellKey > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1621);
}

// ROR Label 1622
if((nCellKey < 0) != (nCellKey <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1622);
}
// ROR Label 1623
if((nCellKey > 0) != (nCellKey <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1623);
}
// ROR Label 1624
if((nCellKey >= 0) != (nCellKey <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1624);
}
// ROR Label 1625
if((nCellKey <= 2147483647) != (nCellKey > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1625);
}
// ROR Label 1626
if((nCellKey < 2147483647) != (nCellKey > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1626);
}
// ROR Label 1627
if((nCellKey >= 2147483647) != (nCellKey > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1627);
}

// MCC Label 1628
if(nCellKey <= 0 && nCellKey > 2147483647 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1628);
}
// MCC Label 1629
if(nCellKey <= 0 && !(nCellKey > 2147483647) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1629);
}
// MCC Label 1630
if(!(nCellKey <= 0) && nCellKey > 2147483647 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1630);
}
// MCC Label 1631
if(!(nCellKey <= 0) && !(nCellKey > 2147483647) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1631);
}
if( nCellKey<=0 || nCellKey>0x7fffffff ){
    *res = 0;
    return SQLITE_CORRUPT_BKPT;
  }
  
// ABS Label 1619
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1619);
}
sqlite3VdbeMemInit(&m, db, 0);
  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);
  
// ABS Label 1632
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1632);
}
if( rc ){
    
// ABS Label 1633
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1633);
}
return rc;
  }
  *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);
  sqlite3VdbeMemRelease(&m);
  return SQLITE_OK;
}

/*
** This routine sets the value to be returned by subsequent calls to
** sqlite3_changes() on the database handle 'db'. 
*/
void sqlite3VdbeSetChanges(sqlite3 *db, i64 nChange){
  assert( sqlite3_mutex_held(db->mutex) );
  db->nChange = nChange;
  db->nTotalChange += nChange;
}

/*
** Set a flag in the vdbe to update the change counter when it is finalised
** or reset.
*/
void sqlite3VdbeCountChanges(Vdbe *v){
  v->changeCntOn = 1;
}

/*
** Mark every prepared statement associated with a database connection
** as expired.
**
** An expired statement means that recompilation of the statement is
** recommend.  Statements expire when things happen that make their
** programs obsolete.  Removing user-defined functions or collating
** sequences, or changing an authorization function are the types of
** things that make prepared statements obsolete.
**
** If iCode is 1, then expiration is advisory.  The statement should
** be reprepared before being restarted, but if it is already running
** it is allowed to run to completion.
**
** Internally, this function just sets the Vdbe.expired flag on all
** prepared statements.  The flag is set to 1 for an immediate expiration
** and set to 2 for an advisory expiration.
*/
void sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){
  Vdbe *p;
  p = db->pVdbe;

// ABS Label 1634
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1634);
}
for(; p; p=p->pNext){
    p->expired = iCode+1;
  };
// ABS Label 1635
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1635);
}

}

/*
** Return the database associated with the Vdbe.
*/
sqlite3 *sqlite3VdbeDb(Vdbe *v){
  
// ABS Label 1636
if(v->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1636);
}
return v->db;
}

/*
** Return the SQLITE_PREPARE flags for a Vdbe.
*/
u8 sqlite3VdbePrepareFlags(Vdbe *v){
  
// ABS Label 1637
if(v->prepFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1637);
}
return v->prepFlags;
}

/*
** Return a pointer to an sqlite3_value structure containing the value bound
** parameter iVar of VM v. Except, if the value is an SQL NULL, return 
** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*
** constants) to the value before returning it.
**
** The returned value must be freed by the caller using sqlite3ValueFree().
*/
sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){
  assert( iVar>0 );
  
// ABS Label 1638
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1638);
}
if( v ){
    Mem *pMem = &v->aVar[iVar-1];
    assert( (v->db->flags & SQLITE_EnableQPSG)==0 );
    
// ROR Label 1639
if((0 != (pMem->flags & 1)) != (0 == (pMem->flags & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1639);
}
if( 0==(pMem->flags & MEM_Null) ){
      sqlite3_value *pRet = sqlite3ValueNew(v->db);
      
// ABS Label 1640
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1640);
}
if( pRet ){
        sqlite3VdbeMemCopy((Mem *)pRet, pMem);
        
// ABS Label 1641
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1641);
}

// ABS Label 1642
if(aff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1642);
}
sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);
      }
      
// ABS Label 1643
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1643);
}
return pRet;
    }
  }
  return 0;
}

/*
** Configure SQL variable iVar so that binding a new value to it signals
** to sqlite3_reoptimize() that re-preparing the statement may result
** in a better query plan.
*/
void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){
  assert( iVar>0 );
  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );
  
// ABS Label 1644
if(iVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1644);
}

// ROR Label 1645
if((iVar < 32) != (iVar >= 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1645);
}
// ROR Label 1646
if((iVar > 32) != (iVar >= 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1646);
}
// ROR Label 1647
if((iVar <= 32) != (iVar >= 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1647);
}
if( iVar>=32 ){
    v->expmask |= 0x80000000;
  }else{
    v->expmask |= ((u32)1 << (iVar-1));
  }
}

/*
** Cause a function to throw an error if it was call from OP_PureFunc
** rather than OP_Function.
**
** OP_PureFunc means that the function must be deterministic, and should
** throw an error if it is given inputs that would make it non-deterministic.
** This routine is invoked by date/time functions that use non-deterministic
** features such as 'now'.
*/
int sqlite3NotPureFunc(sqlite3_context *pCtx){
  const VdbeOp *pOp;
#ifdef SQLITE_ENABLE_STAT4
  if( pCtx->pVdbe==0 ) return 1;
#endif
  pOp = pCtx->pVdbe->aOp + pCtx->iOp;
  
// ROR Label 1648
if((pOp->opcode != 63) != (pOp->opcode == 63))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1648);
}
if( pOp->opcode==OP_PureFunc ){
    const char *zContext;
    char *zMsg;
    
// AOR Label 1650
if(pOp->p5 | 4 != pOp->p5 & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1650);
}
// AOR Label 1651
if(pOp->p5 ^ 4 != pOp->p5 & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1651);
}
if( pOp->p5 & NC_IsCheck ){
      zContext = "a CHECK constraint";
    }else { 
// AOR Label 1652
if(pOp->p5 | 8 != pOp->p5 & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1652);
}
// AOR Label 1653
if(pOp->p5 ^ 8 != pOp->p5 & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1653);
}
if( pOp->p5 & NC_GenCol ){
      zContext = "a generated column";
    }else{
      zContext = "an index";
    };}

    zMsg = sqlite3_mprintf("non-deterministic use of %s() in %s",
                           pCtx->pFunc->zName, zContext);
    
// ABS Label 1649
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1649);
}
sqlite3_result_error(pCtx, zMsg, -1);
    sqlite3_free(zMsg);
    return 0;
  }
  return 1;
}

#ifndef SQLITE_OMIT_VIRTUALTABLE
/*
** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored
** in memory obtained from sqlite3_malloc) into a Vdbe.zErrMsg (text stored
** in memory obtained from sqlite3DbMalloc).
*/
void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){
  
// ABS Label 1654
if(pVtab->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1654);
}
if( pVtab->zErrMsg ){
    
// ABS Label 1655
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1655);
}
sqlite3 *db = p->db;
    
// ABS Label 1656
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1656);
}
sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);
    sqlite3_free(pVtab->zErrMsg);
    pVtab->zErrMsg = 0;
  }
}
#endif /* SQLITE_OMIT_VIRTUALTABLE */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK

/*
** If the second argument is not NULL, release any allocations associated 
** with the memory cells in the p->aMem[] array. Also free the UnpackedRecord
** structure itself, using sqlite3DbFree().
**
** This function is used to free UnpackedRecord structures allocated by
** the vdbeUnpackRecord() function found in vdbeapi.c.
*/
static void vdbeFreeUnpacked(sqlite3 *db, int nField, UnpackedRecord *p){
  if( p ){
    int i;
    for(i=0; i<nField; i++){
      Mem *pMem = &p->aMem[i];
      if( pMem->zMalloc ) sqlite3VdbeMemRelease(pMem);
    }
    sqlite3DbFreeNN(db, p);
  }
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** Invoke the pre-update hook. If this is an UPDATE or DELETE pre-update call,
** then cursor passed as the second argument should point to the row about
** to be update or deleted. If the application calls sqlite3_preupdate_old(),
** the required value will be read from the row the cursor points to.
*/
void sqlite3VdbePreUpdateHook(
  Vdbe *v,                        /* Vdbe pre-update hook is invoked by */
  VdbeCursor *pCsr,               /* Cursor to grab old.* values from */
  int op,                         /* SQLITE_INSERT, UPDATE or DELETE */
  const char *zDb,                /* Database name */
  Table *pTab,                    /* Modified table */
  i64 iKey1,                      /* Initial key value */
  int iReg,                       /* Register for new.* record */
  int iBlobWrite
){
  sqlite3 *db = v->db;
  i64 iKey2;
  PreUpdate preupdate;
  const char *zTbl = pTab->zName;
  static const u8 fakeSortOrder = 0;

  assert( db->pPreUpdate==0 );
  memset(&preupdate, 0, sizeof(PreUpdate));
  if( HasRowid(pTab)==0 ){
    iKey1 = iKey2 = 0;
    preupdate.pPk = sqlite3PrimaryKeyIndex(pTab);
  }else{
    if( op==SQLITE_UPDATE ){
      iKey2 = v->aMem[iReg].u.i;
    }else{
      iKey2 = iKey1;
    }
  }

  assert( pCsr->nField==pTab->nCol 
       || (pCsr->nField==pTab->nCol+1 && op==SQLITE_DELETE && iReg==-1)
  );

  preupdate.v = v;
  preupdate.pCsr = pCsr;
  preupdate.op = op;
  preupdate.iNewReg = iReg;
  preupdate.keyinfo.db = db;
  preupdate.keyinfo.enc = ENC(db);
  preupdate.keyinfo.nKeyField = pTab->nCol;
  preupdate.keyinfo.aSortFlags = (u8*)&fakeSortOrder;
  preupdate.iKey1 = iKey1;
  preupdate.iKey2 = iKey2;
  preupdate.pTab = pTab;
  preupdate.iBlobWrite = iBlobWrite;

  db->pPreUpdate = &preupdate;
  db->xPreUpdateCallback(db->pPreUpdateArg, db, op, zDb, zTbl, iKey1, iKey2);
  db->pPreUpdate = 0;
  sqlite3DbFree(db, preupdate.aRecord);
  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pUnpacked);
  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pNewUnpacked);
  if( preupdate.aNew ){
    int i;
    for(i=0; i<pCsr->nField; i++){
      sqlite3VdbeMemRelease(&preupdate.aNew[i]);
    }
    sqlite3DbFreeNN(db, preupdate.aNew);
  }
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */
