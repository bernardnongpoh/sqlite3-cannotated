/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This is the implementation of the page cache subsystem or "pager".
** 
** The pager is used to access a database disk file.  It implements
** atomic commit and rollback through the use of a journal file that
** is separate from the database file.  The pager also implements file
** locking to prevent two processes from writing the same database
** file simultaneously, or one process from reading the database while
** another is writing.
*/
#ifndef SQLITE_OMIT_DISKIO
#include "sqliteInt.h"
#include "wal.h"


/******************* NOTES ON THE DESIGN OF THE PAGER ************************
**
** This comment block describes invariants that hold when using a rollback
** journal.  These invariants do not apply for journal_mode=WAL,
** journal_mode=MEMORY, or journal_mode=OFF.
**
** Within this comment block, a page is deemed to have been synced
** automatically as soon as it is written when PRAGMA synchronous=OFF.
** Otherwise, the page is not synced until the xSync method of the VFS
** is called successfully on the file containing the page.
**
** Definition:  A page of the database file is said to be "overwriteable" if
** one or more of the following are true about the page:
** 
**     (a)  The original content of the page as it was at the beginning of
**          the transaction has been written into the rollback journal and
**          synced.
** 
**     (b)  The page was a freelist leaf page at the start of the transaction.
** 
**     (c)  The page number is greater than the largest page that existed in
**          the database file at the start of the transaction.
** 
** (1) A page of the database file is never overwritten unless one of the
**     following are true:
** 
**     (a) The page and all other pages on the same sector are overwriteable.
** 
**     (b) The atomic page write optimization is enabled, and the entire
**         transaction other than the update of the transaction sequence
**         number consists of a single page change.
** 
** (2) The content of a page written into the rollback journal exactly matches
**     both the content in the database when the rollback journal was written
**     and the content in the database at the beginning of the current
**     transaction.
** 
** (3) Writes to the database file are an integer multiple of the page size
**     in length and are aligned on a page boundary.
** 
** (4) Reads from the database file are either aligned on a page boundary and
**     an integer multiple of the page size in length or are taken from the
**     first 100 bytes of the database file.
** 
** (5) All writes to the database file are synced prior to the rollback journal
**     being deleted, truncated, or zeroed.
** 
** (6) If a super-journal file is used, then all writes to the database file
**     are synced prior to the super-journal being deleted.
** 
** Definition: Two databases (or the same database at two points it time)
** are said to be "logically equivalent" if they give the same answer to
** all queries.  Note in particular the content of freelist leaf
** pages can be changed arbitrarily without affecting the logical equivalence
** of the database.
** 
** (7) At any time, if any subset, including the empty set and the total set,
**     of the unsynced changes to a rollback journal are removed and the 
**     journal is rolled back, the resulting database file will be logically
**     equivalent to the database file at the beginning of the transaction.
** 
** (8) When a transaction is rolled back, the xTruncate method of the VFS
**     is called to restore the database file to the same size it was at
**     the beginning of the transaction.  (In some VFSes, the xTruncate
**     method is a no-op, but that does not change the fact the SQLite will
**     invoke it.)
** 
** (9) Whenever the database file is modified, at least one bit in the range
**     of bytes from 24 through 39 inclusive will be changed prior to releasing
**     the EXCLUSIVE lock, thus signaling other connections on the same
**     database to flush their caches.
**
** (10) The pattern of bits in bytes 24 through 39 shall not repeat in less
**      than one billion transactions.
**
** (11) A database file is well-formed at the beginning and at the conclusion
**      of every transaction.
**
** (12) An EXCLUSIVE lock is held on the database file when writing to
**      the database file.
**
** (13) A SHARED lock is held on the database file while reading any
**      content out of the database file.
**
******************************************************************************/

/*
** Macros for troubleshooting.  Normally turned off
*/
#if 0
int sqlite3PagerTrace=1;  /* True to enable tracing */
#define sqlite3DebugPrintf printf
#define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }
#else
#define PAGERTRACE(X)
#endif

/*
** The following two macros are used within the PAGERTRACE() macros above
** to print out file-descriptors. 
**
** PAGERID() takes a pointer to a Pager struct as its argument. The
** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file
** struct as its argument.
*/
#define PAGERID(p) (SQLITE_PTR_TO_INT(p->fd))
#define FILEHANDLEID(fd) (SQLITE_PTR_TO_INT(fd))

/*
** The Pager.eState variable stores the current 'state' of a pager. A
** pager may be in any one of the seven states shown in the following
** state diagram.
**
**                            OPEN <------+------+
**                              |         |      |
**                              V         |      |
**               +---------> READER-------+      |
**               |              |                |
**               |              V                |
**               |<-------WRITER_LOCKED------> ERROR
**               |              |                ^  
**               |              V                |
**               |<------WRITER_CACHEMOD-------->|
**               |              |                |
**               |              V                |
**               |<-------WRITER_DBMOD---------->|
**               |              |                |
**               |              V                |
**               +<------WRITER_FINISHED-------->+
**
**
** List of state transitions and the C [function] that performs each:
** 
**   OPEN              -> READER              [sqlite3PagerSharedLock]
**   READER            -> OPEN                [pager_unlock]
**
**   READER            -> WRITER_LOCKED       [sqlite3PagerBegin]
**   WRITER_LOCKED     -> WRITER_CACHEMOD     [pager_open_journal]
**   WRITER_CACHEMOD   -> WRITER_DBMOD        [syncJournal]
**   WRITER_DBMOD      -> WRITER_FINISHED     [sqlite3PagerCommitPhaseOne]
**   WRITER_***        -> READER              [pager_end_transaction]
**
**   WRITER_***        -> ERROR               [pager_error]
**   ERROR             -> OPEN                [pager_unlock]
** 
**
**  OPEN:
**
**    The pager starts up in this state. Nothing is guaranteed in this
**    state - the file may or may not be locked and the database size is
**    unknown. The database may not be read or written.
**
**    * No read or write transaction is active.
**    * Any lock, or no lock at all, may be held on the database file.
**    * The dbSize, dbOrigSize and dbFileSize variables may not be trusted.
**
**  READER:
**
**    In this state all the requirements for reading the database in 
**    rollback (non-WAL) mode are met. Unless the pager is (or recently
**    was) in exclusive-locking mode, a user-level read transaction is 
**    open. The database size is known in this state.
**
**    A connection running with locking_mode=normal enters this state when
**    it opens a read-transaction on the database and returns to state
**    OPEN after the read-transaction is completed. However a connection
**    running in locking_mode=exclusive (including temp databases) remains in
**    this state even after the read-transaction is closed. The only way
**    a locking_mode=exclusive connection can transition from READER to OPEN
**    is via the ERROR state (see below).
** 
**    * A read transaction may be active (but a write-transaction cannot).
**    * A SHARED or greater lock is held on the database file.
**    * The dbSize variable may be trusted (even if a user-level read 
**      transaction is not active). The dbOrigSize and dbFileSize variables
**      may not be trusted at this point.
**    * If the database is a WAL database, then the WAL connection is open.
**    * Even if a read-transaction is not open, it is guaranteed that 
**      there is no hot-journal in the file-system.
**
**  WRITER_LOCKED:
**
**    The pager moves to this state from READER when a write-transaction
**    is first opened on the database. In WRITER_LOCKED state, all locks 
**    required to start a write-transaction are held, but no actual 
**    modifications to the cache or database have taken place.
**
**    In rollback mode, a RESERVED or (if the transaction was opened with 
**    BEGIN EXCLUSIVE) EXCLUSIVE lock is obtained on the database file when
**    moving to this state, but the journal file is not written to or opened 
**    to in this state. If the transaction is committed or rolled back while 
**    in WRITER_LOCKED state, all that is required is to unlock the database 
**    file.
**
**    IN WAL mode, WalBeginWriteTransaction() is called to lock the log file.
**    If the connection is running with locking_mode=exclusive, an attempt
**    is made to obtain an EXCLUSIVE lock on the database file.
**
**    * A write transaction is active.
**    * If the connection is open in rollback-mode, a RESERVED or greater 
**      lock is held on the database file.
**    * If the connection is open in WAL-mode, a WAL write transaction
**      is open (i.e. sqlite3WalBeginWriteTransaction() has been successfully
**      called).
**    * The dbSize, dbOrigSize and dbFileSize variables are all valid.
**    * The contents of the pager cache have not been modified.
**    * The journal file may or may not be open.
**    * Nothing (not even the first header) has been written to the journal.
**
**  WRITER_CACHEMOD:
**
**    A pager moves from WRITER_LOCKED state to this state when a page is
**    first modified by the upper layer. In rollback mode the journal file
**    is opened (if it is not already open) and a header written to the
**    start of it. The database file on disk has not been modified.
**
**    * A write transaction is active.
**    * A RESERVED or greater lock is held on the database file.
**    * The journal file is open and the first header has been written 
**      to it, but the header has not been synced to disk.
**    * The contents of the page cache have been modified.
**
**  WRITER_DBMOD:
**
**    The pager transitions from WRITER_CACHEMOD into WRITER_DBMOD state
**    when it modifies the contents of the database file. WAL connections
**    never enter this state (since they do not modify the database file,
**    just the log file).
**
**    * A write transaction is active.
**    * An EXCLUSIVE or greater lock is held on the database file.
**    * The journal file is open and the first header has been written 
**      and synced to disk.
**    * The contents of the page cache have been modified (and possibly
**      written to disk).
**
**  WRITER_FINISHED:
**
**    It is not possible for a WAL connection to enter this state.
**
**    A rollback-mode pager changes to WRITER_FINISHED state from WRITER_DBMOD
**    state after the entire transaction has been successfully written into the
**    database file. In this state the transaction may be committed simply
**    by finalizing the journal file. Once in WRITER_FINISHED state, it is 
**    not possible to modify the database further. At this point, the upper 
**    layer must either commit or rollback the transaction.
**
**    * A write transaction is active.
**    * An EXCLUSIVE or greater lock is held on the database file.
**    * All writing and syncing of journal and database data has finished.
**      If no error occurred, all that remains is to finalize the journal to
**      commit the transaction. If an error did occur, the caller will need
**      to rollback the transaction. 
**
**  ERROR:
**
**    The ERROR state is entered when an IO or disk-full error (including
**    SQLITE_IOERR_NOMEM) occurs at a point in the code that makes it 
**    difficult to be sure that the in-memory pager state (cache contents, 
**    db size etc.) are consistent with the contents of the file-system.
**
**    Temporary pager files may enter the ERROR state, but in-memory pagers
**    cannot.
**
**    For example, if an IO error occurs while performing a rollback, 
**    the contents of the page-cache may be left in an inconsistent state.
**    At this point it would be dangerous to change back to READER state
**    (as usually happens after a rollback). Any subsequent readers might
**    report database corruption (due to the inconsistent cache), and if
**    they upgrade to writers, they may inadvertently corrupt the database
**    file. To avoid this hazard, the pager switches into the ERROR state
**    instead of READER following such an error.
**
**    Once it has entered the ERROR state, any attempt to use the pager
**    to read or write data returns an error. Eventually, once all 
**    outstanding transactions have been abandoned, the pager is able to
**    transition back to OPEN state, discarding the contents of the 
**    page-cache and any other in-memory state at the same time. Everything
**    is reloaded from disk (and, if necessary, hot-journal rollback peformed)
**    when a read-transaction is next opened on the pager (transitioning
**    the pager into READER state). At that point the system has recovered 
**    from the error.
**
**    Specifically, the pager jumps into the ERROR state if:
**
**      1. An error occurs while attempting a rollback. This happens in
**         function sqlite3PagerRollback().
**
**      2. An error occurs while attempting to finalize a journal file
**         following a commit in function sqlite3PagerCommitPhaseTwo().
**
**      3. An error occurs while attempting to write to the journal or
**         database file in function pagerStress() in order to free up
**         memory.
**
**    In other cases, the error is returned to the b-tree layer. The b-tree
**    layer then attempts a rollback operation. If the error condition 
**    persists, the pager enters the ERROR state via condition (1) above.
**
**    Condition (3) is necessary because it can be triggered by a read-only
**    statement executed within a transaction. In this case, if the error
**    code were simply returned to the user, the b-tree layer would not
**    automatically attempt a rollback, as it assumes that an error in a
**    read-only statement cannot leave the pager in an internally inconsistent 
**    state.
**
**    * The Pager.errCode variable is set to something other than SQLITE_OK.
**    * There are one or more outstanding references to pages (after the
**      last reference is dropped the pager should move back to OPEN state).
**    * The pager is not an in-memory pager.
**    
**
** Notes:
**
**   * A pager is never in WRITER_DBMOD or WRITER_FINISHED state if the
**     connection is open in WAL mode. A WAL connection is always in one
**     of the first four states.
**
**   * Normally, a connection open in exclusive mode is never in PAGER_OPEN
**     state. There are two exceptions: immediately after exclusive-mode has
**     been turned on (and before any read or write transactions are 
**     executed), and when the pager is leaving the "error state".
**
**   * See also: assert_pager_state().
*/
#define PAGER_OPEN                  0
#define PAGER_READER                1
#define PAGER_WRITER_LOCKED         2
#define PAGER_WRITER_CACHEMOD       3
#define PAGER_WRITER_DBMOD          4
#define PAGER_WRITER_FINISHED       5
#define PAGER_ERROR                 6

/*
** The Pager.eLock variable is almost always set to one of the 
** following locking-states, according to the lock currently held on
** the database file: NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.
** This variable is kept up to date as locks are taken and released by
** the pagerLockDb() and pagerUnlockDb() wrappers.
**
** If the VFS xLock() or xUnlock() returns an error other than SQLITE_BUSY
** (i.e. one of the SQLITE_IOERR subtypes), it is not clear whether or not
** the operation was successful. In these circumstances pagerLockDb() and
** pagerUnlockDb() take a conservative approach - eLock is always updated
** when unlocking the file, and only updated when locking the file if the
** VFS call is successful. This way, the Pager.eLock variable may be set
** to a less exclusive (lower) value than the lock that is actually held
** at the system level, but it is never set to a more exclusive value.
**
** This is usually safe. If an xUnlock fails or appears to fail, there may 
** be a few redundant xLock() calls or a lock may be held for longer than
** required, but nothing really goes wrong.
**
** The exception is when the database file is unlocked as the pager moves
** from ERROR to OPEN state. At this point there may be a hot-journal file 
** in the file-system that needs to be rolled back (as part of an OPEN->SHARED
** transition, by the same pager or any other). If the call to xUnlock()
** fails at this point and the pager is left holding an EXCLUSIVE lock, this
** can confuse the call to xCheckReservedLock() call made later as part
** of hot-journal detection.
**
** xCheckReservedLock() is defined as returning true "if there is a RESERVED 
** lock held by this process or any others". So xCheckReservedLock may 
** return true because the caller itself is holding an EXCLUSIVE lock (but
** doesn't know it because of a previous error in xUnlock). If this happens
** a hot-journal may be mistaken for a journal being created by an active
** transaction in another process, causing SQLite to read from the database
** without rolling it back.
**
** To work around this, if a call to xUnlock() fails when unlocking the
** database in the ERROR state, Pager.eLock is set to UNKNOWN_LOCK. It
** is only changed back to a real locking state after a successful call
** to xLock(EXCLUSIVE). Also, the code to do the OPEN->SHARED state transition
** omits the check for a hot-journal if Pager.eLock is set to UNKNOWN_LOCK 
** lock. Instead, it assumes a hot-journal exists and obtains an EXCLUSIVE
** lock on the database file before attempting to roll it back. See function
** PagerSharedLock() for more detail.
**
** Pager.eLock may only be set to UNKNOWN_LOCK when the pager is in 
** PAGER_OPEN state.
*/
#define UNKNOWN_LOCK                (EXCLUSIVE_LOCK+1)

/*
** The maximum allowed sector size. 64KiB. If the xSectorsize() method 
** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.
** This could conceivably cause corruption following a power failure on
** such a system. This is currently an undocumented limit.
*/
#define MAX_SECTOR_SIZE 0x10000


/*
** An instance of the following structure is allocated for each active
** savepoint and statement transaction in the system. All such structures
** are stored in the Pager.aSavepoint[] array, which is allocated and
** resized using sqlite3Realloc().
**
** When a savepoint is created, the PagerSavepoint.iHdrOffset field is
** set to 0. If a journal-header is written into the main journal while
** the savepoint is active, then iHdrOffset is set to the byte offset 
** immediately following the last journal record written into the main
** journal before the journal-header. This is required during savepoint
** rollback (see pagerPlaybackSavepoint()).
*/
typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint {
  i64 iOffset;                 /* Starting offset in main journal */
  i64 iHdrOffset;              /* See above */
  Bitvec *pInSavepoint;        /* Set of pages in this savepoint */
  Pgno nOrig;                  /* Original number of pages in file */
  Pgno iSubRec;                /* Index of first record in sub-journal */
  int bTruncateOnRelease;      /* If stmt journal may be truncated on RELEASE */
#ifndef SQLITE_OMIT_WAL
  u32 aWalData[WAL_SAVEPOINT_NDATA];        /* WAL savepoint context */
#endif
};

/*
** Bits of the Pager.doNotSpill flag.  See further description below.
*/
#define SPILLFLAG_OFF         0x01 /* Never spill cache.  Set via pragma */
#define SPILLFLAG_ROLLBACK    0x02 /* Current rolling back, so do not spill */
#define SPILLFLAG_NOSYNC      0x04 /* Spill is ok, but do not sync */

/*
** An open page cache is an instance of struct Pager. A description of
** some of the more important member variables follows:
**
** eState
**
**   The current 'state' of the pager object. See the comment and state
**   diagram above for a description of the pager state.
**
** eLock
**
**   For a real on-disk database, the current lock held on the database file -
**   NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.
**
**   For a temporary or in-memory database (neither of which require any
**   locks), this variable is always set to EXCLUSIVE_LOCK. Since such
**   databases always have Pager.exclusiveMode==1, this tricks the pager
**   logic into thinking that it already has all the locks it will ever
**   need (and no reason to release them).
**
**   In some (obscure) circumstances, this variable may also be set to
**   UNKNOWN_LOCK. See the comment above the #define of UNKNOWN_LOCK for
**   details.
**
** changeCountDone
**
**   This boolean variable is used to make sure that the change-counter 
**   (the 4-byte header field at byte offset 24 of the database file) is 
**   not updated more often than necessary. 
**
**   It is set to true when the change-counter field is updated, which 
**   can only happen if an exclusive lock is held on the database file.
**   It is cleared (set to false) whenever an exclusive lock is 
**   relinquished on the database file. Each time a transaction is committed,
**   The changeCountDone flag is inspected. If it is true, the work of
**   updating the change-counter is omitted for the current transaction.
**
**   This mechanism means that when running in exclusive mode, a connection 
**   need only update the change-counter once, for the first transaction
**   committed.
**
** setSuper
**
**   When PagerCommitPhaseOne() is called to commit a transaction, it may
**   (or may not) specify a super-journal name to be written into the 
**   journal file before it is synced to disk.
**
**   Whether or not a journal file contains a super-journal pointer affects 
**   the way in which the journal file is finalized after the transaction is 
**   committed or rolled back when running in "journal_mode=PERSIST" mode.
**   If a journal file does not contain a super-journal pointer, it is
**   finalized by overwriting the first journal header with zeroes. If
**   it does contain a super-journal pointer the journal file is finalized 
**   by truncating it to zero bytes, just as if the connection were 
**   running in "journal_mode=truncate" mode.
**
**   Journal files that contain super-journal pointers cannot be finalized
**   simply by overwriting the first journal-header with zeroes, as the
**   super-journal pointer could interfere with hot-journal rollback of any
**   subsequently interrupted transaction that reuses the journal file.
**
**   The flag is cleared as soon as the journal file is finalized (either
**   by PagerCommitPhaseTwo or PagerRollback). If an IO error prevents the
**   journal file from being successfully finalized, the setSuper flag
**   is cleared anyway (and the pager will move to ERROR state).
**
** doNotSpill
**
**   This variables control the behavior of cache-spills  (calls made by
**   the pcache module to the pagerStress() routine to write cached data
**   to the file-system in order to free up memory).
**
**   When bits SPILLFLAG_OFF or SPILLFLAG_ROLLBACK of doNotSpill are set,
**   writing to the database from pagerStress() is disabled altogether.
**   The SPILLFLAG_ROLLBACK case is done in a very obscure case that
**   comes up during savepoint rollback that requires the pcache module
**   to allocate a new page to prevent the journal file from being written
**   while it is being traversed by code in pager_playback().  The SPILLFLAG_OFF
**   case is a user preference.
** 
**   If the SPILLFLAG_NOSYNC bit is set, writing to the database from
**   pagerStress() is permitted, but syncing the journal file is not.
**   This flag is set by sqlite3PagerWrite() when the file-system sector-size
**   is larger than the database page-size in order to prevent a journal sync
**   from happening in between the journalling of two pages on the same sector. 
**
** subjInMemory
**
**   This is a boolean variable. If true, then any required sub-journal
**   is opened as an in-memory journal file. If false, then in-memory
**   sub-journals are only used for in-memory pager files.
**
**   This variable is updated by the upper layer each time a new 
**   write-transaction is opened.
**
** dbSize, dbOrigSize, dbFileSize
**
**   Variable dbSize is set to the number of pages in the database file.
**   It is valid in PAGER_READER and higher states (all states except for
**   OPEN and ERROR). 
**
**   dbSize is set based on the size of the database file, which may be 
**   larger than the size of the database (the value stored at offset
**   28 of the database header by the btree). If the size of the file
**   is not an integer multiple of the page-size, the value stored in
**   dbSize is rounded down (i.e. a 5KB file with 2K page-size has dbSize==2).
**   Except, any file that is greater than 0 bytes in size is considered
**   to have at least one page. (i.e. a 1KB file with 2K page-size leads
**   to dbSize==1).
**
**   During a write-transaction, if pages with page-numbers greater than
**   dbSize are modified in the cache, dbSize is updated accordingly.
**   Similarly, if the database is truncated using PagerTruncateImage(), 
**   dbSize is updated.
**
**   Variables dbOrigSize and dbFileSize are valid in states 
**   PAGER_WRITER_LOCKED and higher. dbOrigSize is a copy of the dbSize
**   variable at the start of the transaction. It is used during rollback,
**   and to determine whether or not pages need to be journalled before
**   being modified.
**
**   Throughout a write-transaction, dbFileSize contains the size of
**   the file on disk in pages. It is set to a copy of dbSize when the
**   write-transaction is first opened, and updated when VFS calls are made
**   to write or truncate the database file on disk. 
**
**   The only reason the dbFileSize variable is required is to suppress 
**   unnecessary calls to xTruncate() after committing a transaction. If, 
**   when a transaction is committed, the dbFileSize variable indicates 
**   that the database file is larger than the database image (Pager.dbSize), 
**   pager_truncate() is called. The pager_truncate() call uses xFilesize()
**   to measure the database file on disk, and then truncates it if required.
**   dbFileSize is not used when rolling back a transaction. In this case
**   pager_truncate() is called unconditionally (which means there may be
**   a call to xFilesize() that is not strictly required). In either case,
**   pager_truncate() may cause the file to become smaller or larger.
**
** dbHintSize
**
**   The dbHintSize variable is used to limit the number of calls made to
**   the VFS xFileControl(FCNTL_SIZE_HINT) method. 
**
**   dbHintSize is set to a copy of the dbSize variable when a
**   write-transaction is opened (at the same time as dbFileSize and
**   dbOrigSize). If the xFileControl(FCNTL_SIZE_HINT) method is called,
**   dbHintSize is increased to the number of pages that correspond to the
**   size-hint passed to the method call. See pager_write_pagelist() for 
**   details.
**
** errCode
**
**   The Pager.errCode variable is only ever used in PAGER_ERROR state. It
**   is set to zero in all other states. In PAGER_ERROR state, Pager.errCode 
**   is always set to SQLITE_FULL, SQLITE_IOERR or one of the SQLITE_IOERR_XXX 
**   sub-codes.
**
** syncFlags, walSyncFlags
**
**   syncFlags is either SQLITE_SYNC_NORMAL (0x02) or SQLITE_SYNC_FULL (0x03).
**   syncFlags is used for rollback mode.  walSyncFlags is used for WAL mode
**   and contains the flags used to sync the checkpoint operations in the
**   lower two bits, and sync flags used for transaction commits in the WAL
**   file in bits 0x04 and 0x08.  In other words, to get the correct sync flags
**   for checkpoint operations, use (walSyncFlags&0x03) and to get the correct
**   sync flags for transaction commit, use ((walSyncFlags>>2)&0x03).  Note
**   that with synchronous=NORMAL in WAL mode, transaction commit is not synced
**   meaning that the 0x04 and 0x08 bits are both zero.
*/
struct Pager {
  sqlite3_vfs *pVfs;          /* OS functions to use for IO */
  u8 exclusiveMode;           /* Boolean. True if locking_mode==EXCLUSIVE */
  u8 journalMode;             /* One of the PAGER_JOURNALMODE_* values */
  u8 useJournal;              /* Use a rollback journal on this file */
  u8 noSync;                  /* Do not sync the journal if true */
  u8 fullSync;                /* Do extra syncs of the journal for robustness */
  u8 extraSync;               /* sync directory after journal delete */
  u8 syncFlags;               /* SYNC_NORMAL or SYNC_FULL otherwise */
  u8 walSyncFlags;            /* See description above */
  u8 tempFile;                /* zFilename is a temporary or immutable file */
  u8 noLock;                  /* Do not lock (except in WAL mode) */
  u8 readOnly;                /* True for a read-only database */
  u8 memDb;                   /* True to inhibit all file I/O */

  /**************************************************************************
  ** The following block contains those class members that change during
  ** routine operation.  Class members not in this block are either fixed
  ** when the pager is first created or else only change when there is a
  ** significant mode change (such as changing the page_size, locking_mode,
  ** or the journal_mode).  From another view, these class members describe
  ** the "state" of the pager, while other class members describe the
  ** "configuration" of the pager.
  */
  u8 eState;                  /* Pager state (OPEN, READER, WRITER_LOCKED..) */
  u8 eLock;                   /* Current lock held on database file */
  u8 changeCountDone;         /* Set after incrementing the change-counter */
  u8 setSuper;                /* Super-jrnl name is written into jrnl */
  u8 doNotSpill;              /* Do not spill the cache when non-zero */
  u8 subjInMemory;            /* True to use in-memory sub-journals */
  u8 bUseFetch;               /* True to use xFetch() */
  u8 hasHeldSharedLock;       /* True if a shared lock has ever been held */
  Pgno dbSize;                /* Number of pages in the database */
  Pgno dbOrigSize;            /* dbSize before the current transaction */
  Pgno dbFileSize;            /* Number of pages in the database file */
  Pgno dbHintSize;            /* Value passed to FCNTL_SIZE_HINT call */
  int errCode;                /* One of several kinds of errors */
  int nRec;                   /* Pages journalled since last j-header written */
  u32 cksumInit;              /* Quasi-random value added to every checksum */
  u32 nSubRec;                /* Number of records written to sub-journal */
  Bitvec *pInJournal;         /* One bit for each page in the database file */
  sqlite3_file *fd;           /* File descriptor for database */
  sqlite3_file *jfd;          /* File descriptor for main journal */
  sqlite3_file *sjfd;         /* File descriptor for sub-journal */
  i64 journalOff;             /* Current write offset in the journal file */
  i64 journalHdr;             /* Byte offset to previous journal header */
  sqlite3_backup *pBackup;    /* Pointer to list of ongoing backup processes */
  PagerSavepoint *aSavepoint; /* Array of active savepoints */
  int nSavepoint;             /* Number of elements in aSavepoint[] */
  u32 iDataVersion;           /* Changes whenever database content changes */
  char dbFileVers[16];        /* Changes whenever database file changes */

  int nMmapOut;               /* Number of mmap pages currently outstanding */
  sqlite3_int64 szMmap;       /* Desired maximum mmap size */
  PgHdr *pMmapFreelist;       /* List of free mmap page headers (pDirty) */
  /*
  ** End of the routinely-changing class members
  ***************************************************************************/

  u16 nExtra;                 /* Add this many bytes to each in-memory page */
  i16 nReserve;               /* Number of unused bytes at end of each page */
  u32 vfsFlags;               /* Flags for sqlite3_vfs.xOpen() */
  u32 sectorSize;             /* Assumed sector size during rollback */
  int pageSize;               /* Number of bytes in a page */
  Pgno mxPgno;                /* Maximum allowed size of the database */
  i64 journalSizeLimit;       /* Size limit for persistent journal files */
  char *zFilename;            /* Name of the database file */
  char *zJournal;             /* Name of the journal file */
  int (*xBusyHandler)(void*); /* Function to call when busy */
  void *pBusyHandlerArg;      /* Context argument for xBusyHandler */
  int aStat[4];               /* Total cache hits, misses, writes, spills */
#ifdef SQLITE_TEST
  int nRead;                  /* Database pages read */
#endif
  void (*xReiniter)(DbPage*); /* Call this routine when reloading pages */
  int (*xGet)(Pager*,Pgno,DbPage**,int); /* Routine to fetch a patch */
  char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */
  PCache *pPCache;            /* Pointer to page cache object */
#ifndef SQLITE_OMIT_WAL
  Wal *pWal;                  /* Write-ahead log used by "journal_mode=wal" */
  char *zWal;                 /* File name for write-ahead log */
#endif
};

/*
** Indexes for use with Pager.aStat[]. The Pager.aStat[] array contains
** the values accessed by passing SQLITE_DBSTATUS_CACHE_HIT, CACHE_MISS 
** or CACHE_WRITE to sqlite3_db_status().
*/
#define PAGER_STAT_HIT   0
#define PAGER_STAT_MISS  1
#define PAGER_STAT_WRITE 2
#define PAGER_STAT_SPILL 3

/*
** The following global variables hold counters used for
** testing purposes only.  These variables do not exist in
** a non-testing build.  These variables are not thread-safe.
*/
#ifdef SQLITE_TEST
int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */
int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */
int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */
# define PAGER_INCR(v)  v++
#else
# define PAGER_INCR(v)
#endif



/*
** Journal files begin with the following magic string.  The data
** was obtained from /dev/random.  It is used only as a sanity check.
**
** Since version 2.8.0, the journal format contains additional sanity
** checking information.  If the power fails while the journal is being
** written, semi-random garbage data might appear in the journal
** file after power is restored.  If an attempt is then made
** to roll the journal back, the database could be corrupted.  The additional
** sanity checking data is an attempt to discover the garbage in the
** journal and ignore it.
**
** The sanity checking information for the new journal format consists
** of a 32-bit checksum on each page of data.  The checksum covers both
** the page number and the pPager->pageSize bytes of data for the page.
** This cksum is initialized to a 32-bit random value that appears in the
** journal file right after the header.  The random initializer is important,
** because garbage data that appears at the end of a journal is likely
** data that was once in other files that have now been deleted.  If the
** garbage data came from an obsolete journal file, the checksums might
** be correct.  But by initializing the checksum to random value which
** is different for every journal, we minimize that risk.
*/
static const unsigned char aJournalMagic[] = {
  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,
};

/*
** The size of the of each page record in the journal is given by
** the following macro.
*/
#define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8)

/*
** The journal header size for this pager. This is usually the same 
** size as a single disk sector. See also setSectorSize().
*/
#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)

/*
** The macro MEMDB is true if we are dealing with an in-memory database.
** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,
** the value of MEMDB will be a constant and the compiler will optimize
** out code that would never execute.
*/
#ifdef SQLITE_OMIT_MEMORYDB
# define MEMDB 0
#else
# define MEMDB pPager->memDb
#endif

/*
** The macro USEFETCH is true if we are allowed to use the xFetch and xUnfetch
** interfaces to access the database using memory-mapped I/O.
*/
#if SQLITE_MAX_MMAP_SIZE>0
# define USEFETCH(x) ((x)->bUseFetch)
#else
# define USEFETCH(x) 0
#endif

/*
** The argument to this macro is a file descriptor (type sqlite3_file*).
** Return 0 if it is not open, or non-zero (but not 1) if it is.
**
** This is so that expressions can be written as:
**
**   if( isOpen(pPager->jfd) ){ ...
**
** instead of
**
**   if( pPager->jfd->pMethods ){ ...
*/
#define isOpen(pFd) ((pFd)->pMethods!=0)

#ifdef SQLITE_DIRECT_OVERFLOW_READ
/*
** Return true if page pgno can be read directly from the database file
** by the b-tree layer. This is the case if:
**
**   * the database file is open,
**   * there are no dirty pages in the cache, and
**   * the desired page is not currently in the wal file.
*/
int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno){
  if( pPager->fd->pMethods==0 ) return 0;
  if( sqlite3PCacheIsDirty(pPager->pPCache) ) return 0;
#ifndef SQLITE_OMIT_WAL
  if( pPager->pWal ){
    u32 iRead = 0;
    int rc;
    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);
    return (rc==SQLITE_OK && iRead==0);
  }
#endif
  return 1;
}
#endif

#ifndef SQLITE_OMIT_WAL
# define pagerUseWal(x) ((x)->pWal!=0)
#else
# define pagerUseWal(x) 0
# define pagerRollbackWal(x) 0
# define pagerWalFrames(v,w,x,y) 0
# define pagerOpenWalIfPresent(z) SQLITE_OK
# define pagerBeginReadTransaction(z) SQLITE_OK
#endif

#ifndef NDEBUG 
/*
** Usage:
**
**   assert( assert_pager_state(pPager) );
**
** This function runs many asserts to try to find inconsistencies in
** the internal state of the Pager object.
*/
static int assert_pager_state(Pager *p){
  Pager *pPager = p;

  /* State must be valid. */
  assert( p->eState==PAGER_OPEN
       || p->eState==PAGER_READER
       || p->eState==PAGER_WRITER_LOCKED
       || p->eState==PAGER_WRITER_CACHEMOD
       || p->eState==PAGER_WRITER_DBMOD
       || p->eState==PAGER_WRITER_FINISHED
       || p->eState==PAGER_ERROR
  );

  /* Regardless of the current state, a temp-file connection always behaves
  ** as if it has an exclusive lock on the database file. It never updates
  ** the change-counter field, so the changeCountDone flag is always set.
  */
  assert( p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK );
  assert( p->tempFile==0 || pPager->changeCountDone );

  /* If the useJournal flag is clear, the journal-mode must be "OFF". 
  ** And if the journal-mode is "OFF", the journal file must not be open.
  */
  assert( p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal );
  assert( p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) );

  /* Check that MEMDB implies noSync. And an in-memory journal. Since 
  ** this means an in-memory pager performs no IO at all, it cannot encounter 
  ** either SQLITE_IOERR or SQLITE_FULL during rollback or while finalizing 
  ** a journal file. (although the in-memory journal implementation may 
  ** return SQLITE_IOERR_NOMEM while the journal file is being written). It 
  ** is therefore not possible for an in-memory pager to enter the ERROR 
  ** state.
  */
  if( MEMDB ){
    assert( !isOpen(p->fd) );
    assert( p->noSync );
    assert( p->journalMode==PAGER_JOURNALMODE_OFF 
         || p->journalMode==PAGER_JOURNALMODE_MEMORY 
    );
    assert( p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN );
    assert( pagerUseWal(p)==0 );
  }

  /* If changeCountDone is set, a RESERVED lock or greater must be held
  ** on the file.
  */
  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );
  assert( p->eLock!=PENDING_LOCK );

  switch( p->eState ){
    case PAGER_OPEN:
      assert( !MEMDB );
      assert( pPager->errCode==SQLITE_OK );
      assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );
      break;

    case PAGER_READER:
      assert( pPager->errCode==SQLITE_OK );
      assert( p->eLock!=UNKNOWN_LOCK );
      assert( p->eLock>=SHARED_LOCK );
      break;

    case PAGER_WRITER_LOCKED:
      assert( p->eLock!=UNKNOWN_LOCK );
      assert( pPager->errCode==SQLITE_OK );
      if( !pagerUseWal(pPager) ){
        assert( p->eLock>=RESERVED_LOCK );
      }
      assert( pPager->dbSize==pPager->dbOrigSize );
      assert( pPager->dbOrigSize==pPager->dbFileSize );
      assert( pPager->dbOrigSize==pPager->dbHintSize );
      assert( pPager->setSuper==0 );
      break;

    case PAGER_WRITER_CACHEMOD:
      assert( p->eLock!=UNKNOWN_LOCK );
      assert( pPager->errCode==SQLITE_OK );
      if( !pagerUseWal(pPager) ){
        /* It is possible that if journal_mode=wal here that neither the
        ** journal file nor the WAL file are open. This happens during
        ** a rollback transaction that switches from journal_mode=off
        ** to journal_mode=wal.
        */
        assert( p->eLock>=RESERVED_LOCK );
        assert( isOpen(p->jfd) 
             || p->journalMode==PAGER_JOURNALMODE_OFF 
             || p->journalMode==PAGER_JOURNALMODE_WAL 
        );
      }
      assert( pPager->dbOrigSize==pPager->dbFileSize );
      assert( pPager->dbOrigSize==pPager->dbHintSize );
      break;

    case PAGER_WRITER_DBMOD:
      assert( p->eLock==EXCLUSIVE_LOCK );
      assert( pPager->errCode==SQLITE_OK );
      assert( !pagerUseWal(pPager) );
      assert( p->eLock>=EXCLUSIVE_LOCK );
      assert( isOpen(p->jfd) 
           || p->journalMode==PAGER_JOURNALMODE_OFF 
           || p->journalMode==PAGER_JOURNALMODE_WAL 
           || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)
      );
      assert( pPager->dbOrigSize<=pPager->dbHintSize );
      break;

    case PAGER_WRITER_FINISHED:
      assert( p->eLock==EXCLUSIVE_LOCK );
      assert( pPager->errCode==SQLITE_OK );
      assert( !pagerUseWal(pPager) );
      assert( isOpen(p->jfd) 
           || p->journalMode==PAGER_JOURNALMODE_OFF 
           || p->journalMode==PAGER_JOURNALMODE_WAL 
           || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)
      );
      break;

    case PAGER_ERROR:
      /* There must be at least one outstanding reference to the pager if
      ** in ERROR state. Otherwise the pager should have already dropped
      ** back to OPEN state.
      */
      assert( pPager->errCode!=SQLITE_OK );
      assert( sqlite3PcacheRefCount(pPager->pPCache)>0 || pPager->tempFile );
      break;
  }

  return 1;
}
#endif /* ifndef NDEBUG */

#ifdef SQLITE_DEBUG 
/*
** Return a pointer to a human readable string in a static buffer
** containing the state of the Pager object passed as an argument. This
** is intended to be used within debuggers. For example, as an alternative
** to "print *pPager" in gdb:
**
** (gdb) printf "%s", print_pager_state(pPager)
**
** This routine has external linkage in order to suppress compiler warnings
** about an unused function.  It is enclosed within SQLITE_DEBUG and so does
** not appear in normal builds.
*/
char *print_pager_state(Pager *p){
  static char zRet[1024];

  sqlite3_snprintf(1024, zRet,
      "Filename:      %s\n"
      "State:         %s errCode=%d\n"
      "Lock:          %s\n"
      "Locking mode:  locking_mode=%s\n"
      "Journal mode:  journal_mode=%s\n"
      "Backing store: tempFile=%d memDb=%d useJournal=%d\n"
      "Journal:       journalOff=%lld journalHdr=%lld\n"
      "Size:          dbsize=%d dbOrigSize=%d dbFileSize=%d\n"
      , p->zFilename
      , p->eState==PAGER_OPEN            ? "OPEN" :
        p->eState==PAGER_READER          ? "READER" :
        p->eState==PAGER_WRITER_LOCKED   ? "WRITER_LOCKED" :
        p->eState==PAGER_WRITER_CACHEMOD ? "WRITER_CACHEMOD" :
        p->eState==PAGER_WRITER_DBMOD    ? "WRITER_DBMOD" :
        p->eState==PAGER_WRITER_FINISHED ? "WRITER_FINISHED" :
        p->eState==PAGER_ERROR           ? "ERROR" : "?error?"
      , (int)p->errCode
      , p->eLock==NO_LOCK         ? "NO_LOCK" :
        p->eLock==RESERVED_LOCK   ? "RESERVED" :
        p->eLock==EXCLUSIVE_LOCK  ? "EXCLUSIVE" :
        p->eLock==SHARED_LOCK     ? "SHARED" :
        p->eLock==UNKNOWN_LOCK    ? "UNKNOWN" : "?error?"
      , p->exclusiveMode ? "exclusive" : "normal"
      , p->journalMode==PAGER_JOURNALMODE_MEMORY   ? "memory" :
        p->journalMode==PAGER_JOURNALMODE_OFF      ? "off" :
        p->journalMode==PAGER_JOURNALMODE_DELETE   ? "delete" :
        p->journalMode==PAGER_JOURNALMODE_PERSIST  ? "persist" :
        p->journalMode==PAGER_JOURNALMODE_TRUNCATE ? "truncate" :
        p->journalMode==PAGER_JOURNALMODE_WAL      ? "wal" : "?error?"
      , (int)p->tempFile, (int)p->memDb, (int)p->useJournal
      , p->journalOff, p->journalHdr
      , (int)p->dbSize, (int)p->dbOrigSize, (int)p->dbFileSize
  );

  return zRet;
}
#endif

/* Forward references to the various page getters */
static int getPageNormal(Pager*,Pgno,DbPage**,int);
static int getPageError(Pager*,Pgno,DbPage**,int);
#if SQLITE_MAX_MMAP_SIZE>0
static int getPageMMap(Pager*,Pgno,DbPage**,int);
#endif

/*
** Set the Pager.xGet method for the appropriate routine used to fetch
** content from the pager.
*/
static void setGetterMethod(Pager *pPager){
  
// ABS Label 7
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
if( pPager->errCode ){
    pPager->xGet = getPageError;
#if SQLITE_MAX_MMAP_SIZE>0
  }else { 
// ABS Label 8
if(((pPager)->bUseFetch) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
if( USEFETCH(pPager) ){
    pPager->xGet = getPageMMap;
#endif /* SQLITE_MAX_MMAP_SIZE>0 */
  }else{
    pPager->xGet = getPageNormal;
  };}

}

/*
** Return true if it is necessary to write page *pPg into the sub-journal.
** A page needs to be written into the sub-journal if there exists one
** or more open savepoints for which:
**
**   * The page-number is less than or equal to PagerSavepoint.nOrig, and
**   * The bit corresponding to the page-number is not set in
**     PagerSavepoint.pInSavepoint.
*/
static int subjRequiresPage(PgHdr *pPg){
  
// ABS Label 9
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
Pager *pPager = pPg->pPager;
  PagerSavepoint *p;
  
// ABS Label 10
if(pPg->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
Pgno pgno = pPg->pgno;
  int i;
  i = 0;

// ABS Label 11
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
// ABS Label 12
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ROR Label 13
if((i <= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if((i > pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
// ROR Label 15
if((i >= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
for(; i<pPager->nSavepoint; i++){
    p = &pPager->aSavepoint[i];
    if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){
      i = i + 1;

// ABS Label 21
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
// ABS Label 22
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ROR Label 23
if((i <= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
// ROR Label 24
if((i > pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
// ROR Label 25
if((i >= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
for(; i<pPager->nSavepoint; i++){
        pPager->aSavepoint[i].bTruncateOnRelease = 0;
      };
// ABS Label 26
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
// ABS Label 27
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}

// ROR Label 28
if((i <= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((i > pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((i >= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}

      return 1;
    }
  };
// ABS Label 16
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
// ABS Label 17
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// ROR Label 18
if((i <= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
// ROR Label 19
if((i > pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if((i >= pPager->nSavepoint) != (i < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}

  return 0;
}

#ifdef SQLITE_DEBUG
/*
** Return true if the page is already in the journal file.
*/
static int pageInJournal(Pager *pPager, PgHdr *pPg){
  return sqlite3BitvecTest(pPager->pInJournal, pPg->pgno);
}
#endif

/*
** Read a 32-bit integer from the given file descriptor.  Store the integer
** that is read in *pRes.  Return SQLITE_OK if everything worked, or an
** error code is something goes wrong.
**
** All values are stored on disk as big-endian.
*/
static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){
  unsigned char ac[4];
  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);
  
// ABS Label 31
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// ROR Label 32
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
if( rc==SQLITE_OK ){
    *pRes = sqlite3Get4byte(ac);
  }
  
// ABS Label 33
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
return rc;
}

/*
** Write a 32-bit integer into a string buffer in big-endian byte order.
*/
#define put32bits(A,B)  sqlite3Put4byte((u8*)A,B)


/*
** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK
** on success or an error code is something goes wrong.
*/
static int write32bits(sqlite3_file *fd, i64 offset, u32 val){
  char ac[4];
  put32bits(ac, val);
  return sqlite3OsWrite(fd, ac, 4, offset);
}

/*
** Unlock the database file to level eLock, which must be either NO_LOCK
** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()
** succeeds, set the Pager.eLock variable to match the (attempted) new lock.
**
** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is
** called, do not modify it. See the comment above the #define of 
** UNKNOWN_LOCK for an explanation of this.
*/
static int pagerUnlockDb(Pager *pPager, int eLock){
  int rc = SQLITE_OK;

  assert( !pPager->exclusiveMode || pPager->eLock==eLock );
  assert( eLock==NO_LOCK || eLock==SHARED_LOCK );
  assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );
  
// MCC Label 35
if(( (pPager->fd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
// MCC Label 36
if(( !((pPager->fd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 36);
}
if( isOpen(pPager->fd) ){
    assert( pPager->eLock>=eLock );
    rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);
    
// ROR Label 37
if((pPager->eLock == (4 + 1)) != (pPager->eLock != (4 + 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
if( pPager->eLock!=UNKNOWN_LOCK ){
      pPager->eLock = (u8)eLock;
    }
    IOTRACE(("UNLOCK %p %d\n", pPager, eLock))
  }
  pPager->changeCountDone = pPager->tempFile; /* ticket fb3b3024ea238d5c */
  
// ABS Label 38
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
return rc;
}

/*
** Lock the database file to level eLock, which must be either SHARED_LOCK,
** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set the
** Pager.eLock variable to the new locking state. 
**
** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is 
** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. 
** See the comment above the #define of UNKNOWN_LOCK for an explanation 
** of this.
*/
static int pagerLockDb(Pager *pPager, int eLock){
  int rc = SQLITE_OK;

  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );
  
// ABS Label 39
if(eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}

// COR Label 40
if((pPager->eLock < eLock && pPager->eLock == (4 + 1)) != (pPager->eLock < eLock || pPager->eLock == (4 + 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 40);
}

// ROR Label 41
if((pPager->eLock <= eLock) != (pPager->eLock < eLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
// ROR Label 42
if((pPager->eLock > eLock) != (pPager->eLock < eLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((pPager->eLock >= eLock) != (pPager->eLock < eLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((pPager->eLock != (4 + 1)) != (pPager->eLock == (4 + 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}

// MCC Label 45
if(pPager->eLock < eLock && pPager->eLock == (4 + 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 45);
}
// MCC Label 46
if(pPager->eLock < eLock && !(pPager->eLock == (4 + 1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 46);
}
// MCC Label 47
if(!(pPager->eLock < eLock) && pPager->eLock == (4 + 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if(!(pPager->eLock < eLock) && !(pPager->eLock == (4 + 1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){
    rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);
    
// ABS Label 49
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}

// COR Label 50
if((rc == 0 || (pPager->eLock != (4 + 1) || eLock == 4)) != (rc == 0 && (pPager->eLock != (4 + 1) || eLock == 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 50);
}

// ROR Label 51
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}

// MCC Label 52
if(rc == 0 && ( pPager->eLock != (4 + 1) && eLock == 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 52);
}
// MCC Label 53
if(rc == 0 && ( pPager->eLock != (4 + 1) && !(eLock == 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(rc == 0 && ( !(pPager->eLock != (4 + 1)) && eLock == 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(rc == 0 && ( !(pPager->eLock != (4 + 1)) && !(eLock == 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(rc == 0) && ( pPager->eLock != (4 + 1) && eLock == 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
// MCC Label 57
if(!(rc == 0) && ( pPager->eLock != (4 + 1) && !(eLock == 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
// MCC Label 58
if(!(rc == 0) && ( !(pPager->eLock != (4 + 1)) && eLock == 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 58);
}
// MCC Label 59
if(!(rc == 0) && ( !(pPager->eLock != (4 + 1)) && !(eLock == 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){
      pPager->eLock = (u8)eLock;
      IOTRACE(("LOCK %p %d\n", pPager, eLock))
    }
  }
  
// ABS Label 60
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
return rc;
}

/*
** This function determines whether or not the atomic-write or
** atomic-batch-write optimizations can be used with this pager. The
** atomic-write optimization can be used if:
**
**  (a) the value returned by OsDeviceCharacteristics() indicates that
**      a database page may be written atomically, and
**  (b) the value returned by OsSectorSize() is less than or equal
**      to the page size.
**
** If it can be used, then the value returned is the size of the journal 
** file when it contains rollback data for exactly one page.
**
** The atomic-batch-write optimization can be used if OsDeviceCharacteristics()
** returns a value with the SQLITE_IOCAP_BATCH_ATOMIC bit set. -1 is
** returned in this case.
**
** If neither optimization can be used, 0 is returned.
*/
static int jrnlBufferSize(Pager *pPager){
  assert( !MEMDB );

#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \
 || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
  int dc;                           /* Device characteristics */

  assert( isOpen(pPager->fd) );
  dc = sqlite3OsDeviceCharacteristics(pPager->fd);
#else
  UNUSED_PARAMETER(pPager);
#endif

#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
  if( pPager->dbSize>0 && (dc&SQLITE_IOCAP_BATCH_ATOMIC) ){
    return -1;
  }
#endif

#ifdef SQLITE_ENABLE_ATOMIC_WRITE
  {
    int nSector = pPager->sectorSize;
    int szPage = pPager->pageSize;

    assert(SQLITE_IOCAP_ATOMIC512==(512>>8));
    assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));
    if( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){
      return 0;
    }
  }

  return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);
#endif

  return 0;
}

/*
** If SQLITE_CHECK_PAGES is defined then we do some sanity checking
** on the cache using a hash function.  This is used for testing
** and debugging only.
*/
#ifdef SQLITE_CHECK_PAGES
/*
** Return a 32-bit hash of the page data for pPage.
*/
static u32 pager_datahash(int nByte, unsigned char *pData){
  u32 hash = 0;
  int i;
  for(i=0; i<nByte; i++){
    hash = (hash*1039) + pData[i];
  }
  return hash;
}
static u32 pager_pagehash(PgHdr *pPage){
  return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData);
}
static void pager_set_pagehash(PgHdr *pPage){
  pPage->pageHash = pager_pagehash(pPage);
}

/*
** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGES
** is defined, and NDEBUG is not defined, an assert() statement checks
** that the page is either dirty or still matches the calculated page-hash.
*/
#define CHECK_PAGE(x) checkPage(x)
static void checkPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  assert( pPager->eState!=PAGER_ERROR );
  assert( (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) );
}

#else
#define pager_datahash(X,Y)  0
#define pager_pagehash(X)  0
#define pager_set_pagehash(X)
#define CHECK_PAGE(x)
#endif  /* SQLITE_CHECK_PAGES */

/*
** When this is called the journal file for pager pPager must be open.
** This function attempts to read a super-journal file name from the 
** end of the file and, if successful, copies it into memory supplied 
** by the caller. See comments above writeSuperJournal() for the format
** used to store a super-journal file name at the end of a journal file.
**
** zSuper must point to a buffer of at least nSuper bytes allocated by
** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there is
** enough space to write the super-journal name). If the super-journal
** name in the journal is longer than nSuper bytes (including a
** nul-terminator), then this is handled as if no super-journal name
** were present in the journal.
**
** If a super-journal file name is present at the end of the journal
** file, then it is copied into the buffer pointed to by zSuper. A
** nul-terminator byte is appended to the buffer following the
** super-journal file name.
**
** If it is determined that no super-journal file name is present 
** zSuper[0] is set to 0 and SQLITE_OK returned.
**
** If an error occurs while reading from the journal file, an SQLite
** error code is returned.
*/
static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u32 nSuper){
  int rc;                    /* Return code */
  u32 len;                   /* Length in bytes of super-journal name */
  i64 szJ;                   /* Total size in bytes of journal file pJrnl */
  u32 cksum;                 /* MJ checksum value read from journal */
  u32 u;                     /* Unsigned loop counter */
  unsigned char aMagic[8];   /* A buffer to hold the magic header */
  zSuper[0] = '\0';

  if( SQLITE_OK!=(rc = sqlite3OsFileSize(pJrnl, &szJ))
   || szJ<16
   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-16, &len))
   || len>=nSuper 
   || len>szJ-16
   || len==0 
   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-12, &cksum))
   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))
   || memcmp(aMagic, aJournalMagic, 8)
   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zSuper, len, szJ-16-len))
  ){
    
// ABS Label 61
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
return rc;
  }

  /* See if the checksum matches the super-journal name */
  u = 0;

// ABS Label 62
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}
// ABS Label 63
if(u < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}

// ROR Label 64
if((u <= len) != (u < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((u > len) != (u < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
// ROR Label 66
if((u >= len) != (u < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
for(; u<len; u++){
    cksum -= zSuper[u];
  };
// ABS Label 67
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
// ABS Label 68
if(u < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}

// ROR Label 69
if((u <= len) != (u < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((u > len) != (u < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
// ROR Label 71
if((u >= len) != (u < len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}

  
// ABS Label 72
if(cksum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
if( cksum ){
    /* If the checksum doesn't add up, then one or more of the disk sectors
    ** containing the super-journal filename is corrupted. This means
    ** definitely roll back, so just return SQLITE_OK and report a (nul)
    ** super-journal filename.
    */
    len = 0;
  }
  zSuper[len] = '\0';
  zSuper[len+1] = '\0';
   
  return SQLITE_OK;
}

/*
** Return the offset of the sector boundary at or immediately 
** following the value in pPager->journalOff, assuming a sector 
** size of pPager->sectorSize bytes.
**
** i.e for a sector size of 512:
**
**   Pager.journalOff          Return value
**   ---------------------------------------
**   0                         0
**   512                       512
**   100                       512
**   2000                      2048
** 
*/
static i64 journalHdrOffset(Pager *pPager){
  i64 offset = 0;
  
// ABS Label 73
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
i64 c = pPager->journalOff;
  
// ABS Label 74
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}
if( c ){
    offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);
  }
  assert( offset%JOURNAL_HDR_SZ(pPager)==0 );
  assert( offset>=c );
  assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );
  
// ABS Label 75
if(offset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}
return offset;
}

/*
** The journal file must be open when this function is called.
**
** This function is a no-op if the journal file has not been written to
** within the current transaction (i.e. if Pager.journalOff==0).
**
** If doTruncate is non-zero or the Pager.journalSizeLimit variable is
** set to 0, then truncate the journal file to zero bytes in size. Otherwise,
** zero the 28-byte header at the start of the journal file. In either case, 
** if the pager is not in no-sync mode, sync the journal file immediately 
** after writing or truncating it.
**
** If Pager.journalSizeLimit is set to a positive, non-zero value, and
** following the truncation or zeroing described above the size of the 
** journal file in bytes is larger than this value, then truncate the
** journal file to Pager.journalSizeLimit bytes. The journal file does
** not need to be synced following this operation.
**
** If an IO error occurs, abandon processing and return the IO error code.
** Otherwise, return SQLITE_OK.
*/
static int zeroJournalHdr(Pager *pPager, int doTruncate){
  int rc = SQLITE_OK;                               /* Return code */
  assert( isOpen(pPager->jfd) );
  assert( !sqlite3JournalIsInMemory(pPager->jfd) );
  
// ABS Label 76
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
if( pPager->journalOff ){
    
// ABS Label 77
if(pPager->journalSizeLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}
const i64 iLimit = pPager->journalSizeLimit;    /* Local cache of jsl */

    IOTRACE(("JZEROHDR %p\n", pPager))
    
// ABS Label 78
if(doTruncate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}
// ABS Label 79
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// COR Label 80
if((doTruncate && iLimit == 0) != (doTruncate || iLimit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 80);
}

// ROR Label 81
if((iLimit != 0) != (iLimit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}

// MCC Label 82
if(doTruncate && iLimit == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
// MCC Label 83
if(doTruncate && !(iLimit == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
// MCC Label 84
if(!(doTruncate) && iLimit == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 84);
}
// MCC Label 85
if(!(doTruncate) && !(iLimit == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 85);
}
if( doTruncate || iLimit==0 ){
      rc = sqlite3OsTruncate(pPager->jfd, 0);
    }else{
      static const char zeroHdr[28] = {0};
      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);
    }
    
// ABS Label 86
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// COR Label 87
if((rc == 0 || !pPager->noSync) != (rc == 0 && !pPager->noSync))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 87);
}

// ROR Label 88
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 88);
}

// MCC Label 89
if(rc == 0 && !pPager->noSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 89);
}
// MCC Label 90
if(rc == 0 && !(!pPager->noSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}
// MCC Label 91
if(!(rc == 0) && !pPager->noSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 91);
}
// MCC Label 92
if(!(rc == 0) && !(!pPager->noSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 92);
}
if( rc==SQLITE_OK && !pPager->noSync ){
      rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);
    }

    /* At this point the transaction is committed but the write lock 
    ** is still held on the file. If there is a size limit configured for 
    ** the persistent journal and the journal file currently consumes more
    ** space than that limit allows for, truncate it now. There is no need
    ** to sync the file following this operation.
    */
    
// ABS Label 93
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
// ABS Label 94
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// COR Label 95
if((rc == 0 || iLimit > 0) != (rc == 0 && iLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 95);
}

// ROR Label 96
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
// ROR Label 97
if((iLimit <= 0) != (iLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
// ROR Label 98
if((iLimit < 0) != (iLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
// ROR Label 99
if((iLimit >= 0) != (iLimit > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}

// MCC Label 100
if(rc == 0 && iLimit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 100);
}
// MCC Label 101
if(rc == 0 && !(iLimit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(!(rc == 0) && iLimit > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
// MCC Label 103
if(!(rc == 0) && !(iLimit > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 103);
}
if( rc==SQLITE_OK && iLimit>0 ){
      i64 sz;
      rc = sqlite3OsFileSize(pPager->jfd, &sz);
      
// ABS Label 104
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
// ABS Label 105
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}
// ABS Label 106
if(sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// COR Label 107
if((rc == 0 || sz > iLimit) != (rc == 0 && sz > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 107);
}

// ROR Label 108
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 108);
}
// ROR Label 109
if((sz <= iLimit) != (sz > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}
// ROR Label 110
if((sz < iLimit) != (sz > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
// ROR Label 111
if((sz >= iLimit) != (sz > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 111);
}

// MCC Label 112
if(rc == 0 && sz > iLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(rc == 0 && !(sz > iLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
// MCC Label 114
if(!(rc == 0) && sz > iLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 114);
}
// MCC Label 115
if(!(rc == 0) && !(sz > iLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 115);
}
if( rc==SQLITE_OK && sz>iLimit ){
        rc = sqlite3OsTruncate(pPager->jfd, iLimit);
      }
    }
  }
  
// ABS Label 116
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
return rc;
}

/*
** The journal file must be open when this routine is called. A journal
** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the
** current location.
**
** The format for the journal header is as follows:
** - 8 bytes: Magic identifying journal format.
** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.
** - 4 bytes: Random number used for page hash.
** - 4 bytes: Initial database page count.
** - 4 bytes: Sector size used by the process that wrote this journal.
** - 4 bytes: Database page size.
** 
** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.
*/
static int writeJournalHdr(Pager *pPager){
  int rc = SQLITE_OK;                 /* Return code */
  
// ABS Label 117
if(pPager->pTmpSpace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */
  u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */
  u32 nWrite;                         /* Bytes of header sector written */
  int ii;                             /* Loop counter */

  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */

  
// ABS Label 124
if((pPager->sectorSize) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}
// ABS Label 125
if(nHeader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}

// ROR Label 126
if((nHeader <= (pPager->sectorSize)) != (nHeader > (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
// ROR Label 127
if((nHeader < (pPager->sectorSize)) != (nHeader > (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 127);
}
// ROR Label 128
if((nHeader >= (pPager->sectorSize)) != (nHeader > (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}
if( nHeader>JOURNAL_HDR_SZ(pPager) ){
    nHeader = JOURNAL_HDR_SZ(pPager);
  }

  /* If there are active savepoints and any of them were created 
  ** since the most recent journal header was written, update the 
  ** PagerSavepoint.iHdrOffset fields now.
  */
  ii = 0;

// ABS Label 129
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}
// ABS Label 130
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}

// ROR Label 131
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}
// ROR Label 132
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
// ROR Label 133
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
for(; ii<pPager->nSavepoint; ii++){
    
// ABS Label 139
if(pPager->aSavepoint[ii].iHdrOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}

// ROR Label 140
if((pPager->aSavepoint[ii].iHdrOffset != 0) != (pPager->aSavepoint[ii].iHdrOffset == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 140);
}
if( pPager->aSavepoint[ii].iHdrOffset==0 ){
      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;
    }
  };
// ABS Label 134
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}
// ABS Label 135
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}

// ROR Label 136
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 136);
}
// ROR Label 137
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
// ROR Label 138
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 138);
}


  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);

  /* 
  ** Write the nRec Field - the number of page records that follow this
  ** journal header. Normally, zero is written to this value at this time.
  ** After the records are added to the journal (and the journal synced, 
  ** if in full-sync mode), the zero is overwritten with the true number
  ** of records (see syncJournal()).
  **
  ** A faster alternative is to write 0xFFFFFFFF to the nRec field. When
  ** reading the journal this value tells SQLite to assume that the
  ** rest of the journal file contains valid page records. This assumption
  ** is dangerous, as if a failure occurred whilst writing to the journal
  ** file it may contain some garbage data. There are two scenarios
  ** where this risk can be ignored:
  **
  **   * When the pager is in no-sync mode. Corruption can follow a
  **     power failure in this case anyway.
  **
  **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees
  **     that garbage data is never appended to the journal file.
  */
  assert( isOpen(pPager->fd) || pPager->noSync );
  if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)
   || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) 
  ){
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);
  }else{
    
// AOR Label 141
if(sizeof (aJournalMagic) - 4 != sizeof (aJournalMagic) + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 141);
}
// AOR Label 142
if(sizeof (aJournalMagic) / 4 != sizeof (aJournalMagic) + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 142);
}
// AOR Label 143
if(sizeof (aJournalMagic) * 4 != sizeof (aJournalMagic) + 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 143);
}
memset(zHeader, 0, sizeof(aJournalMagic)+4);
  }

  /* The random check-hash initializer */ 
  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
  put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);
  /* The initial database size */
  put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);
  /* The assumed sector size for this process */
  put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);

  /* The page size */
  put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize);

  /* Initializing the tail of the buffer is not necessary.  Everything
  ** works find if the following memset() is omitted.  But initializing
  ** the memory prevents valgrind from complaining, so we are willing to
  ** take the performance hit.
  */
  
// AOR Label 121
if(nHeader / (sizeof (aJournalMagic) + 20) != nHeader - (sizeof (aJournalMagic) + 20))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 121);
}
// AOR Label 122
if(nHeader + (sizeof (aJournalMagic) + 20) != nHeader - (sizeof (aJournalMagic) + 20))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 122);
}
// AOR Label 123
if(nHeader * (sizeof (aJournalMagic) + 20) != nHeader - (sizeof (aJournalMagic) + 20))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 123);
}
memset(&zHeader[sizeof(aJournalMagic)+20], 0,
         nHeader-(sizeof(aJournalMagic)+20));

  /* In theory, it is only necessary to write the 28 bytes that the 
  ** journal header consumes to the journal file here. Then increment the 
  ** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next 
  ** record is written to the following sector (leaving a gap in the file
  ** that will be implicitly filled in by the OS).
  **
  ** However it has been discovered that on some systems this pattern can 
  ** be significantly slower than contiguously writing data to the file,
  ** even if that means explicitly writing data to the block of 
  ** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what
  ** is done. 
  **
  ** The loop is required here in case the sector-size is larger than the 
  ** database page size. Since the zHeader buffer is only Pager.pageSize
  ** bytes in size, more than one call to sqlite3OsWrite() may be required
  ** to populate the entire journal header sector.
  */ 
  nWrite = 0;

// ABS Label 144
if((pPager->sectorSize) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}
// ABS Label 145
if(nWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}
// ABS Label 146
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// COR Label 147
if((rc == 0 || nWrite < (pPager->sectorSize)) != (rc == 0 && nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 147);
}

// ROR Label 148
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 148);
}
// ROR Label 149
if((nWrite <= (pPager->sectorSize)) != (nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
// ROR Label 150
if((nWrite > (pPager->sectorSize)) != (nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if((nWrite >= (pPager->sectorSize)) != (nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}

// MCC Label 152
if(rc == 0 && nWrite < (pPager->sectorSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 152);
}
// MCC Label 153
if(rc == 0 && !(nWrite < (pPager->sectorSize)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 153);
}
// MCC Label 154
if(!(rc == 0) && nWrite < (pPager->sectorSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 154);
}
// MCC Label 155
if(!(rc == 0) && !(nWrite < (pPager->sectorSize)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 155);
}
for(; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){
    IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))
    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);
    assert( pPager->journalHdr <= pPager->journalOff );
    pPager->journalOff += nHeader;
  };
// ABS Label 156
if((pPager->sectorSize) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
// ABS Label 157
if(nWrite < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
// ABS Label 158
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// COR Label 159
if((rc == 0 || nWrite < (pPager->sectorSize)) != (rc == 0 && nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 159);
}

// ROR Label 160
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((nWrite <= (pPager->sectorSize)) != (nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((nWrite > (pPager->sectorSize)) != (nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((nWrite >= (pPager->sectorSize)) != (nWrite < (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}

// MCC Label 164
if(rc == 0 && nWrite < (pPager->sectorSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(rc == 0 && !(nWrite < (pPager->sectorSize)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
// MCC Label 166
if(!(rc == 0) && nWrite < (pPager->sectorSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(!(rc == 0) && !(nWrite < (pPager->sectorSize)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}


  
// ABS Label 168
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}
return rc;
}

/*
** The journal file must be open when this is called. A journal header file
** (JOURNAL_HDR_SZ bytes) is read from the current location in the journal
** file. The current location in the journal file is given by
** pPager->journalOff. See comments above function writeJournalHdr() for
** a description of the journal header format.
**
** If the header is read successfully, *pNRec is set to the number of
** page records following this header and *pDbSize is set to the size of the
** database before the transaction began, in pages. Also, pPager->cksumInit
** is set to the value read from the journal header. SQLITE_OK is returned
** in this case.
**
** If the journal header file appears to be corrupted, SQLITE_DONE is
** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytes
** cannot be read from the journal file an error code is returned.
*/
static int readJournalHdr(
  Pager *pPager,               /* Pager object */
  int isHot,
  i64 journalSize,             /* Size of the open journal file in bytes */
  u32 *pNRec,                  /* OUT: Value read from the nRec field */
  u32 *pDbSize                 /* OUT: Value of original database size field */
){
  int rc;                      /* Return code */
  unsigned char aMagic[8];     /* A buffer to hold the magic header */
  i64 iHdrOff;                 /* Offset of journal header being read */

  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */

  /* Advance Pager.journalOff to the start of the next sector. If the
  ** journal file is too small for there to be a header stored at this
  ** point, return SQLITE_DONE.
  */
  pPager->journalOff = journalHdrOffset(pPager);
  
// ABS Label 169
if(journalSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
// ABS Label 170
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// AOR Label 171
if(pPager->journalOff - (pPager->sectorSize) != pPager->journalOff + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 171);
}
// AOR Label 172
if(pPager->journalOff / (pPager->sectorSize) != pPager->journalOff + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 172);
}
// AOR Label 173
if(pPager->journalOff * (pPager->sectorSize) != pPager->journalOff + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 173);
}

// ROR Label 174
if((pPager->journalOff + (pPager->sectorSize) <= journalSize) != (pPager->journalOff + (pPager->sectorSize) > journalSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((pPager->journalOff + (pPager->sectorSize) < journalSize) != (pPager->journalOff + (pPager->sectorSize) > journalSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
// ROR Label 176
if((pPager->journalOff + (pPager->sectorSize) >= journalSize) != (pPager->journalOff + (pPager->sectorSize) > journalSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){
    return SQLITE_DONE;
  }
  iHdrOff = pPager->journalOff;

  /* Read in the first 8 bytes of the journal header. If they do not match
  ** the  magic string found at the start of each journal header, return
  ** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,
  ** proceed.
  */
  
// ABS Label 177
if(iHdrOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}
// ABS Label 178
if(isHot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}
// ABS Label 179
if(pPager->journalHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}

// COR Label 180
if((isHot && iHdrOff != pPager->journalHdr) != (isHot || iHdrOff != pPager->journalHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 180);
}

// ROR Label 181
if((iHdrOff == pPager->journalHdr) != (iHdrOff != pPager->journalHdr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 181);
}

// MCC Label 182
if(isHot && iHdrOff != pPager->journalHdr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(isHot && !(iHdrOff != pPager->journalHdr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(!(isHot) && iHdrOff != pPager->journalHdr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}
// MCC Label 185
if(!(isHot) && !(iHdrOff != pPager->journalHdr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 185);
}
if( isHot || iHdrOff!=pPager->journalHdr ){
    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);
    
// ABS Label 186
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
if( rc ){
      
// ABS Label 187
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
return rc;
    }
    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){
      return SQLITE_DONE;
    }
  }

  /* Read the first three 32-bit fields of the journal header: The nRec
  ** field, the checksum-initializer and the database size at the start
  ** of the transaction. Return an error code if anything goes wrong.
  */
  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))
   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))
   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))
  ){
    
// ABS Label 188
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}
return rc;
  }

  
// ABS Label 189
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}

// ROR Label 190
if((pPager->journalOff != 0) != (pPager->journalOff == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}
if( pPager->journalOff==0 ){
    u32 iPageSize;               /* Page-size field of journal header */
    u32 iSectorSize;             /* Sector-size field of journal header */

    /* Read the page-size and sector-size journal header fields. */
    if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))
     || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))
    ){
      
// ABS Label 191
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
return rc;
    }

    /* Versions of SQLite prior to 3.5.8 set the page-size field of the
    ** journal header to zero. In this case, assume that the Pager.pageSize
    ** variable is already set to the correct page size.
    */
    
// ABS Label 192
if(iPageSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}

// ROR Label 193
if((iPageSize != 0) != (iPageSize == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
if( iPageSize==0 ){
      iPageSize = pPager->pageSize;
    }

    /* Check that the values read from the page-size and sector-size fields
    ** are within range. To be 'in range', both values need to be a power
    ** of two greater than or equal to 512 or 32, and not greater than their 
    ** respective compile time maximum limits.
    */
    
// ABS Label 194
if(iPageSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}
// ABS Label 195
if(iSectorSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}

// COR Label 196
if((iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536 || iSectorSize > 65536 || ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0) != (iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536 || iSectorSize > 65536 || ((iPageSize - 1) & iPageSize) != 0 || ((iSectorSize - 1) & iSectorSize) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 196);
}
// COR Label 197
if((iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536 || iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0) != (iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536 || iSectorSize > 65536 || ((iPageSize - 1) & iPageSize) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 197);
}
// COR Label 198
if((iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536 && iSectorSize > 65536) != (iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536 || iSectorSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 198);
}
// COR Label 199
if((iPageSize < 512 || iSectorSize < 32 && iPageSize > 65536) != (iPageSize < 512 || iSectorSize < 32 || iPageSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 199);
}
// COR Label 200
if((iPageSize < 512 && iSectorSize < 32) != (iPageSize < 512 || iSectorSize < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 200);
}

// ROR Label 201
if((iPageSize <= 512) != (iPageSize < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
// ROR Label 202
if((iPageSize > 512) != (iPageSize < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
// ROR Label 203
if((iPageSize >= 512) != (iPageSize < 512))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
// ROR Label 204
if((iSectorSize <= 32) != (iSectorSize < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((iSectorSize > 32) != (iSectorSize < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((iSectorSize >= 32) != (iSectorSize < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((iPageSize <= 65536) != (iPageSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
// ROR Label 208
if((iPageSize < 65536) != (iPageSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((iPageSize >= 65536) != (iPageSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((iSectorSize <= 65536) != (iSectorSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
// ROR Label 211
if((iSectorSize < 65536) != (iSectorSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
// ROR Label 212
if((iSectorSize >= 65536) != (iSectorSize > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 212);
}
// ROR Label 213
if((((iPageSize - 1) & iPageSize) == 0) != (((iPageSize - 1) & iPageSize) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 213);
}
// ROR Label 214
if((((iSectorSize - 1) & iSectorSize) == 0) != (((iSectorSize - 1) & iSectorSize) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 214);
}

// MCC Label 215
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
// MCC Label 219
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
// MCC Label 222
if(iPageSize < 512 && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
// MCC Label 223
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(iPageSize < 512 && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
// MCC Label 234
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
// MCC Label 235
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
// MCC Label 236
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
// MCC Label 237
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 237);
}
// MCC Label 238
if(iPageSize < 512 && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 238);
}
// MCC Label 239
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 239);
}
// MCC Label 240
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}
// MCC Label 242
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 242);
}
// MCC Label 243
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 243);
}
// MCC Label 244
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 244);
}
// MCC Label 245
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(iPageSize < 512 && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
// MCC Label 247
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
// MCC Label 249
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 249);
}
// MCC Label 250
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 250);
}
// MCC Label 251
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 251);
}
// MCC Label 252
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 252);
}
// MCC Label 253
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 253);
}
// MCC Label 254
if(!(iPageSize < 512) && iSectorSize < 32 && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 254);
}
// MCC Label 255
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
// MCC Label 256
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 256);
}
// MCC Label 257
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 257);
}
// MCC Label 258
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 258);
}
// MCC Label 259
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 259);
}
// MCC Label 260
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(!(iPageSize < 512) && iSectorSize < 32 && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
// MCC Label 264
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(!(iPageSize < 512) && !(iSectorSize < 32) && iPageSize > 65536 && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
// MCC Label 271
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 271);
}
// MCC Label 272
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 272);
}
// MCC Label 273
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 273);
}
// MCC Label 274
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && iSectorSize > 65536 && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 274);
}
// MCC Label 275
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
// MCC Label 276
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && ((iPageSize - 1) & iPageSize) != 0 && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 276);
}
// MCC Label 277
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && ((iSectorSize - 1) & iSectorSize) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 277);
}
// MCC Label 278
if(!(iPageSize < 512) && !(iSectorSize < 32) && !(iPageSize > 65536) && !(iSectorSize > 65536) && !(((iPageSize - 1) & iPageSize) != 0) && !(((iSectorSize - 1) & iSectorSize) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}
if( iPageSize<512                  || iSectorSize<32
     || iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZE
     || ((iPageSize-1)&iPageSize)!=0   || ((iSectorSize-1)&iSectorSize)!=0 
    ){
      /* If the either the page-size or sector-size in the journal-header is 
      ** invalid, then the process that wrote the journal-header must have 
      ** crashed before the header was synced. In this case stop reading 
      ** the journal file here.
      */
      return SQLITE_DONE;
    }

    /* Update the page-size to match the value read from the journal. 
    ** Use a testcase() macro to make sure that malloc failure within 
    ** PagerSetPagesize() is tested.
    */
    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);
    testcase( rc!=SQLITE_OK );

    /* Update the assumed sector-size to match the value used by 
    ** the process that created this journal. If this journal was
    ** created by a process other than this one, then this routine
    ** is being called from within pager_playback(). The local value
    ** of Pager.sectorSize is restored at the end of that routine.
    */
    pPager->sectorSize = iSectorSize;
  }

  pPager->journalOff += JOURNAL_HDR_SZ(pPager);
  
// ABS Label 279
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}
return rc;
}


/*
** Write the supplied super-journal name into the journal file for pager
** pPager at the current location. The super-journal name must be the last
** thing written to a journal file. If the pager is in full-sync mode, the
** journal file descriptor is advanced to the next sector boundary before
** anything is written. The format is:
**
**   + 4 bytes: PAGER_MJ_PGNO.
**   + N bytes: super-journal filename in utf-8.
**   + 4 bytes: N (length of super-journal name in bytes, no nul-terminator).
**   + 4 bytes: super-journal name checksum.
**   + 8 bytes: aJournalMagic[].
**
** The super-journal page checksum is the sum of the bytes in thesuper-journal
** name, where each byte is interpreted as a signed 8-bit integer.
**
** If zSuper is a NULL pointer (occurs for a single database transaction), 
** this call is a no-op.
*/
static int writeSuperJournal(Pager *pPager, const char *zSuper){
  int rc;                          /* Return code */
  int nSuper;                      /* Length of string zSuper */
  i64 iHdrOff;                     /* Offset of header in journal file */
  i64 jrnlSize;                    /* Size of journal file on disk */
  u32 cksum = 0;                   /* Checksum of string zSuper */

  assert( pPager->setSuper==0 );
  assert( !pagerUseWal(pPager) );

  
// COR Label 280
if((!zSuper || pPager->journalMode == 4 && !((pPager->jfd)->pMethods != 0)) != (!zSuper || pPager->journalMode == 4 || !((pPager->jfd)->pMethods != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 280);
}
// COR Label 281
if((!zSuper && pPager->journalMode == 4) != (!zSuper || pPager->journalMode == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 281);
}

// ROR Label 282
if((pPager->journalMode != 4) != (pPager->journalMode == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}

// MCC Label 283
if(!zSuper && pPager->journalMode == 4 && !((pPager->jfd)->pMethods != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}
// MCC Label 284
if(!zSuper && pPager->journalMode == 4 && !(!((pPager->jfd)->pMethods != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 284);
}
// MCC Label 285
if(!zSuper && !(pPager->journalMode == 4) && !((pPager->jfd)->pMethods != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 285);
}
// MCC Label 286
if(!zSuper && !(pPager->journalMode == 4) && !(!((pPager->jfd)->pMethods != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 286);
}
// MCC Label 287
if(!(!zSuper) && pPager->journalMode == 4 && !((pPager->jfd)->pMethods != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 287);
}
// MCC Label 288
if(!(!zSuper) && pPager->journalMode == 4 && !(!((pPager->jfd)->pMethods != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 288);
}
// MCC Label 289
if(!(!zSuper) && !(pPager->journalMode == 4) && !((pPager->jfd)->pMethods != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 289);
}
// MCC Label 290
if(!(!zSuper) && !(pPager->journalMode == 4) && !(!((pPager->jfd)->pMethods != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 290);
}
if( !zSuper 
   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY 
   || !isOpen(pPager->jfd)
  ){
    return SQLITE_OK;
  }
  pPager->setSuper = 1;
  assert( pPager->journalHdr <= pPager->journalOff );

  /* Calculate the length in bytes and the checksum of zSuper */
  nSuper = 0;

// ABS Label 291
if(nSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}
// ABS Label 292
if(zSuper[nSuper] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
for(; zSuper[nSuper]; nSuper++){
    cksum += zSuper[nSuper];
  };
// ABS Label 293
if(nSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
// ABS Label 294
if(zSuper[nSuper] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}


  /* If in full-sync mode, advance to the next disk sector before writing
  ** the super-journal name. This is in case the previous page written to
  ** the journal has already been synced.
  */
  
// ABS Label 295
if(pPager->fullSync < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
if( pPager->fullSync ){
    pPager->journalOff = journalHdrOffset(pPager);
  }
  iHdrOff = pPager->journalOff;

  /* Write the super-journal data to the end of the journal file. If
  ** an error occurs, return the error code to the caller.
  */
  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zSuper, nSuper, iHdrOff+4)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper, nSuper)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper+4, cksum)))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,
                                 iHdrOff+4+nSuper+8)))
  ){
    
// ABS Label 296
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
return rc;
  }
  pPager->journalOff += (nSuper+20);

  /* If the pager is in peristent-journal mode, then the physical 
  ** journal-file may extend past the end of the super-journal name
  ** and 8 bytes of magic data just written to the file. This is 
  ** dangerous because the code to rollback a hot-journal file
  ** will not be able to find the super-journal name to determine 
  ** whether or not the journal is hot. 
  **
  ** Easiest thing to do in this scenario is to truncate the journal 
  ** file to the required size.
  */ 
  if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))
   && jrnlSize>pPager->journalOff
  ){
    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
  }
  
// ABS Label 297
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
return rc;
}

/*
** Discard the entire contents of the in-memory page-cache.
*/
static void pager_reset(Pager *pPager){
  pPager->iDataVersion++;
  
// ABS Label 298
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
sqlite3BackupRestart(pPager->pBackup);
  
// ABS Label 299
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
sqlite3PcacheClear(pPager->pPCache);
}

/*
** Return the pPager->iDataVersion value
*/
u32 sqlite3PagerDataVersion(Pager *pPager){
  
// ABS Label 300
if(pPager->iDataVersion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
return pPager->iDataVersion;
}

/*
** Free all structures in the Pager.aSavepoint[] array and set both
** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal
** if it is open and the pager is not in exclusive mode.
*/
static void releaseAllSavepoints(Pager *pPager){
  int ii;               /* Iterator for looping through Pager.aSavepoint */
  ii = 0;

// ABS Label 301
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}
// ABS Label 302
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}

// ROR Label 303
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 303);
}
// ROR Label 304
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
// ROR Label 305
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}
for(; ii<pPager->nSavepoint; ii++){
    
// ABS Label 311
if(pPager->aSavepoint[ii].pInSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
  };
// ABS Label 306
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
// ABS Label 307
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}

// ROR Label 308
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 308);
}
// ROR Label 309
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
// ROR Label 310
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}

  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){
    
// ABS Label 312
if(pPager->sjfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
sqlite3OsClose(pPager->sjfd);
  }
  sqlite3_free(pPager->aSavepoint);
  pPager->aSavepoint = 0;
  pPager->nSavepoint = 0;
  pPager->nSubRec = 0;
}

/*
** Set the bit number pgno in the PagerSavepoint.pInSavepoint 
** bitvecs of all open savepoints. Return SQLITE_OK if successful
** or SQLITE_NOMEM if a malloc failure occurs.
*/
static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){
  int ii;                   /* Loop counter */
  int rc = SQLITE_OK;       /* Result code */

  ii = 0;

// ABS Label 313
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
// ABS Label 314
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}

// ROR Label 315
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}
// ROR Label 316
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
// ROR Label 317
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}
for(; ii<pPager->nSavepoint; ii++){
    PagerSavepoint *p = &pPager->aSavepoint[ii];
    
// ABS Label 323
if(p->nOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
// ABS Label 324
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ROR Label 325
if((pgno < p->nOrig) != (pgno <= p->nOrig))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}
// ROR Label 326
if((pgno > p->nOrig) != (pgno <= p->nOrig))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 326);
}
// ROR Label 327
if((pgno >= p->nOrig) != (pgno <= p->nOrig))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
if( pgno<=p->nOrig ){
      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);
      testcase( rc==SQLITE_NOMEM );
      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
    }
  };
// ABS Label 318
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
// ABS Label 319
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}

// ROR Label 320
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 320);
}
// ROR Label 321
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 321);
}
// ROR Label 322
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}

  
// ABS Label 328
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
return rc;
}

/*
** This function is a no-op if the pager is in exclusive mode and not
** in the ERROR state. Otherwise, it switches the pager to PAGER_OPEN
** state.
**
** If the pager is not in exclusive-access mode, the database file is
** completely unlocked. If the file is unlocked and the file-system does
** not exhibit the UNDELETABLE_WHEN_OPEN property, the journal file is
** closed (if it is open).
**
** If the pager is in ERROR state when this function is called, the 
** contents of the pager cache are discarded before switching back to 
** the OPEN state. Regardless of whether the pager is in exclusive-mode
** or not, any journal file left in the file-system will be treated
** as a hot-journal and rolled back the next time a read-transaction
** is opened (by this or by any other connection).
*/
static void pager_unlock(Pager *pPager){

  assert( pPager->eState==PAGER_READER 
       || pPager->eState==PAGER_OPEN 
       || pPager->eState==PAGER_ERROR 
  );

  
// ABS Label 329
if(pPager->pInJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  
// ABS Label 330
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
releaseAllSavepoints(pPager);

  
// MCC Label 331
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 331);
}
// MCC Label 332
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 332);
}
if( pagerUseWal(pPager) ){
    assert( !isOpen(pPager->jfd) );
    
// ABS Label 333
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
sqlite3WalEndReadTransaction(pPager->pWal);
    pPager->eState = PAGER_OPEN;
  }else { if( !pPager->exclusiveMode ){
    int rc;                       /* Error code returned by pagerUnlockDb() */
    int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;

    /* If the operating system support deletion of open files, then
    ** close the journal file when dropping the database lock.  Otherwise
    ** another connection with journal_mode=delete might delete the file
    ** out from under us.
    */
    assert( (PAGER_JOURNALMODE_MEMORY   & 5)!=1 );
    assert( (PAGER_JOURNALMODE_OFF      & 5)!=1 );
    assert( (PAGER_JOURNALMODE_WAL      & 5)!=1 );
    assert( (PAGER_JOURNALMODE_DELETE   & 5)!=1 );
    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );
    assert( (PAGER_JOURNALMODE_PERSIST  & 5)==1 );
    
// COR Label 334
if((0 == (iDc & 2048) && 1 != (pPager->journalMode & 5)) != (0 == (iDc & 2048) || 1 != (pPager->journalMode & 5)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 334);
}

// ROR Label 335
if((0 != (iDc & 2048)) != (0 == (iDc & 2048)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 335);
}
// ROR Label 336
if((1 == (pPager->journalMode & 5)) != (1 != (pPager->journalMode & 5)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}

// MCC Label 337
if(0 == (iDc & 2048) && 1 != (pPager->journalMode & 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 337);
}
// MCC Label 338
if(0 == (iDc & 2048) && !(1 != (pPager->journalMode & 5)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 338);
}
// MCC Label 339
if(!(0 == (iDc & 2048)) && 1 != (pPager->journalMode & 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 339);
}
// MCC Label 340
if(!(0 == (iDc & 2048)) && !(1 != (pPager->journalMode & 5)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 340);
}
if( 0==(iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)
     || 1!=(pPager->journalMode & 5)
    ){
      
// ABS Label 341
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
sqlite3OsClose(pPager->jfd);
    }

    /* If the pager is in the ERROR state and the call to unlock the database
    ** file fails, set the current lock to UNKNOWN_LOCK. See the comment
    ** above the #define for UNKNOWN_LOCK for an explanation of why this
    ** is necessary.
    */
    rc = pagerUnlockDb(pPager, NO_LOCK);
    
// ABS Label 342
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// COR Label 343
if((rc != 0 || pPager->eState == 6) != (rc != 0 && pPager->eState == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 343);
}

// ROR Label 344
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
// ROR Label 345
if((pPager->eState != 6) != (pPager->eState == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 345);
}

// MCC Label 346
if(rc != 0 && pPager->eState == 6 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 346);
}
// MCC Label 347
if(rc != 0 && !(pPager->eState == 6) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 347);
}
// MCC Label 348
if(!(rc != 0) && pPager->eState == 6 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 348);
}
// MCC Label 349
if(!(rc != 0) && !(pPager->eState == 6) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){
      pPager->eLock = UNKNOWN_LOCK;
    }

    /* The pager state may be changed from PAGER_ERROR to PAGER_OPEN here
    ** without clearing the error code. This is intentional - the error
    ** code is cleared and the cache reset in the block below.
    */
    assert( pPager->errCode || pPager->eState!=PAGER_ERROR );
    pPager->eState = PAGER_OPEN;
  };}


  /* If Pager.errCode is set, the contents of the pager cache cannot be
  ** trusted. Now that there are no outstanding references to the pager,
  ** it can safely move back to PAGER_OPEN state. This happens in both
  ** normal and exclusive-locking mode.
  */
  assert( pPager->errCode==SQLITE_OK || !MEMDB );
  
// ABS Label 350
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
if( pPager->errCode ){
    
// ROR Label 352
if((pPager->tempFile != 0) != (pPager->tempFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 352);
}
if( pPager->tempFile==0 ){
      
// ABS Label 353
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}
pager_reset(pPager);
      pPager->changeCountDone = 0;
      pPager->eState = PAGER_OPEN;
    }else{
      pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);
    }
    
// ABS Label 354
if(((pPager)->bUseFetch) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
if( USEFETCH(pPager) ) { 
// ABS Label 355
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
sqlite3OsUnfetch(pPager->fd, 0, 0);
}
    pPager->errCode = SQLITE_OK;
    
// ABS Label 351
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
setGetterMethod(pPager);
  }

  pPager->journalOff = 0;
  pPager->journalHdr = 0;
  pPager->setSuper = 0;
}

/*
** This function is called whenever an IOERR or FULL error that requires
** the pager to transition into the ERROR state may ahve occurred.
** The first argument is a pointer to the pager structure, the second 
** the error-code about to be returned by a pager API function. The 
** value returned is a copy of the second argument to this function. 
**
** If the second argument is SQLITE_FULL, SQLITE_IOERR or one of the
** IOERR sub-codes, the pager enters the ERROR state and the error code
** is stored in Pager.errCode. While the pager remains in the ERROR state,
** all major API calls on the Pager will immediately return Pager.errCode.
**
** The ERROR state indicates that the contents of the pager-cache 
** cannot be trusted. This state can be cleared by completely discarding 
** the contents of the pager-cache. If a transaction was active when
** the persistent error occurred, then the rollback journal may need
** to be replayed to restore the contents of the database file (as if
** it were a hot-journal).
*/
static int pager_error(Pager *pPager, int rc){
  
// ABS Label 356
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// AOR Label 357
if(rc | 255 != rc & 255)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 357);
}
// AOR Label 358
if(rc ^ 255 != rc & 255)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 358);
}
int rc2 = rc & 0xff;
  assert( rc==SQLITE_OK || !MEMDB );
  assert(
       pPager->errCode==SQLITE_FULL ||
       pPager->errCode==SQLITE_OK ||
       (pPager->errCode & 0xff)==SQLITE_IOERR
  );
  
// ABS Label 359
if(rc2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}

// COR Label 360
if((rc2 == 13 && rc2 == 10) != (rc2 == 13 || rc2 == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 360);
}

// ROR Label 361
if((rc2 != 13) != (rc2 == 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 361);
}
// ROR Label 362
if((rc2 != 10) != (rc2 == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}

// MCC Label 363
if(rc2 == 13 && rc2 == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
// MCC Label 364
if(rc2 == 13 && !(rc2 == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 364);
}
// MCC Label 365
if(!(rc2 == 13) && rc2 == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 365);
}
// MCC Label 366
if(!(rc2 == 13) && !(rc2 == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 366);
}
if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){
    pPager->errCode = rc;
    pPager->eState = PAGER_ERROR;
    
// ABS Label 367
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}
setGetterMethod(pPager);
  }
  
// ABS Label 368
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}
return rc;
}

static int pager_truncate(Pager *pPager, Pgno nPage);

/*
** The write transaction open on pPager is being committed (bCommit==1)
** or rolled back (bCommit==0).
**
** Return TRUE if and only if all dirty pages should be flushed to disk.
**
** Rules:
**
**   *  For non-TEMP databases, always sync to disk.  This is necessary
**      for transactions to be durable.
**
**   *  Sync TEMP database only on a COMMIT (not a ROLLBACK) when the backing
**      file has been created already (via a spill on pagerStress()) and
**      when the number of dirty pages in memory exceeds 25% of the total
**      cache size.
*/
static int pagerFlushOnCommit(Pager *pPager, int bCommit){
  
// ROR Label 369
if((pPager->tempFile != 0) != (pPager->tempFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}
if( pPager->tempFile==0 ) { return 1;
}
  if( !bCommit ) { return 0;
}
  if( !isOpen(pPager->fd) ) { return 0;
}
  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);
}

/*
** This routine ends a transaction. A transaction is usually ended by 
** either a COMMIT or a ROLLBACK operation. This routine may be called 
** after rollback of a hot-journal, or if an error occurs while opening
** the journal file or writing the very first journal-header of a
** database transaction.
** 
** This routine is never called in PAGER_ERROR state. If it is called
** in PAGER_NONE or PAGER_SHARED state and the lock held is less
** exclusive than a RESERVED lock, it is a no-op.
**
** Otherwise, any active savepoints are released.
**
** If the journal file is open, then it is "finalized". Once a journal 
** file has been finalized it is not possible to use it to roll back a 
** transaction. Nor will it be considered to be a hot-journal by this
** or any other database connection. Exactly how a journal is finalized
** depends on whether or not the pager is running in exclusive mode and
** the current journal-mode (Pager.journalMode value), as follows:
**
**   journalMode==MEMORY
**     Journal file descriptor is simply closed. This destroys an 
**     in-memory journal.
**
**   journalMode==TRUNCATE
**     Journal file is truncated to zero bytes in size.
**
**   journalMode==PERSIST
**     The first 28 bytes of the journal file are zeroed. This invalidates
**     the first journal header in the file, and hence the entire journal
**     file. An invalid journal file cannot be rolled back.
**
**   journalMode==DELETE
**     The journal file is closed and deleted using sqlite3OsDelete().
**
**     If the pager is running in exclusive mode, this method of finalizing
**     the journal file is never used. Instead, if the journalMode is
**     DELETE and the pager is in exclusive mode, the method described under
**     journalMode==PERSIST is used instead.
**
** After the journal is finalized, the pager moves to PAGER_READER state.
** If running in non-exclusive rollback mode, the lock on the file is 
** downgraded to a SHARED_LOCK.
**
** SQLITE_OK is returned if no error occurs. If an error occurs during
** any of the IO operations to finalize the journal file or unlock the
** database then the IO error code is returned to the user. If the 
** operation to finalize the journal file fails, then the code still
** tries to unlock the database file if not in exclusive mode. If the
** unlock operation fails as well, then the first error code related
** to the first error encountered (the journal finalization one) is
** returned.
*/
static int pager_end_transaction(Pager *pPager, int hasSuper, int bCommit){
  int rc = SQLITE_OK;      /* Error code from journal finalization operation */
  int rc2 = SQLITE_OK;     /* Error code from db file unlock operation */

  /* Do nothing if the pager does not have an open write transaction
  ** or at least a RESERVED lock. This function may be called when there
  ** is no write-transaction active but a RESERVED or greater lock is
  ** held under two circumstances:
  **
  **   1. After a successful hot-journal rollback, it is called with
  **      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.
  **
  **   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE 
  **      lock switches back to locking_mode=normal and then executes a
  **      read-transaction, this function is called with eState==PAGER_READER 
  **      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.
  */
  assert( assert_pager_state(pPager) );
  assert( pPager->eState!=PAGER_ERROR );
  
// COR Label 372
if((pPager->eState < 2 || pPager->eLock < 2) != (pPager->eState < 2 && pPager->eLock < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 372);
}

// ROR Label 373
if((pPager->eState <= 2) != (pPager->eState < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 373);
}
// ROR Label 374
if((pPager->eState > 2) != (pPager->eState < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 374);
}
// ROR Label 375
if((pPager->eState >= 2) != (pPager->eState < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
// ROR Label 376
if((pPager->eLock <= 2) != (pPager->eLock < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((pPager->eLock > 2) != (pPager->eLock < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((pPager->eLock >= 2) != (pPager->eLock < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}

// MCC Label 379
if(pPager->eState < 2 && pPager->eLock < 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(pPager->eState < 2 && !(pPager->eLock < 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(!(pPager->eState < 2) && pPager->eLock < 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(!(pPager->eState < 2) && !(pPager->eLock < 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}
if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){
    return SQLITE_OK;
  }

  
// ABS Label 370
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}
releaseAllSavepoints(pPager);
  assert( isOpen(pPager->jfd) || pPager->pInJournal==0 
      || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_BATCH_ATOMIC)
  );
  
// MCC Label 383
if(( (pPager->jfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(( !((pPager->jfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
if( isOpen(pPager->jfd) ){
    assert( !pagerUseWal(pPager) );

    /* Finalize the journal file. */
    if( sqlite3JournalIsInMemory(pPager->jfd) ){
      /* assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ); */
      
// ABS Label 385
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
sqlite3OsClose(pPager->jfd);
    }else { 
// ROR Label 386
if((pPager->journalMode != 3) != (pPager->journalMode == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){
      
// ABS Label 387
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// ROR Label 388
if((pPager->journalOff != 0) != (pPager->journalOff == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 388);
}
if( pPager->journalOff==0 ){
        rc = SQLITE_OK;
      }else{
        rc = sqlite3OsTruncate(pPager->jfd, 0);
        
// ABS Label 389
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}

// COR Label 390
if((rc == 0 || pPager->fullSync) != (rc == 0 && pPager->fullSync))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 390);
}

// ROR Label 391
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}

// MCC Label 392
if(rc == 0 && pPager->fullSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
// MCC Label 393
if(rc == 0 && !(pPager->fullSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(!(rc == 0) && pPager->fullSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(!(rc == 0) && !(pPager->fullSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
if( rc==SQLITE_OK && pPager->fullSync ){
          /* Make sure the new file size is written into the inode right away.
          ** Otherwise the journal might resurrect following a power loss and
          ** cause the last transaction to roll back.  See
          ** https://bugzilla.mozilla.org/show_bug.cgi?id=1072773
          */
          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
        }
      }
      pPager->journalOff = 0;
    }else { 
// COR Label 396
if((pPager->journalMode == 1 && (pPager->exclusiveMode && pPager->journalMode != 5)) != (pPager->journalMode == 1 || (pPager->exclusiveMode && pPager->journalMode != 5)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 396);
}

// ROR Label 397
if((pPager->journalMode != 1) != (pPager->journalMode == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 397);
}

// MCC Label 398
if(pPager->journalMode == 1 && ( pPager->exclusiveMode && pPager->journalMode != 5 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 398);
}
// MCC Label 399
if(pPager->journalMode == 1 && ( pPager->exclusiveMode && !(pPager->journalMode != 5) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 399);
}
// MCC Label 400
if(pPager->journalMode == 1 && ( !(pPager->exclusiveMode) && pPager->journalMode != 5 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 400);
}
// MCC Label 401
if(pPager->journalMode == 1 && ( !(pPager->exclusiveMode) && !(pPager->journalMode != 5) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 401);
}
// MCC Label 402
if(!(pPager->journalMode == 1) && ( pPager->exclusiveMode && pPager->journalMode != 5 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 402);
}
// MCC Label 403
if(!(pPager->journalMode == 1) && ( pPager->exclusiveMode && !(pPager->journalMode != 5) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 403);
}
// MCC Label 404
if(!(pPager->journalMode == 1) && ( !(pPager->exclusiveMode) && pPager->journalMode != 5 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 404);
}
// MCC Label 405
if(!(pPager->journalMode == 1) && ( !(pPager->exclusiveMode) && !(pPager->journalMode != 5) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 405);
}
if( pPager->journalMode==PAGER_JOURNALMODE_PERSIST
      || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)
    ){
      rc = zeroJournalHdr(pPager, hasSuper||pPager->tempFile);
      pPager->journalOff = 0;
    }else{
      /* This branch may be executed with Pager.journalMode==MEMORY if
      ** a hot-journal was just rolled back. In this case the journal
      ** file should be closed and deleted. If this connection writes to
      ** the database file, it will do so using an in-memory journal.
      */
      int bDelete = !pPager->tempFile;
      assert( sqlite3JournalIsInMemory(pPager->jfd)==0 );
      assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE 
           || pPager->journalMode==PAGER_JOURNALMODE_MEMORY 
           || pPager->journalMode==PAGER_JOURNALMODE_WAL 
      );
      
// ABS Label 406
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
sqlite3OsClose(pPager->jfd);
      
// ABS Label 407
if(bDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}
if( bDelete ){
        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
      }
    };}
;}

  }

#ifdef SQLITE_CHECK_PAGES
  sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);
  if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){
    PgHdr *p = sqlite3PagerLookup(pPager, 1);
    if( p ){
      p->pageHash = 0;
      sqlite3PagerUnrefNotNull(p);
    }
  }
#endif

  
// ABS Label 371
if(pPager->pInJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}
sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  pPager->nRec = 0;
  
// ABS Label 408
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}

// ROR Label 409
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 409);
}
if( rc==SQLITE_OK ){
    if( MEMDB || pagerFlushOnCommit(pPager, bCommit) ){
      
// ABS Label 412
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}
sqlite3PcacheCleanAll(pPager->pPCache);
    }else{
      
// ABS Label 413
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
sqlite3PcacheClearWritable(pPager->pPCache);
    }
    
// ABS Label 410
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ABS Label 411
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}
sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
  }

  
// MCC Label 414
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 414);
}
// MCC Label 415
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 415);
}
if( pagerUseWal(pPager) ){
    /* Drop the WAL write-lock, if any. Also, if the connection was in 
    ** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE 
    ** lock held on the database file.
    */
    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
    assert( rc2==SQLITE_OK );
  }else { 
// ABS Label 416
if(bCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
// ABS Label 417
if(pPager->dbFileSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
// ABS Label 418
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
// ABS Label 419
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}

// COR Label 420
if((rc == 0 && bCommit || pPager->dbFileSize > pPager->dbSize) != (rc == 0 && bCommit && pPager->dbFileSize > pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 420);
}
// COR Label 421
if((rc == 0 || bCommit) != (rc == 0 && bCommit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 421);
}

// ROR Label 422
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 422);
}
// ROR Label 423
if((pPager->dbFileSize <= pPager->dbSize) != (pPager->dbFileSize > pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 423);
}
// ROR Label 424
if((pPager->dbFileSize < pPager->dbSize) != (pPager->dbFileSize > pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 424);
}
// ROR Label 425
if((pPager->dbFileSize >= pPager->dbSize) != (pPager->dbFileSize > pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}

// MCC Label 426
if(rc == 0 && bCommit && pPager->dbFileSize > pPager->dbSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 426);
}
// MCC Label 427
if(rc == 0 && bCommit && !(pPager->dbFileSize > pPager->dbSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 427);
}
// MCC Label 428
if(rc == 0 && !(bCommit) && pPager->dbFileSize > pPager->dbSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 428);
}
// MCC Label 429
if(rc == 0 && !(bCommit) && !(pPager->dbFileSize > pPager->dbSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 429);
}
// MCC Label 430
if(!(rc == 0) && bCommit && pPager->dbFileSize > pPager->dbSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 430);
}
// MCC Label 431
if(!(rc == 0) && bCommit && !(pPager->dbFileSize > pPager->dbSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 431);
}
// MCC Label 432
if(!(rc == 0) && !(bCommit) && pPager->dbFileSize > pPager->dbSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 432);
}
// MCC Label 433
if(!(rc == 0) && !(bCommit) && !(pPager->dbFileSize > pPager->dbSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 433);
}
if( rc==SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize ){
    /* This branch is taken when committing a transaction in rollback-journal
    ** mode if the database file on disk is larger than the database image.
    ** At this point the journal has been finalized and the transaction 
    ** successfully committed, but the EXCLUSIVE lock is still held on the
    ** file. So it is safe to truncate the database file to its minimum
    ** required size.  */
    assert( pPager->eLock==EXCLUSIVE_LOCK );
    rc = pager_truncate(pPager, pPager->dbSize);
  };}


  
// ABS Label 434
if(bCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}
// ABS Label 435
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}

// COR Label 436
if((rc == 0 || bCommit) != (rc == 0 && bCommit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 436);
}

// ROR Label 437
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}

// MCC Label 438
if(rc == 0 && bCommit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 438);
}
// MCC Label 439
if(rc == 0 && !(bCommit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 439);
}
// MCC Label 440
if(!(rc == 0) && bCommit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(!(rc == 0) && !(bCommit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
if( rc==SQLITE_OK && bCommit ){
    rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);
    
// ABS Label 442
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}

// ROR Label 443
if((rc != 12) != (rc == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 443);
}
if( rc==SQLITE_NOTFOUND ) { rc = SQLITE_OK;
}
  }

  if( !pPager->exclusiveMode 
   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))
  ){
    rc2 = pagerUnlockDb(pPager, SHARED_LOCK);
  }
  pPager->eState = PAGER_READER;
  pPager->setSuper = 0;

  
// MCC Label 444
if(( ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 444);
}
return (rc==SQLITE_OK?rc2:rc);
}

/*
** Execute a rollback if a transaction is active and unlock the 
** database file. 
**
** If the pager has already entered the ERROR state, do not attempt 
** the rollback at this time. Instead, pager_unlock() is called. The
** call to pager_unlock() will discard all in-memory pages, unlock
** the database file and move the pager back to OPEN state. If this 
** means that there is a hot-journal left in the file-system, the next 
** connection to obtain a shared lock on the pager (which may be this one) 
** will roll it back.
**
** If the pager has not already entered the ERROR state, but an IO or
** malloc error occurs during a rollback, then this will itself cause 
** the pager to enter the ERROR state. Which will be cleared by the
** call to pager_unlock(), as described above.
*/
static void pagerUnlockAndRollback(Pager *pPager){
  
// COR Label 446
if((pPager->eState != 6 || pPager->eState != 0) != (pPager->eState != 6 && pPager->eState != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 446);
}

// ROR Label 447
if((pPager->eState == 6) != (pPager->eState != 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((pPager->eState == 0) != (pPager->eState != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}

// MCC Label 449
if(pPager->eState != 6 && pPager->eState != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 449);
}
// MCC Label 450
if(pPager->eState != 6 && !(pPager->eState != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 450);
}
// MCC Label 451
if(!(pPager->eState != 6) && pPager->eState != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 451);
}
// MCC Label 452
if(!(pPager->eState != 6) && !(pPager->eState != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 452);
}
if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){
    assert( assert_pager_state(pPager) );
    
// ROR Label 453
if((pPager->eState < 2) != (pPager->eState >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}
// ROR Label 454
if((pPager->eState > 2) != (pPager->eState >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 454);
}
// ROR Label 455
if((pPager->eState <= 2) != (pPager->eState >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}
if( pPager->eState>=PAGER_WRITER_LOCKED ){
      sqlite3BeginBenignMalloc();
      
// ABS Label 456
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}
sqlite3PagerRollback(pPager);
      sqlite3EndBenignMalloc();
    }else { if( !pPager->exclusiveMode ){
      assert( pPager->eState==PAGER_READER );
      
// ABS Label 457
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
pager_end_transaction(pPager, 0, 0);
    };}

  }
  
// ABS Label 445
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}
pager_unlock(pPager);
}

/*
** Parameter aData must point to a buffer of pPager->pageSize bytes
** of data. Compute and return a checksum based ont the contents of the 
** page of data and the current value of pPager->cksumInit.
**
** This is not a real checksum. It is really just the sum of the 
** random initial value (pPager->cksumInit) and every 200th byte
** of the page data, starting with byte offset (pPager->pageSize%200).
** Each byte is interpreted as an 8-bit unsigned integer.
**
** Changing the formula used to compute this checksum results in an
** incompatible journal file format.
**
** If journal corruption occurs due to a power failure, the most likely 
** scenario is that one end or the other of the record will be changed. 
** It is much less likely that the two ends of the journal record will be
** correct and the middle be corrupt.  Thus, this "checksum" scheme,
** though fast and simple, catches the mostly likely kind of corruption.
*/
static u32 pager_cksum(Pager *pPager, const u8 *aData){
  
// ABS Label 458
if(pPager->cksumInit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
u32 cksum = pPager->cksumInit;         /* Checksum value to return */
  
// ABS Label 459
if(pPager->pageSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// AOR Label 460
if(pPager->pageSize / 200 != pPager->pageSize - 200)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 460);
}
// AOR Label 461
if(pPager->pageSize + 200 != pPager->pageSize - 200)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 461);
}
// AOR Label 462
if(pPager->pageSize * 200 != pPager->pageSize - 200)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 462);
}
int i = pPager->pageSize-200;          /* Loop counter */
  
// ABS Label 463
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}

// ROR Label 464
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 464);
}
// ROR Label 465
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
// ROR Label 466
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 466);
}
while( i>0 ){
    cksum += aData[i];
    i -= 200;
  };
// ABS Label 467
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 467);
}

// ROR Label 468
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 468);
}
// ROR Label 469
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 469);
}
// ROR Label 470
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 470);
}

  
// ABS Label 471
if(cksum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}
return cksum;
}

/*
** Read a single page from either the journal file (if isMainJrnl==1) or
** from the sub-journal (if isMainJrnl==0) and playback that page.
** The page begins at offset *pOffset into the file. The *pOffset
** value is increased to the start of the next page in the journal.
**
** The main rollback journal uses checksums - the statement journal does 
** not.
**
** If the page number of the page record read from the (sub-)journal file
** is greater than the current value of Pager.dbSize, then playback is
** skipped and SQLITE_OK is returned.
**
** If pDone is not NULL, then it is a record of pages that have already
** been played back.  If the page at *pOffset has already been played back
** (if the corresponding pDone bit is set) then skip the playback.
** Make sure the pDone bit corresponding to the *pOffset page is set
** prior to returning.
**
** If the page record is successfully read from the (sub-)journal file
** and played back, then SQLITE_OK is returned. If an IO error occurs
** while reading the record from the (sub-)journal file or while writing
** to the database file, then the IO error code is returned. If data
** is successfully read from the (sub-)journal file but appears to be
** corrupted, SQLITE_DONE is returned. Data is considered corrupted in
** two circumstances:
** 
**   * If the record page-number is illegal (0 or PAGER_MJ_PGNO), or
**   * If the record is being rolled back from the main journal file
**     and the checksum field does not match the record content.
**
** Neither of these two scenarios are possible during a savepoint rollback.
**
** If this is a savepoint rollback, then memory may have to be dynamically
** allocated by this function. If this is the case and an allocation fails,
** SQLITE_NOMEM is returned.
*/
static int pager_playback_one_page(
  Pager *pPager,                /* The pager being played back */
  i64 *pOffset,                 /* Offset of record to playback */
  Bitvec *pDone,                /* Bitvec of pages already played back */
  int isMainJrnl,               /* 1 -> main journal. 0 -> sub-journal. */
  int isSavepnt                 /* True for a savepoint rollback */
){
  int rc;
  PgHdr *pPg;                   /* An existing page in the cache */
  Pgno pgno;                    /* The page number of a page in journal */
  u32 cksum;                    /* Checksum used for sanity checking */
  char *aData;                  /* Temporary storage for the page */
  sqlite3_file *jfd;            /* The file descriptor for the journal file */
  int isSynced;                 /* True if journal page is synced */

  assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */
  assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */
  assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */
  assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */

  aData = pPager->pTmpSpace;
  assert( aData );         /* Temp storage must have already been allocated */
  assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) );

  /* Either the state is greater than PAGER_WRITER_CACHEMOD (a transaction 
  ** or savepoint rollback done at the request of the caller) or this is
  ** a hot-journal rollback. If it is a hot-journal rollback, the pager
  ** is in state OPEN and holds an EXCLUSIVE lock. Hot-journal rollback
  ** only reads from the main journal, not the sub-journal.
  */
  assert( pPager->eState>=PAGER_WRITER_CACHEMOD
       || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)
  );
  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );

  /* Read the page number and page data from the journal or sub-journal
  ** file. Return an error code to the caller if an IO error occurs.
  */
  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;
  rc = read32bits(jfd, *pOffset, &pgno);
  
// ABS Label 472
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}

// ROR Label 473
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 473);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 474
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}
return rc;
}
  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);
  
// ABS Label 475
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}

// ROR Label 476
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 476);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 477
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}
return rc;
}
  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;

  /* Sanity checking on the page.  This is more important that I originally
  ** thought.  If a power failure occurs while the journal is being written,
  ** it could cause invalid data to be written into the journal.  We need to
  ** detect this invalid data (with high probability) and ignore it.
  */
  
// ABS Label 478
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}

// COR Label 479
if((pgno == 0 && pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != (pgno == 0 || pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 479);
}

// ROR Label 480
if((pgno != 0) != (pgno == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
// ROR Label 481
if((pgno != ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != (pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 481);
}

// MCC Label 482
if(pgno == 0 && pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 482);
}
// MCC Label 483
if(pgno == 0 && !(pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 483);
}
// MCC Label 484
if(!(pgno == 0) && pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 484);
}
// MCC Label 485
if(!(pgno == 0) && !(pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 485);
}
if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){
    assert( !isSavepnt );
    return SQLITE_DONE;
  }
  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){
    return SQLITE_OK;
  }
  
// ABS Label 486
if(isMainJrnl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
if( isMainJrnl ){
    rc = read32bits(jfd, (*pOffset)-4, &cksum);
    
// ABS Label 487
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
if( rc ) { 
// ABS Label 488
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
return rc;
}
    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){
      return SQLITE_DONE;
    }
  }

  /* If this page has already been played back before during the current
  ** rollback, then don't bother to play it back again.
  */
  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=SQLITE_OK ){
    
// ABS Label 489
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}
return rc;
  }

  /* When playing back page 1, restore the nReserve setting
  */
  
// ABS Label 490
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 490);
}

// COR Label 491
if((pgno == 1 || pPager->nReserve != ((u8 *)aData)[20]) != (pgno == 1 && pPager->nReserve != ((u8 *)aData)[20]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 491);
}

// ROR Label 492
if((pgno != 1) != (pgno == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 492);
}
// ROR Label 493
if((pPager->nReserve == ((u8 *)aData)[20]) != (pPager->nReserve != ((u8 *)aData)[20]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}

// MCC Label 494
if(pgno == 1 && pPager->nReserve != ((u8 *)aData)[20] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
// MCC Label 495
if(pgno == 1 && !(pPager->nReserve != ((u8 *)aData)[20]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 495);
}
// MCC Label 496
if(!(pgno == 1) && pPager->nReserve != ((u8 *)aData)[20] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 496);
}
// MCC Label 497
if(!(pgno == 1) && !(pPager->nReserve != ((u8 *)aData)[20]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){
    pPager->nReserve = ((u8*)aData)[20];
  }

  /* If the pager is in CACHEMOD state, then there must be a copy of this
  ** page in the pager cache. In this case just update the pager cache,
  ** not the database file. The page is left marked dirty in this case.
  **
  ** An exception to the above rule: If the database is in no-sync mode
  ** and a page is moved during an incremental vacuum then the page may
  ** not be in the pager cache. Later: if a malloc() or IO error occurs
  ** during a Movepage() call, then the page may not be in the cache
  ** either. So the condition described in the above paragraph is not
  ** assert()able.
  **
  ** If in WRITER_DBMOD, WRITER_FINISHED or OPEN state, then we update the
  ** pager cache if it exists and the main file. The page is then marked 
  ** not dirty. Since this code is only executed in PAGER_OPEN state for
  ** a hot-journal rollback, it is guaranteed that the page-cache is empty
  ** if the pager is in OPEN state.
  **
  ** Ticket #1171:  The statement journal might contain page content that is
  ** different from the page content at the start of the transaction.
  ** This occurs when a page is changed prior to the start of a statement
  ** then changed again within the statement.  When rolling back such a
  ** statement we must not write to the original database unless we know
  ** for certain that original page contents are synced into the main rollback
  ** journal.  Otherwise, a power loss might leave modified data in the
  ** database file without an entry in the rollback journal that can
  ** restore the database to its original form.  Two conditions must be
  ** met before writing to the database files. (1) the database must be
  ** locked.  (2) we know that the original page content is fully synced
  ** in the main journal either because the page is not in cache or else
  ** the page is marked as needSync==0.
  **
  ** 2008-04-14:  When attempting to vacuum a corrupt database file, it
  ** is possible to fail a statement on a database that does not yet exist.
  ** Do not attempt to write if database file has never been opened.
  */
  
// MCC Label 498
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 498);
}
// MCC Label 499
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
if( pagerUseWal(pPager) ){
    pPg = 0;
  }else{
    pPg = sqlite3PagerLookup(pPager, pgno);
  }
  assert( pPg || !MEMDB );
  assert( pPager->eState!=PAGER_OPEN || pPg==0 || pPager->tempFile );
  PAGERTRACE(("PLAYBACK %d page %d hash(%08x) %s\n",
           PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),
           (isMainJrnl?"main-journal":"sub-journal")
  ));
  
// ABS Label 500
if(isMainJrnl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}
if( isMainJrnl ){
    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);
  }else{
    isSynced = (pPg==0 || 0==(pPg->flags & PGHDR_NEED_SYNC));
  }
  
// ABS Label 501
if(isSynced < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}

// COR Label 502
if((((pPager->fd)->pMethods != 0) && (pPager->eState >= 4 || pPager->eState == 0) || isSynced) != (((pPager->fd)->pMethods != 0) && (pPager->eState >= 4 || pPager->eState == 0) && isSynced))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 502);
}
// COR Label 503
if((((pPager->fd)->pMethods != 0) || (pPager->eState >= 4 || pPager->eState == 0)) != (((pPager->fd)->pMethods != 0) && (pPager->eState >= 4 || pPager->eState == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 503);
}

// MCC Label 504
if(( (pPager->fd)->pMethods != 0 ) && ( pPager->eState >= 4 && pPager->eState == 0 ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
// MCC Label 505
if(( (pPager->fd)->pMethods != 0 ) && ( pPager->eState >= 4 && pPager->eState == 0 ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(( (pPager->fd)->pMethods != 0 ) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(( (pPager->fd)->pMethods != 0 ) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(( (pPager->fd)->pMethods != 0 ) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(( (pPager->fd)->pMethods != 0 ) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}
// MCC Label 510
if(( (pPager->fd)->pMethods != 0 ) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 510);
}
// MCC Label 511
if(( (pPager->fd)->pMethods != 0 ) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 511);
}
// MCC Label 512
if(( !((pPager->fd)->pMethods != 0) ) && ( pPager->eState >= 4 && pPager->eState == 0 ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 512);
}
// MCC Label 513
if(( !((pPager->fd)->pMethods != 0) ) && ( pPager->eState >= 4 && pPager->eState == 0 ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 513);
}
// MCC Label 514
if(( !((pPager->fd)->pMethods != 0) ) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 514);
}
// MCC Label 515
if(( !((pPager->fd)->pMethods != 0) ) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 515);
}
// MCC Label 516
if(( !((pPager->fd)->pMethods != 0) ) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 516);
}
// MCC Label 517
if(( !((pPager->fd)->pMethods != 0) ) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 517);
}
// MCC Label 518
if(( !((pPager->fd)->pMethods != 0) ) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) && isSynced ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 518);
}
// MCC Label 519
if(( !((pPager->fd)->pMethods != 0) ) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) && !(isSynced) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 519);
}
if( isOpen(pPager->fd)
   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)
   && isSynced
  ){
    
// AOR Label 520
if((pgno - 1) - (i64)pPager->pageSize != (pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 520);
}
// AOR Label 521
if((pgno - 1) + (i64)pPager->pageSize != (pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 521);
}
// AOR Label 522
if((pgno - 1) / (i64)pPager->pageSize != (pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 522);
}
i64 ofst = (pgno-1)*(i64)pPager->pageSize;
    testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );
    assert( !pagerUseWal(pPager) );

    /* Write the data read from the journal back into the database file.
    ** This is usually safe even for an encrypted database - as the data
    ** was encrypted before it was written to the journal file. The exception
    ** is if the data was just read from an in-memory sub-journal. In that
    ** case it must be encrypted here before it is copied into the database
    ** file.  */
    rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);

    
// ABS Label 523
if(pPager->dbFileSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}
// ABS Label 524
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}

// ROR Label 525
if((pgno <= pPager->dbFileSize) != (pgno > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 525);
}
// ROR Label 526
if((pgno < pPager->dbFileSize) != (pgno > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 526);
}
// ROR Label 527
if((pgno >= pPager->dbFileSize) != (pgno > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 527);
}
if( pgno>pPager->dbFileSize ){
      pPager->dbFileSize = pgno;
    }
    
// ABS Label 528
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}
if( pPager->pBackup ){
      
// ABS Label 529
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// ABS Label 530
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}
sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
    }
  }else { 
// ABS Label 531
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 531);
}

// COR Label 532
if((!isMainJrnl || pPg == 0) != (!isMainJrnl && pPg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 532);
}

// ROR Label 533
if((pPg != 0) != (pPg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 533);
}

// MCC Label 534
if(!isMainJrnl && pPg == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 534);
}
// MCC Label 535
if(!isMainJrnl && !(pPg == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 535);
}
// MCC Label 536
if(!(!isMainJrnl) && pPg == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 536);
}
// MCC Label 537
if(!(!isMainJrnl) && !(pPg == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 537);
}
if( !isMainJrnl && pPg==0 ){
    /* If this is a rollback of a savepoint and data was not written to
    ** the database and the page is not in-memory, there is a potential
    ** problem. When the page is next fetched by the b-tree layer, it 
    ** will be read from the database file, which may or may not be 
    ** current. 
    **
    ** There are a couple of different ways this can happen. All are quite
    ** obscure. When running in synchronous mode, this can only happen 
    ** if the page is on the free-list at the start of the transaction, then
    ** populated, then moved using sqlite3PagerMovepage().
    **
    ** The solution is to add an in-memory page to the cache containing
    ** the data just read from the sub-journal. Mark the page as dirty 
    ** and if the pager requires a journal-sync, then mark the page as 
    ** requiring a journal-sync before it is written.
    */
    assert( isSavepnt );
    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)==0 );
    pPager->doNotSpill |= SPILLFLAG_ROLLBACK;
    rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);
    assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)!=0 );
    pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;
    
// ABS Label 539
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}

// ROR Label 540
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 540);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 541
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}
return rc;
}
    
// ABS Label 538
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 538);
}
sqlite3PcacheMakeDirty(pPg);
  };}

  
// ABS Label 542
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
if( pPg ){
    /* No page should ever be explicitly rolled back that is in use, except
    ** for page 1 which is held in use in order to keep the lock on the
    ** database active. However such a page may be rolled back as a result
    ** of an internal error resulting in an automatic call to
    ** sqlite3PagerRollback().
    */
    void *pData;
    pData = pPg->pData;
    
// ABS Label 543
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}
memcpy(pData, (u8*)aData, pPager->pageSize);
    
// ABS Label 544
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 544);
}
pPager->xReiniter(pPg);
    /* It used to be that sqlite3PcacheMakeClean(pPg) was called here.  But
    ** that call was dangerous and had no detectable benefit since the cache
    ** is normally cleaned by sqlite3PcacheCleanAll() after rollback and so
    ** has been removed. */
    pager_set_pagehash(pPg);

    /* If this was page 1, then restore the value of Pager.dbFileVers.
    ** Do this before any decoding. */
    
// ABS Label 546
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}

// ROR Label 547
if((pgno != 1) != (pgno == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 547);
}
if( pgno==1 ){
      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
    }
    
// ABS Label 545
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}
sqlite3PcacheRelease(pPg);
  }
  
// ABS Label 548
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}
return rc;
}

/*
** Parameter zSuper is the name of a super-journal file. A single journal
** file that referred to the super-journal file has just been rolled back.
** This routine checks if it is possible to delete the super-journal file,
** and does so if it is.
**
** Argument zSuper may point to Pager.pTmpSpace. So that buffer is not 
** available for use within this function.
**
** When a super-journal file is created, it is populated with the names 
** of all of its child journals, one after another, formatted as utf-8 
** encoded text. The end of each child journal file is marked with a 
** nul-terminator byte (0x00). i.e. the entire contents of a super-journal
** file for a transaction involving two databases might be:
**
**   "/home/bill/a.db-journal\x00/home/bill/b.db-journal\x00"
**
** A super-journal file may only be deleted once all of its child 
** journals have been rolled back.
**
** This function reads the contents of the super-journal file into 
** memory and loops through each of the child journal names. For
** each child journal, it checks if:
**
**   * if the child journal exists, and if so
**   * if the child journal contains a reference to super-journal 
**     file zSuper
**
** If a child journal can be found that matches both of the criteria
** above, this function returns without doing anything. Otherwise, if
** no such child journal can be found, file zSuper is deleted from
** the file-system using sqlite3OsDelete().
**
** If an IO error within this function, an error code is returned. This
** function allocates memory by calling sqlite3Malloc(). If an allocation
** fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors 
** occur, SQLITE_OK is returned.
**
** TODO: This function allocates a single block of memory to load
** the entire contents of the super-journal file. This could be
** a couple of kilobytes or so - potentially larger than the page 
** size.
*/
static int pager_delsuper(Pager *pPager, const char *zSuper){
  
// ABS Label 549
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}
sqlite3_vfs *pVfs = pPager->pVfs;
  int rc;                   /* Return code */
  sqlite3_file *pSuper;     /* Malloc'd super-journal file descriptor */
  sqlite3_file *pJournal;   /* Malloc'd child-journal file descriptor */
  char *zSuperJournal = 0;  /* Contents of super-journal file */
  i64 nSuperJournal;        /* Size of super-journal file */
  char *zJournal;           /* Pointer to one journal within MJ file */
  char *zSuperPtr;          /* Space to hold super-journal filename */
  char *zFree = 0;          /* Free this buffer */
  int nSuperPtr;            /* Amount of space allocated to zSuperPtr[] */

  /* Allocate space for both the pJournal and pSuper file descriptors.
  ** If successful, open the super-journal file for reading.
  */
  pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);
  if( !pSuper ){
    rc = SQLITE_NOMEM_BKPT;
    pJournal = 0;
  }else{
    const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);
    rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);
    pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);
  }
  
// ABS Label 551
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 551);
}

// ROR Label 552
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 552);
}
if( rc!=SQLITE_OK ) { goto delsuper_out;
}

  /* Load the entire super-journal file into space obtained from
  ** sqlite3_malloc() and pointed to by zSuperJournal.   Also obtain
  ** sufficient space (in zSuperPtr) to hold the names of super-journal
  ** files extracted from regular rollback-journals.
  */
  rc = sqlite3OsFileSize(pSuper, &nSuperJournal);
  
// ABS Label 553
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}

// ROR Label 554
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 554);
}
if( rc!=SQLITE_OK ) { goto delsuper_out;
}
  nSuperPtr = pVfs->mxPathname+1;
  zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);
  if( !zFree ){
    rc = SQLITE_NOMEM_BKPT;
    goto delsuper_out;
  }
  zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;
  zSuperJournal = &zFree[4];
  zSuperPtr = &zSuperJournal[nSuperJournal+2];
  rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);
  
// ABS Label 555
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 555);
}

// ROR Label 556
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 556);
}
if( rc!=SQLITE_OK ) { goto delsuper_out;
}
  zSuperJournal[nSuperJournal] = 0;
  zSuperJournal[nSuperJournal+1] = 0;

  zJournal = zSuperJournal;
  
// ABS Label 557
if(nSuperJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}

// ROR Label 558
if(((zJournal - zSuperJournal) <= nSuperJournal) != ((zJournal - zSuperJournal) < nSuperJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 558);
}
// ROR Label 559
if(((zJournal - zSuperJournal) > nSuperJournal) != ((zJournal - zSuperJournal) < nSuperJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 559);
}
// ROR Label 560
if(((zJournal - zSuperJournal) >= nSuperJournal) != ((zJournal - zSuperJournal) < nSuperJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 560);
}
while( (zJournal-zSuperJournal)<nSuperJournal ){
    int exists;
    rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);
    
// ABS Label 565
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 565);
}

// ROR Label 566
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 566);
}
if( rc!=SQLITE_OK ){
      goto delsuper_out;
    }
    
// ABS Label 567
if(exists < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}
if( exists ){
      /* One of the journals pointed to by the super-journal exists.
      ** Open it and check if it points at the super-journal. If
      ** so, return without deleting the super-journal file.
      ** NB:  zJournal is really a MAIN_JOURNAL.  But call it a 
      ** SUPER_JOURNAL here so that the VFS will not send the zJournal
      ** name into sqlite3_database_file_object().
      */
      int c;
      int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);
      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
      
// ABS Label 569
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 569);
}

// ROR Label 570
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 570);
}
if( rc!=SQLITE_OK ){
        goto delsuper_out;
      }

      rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);
      
// ABS Label 568
if(pJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 568);
}
sqlite3OsClose(pJournal);
      
// ABS Label 571
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 571);
}

// ROR Label 572
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
if( rc!=SQLITE_OK ){
        goto delsuper_out;
      }

      c = zSuperPtr[0]!=0 && strcmp(zSuperPtr, zSuper)==0;
      
// ABS Label 573
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}
if( c ){
        /* We have a match. Do not delete the super-journal file. */
        goto delsuper_out;
      }
    }
    zJournal += (sqlite3Strlen30(zJournal)+1);
  };
// ABS Label 561
if(nSuperJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}

// ROR Label 562
if(((zJournal - zSuperJournal) <= nSuperJournal) != ((zJournal - zSuperJournal) < nSuperJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 562);
}
// ROR Label 563
if(((zJournal - zSuperJournal) > nSuperJournal) != ((zJournal - zSuperJournal) < nSuperJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 563);
}
// ROR Label 564
if(((zJournal - zSuperJournal) >= nSuperJournal) != ((zJournal - zSuperJournal) < nSuperJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}

 
  
// ABS Label 550
if(pSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}
sqlite3OsClose(pSuper);
  rc = sqlite3OsDelete(pVfs, zSuper, 0);

delsuper_out:
  sqlite3_free(zFree);
  
// ABS Label 574
if(pSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}
if( pSuper ){
    
// ABS Label 575
if(pSuper < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 575);
}
sqlite3OsClose(pSuper);
    assert( !isOpen(pJournal) );
    sqlite3_free(pSuper);
  }
  
// ABS Label 576
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 576);
}
return rc;
}


/*
** This function is used to change the actual size of the database 
** file in the file-system. This only happens when committing a transaction,
** or rolling back a transaction (including rolling back a hot-journal).
**
** If the main database file is not open, or the pager is not in either
** DBMOD or OPEN state, this function is a no-op. Otherwise, the size 
** of the file is changed to nPage pages (nPage*pPager->pageSize bytes). 
** If the file on disk is currently larger than nPage pages, then use the VFS
** xTruncate() method to truncate it.
**
** Or, it might be the case that the file on disk is smaller than 
** nPage pages. Some operating system implementations can get confused if 
** you try to truncate a file to some size that is larger than it 
** currently is, so detect this case and write a single zero byte to 
** the end of the new file instead.
**
** If successful, return SQLITE_OK. If an IO error occurs while modifying
** the database file, return the error code to the caller.
*/
static int pager_truncate(Pager *pPager, Pgno nPage){
  int rc = SQLITE_OK;
  assert( pPager->eState!=PAGER_ERROR );
  assert( pPager->eState!=PAGER_READER );
  
  
// COR Label 577
if((((pPager->fd)->pMethods != 0) || (pPager->eState >= 4 || pPager->eState == 0)) != (((pPager->fd)->pMethods != 0) && (pPager->eState >= 4 || pPager->eState == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 577);
}

// MCC Label 578
if(( (pPager->fd)->pMethods != 0 ) && ( pPager->eState >= 4 && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
// MCC Label 579
if(( (pPager->fd)->pMethods != 0 ) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 579);
}
// MCC Label 580
if(( (pPager->fd)->pMethods != 0 ) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 580);
}
// MCC Label 581
if(( (pPager->fd)->pMethods != 0 ) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 581);
}
// MCC Label 582
if(( !((pPager->fd)->pMethods != 0) ) && ( pPager->eState >= 4 && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(( !((pPager->fd)->pMethods != 0) ) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(( !((pPager->fd)->pMethods != 0) ) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(( !((pPager->fd)->pMethods != 0) ) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
if( isOpen(pPager->fd) 
   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN) 
  ){
    i64 currentSize, newSize;
    
// ABS Label 586
if(pPager->pageSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 586);
}
int szPage = pPager->pageSize;
    assert( pPager->eLock==EXCLUSIVE_LOCK );
    /* TODO: Is it safe to use Pager.dbFileSize here? */
    rc = sqlite3OsFileSize(pPager->fd, &currentSize);
    newSize = szPage*(i64)nPage;
    
// ABS Label 587
if(currentSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 587);
}
// ABS Label 588
if(newSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 588);
}
// ABS Label 589
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}

// COR Label 590
if((rc == 0 || currentSize != newSize) != (rc == 0 && currentSize != newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 590);
}

// ROR Label 591
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 591);
}
// ROR Label 592
if((currentSize == newSize) != (currentSize != newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}

// MCC Label 593
if(rc == 0 && currentSize != newSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 593);
}
// MCC Label 594
if(rc == 0 && !(currentSize != newSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 594);
}
// MCC Label 595
if(!(rc == 0) && currentSize != newSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(!(rc == 0) && !(currentSize != newSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
if( rc==SQLITE_OK && currentSize!=newSize ){
      
// ABS Label 597
if(currentSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 597);
}
// ABS Label 598
if(newSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}

// ROR Label 599
if((currentSize <= newSize) != (currentSize > newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 599);
}
// ROR Label 600
if((currentSize < newSize) != (currentSize > newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 600);
}
// ROR Label 601
if((currentSize >= newSize) != (currentSize > newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 601);
}
if( currentSize>newSize ){
        rc = sqlite3OsTruncate(pPager->fd, newSize);
      }else { 
// ABS Label 602
if(newSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}

// ROR Label 603
if(((currentSize + szPage) < newSize) != ((currentSize + szPage) <= newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 603);
}
// ROR Label 604
if(((currentSize + szPage) > newSize) != ((currentSize + szPage) <= newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 604);
}
// ROR Label 605
if(((currentSize + szPage) >= newSize) != ((currentSize + szPage) <= newSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 605);
}
if( (currentSize+szPage)<=newSize ){
        
// ABS Label 606
if(pPager->pTmpSpace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}
char *pTmp = pPager->pTmpSpace;
        memset(pTmp, 0, szPage);
        testcase( (newSize-szPage) == currentSize );
        testcase( (newSize-szPage) >  currentSize );
        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);
      };}

      
// ABS Label 607
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}

// ROR Label 608
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 608);
}
if( rc==SQLITE_OK ){
        pPager->dbFileSize = nPage;
      }
    }
  }
  
// ABS Label 609
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}
return rc;
}

/*
** Return a sanitized version of the sector-size of OS file pFile. The
** return value is guaranteed to lie between 32 and MAX_SECTOR_SIZE.
*/
int sqlite3SectorSize(sqlite3_file *pFile){
  int iRet = sqlite3OsSectorSize(pFile);
  
// ABS Label 610
if(iRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}

// ROR Label 611
if((iRet <= 32) != (iRet < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 611);
}
// ROR Label 612
if((iRet > 32) != (iRet < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 612);
}
// ROR Label 613
if((iRet >= 32) != (iRet < 32))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 613);
}
if( iRet<32 ){
    iRet = 512;
  }else { 
// ABS Label 614
if(iRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 614);
}

// ROR Label 615
if((iRet <= 65536) != (iRet > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 615);
}
// ROR Label 616
if((iRet < 65536) != (iRet > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 616);
}
// ROR Label 617
if((iRet >= 65536) != (iRet > 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 617);
}
if( iRet>MAX_SECTOR_SIZE ){
    assert( MAX_SECTOR_SIZE>=512 );
    iRet = MAX_SECTOR_SIZE;
  };}

  
// ABS Label 618
if(iRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}
return iRet;
}

/*
** Set the value of the Pager.sectorSize variable for the given
** pager based on the value returned by the xSectorSize method
** of the open database file. The sector size will be used 
** to determine the size and alignment of journal header and 
** super-journal pointers within created journal files.
**
** For temporary files the effective sector size is always 512 bytes.
**
** Otherwise, for non-temporary files, the effective sector size is
** the value returned by the xSectorSize() method rounded up to 32 if
** it is less than 32, or rounded down to MAX_SECTOR_SIZE if it
** is greater than MAX_SECTOR_SIZE.
**
** If the file has the SQLITE_IOCAP_POWERSAFE_OVERWRITE property, then set
** the effective sector size to its minimum value (512).  The purpose of
** pPager->sectorSize is to define the "blast radius" of bytes that
** might change if a crash occurs while writing to a single byte in
** that range.  But with POWERSAFE_OVERWRITE, the blast radius is zero
** (that is what POWERSAFE_OVERWRITE means), so we minimize the sector
** size.  For backwards compatibility of the rollback journal file format,
** we cannot reduce the effective sector size below 512.
*/
static void setSectorSize(Pager *pPager){
  assert( isOpen(pPager->fd) || pPager->tempFile );

  if( pPager->tempFile
   || (sqlite3OsDeviceCharacteristics(pPager->fd) & 
              SQLITE_IOCAP_POWERSAFE_OVERWRITE)!=0
  ){
    /* Sector size doesn't matter for temporary files. Also, the file
    ** may not have been opened yet, in which case the OsSectorSize()
    ** call will segfault. */
    pPager->sectorSize = 512;
  }else{
    pPager->sectorSize = sqlite3SectorSize(pPager->fd);
  }
}

/*
** Playback the journal and thus restore the database file to
** the state it was in before we started making changes.  
**
** The journal file format is as follows: 
**
**  (1)  8 byte prefix.  A copy of aJournalMagic[].
**  (2)  4 byte big-endian integer which is the number of valid page records
**       in the journal.  If this value is 0xffffffff, then compute the
**       number of page records from the journal size.
**  (3)  4 byte big-endian integer which is the initial value for the 
**       sanity checksum.
**  (4)  4 byte integer which is the number of pages to truncate the
**       database to during a rollback.
**  (5)  4 byte big-endian integer which is the sector size.  The header
**       is this many bytes in size.
**  (6)  4 byte big-endian integer which is the page size.
**  (7)  zero padding out to the next sector size.
**  (8)  Zero or more pages instances, each as follows:
**        +  4 byte page number.
**        +  pPager->pageSize bytes of data.
**        +  4 byte checksum
**
** When we speak of the journal header, we mean the first 7 items above.
** Each entry in the journal is an instance of the 8th item.
**
** Call the value from the second bullet "nRec".  nRec is the number of
** valid page entries in the journal.  In most cases, you can compute the
** value of nRec from the size of the journal file.  But if a power
** failure occurred while the journal was being written, it could be the
** case that the size of the journal file had already been increased but
** the extra entries had not yet made it safely to disk.  In such a case,
** the value of nRec computed from the file size would be too large.  For
** that reason, we always use the nRec value in the header.
**
** If the nRec value is 0xffffffff it means that nRec should be computed
** from the file size.  This value is used when the user selects the
** no-sync option for the journal.  A power failure could lead to corruption
** in this case.  But for things like temporary table (which will be
** deleted when the power is restored) we don't care.  
**
** If the file opened as the journal file is not a well-formed
** journal file then all pages up to the first corrupted page are rolled
** back (or no pages if the journal header is corrupted). The journal file
** is then deleted and SQLITE_OK returned, just as if no corruption had
** been encountered.
**
** If an I/O or malloc() error occurs, the journal-file is not deleted
** and an error code is returned.
**
** The isHot parameter indicates that we are trying to rollback a journal
** that might be a hot journal.  Or, it could be that the journal is 
** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.
** If the journal really is hot, reset the pager cache prior rolling
** back any content.  If the journal is merely persistent, no reset is
** needed.
*/
static int pager_playback(Pager *pPager, int isHot){
  
// ABS Label 619
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}
sqlite3_vfs *pVfs = pPager->pVfs;
  i64 szJ;                 /* Size of the journal file in bytes */
  u32 nRec;                /* Number of Records in the journal */
  u32 u;                   /* Unsigned loop counter */
  Pgno mxPg = 0;           /* Size of the original file in pages */
  int rc;                  /* Result code of a subroutine */
  int res = 1;             /* Value returned by sqlite3OsAccess() */
  char *zSuper = 0;        /* Name of super-journal file if any */
  int needPagerReset;      /* True to reset page prior to first page rollback */
  int nPlayback = 0;       /* Total number of pages restored from journal */
  u32 savedPageSize = pPager->pageSize;

  /* Figure out how many records are in the journal.  Abort early if
  ** the journal is empty.
  */
  assert( isOpen(pPager->jfd) );
  rc = sqlite3OsFileSize(pPager->jfd, &szJ);
  
// ABS Label 621
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 621);
}

// ROR Label 622
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 622);
}
if( rc!=SQLITE_OK ){
    goto end_playback;
  }

  /* Read the super-journal name from the journal, if it is present.
  ** If a super-journal file name is specified, but the file is not
  ** present on disk, then the journal is not hot and does not need to be
  ** played back.
  **
  ** TODO: Technically the following is an error because it assumes that
  ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. that
  ** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,
  ** mxPathname is 512, which is the same as the minimum allowable value
  ** for pageSize.
  */
  zSuper = pPager->pTmpSpace;
  rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);
  
// ABS Label 623
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}

// COR Label 624
if((rc == 0 || zSuper[0]) != (rc == 0 && zSuper[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 624);
}

// ROR Label 625
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}

// MCC Label 626
if(rc == 0 && zSuper[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 626);
}
// MCC Label 627
if(rc == 0 && !(zSuper[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 627);
}
// MCC Label 628
if(!(rc == 0) && zSuper[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 628);
}
// MCC Label 629
if(!(rc == 0) && !(zSuper[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 629);
}
if( rc==SQLITE_OK && zSuper[0] ){
    rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);
  }
  zSuper = 0;
  
// ABS Label 630
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}

// COR Label 631
if((rc != 0 && !res) != (rc != 0 || !res))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 631);
}

// ROR Label 632
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 632);
}

// MCC Label 633
if(rc != 0 && !res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 633);
}
// MCC Label 634
if(rc != 0 && !(!res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 634);
}
// MCC Label 635
if(!(rc != 0) && !res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 635);
}
// MCC Label 636
if(!(rc != 0) && !(!res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 636);
}
if( rc!=SQLITE_OK || !res ){
    goto end_playback;
  }
  pPager->journalOff = 0;
  needPagerReset = isHot;

  /* This loop terminates either when a readJournalHdr() or 
  ** pager_playback_one_page() call returns SQLITE_DONE or an IO error 
  ** occurs. 
  */
  while( 1 ){
    /* Read the next journal header from the journal file.  If there are
    ** not enough bytes left in the journal file for a complete header, or
    ** it is corrupted, then a process must have failed while writing it.
    ** This indicates nothing more needs to be rolled back.
    */
    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
    
// ABS Label 637
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}

// ROR Label 638
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 638);
}
if( rc!=SQLITE_OK ){ 
      
// ABS Label 639
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// ROR Label 640
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 640);
}
if( rc==SQLITE_DONE ){
        rc = SQLITE_OK;
      }
      goto end_playback;
    }

    /* If nRec is 0xffffffff, then this journal was created by a process
    ** working in no-sync mode. This means that the rest of the journal
    ** file consists of pages, there are no more journal headers. Compute
    ** the value of nRec based on this assumption.
    */
    
// ABS Label 641
if(nRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}

// ROR Label 642
if((nRec != 4294967295U) != (nRec == 4294967295U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}
if( nRec==0xffffffff ){
      assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );
      nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));
    }

    /* If nRec is 0 and this rollback is of a transaction created by this
    ** process and if this is the final header in the journal, then it means
    ** that this part of the journal was being filled but has not yet been
    ** synced to disk.  Compute the number of pages based on the remaining
    ** size of the file.
    **
    ** The third term of the test was added to fix ticket #2565.
    ** When rolling back a hot journal, nRec==0 always means that the next
    ** chunk of the journal contains zero pages to be rolled back.  But
    ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in
    ** the journal, it means that the journal might contain additional
    ** pages that need to be rolled back and that the number of pages 
    ** should be computed based on the journal file size.
    */
    
// ABS Label 643
if(nRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}
// ABS Label 644
if(pPager->journalHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}
// ABS Label 645
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}

// AOR Label 646
if(pPager->journalHdr - (pPager->sectorSize) != pPager->journalHdr + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 646);
}
// AOR Label 647
if(pPager->journalHdr / (pPager->sectorSize) != pPager->journalHdr + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 647);
}
// AOR Label 648
if(pPager->journalHdr * (pPager->sectorSize) != pPager->journalHdr + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 648);
}

// COR Label 649
if((nRec == 0 && !isHot || pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) != (nRec == 0 && !isHot && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 649);
}
// COR Label 650
if((nRec == 0 || !isHot) != (nRec == 0 && !isHot))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 650);
}

// ROR Label 651
if((nRec != 0) != (nRec == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}
// ROR Label 652
if((pPager->journalHdr + (pPager->sectorSize) != pPager->journalOff) != (pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 652);
}

// MCC Label 653
if(nRec == 0 && !isHot && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 653);
}
// MCC Label 654
if(nRec == 0 && !isHot && !(pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 654);
}
// MCC Label 655
if(nRec == 0 && !(!isHot) && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 655);
}
// MCC Label 656
if(nRec == 0 && !(!isHot) && !(pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 656);
}
// MCC Label 657
if(!(nRec == 0) && !isHot && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 657);
}
// MCC Label 658
if(!(nRec == 0) && !isHot && !(pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 658);
}
// MCC Label 659
if(!(nRec == 0) && !(!isHot) && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 659);
}
// MCC Label 660
if(!(nRec == 0) && !(!isHot) && !(pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 660);
}
if( nRec==0 && !isHot &&
        pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){
      nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));
    }

    /* If this is the first header read from the journal, truncate the
    ** database file back to its original size.
    */
    
// ABS Label 661
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}

// ROR Label 662
if((pPager->journalOff != (pPager->sectorSize)) != (pPager->journalOff == (pPager->sectorSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){
      rc = pager_truncate(pPager, mxPg);
      
// ABS Label 663
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}

// ROR Label 664
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 664);
}
if( rc!=SQLITE_OK ){
        goto end_playback;
      }
      pPager->dbSize = mxPg;
    }

    /* Copy original pages out of the journal and back into the 
    ** database file and/or page cache.
    */
    u = 0;

// ABS Label 665
if(nRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 665);
}
// ABS Label 666
if(u < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ROR Label 667
if((u <= nRec) != (u < nRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
// ROR Label 668
if((u > nRec) != (u < nRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 668);
}
// ROR Label 669
if((u >= nRec) != (u < nRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 669);
}
for(; u<nRec; u++){
      
// ABS Label 675
if(needPagerReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}
if( needPagerReset ){
        
// ABS Label 676
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}
pager_reset(pPager);
        needPagerReset = 0;
      }
      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);
      
// ABS Label 677
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}

// ROR Label 678
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 678);
}
if( rc==SQLITE_OK ){
        nPlayback++;
      }else{
        
// ABS Label 679
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}

// ROR Label 680
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 680);
}
if( rc==SQLITE_DONE ){
          pPager->journalOff = szJ;
          break;
        }else { 
// ABS Label 681
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}

// ROR Label 682
if((rc != (10 | (2 << 8))) != (rc == (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 682);
}
if( rc==SQLITE_IOERR_SHORT_READ ){
          /* If the journal has been truncated, simply stop reading and
          ** processing the journal. This might happen if the journal was
          ** not completely written and synced prior to a crash.  In that
          ** case, the database should have never been written in the
          ** first place so it is OK to simply abandon the rollback. */
          rc = SQLITE_OK;
          goto end_playback;
        }else{
          /* If we are unable to rollback, quit and return the error
          ** code.  This will cause the pager to enter the error state
          ** so that no further harm will be done.  Perhaps the next
          ** process to come along will be able to rollback the database.
          */
          goto end_playback;
        };}

      }
    };
// ABS Label 670
if(nRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}
// ABS Label 671
if(u < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ROR Label 672
if((u <= nRec) != (u < nRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 672);
}
// ROR Label 673
if((u > nRec) != (u < nRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 673);
}
// ROR Label 674
if((u >= nRec) != (u < nRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 674);
}

  };
  /*NOTREACHED*/
  assert( 0 );

end_playback:
  
// ABS Label 683
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}

// ROR Label 684
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 684);
}
if( rc==SQLITE_OK ){
    rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);
  }
  /* Following a rollback, the database file should be back in its original
  ** state prior to the start of the transaction, so invoke the
  ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the
  ** assertion that the transaction counter was modified.
  */
#ifdef SQLITE_DEBUG
  sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);
#endif

  /* If this playback is happening automatically as a result of an IO or 
  ** malloc error that occurred after the change-counter was updated but 
  ** before the transaction was committed, then the change-counter 
  ** modification may just have been reverted. If this happens in exclusive 
  ** mode, then subsequent transactions performed by the connection will not
  ** update the change-counter at all. This may lead to cache inconsistency
  ** problems for other processes at some point in the future. So, just
  ** in case this has happened, clear the changeCountDone flag now.
  */
  pPager->changeCountDone = pPager->tempFile;

  
// ABS Label 685
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}

// ROR Label 686
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 686);
}
if( rc==SQLITE_OK ){
    /* Leave 4 bytes of space before the super-journal filename in memory.
    ** This is because it may end up being passed to sqlite3OsOpen(), in
    ** which case it requires 4 0x00 bytes in memory immediately before
    ** the filename. */
    zSuper = &pPager->pTmpSpace[4];
    rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);
    testcase( rc!=SQLITE_OK );
  }
  
// ABS Label 687
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}

// COR Label 688
if((rc == 0 || (pPager->eState >= 4 || pPager->eState == 0)) != (rc == 0 && (pPager->eState >= 4 || pPager->eState == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 688);
}

// ROR Label 689
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 689);
}

// MCC Label 690
if(rc == 0 && ( pPager->eState >= 4 && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 690);
}
// MCC Label 691
if(rc == 0 && ( pPager->eState >= 4 && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 691);
}
// MCC Label 692
if(rc == 0 && ( !(pPager->eState >= 4) && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 692);
}
// MCC Label 693
if(rc == 0 && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 693);
}
// MCC Label 694
if(!(rc == 0) && ( pPager->eState >= 4 && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 694);
}
// MCC Label 695
if(!(rc == 0) && ( pPager->eState >= 4 && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 695);
}
// MCC Label 696
if(!(rc == 0) && ( !(pPager->eState >= 4) && pPager->eState == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 696);
}
// MCC Label 697
if(!(rc == 0) && ( !(pPager->eState >= 4) && !(pPager->eState == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 697);
}
if( rc==SQLITE_OK
   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)
  ){
    rc = sqlite3PagerSync(pPager, 0);
  }
  
// ABS Label 698
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 698);
}

// ROR Label 699
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}
if( rc==SQLITE_OK ){
    rc = pager_end_transaction(pPager, zSuper[0]!='\0', 0);
    testcase( rc!=SQLITE_OK );
  }
  
// ABS Label 700
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}
// ABS Label 701
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}

// COR Label 702
if((rc == 0 && zSuper[0] || res) != (rc == 0 && zSuper[0] && res))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 702);
}
// COR Label 703
if((rc == 0 || zSuper[0]) != (rc == 0 && zSuper[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 703);
}

// ROR Label 704
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 704);
}

// MCC Label 705
if(rc == 0 && zSuper[0] && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 705);
}
// MCC Label 706
if(rc == 0 && zSuper[0] && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 706);
}
// MCC Label 707
if(rc == 0 && !(zSuper[0]) && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 707);
}
// MCC Label 708
if(rc == 0 && !(zSuper[0]) && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 708);
}
// MCC Label 709
if(!(rc == 0) && zSuper[0] && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 709);
}
// MCC Label 710
if(!(rc == 0) && zSuper[0] && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 710);
}
// MCC Label 711
if(!(rc == 0) && !(zSuper[0]) && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 711);
}
// MCC Label 712
if(!(rc == 0) && !(zSuper[0]) && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 712);
}
if( rc==SQLITE_OK && zSuper[0] && res ){
    /* If there was a super-journal and this routine will return success,
    ** see if it is possible to delete the super-journal.
    */
    assert( zSuper==&pPager->pTmpSpace[4] );
    memset(&zSuper[-4], 0, 4);
    rc = pager_delsuper(pPager, zSuper);
    testcase( rc!=SQLITE_OK );
  }
  
// ABS Label 713
if(isHot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 713);
}
// ABS Label 714
if(nPlayback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}

// COR Label 715
if((isHot || nPlayback) != (isHot && nPlayback))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 715);
}

// MCC Label 716
if(isHot && nPlayback ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 716);
}
// MCC Label 717
if(isHot && !(nPlayback) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 717);
}
// MCC Label 718
if(!(isHot) && nPlayback ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 718);
}
// MCC Label 719
if(!(isHot) && !(nPlayback) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 719);
}
if( isHot && nPlayback ){
    
// ABS Label 720
if(nPlayback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 720);
}

// ABS Label 721
if(pPager->zJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}
sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",
                nPlayback, pPager->zJournal);
  }

  /* The Pager.sectorSize variable may have been updated while rolling
  ** back a journal created by a process with a different sector size
  ** value. Reset it to the correct value for this process.
  */
  
// ABS Label 620
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 620);
}
setSectorSize(pPager);
  
// ABS Label 722
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 722);
}
return rc;
}


/*
** Read the content for page pPg out of the database file (or out of
** the WAL if that is where the most recent copy if found) into 
** pPg->pData. A shared lock or greater must be held on the database
** file before this function is called.
**
** If page 1 is read, then the value of Pager.dbFileVers[] is set to
** the value read from the database file.
**
** If an IO error occurs, then the IO error is returned to the caller.
** Otherwise, SQLITE_OK is returned.
*/
static int readDbPage(PgHdr *pPg){
  
// ABS Label 723
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 723);
}
Pager *pPager = pPg->pPager; /* Pager object associated with page pPg */
  int rc = SQLITE_OK;          /* Return code */

#ifndef SQLITE_OMIT_WAL
  u32 iFrame = 0;              /* Frame of WAL containing pgno */

  assert( pPager->eState>=PAGER_READER && !MEMDB );
  assert( isOpen(pPager->fd) );

  
// MCC Label 724
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 724);
}
// MCC Label 725
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 725);
}
if( pagerUseWal(pPager) ){
    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);
    
// ABS Label 726
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}
if( rc ) { 
// ABS Label 727
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}
return rc;
}
  }
  
// ABS Label 728
if(iFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}
if( iFrame ){
    rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);
  }else
#endif
  {
    
// AOR Label 729
if((pPg->pgno - 1) - (i64)pPager->pageSize != (pPg->pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 729);
}
// AOR Label 730
if((pPg->pgno - 1) + (i64)pPager->pageSize != (pPg->pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 730);
}
// AOR Label 731
if((pPg->pgno - 1) / (i64)pPager->pageSize != (pPg->pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 731);
}
i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;
    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);
    
// ABS Label 732
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}

// ROR Label 733
if((rc != (10 | (2 << 8))) != (rc == (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 733);
}
if( rc==SQLITE_IOERR_SHORT_READ ){
      rc = SQLITE_OK;
    }
  }

  
// ABS Label 734
if(pPg->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 734);
}

// ROR Label 735
if((pPg->pgno != 1) != (pPg->pgno == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 735);
}
if( pPg->pgno==1 ){
    
// ABS Label 736
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}
if( rc ){
      /* If the read is unsuccessful, set the dbFileVers[] to something
      ** that will never be a valid file version.  dbFileVers[] is a copy
      ** of bytes 24..39 of the database.  Bytes 28..31 should always be
      ** zero or the size of the database in page. Bytes 32..35 and 35..39
      ** should be page numbers which are never 0xffffffff.  So filling
      ** pPager->dbFileVers[] with all 0xff bytes should suffice.
      **
      ** For an encrypted database, the situation is more complex:  bytes
      ** 24..39 of the database are white noise.  But the probability of
      ** white noise equaling 16 bytes of 0xff is vanishingly small so
      ** we should still be ok.
      */
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
    }else{
      u8 *dbFileVers = &((u8*)pPg->pData)[24];
      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
    }
  }
  PAGER_INCR(sqlite3_pager_readdb_count);
  PAGER_INCR(pPager->nRead);
  IOTRACE(("PGIN %p %d\n", pPager, pPg->pgno));
  PAGERTRACE(("FETCH %d page %d hash(%08x)\n",
               PAGERID(pPager), pPg->pgno, pager_pagehash(pPg)));

  
// ABS Label 737
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 737);
}
return rc;
}

/*
** Update the value of the change-counter at offsets 24 and 92 in
** the header and the sqlite version number at offset 96.
**
** This is an unconditional update.  See also the pager_incr_changecounter()
** routine which only updates the change-counter if the update is actually
** needed, as determined by the pPager->changeCountDone state variable.
*/
static void pager_write_changecounter(PgHdr *pPg){
  u32 change_counter;

  /* Increment the value just read and write it back to byte 24. */
  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;
  put32bits(((char*)pPg->pData)+24, change_counter);

  /* Also store the SQLite version number in bytes 96..99 and in
  ** bytes 92..95 store the change counter for which the version number
  ** is valid. */
  put32bits(((char*)pPg->pData)+92, change_counter);
  put32bits(((char*)pPg->pData)+96, SQLITE_VERSION_NUMBER);
}

#ifndef SQLITE_OMIT_WAL
/*
** This function is invoked once for each page that has already been 
** written into the log file when a WAL transaction is rolled back.
** Parameter iPg is the page number of said page. The pCtx argument 
** is actually a pointer to the Pager structure.
**
** If page iPg is present in the cache, and has no outstanding references,
** it is discarded. Otherwise, if there are one or more outstanding
** references, the page content is reloaded from the database. If the
** attempt to reload content from the database is required and fails, 
** return an SQLite error code. Otherwise, SQLITE_OK.
*/
static int pagerUndoCallback(void *pCtx, Pgno iPg){
  int rc = SQLITE_OK;
  Pager *pPager = (Pager *)pCtx;
  PgHdr *pPg;

  assert( pagerUseWal(pPager) );
  pPg = sqlite3PagerLookup(pPager, iPg);
  
// ABS Label 750
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 750);
}
if( pPg ){
    if( sqlite3PcachePageRefcount(pPg)==1 ){
      
// ABS Label 751
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 751);
}
sqlite3PcacheDrop(pPg);
    }else{
      rc = readDbPage(pPg);
      
// ABS Label 753
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 753);
}

// ROR Label 754
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 754);
}
if( rc==SQLITE_OK ){
        
// ABS Label 755
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}
pPager->xReiniter(pPg);
      }
      
// ABS Label 752
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 752);
}
sqlite3PagerUnrefNotNull(pPg);
    }
  }

  /* Normally, if a transaction is rolled back, any backup processes are
  ** updated as data is copied out of the rollback journal and into the
  ** database. This is not generally possible with a WAL database, as
  ** rollback involves simply truncating the log file. Therefore, if one
  ** or more frames have already been written to the log (and therefore 
  ** also copied into the backup databases) as part of this transaction,
  ** the backups must be restarted.
  */
  
// ABS Label 749
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}
sqlite3BackupRestart(pPager->pBackup);

  
// ABS Label 756
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}
return rc;
}

/*
** This function is called to rollback a transaction on a WAL database.
*/
static int pagerRollbackWal(Pager *pPager){
  int rc;                         /* Return Code */
  PgHdr *pList;                   /* List of dirty pages to revert */

  /* For all pages in the cache that are currently dirty or have already
  ** been written (but not committed) to the log file, do one of the 
  ** following:
  **
  **   + Discard the cached page (if refcount==0), or
  **   + Reload page content from the database (if refcount>0).
  */
  pPager->dbSize = pPager->dbOrigSize;
  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);
  pList = sqlite3PcacheDirtyList(pPager->pPCache);
  
// ABS Label 757
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}
// ABS Label 758
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}

// COR Label 759
if((pList || rc == 0) != (pList && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 759);
}

// ROR Label 760
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 760);
}

// MCC Label 761
if(pList && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 761);
}
// MCC Label 762
if(pList && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 762);
}
// MCC Label 763
if(!(pList) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 763);
}
// MCC Label 764
if(!(pList) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 764);
}
while( pList && rc==SQLITE_OK ){
    
// ABS Label 773
if(pList->pDirty < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}
PgHdr *pNext = pList->pDirty;
    rc = pagerUndoCallback((void *)pPager, pList->pgno);
    pList = pNext;
  };
// ABS Label 765
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}
// ABS Label 766
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 766);
}

// COR Label 767
if((pList || rc == 0) != (pList && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 767);
}

// ROR Label 768
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 768);
}

// MCC Label 769
if(pList && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 769);
}
// MCC Label 770
if(pList && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
// MCC Label 771
if(!(pList) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 771);
}
// MCC Label 772
if(!(pList) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 772);
}


  
// ABS Label 774
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}
return rc;
}

/*
** This function is a wrapper around sqlite3WalFrames(). As well as logging
** the contents of the list of pages headed by pList (connected by pDirty),
** this function notifies any active backup processes that the pages have
** changed. 
**
** The list of pages passed into this routine is always sorted by page number.
** Hence, if page 1 appears anywhere on the list, it will be the first page.
*/ 
static int pagerWalFrames(
  Pager *pPager,                  /* Pager object */
  PgHdr *pList,                   /* List of frames to log */
  Pgno nTruncate,                 /* Database size after this commit */
  int isCommit                    /* True if this is a commit */
){
  int rc;                         /* Return code */
  int nList;                      /* Number of pages in pList */
  PgHdr *p;                       /* For looping over pages */

  assert( pPager->pWal );
  assert( pList );
#ifdef SQLITE_DEBUG
  /* Verify that the page list is in accending order */
  for(p=pList; p && p->pDirty; p=p->pDirty){
    assert( p->pgno < p->pDirty->pgno );
  }
#endif

  assert( pList->pDirty==0 || isCommit );
  
// ABS Label 775
if(isCommit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}
if( isCommit ){
    /* If a WAL transaction is being committed, there is no point in writing
    ** any pages with page numbers greater than nTruncate into the WAL file.
    ** They will never be read by any client. So remove them from the pDirty
    ** list here. */
    PgHdr **ppNext = &pList;
    nList = 0;
    p = pList;
for(; (*ppNext = p)!=0; p=p->pDirty){
      
// ABS Label 776
if(nTruncate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}
// ABS Label 777
if(p->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ROR Label 778
if((p->pgno < nTruncate) != (p->pgno <= nTruncate))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 778);
}
// ROR Label 779
if((p->pgno > nTruncate) != (p->pgno <= nTruncate))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 779);
}
// ROR Label 780
if((p->pgno >= nTruncate) != (p->pgno <= nTruncate))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 780);
}
if( p->pgno<=nTruncate ){
        ppNext = &p->pDirty;
        nList++;
      }
    };
    assert( pList );
  }else{
    nList = 1;
  }
  pPager->aStat[PAGER_STAT_WRITE] += nList;

  
// ABS Label 781
if(pList->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}

// ROR Label 782
if((pList->pgno != 1) != (pList->pgno == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 782);
}
if( pList->pgno==1 ) { 
// ABS Label 783
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}
pager_write_changecounter(pList);
}
  rc = sqlite3WalFrames(pPager->pWal, 
      pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags
  );
  
// ABS Label 784
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}
// ABS Label 785
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// COR Label 786
if((rc == 0 || pPager->pBackup) != (rc == 0 && pPager->pBackup))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 786);
}

// ROR Label 787
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 787);
}

// MCC Label 788
if(rc == 0 && pPager->pBackup ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 788);
}
// MCC Label 789
if(rc == 0 && !(pPager->pBackup) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 789);
}
// MCC Label 790
if(!(rc == 0) && pPager->pBackup ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 790);
}
// MCC Label 791
if(!(rc == 0) && !(pPager->pBackup) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 791);
}
if( rc==SQLITE_OK && pPager->pBackup ){
    p = pList;

// ABS Label 792
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}
for(; p; p=p->pDirty){
      
// ABS Label 794
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}

// ABS Label 795
if(p->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}
sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
    };
// ABS Label 793
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}

  }

#ifdef SQLITE_CHECK_PAGES
  pList = sqlite3PcacheDirtyList(pPager->pPCache);
  for(p=pList; p; p=p->pDirty){
    pager_set_pagehash(p);
  }
#endif

  
// ABS Label 796
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}
return rc;
}

/*
** Begin a read transaction on the WAL.
**
** This routine used to be called "pagerOpenSnapshot()" because it essentially
** makes a snapshot of the database at the current point in time and preserves
** that snapshot for use by the reader in spite of concurrently changes by
** other writers or checkpointers.
*/
static int pagerBeginReadTransaction(Pager *pPager){
  int rc;                         /* Return code */
  int changed = 0;                /* True if cache must be reset */

  assert( pagerUseWal(pPager) );
  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );

  /* sqlite3WalEndReadTransaction() was not called for the previous
  ** transaction in locking_mode=EXCLUSIVE.  So call it now.  If we
  ** are in locking_mode=NORMAL and EndRead() was previously called,
  ** the duplicate call is harmless.
  */
  
// ABS Label 797
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}
sqlite3WalEndReadTransaction(pPager->pWal);

  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);
  
// ABS Label 798
if(changed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}
// ABS Label 799
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}

// COR Label 800
if((rc != 0 && changed) != (rc != 0 || changed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 800);
}

// ROR Label 801
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 801);
}

// MCC Label 802
if(rc != 0 && changed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 802);
}
// MCC Label 803
if(rc != 0 && !(changed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 803);
}
// MCC Label 804
if(!(rc != 0) && changed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 804);
}
// MCC Label 805
if(!(rc != 0) && !(changed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 805);
}
if( rc!=SQLITE_OK || changed ){
    
// ABS Label 806
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}
pager_reset(pPager);
    
// ABS Label 807
if(((pPager)->bUseFetch) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}
if( USEFETCH(pPager) ) { 
// ABS Label 808
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}
sqlite3OsUnfetch(pPager->fd, 0, 0);
}
  }

  
// ABS Label 809
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}
return rc;
}
#endif

/*
** This function is called as part of the transition from PAGER_OPEN
** to PAGER_READER state to determine the size of the database file
** in pages (assuming the page size currently stored in Pager.pageSize).
**
** If no error occurs, SQLITE_OK is returned and the size of the database
** in pages is stored in *pnPage. Otherwise, an error code (perhaps
** SQLITE_IOERR_FSTAT) is returned and *pnPage is left unmodified.
*/
static int pagerPagecount(Pager *pPager, Pgno *pnPage){
  Pgno nPage;                     /* Value to return via *pnPage */

  /* Query the WAL sub-system for the database size. The WalDbsize()
  ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), or
  ** if the database size is not available. The database size is not
  ** available from the WAL sub-system if the log file is empty or
  ** contains no valid committed transactions.
  */
  assert( pPager->eState==PAGER_OPEN );
  assert( pPager->eLock>=SHARED_LOCK );
  assert( isOpen(pPager->fd) );
  assert( pPager->tempFile==0 );
  nPage = sqlite3WalDbsize(pPager->pWal);

  /* If the number of pages in the database is not available from the
  ** WAL sub-system, determine the page count based on the size of
  ** the database file.  If the size of the database file is not an
  ** integer multiple of the page-size, round up the result.
  */
  
// ABS Label 810
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}

// COR Label 811
if((nPage == 0 || (((pPager->fd)->pMethods != 0))) != (nPage == 0 && (((pPager->fd)->pMethods != 0))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 811);
}

// ROR Label 812
if((nPage != 0) != (nPage == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 812);
}

// MCC Label 813
if(nPage == 0 && ( ( (pPager->fd)->pMethods != 0 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 813);
}
// MCC Label 814
if(nPage == 0 && ( ( !((pPager->fd)->pMethods != 0) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 814);
}
// MCC Label 815
if(!(nPage == 0) && ( ( (pPager->fd)->pMethods != 0 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 815);
}
// MCC Label 816
if(!(nPage == 0) && ( ( !((pPager->fd)->pMethods != 0) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 816);
}
if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){
    i64 n = 0;                    /* Size of db file in bytes */
    int rc = sqlite3OsFileSize(pPager->fd, &n);
    
// ABS Label 817
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}

// ROR Label 818
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 818);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 819
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}
return rc;
    }
    nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);
  }

  /* If the current number of pages in the file is greater than the
  ** configured maximum pager number, increase the allowed limit so
  ** that the file can be read.
  */
  
// ABS Label 820
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
// ABS Label 821
if(pPager->mxPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}

// ROR Label 822
if((nPage <= pPager->mxPgno) != (nPage > pPager->mxPgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 822);
}
// ROR Label 823
if((nPage < pPager->mxPgno) != (nPage > pPager->mxPgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 823);
}
// ROR Label 824
if((nPage >= pPager->mxPgno) != (nPage > pPager->mxPgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 824);
}
if( nPage>pPager->mxPgno ){
    pPager->mxPgno = (Pgno)nPage;
  }

  *pnPage = nPage;
  return SQLITE_OK;
}

#ifndef SQLITE_OMIT_WAL
/*
** Check if the *-wal file that corresponds to the database opened by pPager
** exists if the database is not empy, or verify that the *-wal file does
** not exist (by deleting it) if the database file is empty.
**
** If the database is not empty and the *-wal file exists, open the pager
** in WAL mode.  If the database is empty or if no *-wal file exists and
** if no error occurs, make sure Pager.journalMode is not set to
** PAGER_JOURNALMODE_WAL.
**
** Return SQLITE_OK or an error code.
**
** The caller must hold a SHARED lock on the database file to call this
** function. Because an EXCLUSIVE lock on the db file is required to delete 
** a WAL on a none-empty database, this ensures there is no race condition 
** between the xAccess() below and an xDelete() being executed by some 
** other connection.
*/
static int pagerOpenWalIfPresent(Pager *pPager){
  int rc = SQLITE_OK;
  assert( pPager->eState==PAGER_OPEN );
  assert( pPager->eLock>=SHARED_LOCK );

  if( !pPager->tempFile ){
    int isWal;                    /* True if WAL file exists */
    rc = sqlite3OsAccess(
        pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal
    );
    
// ABS Label 825
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}

// ROR Label 826
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 826);
}
if( rc==SQLITE_OK ){
      
// ABS Label 827
if(isWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
if( isWal ){
        Pgno nPage;                   /* Size of the database file */

        rc = pagerPagecount(pPager, &nPage);
        
// ABS Label 828
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}
if( rc ) { 
// ABS Label 829
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}
return rc;
}
        
// ABS Label 830
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}

// ROR Label 831
if((nPage != 0) != (nPage == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 831);
}
if( nPage==0 ){
          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
        }else{
          testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );
          rc = sqlite3PagerOpenWal(pPager, 0);
        }
      }else { 
// ROR Label 832
if((pPager->journalMode != 5) != (pPager->journalMode == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}
if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){
        pPager->journalMode = PAGER_JOURNALMODE_DELETE;
      };}

    }
  }
  
// ABS Label 833
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}
return rc;
}
#endif

/*
** Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playback
** the entire super-journal file. The case pSavepoint==NULL occurs when 
** a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction 
** savepoint.
**
** When pSavepoint is not NULL (meaning a non-transaction savepoint is 
** being rolled back), then the rollback consists of up to three stages,
** performed in the order specified:
**
**   * Pages are played back from the main journal starting at byte
**     offset PagerSavepoint.iOffset and continuing to 
**     PagerSavepoint.iHdrOffset, or to the end of the main journal
**     file if PagerSavepoint.iHdrOffset is zero.
**
**   * If PagerSavepoint.iHdrOffset is not zero, then pages are played
**     back starting from the journal header immediately following 
**     PagerSavepoint.iHdrOffset to the end of the main journal file.
**
**   * Pages are then played back from the sub-journal file, starting
**     with the PagerSavepoint.iSubRec and continuing to the end of
**     the journal file.
**
** Throughout the rollback process, each time a page is rolled back, the
** corresponding bit is set in a bitvec structure (variable pDone in the
** implementation below). This is used to ensure that a page is only
** rolled back the first time it is encountered in either journal.
**
** If pSavepoint is NULL, then pages are only played back from the main
** journal file. There is no need for a bitvec in this case.
**
** In either case, before playback commences the Pager.dbSize variable
** is reset to the value that it held at the start of the savepoint 
** (or transaction). No page with a page-number greater than this value
** is played back. If one is encountered it is simply skipped.
*/
static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){
  i64 szJ;                 /* Effective size of the main journal */
  i64 iHdrOff;             /* End of first segment of main-journal records */
  int rc = SQLITE_OK;      /* Return code */
  Bitvec *pDone = 0;       /* Bitvec to ensure pages played back only once */

  assert( pPager->eState!=PAGER_ERROR );
  assert( pPager->eState>=PAGER_WRITER_LOCKED );

  /* Allocate a bitvec to use to store the set of pages rolled back */
  
// ABS Label 835
if(pSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}
if( pSavepoint ){
    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);
    if( !pDone ){
      return SQLITE_NOMEM_BKPT;
    }
  }

  /* Set the database size back to the value it was before the savepoint 
  ** being reverted was opened.
  */
  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;
  pPager->changeCountDone = pPager->tempFile;

  
// COR Label 836
if((!pSavepoint || ((pPager)->pWal != 0)) != (!pSavepoint && ((pPager)->pWal != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 836);
}

// MCC Label 837
if(!pSavepoint && ( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 837);
}
// MCC Label 838
if(!pSavepoint && ( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 838);
}
// MCC Label 839
if(!(!pSavepoint) && ( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 839);
}
// MCC Label 840
if(!(!pSavepoint) && ( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 840);
}
if( !pSavepoint && pagerUseWal(pPager) ){
    return pagerRollbackWal(pPager);
  }

  /* Use pPager->journalOff as the effective size of the main rollback
  ** journal.  The actual file might be larger than this in
  ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything
  ** past pPager->journalOff is off-limits to us.
  */
  szJ = pPager->journalOff;
  assert( pagerUseWal(pPager)==0 || szJ==0 );

  /* Begin by rolling back records from the main journal starting at
  ** PagerSavepoint.iOffset and continuing to the next journal header.
  ** There might be records in the main journal that have a page number
  ** greater than the current database size (pPager->dbSize) but those
  ** will be skipped automatically.  Pages are added to pDone as they
  ** are played back.
  */
  
// ABS Label 841
if(pSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 841);
}

// COR Label 842
if((pSavepoint || !((pPager)->pWal != 0)) != (pSavepoint && !((pPager)->pWal != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 842);
}

// MCC Label 843
if(pSavepoint && !((pPager)->pWal != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 843);
}
// MCC Label 844
if(pSavepoint && !(!((pPager)->pWal != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 844);
}
// MCC Label 845
if(!(pSavepoint) && !((pPager)->pWal != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 845);
}
// MCC Label 846
if(!(pSavepoint) && !(!((pPager)->pWal != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 846);
}
if( pSavepoint && !pagerUseWal(pPager) ){
    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;
    pPager->journalOff = pSavepoint->iOffset;
    
// ABS Label 847
if(iHdrOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}
// ABS Label 848
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}
// ABS Label 849
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}

// COR Label 850
if((rc == 0 || pPager->journalOff < iHdrOff) != (rc == 0 && pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 850);
}

// ROR Label 851
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 851);
}
// ROR Label 852
if((pPager->journalOff <= iHdrOff) != (pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 852);
}
// ROR Label 853
if((pPager->journalOff > iHdrOff) != (pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
// ROR Label 854
if((pPager->journalOff >= iHdrOff) != (pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 854);
}

// MCC Label 855
if(rc == 0 && pPager->journalOff < iHdrOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 855);
}
// MCC Label 856
if(rc == 0 && !(pPager->journalOff < iHdrOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 856);
}
// MCC Label 857
if(!(rc == 0) && pPager->journalOff < iHdrOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 857);
}
// MCC Label 858
if(!(rc == 0) && !(pPager->journalOff < iHdrOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 858);
}
while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    };
// ABS Label 859
if(iHdrOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}
// ABS Label 860
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}
// ABS Label 861
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 861);
}

// COR Label 862
if((rc == 0 || pPager->journalOff < iHdrOff) != (rc == 0 && pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 862);
}

// ROR Label 863
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 863);
}
// ROR Label 864
if((pPager->journalOff <= iHdrOff) != (pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}
// ROR Label 865
if((pPager->journalOff > iHdrOff) != (pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 865);
}
// ROR Label 866
if((pPager->journalOff >= iHdrOff) != (pPager->journalOff < iHdrOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}

// MCC Label 867
if(rc == 0 && pPager->journalOff < iHdrOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 867);
}
// MCC Label 868
if(rc == 0 && !(pPager->journalOff < iHdrOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 868);
}
// MCC Label 869
if(!(rc == 0) && pPager->journalOff < iHdrOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 869);
}
// MCC Label 870
if(!(rc == 0) && !(pPager->journalOff < iHdrOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 870);
}

    assert( rc!=SQLITE_DONE );
  }else{
    pPager->journalOff = 0;
  }

  /* Continue rolling back records out of the main journal starting at
  ** the first journal header seen and continuing until the effective end
  ** of the main journal file.  Continue to skip out-of-range pages and
  ** continue adding pages rolled back to pDone.
  */
  
// ABS Label 871
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}
// ABS Label 872
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
// ABS Label 873
if(szJ < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// COR Label 874
if((rc == 0 || pPager->journalOff < szJ) != (rc == 0 && pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 874);
}

// ROR Label 875
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}
// ROR Label 876
if((pPager->journalOff <= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 876);
}
// ROR Label 877
if((pPager->journalOff > szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 877);
}
// ROR Label 878
if((pPager->journalOff >= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 878);
}

// MCC Label 879
if(rc == 0 && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 879);
}
// MCC Label 880
if(rc == 0 && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 880);
}
// MCC Label 881
if(!(rc == 0) && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 881);
}
// MCC Label 882
if(!(rc == 0) && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 882);
}
while( rc==SQLITE_OK && pPager->journalOff<szJ ){
    u32 ii;            /* Loop counter */
    u32 nJRec = 0;     /* Number of Journal Records */
    u32 dummy;
    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);
    assert( rc!=SQLITE_DONE );

    /*
    ** The "pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff"
    ** test is related to ticket #2565.  See the discussion in the
    ** pager_playback() function for additional information.
    */
    
// ABS Label 895
if(nJRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}
// ABS Label 896
if(pPager->journalHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}
// ABS Label 897
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}

// AOR Label 898
if(pPager->journalHdr - (pPager->sectorSize) != pPager->journalHdr + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 898);
}
// AOR Label 899
if(pPager->journalHdr / (pPager->sectorSize) != pPager->journalHdr + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 899);
}
// AOR Label 900
if(pPager->journalHdr * (pPager->sectorSize) != pPager->journalHdr + (pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 900);
}

// COR Label 901
if((nJRec == 0 || pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) != (nJRec == 0 && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 901);
}

// ROR Label 902
if((nJRec != 0) != (nJRec == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 902);
}
// ROR Label 903
if((pPager->journalHdr + (pPager->sectorSize) != pPager->journalOff) != (pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 903);
}

// MCC Label 904
if(nJRec == 0 && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 904);
}
// MCC Label 905
if(nJRec == 0 && !(pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 905);
}
// MCC Label 906
if(!(nJRec == 0) && pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 906);
}
// MCC Label 907
if(!(nJRec == 0) && !(pPager->journalHdr + (pPager->sectorSize) == pPager->journalOff) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
if( nJRec==0 
     && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff
    ){
      nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));
    }
    ii = 0;

// ABS Label 908
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 908);
}
// ABS Label 909
if(nJRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 909);
}
// ABS Label 910
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}
// ABS Label 911
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}
// ABS Label 912
if(szJ < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 912);
}

// COR Label 913
if((rc == 0 && ii < nJRec || pPager->journalOff < szJ) != (rc == 0 && ii < nJRec && pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 913);
}
// COR Label 914
if((rc == 0 || ii < nJRec) != (rc == 0 && ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 914);
}

// ROR Label 915
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 915);
}
// ROR Label 916
if((ii <= nJRec) != (ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 916);
}
// ROR Label 917
if((ii > nJRec) != (ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 917);
}
// ROR Label 918
if((ii >= nJRec) != (ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
// ROR Label 919
if((pPager->journalOff <= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 919);
}
// ROR Label 920
if((pPager->journalOff > szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 920);
}
// ROR Label 921
if((pPager->journalOff >= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 921);
}

// MCC Label 922
if(rc == 0 && ii < nJRec && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 922);
}
// MCC Label 923
if(rc == 0 && ii < nJRec && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 923);
}
// MCC Label 924
if(rc == 0 && !(ii < nJRec) && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 924);
}
// MCC Label 925
if(rc == 0 && !(ii < nJRec) && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 925);
}
// MCC Label 926
if(!(rc == 0) && ii < nJRec && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 926);
}
// MCC Label 927
if(!(rc == 0) && ii < nJRec && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 927);
}
// MCC Label 928
if(!(rc == 0) && !(ii < nJRec) && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 928);
}
// MCC Label 929
if(!(rc == 0) && !(ii < nJRec) && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 929);
}
for(; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    };
// ABS Label 930
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
// ABS Label 931
if(nJRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 931);
}
// ABS Label 932
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 932);
}
// ABS Label 933
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}
// ABS Label 934
if(szJ < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}

// COR Label 935
if((rc == 0 && ii < nJRec || pPager->journalOff < szJ) != (rc == 0 && ii < nJRec && pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 935);
}
// COR Label 936
if((rc == 0 || ii < nJRec) != (rc == 0 && ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 936);
}

// ROR Label 937
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 937);
}
// ROR Label 938
if((ii <= nJRec) != (ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 938);
}
// ROR Label 939
if((ii > nJRec) != (ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 939);
}
// ROR Label 940
if((ii >= nJRec) != (ii < nJRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 940);
}
// ROR Label 941
if((pPager->journalOff <= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 941);
}
// ROR Label 942
if((pPager->journalOff > szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 942);
}
// ROR Label 943
if((pPager->journalOff >= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 943);
}

// MCC Label 944
if(rc == 0 && ii < nJRec && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 944);
}
// MCC Label 945
if(rc == 0 && ii < nJRec && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 945);
}
// MCC Label 946
if(rc == 0 && !(ii < nJRec) && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 946);
}
// MCC Label 947
if(rc == 0 && !(ii < nJRec) && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 947);
}
// MCC Label 948
if(!(rc == 0) && ii < nJRec && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 948);
}
// MCC Label 949
if(!(rc == 0) && ii < nJRec && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 949);
}
// MCC Label 950
if(!(rc == 0) && !(ii < nJRec) && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 950);
}
// MCC Label 951
if(!(rc == 0) && !(ii < nJRec) && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 951);
}

    assert( rc!=SQLITE_DONE );
  };
// ABS Label 883
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}
// ABS Label 884
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 884);
}
// ABS Label 885
if(szJ < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 885);
}

// COR Label 886
if((rc == 0 || pPager->journalOff < szJ) != (rc == 0 && pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 886);
}

// ROR Label 887
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}
// ROR Label 888
if((pPager->journalOff <= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
// ROR Label 889
if((pPager->journalOff > szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 889);
}
// ROR Label 890
if((pPager->journalOff >= szJ) != (pPager->journalOff < szJ))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 890);
}

// MCC Label 891
if(rc == 0 && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 891);
}
// MCC Label 892
if(rc == 0 && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 892);
}
// MCC Label 893
if(!(rc == 0) && pPager->journalOff < szJ ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 893);
}
// MCC Label 894
if(!(rc == 0) && !(pPager->journalOff < szJ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 894);
}

  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );

  /* Finally,  rollback pages from the sub-journal.  Page that were
  ** previously rolled back out of the main journal (and are hence in pDone)
  ** will be skipped.  Out-of-range pages are also skipped.
  */
  
// ABS Label 952
if(pSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 952);
}
if( pSavepoint ){
    u32 ii;            /* Loop counter */
    
// AOR Label 953
if((i64)pSavepoint->iSubRec - (4 + pPager->pageSize) != (i64)pSavepoint->iSubRec * (4 + pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 953);
}
// AOR Label 954
if((i64)pSavepoint->iSubRec + (4 + pPager->pageSize) != (i64)pSavepoint->iSubRec * (4 + pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 954);
}
// AOR Label 955
if((i64)pSavepoint->iSubRec / (4 + pPager->pageSize) != (i64)pSavepoint->iSubRec * (4 + pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 955);
}
i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);

    
// MCC Label 956
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 956);
}
// MCC Label 957
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 957);
}
if( pagerUseWal(pPager) ){
      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
    }
    ii = pSavepoint->iSubRec;

// ABS Label 958
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 958);
}
// ABS Label 959
if(pPager->nSubRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 959);
}
// ABS Label 960
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 960);
}

// COR Label 961
if((rc == 0 || ii < pPager->nSubRec) != (rc == 0 && ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 961);
}

// ROR Label 962
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 962);
}
// ROR Label 963
if((ii <= pPager->nSubRec) != (ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 963);
}
// ROR Label 964
if((ii > pPager->nSubRec) != (ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 964);
}
// ROR Label 965
if((ii >= pPager->nSubRec) != (ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 965);
}

// MCC Label 966
if(rc == 0 && ii < pPager->nSubRec ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 966);
}
// MCC Label 967
if(rc == 0 && !(ii < pPager->nSubRec) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 967);
}
// MCC Label 968
if(!(rc == 0) && ii < pPager->nSubRec ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 968);
}
// MCC Label 969
if(!(rc == 0) && !(ii < pPager->nSubRec) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 969);
}
for(; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){
      assert( offset==(i64)ii*(4+pPager->pageSize) );
      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);
    };
// ABS Label 970
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}
// ABS Label 971
if(pPager->nSubRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 971);
}
// ABS Label 972
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 972);
}

// COR Label 973
if((rc == 0 || ii < pPager->nSubRec) != (rc == 0 && ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 973);
}

// ROR Label 974
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 974);
}
// ROR Label 975
if((ii <= pPager->nSubRec) != (ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 975);
}
// ROR Label 976
if((ii > pPager->nSubRec) != (ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 976);
}
// ROR Label 977
if((ii >= pPager->nSubRec) != (ii < pPager->nSubRec))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 977);
}

// MCC Label 978
if(rc == 0 && ii < pPager->nSubRec ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 978);
}
// MCC Label 979
if(rc == 0 && !(ii < pPager->nSubRec) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 979);
}
// MCC Label 980
if(!(rc == 0) && ii < pPager->nSubRec ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 980);
}
// MCC Label 981
if(!(rc == 0) && !(ii < pPager->nSubRec) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 981);
}

    assert( rc!=SQLITE_DONE );
  }

  
// ABS Label 834
if(pDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 834);
}
sqlite3BitvecDestroy(pDone);
  
// ABS Label 982
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}

// ROR Label 983
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 983);
}
if( rc==SQLITE_OK ){
    pPager->journalOff = szJ;
  }

  
// ABS Label 984
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 984);
}
return rc;
}

/*
** Change the maximum number of in-memory pages that are allowed
** before attempting to recycle clean and unused pages.
*/
void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){
  
// ABS Label 985
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}

// ABS Label 986
if(mxPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}
sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
}

/*
** Change the maximum number of in-memory pages that are allowed
** before attempting to spill pages to journal.
*/
int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}

/*
** Invoke SQLITE_FCNTL_MMAP_SIZE based on the current value of szMmap.
*/
static void pagerFixMaplimit(Pager *pPager){
#if SQLITE_MAX_MMAP_SIZE>0
  
// ABS Label 987
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 987);
}
sqlite3_file *fd = pPager->fd;
  
// ABS Label 988
if(fd->pMethods->iVersion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 988);
}

// COR Label 989
if((((fd)->pMethods != 0) || fd->pMethods->iVersion >= 3) != (((fd)->pMethods != 0) && fd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 989);
}

// ROR Label 990
if((fd->pMethods->iVersion < 3) != (fd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 990);
}
// ROR Label 991
if((fd->pMethods->iVersion > 3) != (fd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 991);
}
// ROR Label 992
if((fd->pMethods->iVersion <= 3) != (fd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 992);
}

// MCC Label 993
if(( (fd)->pMethods != 0 ) && fd->pMethods->iVersion >= 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 993);
}
// MCC Label 994
if(( (fd)->pMethods != 0 ) && !(fd->pMethods->iVersion >= 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 994);
}
// MCC Label 995
if(( !((fd)->pMethods != 0) ) && fd->pMethods->iVersion >= 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 995);
}
// MCC Label 996
if(( !((fd)->pMethods != 0) ) && !(fd->pMethods->iVersion >= 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 996);
}
if( isOpen(fd) && fd->pMethods->iVersion>=3 ){
    sqlite3_int64 sz;
    sz = pPager->szMmap;
    pPager->bUseFetch = (sz>0);
    
// ABS Label 997
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}
setGetterMethod(pPager);
    
// ABS Label 998
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}
sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);
  }
#endif
}

/*
** Change the maximum size of any memory mapping made of the database file.
*/
void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){
  pPager->szMmap = szMmap;
  
// ABS Label 999
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}
pagerFixMaplimit(pPager);
}

/*
** Free as much memory as possible from the pager.
*/
void sqlite3PagerShrink(Pager *pPager){
  
// ABS Label 1000
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}
sqlite3PcacheShrink(pPager->pPCache);
}

/*
** Adjust settings of the pager to those specified in the pgFlags parameter.
**
** The "level" in pgFlags & PAGER_SYNCHRONOUS_MASK sets the robustness
** of the database to damage due to OS crashes or power failures by
** changing the number of syncs()s when writing the journals.
** There are four levels:
**
**    OFF       sqlite3OsSync() is never called.  This is the default
**              for temporary and transient files.
**
**    NORMAL    The journal is synced once before writes begin on the
**              database.  This is normally adequate protection, but
**              it is theoretically possible, though very unlikely,
**              that an inopertune power failure could leave the journal
**              in a state which would cause damage to the database
**              when it is rolled back.
**
**    FULL      The journal is synced twice before writes begin on the
**              database (with some additional information - the nRec field
**              of the journal header - being written in between the two
**              syncs).  If we assume that writing a
**              single disk sector is atomic, then this mode provides
**              assurance that the journal will not be corrupted to the
**              point of causing damage to the database during rollback.
**
**    EXTRA     This is like FULL except that is also syncs the directory
**              that contains the rollback journal after the rollback
**              journal is unlinked.
**
** The above is for a rollback-journal mode.  For WAL mode, OFF continues
** to mean that no syncs ever occur.  NORMAL means that the WAL is synced
** prior to the start of checkpoint and that the database file is synced
** at the conclusion of the checkpoint if the entire content of the WAL
** was written back into the database.  But no sync operations occur for
** an ordinary commit in NORMAL mode with WAL.  FULL means that the WAL
** file is synced following each commit operation, in addition to the
** syncs associated with NORMAL.  There is no difference between FULL
** and EXTRA for WAL mode.
**
** Do not confuse synchronous=FULL with SQLITE_SYNC_FULL.  The
** SQLITE_SYNC_FULL macro means to use the MacOSX-style full-fsync
** using fcntl(F_FULLFSYNC).  SQLITE_SYNC_NORMAL means to do an
** ordinary fsync() call.  There is no difference between SQLITE_SYNC_FULL
** and SQLITE_SYNC_NORMAL on platforms other than MacOSX.  But the
** synchronous=FULL versus synchronous=NORMAL setting determines when
** the xSync primitive is called and is relevant to all platforms.
**
** Numeric values associated with these states are OFF==1, NORMAL=2,
** and FULL=3.
*/
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
void sqlite3PagerSetFlags(
  Pager *pPager,        /* The pager to set safety level for */
  unsigned pgFlags      /* Various flags */
){
  
// ABS Label 1001
if(pgFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1001);
}

// AOR Label 1002
if(pgFlags | 7 != pgFlags & 7)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1002);
}
// AOR Label 1003
if(pgFlags ^ 7 != pgFlags & 7)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1003);
}
unsigned level = pgFlags & PAGER_SYNCHRONOUS_MASK;
  
// ABS Label 1004
if(pPager->tempFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1004);
}
if( pPager->tempFile ){
    pPager->noSync = 1;
    pPager->fullSync = 0;
    pPager->extraSync = 0;
  }else{
    pPager->noSync =  level==PAGER_SYNCHRONOUS_OFF ?1:0;
    pPager->fullSync = level>=PAGER_SYNCHRONOUS_FULL ?1:0;
    pPager->extraSync = level==PAGER_SYNCHRONOUS_EXTRA ?1:0;
  }
  
// ABS Label 1005
if(pPager->noSync < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1005);
}
if( pPager->noSync ){
    pPager->syncFlags = 0;
  }else { 
// ABS Label 1006
if(pgFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}

// AOR Label 1007
if(pgFlags | 8 != pgFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1007);
}
// AOR Label 1008
if(pgFlags ^ 8 != pgFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1008);
}
if( pgFlags & PAGER_FULLFSYNC ){
    pPager->syncFlags = SQLITE_SYNC_FULL;
  }else{
    pPager->syncFlags = SQLITE_SYNC_NORMAL;
  };}

  pPager->walSyncFlags = (pPager->syncFlags<<2);
  
// ABS Label 1009
if(pPager->fullSync < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1009);
}
if( pPager->fullSync ){
    pPager->walSyncFlags |= pPager->syncFlags;
  }
  
// COR Label 1010
if(((pgFlags & 16) || !pPager->noSync) != ((pgFlags & 16) && !pPager->noSync))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1010);
}

// MCC Label 1011
if(( pgFlags & 16 ) && !pPager->noSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1011);
}
// MCC Label 1012
if(( pgFlags & 16 ) && !(!pPager->noSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1012);
}
// MCC Label 1013
if(( !(pgFlags & 16) ) && !pPager->noSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1013);
}
// MCC Label 1014
if(( !(pgFlags & 16) ) && !(!pPager->noSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1014);
}
if( (pgFlags & PAGER_CKPT_FULLFSYNC) && !pPager->noSync ){
    pPager->walSyncFlags |= (SQLITE_SYNC_FULL<<2);
  }
  
// ABS Label 1015
if(pgFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}

// AOR Label 1016
if(pgFlags | 32 != pgFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1016);
}
// AOR Label 1017
if(pgFlags ^ 32 != pgFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1017);
}
if( pgFlags & PAGER_CACHESPILL ){
    pPager->doNotSpill &= ~SPILLFLAG_OFF;
  }else{
    pPager->doNotSpill |= SPILLFLAG_OFF;
  }
}
#endif

/*
** The following global variable is incremented whenever the library
** attempts to open a temporary file.  This information is used for
** testing and analysis only.  
*/
#ifdef SQLITE_TEST
int sqlite3_opentemp_count = 0;
#endif

/*
** Open a temporary file.
**
** Write the file descriptor into *pFile. Return SQLITE_OK on success 
** or some other error code if we fail. The OS will automatically 
** delete the temporary file when it is closed.
**
** The flags passed to the VFS layer xOpen() call are those specified
** by parameter vfsFlags ORed with the following:
**
**     SQLITE_OPEN_READWRITE
**     SQLITE_OPEN_CREATE
**     SQLITE_OPEN_EXCLUSIVE
**     SQLITE_OPEN_DELETEONCLOSE
*/
static int pagerOpentemp(
  Pager *pPager,        /* The pager object */
  sqlite3_file *pFile,  /* Write the file descriptor here */
  int vfsFlags          /* Flags passed through to the VFS */
){
  int rc;               /* Return code */

#ifdef SQLITE_TEST
  sqlite3_opentemp_count++;  /* Used for testing and analysis only */
#endif

  vfsFlags |=  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |
            SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;
  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);
  assert( rc!=SQLITE_OK || isOpen(pFile) );
  
// ABS Label 1018
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1018);
}
return rc;
}

/*
** Set the busy handler function.
**
** The pager invokes the busy-handler if sqlite3OsLock() returns 
** SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,
** or when trying to upgrade from a RESERVED lock to an EXCLUSIVE 
** lock. It does *not* invoke the busy handler when upgrading from
** SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVE
** (which occurs during hot-journal rollback). Summary:
**
**   Transition                        | Invokes xBusyHandler
**   --------------------------------------------------------
**   NO_LOCK       -> SHARED_LOCK      | Yes
**   SHARED_LOCK   -> RESERVED_LOCK    | No
**   SHARED_LOCK   -> EXCLUSIVE_LOCK   | No
**   RESERVED_LOCK -> EXCLUSIVE_LOCK   | Yes
**
** If the busy-handler callback returns non-zero, the lock is 
** retried. If it returns zero, then the SQLITE_BUSY error is
** returned to the caller of the pager API function.
*/
void sqlite3PagerSetBusyHandler(
  Pager *pPager,                       /* Pager object */
  int (*xBusyHandler)(void *),         /* Pointer to busy-handler function */
  void *pBusyHandlerArg                /* Argument to pass to xBusyHandler */
){
  void **ap;
  pPager->xBusyHandler = xBusyHandler;
  pPager->pBusyHandlerArg = pBusyHandlerArg;
  ap = (void **)&pPager->xBusyHandler;
  assert( ((int(*)(void *))(ap[0]))==xBusyHandler );
  assert( ap[1]==pBusyHandlerArg );
  
// ABS Label 1019
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}
sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);
}

/*
** Change the page size used by the Pager object. The new page size 
** is passed in *pPageSize.
**
** If the pager is in the error state when this function is called, it
** is a no-op. The value returned is the error state error code (i.e. 
** one of SQLITE_IOERR, an SQLITE_IOERR_xxx sub-code or SQLITE_FULL).
**
** Otherwise, if all of the following are true:
**
**   * the new page size (value of *pPageSize) is valid (a power 
**     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and
**
**   * there are no outstanding page references, and
**
**   * the database is either not an in-memory database or it is
**     an in-memory database that currently consists of zero pages.
**
** then the pager object page size is set to *pPageSize.
**
** If the page size is changed, then this function uses sqlite3PagerMalloc() 
** to obtain a new Pager.pTmpSpace buffer. If this allocation attempt 
** fails, SQLITE_NOMEM is returned and the page size remains unchanged. 
** In all other cases, SQLITE_OK is returned.
**
** If the page size is not changed, either because one of the enumerated
** conditions above is not true, the pager was in error state when this
** function was called, or because the memory allocation attempt failed, 
** then *pPageSize is set to the old, retained page size before returning.
*/
int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){
  int rc = SQLITE_OK;

  /* It is not possible to do a full assert_pager_state() here, as this
  ** function may be called from within PagerOpen(), before the state
  ** of the Pager object is internally consistent.
  **
  ** At one point this function returned an error if the pager was in 
  ** PAGER_ERROR state. But since PAGER_ERROR state guarantees that
  ** there is at least one outstanding page reference, this function
  ** is a no-op for that case anyhow.
  */

  
// ABS Label 1020
if(*pPageSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1020);
}
u32 pageSize = *pPageSize;
  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );
  if( (pPager->memDb==0 || pPager->dbSize==0)
   && sqlite3PcacheRefCount(pPager->pPCache)==0 
   && pageSize && pageSize!=(u32)pPager->pageSize 
  ){
    char *pNew = NULL;             /* New temp space */
    i64 nByte = 0;

    
// COR Label 1021
if((pPager->eState > 0 || ((pPager->fd)->pMethods != 0)) != (pPager->eState > 0 && ((pPager->fd)->pMethods != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1021);
}

// ROR Label 1022
if((pPager->eState <= 0) != (pPager->eState > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1022);
}
// ROR Label 1023
if((pPager->eState < 0) != (pPager->eState > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1023);
}
// ROR Label 1024
if((pPager->eState >= 0) != (pPager->eState > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1024);
}

// MCC Label 1025
if(pPager->eState > 0 && ( (pPager->fd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1025);
}
// MCC Label 1026
if(pPager->eState > 0 && ( !((pPager->fd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1026);
}
// MCC Label 1027
if(!(pPager->eState > 0) && ( (pPager->fd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1027);
}
// MCC Label 1028
if(!(pPager->eState > 0) && ( !((pPager->fd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1028);
}
if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){
      rc = sqlite3OsFileSize(pPager->fd, &nByte);
    }
    
// ABS Label 1029
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}

// ROR Label 1030
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1030);
}
if( rc==SQLITE_OK ){
      /* 8 bytes of zeroed overrun space is sufficient so that the b-tree
      * cell header parser will never run off the end of the allocation */
      pNew = (char *)sqlite3PageMalloc(pageSize+8);
      if( !pNew ){
        rc = SQLITE_NOMEM_BKPT;
      }else{
        memset(pNew+pageSize, 0, 8);
      }
    }

    
// ABS Label 1031
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}

// ROR Label 1032
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1032);
}
if( rc==SQLITE_OK ){
      
// ABS Label 1033
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}
pager_reset(pPager);
      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
    }
    
// ABS Label 1034
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1034);
}

// ROR Label 1035
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1035);
}
if( rc==SQLITE_OK ){
      sqlite3PageFree(pPager->pTmpSpace);
      pPager->pTmpSpace = pNew;
      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);
      pPager->pageSize = pageSize;
    }else{
      sqlite3PageFree(pNew);
    }
  }

  *pPageSize = pPager->pageSize;
  
// ABS Label 1036
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1036);
}

// ROR Label 1037
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1037);
}
if( rc==SQLITE_OK ){
    
// ABS Label 1039
if(nReserve < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1039);
}

// ROR Label 1040
if((nReserve <= 0) != (nReserve < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1040);
}
// ROR Label 1041
if((nReserve > 0) != (nReserve < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1041);
}
// ROR Label 1042
if((nReserve >= 0) != (nReserve < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1042);
}
if( nReserve<0 ) { nReserve = pPager->nReserve;
}
    assert( nReserve>=0 && nReserve<1000 );
    pPager->nReserve = (i16)nReserve;
    
// ABS Label 1038
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1038);
}
pagerFixMaplimit(pPager);
  }
  
// ABS Label 1043
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}
return rc;
}

/*
** Return a pointer to the "temporary page" buffer held internally
** by the pager.  This is a buffer that is big enough to hold the
** entire content of a database page.  This buffer is used internally
** during rollback and will be overwritten whenever a rollback
** occurs.  But other modules are free to use it too, as long as
** no rollbacks are happening.
*/
void *sqlite3PagerTempSpace(Pager *pPager){
  return pPager->pTmpSpace;
}

/*
** Attempt to set the maximum database page count if mxPage is positive. 
** Make no changes if mxPage is zero or negative.  And never reduce the
** maximum page count below the current size of the database.
**
** Regardless of mxPage, return the current maximum page count.
*/
Pgno sqlite3PagerMaxPageCount(Pager *pPager, Pgno mxPage){
  
// ABS Label 1044
if(mxPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// ROR Label 1045
if((mxPage <= 0) != (mxPage > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1045);
}
// ROR Label 1046
if((mxPage < 0) != (mxPage > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1046);
}
// ROR Label 1047
if((mxPage >= 0) != (mxPage > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1047);
}
if( mxPage>0 ){
    pPager->mxPgno = mxPage;
  }
  assert( pPager->eState!=PAGER_OPEN );      /* Called only by OP_MaxPgcnt */
  /* assert( pPager->mxPgno>=pPager->dbSize ); */
  /* OP_MaxPgcnt ensures that the parameter passed to this function is not
  ** less than the total number of valid pages in the database. But this
  ** may be less than Pager.dbSize, and so the assert() above is not valid */
  
// ABS Label 1048
if(pPager->mxPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}
return pPager->mxPgno;
}

/*
** The following set of routines are used to disable the simulated
** I/O error mechanism.  These routines are used to avoid simulated
** errors in places where we do not care about errors.
**
** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops
** and generate no code.
*/
#ifdef SQLITE_TEST
extern int sqlite3_io_error_pending;
extern int sqlite3_io_error_hit;
static int saved_cnt;
void disable_simulated_io_errors(void){
  saved_cnt = sqlite3_io_error_pending;
  sqlite3_io_error_pending = -1;
}
void enable_simulated_io_errors(void){
  sqlite3_io_error_pending = saved_cnt;
}
#else
# define disable_simulated_io_errors()
# define enable_simulated_io_errors()
#endif

/*
** Read the first N bytes from the beginning of the file into memory
** that pDest points to. 
**
** If the pager was opened on a transient file (zFilename==""), or
** opened on a file less than N bytes in size, the output buffer is
** zeroed and SQLITE_OK returned. The rationale for this is that this 
** function is used to read database headers, and a new transient or
** zero sized database has a header than consists entirely of zeroes.
**
** If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,
** the error code is returned to the caller and the contents of the
** output buffer undefined.
*/
int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){
  int rc = SQLITE_OK;
  memset(pDest, 0, N);
  assert( isOpen(pPager->fd) || pPager->tempFile );

  /* This routine is only called by btree immediately after creating
  ** the Pager object.  There has not been an opportunity to transition
  ** to WAL mode yet.
  */
  assert( !pagerUseWal(pPager) );

  
// MCC Label 1049
if(( (pPager->fd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1049);
}
// MCC Label 1050
if(( !((pPager->fd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1050);
}
if( isOpen(pPager->fd) ){
    IOTRACE(("DBHDR %p 0 %d\n", pPager, N))
    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);
    
// ABS Label 1051
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}

// ROR Label 1052
if((rc != (10 | (2 << 8))) != (rc == (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1052);
}
if( rc==SQLITE_IOERR_SHORT_READ ){
      rc = SQLITE_OK;
    }
  }
  
// ABS Label 1053
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
return rc;
}

/*
** This function may only be called when a read-transaction is open on
** the pager. It returns the total number of pages in the database.
**
** However, if the file is between 1 and <page-size> bytes in size, then 
** this is considered a 1 page file.
*/
void sqlite3PagerPagecount(Pager *pPager, int *pnPage){
  assert( pPager->eState>=PAGER_READER );
  assert( pPager->eState!=PAGER_WRITER_FINISHED );
  *pnPage = (int)pPager->dbSize;
}


/*
** Try to obtain a lock of type locktype on the database file. If
** a similar or greater lock is already held, this function is a no-op
** (returning SQLITE_OK immediately).
**
** Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke 
** the busy callback if the lock is currently not available. Repeat 
** until the busy callback returns false or until the attempt to 
** obtain the lock succeeds.
**
** Return SQLITE_OK on success and an error code if we cannot obtain
** the lock. If the lock is obtained successfully, set the Pager.state 
** variable to locktype before returning.
*/
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;                              /* Return code */

  /* Check that this is either a no-op (because the requested lock is 
  ** already held), or one of the transitions that the busy-handler
  ** may be invoked during, according to the comment above
  ** sqlite3PagerSetBusyhandler().
  */
  assert( (pPager->eLock>=locktype)
       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)
       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)
  );

  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );;
  
// ABS Label 1054
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}
return rc;
}

/*
** Function assertTruncateConstraint(pPager) checks that one of the 
** following is true for all dirty pages currently in the page-cache:
**
**   a) The page number is less than or equal to the size of the 
**      current database image, in pages, OR
**
**   b) if the page content were written at this time, it would not
**      be necessary to write the current content out to the sub-journal
**      (as determined by function subjRequiresPage()).
**
** If the condition asserted by this function were not true, and the
** dirty page were to be discarded from the cache via the pagerStress()
** routine, pagerStress() would not write the current page content to
** the database file. If a savepoint transaction were rolled back after
** this happened, the correct behavior would be to restore the current
** content of the page. However, since this content is not present in either
** the database file or the portion of the rollback journal and 
** sub-journal rolled back the content could not be restored and the
** database image would become corrupt. It is therefore fortunate that 
** this circumstance cannot arise.
*/
#if defined(SQLITE_DEBUG)
static void assertTruncateConstraintCb(PgHdr *pPg){
  assert( pPg->flags&PGHDR_DIRTY );
  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );
}
static void assertTruncateConstraint(Pager *pPager){
  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);
}
#else
# define assertTruncateConstraint(pPager)
#endif

/*
** Truncate the in-memory database file image to nPage pages. This 
** function does not actually modify the database file on disk. It 
** just sets the internal state of the pager object so that the 
** truncation will be done when the current transaction is committed.
**
** This function is only called right before committing a transaction.
** Once this function has been called, the transaction must either be
** rolled back or committed. It is not safe to call this function and
** then continue writing to the database.
*/
void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){
  assert( pPager->dbSize>=nPage || CORRUPT_DB );
  testcase( pPager->dbSize<nPage );
  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );
  pPager->dbSize = nPage;

  /* At one point the code here called assertTruncateConstraint() to
  ** ensure that all pages being truncated away by this operation are,
  ** if one or more savepoints are open, present in the savepoint 
  ** journal so that they can be restored if the savepoint is rolled
  ** back. This is no longer necessary as this function is now only
  ** called right before committing a transaction. So although the 
  ** Pager object may still have open savepoints (Pager.nSavepoint!=0), 
  ** they cannot be rolled back. So the assertTruncateConstraint() call
  ** is no longer correct. */
}


/*
** This function is called before attempting a hot-journal rollback. It
** syncs the journal file to disk, then sets pPager->journalHdr to the
** size of the journal file so that the pager_playback() routine knows
** that the entire journal file has been synced.
**
** Syncing a hot-journal to disk before attempting to roll it back ensures 
** that if a power-failure occurs during the rollback, the process that
** attempts rollback following system recovery sees the same journal
** content as this process.
**
** If everything goes as planned, SQLITE_OK is returned. Otherwise, 
** an SQLite error code.
*/
static int pagerSyncHotJournal(Pager *pPager){
  int rc = SQLITE_OK;
  if( !pPager->noSync ){
    rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);
  }
  
// ABS Label 1055
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}

// ROR Label 1056
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1056);
}
if( rc==SQLITE_OK ){
    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);
  }
  
// ABS Label 1057
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}
return rc;
}

#if SQLITE_MAX_MMAP_SIZE>0
/*
** Obtain a reference to a memory mapped page object for page number pgno. 
** The new object will use the pointer pData, obtained from xFetch().
** If successful, set *ppPage to point to the new page reference
** and return SQLITE_OK. Otherwise, return an SQLite error code and set
** *ppPage to zero.
**
** Page references obtained by calling this function should be released
** by calling pagerReleaseMapPage().
*/
static int pagerAcquireMapPage(
  Pager *pPager,                  /* Pager object */
  Pgno pgno,                      /* Page number */
  void *pData,                    /* xFetch()'d data for this page */
  PgHdr **ppPage                  /* OUT: Acquired page object */
){
  PgHdr *p;                       /* Memory mapped page to return */
  
  
// ABS Label 1058
if(pPager->pMmapFreelist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}
if( pPager->pMmapFreelist ){
    *ppPage = p = pPager->pMmapFreelist;
    pPager->pMmapFreelist = p->pDirty;
    p->pDirty = 0;
    assert( pPager->nExtra>=8 );
    
// ABS Label 1059
if(p->pExtra < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}
memset(p->pExtra, 0, 8);
  }else{
    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
    
// ABS Label 1060
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}

// ROR Label 1061
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1061);
}
if( p==0 ){
      
// ABS Label 1062
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1062);
}

// AOR Label 1063
if((i64)(pgno - 1) - pPager->pageSize != (i64)(pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1063);
}
// AOR Label 1064
if((i64)(pgno - 1) + pPager->pageSize != (i64)(pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1064);
}
// AOR Label 1065
if((i64)(pgno - 1) / pPager->pageSize != (i64)(pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1065);
}

// ABS Label 1066
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1066);
}
sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);
      return SQLITE_NOMEM_BKPT;
    }
    p->pExtra = (void *)&p[1];
    p->flags = PGHDR_MMAP;
    p->nRef = 1;
    p->pPager = pPager;
  }

  assert( p->pExtra==(void *)&p[1] );
  assert( p->pPage==0 );
  assert( p->flags==PGHDR_MMAP );
  assert( p->pPager==pPager );
  assert( p->nRef==1 );

  p->pgno = pgno;
  p->pData = pData;
  pPager->nMmapOut++;

  return SQLITE_OK;
}
#endif

/*
** Release a reference to page pPg. pPg must have been returned by an 
** earlier call to pagerAcquireMapPage().
*/
static void pagerReleaseMapPage(PgHdr *pPg){
  
// ABS Label 1067
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}
Pager *pPager = pPg->pPager;
  pPager->nMmapOut--;
  pPg->pDirty = pPager->pMmapFreelist;
  pPager->pMmapFreelist = pPg;

  assert( pPager->fd->pMethods->iVersion>=3 );
  
// ABS Label 1068
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1068);
}

// AOR Label 1069
if((i64)(pPg->pgno - 1) - pPager->pageSize != (i64)(pPg->pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1069);
}
// AOR Label 1070
if((i64)(pPg->pgno - 1) + pPager->pageSize != (i64)(pPg->pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1070);
}
// AOR Label 1071
if((i64)(pPg->pgno - 1) / pPager->pageSize != (i64)(pPg->pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1071);
}

// ABS Label 1072
if(pPg->pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1072);
}
sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);
}

/*
** Free all PgHdr objects stored in the Pager.pMmapFreelist list.
*/
static void pagerFreeMapHdrs(Pager *pPager){
  PgHdr *p;
  PgHdr *pNext;
  p = pPager->pMmapFreelist;

// ABS Label 1073
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1073);
}
for(; p; p=pNext){
    pNext = p->pDirty;
    sqlite3_free(p);
  };
// ABS Label 1074
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1074);
}

}

/* Verify that the database file has not be deleted or renamed out from
** under the pager.  Return SQLITE_OK if the database is still where it ought
** to be on disk.  Return non-zero (SQLITE_READONLY_DBMOVED or some other error
** code from sqlite3OsAccess()) if the database has gone missing.
*/
static int databaseIsUnmoved(Pager *pPager){
  int bHasMoved = 0;
  int rc;

  
// ABS Label 1075
if(pPager->tempFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1075);
}
if( pPager->tempFile ) { return SQLITE_OK;
}
  
// ABS Label 1076
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1076);
}

// ROR Label 1077
if((pPager->dbSize != 0) != (pPager->dbSize == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1077);
}
if( pPager->dbSize==0 ) { return SQLITE_OK;
}
  assert( pPager->zFilename && pPager->zFilename[0] );
  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);
  
// ABS Label 1078
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1078);
}

// ROR Label 1079
if((rc != 12) != (rc == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1079);
}
if( rc==SQLITE_NOTFOUND ){
    /* If the HAS_MOVED file-control is unimplemented, assume that the file
    ** has not been moved.  That is the historical behavior of SQLite: prior to
    ** version 3.8.3, it never checked */
    rc = SQLITE_OK;
  }else { 
// ABS Label 1080
if(bHasMoved < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}
// ABS Label 1081
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1081);
}

// COR Label 1082
if((rc == 0 || bHasMoved) != (rc == 0 && bHasMoved))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1082);
}

// ROR Label 1083
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1083);
}

// MCC Label 1084
if(rc == 0 && bHasMoved ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1084);
}
// MCC Label 1085
if(rc == 0 && !(bHasMoved) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1085);
}
// MCC Label 1086
if(!(rc == 0) && bHasMoved ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1086);
}
// MCC Label 1087
if(!(rc == 0) && !(bHasMoved) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1087);
}
if( rc==SQLITE_OK && bHasMoved ){
    rc = SQLITE_READONLY_DBMOVED;
  };}

  
// ABS Label 1088
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}
return rc;
}


/*
** Shutdown the page cache.  Free all memory and close all files.
**
** If a transaction was in progress when this routine is called, that
** transaction is rolled back.  All outstanding pages are invalidated
** and their memory is freed.  Any attempt to use a page associated
** with this page cache after this function returns will likely
** result in a coredump.
**
** This function always succeeds. If a transaction is active an attempt
** is made to roll it back. If an error occurs during the rollback 
** a hot journal may be left in the filesystem but no error is returned
** to the caller.
*/
int sqlite3PagerClose(Pager *pPager, sqlite3 *db){
  u8 *pTmp = (u8*)pPager->pTmpSpace;
  assert( db || pagerUseWal(pPager)==0 );
  assert( assert_pager_state(pPager) );
  disable_simulated_io_errors();
  sqlite3BeginBenignMalloc();
  
// ABS Label 1089
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}
pagerFreeMapHdrs(pPager);
  /* pPager->errCode = 0; */
  pPager->exclusiveMode = 0;
#ifndef SQLITE_OMIT_WAL
  {
    u8 *a = 0;
    assert( db || pPager->pWal==0 );
    if( db && 0==(db->flags & SQLITE_NoCkptOnClose) 
     && SQLITE_OK==databaseIsUnmoved(pPager)
    ){
      a = pTmp;
    }
    
// ABS Label 1094
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1094);
}

// ABS Label 1095
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}

// ABS Label 1096
if(pPager->pageSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1096);
}

// ABS Label 1097
if(a < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1097);
}
sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);
    pPager->pWal = 0;
  }
#endif
  
// ABS Label 1090
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}
pager_reset(pPager);
  
// ABS Label 1098
if(pPager->memDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1098);
}
if( MEMDB ){
    
// ABS Label 1099
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}
pager_unlock(pPager);
  }else{
    /* If it is open, sync the journal file before calling UnlockAndRollback.
    ** If this is not done, then an unsynced portion of the open journal 
    ** file may be played back into the database. If a power failure occurs 
    ** while this is happening, the database could become corrupt.
    **
    ** If an error occurs while trying to sync the journal, shift the pager
    ** into the ERROR state. This causes UnlockAndRollback to unlock the
    ** database and close the journal file without attempting to roll it
    ** back or finalize it. The next database user will have to do hot-journal
    ** rollback before accessing the database file.
    */
    
// MCC Label 1101
if(( (pPager->jfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1101);
}
// MCC Label 1102
if(( !((pPager->jfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1102);
}
if( isOpen(pPager->jfd) ){
      
// ABS Label 1103
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1103);
}
pager_error(pPager, pagerSyncHotJournal(pPager));
    }
    
// ABS Label 1100
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}
pagerUnlockAndRollback(pPager);
  }
  sqlite3EndBenignMalloc();
  enable_simulated_io_errors();
  PAGERTRACE(("CLOSE %d\n", PAGERID(pPager)));
  IOTRACE(("CLOSE %p\n", pPager))
  
// ABS Label 1091
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}
sqlite3OsClose(pPager->jfd);
  
// ABS Label 1092
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}
sqlite3OsClose(pPager->fd);
  sqlite3PageFree(pTmp);
  
// ABS Label 1093
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1093);
}
sqlite3PcacheClose(pPager->pPCache);
  assert( !pPager->aSavepoint && !pPager->pInJournal );
  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) );

  sqlite3_free(pPager);
  return SQLITE_OK;
}

#if !defined(NDEBUG) || defined(SQLITE_TEST)
/*
** Return the page number for page pPg.
*/
Pgno sqlite3PagerPagenumber(DbPage *pPg){
  return pPg->pgno;
}
#endif

/*
** Increment the reference count for page pPg.
*/
void sqlite3PagerRef(DbPage *pPg){
  
// ABS Label 1104
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}
sqlite3PcacheRef(pPg);
}

/*
** Sync the journal. In other words, make sure all the pages that have
** been written to the journal have actually reached the surface of the
** disk and can be restored in the event of a hot-journal rollback.
**
** If the Pager.noSync flag is set, then this function is a no-op.
** Otherwise, the actions required depend on the journal-mode and the 
** device characteristics of the file-system, as follows:
**
**   * If the journal file is an in-memory journal file, no action need
**     be taken.
**
**   * Otherwise, if the device does not support the SAFE_APPEND property,
**     then the nRec field of the most recently written journal header
**     is updated to contain the number of journal records that have
**     been written following it. If the pager is operating in full-sync
**     mode, then the journal file is synced before this field is updated.
**
**   * If the device does not support the SEQUENTIAL property, then 
**     journal file is synced.
**
** Or, in pseudo-code:
**
**   if( NOT <in-memory journal> ){
**     if( NOT SAFE_APPEND ){
**       if( <full-sync mode> ) xSync(<journal file>);
**       <update nRec field>
**     } 
**     if( NOT SEQUENTIAL ) xSync(<journal file>);
**   }
**
** If successful, this routine clears the PGHDR_NEED_SYNC flag of every 
** page currently held in memory before returning SQLITE_OK. If an IO
** error is encountered, then the IO error code is returned to the caller.
*/
static int syncJournal(Pager *pPager, int newHdr){
  int rc;                         /* Return code */

  assert( pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
  );
  assert( assert_pager_state(pPager) );
  assert( !pagerUseWal(pPager) );

  rc = sqlite3PagerExclusiveLock(pPager);
  
// ABS Label 1106
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1106);
}

// ROR Label 1107
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1107);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1108
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1108);
}
return rc;
}

  if( !pPager->noSync ){
    assert( !pPager->tempFile );
    
// COR Label 1109
if((((pPager->jfd)->pMethods != 0) || pPager->journalMode != 4) != (((pPager->jfd)->pMethods != 0) && pPager->journalMode != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1109);
}

// ROR Label 1110
if((pPager->journalMode == 4) != (pPager->journalMode != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1110);
}

// MCC Label 1111
if(( (pPager->jfd)->pMethods != 0 ) && pPager->journalMode != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1111);
}
// MCC Label 1112
if(( (pPager->jfd)->pMethods != 0 ) && !(pPager->journalMode != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1112);
}
// MCC Label 1113
if(( !((pPager->jfd)->pMethods != 0) ) && pPager->journalMode != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1113);
}
// MCC Label 1114
if(( !((pPager->jfd)->pMethods != 0) ) && !(pPager->journalMode != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1114);
}
if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){
      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      assert( isOpen(pPager->jfd) );

      
// ROR Label 1115
if((0 != (iDc & 512)) != (0 == (iDc & 512)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1115);
}
if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){
        /* This block deals with an obscure problem. If the last connection
        ** that wrote to this database was operating in persistent-journal
        ** mode, then the journal file may at this point actually be larger
        ** than Pager.journalOff bytes. If the next thing in the journal
        ** file happens to be a journal-header (written as part of the
        ** previous connection's transaction), and a crash or power-failure 
        ** occurs after nRec is updated but before this connection writes 
        ** anything else to the journal file (or commits/rolls back its 
        ** transaction), then SQLite may become confused when doing the 
        ** hot-journal rollback following recovery. It may roll back all
        ** of this connections data, then proceed to rolling back the old,
        ** out-of-date data that follows it. Database corruption.
        **
        ** To work around this, if the journal file does appear to contain
        ** a valid header following Pager.journalOff, then write a 0x00
        ** byte to the start of it to prevent it from being recognized.
        **
        ** Variable iNextHdrOffset is set to the offset at which this
        ** problematic header will occur, if it exists. aMagic is used 
        ** as a temporary buffer to inspect the first couple of bytes of
        ** the potential journal header.
        */
        i64 iNextHdrOffset;
        u8 aMagic[8];
        u8 zHeader[sizeof(aJournalMagic)+4];

        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);

        iNextHdrOffset = journalHdrOffset(pPager);
        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
        
// ABS Label 1116
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1116);
}

// MCC Label 1117
if(rc == 0 && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1117);
}
// MCC Label 1118
if(!(rc == 0) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1118);
}
if( rc==SQLITE_OK && 0==memcmp(aMagic, aJournalMagic, 8) ){
          static const u8 zerobyte = 0;
          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
        }
        
// ABS Label 1119
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1119);
}

// COR Label 1120
if((rc != 0 || rc != (10 | (2 << 8))) != (rc != 0 && rc != (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1120);
}

// ROR Label 1121
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1121);
}
// ROR Label 1122
if((rc == (10 | (2 << 8))) != (rc != (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1122);
}

// MCC Label 1123
if(rc != 0 && rc != (10 | (2 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1123);
}
// MCC Label 1124
if(rc != 0 && !(rc != (10 | (2 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1124);
}
// MCC Label 1125
if(!(rc != 0) && rc != (10 | (2 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1125);
}
// MCC Label 1126
if(!(rc != 0) && !(rc != (10 | (2 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1126);
}
if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){
          
// ABS Label 1127
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}
return rc;
        }

        /* Write the nRec value into the journal file header. If in
        ** full-synchronous mode, sync the journal first. This ensures that
        ** all data has really hit the disk before nRec is updated to mark
        ** it as a candidate for rollback.
        **
        ** This is not required if the persistent media supports the
        ** SAFE_APPEND property. Because in this case it is not possible 
        ** for garbage data to be appended to the file, the nRec field
        ** is populated with 0xFFFFFFFF when the journal header is written
        ** and never needs to be updated.
        */
        
// COR Label 1128
if((pPager->fullSync || 0 == (iDc & 1024)) != (pPager->fullSync && 0 == (iDc & 1024)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1128);
}

// ROR Label 1129
if((0 != (iDc & 1024)) != (0 == (iDc & 1024)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1129);
}

// MCC Label 1130
if(pPager->fullSync && 0 == (iDc & 1024) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1130);
}
// MCC Label 1131
if(pPager->fullSync && !(0 == (iDc & 1024)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1131);
}
// MCC Label 1132
if(!(pPager->fullSync) && 0 == (iDc & 1024) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1132);
}
// MCC Label 1133
if(!(pPager->fullSync) && !(0 == (iDc & 1024)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1133);
}
if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){
          PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));
          IOTRACE(("JSYNC %p\n", pPager))
          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
          
// ABS Label 1134
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}

// ROR Label 1135
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1135);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1136
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1136);
}
return rc;
}
        }
        IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));
        rc = sqlite3OsWrite(
            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
        );
        
// ABS Label 1137
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1137);
}

// ROR Label 1138
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1138);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1139
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1139);
}
return rc;
}
      }
      
// ROR Label 1140
if((0 != (iDc & 1024)) != (0 == (iDc & 1024)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1140);
}
if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){
        PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));
        IOTRACE(("JSYNC %p\n", pPager))
        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags| 
          (pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)
        );
        
// ABS Label 1141
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1141);
}

// ROR Label 1142
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1142);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1143
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1143);
}
return rc;
}
      }

      pPager->journalHdr = pPager->journalOff;
      
// ABS Label 1144
if(newHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1144);
}

// COR Label 1145
if((newHdr || 0 == (iDc & 512)) != (newHdr && 0 == (iDc & 512)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1145);
}

// ROR Label 1146
if((0 != (iDc & 512)) != (0 == (iDc & 512)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1146);
}

// MCC Label 1147
if(newHdr && 0 == (iDc & 512) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1147);
}
// MCC Label 1148
if(newHdr && !(0 == (iDc & 512)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1148);
}
// MCC Label 1149
if(!(newHdr) && 0 == (iDc & 512) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1149);
}
// MCC Label 1150
if(!(newHdr) && !(0 == (iDc & 512)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1150);
}
if( newHdr && 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){
        pPager->nRec = 0;
        rc = writeJournalHdr(pPager);
        
// ABS Label 1151
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1151);
}

// ROR Label 1152
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1152);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1153
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1153);
}
return rc;
}
      }
    }else{
      pPager->journalHdr = pPager->journalOff;
    }
  }

  /* Unless the pager is in noSync mode, the journal file was just 
  ** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on 
  ** all pages.
  */
  
// ABS Label 1105
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1105);
}
sqlite3PcacheClearSyncFlags(pPager->pPCache);
  pPager->eState = PAGER_WRITER_DBMOD;
  assert( assert_pager_state(pPager) );
  return SQLITE_OK;
}

/*
** The argument is the first in a linked list of dirty pages connected
** by the PgHdr.pDirty pointer. This function writes each one of the
** in-memory pages in the list to the database file. The argument may
** be NULL, representing an empty list. In this case this function is
** a no-op.
**
** The pager must hold at least a RESERVED lock when this function
** is called. Before writing anything to the database file, this lock
** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,
** SQLITE_BUSY is returned and no data is written to the database file.
** 
** If the pager is a temp-file pager and the actual file-system file
** is not yet open, it is created and opened before any data is 
** written out.
**
** Once the lock has been upgraded and, if necessary, the file opened,
** the pages are written out to the database file in list order. Writing
** a page is skipped if it meets either of the following criteria:
**
**   * The page number is greater than Pager.dbSize, or
**   * The PGHDR_DONT_WRITE flag is set on the page.
**
** If writing out a page causes the database file to grow, Pager.dbFileSize
** is updated accordingly. If page 1 is written out, then the value cached
** in Pager.dbFileVers[] is updated to match the new value stored in
** the database file.
**
** If everything is successful, SQLITE_OK is returned. If an IO error 
** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot
** be obtained, SQLITE_BUSY is returned.
*/
static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
  int rc = SQLITE_OK;                  /* Return code */

  /* This function is only called for rollback pagers in WRITER_DBMOD state. */
  assert( !pagerUseWal(pPager) );
  assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );
  assert( pPager->eLock==EXCLUSIVE_LOCK );
  assert( isOpen(pPager->fd) || pList->pDirty==0 );

  /* If the file is a temp-file has not yet been opened, open it now. It
  ** is not possible for rc to be other than SQLITE_OK if this branch
  ** is taken, as pager_wait_on_lock() is a no-op for temp-files.
  */
  if( !isOpen(pPager->fd) ){
    assert( pPager->tempFile && rc==SQLITE_OK );
    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
  }

  /* Before the first write, give the VFS a hint of what the final
  ** file size will be.
  */
  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );
  
// ABS Label 1154
if(pPager->dbHintSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1154);
}
// ABS Label 1155
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1155);
}
// ABS Label 1156
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}

// COR Label 1157
if((rc == 0 && pPager->dbHintSize < pPager->dbSize || (pList->pDirty || pList->pgno > pPager->dbHintSize)) != (rc == 0 && pPager->dbHintSize < pPager->dbSize && (pList->pDirty || pList->pgno > pPager->dbHintSize)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1157);
}
// COR Label 1158
if((rc == 0 || pPager->dbHintSize < pPager->dbSize) != (rc == 0 && pPager->dbHintSize < pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1158);
}

// ROR Label 1159
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1159);
}
// ROR Label 1160
if((pPager->dbHintSize <= pPager->dbSize) != (pPager->dbHintSize < pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1160);
}
// ROR Label 1161
if((pPager->dbHintSize > pPager->dbSize) != (pPager->dbHintSize < pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1161);
}
// ROR Label 1162
if((pPager->dbHintSize >= pPager->dbSize) != (pPager->dbHintSize < pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1162);
}

// MCC Label 1163
if(rc == 0 && pPager->dbHintSize < pPager->dbSize && ( pList->pDirty && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1163);
}
// MCC Label 1164
if(rc == 0 && pPager->dbHintSize < pPager->dbSize && ( pList->pDirty && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1164);
}
// MCC Label 1165
if(rc == 0 && pPager->dbHintSize < pPager->dbSize && ( !(pList->pDirty) && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1165);
}
// MCC Label 1166
if(rc == 0 && pPager->dbHintSize < pPager->dbSize && ( !(pList->pDirty) && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1166);
}
// MCC Label 1167
if(rc == 0 && !(pPager->dbHintSize < pPager->dbSize) && ( pList->pDirty && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1167);
}
// MCC Label 1168
if(rc == 0 && !(pPager->dbHintSize < pPager->dbSize) && ( pList->pDirty && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1168);
}
// MCC Label 1169
if(rc == 0 && !(pPager->dbHintSize < pPager->dbSize) && ( !(pList->pDirty) && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1169);
}
// MCC Label 1170
if(rc == 0 && !(pPager->dbHintSize < pPager->dbSize) && ( !(pList->pDirty) && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1170);
}
// MCC Label 1171
if(!(rc == 0) && pPager->dbHintSize < pPager->dbSize && ( pList->pDirty && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1171);
}
// MCC Label 1172
if(!(rc == 0) && pPager->dbHintSize < pPager->dbSize && ( pList->pDirty && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1172);
}
// MCC Label 1173
if(!(rc == 0) && pPager->dbHintSize < pPager->dbSize && ( !(pList->pDirty) && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1173);
}
// MCC Label 1174
if(!(rc == 0) && pPager->dbHintSize < pPager->dbSize && ( !(pList->pDirty) && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1174);
}
// MCC Label 1175
if(!(rc == 0) && !(pPager->dbHintSize < pPager->dbSize) && ( pList->pDirty && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1175);
}
// MCC Label 1176
if(!(rc == 0) && !(pPager->dbHintSize < pPager->dbSize) && ( pList->pDirty && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1176);
}
// MCC Label 1177
if(!(rc == 0) && !(pPager->dbHintSize < pPager->dbSize) && ( !(pList->pDirty) && pList->pgno > pPager->dbHintSize ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1177);
}
// MCC Label 1178
if(!(rc == 0) && !(pPager->dbHintSize < pPager->dbSize) && ( !(pList->pDirty) && !(pList->pgno > pPager->dbHintSize) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1178);
}
if( rc==SQLITE_OK 
   && pPager->dbHintSize<pPager->dbSize
   && (pList->pDirty || pList->pgno>pPager->dbHintSize)
  ){
    
// AOR Label 1179
if(pPager->pageSize - (sqlite3_int64)pPager->dbSize != pPager->pageSize * (sqlite3_int64)pPager->dbSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1179);
}
// AOR Label 1180
if(pPager->pageSize + (sqlite3_int64)pPager->dbSize != pPager->pageSize * (sqlite3_int64)pPager->dbSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1180);
}
// AOR Label 1181
if(pPager->pageSize / (sqlite3_int64)pPager->dbSize != pPager->pageSize * (sqlite3_int64)pPager->dbSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1181);
}
sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
    
// ABS Label 1182
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1182);
}
sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);
    pPager->dbHintSize = pPager->dbSize;
  }

  
// ABS Label 1183
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1183);
}
// ABS Label 1184
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1184);
}

// COR Label 1185
if((rc == 0 || pList) != (rc == 0 && pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1185);
}

// ROR Label 1186
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1186);
}

// MCC Label 1187
if(rc == 0 && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1187);
}
// MCC Label 1188
if(rc == 0 && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1188);
}
// MCC Label 1189
if(!(rc == 0) && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1189);
}
// MCC Label 1190
if(!(rc == 0) && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1190);
}
while( rc==SQLITE_OK && pList ){
    
// ABS Label 1199
if(pList->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}
Pgno pgno = pList->pgno;

    /* If there are dirty pages in the page cache with page numbers greater
    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to
    ** make the file smaller (presumably by auto-vacuum code). Do not write
    ** any such pages to the file.
    **
    ** Also, do not write out any page that has the PGHDR_DONT_WRITE flag
    ** set (set by sqlite3PagerDontWrite()).
    */
    
// ABS Label 1200
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1200);
}
// ABS Label 1201
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1201);
}

// COR Label 1202
if((pgno <= pPager->dbSize || 0 == (pList->flags & 16)) != (pgno <= pPager->dbSize && 0 == (pList->flags & 16)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1202);
}

// ROR Label 1203
if((pgno < pPager->dbSize) != (pgno <= pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1203);
}
// ROR Label 1204
if((pgno > pPager->dbSize) != (pgno <= pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1204);
}
// ROR Label 1205
if((pgno >= pPager->dbSize) != (pgno <= pPager->dbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1205);
}
// ROR Label 1206
if((0 != (pList->flags & 16)) != (0 == (pList->flags & 16)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1206);
}

// MCC Label 1207
if(pgno <= pPager->dbSize && 0 == (pList->flags & 16) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1207);
}
// MCC Label 1208
if(pgno <= pPager->dbSize && !(0 == (pList->flags & 16)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1208);
}
// MCC Label 1209
if(!(pgno <= pPager->dbSize) && 0 == (pList->flags & 16) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1209);
}
// MCC Label 1210
if(!(pgno <= pPager->dbSize) && !(0 == (pList->flags & 16)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1210);
}
if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){
      
// AOR Label 1211
if((pgno - 1) - (i64)pPager->pageSize != (pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1211);
}
// AOR Label 1212
if((pgno - 1) + (i64)pPager->pageSize != (pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1212);
}
// AOR Label 1213
if((pgno - 1) / (i64)pPager->pageSize != (pgno - 1) * (i64)pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1213);
}
i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */
      char *pData;                                   /* Data to write */    

      assert( (pList->flags&PGHDR_NEED_SYNC)==0 );
      
// ABS Label 1216
if(pList->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1216);
}

// ROR Label 1217
if((pList->pgno != 1) != (pList->pgno == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1217);
}
if( pList->pgno==1 ) { 
// ABS Label 1218
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1218);
}
pager_write_changecounter(pList);
}

      pData = pList->pData;

      /* Write out the page data. */
      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);

      /* If page 1 was just written, update Pager.dbFileVers to match
      ** the value now stored in the database file. If writing this 
      ** page caused the database file to grow, update dbFileSize. 
      */
      
// ABS Label 1219
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1219);
}

// ROR Label 1220
if((pgno != 1) != (pgno == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1220);
}
if( pgno==1 ){
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
      }
      
// ABS Label 1221
if(pPager->dbFileSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1221);
}
// ABS Label 1222
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1222);
}

// ROR Label 1223
if((pgno <= pPager->dbFileSize) != (pgno > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1223);
}
// ROR Label 1224
if((pgno < pPager->dbFileSize) != (pgno > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1224);
}
// ROR Label 1225
if((pgno >= pPager->dbFileSize) != (pgno > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1225);
}
if( pgno>pPager->dbFileSize ){
        pPager->dbFileSize = pgno;
      }
      pPager->aStat[PAGER_STAT_WRITE]++;

      /* Update any backup objects copying the contents of this pager. */
      
// ABS Label 1214
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1214);
}

// ABS Label 1215
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1215);
}
sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);

      PAGERTRACE(("STORE %d page %d hash(%08x)\n",
                   PAGERID(pPager), pgno, pager_pagehash(pList)));
      IOTRACE(("PGOUT %p %d\n", pPager, pgno));
      PAGER_INCR(sqlite3_pager_writedb_count);
    }else{
      PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));
    }
    pager_set_pagehash(pList);
    pList = pList->pDirty;
  };
// ABS Label 1191
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}
// ABS Label 1192
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1192);
}

// COR Label 1193
if((rc == 0 || pList) != (rc == 0 && pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1193);
}

// ROR Label 1194
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1194);
}

// MCC Label 1195
if(rc == 0 && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1195);
}
// MCC Label 1196
if(rc == 0 && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1196);
}
// MCC Label 1197
if(!(rc == 0) && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1197);
}
// MCC Label 1198
if(!(rc == 0) && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1198);
}


  
// ABS Label 1226
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1226);
}
return rc;
}

/*
** Ensure that the sub-journal file is open. If it is already open, this 
** function is a no-op.
**
** SQLITE_OK is returned if everything goes according to plan. An 
** SQLITE_IOERR_XXX error code is returned if a call to sqlite3OsOpen() 
** fails.
*/
static int openSubJournal(Pager *pPager){
  int rc = SQLITE_OK;
  if( !isOpen(pPager->sjfd) ){
    
// AOR Label 1227
if(8192 | 2 | 4 | 16 & 8 != 8192 | 2 | 4 | 16 | 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1227);
}
// AOR Label 1228
if(8192 | 2 | 4 | 16 ^ 8 != 8192 | 2 | 4 | 16 | 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1228);
}
// AOR Label 1229
if(8192 | 2 | 4 & 16 != 8192 | 2 | 4 | 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1229);
}
// AOR Label 1230
if(8192 | 2 | 4 ^ 16 != 8192 | 2 | 4 | 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1230);
}
// AOR Label 1231
if(8192 | 2 & 4 != 8192 | 2 | 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1231);
}
// AOR Label 1232
if(8192 | 2 ^ 4 != 8192 | 2 | 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1232);
}
// AOR Label 1233
if(8192 & 2 != 8192 | 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1233);
}
// AOR Label 1234
if(8192 ^ 2 != 8192 | 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1234);
}
const int flags =  SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_READWRITE 
      | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE 
      | SQLITE_OPEN_DELETEONCLOSE;
    
// ABS Label 1235
if(sqlite3Config.nStmtSpill < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1235);
}
int nStmtSpill = sqlite3Config.nStmtSpill;
    
// COR Label 1236
if((pPager->journalMode == 4 && pPager->subjInMemory) != (pPager->journalMode == 4 || pPager->subjInMemory))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1236);
}

// ROR Label 1237
if((pPager->journalMode != 4) != (pPager->journalMode == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1237);
}

// MCC Label 1238
if(pPager->journalMode == 4 && pPager->subjInMemory ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1238);
}
// MCC Label 1239
if(pPager->journalMode == 4 && !(pPager->subjInMemory) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1239);
}
// MCC Label 1240
if(!(pPager->journalMode == 4) && pPager->subjInMemory ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1240);
}
// MCC Label 1241
if(!(pPager->journalMode == 4) && !(pPager->subjInMemory) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1241);
}
if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){
      nStmtSpill = -1;
    }
    rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);
  }
  
// ABS Label 1242
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1242);
}
return rc;
}

/*
** Append a record of the current state of page pPg to the sub-journal. 
**
** If successful, set the bit corresponding to pPg->pgno in the bitvecs
** for all open savepoints before returning.
**
** This function returns SQLITE_OK if everything is successful, an IO
** error code if the attempt to write to the sub-journal fails, or 
** SQLITE_NOMEM if a malloc fails while setting a bit in a savepoint
** bitvec.
*/
static int subjournalPage(PgHdr *pPg){
  int rc = SQLITE_OK;
  
// ABS Label 1243
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1243);
}
Pager *pPager = pPg->pPager;
  
// ROR Label 1244
if((pPager->journalMode == 2) != (pPager->journalMode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1244);
}
if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){

    /* Open the sub-journal, if it has not already been opened */
    assert( pPager->useJournal );
    assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );
    assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );
    assert( pagerUseWal(pPager) 
         || pageInJournal(pPager, pPg) 
         || pPg->pgno>pPager->dbOrigSize 
    );
    rc = openSubJournal(pPager);

    /* If the sub-journal was opened successfully (or was already open),
    ** write the journal record into the file.  */
    
// ABS Label 1245
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1245);
}

// ROR Label 1246
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1246);
}
if( rc==SQLITE_OK ){
      
// ABS Label 1247
if(pPg->pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1247);
}
void *pData = pPg->pData;
      
// AOR Label 1248
if((i64)pPager->nSubRec - (4 + pPager->pageSize) != (i64)pPager->nSubRec * (4 + pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1248);
}
// AOR Label 1249
if((i64)pPager->nSubRec + (4 + pPager->pageSize) != (i64)pPager->nSubRec * (4 + pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1249);
}
// AOR Label 1250
if((i64)pPager->nSubRec / (4 + pPager->pageSize) != (i64)pPager->nSubRec * (4 + pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1250);
}
i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);
      char *pData2;
      pData2 = pData;
      PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));
      rc = write32bits(pPager->sjfd, offset, pPg->pgno);
      
// ABS Label 1251
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1251);
}

// ROR Label 1252
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1252);
}
if( rc==SQLITE_OK ){
        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);
      }
    }
  }
  
// ABS Label 1253
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1253);
}

// ROR Label 1254
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1254);
}
if( rc==SQLITE_OK ){
    pPager->nSubRec++;
    assert( pPager->nSavepoint>0 );
    rc = addToSavepointBitvecs(pPager, pPg->pgno);
  }
  
// ABS Label 1255
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1255);
}
return rc;
}
static int subjournalPageIfRequired(PgHdr *pPg){
  if( subjRequiresPage(pPg) ){
    return subjournalPage(pPg);
  }else{
    return SQLITE_OK;
  }
}

/*
** This function is called by the pcache layer when it has reached some
** soft memory limit. The first argument is a pointer to a Pager object
** (cast as a void*). The pager is always 'purgeable' (not an in-memory
** database). The second argument is a reference to a page that is 
** currently dirty but has no outstanding references. The page
** is always associated with the Pager object passed as the first 
** argument.
**
** The job of this function is to make pPg clean by writing its contents
** out to the database file, if possible. This may involve syncing the
** journal file. 
**
** If successful, sqlite3PcacheMakeClean() is called on the page and
** SQLITE_OK returned. If an IO error occurs while trying to make the
** page clean, the IO error code is returned. If the page cannot be
** made clean for some other reason, but no error occurs, then SQLITE_OK
** is returned by sqlite3PcacheMakeClean() is not called.
*/
static int pagerStress(void *p, PgHdr *pPg){
  Pager *pPager = (Pager *)p;
  int rc = SQLITE_OK;

  assert( pPg->pPager==pPager );
  assert( pPg->flags&PGHDR_DIRTY );

  /* The doNotSpill NOSYNC bit is set during times when doing a sync of
  ** journal (and adding a new header) is not allowed.  This occurs
  ** during calls to sqlite3PagerWrite() while trying to journal multiple
  ** pages belonging to the same sector.
  **
  ** The doNotSpill ROLLBACK and OFF bits inhibits all cache spilling
  ** regardless of whether or not a sync is required.  This is set during
  ** a rollback or by user request, respectively.
  **
  ** Spilling is also prohibited when in an error state since that could
  ** lead to database corruption.   In the current implementation it 
  ** is impossible for sqlite3PcacheFetch() to be called with createFlag==3
  ** while in the error state, hence it is impossible for this routine to
  ** be called in the error state.  Nevertheless, we include a NEVER()
  ** test for the error state as a safeguard against future changes.
  */
  
// ABS Label 1256
if((pPager->errCode) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1256);
}
if( NEVER(pPager->errCode) ) { return SQLITE_OK;
}
  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );
  testcase( pPager->doNotSpill & SPILLFLAG_OFF );
  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );
  
// COR Label 1257
if((pPager->doNotSpill || ((pPager->doNotSpill & (2 | 1)) != 0 || (pPg->flags & 8) != 0)) != (pPager->doNotSpill && ((pPager->doNotSpill & (2 | 1)) != 0 || (pPg->flags & 8) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1257);
}

// MCC Label 1258
if(pPager->doNotSpill && ( (pPager->doNotSpill & (2 | 1)) != 0 && (pPg->flags & 8) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1258);
}
// MCC Label 1259
if(pPager->doNotSpill && ( (pPager->doNotSpill & (2 | 1)) != 0 && !((pPg->flags & 8) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1259);
}
// MCC Label 1260
if(pPager->doNotSpill && ( !((pPager->doNotSpill & (2 | 1)) != 0) && (pPg->flags & 8) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1260);
}
// MCC Label 1261
if(pPager->doNotSpill && ( !((pPager->doNotSpill & (2 | 1)) != 0) && !((pPg->flags & 8) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1261);
}
// MCC Label 1262
if(!(pPager->doNotSpill) && ( (pPager->doNotSpill & (2 | 1)) != 0 && (pPg->flags & 8) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1262);
}
// MCC Label 1263
if(!(pPager->doNotSpill) && ( (pPager->doNotSpill & (2 | 1)) != 0 && !((pPg->flags & 8) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1263);
}
// MCC Label 1264
if(!(pPager->doNotSpill) && ( !((pPager->doNotSpill & (2 | 1)) != 0) && (pPg->flags & 8) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1264);
}
// MCC Label 1265
if(!(pPager->doNotSpill) && ( !((pPager->doNotSpill & (2 | 1)) != 0) && !((pPg->flags & 8) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1265);
}
if( pPager->doNotSpill
   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0
      || (pPg->flags & PGHDR_NEED_SYNC)!=0)
  ){
    return SQLITE_OK;
  }

  pPager->aStat[PAGER_STAT_SPILL]++;
  pPg->pDirty = 0;
  
// MCC Label 1266
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1266);
}
// MCC Label 1267
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1267);
}
if( pagerUseWal(pPager) ){
    /* Write a single frame for this page to the log. */
    rc = subjournalPageIfRequired(pPg); 
    
// ABS Label 1268
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1268);
}

// ROR Label 1269
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1269);
}
if( rc==SQLITE_OK ){
      rc = pagerWalFrames(pPager, pPg, 0, 0);
    }
  }else{
    
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
    if( pPager->tempFile==0 ){
      rc = sqlite3JournalCreate(pPager->jfd);
      if( rc!=SQLITE_OK ) return pager_error(pPager, rc);
    }
#endif
  
    /* Sync the journal file if required. */
    
// AOR Label 1270
if(pPg->flags | 8 != pPg->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1270);
}
// AOR Label 1271
if(pPg->flags ^ 8 != pPg->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1271);
}

// COR Label 1272
if((pPg->flags & 8 && pPager->eState == 3) != (pPg->flags & 8 || pPager->eState == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1272);
}

// ROR Label 1273
if((pPager->eState != 3) != (pPager->eState == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1273);
}

// MCC Label 1274
if(pPg->flags & 8 && pPager->eState == 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1274);
}
// MCC Label 1275
if(pPg->flags & 8 && !(pPager->eState == 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1275);
}
// MCC Label 1276
if(!(pPg->flags & 8) && pPager->eState == 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1276);
}
// MCC Label 1277
if(!(pPg->flags & 8) && !(pPager->eState == 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1277);
}
if( pPg->flags&PGHDR_NEED_SYNC 
     || pPager->eState==PAGER_WRITER_CACHEMOD
    ){
      rc = syncJournal(pPager, 1);
    }
  
    /* Write the contents of the page out to the database file. */
    
// ABS Label 1278
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1278);
}

// ROR Label 1279
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1279);
}
if( rc==SQLITE_OK ){
      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );
      rc = pager_write_pagelist(pPager, pPg);
    }
  }

  /* Mark the page as clean. */
  
// ABS Label 1280
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1280);
}

// ROR Label 1281
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1281);
}
if( rc==SQLITE_OK ){
    PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));
    
// ABS Label 1282
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1282);
}
sqlite3PcacheMakeClean(pPg);
  }

  return pager_error(pPager, rc); 
}

/*
** Flush all unreferenced dirty pages to disk.
*/
int sqlite3PagerFlush(Pager *pPager){
  
// ABS Label 1283
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1283);
}
int rc = pPager->errCode;
  if( !MEMDB ){
    PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
    assert( assert_pager_state(pPager) );
    
// ABS Label 1284
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1284);
}
// ABS Label 1285
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1285);
}

// COR Label 1286
if((rc == 0 || pList) != (rc == 0 && pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1286);
}

// ROR Label 1287
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1287);
}

// MCC Label 1288
if(rc == 0 && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1288);
}
// MCC Label 1289
if(rc == 0 && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1289);
}
// MCC Label 1290
if(!(rc == 0) && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1290);
}
// MCC Label 1291
if(!(rc == 0) && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1291);
}
while( rc==SQLITE_OK && pList ){
      
// ABS Label 1300
if(pList->pDirty < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1300);
}
PgHdr *pNext = pList->pDirty;
      
// ROR Label 1301
if((pList->nRef != 0) != (pList->nRef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1301);
}
if( pList->nRef==0 ){
        rc = pagerStress((void*)pPager, pList);
      }
      pList = pNext;
    };
// ABS Label 1292
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1292);
}
// ABS Label 1293
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1293);
}

// COR Label 1294
if((rc == 0 || pList) != (rc == 0 && pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1294);
}

// ROR Label 1295
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1295);
}

// MCC Label 1296
if(rc == 0 && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1296);
}
// MCC Label 1297
if(rc == 0 && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1297);
}
// MCC Label 1298
if(!(rc == 0) && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1298);
}
// MCC Label 1299
if(!(rc == 0) && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1299);
}

  }

  
// ABS Label 1302
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1302);
}
return rc;
}

/*
** Allocate and initialize a new Pager object and put a pointer to it
** in *ppPager. The pager should eventually be freed by passing it
** to sqlite3PagerClose().
**
** The zFilename argument is the path to the database file to open.
** If zFilename is NULL then a randomly-named temporary file is created
** and used as the file to be cached. Temporary files are be deleted
** automatically when they are closed. If zFilename is ":memory:" then 
** all information is held in cache. It is never written to disk. 
** This can be used to implement an in-memory database.
**
** The nExtra parameter specifies the number of bytes of space allocated
** along with each page reference. This space is available to the user
** via the sqlite3PagerGetExtra() API.  When a new page is allocated, the
** first 8 bytes of this space are zeroed but the remainder is uninitialized.
** (The extra space is used by btree as the MemPage object.)
**
** The flags argument is used to specify properties that affect the
** operation of the pager. It should be passed some bitwise combination
** of the PAGER_* flags.
**
** The vfsFlags parameter is a bitmask to pass to the flags parameter
** of the xOpen() method of the supplied VFS when opening files. 
**
** If the pager object is allocated and the specified file opened 
** successfully, SQLITE_OK is returned and *ppPager set to point to
** the new pager object. If an error occurs, *ppPager is set to NULL
** and error code returned. This function may return SQLITE_NOMEM
** (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or 
** various SQLITE_IO_XXX errors.
*/
int sqlite3PagerOpen(
  sqlite3_vfs *pVfs,       /* The virtual file system to use */
  Pager **ppPager,         /* OUT: Return the Pager structure here */
  const char *zFilename,   /* Name of the database file to open */
  int nExtra,              /* Extra bytes append to each in-memory page */
  int flags,               /* flags controlling this file */
  int vfsFlags,            /* flags passed through to sqlite3_vfs.xOpen() */
  void (*xReinit)(DbPage*) /* Function to reinitialize pages */
){
  u8 *pPtr;
  Pager *pPager = 0;       /* Pager object to allocate and return */
  int rc = SQLITE_OK;      /* Return code */
  int tempFile = 0;        /* True for temp files (incl. in-memory files) */
  int memDb = 0;           /* True if this is an in-memory file */
#ifndef SQLITE_OMIT_DESERIALIZE
  int memJM = 0;           /* Memory journal mode */
#else
# define memJM 0
#endif
  int readOnly = 0;        /* True if this is a read-only file */
  int journalFileSize;     /* Bytes to allocate for each journal fd */
  char *zPathname = 0;     /* Full path to database file */
  int nPathname = 0;       /* Number of bytes in zPathname */
  
// ROR Label 1303
if(((flags & 1) != 0) != ((flags & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1303);
}
int useJournal = (flags & PAGER_OMIT_JOURNAL)==0; /* False to omit journal */
  int pcacheSize = sqlite3PcacheSize();       /* Bytes to allocate for PCache */
  u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */
  const char *zUri = 0;    /* URI args to copy */
  int nUriByte = 1;        /* Number of bytes of URI args at *zUri */
  int nUri = 0;            /* Number of URI parameters */

  /* Figure out how much space is required for each journal file-handle
  ** (there are two of them, the main journal and the sub-journal).  */
  journalFileSize = ROUND8(sqlite3JournalSize(pVfs));

  /* Set the output variable to NULL in case an error occurs. */
  *ppPager = 0;

#ifndef SQLITE_OMIT_MEMORYDB
  
// ABS Label 1306
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1306);
}

// AOR Label 1307
if(flags | 2 != flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1307);
}
// AOR Label 1308
if(flags ^ 2 != flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1308);
}
if( flags & PAGER_MEMORY ){
    memDb = 1;
    
// ABS Label 1309
if(zFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1309);
}

// COR Label 1310
if((zFilename || zFilename[0]) != (zFilename && zFilename[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1310);
}

// MCC Label 1311
if(zFilename && zFilename[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1311);
}
// MCC Label 1312
if(zFilename && !(zFilename[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1312);
}
// MCC Label 1313
if(!(zFilename) && zFilename[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1313);
}
// MCC Label 1314
if(!(zFilename) && !(zFilename[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1314);
}
if( zFilename && zFilename[0] ){
      zPathname = sqlite3DbStrDup(0, zFilename);
      
// ABS Label 1315
if(zPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1315);
}

// ROR Label 1316
if((zPathname != 0) != (zPathname == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1316);
}
if( zPathname==0  ) { return SQLITE_NOMEM_BKPT;
}
      nPathname = sqlite3Strlen30(zPathname);
      zFilename = 0;
    }
  }
#endif

  /* Compute and store the full pathname in an allocated buffer pointed
  ** to by zPathname, length nPathname. Or, if this is a temporary file,
  ** leave both nPathname and zPathname set to 0.
  */
  
// ABS Label 1317
if(zFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1317);
}

// COR Label 1318
if((zFilename || zFilename[0]) != (zFilename && zFilename[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1318);
}

// MCC Label 1319
if(zFilename && zFilename[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1319);
}
// MCC Label 1320
if(zFilename && !(zFilename[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1320);
}
// MCC Label 1321
if(!(zFilename) && zFilename[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1321);
}
// MCC Label 1322
if(!(zFilename) && !(zFilename[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1322);
}
if( zFilename && zFilename[0] ){
    const char *z;
    nPathname = pVfs->mxPathname+1;
    zPathname = sqlite3DbMallocRaw(0, nPathname*2);
    
// ABS Label 1323
if(zPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1323);
}

// ROR Label 1324
if((zPathname != 0) != (zPathname == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1324);
}
if( zPathname==0 ){
      return SQLITE_NOMEM_BKPT;
    }
    zPathname[0] = 0; /* Make sure initialized even if FullPathname() fails */
    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
    
// ABS Label 1325
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1325);
}

// ROR Label 1326
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1326);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 1327
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1327);
}

// ROR Label 1328
if((rc != (0 | (2 << 8))) != (rc == (0 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1328);
}
if( rc==SQLITE_OK_SYMLINK ){
        
// ABS Label 1329
if(vfsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1329);
}

// AOR Label 1330
if(vfsFlags | 16777216 != vfsFlags & 16777216)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1330);
}
// AOR Label 1331
if(vfsFlags ^ 16777216 != vfsFlags & 16777216)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1331);
}
if( vfsFlags & SQLITE_OPEN_NOFOLLOW ){
          rc = SQLITE_CANTOPEN_SYMLINK;
        }else{
          rc = SQLITE_OK;
        }
      }
    }
    nPathname = sqlite3Strlen30(zPathname);
    z = zUri = &zFilename[sqlite3Strlen30(zFilename)+1];
    
// ABS Label 1332
if(*z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1332);
}
while( *z ){
      z += strlen(z)+1;
      z += strlen(z)+1;
      nUri++;
    };
// ABS Label 1333
if(*z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1333);
}

    nUriByte = (int)(&z[1] - zUri);
    assert( nUriByte>=1 );
    
// ABS Label 1334
if(nPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1334);
}
// ABS Label 1335
if(pVfs->mxPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1335);
}
// ABS Label 1336
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1336);
}

// AOR Label 1337
if(nPathname - 8 != nPathname + 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1337);
}
// AOR Label 1338
if(nPathname / 8 != nPathname + 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1338);
}
// AOR Label 1339
if(nPathname * 8 != nPathname + 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1339);
}

// COR Label 1340
if((rc == 0 || nPathname + 8 > pVfs->mxPathname) != (rc == 0 && nPathname + 8 > pVfs->mxPathname))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1340);
}

// ROR Label 1341
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1341);
}
// ROR Label 1342
if((nPathname + 8 <= pVfs->mxPathname) != (nPathname + 8 > pVfs->mxPathname))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1342);
}
// ROR Label 1343
if((nPathname + 8 < pVfs->mxPathname) != (nPathname + 8 > pVfs->mxPathname))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1343);
}
// ROR Label 1344
if((nPathname + 8 >= pVfs->mxPathname) != (nPathname + 8 > pVfs->mxPathname))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1344);
}

// MCC Label 1345
if(rc == 0 && nPathname + 8 > pVfs->mxPathname ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1345);
}
// MCC Label 1346
if(rc == 0 && !(nPathname + 8 > pVfs->mxPathname) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1346);
}
// MCC Label 1347
if(!(rc == 0) && nPathname + 8 > pVfs->mxPathname ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1347);
}
// MCC Label 1348
if(!(rc == 0) && !(nPathname + 8 > pVfs->mxPathname) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1348);
}
if( rc==SQLITE_OK && nPathname+8>pVfs->mxPathname ){
      /* This branch is taken when the journal path required by
      ** the database being opened will be more than pVfs->mxPathname
      ** bytes in length. This means the database cannot be opened,
      ** as it will not be possible to open the journal file or even
      ** check for a hot-journal before reading.
      */
      rc = SQLITE_CANTOPEN_BKPT;
    }
    
// ABS Label 1349
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1349);
}

// ROR Label 1350
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1350);
}
if( rc!=SQLITE_OK ){
      sqlite3DbFree(0, zPathname);
      
// ABS Label 1351
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1351);
}
return rc;
    }
  }

  /* Allocate memory for the Pager structure, PCache object, the
  ** three file descriptors, the database file name and the journal 
  ** file name. The layout in memory is as follows:
  **
  **     Pager object                    (sizeof(Pager) bytes)
  **     PCache object                   (sqlite3PcacheSize() bytes)
  **     Database file handle            (pVfs->szOsFile bytes)
  **     Sub-journal file handle         (journalFileSize bytes)
  **     Main journal file handle        (journalFileSize bytes)
  **     Ptr back to the Pager           (sizeof(Pager*) bytes)
  **     \0\0\0\0 database prefix        (4 bytes)
  **     Database file name              (nPathname+1 bytes)
  **     URI query parameters            (nUriByte bytes)
  **     Journal filename                (nPathname+8+1 bytes)
  **     WAL filename                    (nPathname+4+1 bytes)
  **     \0\0\0 terminator               (3 bytes)
  **
  ** Some 3rd-party software, over which we have no control, depends on
  ** the specific order of the filenames and the \0 separators between them
  ** so that it can (for example) find the database filename given the WAL
  ** filename without using the sqlite3_filename_database() API.  This is a
  ** misuse of SQLite and a bug in the 3rd-party software, but the 3rd-party
  ** software is in widespread use, so we try to avoid changing the filename
  ** order and formatting if possible.  In particular, the details of the
  ** filename format expected by 3rd-party software should be as follows:
  **
  **   - Main Database Path
  **   - \0
  **   - Multiple URI components consisting of:
  **     - Key
  **     - \0
  **     - Value
  **     - \0
  **   - \0
  **   - Journal Path
  **   - \0
  **   - WAL Path (zWALName)
  **   - \0
  **
  ** The sqlite3_create_filename() interface and the databaseFilename() utility
  ** that is used by sqlite3_filename_database() and kin also depend on the
  ** specific formatting and order of the various filenames, so if the format
  ** changes here, be sure to change it there as well.
  */
  pPtr = (u8 *)sqlite3MallocZero(
    ROUND8(sizeof(*pPager)) +            /* Pager structure */
    ROUND8(pcacheSize) +                 /* PCache object */
    ROUND8(pVfs->szOsFile) +             /* The main db file */
    journalFileSize * 2 +                /* The two journal files */
    sizeof(pPager) +                     /* Space to hold a pointer */
    4 +                                  /* Database prefix */
    nPathname + 1 +                      /* database filename */
    nUriByte +                           /* query parameters */
    nPathname + 8 + 1 +                  /* Journal filename */
#ifndef SQLITE_OMIT_WAL
    nPathname + 4 + 1 +                  /* WAL filename */
#endif
    3                                    /* Terminator */
  );
  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) );
  if( !pPtr ){
    sqlite3DbFree(0, zPathname);
    return SQLITE_NOMEM_BKPT;
  }
  pPager = (Pager*)pPtr;                  pPtr += ROUND8(sizeof(*pPager));
  pPager->pPCache = (PCache*)pPtr;        pPtr += ROUND8(pcacheSize);
  pPager->fd = (sqlite3_file*)pPtr;       pPtr += ROUND8(pVfs->szOsFile);
  pPager->sjfd = (sqlite3_file*)pPtr;     pPtr += journalFileSize;
  pPager->jfd =  (sqlite3_file*)pPtr;     pPtr += journalFileSize;
  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );
  memcpy(pPtr, &pPager, sizeof(pPager));  pPtr += sizeof(pPager);

  /* Fill in the Pager.zFilename and pPager.zQueryParam fields */
                                          pPtr += 4;  /* Skip zero prefix */
  pPager->zFilename = (char*)pPtr;
  
// ABS Label 1352
if(nPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}

// ROR Label 1353
if((nPathname <= 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1353);
}
// ROR Label 1354
if((nPathname < 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1354);
}
// ROR Label 1355
if((nPathname >= 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1355);
}
if( nPathname>0 ){
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname + 1;
    
// ABS Label 1356
if(zUri < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1356);
}
if( zUri ){
      memcpy(pPtr, zUri, nUriByte);       pPtr += nUriByte;
    }else{
                                          pPtr++;
    }
  }


  /* Fill in Pager.zJournal */
  
// ABS Label 1357
if(nPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1357);
}

// ROR Label 1358
if((nPathname <= 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1358);
}
// ROR Label 1359
if((nPathname < 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1359);
}
// ROR Label 1360
if((nPathname >= 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1360);
}
if( nPathname>0 ){
    pPager->zJournal = (char*)pPtr;
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
    memcpy(pPtr, "-journal",8);           pPtr += 8 + 1;
#ifdef SQLITE_ENABLE_8_3_NAMES
    sqlite3FileSuffix3(zFilename,pPager->zJournal);
    pPtr = (u8*)(pPager->zJournal + sqlite3Strlen30(pPager->zJournal)+1);
#endif
  }else{
    pPager->zJournal = 0;
  }

#ifndef SQLITE_OMIT_WAL
  /* Fill in Pager.zWal */
  
// ABS Label 1361
if(nPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1361);
}

// ROR Label 1362
if((nPathname <= 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1362);
}
// ROR Label 1363
if((nPathname < 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1363);
}
// ROR Label 1364
if((nPathname >= 0) != (nPathname > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1364);
}
if( nPathname>0 ){
    pPager->zWal = (char*)pPtr;
    memcpy(pPtr, zPathname, nPathname);   pPtr += nPathname;
    memcpy(pPtr, "-wal", 4);              pPtr += 4 + 1;
#ifdef SQLITE_ENABLE_8_3_NAMES
    sqlite3FileSuffix3(zFilename, pPager->zWal);
    pPtr = (u8*)(pPager->zWal + sqlite3Strlen30(pPager->zWal)+1);
#endif
  }else{
    pPager->zWal = 0;
  }
#endif

  
// ABS Label 1365
if(nPathname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1365);
}
if( nPathname ) { sqlite3DbFree(0, zPathname);
}
  pPager->pVfs = pVfs;
  pPager->vfsFlags = vfsFlags;

  /* Open the pager file.
  */
  
// ABS Label 1366
if(zFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1366);
}

// COR Label 1367
if((zFilename || zFilename[0]) != (zFilename && zFilename[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1367);
}

// MCC Label 1368
if(zFilename && zFilename[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1368);
}
// MCC Label 1369
if(zFilename && !(zFilename[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1369);
}
// MCC Label 1370
if(!(zFilename) && zFilename[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1370);
}
// MCC Label 1371
if(!(zFilename) && !(zFilename[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1371);
}
if( zFilename && zFilename[0] ){
    int fout = 0;                    /* VFS flags returned by xOpen() */
    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
    assert( !memDb );
#ifndef SQLITE_OMIT_DESERIALIZE
    memJM = (fout&SQLITE_OPEN_MEMORY)!=0;
#endif
    readOnly = (fout&SQLITE_OPEN_READONLY)!=0;

    /* If the file was successfully opened for read/write access,
    ** choose a default page size in case we have to create the
    ** database file. The default page size is the maximum of:
    **
    **    + SQLITE_DEFAULT_PAGE_SIZE,
    **    + The value returned by sqlite3OsSectorSize()
    **    + The largest page size that can be written atomically.
    */
    
// ABS Label 1372
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1372);
}

// ROR Label 1373
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1373);
}
if( rc==SQLITE_OK ){
      int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      if( !readOnly ){
        
// ABS Label 1374
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1374);
}
setSectorSize(pPager);
        assert(SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE);
        
// ABS Label 1375
if(pPager->sectorSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1375);
}
// ABS Label 1376
if(szPageDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1376);
}

// ROR Label 1377
if((szPageDflt <= pPager->sectorSize) != (szPageDflt < pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1377);
}
// ROR Label 1378
if((szPageDflt > pPager->sectorSize) != (szPageDflt < pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1378);
}
// ROR Label 1379
if((szPageDflt >= pPager->sectorSize) != (szPageDflt < pPager->sectorSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1379);
}
if( szPageDflt<pPager->sectorSize ){
          
// ABS Label 1380
if(pPager->sectorSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1380);
}

// ROR Label 1381
if((pPager->sectorSize <= 8192) != (pPager->sectorSize > 8192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1381);
}
// ROR Label 1382
if((pPager->sectorSize < 8192) != (pPager->sectorSize > 8192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1382);
}
// ROR Label 1383
if((pPager->sectorSize >= 8192) != (pPager->sectorSize > 8192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1383);
}
if( pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE ){
            szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;
          }else{
            szPageDflt = (u32)pPager->sectorSize;
          }
        }
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
        {
          int ii;
          assert(SQLITE_IOCAP_ATOMIC512==(512>>8));
          assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));
          assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);
          for(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){
            if( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ){
              szPageDflt = ii;
            }
          }
        }
#endif
      }
      pPager->noLock = sqlite3_uri_boolean(pPager->zFilename, "nolock", 0);
      if( (iDc & SQLITE_IOCAP_IMMUTABLE)!=0
       || sqlite3_uri_boolean(pPager->zFilename, "immutable", 0) ){
          vfsFlags |= SQLITE_OPEN_READONLY;
          goto act_like_temp_file;
      }
    }
  }else{
    /* If a temporary file is requested, it is not opened immediately.
    ** In this case we accept the default page size and delay actually
    ** opening the file until the first call to OsWrite().
    **
    ** This branch is also run for an in-memory database. An in-memory
    ** database is the same as a temp-file that is never written out to
    ** disk and uses an in-memory rollback journal.
    **
    ** This branch also runs for files marked as immutable.
    */ 
act_like_temp_file:
    tempFile = 1;
    pPager->eState = PAGER_READER;     /* Pretend we already have a lock */
    pPager->eLock = EXCLUSIVE_LOCK;    /* Pretend we are in EXCLUSIVE mode */
    pPager->noLock = 1;                /* Do no locking */
    readOnly = (vfsFlags&SQLITE_OPEN_READONLY);
  }

  /* The following call to PagerSetPagesize() serves to set the value of 
  ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.
  */
  
// ABS Label 1384
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1384);
}

// ROR Label 1385
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1385);
}
if( rc==SQLITE_OK ){
    assert( pPager->memDb==0 );
    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);
    testcase( rc!=SQLITE_OK );
  }

  /* Initialize the PCache object. */
  
// ABS Label 1386
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1386);
}

// ROR Label 1387
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1387);
}
if( rc==SQLITE_OK ){
    nExtra = ROUND8(nExtra);
    assert( nExtra>=8 && nExtra<1000 );
    rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,
                       !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);
  }

  /* If an error occurred above, free the  Pager structure and close the file.
  */
  
// ABS Label 1388
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1388);
}

// ROR Label 1389
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1389);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 1390
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1390);
}
sqlite3OsClose(pPager->fd);
    sqlite3PageFree(pPager->pTmpSpace);
    sqlite3_free(pPager);
    
// ABS Label 1391
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1391);
}
return rc;
  }

  PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));
  IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename))

  pPager->useJournal = (u8)useJournal;
  /* pPager->stmtOpen = 0; */
  /* pPager->stmtInUse = 0; */
  /* pPager->nRef = 0; */
  /* pPager->stmtSize = 0; */
  /* pPager->stmtJSize = 0; */
  /* pPager->nPage = 0; */
  pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;
  /* pPager->state = PAGER_UNLOCK; */
  /* pPager->errMask = 0; */
  pPager->tempFile = (u8)tempFile;
  assert( tempFile==PAGER_LOCKINGMODE_NORMAL 
          || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE );
  assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );
  pPager->exclusiveMode = (u8)tempFile; 
  pPager->changeCountDone = pPager->tempFile;
  pPager->memDb = (u8)memDb;
  pPager->readOnly = (u8)readOnly;
  assert( useJournal || pPager->tempFile );
  pPager->noSync = pPager->tempFile;
  
// ABS Label 1392
if(pPager->noSync < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1392);
}
if( pPager->noSync ){
    assert( pPager->fullSync==0 );
    assert( pPager->extraSync==0 );
    assert( pPager->syncFlags==0 );
    assert( pPager->walSyncFlags==0 );
  }else{
    pPager->fullSync = 1;
    pPager->extraSync = 0;
    pPager->syncFlags = SQLITE_SYNC_NORMAL;
    pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);
  }
  /* pPager->pFirst = 0; */
  /* pPager->pFirstSynced = 0; */
  /* pPager->pLast = 0; */
  pPager->nExtra = (u16)nExtra;
  pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;
  assert( isOpen(pPager->fd) || tempFile );
  
// ABS Label 1304
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1304);
}
setSectorSize(pPager);
  if( !useJournal ){
    pPager->journalMode = PAGER_JOURNALMODE_OFF;
  }else { 
// ABS Label 1393
if(memDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1393);
}
// ABS Label 1394
if(memJM < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1394);
}

// COR Label 1395
if((memDb && memJM) != (memDb || memJM))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1395);
}

// MCC Label 1396
if(memDb && memJM ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1396);
}
// MCC Label 1397
if(memDb && !(memJM) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1397);
}
// MCC Label 1398
if(!(memDb) && memJM ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1398);
}
// MCC Label 1399
if(!(memDb) && !(memJM) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1399);
}
if( memDb || memJM ){
    pPager->journalMode = PAGER_JOURNALMODE_MEMORY;
  };}

  /* pPager->xBusyHandler = 0; */
  /* pPager->pBusyHandlerArg = 0; */
  pPager->xReiniter = xReinit;
  
// ABS Label 1305
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1305);
}
setGetterMethod(pPager);
  /* memset(pPager->aHash, 0, sizeof(pPager->aHash)); */
  /* pPager->szMmap = SQLITE_DEFAULT_MMAP_SIZE // will be set by btree.c */

  *ppPager = pPager;
  return SQLITE_OK;
}

/*
** Return the sqlite3_file for the main database given the name
** of the corresonding WAL or Journal name as passed into
** xOpen.
*/
sqlite3_file *sqlite3_database_file_object(const char *zName){
  Pager *pPager;
  
// COR Label 1400
if((zName[-1] != 0 || zName[-2] != 0 || zName[-3] != 0 && zName[-4] != 0) != (zName[-1] != 0 || zName[-2] != 0 || zName[-3] != 0 || zName[-4] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1400);
}
// COR Label 1401
if((zName[-1] != 0 || zName[-2] != 0 && zName[-3] != 0) != (zName[-1] != 0 || zName[-2] != 0 || zName[-3] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1401);
}
// COR Label 1402
if((zName[-1] != 0 && zName[-2] != 0) != (zName[-1] != 0 || zName[-2] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1402);
}

// ROR Label 1403
if((zName[-1] == 0) != (zName[-1] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1403);
}
// ROR Label 1404
if((zName[-2] == 0) != (zName[-2] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1404);
}
// ROR Label 1405
if((zName[-3] == 0) != (zName[-3] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1405);
}
// ROR Label 1406
if((zName[-4] == 0) != (zName[-4] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1406);
}

// MCC Label 1407
if(zName[-1] != 0 && zName[-2] != 0 && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1407);
}
// MCC Label 1408
if(zName[-1] != 0 && zName[-2] != 0 && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1408);
}
// MCC Label 1409
if(zName[-1] != 0 && zName[-2] != 0 && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1409);
}
// MCC Label 1410
if(zName[-1] != 0 && zName[-2] != 0 && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1410);
}
// MCC Label 1411
if(zName[-1] != 0 && !(zName[-2] != 0) && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1411);
}
// MCC Label 1412
if(zName[-1] != 0 && !(zName[-2] != 0) && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1412);
}
// MCC Label 1413
if(zName[-1] != 0 && !(zName[-2] != 0) && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1413);
}
// MCC Label 1414
if(zName[-1] != 0 && !(zName[-2] != 0) && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1414);
}
// MCC Label 1415
if(!(zName[-1] != 0) && zName[-2] != 0 && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1415);
}
// MCC Label 1416
if(!(zName[-1] != 0) && zName[-2] != 0 && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1416);
}
// MCC Label 1417
if(!(zName[-1] != 0) && zName[-2] != 0 && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1417);
}
// MCC Label 1418
if(!(zName[-1] != 0) && zName[-2] != 0 && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1418);
}
// MCC Label 1419
if(!(zName[-1] != 0) && !(zName[-2] != 0) && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1419);
}
// MCC Label 1420
if(!(zName[-1] != 0) && !(zName[-2] != 0) && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1420);
}
// MCC Label 1421
if(!(zName[-1] != 0) && !(zName[-2] != 0) && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1421);
}
// MCC Label 1422
if(!(zName[-1] != 0) && !(zName[-2] != 0) && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1422);
}
while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){
    zName--;
  };
// COR Label 1423
if((zName[-1] != 0 || zName[-2] != 0 || zName[-3] != 0 && zName[-4] != 0) != (zName[-1] != 0 || zName[-2] != 0 || zName[-3] != 0 || zName[-4] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1423);
}
// COR Label 1424
if((zName[-1] != 0 || zName[-2] != 0 && zName[-3] != 0) != (zName[-1] != 0 || zName[-2] != 0 || zName[-3] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1424);
}
// COR Label 1425
if((zName[-1] != 0 && zName[-2] != 0) != (zName[-1] != 0 || zName[-2] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1425);
}

// ROR Label 1426
if((zName[-1] == 0) != (zName[-1] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1426);
}
// ROR Label 1427
if((zName[-2] == 0) != (zName[-2] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1427);
}
// ROR Label 1428
if((zName[-3] == 0) != (zName[-3] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1428);
}
// ROR Label 1429
if((zName[-4] == 0) != (zName[-4] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1429);
}

// MCC Label 1430
if(zName[-1] != 0 && zName[-2] != 0 && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1430);
}
// MCC Label 1431
if(zName[-1] != 0 && zName[-2] != 0 && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1431);
}
// MCC Label 1432
if(zName[-1] != 0 && zName[-2] != 0 && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1432);
}
// MCC Label 1433
if(zName[-1] != 0 && zName[-2] != 0 && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1433);
}
// MCC Label 1434
if(zName[-1] != 0 && !(zName[-2] != 0) && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1434);
}
// MCC Label 1435
if(zName[-1] != 0 && !(zName[-2] != 0) && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1435);
}
// MCC Label 1436
if(zName[-1] != 0 && !(zName[-2] != 0) && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1436);
}
// MCC Label 1437
if(zName[-1] != 0 && !(zName[-2] != 0) && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1437);
}
// MCC Label 1438
if(!(zName[-1] != 0) && zName[-2] != 0 && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1438);
}
// MCC Label 1439
if(!(zName[-1] != 0) && zName[-2] != 0 && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1439);
}
// MCC Label 1440
if(!(zName[-1] != 0) && zName[-2] != 0 && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1440);
}
// MCC Label 1441
if(!(zName[-1] != 0) && zName[-2] != 0 && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1441);
}
// MCC Label 1442
if(!(zName[-1] != 0) && !(zName[-2] != 0) && zName[-3] != 0 && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1442);
}
// MCC Label 1443
if(!(zName[-1] != 0) && !(zName[-2] != 0) && zName[-3] != 0 && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1443);
}
// MCC Label 1444
if(!(zName[-1] != 0) && !(zName[-2] != 0) && !(zName[-3] != 0) && zName[-4] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1444);
}
// MCC Label 1445
if(!(zName[-1] != 0) && !(zName[-2] != 0) && !(zName[-3] != 0) && !(zName[-4] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1445);
}

  pPager = *(Pager**)(zName - 4 - sizeof(Pager*));
  
// ABS Label 1446
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1446);
}
return pPager->fd;
}


/*
** This function is called after transitioning from PAGER_UNLOCK to
** PAGER_SHARED state. It tests if there is a hot journal present in
** the file-system for the given pager. A hot journal is one that 
** needs to be played back. According to this function, a hot-journal
** file exists if the following criteria are met:
**
**   * The journal file exists in the file system, and
**   * No process holds a RESERVED or greater lock on the database file, and
**   * The database file itself is greater than 0 bytes in size, and
**   * The first byte of the journal file exists and is not 0x00.
**
** If the current size of the database file is 0 but a journal file
** exists, that is probably an old journal left over from a prior
** database with the same name. In this case the journal file is
** just deleted using OsDelete, *pExists is set to 0 and SQLITE_OK
** is returned.
**
** This routine does not check if there is a super-journal filename
** at the end of the file. If there is, and that super-journal file
** does not exist, then the journal file is not really hot. In this
** case this routine will return a false-positive. The pager_playback()
** routine will discover that the journal file is not really hot and 
** will not roll it back. 
**
** If a hot-journal file is found to exist, *pExists is set to 1 and 
** SQLITE_OK returned. If no hot-journal file is present, *pExists is
** set to 0 and SQLITE_OK returned. If an IO error occurs while trying
** to determine whether or not a hot-journal file exists, the IO error
** code is returned and the value of *pExists is undefined.
*/
static int hasHotJournal(Pager *pPager, int *pExists){
  
// ABS Label 1447
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1447);
}
sqlite3_vfs * const pVfs = pPager->pVfs;
  int rc = SQLITE_OK;           /* Return code */
  int exists = 1;               /* True if a journal file is present */
  int jrnlOpen = !!isOpen(pPager->jfd);

  assert( pPager->useJournal );
  assert( isOpen(pPager->fd) );
  assert( pPager->eState==PAGER_OPEN );

  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &
    SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
  ));

  *pExists = 0;
  if( !jrnlOpen ){
    rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);
  }
  
// ABS Label 1448
if(exists < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1448);
}
// ABS Label 1449
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1449);
}

// COR Label 1450
if((rc == 0 || exists) != (rc == 0 && exists))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1450);
}

// ROR Label 1451
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1451);
}

// MCC Label 1452
if(rc == 0 && exists ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1452);
}
// MCC Label 1453
if(rc == 0 && !(exists) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1453);
}
// MCC Label 1454
if(!(rc == 0) && exists ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1454);
}
// MCC Label 1455
if(!(rc == 0) && !(exists) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1455);
}
if( rc==SQLITE_OK && exists ){
    int locked = 0;             /* True if some process holds a RESERVED lock */

    /* Race condition here:  Another process might have been holding the
    ** the RESERVED lock and have a journal open at the sqlite3OsAccess() 
    ** call above, but then delete the journal and drop the lock before
    ** we get to the following sqlite3OsCheckReservedLock() call.  If that
    ** is the case, this routine might think there is a hot journal when
    ** in fact there is none.  This results in a false-positive which will
    ** be dealt with by the playback routine.  Ticket #3883.
    */
    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
    
// ABS Label 1456
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1456);
}

// COR Label 1457
if((rc == 0 || !locked) != (rc == 0 && !locked))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1457);
}

// ROR Label 1458
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1458);
}

// MCC Label 1459
if(rc == 0 && !locked ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1459);
}
// MCC Label 1460
if(rc == 0 && !(!locked) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1460);
}
// MCC Label 1461
if(!(rc == 0) && !locked ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1461);
}
// MCC Label 1462
if(!(rc == 0) && !(!locked) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1462);
}
if( rc==SQLITE_OK && !locked ){
      Pgno nPage;                 /* Number of pages in database file */

      assert( pPager->tempFile==0 );
      rc = pagerPagecount(pPager, &nPage);
      
// ABS Label 1463
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1463);
}

// ROR Label 1464
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1464);
}
if( rc==SQLITE_OK ){
        /* If the database is zero pages in size, that means that either (1) the
        ** journal is a remnant from a prior database with the same name where
        ** the database file but not the journal was deleted, or (2) the initial
        ** transaction that populates a new database is being rolled back.
        ** In either case, the journal file can be deleted.  However, take care
        ** not to delete the journal file if it is already open due to
        ** journal_mode=PERSIST.
        */
        
// ABS Label 1465
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1465);
}

// COR Label 1466
if((nPage == 0 || !jrnlOpen) != (nPage == 0 && !jrnlOpen))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1466);
}

// ROR Label 1467
if((nPage != 0) != (nPage == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1467);
}

// MCC Label 1468
if(nPage == 0 && !jrnlOpen ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1468);
}
// MCC Label 1469
if(nPage == 0 && !(!jrnlOpen) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1469);
}
// MCC Label 1470
if(!(nPage == 0) && !jrnlOpen ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1470);
}
// MCC Label 1471
if(!(nPage == 0) && !(!jrnlOpen) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1471);
}
if( nPage==0 && !jrnlOpen ){
          sqlite3BeginBenignMalloc();
          if( pagerLockDb(pPager, RESERVED_LOCK)==SQLITE_OK ){
            
// ABS Label 1472
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1472);
}
sqlite3OsDelete(pVfs, pPager->zJournal, 0);
            if( !pPager->exclusiveMode ) { 
// ABS Label 1473
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1473);
}
pagerUnlockDb(pPager, SHARED_LOCK);
}
          }
          sqlite3EndBenignMalloc();
        }else{
          /* The journal file exists and no other connection has a reserved
          ** or greater lock on the database file. Now check that there is
          ** at least one non-zero bytes at the start of the journal file.
          ** If there is, then we consider this journal to be hot. If not, 
          ** it can be ignored.
          */
          if( !jrnlOpen ){
            
// AOR Label 1474
if(1 & 2048 != 1 | 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1474);
}
// AOR Label 1475
if(1 ^ 2048 != 1 | 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1475);
}
int f = SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL;
            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);
          }
          
// ABS Label 1476
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1476);
}

// ROR Label 1477
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1477);
}
if( rc==SQLITE_OK ){
            u8 first = 0;
            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);
            
// ABS Label 1478
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1478);
}

// ROR Label 1479
if((rc != (10 | (2 << 8))) != (rc == (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1479);
}
if( rc==SQLITE_IOERR_SHORT_READ ){
              rc = SQLITE_OK;
            }
            if( !jrnlOpen ){
              
// ABS Label 1480
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1480);
}
sqlite3OsClose(pPager->jfd);
            }
            *pExists = (first!=0);
          }else { 
// ABS Label 1481
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1481);
}

// ROR Label 1482
if((rc != 14) != (rc == 14))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1482);
}
if( rc==SQLITE_CANTOPEN ){
            /* If we cannot open the rollback journal file in order to see if
            ** it has a zero header, that might be due to an I/O error, or
            ** it might be due to the race condition described above and in
            ** ticket #3883.  Either way, assume that the journal is hot.
            ** This might be a false positive.  But if it is, then the
            ** automatic journal playback and recovery mechanism will deal
            ** with it under an EXCLUSIVE lock where we do not need to
            ** worry so much with race conditions.
            */
            *pExists = 1;
            rc = SQLITE_OK;
          };}

        }
      }
    }
  }

  
// ABS Label 1483
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1483);
}
return rc;
}

/*
** This function is called to obtain a shared lock on the database file.
** It is illegal to call sqlite3PagerGet() until after this function
** has been successfully called. If a shared-lock is already held when
** this function is called, it is a no-op.
**
** The following operations are also performed by this function.
**
**   1) If the pager is currently in PAGER_OPEN state (no lock held
**      on the database file), then an attempt is made to obtain a
**      SHARED lock on the database file. Immediately after obtaining
**      the SHARED lock, the file-system is checked for a hot-journal,
**      which is played back if present. Following any hot-journal 
**      rollback, the contents of the cache are validated by checking
**      the 'change-counter' field of the database file header and
**      discarded if they are found to be invalid.
**
**   2) If the pager is running in exclusive-mode, and there are currently
**      no outstanding references to any pages, and is in the error state,
**      then an attempt is made to clear the error state by discarding
**      the contents of the page cache and rolling back any open journal
**      file.
**
** If everything is successful, SQLITE_OK is returned. If an IO error 
** occurs while locking the database, checking for a hot-journal file or 
** rolling back a journal file, the IO error code is returned.
*/
int sqlite3PagerSharedLock(Pager *pPager){
  int rc = SQLITE_OK;                /* Return code */

  /* This routine is only called from b-tree and only when there are no
  ** outstanding pages. This implies that the pager state should either
  ** be OPEN or READER. READER is only possible if the pager is or was in 
  ** exclusive access mode.  */
  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );
  assert( assert_pager_state(pPager) );
  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );
  assert( pPager->errCode==SQLITE_OK );

  
// COR Label 1484
if((!((pPager)->pWal != 0) || pPager->eState == 0) != (!((pPager)->pWal != 0) && pPager->eState == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1484);
}

// ROR Label 1485
if((pPager->eState != 0) != (pPager->eState == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1485);
}

// MCC Label 1486
if(!((pPager)->pWal != 0) && pPager->eState == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1486);
}
// MCC Label 1487
if(!((pPager)->pWal != 0) && !(pPager->eState == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1487);
}
// MCC Label 1488
if(!(!((pPager)->pWal != 0)) && pPager->eState == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1488);
}
// MCC Label 1489
if(!(!((pPager)->pWal != 0)) && !(pPager->eState == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1489);
}
if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){
    int bHotJournal = 1;          /* True if there exists a hot journal-file */

    assert( !MEMDB );
    assert( pPager->tempFile==0 || pPager->eLock==EXCLUSIVE_LOCK );

    rc = pager_wait_on_lock(pPager, SHARED_LOCK);
    
// ABS Label 1490
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1490);
}

// ROR Label 1491
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1491);
}
if( rc!=SQLITE_OK ){
      assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );
      goto failed;
    }

    /* If a journal file exists, and there is no RESERVED lock on the
    ** database file, then it either needs to be played back or deleted.
    */
    
// ROR Label 1492
if((pPager->eLock < 1) != (pPager->eLock <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1492);
}
// ROR Label 1493
if((pPager->eLock > 1) != (pPager->eLock <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1493);
}
// ROR Label 1494
if((pPager->eLock >= 1) != (pPager->eLock <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1494);
}
if( pPager->eLock<=SHARED_LOCK ){
      rc = hasHotJournal(pPager, &bHotJournal);
    }
    
// ABS Label 1495
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1495);
}

// ROR Label 1496
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1496);
}
if( rc!=SQLITE_OK ){
      goto failed;
    }
    
// ABS Label 1497
if(bHotJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1497);
}
if( bHotJournal ){
      
// ABS Label 1498
if(pPager->readOnly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1498);
}
if( pPager->readOnly ){
        rc = SQLITE_READONLY_ROLLBACK;
        goto failed;
      }

      /* Get an EXCLUSIVE lock on the database file. At this point it is
      ** important that a RESERVED lock is not obtained on the way to the
      ** EXCLUSIVE lock. If it were, another process might open the
      ** database file, detect the RESERVED lock, and conclude that the
      ** database is safe to read while this process is still rolling the 
      ** hot-journal back.
      ** 
      ** Because the intermediate RESERVED lock is not requested, any
      ** other process attempting to access the database file will get to 
      ** this point in the code and fail to obtain its own EXCLUSIVE lock 
      ** on the database file.
      **
      ** Unless the pager is in locking_mode=exclusive mode, the lock is
      ** downgraded to SHARED_LOCK before this function returns.
      */
      rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
      
// ABS Label 1499
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1499);
}

// ROR Label 1500
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1500);
}
if( rc!=SQLITE_OK ){
        goto failed;
      }
 
      /* If it is not already open and the file exists on disk, open the 
      ** journal for read/write access. Write access is required because 
      ** in exclusive-access mode the file descriptor will be kept open 
      ** and possibly used for a transaction later on. Also, write-access 
      ** is usually required to finalize the journal in journal_mode=persist 
      ** mode (and also for journal_mode=truncate on some systems).
      **
      ** If the journal does not exist, it usually means that some 
      ** other connection managed to get in and roll it back before 
      ** this connection obtained the exclusive lock above. Or, it 
      ** may mean that the pager was in the error-state when this
      ** function was called and the journal file does not exist.
      */
      if( !isOpen(pPager->jfd) ){
        
// ABS Label 1501
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1501);
}
sqlite3_vfs * const pVfs = pPager->pVfs;
        int bExists;              /* True if journal file exists */
        rc = sqlite3OsAccess(
            pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);
        
// ABS Label 1502
if(bExists < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1502);
}
// ABS Label 1503
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1503);
}

// COR Label 1504
if((rc == 0 || bExists) != (rc == 0 && bExists))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1504);
}

// ROR Label 1505
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1505);
}

// MCC Label 1506
if(rc == 0 && bExists ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1506);
}
// MCC Label 1507
if(rc == 0 && !(bExists) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1507);
}
// MCC Label 1508
if(!(rc == 0) && bExists ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1508);
}
// MCC Label 1509
if(!(rc == 0) && !(bExists) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1509);
}
if( rc==SQLITE_OK && bExists ){
          int fout = 0;
          
// AOR Label 1510
if(2 & 2048 != 2 | 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1510);
}
// AOR Label 1511
if(2 ^ 2048 != 2 | 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1511);
}
int f = SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_JOURNAL;
          assert( !pPager->tempFile );
          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);
          assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );
          
// ABS Label 1512
if(fout < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1512);
}
// ABS Label 1513
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1513);
}

// AOR Label 1514
if(fout | 1 != fout & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1514);
}
// AOR Label 1515
if(fout ^ 1 != fout & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1515);
}

// COR Label 1516
if((rc == 0 || fout & 1) != (rc == 0 && fout & 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1516);
}

// ROR Label 1517
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1517);
}

// MCC Label 1518
if(rc == 0 && fout & 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1518);
}
// MCC Label 1519
if(rc == 0 && !(fout & 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1519);
}
// MCC Label 1520
if(!(rc == 0) && fout & 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1520);
}
// MCC Label 1521
if(!(rc == 0) && !(fout & 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1521);
}
if( rc==SQLITE_OK && fout&SQLITE_OPEN_READONLY ){
            rc = SQLITE_CANTOPEN_BKPT;
            
// ABS Label 1522
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1522);
}
sqlite3OsClose(pPager->jfd);
          }
        }
      }
 
      /* Playback and delete the journal.  Drop the database write
      ** lock and reacquire the read lock. Purge the cache before
      ** playing back the hot-journal so that we don't end up with
      ** an inconsistent cache.  Sync the hot journal before playing
      ** it back since the process that crashed and left the hot journal
      ** probably did not sync it and we are required to always sync
      ** the journal before playing it back.
      */
      
// MCC Label 1523
if(( (pPager->jfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1523);
}
// MCC Label 1524
if(( !((pPager->jfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1524);
}
if( isOpen(pPager->jfd) ){
        assert( rc==SQLITE_OK );
        rc = pagerSyncHotJournal(pPager);
        
// ABS Label 1525
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1525);
}

// ROR Label 1526
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1526);
}
if( rc==SQLITE_OK ){
          rc = pager_playback(pPager, !pPager->tempFile);
          pPager->eState = PAGER_OPEN;
        }
      }else { if( !pPager->exclusiveMode ){
        
// ABS Label 1527
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1527);
}
pagerUnlockDb(pPager, SHARED_LOCK);
      };}


      
// ABS Label 1528
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1528);
}

// ROR Label 1529
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1529);
}
if( rc!=SQLITE_OK ){
        /* This branch is taken if an error occurs while trying to open
        ** or roll back a hot-journal while holding an EXCLUSIVE lock. The
        ** pager_unlock() routine will be called before returning to unlock
        ** the file. If the unlock attempt fails, then Pager.eLock must be
        ** set to UNKNOWN_LOCK (see the comment above the #define for 
        ** UNKNOWN_LOCK above for an explanation). 
        **
        ** In order to get pager_unlock() to do this, set Pager.eState to
        ** PAGER_ERROR now. This is not actually counted as a transition
        ** to ERROR state in the state diagram at the top of this file,
        ** since we know that the same call to pager_unlock() will very
        ** shortly transition the pager object to the OPEN state. Calling
        ** assert_pager_state() would fail now, as it should not be possible
        ** to be in ERROR state when there are zero outstanding page 
        ** references.
        */
        
// ABS Label 1530
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1530);
}

// ABS Label 1531
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1531);
}
pager_error(pPager, rc);
        goto failed;
      }

      assert( pPager->eState==PAGER_OPEN );
      assert( (pPager->eLock==SHARED_LOCK)
           || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)
      );
    }

    
// COR Label 1532
if((!pPager->tempFile || pPager->hasHeldSharedLock) != (!pPager->tempFile && pPager->hasHeldSharedLock))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1532);
}

// MCC Label 1533
if(!pPager->tempFile && pPager->hasHeldSharedLock ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1533);
}
// MCC Label 1534
if(!pPager->tempFile && !(pPager->hasHeldSharedLock) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1534);
}
// MCC Label 1535
if(!(!pPager->tempFile) && pPager->hasHeldSharedLock ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1535);
}
// MCC Label 1536
if(!(!pPager->tempFile) && !(pPager->hasHeldSharedLock) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1536);
}
if( !pPager->tempFile && pPager->hasHeldSharedLock ){
      /* The shared-lock has just been acquired then check to
      ** see if the database has been modified.  If the database has changed,
      ** flush the cache.  The hasHeldSharedLock flag prevents this from
      ** occurring on the very first access to a file, in order to save a
      ** single unnecessary sqlite3OsRead() call at the start-up.
      **
      ** Database changes are detected by looking at 15 bytes beginning
      ** at offset 24 into the file.  The first 4 of these 16 bytes are
      ** a 32-bit counter that is incremented with each change.  The
      ** other bytes change randomly with each file change when
      ** a codec is in use.
      ** 
      ** There is a vanishingly small chance that a change will not be 
      ** detected.  The chance of an undetected change is so small that
      ** it can be neglected.
      */
      char dbFileVers[sizeof(pPager->dbFileVers)];

      IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));
      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
      
// ABS Label 1537
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1537);
}

// ROR Label 1538
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1538);
}
if( rc!=SQLITE_OK ){
        
// ABS Label 1539
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1539);
}

// ROR Label 1540
if((rc == (10 | (2 << 8))) != (rc != (10 | (2 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1540);
}
if( rc!=SQLITE_IOERR_SHORT_READ ){
          goto failed;
        }
        memset(dbFileVers, 0, sizeof(dbFileVers));
      }

      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){
        
// ABS Label 1541
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1541);
}
pager_reset(pPager);

        /* Unmap the database file. It is possible that external processes
        ** may have truncated the database file and then extended it back
        ** to its original size while this process was not holding a lock.
        ** In this case there may exist a Pager.pMap mapping that appears
        ** to be the right size but is not actually valid. Avoid this
        ** possibility by unmapping the db here. */
        
// ABS Label 1542
if(((pPager)->bUseFetch) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1542);
}
if( USEFETCH(pPager) ){
          
// ABS Label 1543
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1543);
}
sqlite3OsUnfetch(pPager->fd, 0, 0);
        }
      }
    }

    /* If there is a WAL file in the file-system, open this database in WAL
    ** mode. Otherwise, the following function call is a no-op.
    */
    rc = pagerOpenWalIfPresent(pPager);
#ifndef SQLITE_OMIT_WAL
    assert( pPager->pWal==0 || rc==SQLITE_OK );
#endif
  }

  
// MCC Label 1544
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1544);
}
// MCC Label 1545
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1545);
}
if( pagerUseWal(pPager) ){
    assert( rc==SQLITE_OK );
    rc = pagerBeginReadTransaction(pPager);
  }

  
// ABS Label 1546
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1546);
}

// COR Label 1547
if((pPager->tempFile == 0 && pPager->eState == 0 || rc == 0) != (pPager->tempFile == 0 && pPager->eState == 0 && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1547);
}
// COR Label 1548
if((pPager->tempFile == 0 || pPager->eState == 0) != (pPager->tempFile == 0 && pPager->eState == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1548);
}

// ROR Label 1549
if((pPager->tempFile != 0) != (pPager->tempFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1549);
}
// ROR Label 1550
if((pPager->eState != 0) != (pPager->eState == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1550);
}
// ROR Label 1551
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1551);
}

// MCC Label 1552
if(pPager->tempFile == 0 && pPager->eState == 0 && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1552);
}
// MCC Label 1553
if(pPager->tempFile == 0 && pPager->eState == 0 && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1553);
}
// MCC Label 1554
if(pPager->tempFile == 0 && !(pPager->eState == 0) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1554);
}
// MCC Label 1555
if(pPager->tempFile == 0 && !(pPager->eState == 0) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1555);
}
// MCC Label 1556
if(!(pPager->tempFile == 0) && pPager->eState == 0 && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1556);
}
// MCC Label 1557
if(!(pPager->tempFile == 0) && pPager->eState == 0 && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1557);
}
// MCC Label 1558
if(!(pPager->tempFile == 0) && !(pPager->eState == 0) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1558);
}
// MCC Label 1559
if(!(pPager->tempFile == 0) && !(pPager->eState == 0) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1559);
}
if( pPager->tempFile==0 && pPager->eState==PAGER_OPEN && rc==SQLITE_OK ){
    rc = pagerPagecount(pPager, &pPager->dbSize);
  }

 failed:
  
// ABS Label 1560
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1560);
}

// ROR Label 1561
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1561);
}
if( rc!=SQLITE_OK ){
    assert( !MEMDB );
    
// ABS Label 1562
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1562);
}
pager_unlock(pPager);
    assert( pPager->eState==PAGER_OPEN );
  }else{
    pPager->eState = PAGER_READER;
    pPager->hasHeldSharedLock = 1;
  }
  
// ABS Label 1563
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1563);
}
return rc;
}

/*
** If the reference count has reached zero, rollback any active
** transaction and unlock the pager.
**
** Except, in locking_mode=EXCLUSIVE when there is nothing to in
** the rollback journal, the unlock is not performed and there is
** nothing to rollback, so this routine is a no-op.
*/ 
static void pagerUnlockIfUnused(Pager *pPager){
  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){
    assert( pPager->nMmapOut==0 ); /* because page1 is never memory mapped */
    
// ABS Label 1564
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1564);
}
pagerUnlockAndRollback(pPager);
  }
}

/*
** The page getter methods each try to acquire a reference to a
** page with page number pgno. If the requested reference is 
** successfully obtained, it is copied to *ppPage and SQLITE_OK returned.
**
** There are different implementations of the getter method depending
** on the current state of the pager.
**
**     getPageNormal()         --  The normal getter
**     getPageError()          --  Used if the pager is in an error state
**     getPageMmap()           --  Used if memory-mapped I/O is enabled
**
** If the requested page is already in the cache, it is returned. 
** Otherwise, a new page object is allocated and populated with data
** read from the database file. In some cases, the pcache module may
** choose not to allocate a new page object and may reuse an existing
** object with no outstanding references.
**
** The extra data appended to a page is always initialized to zeros the 
** first time a page is loaded into memory. If the page requested is 
** already in the cache when this function is called, then the extra
** data is left as it was when the page object was last used.
**
** If the database image is smaller than the requested page or if 
** the flags parameter contains the PAGER_GET_NOCONTENT bit and the 
** requested page is not already stored in the cache, then no 
** actual disk read occurs. In this case the memory image of the 
** page is initialized to all zeros. 
**
** If PAGER_GET_NOCONTENT is true, it means that we do not care about
** the contents of the page. This occurs in two scenarios:
**
**   a) When reading a free-list leaf page from the database, and
**
**   b) When a savepoint is being rolled back and we need to load
**      a new page into the cache to be filled with the data read
**      from the savepoint journal.
**
** If PAGER_GET_NOCONTENT is true, then the data returned is zeroed instead
** of being read from the database. Additionally, the bits corresponding
** to pgno in Pager.pInJournal (bitvec of pages already written to the
** journal file) and the PagerSavepoint.pInSavepoint bitvecs of any open
** savepoints are set. This means if the page is made writable at any
** point in the future, using a call to sqlite3PagerWrite(), its contents
** will not be journaled. This saves IO.
**
** The acquisition might fail for several reasons.  In all cases,
** an appropriate error code is returned and *ppPage is set to NULL.
**
** See also sqlite3PagerLookup().  Both this routine and Lookup() attempt
** to find a page in the in-memory cache first.  If the page is not already
** in memory, this routine goes to disk to read it in whereas Lookup()
** just returns 0.  This routine acquires a read-lock the first time it
** has to go to disk, and could also playback an old journal if necessary.
** Since Lookup() never goes to disk, it never has to deal with locks
** or journal files.
*/
static int getPageNormal(
  Pager *pPager,      /* The pager open on the database file */
  Pgno pgno,          /* Page number to fetch */
  DbPage **ppPage,    /* Write a pointer to the page here */
  int flags           /* PAGER_GET_XXX flags */
){
  int rc = SQLITE_OK;
  PgHdr *pPg;
  u8 noContent;                   /* True if PAGER_GET_NOCONTENT is set */
  sqlite3_pcache_page *pBase;

  assert( pPager->errCode==SQLITE_OK );
  assert( pPager->eState>=PAGER_READER );
  assert( assert_pager_state(pPager) );
  assert( pPager->hasHeldSharedLock==1 );

  
// ABS Label 1566
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1566);
}

// ROR Label 1567
if((pgno != 0) != (pgno == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1567);
}
if( pgno==0 ) { return SQLITE_CORRUPT_BKPT;
}
  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);
  
// ABS Label 1568
if(pBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1568);
}

// ROR Label 1569
if((pBase != 0) != (pBase == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1569);
}
if( pBase==0 ){
    pPg = 0;
    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);
    
// ABS Label 1570
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1570);
}

// ROR Label 1571
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1571);
}
if( rc!=SQLITE_OK ) { goto pager_acquire_err;
}
    
// ABS Label 1572
if(pBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1572);
}

// ROR Label 1573
if((pBase != 0) != (pBase == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1573);
}
if( pBase==0 ){
      rc = SQLITE_NOMEM_BKPT;
      goto pager_acquire_err;
    }
  }
  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);
  assert( pPg==(*ppPage) );
  assert( pPg->pgno==pgno );
  assert( pPg->pPager==pPager || pPg->pPager==0 );

  noContent = (flags & PAGER_GET_NOCONTENT)!=0;
  
// ABS Label 1574
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1574);
}

// COR Label 1575
if((pPg->pPager || !noContent) != (pPg->pPager && !noContent))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1575);
}

// MCC Label 1576
if(pPg->pPager && !noContent ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1576);
}
// MCC Label 1577
if(pPg->pPager && !(!noContent) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1577);
}
// MCC Label 1578
if(!(pPg->pPager) && !noContent ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1578);
}
// MCC Label 1579
if(!(pPg->pPager) && !(!noContent) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1579);
}
if( pPg->pPager && !noContent ){
    /* In this case the pcache already contains an initialized copy of
    ** the page. Return without further ado.  */
    assert( pgno!=PAGER_MJ_PGNO(pPager) );
    pPager->aStat[PAGER_STAT_HIT]++;
    return SQLITE_OK;

  }else{
    /* The pager cache has created a new page. Its content needs to 
    ** be initialized. But first some error checks:
    **
    ** (*) obsolete.  Was: maximum page number is 2^31
    ** (2) Never try to fetch the locking page
    */
    
// ABS Label 1580
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1580);
}

// ROR Label 1581
if((pgno != ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != (pgno == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1581);
}
if( pgno==PAGER_MJ_PGNO(pPager) ){
      rc = SQLITE_CORRUPT_BKPT;
      goto pager_acquire_err;
    }

    pPg->pPager = pPager;

    assert( !isOpen(pPager->fd) || !MEMDB );
    
// ABS Label 1582
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1582);
}
// ABS Label 1583
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1583);
}

// COR Label 1584
if((!((pPager->fd)->pMethods != 0) || pPager->dbSize < pgno && noContent) != (!((pPager->fd)->pMethods != 0) || pPager->dbSize < pgno || noContent))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1584);
}
// COR Label 1585
if((!((pPager->fd)->pMethods != 0) && pPager->dbSize < pgno) != (!((pPager->fd)->pMethods != 0) || pPager->dbSize < pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1585);
}

// ROR Label 1586
if((pPager->dbSize <= pgno) != (pPager->dbSize < pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1586);
}
// ROR Label 1587
if((pPager->dbSize > pgno) != (pPager->dbSize < pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1587);
}
// ROR Label 1588
if((pPager->dbSize >= pgno) != (pPager->dbSize < pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1588);
}

// MCC Label 1589
if(!((pPager->fd)->pMethods != 0) && pPager->dbSize < pgno && noContent ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1589);
}
// MCC Label 1590
if(!((pPager->fd)->pMethods != 0) && pPager->dbSize < pgno && !(noContent) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1590);
}
// MCC Label 1591
if(!((pPager->fd)->pMethods != 0) && !(pPager->dbSize < pgno) && noContent ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1591);
}
// MCC Label 1592
if(!((pPager->fd)->pMethods != 0) && !(pPager->dbSize < pgno) && !(noContent) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1592);
}
// MCC Label 1593
if(!(!((pPager->fd)->pMethods != 0)) && pPager->dbSize < pgno && noContent ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1593);
}
// MCC Label 1594
if(!(!((pPager->fd)->pMethods != 0)) && pPager->dbSize < pgno && !(noContent) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1594);
}
// MCC Label 1595
if(!(!((pPager->fd)->pMethods != 0)) && !(pPager->dbSize < pgno) && noContent ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1595);
}
// MCC Label 1596
if(!(!((pPager->fd)->pMethods != 0)) && !(pPager->dbSize < pgno) && !(noContent) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1596);
}
if( !isOpen(pPager->fd) || pPager->dbSize<pgno || noContent ){
      
// ABS Label 1598
if(pPager->mxPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1598);
}
// ABS Label 1599
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1599);
}

// ROR Label 1600
if((pgno <= pPager->mxPgno) != (pgno > pPager->mxPgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1600);
}
// ROR Label 1601
if((pgno < pPager->mxPgno) != (pgno > pPager->mxPgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1601);
}
// ROR Label 1602
if((pgno >= pPager->mxPgno) != (pgno > pPager->mxPgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1602);
}
if( pgno>pPager->mxPgno ){
        rc = SQLITE_FULL;
        goto pager_acquire_err;
      }
      
// ABS Label 1603
if(noContent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1603);
}
if( noContent ){
        /* Failure to set the bits in the InJournal bit-vectors is benign.
        ** It merely means that we might do some extra work to journal a 
        ** page that does not need to be journaled.  Nevertheless, be sure 
        ** to test the case where a malloc error occurs while trying to set 
        ** a bit in a bit vector.
        */
        sqlite3BeginBenignMalloc();
        
// ABS Label 1606
if(pPager->dbOrigSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1606);
}
// ABS Label 1607
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1607);
}

// ROR Label 1608
if((pgno < pPager->dbOrigSize) != (pgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1608);
}
// ROR Label 1609
if((pgno > pPager->dbOrigSize) != (pgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1609);
}
// ROR Label 1610
if((pgno >= pPager->dbOrigSize) != (pgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1610);
}
if( pgno<=pPager->dbOrigSize ){
          TESTONLY( rc = ) 
// ABS Label 1611
if(pPager->pInJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1611);
}

// ABS Label 1612
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1612);
}
sqlite3BitvecSet(pPager->pInJournal, pgno);
          testcase( rc==SQLITE_NOMEM );
        }
        TESTONLY( rc = ) 
// ABS Label 1604
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1604);
}

// ABS Label 1605
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1605);
}
addToSavepointBitvecs(pPager, pgno);
        testcase( rc==SQLITE_NOMEM );
        sqlite3EndBenignMalloc();
      }
      
// ABS Label 1597
if(pPg->pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1597);
}
memset(pPg->pData, 0, pPager->pageSize);
      IOTRACE(("ZERO %p %d\n", pPager, pgno));
    }else{
      assert( pPg->pPager==pPager );
      pPager->aStat[PAGER_STAT_MISS]++;
      rc = readDbPage(pPg);
      
// ABS Label 1613
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1613);
}

// ROR Label 1614
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1614);
}
if( rc!=SQLITE_OK ){
        goto pager_acquire_err;
      }
    }
    pager_set_pagehash(pPg);
  }
  return SQLITE_OK;

pager_acquire_err:
  assert( rc!=SQLITE_OK );
  
// ABS Label 1615
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1615);
}
if( pPg ){
    
// ABS Label 1616
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1616);
}
sqlite3PcacheDrop(pPg);
  }
  
// ABS Label 1565
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1565);
}
pagerUnlockIfUnused(pPager);
  *ppPage = 0;
  
// ABS Label 1617
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1617);
}
return rc;
}

#if SQLITE_MAX_MMAP_SIZE>0
/* The page getter for when memory-mapped I/O is enabled */
static int getPageMMap(
  Pager *pPager,      /* The pager open on the database file */
  Pgno pgno,          /* Page number to fetch */
  DbPage **ppPage,    /* Write a pointer to the page here */
  int flags           /* PAGER_GET_XXX flags */
){
  int rc = SQLITE_OK;
  PgHdr *pPg = 0;
  u32 iFrame = 0;                 /* Frame to read from WAL file */

  /* It is acceptable to use a read-only (mmap) page for any page except
  ** page 1 if there is no write-transaction open or the ACQUIRE_READONLY
  ** flag was specified by the caller. And so long as the db is not a 
  ** temporary or in-memory database.  */
  const int bMmapOk = (pgno>1
   && (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))
  );

  assert( USEFETCH(pPager) );

  /* Optimization note:  Adding the "pgno<=1" term before "pgno==0" here
  ** allows the compiler optimizer to reuse the results of the "pgno>1"
  ** test in the previous statement, and avoid testing pgno==0 in the
  ** common case where pgno is large. */
  
// ABS Label 1618
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1618);
}

// COR Label 1619
if((pgno <= 1 || pgno == 0) != (pgno <= 1 && pgno == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1619);
}

// ROR Label 1620
if((pgno < 1) != (pgno <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1620);
}
// ROR Label 1621
if((pgno > 1) != (pgno <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1621);
}
// ROR Label 1622
if((pgno >= 1) != (pgno <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1622);
}
// ROR Label 1623
if((pgno != 0) != (pgno == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1623);
}

// MCC Label 1624
if(pgno <= 1 && pgno == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1624);
}
// MCC Label 1625
if(pgno <= 1 && !(pgno == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1625);
}
// MCC Label 1626
if(!(pgno <= 1) && pgno == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1626);
}
// MCC Label 1627
if(!(pgno <= 1) && !(pgno == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1627);
}
if( pgno<=1 && pgno==0 ){
    return SQLITE_CORRUPT_BKPT;
  }
  assert( pPager->eState>=PAGER_READER );
  assert( assert_pager_state(pPager) );
  assert( pPager->hasHeldSharedLock==1 );
  assert( pPager->errCode==SQLITE_OK );

  
// ABS Label 1628
if(bMmapOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1628);
}

// COR Label 1629
if((bMmapOk || ((pPager)->pWal != 0)) != (bMmapOk && ((pPager)->pWal != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1629);
}

// MCC Label 1630
if(bMmapOk && ( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1630);
}
// MCC Label 1631
if(bMmapOk && ( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1631);
}
// MCC Label 1632
if(!(bMmapOk) && ( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1632);
}
// MCC Label 1633
if(!(bMmapOk) && ( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1633);
}
if( bMmapOk && pagerUseWal(pPager) ){
    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);
    
// ABS Label 1634
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1634);
}

// ROR Label 1635
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1635);
}
if( rc!=SQLITE_OK ){
      *ppPage = 0;
      
// ABS Label 1636
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1636);
}
return rc;
    }
  }
  
// ABS Label 1637
if(bMmapOk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1637);
}
// ABS Label 1638
if(iFrame < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1638);
}

// COR Label 1639
if((bMmapOk || iFrame == 0) != (bMmapOk && iFrame == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1639);
}

// ROR Label 1640
if((iFrame != 0) != (iFrame == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1640);
}

// MCC Label 1641
if(bMmapOk && iFrame == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1641);
}
// MCC Label 1642
if(bMmapOk && !(iFrame == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1642);
}
// MCC Label 1643
if(!(bMmapOk) && iFrame == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1643);
}
// MCC Label 1644
if(!(bMmapOk) && !(iFrame == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1644);
}
if( bMmapOk && iFrame==0 ){
    void *pData = 0;
    rc = sqlite3OsFetch(pPager->fd, 
        (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData
    );
    
// ABS Label 1645
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1645);
}
// ABS Label 1646
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1646);
}

// COR Label 1647
if((rc == 0 || pData) != (rc == 0 && pData))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1647);
}

// ROR Label 1648
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1648);
}

// MCC Label 1649
if(rc == 0 && pData ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1649);
}
// MCC Label 1650
if(rc == 0 && !(pData) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1650);
}
// MCC Label 1651
if(!(rc == 0) && pData ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1651);
}
// MCC Label 1652
if(!(rc == 0) && !(pData) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1652);
}
if( rc==SQLITE_OK && pData ){
      
// COR Label 1653
if((pPager->eState > 1 && pPager->tempFile) != (pPager->eState > 1 || pPager->tempFile))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1653);
}

// ROR Label 1654
if((pPager->eState <= 1) != (pPager->eState > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1654);
}
// ROR Label 1655
if((pPager->eState < 1) != (pPager->eState > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1655);
}
// ROR Label 1656
if((pPager->eState >= 1) != (pPager->eState > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1656);
}

// MCC Label 1657
if(pPager->eState > 1 && pPager->tempFile ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1657);
}
// MCC Label 1658
if(pPager->eState > 1 && !(pPager->tempFile) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1658);
}
// MCC Label 1659
if(!(pPager->eState > 1) && pPager->tempFile ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1659);
}
// MCC Label 1660
if(!(pPager->eState > 1) && !(pPager->tempFile) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1660);
}
if( pPager->eState>PAGER_READER || pPager->tempFile ){
        pPg = sqlite3PagerLookup(pPager, pgno);
      }
      
// ABS Label 1661
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1661);
}

// ROR Label 1662
if((pPg != 0) != (pPg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1662);
}
if( pPg==0 ){
        rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);
      }else{
        
// ABS Label 1663
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1663);
}

// AOR Label 1664
if((i64)(pgno - 1) - pPager->pageSize != (i64)(pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1664);
}
// AOR Label 1665
if((i64)(pgno - 1) + pPager->pageSize != (i64)(pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1665);
}
// AOR Label 1666
if((i64)(pgno - 1) / pPager->pageSize != (i64)(pgno - 1) * pPager->pageSize)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1666);
}

// ABS Label 1667
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1667);
}
sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);
      }
      
// ABS Label 1668
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1668);
}
if( pPg ){
        assert( rc==SQLITE_OK );
        *ppPage = pPg;
        return SQLITE_OK;
      }
    }
    
// ABS Label 1669
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1669);
}

// ROR Label 1670
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1670);
}
if( rc!=SQLITE_OK ){
      *ppPage = 0;
      
// ABS Label 1671
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1671);
}
return rc;
    }
  }
  return getPageNormal(pPager, pgno, ppPage, flags);
}
#endif /* SQLITE_MAX_MMAP_SIZE>0 */

/* The page getter method for when the pager is an error state */
static int getPageError(
  Pager *pPager,      /* The pager open on the database file */
  Pgno pgno,          /* Page number to fetch */
  DbPage **ppPage,    /* Write a pointer to the page here */
  int flags           /* PAGER_GET_XXX flags */
){
  UNUSED_PARAMETER(pgno);
  UNUSED_PARAMETER(flags);
  assert( pPager->errCode!=SQLITE_OK );
  *ppPage = 0;
  
// ABS Label 1672
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1672);
}
return pPager->errCode;
}


/* Dispatch all page fetch requests to the appropriate getter method.
*/
int sqlite3PagerGet(
  Pager *pPager,      /* The pager open on the database file */
  Pgno pgno,          /* Page number to fetch */
  DbPage **ppPage,    /* Write a pointer to the page here */
  int flags           /* PAGER_GET_XXX flags */
){
  return pPager->xGet(pPager, pgno, ppPage, flags);
}

/*
** Acquire a page if it is already in the in-memory cache.  Do
** not read the page from disk.  Return a pointer to the page,
** or 0 if the page is not in cache. 
**
** See also sqlite3PagerGet().  The difference between this routine
** and sqlite3PagerGet() is that _get() will go to the disk and read
** in the page if the page is not already in cache.  This routine
** returns NULL if the page is not in cache or if a disk I/O error 
** has ever happened.
*/
DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
  sqlite3_pcache_page *pPage;
  assert( pPager!=0 );
  assert( pgno!=0 );
  assert( pPager->pPCache!=0 );
  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
  assert( pPage==0 || pPager->hasHeldSharedLock );
  
// ABS Label 1673
if(pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1673);
}

// ROR Label 1674
if((pPage != 0) != (pPage == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1674);
}
if( pPage==0 ) { return 0;
}
  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
}

/*
** Release a page reference.
**
** The sqlite3PagerUnref() and sqlite3PagerUnrefNotNull() may only be
** used if we know that the page being released is not the last page.
** The btree layer always holds page1 open until the end, so these first
** to routines can be used to release any page other than BtShared.pPage1.
**
** Use sqlite3PagerUnrefPageOne() to release page1.  This latter routine
** checks the total number of outstanding pages and if the number of
** pages reaches zero it drops the database lock.
*/
void sqlite3PagerUnrefNotNull(DbPage *pPg){
  TESTONLY( Pager *pPager = pPg->pPager; )
  assert( pPg!=0 );
  
// AOR Label 1675
if(pPg->flags | 32 != pPg->flags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1675);
}
// AOR Label 1676
if(pPg->flags ^ 32 != pPg->flags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1676);
}
if( pPg->flags & PGHDR_MMAP ){
    assert( pPg->pgno!=1 );  /* Page1 is never memory mapped */
    
// ABS Label 1677
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1677);
}
pagerReleaseMapPage(pPg);
  }else{
    
// ABS Label 1678
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1678);
}
sqlite3PcacheRelease(pPg);
  }
  /* Do not use this routine to release the last reference to page1 */
  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );
}
void sqlite3PagerUnref(DbPage *pPg){
  
// ABS Label 1679
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1679);
}
if( pPg ) { 
// ABS Label 1680
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1680);
}
sqlite3PagerUnrefNotNull(pPg);
}
}
void sqlite3PagerUnrefPageOne(DbPage *pPg){
  Pager *pPager;
  assert( pPg!=0 );
  assert( pPg->pgno==1 );
  assert( (pPg->flags & PGHDR_MMAP)==0 ); /* Page1 is never memory mapped */
  pPager = pPg->pPager;
  
// ABS Label 1681
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1681);
}
sqlite3PcacheRelease(pPg);
  
// ABS Label 1682
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1682);
}
pagerUnlockIfUnused(pPager);
}

/*
** This function is called at the start of every write transaction.
** There must already be a RESERVED or EXCLUSIVE lock on the database 
** file when this routine is called.
**
** Open the journal file for pager pPager and write a journal header
** to the start of it. If there are active savepoints, open the sub-journal
** as well. This function is only used when the journal file is being 
** opened to write a rollback log for a transaction. It is not used 
** when opening a hot journal file to roll it back.
**
** If the journal file is already open (as it may be in exclusive mode),
** then this function just writes a journal header to the start of the
** already open file. 
**
** Whether or not the journal file is opened by this function, the
** Pager.pInJournal bitvec structure is allocated.
**
** Return SQLITE_OK if everything is successful. Otherwise, return 
** SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or 
** an IO error code if opening or writing the journal file fails.
*/
static int pager_open_journal(Pager *pPager){
  int rc = SQLITE_OK;                        /* Return code */
  
// ABS Label 1683
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1683);
}
sqlite3_vfs * const pVfs = pPager->pVfs;   /* Local cache of vfs pointer */

  assert( pPager->eState==PAGER_WRITER_LOCKED );
  assert( assert_pager_state(pPager) );
  assert( pPager->pInJournal==0 );
  
  /* If already in the error state, this function is a no-op.  But on
  ** the other hand, this routine is never called if we are already in
  ** an error state. */
  
// ABS Label 1684
if((pPager->errCode) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1684);
}
if( NEVER(pPager->errCode) ) { 
// ABS Label 1685
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1685);
}
return pPager->errCode;
}

  
// COR Label 1686
if((!((pPager)->pWal != 0) || pPager->journalMode != 2) != (!((pPager)->pWal != 0) && pPager->journalMode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1686);
}

// ROR Label 1687
if((pPager->journalMode == 2) != (pPager->journalMode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1687);
}

// MCC Label 1688
if(!((pPager)->pWal != 0) && pPager->journalMode != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1688);
}
// MCC Label 1689
if(!((pPager)->pWal != 0) && !(pPager->journalMode != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1689);
}
// MCC Label 1690
if(!(!((pPager)->pWal != 0)) && pPager->journalMode != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1690);
}
// MCC Label 1691
if(!(!((pPager)->pWal != 0)) && !(pPager->journalMode != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1691);
}
if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){
    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
    
// ABS Label 1692
if(pPager->pInJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1692);
}

// ROR Label 1693
if((pPager->pInJournal != 0) != (pPager->pInJournal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1693);
}
if( pPager->pInJournal==0 ){
      return SQLITE_NOMEM_BKPT;
    }
  
    /* Open the journal file if it is not already open. */
    if( !isOpen(pPager->jfd) ){
      
// ROR Label 1694
if((pPager->journalMode != 4) != (pPager->journalMode == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1694);
}
if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){
        
// ABS Label 1695
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1695);
}
sqlite3MemJournalOpen(pPager->jfd);
      }else{
        
// AOR Label 1696
if(2 & 4 != 2 | 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1696);
}
// AOR Label 1697
if(2 ^ 4 != 2 | 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1697);
}
int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;
        int nSpill;

        
// ABS Label 1698
if(pPager->tempFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1698);
}
if( pPager->tempFile ){
          flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL);
          nSpill = sqlite3Config.nStmtSpill;
        }else{
          flags |= SQLITE_OPEN_MAIN_JOURNAL;
          nSpill = jrnlBufferSize(pPager);
        }
          
        /* Verify that the database still has the same name as it did when
        ** it was originally opened. */
        rc = databaseIsUnmoved(pPager);
        
// ABS Label 1699
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1699);
}

// ROR Label 1700
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1700);
}
if( rc==SQLITE_OK ){
          rc = sqlite3JournalOpen (
              pVfs, pPager->zJournal, pPager->jfd, flags, nSpill
          );
        }
      }
      assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );
    }
  
  
    /* Write the first journal header to the journal file and open 
    ** the sub-journal if necessary.
    */
    
// ABS Label 1701
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1701);
}

// ROR Label 1702
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1702);
}
if( rc==SQLITE_OK ){
      /* TODO: Check if all of these are really required. */
      pPager->nRec = 0;
      pPager->journalOff = 0;
      pPager->setSuper = 0;
      pPager->journalHdr = 0;
      rc = writeJournalHdr(pPager);
    }
  }

  
// ABS Label 1703
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1703);
}

// ROR Label 1704
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1704);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 1705
if(pPager->pInJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1705);
}
sqlite3BitvecDestroy(pPager->pInJournal);
    pPager->pInJournal = 0;
  }else{
    assert( pPager->eState==PAGER_WRITER_LOCKED );
    pPager->eState = PAGER_WRITER_CACHEMOD;
  }

  
// ABS Label 1706
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1706);
}
return rc;
}

/*
** Begin a write-transaction on the specified pager object. If a 
** write-transaction has already been opened, this function is a no-op.
**
** If the exFlag argument is false, then acquire at least a RESERVED
** lock on the database file. If exFlag is true, then acquire at least
** an EXCLUSIVE lock. If such a lock is already held, no locking 
** functions need be called.
**
** If the subjInMemory argument is non-zero, then any sub-journal opened
** within this transaction will be opened as an in-memory file. This
** has no effect if the sub-journal is already opened (as it may be when
** running in exclusive mode) or if the transaction does not require a
** sub-journal. If the subjInMemory argument is zero, then any required
** sub-journal is implemented in-memory if pPager is an in-memory database, 
** or using a temporary file otherwise.
*/
int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){
  int rc = SQLITE_OK;

  
// ABS Label 1707
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1707);
}
if( pPager->errCode ) { 
// ABS Label 1708
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1708);
}
return pPager->errCode;
}
  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );
  pPager->subjInMemory = (u8)subjInMemory;

  
// ROR Label 1709
if((pPager->eState != 1) != (pPager->eState == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1709);
}
if( pPager->eState==PAGER_READER ){
    assert( pPager->pInJournal==0 );

    
// MCC Label 1710
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1710);
}
// MCC Label 1711
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1711);
}
if( pagerUseWal(pPager) ){
      /* If the pager is configured to use locking_mode=exclusive, and an
      ** exclusive lock on the database is not already held, obtain it now.
      */
      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){
        rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
        
// ABS Label 1712
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1712);
}

// ROR Label 1713
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1713);
}
if( rc!=SQLITE_OK ){
          
// ABS Label 1714
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1714);
}
return rc;
        }
        (void)sqlite3WalExclusiveMode(pPager->pWal, 1);
      }

      /* Grab the write lock on the log file. If successful, upgrade to
      ** PAGER_RESERVED state. Otherwise, return an error code to the caller.
      ** The busy-handler is not invoked if another connection already
      ** holds the write-lock. If possible, the upper layer will call it.
      */
      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
    }else{
      /* Obtain a RESERVED lock on the database file. If the exFlag parameter
      ** is true, then immediately upgrade this to an EXCLUSIVE lock. The
      ** busy-handler callback can be used when upgrading to the EXCLUSIVE
      ** lock, but not when obtaining the RESERVED lock.
      */
      rc = pagerLockDb(pPager, RESERVED_LOCK);
      
// ABS Label 1715
if(exFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1715);
}
// ABS Label 1716
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1716);
}

// COR Label 1717
if((rc == 0 || exFlag) != (rc == 0 && exFlag))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1717);
}

// ROR Label 1718
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1718);
}

// MCC Label 1719
if(rc == 0 && exFlag ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1719);
}
// MCC Label 1720
if(rc == 0 && !(exFlag) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1720);
}
// MCC Label 1721
if(!(rc == 0) && exFlag ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1721);
}
// MCC Label 1722
if(!(rc == 0) && !(exFlag) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1722);
}
if( rc==SQLITE_OK && exFlag ){
        rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
      }
    }

    
// ABS Label 1723
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1723);
}

// ROR Label 1724
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1724);
}
if( rc==SQLITE_OK ){
      /* Change to WRITER_LOCKED state.
      **
      ** WAL mode sets Pager.eState to PAGER_WRITER_LOCKED or CACHEMOD
      ** when it has an open transaction, but never to DBMOD or FINISHED.
      ** This is because in those states the code to roll back savepoint 
      ** transactions may copy data from the sub-journal into the database 
      ** file as well as into the page cache. Which would be incorrect in 
      ** WAL mode.
      */
      pPager->eState = PAGER_WRITER_LOCKED;
      pPager->dbHintSize = pPager->dbSize;
      pPager->dbFileSize = pPager->dbSize;
      pPager->dbOrigSize = pPager->dbSize;
      pPager->journalOff = 0;
    }

    assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );
    assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );
    assert( assert_pager_state(pPager) );
  }

  PAGERTRACE(("TRANSACTION %d\n", PAGERID(pPager)));
  
// ABS Label 1725
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1725);
}
return rc;
}

/*
** Write page pPg onto the end of the rollback journal.
*/
static SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){
  
// ABS Label 1726
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1726);
}
Pager *pPager = pPg->pPager;
  int rc;
  u32 cksum;
  char *pData2;
  
// ABS Label 1727
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1727);
}
i64 iOff = pPager->journalOff;

  /* We should never write to the journal file the page that
  ** contains the database locks.  The following assert verifies
  ** that we do not. */
  assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) );

  assert( pPager->journalHdr<=pPager->journalOff );
  pData2 = pPg->pData;
  cksum = pager_cksum(pPager, (u8*)pData2);

  /* Even if an IO or diskfull error occurs while journalling the
  ** page in the block above, set the need-sync flag for the page.
  ** Otherwise, when the transaction is rolled back, the logic in
  ** playback_one_page() will think that the page needs to be restored
  ** in the database file. And if an IO error occurs while doing so,
  ** then corruption may follow.
  */
  pPg->flags |= PGHDR_NEED_SYNC;

  rc = write32bits(pPager->jfd, iOff, pPg->pgno);
  
// ABS Label 1728
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1728);
}

// ROR Label 1729
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1729);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1730
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1730);
}
return rc;
}
  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);
  
// ABS Label 1731
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1731);
}

// ROR Label 1732
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1732);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1733
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1733);
}
return rc;
}
  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);
  
// ABS Label 1734
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1734);
}

// ROR Label 1735
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1735);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1736
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1736);
}
return rc;
}

  IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno, 
           pPager->journalOff, pPager->pageSize));
  PAGER_INCR(sqlite3_pager_writej_count);
  PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",
       PAGERID(pPager), pPg->pgno, 
       ((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg)));

  pPager->journalOff += 8 + pPager->pageSize;
  pPager->nRec++;
  assert( pPager->pInJournal!=0 );
  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
  testcase( rc==SQLITE_NOMEM );
  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
  rc |= addToSavepointBitvecs(pPager, pPg->pgno);
  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
  
// ABS Label 1737
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1737);
}
return rc;
}

/*
** Mark a single data page as writeable. The page is written into the 
** main journal or sub-journal as required. If the page is written into
** one of the journals, the corresponding bit is set in the 
** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs
** of any open savepoints as appropriate.
*/
static int pager_write(PgHdr *pPg){
  
// ABS Label 1738
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1738);
}
Pager *pPager = pPg->pPager;
  int rc = SQLITE_OK;

  /* This routine is not called unless a write-transaction has already 
  ** been started. The journal file may or may not be open at this point.
  ** It is never called in the ERROR state.
  */
  assert( pPager->eState==PAGER_WRITER_LOCKED
       || pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
  );
  assert( assert_pager_state(pPager) );
  assert( pPager->errCode==0 );
  assert( pPager->readOnly==0 );
  CHECK_PAGE(pPg);

  /* The journal file needs to be opened. Higher level routines have already
  ** obtained the necessary locks to begin the write-transaction, but the
  ** rollback journal might not yet be open. Open it now if this is the case.
  **
  ** This is done before calling sqlite3PcacheMakeDirty() on the page. 
  ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then
  ** an error might occur and the pager would end up in WRITER_LOCKED state
  ** with pages marked as dirty in the cache.
  */
  
// ROR Label 1740
if((pPager->eState != 2) != (pPager->eState == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1740);
}
if( pPager->eState==PAGER_WRITER_LOCKED ){
    rc = pager_open_journal(pPager);
    
// ABS Label 1741
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1741);
}

// ROR Label 1742
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1742);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 1743
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1743);
}
return rc;
}
  }
  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );
  assert( assert_pager_state(pPager) );

  /* Mark the page that is about to be modified as dirty. */
  
// ABS Label 1739
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1739);
}
sqlite3PcacheMakeDirty(pPg);

  /* If a rollback journal is in use, them make sure the page that is about
  ** to change is in the rollback journal, or if the page is a new page off
  ** then end of the file, make sure it is marked as PGHDR_NEED_SYNC.
  */
  assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );
  if( pPager->pInJournal!=0
   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0
  ){
    assert( pagerUseWal(pPager)==0 );
    
// ABS Label 1744
if(pPager->dbOrigSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1744);
}
// ABS Label 1745
if(pPg->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1745);
}

// ROR Label 1746
if((pPg->pgno < pPager->dbOrigSize) != (pPg->pgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1746);
}
// ROR Label 1747
if((pPg->pgno > pPager->dbOrigSize) != (pPg->pgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1747);
}
// ROR Label 1748
if((pPg->pgno >= pPager->dbOrigSize) != (pPg->pgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1748);
}
if( pPg->pgno<=pPager->dbOrigSize ){
      rc = pagerAddPageToRollbackJournal(pPg);
      
// ABS Label 1749
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1749);
}

// ROR Label 1750
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1750);
}
if( rc!=SQLITE_OK ){
        
// ABS Label 1751
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1751);
}
return rc;
      }
    }else{
      
// ROR Label 1752
if((pPager->eState == 4) != (pPager->eState != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1752);
}
if( pPager->eState!=PAGER_WRITER_DBMOD ){
        pPg->flags |= PGHDR_NEED_SYNC;
      }
      PAGERTRACE(("APPEND %d page %d needSync=%d\n",
              PAGERID(pPager), pPg->pgno,
             ((pPg->flags&PGHDR_NEED_SYNC)?1:0)));
    }
  }

  /* The PGHDR_DIRTY bit is set above when the page was added to the dirty-list
  ** and before writing the page into the rollback journal.  Wait until now,
  ** after the page has been successfully journalled, before setting the
  ** PGHDR_WRITEABLE bit that indicates that the page can be safely modified.
  */
  pPg->flags |= PGHDR_WRITEABLE;
  
  /* If the statement journal is open and the page is not in it,
  ** then write the page into the statement journal.
  */
  
// ABS Label 1753
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1753);
}

// ROR Label 1754
if((pPager->nSavepoint <= 0) != (pPager->nSavepoint > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1754);
}
// ROR Label 1755
if((pPager->nSavepoint < 0) != (pPager->nSavepoint > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1755);
}
// ROR Label 1756
if((pPager->nSavepoint >= 0) != (pPager->nSavepoint > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1756);
}
if( pPager->nSavepoint>0 ){
    rc = subjournalPageIfRequired(pPg);
  }

  /* Update the database size and return. */
  
// ABS Label 1757
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1757);
}
// ABS Label 1758
if(pPg->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1758);
}

// ROR Label 1759
if((pPager->dbSize <= pPg->pgno) != (pPager->dbSize < pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1759);
}
// ROR Label 1760
if((pPager->dbSize > pPg->pgno) != (pPager->dbSize < pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1760);
}
// ROR Label 1761
if((pPager->dbSize >= pPg->pgno) != (pPager->dbSize < pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1761);
}
if( pPager->dbSize<pPg->pgno ){
    pPager->dbSize = pPg->pgno;
  }
  
// ABS Label 1762
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1762);
}
return rc;
}

/*
** This is a variant of sqlite3PagerWrite() that runs when the sector size
** is larger than the page size.  SQLite makes the (reasonable) assumption that
** all bytes of a sector are written together by hardware.  Hence, all bytes of
** a sector need to be journalled in case of a power loss in the middle of
** a write.
**
** Usually, the sector size is less than or equal to the page size, in which
** case pages can be individually written.  This routine only runs in the
** exceptional case where the page size is smaller than the sector size.
*/
static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){
  int rc = SQLITE_OK;          /* Return code */
  Pgno nPageCount;             /* Total number of pages in database file */
  Pgno pg1;                    /* First page of the sector pPg is located on. */
  int nPage = 0;               /* Number of pages starting at pg1 to journal */
  int ii;                      /* Loop counter */
  int needSync = 0;            /* True if any page has PGHDR_NEED_SYNC */
  
// ABS Label 1763
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1763);
}
Pager *pPager = pPg->pPager; /* The pager that owns pPg */
  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);

  /* Set the doNotSpill NOSYNC bit to 1. This is because we cannot allow
  ** a journal header to be written between the pages journaled by
  ** this function.
  */
  assert( !MEMDB );
  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)==0 );
  pPager->doNotSpill |= SPILLFLAG_NOSYNC;

  /* This trick assumes that both the page-size and sector-size are
  ** an integer power of 2. It sets variable pg1 to the identifier
  ** of the first page of the sector pPg is located on.
  */
  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;

  nPageCount = pPager->dbSize;
  
// ABS Label 1764
if(nPageCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1764);
}
// ABS Label 1765
if(pPg->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1765);
}

// ROR Label 1766
if((pPg->pgno <= nPageCount) != (pPg->pgno > nPageCount))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1766);
}
// ROR Label 1767
if((pPg->pgno < nPageCount) != (pPg->pgno > nPageCount))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1767);
}
// ROR Label 1768
if((pPg->pgno >= nPageCount) != (pPg->pgno > nPageCount))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1768);
}
if( pPg->pgno>nPageCount ){
    nPage = (pPg->pgno - pg1)+1;
  }else { 
// ABS Label 1769
if(nPageCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1769);
}

// ROR Label 1770
if(((pg1 + nPagePerSector - 1) <= nPageCount) != ((pg1 + nPagePerSector - 1) > nPageCount))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1770);
}
// ROR Label 1771
if(((pg1 + nPagePerSector - 1) < nPageCount) != ((pg1 + nPagePerSector - 1) > nPageCount))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1771);
}
// ROR Label 1772
if(((pg1 + nPagePerSector - 1) >= nPageCount) != ((pg1 + nPagePerSector - 1) > nPageCount))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1772);
}
if( (pg1+nPagePerSector-1)>nPageCount ){
    nPage = nPageCount+1-pg1;
  }else{
    nPage = nPagePerSector;
  };}

  assert(nPage>0);
  assert(pg1<=pPg->pgno);
  assert((pg1+nPage)>pPg->pgno);

  ii = 0;

// ABS Label 1773
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1773);
}
// ABS Label 1774
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1774);
}
// ABS Label 1775
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1775);
}

// COR Label 1776
if((ii < nPage || rc == 0) != (ii < nPage && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1776);
}

// ROR Label 1777
if((ii <= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1777);
}
// ROR Label 1778
if((ii > nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1778);
}
// ROR Label 1779
if((ii >= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1779);
}
// ROR Label 1780
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1780);
}

// MCC Label 1781
if(ii < nPage && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1781);
}
// MCC Label 1782
if(ii < nPage && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1782);
}
// MCC Label 1783
if(!(ii < nPage) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1783);
}
// MCC Label 1784
if(!(ii < nPage) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1784);
}
for(; ii<nPage && rc==SQLITE_OK; ii++){
    
// ABS Label 1797
if(pg1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1797);
}

// AOR Label 1798
if(pg1 - ii != pg1 + ii)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1798);
}
// AOR Label 1799
if(pg1 / ii != pg1 + ii)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1799);
}
// AOR Label 1800
if(pg1 * ii != pg1 + ii)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1800);
}
Pgno pg = pg1+ii;
    PgHdr *pPage;
    if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){
      
// ABS Label 1801
if(pg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1801);
}

// ROR Label 1802
if((pg == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != (pg != ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1802);
}
if( pg!=PAGER_MJ_PGNO(pPager) ){
        rc = sqlite3PagerGet(pPager, pg, &pPage, 0);
        
// ABS Label 1803
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1803);
}

// ROR Label 1804
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1804);
}
if( rc==SQLITE_OK ){
          rc = pager_write(pPage);
          
// AOR Label 1806
if(pPage->flags | 8 != pPage->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1806);
}
// AOR Label 1807
if(pPage->flags ^ 8 != pPage->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1807);
}
if( pPage->flags&PGHDR_NEED_SYNC ){
            needSync = 1;
          }
          
// ABS Label 1805
if(pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1805);
}
sqlite3PagerUnrefNotNull(pPage);
        }
      }
    }else { if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){
      
// AOR Label 1809
if(pPage->flags | 8 != pPage->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1809);
}
// AOR Label 1810
if(pPage->flags ^ 8 != pPage->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1810);
}
if( pPage->flags&PGHDR_NEED_SYNC ){
        needSync = 1;
      }
      
// ABS Label 1808
if(pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1808);
}
sqlite3PagerUnrefNotNull(pPage);
    };}

  };
// ABS Label 1785
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1785);
}
// ABS Label 1786
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1786);
}
// ABS Label 1787
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1787);
}

// COR Label 1788
if((ii < nPage || rc == 0) != (ii < nPage && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1788);
}

// ROR Label 1789
if((ii <= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1789);
}
// ROR Label 1790
if((ii > nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1790);
}
// ROR Label 1791
if((ii >= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1791);
}
// ROR Label 1792
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1792);
}

// MCC Label 1793
if(ii < nPage && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1793);
}
// MCC Label 1794
if(ii < nPage && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1794);
}
// MCC Label 1795
if(!(ii < nPage) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1795);
}
// MCC Label 1796
if(!(ii < nPage) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1796);
}


  /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages 
  ** starting at pg1, then it needs to be set for all of them. Because
  ** writing to any of these nPage pages may damage the others, the
  ** journal file must contain sync()ed copies of all of them
  ** before any of them can be written out to the database file.
  */
  
// ABS Label 1811
if(needSync < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1811);
}
// ABS Label 1812
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1812);
}

// COR Label 1813
if((rc == 0 || needSync) != (rc == 0 && needSync))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1813);
}

// ROR Label 1814
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1814);
}

// MCC Label 1815
if(rc == 0 && needSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1815);
}
// MCC Label 1816
if(rc == 0 && !(needSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1816);
}
// MCC Label 1817
if(!(rc == 0) && needSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1817);
}
// MCC Label 1818
if(!(rc == 0) && !(needSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1818);
}
if( rc==SQLITE_OK && needSync ){
    assert( !MEMDB );
    ii = 0;

// ABS Label 1819
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1819);
}
// ABS Label 1820
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1820);
}

// ROR Label 1821
if((ii <= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1821);
}
// ROR Label 1822
if((ii > nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1822);
}
// ROR Label 1823
if((ii >= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1823);
}
for(; ii<nPage; ii++){
      PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);
      
// ABS Label 1829
if(pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1829);
}
if( pPage ){
        pPage->flags |= PGHDR_NEED_SYNC;
        
// ABS Label 1830
if(pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1830);
}
sqlite3PagerUnrefNotNull(pPage);
      }
    };
// ABS Label 1824
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1824);
}
// ABS Label 1825
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1825);
}

// ROR Label 1826
if((ii <= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1826);
}
// ROR Label 1827
if((ii > nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1827);
}
// ROR Label 1828
if((ii >= nPage) != (ii < nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1828);
}

  }

  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)!=0 );
  pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;
  
// ABS Label 1831
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1831);
}
return rc;
}

/*
** Mark a data page as writeable. This routine must be called before 
** making changes to a page. The caller must check the return value 
** of this function and be careful not to change any page data unless 
** this routine returns SQLITE_OK.
**
** The difference between this function and pager_write() is that this
** function also deals with the special case where 2 or more pages
** fit on a single disk sector. In this case all co-resident pages
** must have been written to the journal file before returning.
**
** If an error occurs, SQLITE_NOMEM or an IO error code is returned
** as appropriate. Otherwise, SQLITE_OK.
*/
int sqlite3PagerWrite(PgHdr *pPg){
  
// ABS Label 1832
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1832);
}
Pager *pPager = pPg->pPager;
  assert( (pPg->flags & PGHDR_MMAP)==0 );
  assert( pPager->eState>=PAGER_WRITER_LOCKED );
  assert( assert_pager_state(pPager) );
  
// ABS Label 1833
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1833);
}
// ABS Label 1834
if(pPg->pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1834);
}

// COR Label 1835
if(((pPg->flags & 4) != 0 || pPager->dbSize >= pPg->pgno) != ((pPg->flags & 4) != 0 && pPager->dbSize >= pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1835);
}

// ROR Label 1836
if(((pPg->flags & 4) == 0) != ((pPg->flags & 4) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1836);
}
// ROR Label 1837
if((pPager->dbSize < pPg->pgno) != (pPager->dbSize >= pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1837);
}
// ROR Label 1838
if((pPager->dbSize > pPg->pgno) != (pPager->dbSize >= pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1838);
}
// ROR Label 1839
if((pPager->dbSize <= pPg->pgno) != (pPager->dbSize >= pPg->pgno))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1839);
}

// MCC Label 1840
if((pPg->flags & 4) != 0 && pPager->dbSize >= pPg->pgno ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1840);
}
// MCC Label 1841
if((pPg->flags & 4) != 0 && !(pPager->dbSize >= pPg->pgno) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1841);
}
// MCC Label 1842
if(!((pPg->flags & 4) != 0) && pPager->dbSize >= pPg->pgno ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1842);
}
// MCC Label 1843
if(!((pPg->flags & 4) != 0) && !(pPager->dbSize >= pPg->pgno) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1843);
}
if( (pPg->flags & PGHDR_WRITEABLE)!=0 && pPager->dbSize>=pPg->pgno ){
    
// ABS Label 1844
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1844);
}
if( pPager->nSavepoint ) { return subjournalPageIfRequired(pPg);
}
    return SQLITE_OK;
  }else { 
// ABS Label 1845
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1845);
}
if( pPager->errCode ){
    
// ABS Label 1846
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1846);
}
return pPager->errCode;
  }else { 
// ABS Label 1847
if(pPager->sectorSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1847);
}

// ROR Label 1848
if((pPager->sectorSize <= (u32)pPager->pageSize) != (pPager->sectorSize > (u32)pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1848);
}
// ROR Label 1849
if((pPager->sectorSize < (u32)pPager->pageSize) != (pPager->sectorSize > (u32)pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1849);
}
// ROR Label 1850
if((pPager->sectorSize >= (u32)pPager->pageSize) != (pPager->sectorSize > (u32)pPager->pageSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1850);
}
if( pPager->sectorSize > (u32)pPager->pageSize ){
    assert( pPager->tempFile==0 );
    return pagerWriteLargeSector(pPg);
  }else{
    return pager_write(pPg);
  };}
;}

}

/*
** Return TRUE if the page given in the argument was previously passed
** to sqlite3PagerWrite().  In other words, return TRUE if it is ok
** to change the content of the page.
*/
#ifndef NDEBUG
int sqlite3PagerIswriteable(DbPage *pPg){
  return pPg->flags & PGHDR_WRITEABLE;
}
#endif

/*
** A call to this routine tells the pager that it is not necessary to
** write the information on page pPg back to the disk, even though
** that page might be marked as dirty.  This happens, for example, when
** the page has been added as a leaf of the freelist and so its
** content no longer matters.
**
** The overlying software layer calls this routine when all of the data
** on the given page is unused. The pager marks the page as clean so
** that it does not get written to disk.
**
** Tests show that this optimization can quadruple the speed of large 
** DELETE operations.
**
** This optimization cannot be used with a temp-file, as the page may
** have been dirty at the start of the transaction. In that case, if
** memory pressure forces page pPg out of the cache, the data does need 
** to be written out to disk so that it may be read back in if the 
** current transaction is rolled back.
*/
void sqlite3PagerDontWrite(PgHdr *pPg){
  
// ABS Label 1851
if(pPg->pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1851);
}
Pager *pPager = pPg->pPager;
  
// ABS Label 1852
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1852);
}

// COR Label 1853
if((!pPager->tempFile && (pPg->flags & 2) || pPager->nSavepoint == 0) != (!pPager->tempFile && (pPg->flags & 2) && pPager->nSavepoint == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1853);
}
// COR Label 1854
if((!pPager->tempFile || (pPg->flags & 2)) != (!pPager->tempFile && (pPg->flags & 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1854);
}

// ROR Label 1855
if((pPager->nSavepoint != 0) != (pPager->nSavepoint == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1855);
}

// MCC Label 1856
if(!pPager->tempFile && ( pPg->flags & 2 ) && pPager->nSavepoint == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1856);
}
// MCC Label 1857
if(!pPager->tempFile && ( pPg->flags & 2 ) && !(pPager->nSavepoint == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1857);
}
// MCC Label 1858
if(!pPager->tempFile && ( !(pPg->flags & 2) ) && pPager->nSavepoint == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1858);
}
// MCC Label 1859
if(!pPager->tempFile && ( !(pPg->flags & 2) ) && !(pPager->nSavepoint == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1859);
}
// MCC Label 1860
if(!(!pPager->tempFile) && ( pPg->flags & 2 ) && pPager->nSavepoint == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1860);
}
// MCC Label 1861
if(!(!pPager->tempFile) && ( pPg->flags & 2 ) && !(pPager->nSavepoint == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1861);
}
// MCC Label 1862
if(!(!pPager->tempFile) && ( !(pPg->flags & 2) ) && pPager->nSavepoint == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1862);
}
// MCC Label 1863
if(!(!pPager->tempFile) && ( !(pPg->flags & 2) ) && !(pPager->nSavepoint == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1863);
}
if( !pPager->tempFile && (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){
    PAGERTRACE(("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager)));
    IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno))
    pPg->flags |= PGHDR_DONT_WRITE;
    pPg->flags &= ~PGHDR_WRITEABLE;
    testcase( pPg->flags & PGHDR_NEED_SYNC );
    pager_set_pagehash(pPg);
  }
}

/*
** This routine is called to increment the value of the database file 
** change-counter, stored as a 4-byte big-endian integer starting at 
** byte offset 24 of the pager file.  The secondary change counter at
** 92 is also updated, as is the SQLite version number at offset 96.
**
** But this only happens if the pPager->changeCountDone flag is false.
** To avoid excess churning of page 1, the update only happens once.
** See also the pager_write_changecounter() routine that does an 
** unconditional update of the change counters.
**
** If the isDirectMode flag is zero, then this is done by calling 
** sqlite3PagerWrite() on page 1, then modifying the contents of the
** page data. In this case the file will be updated when the current
** transaction is committed.
**
** The isDirectMode flag may only be non-zero if the library was compiled
** with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,
** if isDirect is non-zero, then the database file is updated directly
** by writing an updated version of page 1 using a call to the 
** sqlite3OsWrite() function.
*/
static int pager_incr_changecounter(Pager *pPager, int isDirectMode){
  int rc = SQLITE_OK;

  assert( pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
  );
  assert( assert_pager_state(pPager) );

  /* Declare and initialize constant integer 'isDirect'. If the
  ** atomic-write optimization is enabled in this build, then isDirect
  ** is initialized to the value passed as the isDirectMode parameter
  ** to this function. Otherwise, it is always set to zero.
  **
  ** The idea is that if the atomic-write optimization is not
  ** enabled at compile time, the compiler can omit the tests of
  ** 'isDirect' below, as well as the block enclosed in the
  ** "if( isDirect )" condition.
  */
#ifndef SQLITE_ENABLE_ATOMIC_WRITE
# define DIRECT_MODE 0
  assert( isDirectMode==0 );
  UNUSED_PARAMETER(isDirectMode);
#else
# define DIRECT_MODE isDirectMode
#endif

  
// COR Label 1864
if((!pPager->changeCountDone || (pPager->dbSize > 0)) != (!pPager->changeCountDone && (pPager->dbSize > 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1864);
}

// MCC Label 1865
if(!pPager->changeCountDone && ( pPager->dbSize > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1865);
}
// MCC Label 1866
if(!pPager->changeCountDone && ( !(pPager->dbSize > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1866);
}
// MCC Label 1867
if(!(!pPager->changeCountDone) && ( pPager->dbSize > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1867);
}
// MCC Label 1868
if(!(!pPager->changeCountDone) && ( !(pPager->dbSize > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1868);
}
if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){
    PgHdr *pPgHdr;                /* Reference to page 1 */

    assert( !pPager->tempFile && isOpen(pPager->fd) );

    /* Open page 1 of the file for writing. */
    rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);
    assert( pPgHdr==0 || rc==SQLITE_OK );

    /* If page one was fetched successfully, and this function is not
    ** operating in direct-mode, make page 1 writable.  When not in 
    ** direct mode, page 1 is always held in cache and hence the PagerGet()
    ** above is always successful - hence the ALWAYS on rc==SQLITE_OK.
    */
    
// COR Label 1870
if((!0 || (rc == 0)) != (!0 && (rc == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1870);
}

// MCC Label 1871
if(!0 && ( rc == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1871);
}
// MCC Label 1872
if(!0 && ( !(rc == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1872);
}
// MCC Label 1873
if(!(!0) && ( rc == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1873);
}
// MCC Label 1874
if(!(!0) && ( !(rc == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1874);
}
if( !DIRECT_MODE && ALWAYS(rc==SQLITE_OK) ){
      rc = sqlite3PagerWrite(pPgHdr);
    }

    
// ABS Label 1875
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1875);
}

// ROR Label 1876
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1876);
}
if( rc==SQLITE_OK ){
      /* Actually do the update of the change counter */
      
// ABS Label 1877
if(pPgHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1877);
}
pager_write_changecounter(pPgHdr);

      /* If running in direct mode, write the contents of page 1 to the file. */
      if( DIRECT_MODE ){
        const void *zBuf;
        assert( pPager->dbFileSize>0 );
        zBuf = pPgHdr->pData;
        
// ABS Label 1878
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1878);
}

// ROR Label 1879
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1879);
}
if( rc==SQLITE_OK ){
          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);
          pPager->aStat[PAGER_STAT_WRITE]++;
        }
        
// ABS Label 1880
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1880);
}

// ROR Label 1881
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1881);
}
if( rc==SQLITE_OK ){
          /* Update the pager's copy of the change-counter. Otherwise, the
          ** next time a read transaction is opened the cache will be
          ** flushed (as the change-counter values will not match).  */
          const void *pCopy = (const void *)&((const char *)zBuf)[24];
          
// ABS Label 1882
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1882);
}
memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
          pPager->changeCountDone = 1;
        }
      }else{
        pPager->changeCountDone = 1;
      }
    }

    /* Release the page reference. */
    
// ABS Label 1869
if(pPgHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1869);
}
sqlite3PagerUnref(pPgHdr);
  }
  
// ABS Label 1883
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1883);
}
return rc;
}

/*
** Sync the database file to disk. This is a no-op for in-memory databases
** or pages with the Pager.noSync flag set.
**
** If successful, or if called on a pager for which it is a no-op, this
** function returns SQLITE_OK. Otherwise, an IO error code is returned.
*/
int sqlite3PagerSync(Pager *pPager, const char *zSuper){
  int rc = SQLITE_OK;
  void *pArg = (void*)zSuper;
  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);
  
// ABS Label 1884
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1884);
}

// ROR Label 1885
if((rc != 12) != (rc == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1885);
}
if( rc==SQLITE_NOTFOUND ) { rc = SQLITE_OK;
}
  
// ABS Label 1886
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1886);
}

// COR Label 1887
if((rc == 0 || !pPager->noSync) != (rc == 0 && !pPager->noSync))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1887);
}

// ROR Label 1888
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1888);
}

// MCC Label 1889
if(rc == 0 && !pPager->noSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1889);
}
// MCC Label 1890
if(rc == 0 && !(!pPager->noSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1890);
}
// MCC Label 1891
if(!(rc == 0) && !pPager->noSync ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1891);
}
// MCC Label 1892
if(!(rc == 0) && !(!pPager->noSync) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1892);
}
if( rc==SQLITE_OK && !pPager->noSync ){
    assert( !MEMDB );
    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
  }
  
// ABS Label 1893
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1893);
}
return rc;
}

/*
** This function may only be called while a write-transaction is active in
** rollback. If the connection is in WAL mode, this call is a no-op. 
** Otherwise, if the connection does not already have an EXCLUSIVE lock on 
** the database file, an attempt is made to obtain one.
**
** If the EXCLUSIVE lock is already held or the attempt to obtain it is
** successful, or the connection is in WAL mode, SQLITE_OK is returned.
** Otherwise, either SQLITE_BUSY or an SQLITE_IOERR_XXX error code is 
** returned.
*/
int sqlite3PagerExclusiveLock(Pager *pPager){
  
// ABS Label 1894
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1894);
}
int rc = pPager->errCode;
  assert( assert_pager_state(pPager) );
  
// ABS Label 1895
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1895);
}

// ROR Label 1896
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1896);
}
if( rc==SQLITE_OK ){
    assert( pPager->eState==PAGER_WRITER_CACHEMOD 
         || pPager->eState==PAGER_WRITER_DBMOD 
         || pPager->eState==PAGER_WRITER_LOCKED 
    );
    assert( assert_pager_state(pPager) );
    
// ROR Label 1897
if((0 != ((pPager)->pWal != 0)) != (0 == ((pPager)->pWal != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1897);
}
if( 0==pagerUseWal(pPager) ){
      rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
    }
  }
  
// ABS Label 1898
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1898);
}
return rc;
}

/*
** Sync the database file for the pager pPager. zSuper points to the name
** of a super-journal file that should be written into the individual
** journal file. zSuper may be NULL, which is interpreted as no 
** super-journal (a single database transaction).
**
** This routine ensures that:
**
**   * The database file change-counter is updated,
**   * the journal is synced (unless the atomic-write optimization is used),
**   * all dirty pages are written to the database file, 
**   * the database file is truncated (if required), and
**   * the database file synced. 
**
** The only thing that remains to commit the transaction is to finalize 
** (delete, truncate or zero the first part of) the journal file (or 
** delete the super-journal file if specified).
**
** Note that if zSuper==NULL, this does not overwrite a previous value
** passed to an sqlite3PagerCommitPhaseOne() call.
**
** If the final parameter - noSync - is true, then the database file itself
** is not synced. The caller must call sqlite3PagerSync() directly to
** sync the database file before calling CommitPhaseTwo() to delete the
** journal file in this case.
*/
int sqlite3PagerCommitPhaseOne(
  Pager *pPager,                  /* Pager object */
  const char *zSuper,            /* If not NULL, the super-journal name */
  int noSync                      /* True to omit the xSync on the db file */
){
  int rc = SQLITE_OK;             /* Return code */

  assert( pPager->eState==PAGER_WRITER_LOCKED
       || pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
       || pPager->eState==PAGER_ERROR
  );
  assert( assert_pager_state(pPager) );

  /* If a prior error occurred, report that error again. */
  
// ABS Label 1899
if((pPager->errCode) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1899);
}
if( NEVER(pPager->errCode) ) { 
// ABS Label 1900
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1900);
}
return pPager->errCode;
}

  /* Provide the ability to easily simulate an I/O error during testing */
  if( sqlite3FaultSim(400) ) { return SQLITE_IOERR;
}

  PAGERTRACE(("DATABASE SYNC: File=%s zSuper=%s nSize=%d\n", 
      pPager->zFilename, zSuper, pPager->dbSize));

  /* If no database changes have been made, return early. */
  
// ROR Label 1901
if((pPager->eState <= 3) != (pPager->eState < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1901);
}
// ROR Label 1902
if((pPager->eState > 3) != (pPager->eState < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1902);
}
// ROR Label 1903
if((pPager->eState >= 3) != (pPager->eState < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1903);
}
if( pPager->eState<PAGER_WRITER_CACHEMOD ) { return SQLITE_OK;
}

  assert( MEMDB==0 || pPager->tempFile );
  assert( isOpen(pPager->fd) || pPager->tempFile );
  if( 0==pagerFlushOnCommit(pPager, 1) ){
    /* If this is an in-memory db, or no pages have been written to, or this
    ** function has already been called, it is mostly a no-op.  However, any
    ** backup in progress needs to be restarted.  */
    
// ABS Label 1904
if(pPager->pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1904);
}
sqlite3BackupRestart(pPager->pBackup);
  }else{
    PgHdr *pList;
    
// MCC Label 1905
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1905);
}
// MCC Label 1906
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1906);
}
if( pagerUseWal(pPager) ){
      PgHdr *pPageOne = 0;
      pList = sqlite3PcacheDirtyList(pPager->pPCache);
      
// ABS Label 1908
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1908);
}

// ROR Label 1909
if((pList != 0) != (pList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1909);
}
if( pList==0 ){
        /* Must have at least one page for the WAL commit flag.
        ** Ticket [2d1a5c67dfc2363e44f29d9bbd57f] 2011-05-18 */
        rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);
        pList = pPageOne;
        pList->pDirty = 0;
      }
      assert( rc==SQLITE_OK );
      
// ABS Label 1910
if((pList) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1910);
}
if( ALWAYS(pList) ){
        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
      }
      
// ABS Label 1907
if(pPageOne < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1907);
}
sqlite3PagerUnref(pPageOne);
      
// ABS Label 1911
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1911);
}

// ROR Label 1912
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1912);
}
if( rc==SQLITE_OK ){
        
// ABS Label 1913
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1913);
}
sqlite3PcacheCleanAll(pPager->pPCache);
      }
    }else{
      /* The bBatch boolean is true if the batch-atomic-write commit method
      ** should be used.  No rollback journal is created if batch-atomic-write
      ** is enabled.
      */
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
      sqlite3_file *fd = pPager->fd;
      int bBatch = zSuper==0    /* An SQLITE_IOCAP_BATCH_ATOMIC commit */
        && (sqlite3OsDeviceCharacteristics(fd) & SQLITE_IOCAP_BATCH_ATOMIC)
        && !pPager->noSync
        && sqlite3JournalIsInMemory(pPager->jfd);
#else
#     define bBatch 0
#endif

#ifdef SQLITE_ENABLE_ATOMIC_WRITE
      /* The following block updates the change-counter. Exactly how it
      ** does this depends on whether or not the atomic-update optimization
      ** was enabled at compile time, and if this transaction meets the 
      ** runtime criteria to use the operation: 
      **
      **    * The file-system supports the atomic-write property for
      **      blocks of size page-size, and 
      **    * This commit is not part of a multi-file transaction, and
      **    * Exactly one page has been modified and store in the journal file.
      **
      ** If the optimization was not enabled at compile time, then the
      ** pager_incr_changecounter() function is called to update the change
      ** counter in 'indirect-mode'. If the optimization is compiled in but
      ** is not applicable to this transaction, call sqlite3JournalCreate()
      ** to make sure the journal file has actually been created, then call
      ** pager_incr_changecounter() to update the change-counter in indirect
      ** mode. 
      **
      ** Otherwise, if the optimization is both enabled and applicable,
      ** then call pager_incr_changecounter() to update the change-counter
      ** in 'direct' mode. In this case the journal file will never be
      ** created for this transaction.
      */
      if( bBatch==0 ){
        PgHdr *pPg;
        assert( isOpen(pPager->jfd) 
            || pPager->journalMode==PAGER_JOURNALMODE_OFF 
            || pPager->journalMode==PAGER_JOURNALMODE_WAL 
            );
        if( !zSuper && isOpen(pPager->jfd) 
         && pPager->journalOff==jrnlBufferSize(pPager) 
         && pPager->dbSize>=pPager->dbOrigSize
         && (!(pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)
        ){
          /* Update the db file change counter via the direct-write method. The 
          ** following call will modify the in-memory representation of page 1 
          ** to include the updated change counter and then write page 1 
          ** directly to the database file. Because of the atomic-write 
          ** property of the host file-system, this is safe.
          */
          rc = pager_incr_changecounter(pPager, 1);
        }else{
          rc = sqlite3JournalCreate(pPager->jfd);
          if( rc==SQLITE_OK ){
            rc = pager_incr_changecounter(pPager, 0);
          }
        }
      }
#else  /* SQLITE_ENABLE_ATOMIC_WRITE */
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
      if( zSuper ){
        rc = sqlite3JournalCreate(pPager->jfd);
        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;
        assert( bBatch==0 );
      }
#endif
      rc = pager_incr_changecounter(pPager, 0);
#endif /* !SQLITE_ENABLE_ATOMIC_WRITE */
      
// ABS Label 1915
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1915);
}

// ROR Label 1916
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1916);
}
if( rc!=SQLITE_OK ) { goto commit_phase_one_exit;
}
  
      /* Write the super-journal name into the journal file. If a
      ** super-journal file name has already been written to the journal file, 
      ** or if zSuper is NULL (no super-journal), then this call is a no-op.
      */
      rc = writeSuperJournal(pPager, zSuper);
      
// ABS Label 1917
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1917);
}

// ROR Label 1918
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1918);
}
if( rc!=SQLITE_OK ) { goto commit_phase_one_exit;
}
  
      /* Sync the journal file and write all dirty pages to the database.
      ** If the atomic-update optimization is being used, this sync will not 
      ** create the journal file or perform any real IO.
      **
      ** Because the change-counter page was just modified, unless the
      ** atomic-update optimization is used it is almost certain that the
      ** journal requires a sync here. However, in locking_mode=exclusive
      ** on a system under memory pressure it is just possible that this is 
      ** not the case. In this case it is likely enough that the redundant
      ** xSync() call will be changed to a no-op by the OS anyhow. 
      */
      rc = syncJournal(pPager, 0);
      
// ABS Label 1919
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1919);
}

// ROR Label 1920
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1920);
}
if( rc!=SQLITE_OK ) { goto commit_phase_one_exit;
}

      pList = sqlite3PcacheDirtyList(pPager->pPCache);
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
      if( bBatch ){
        rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, 0);
        if( rc==SQLITE_OK ){
          rc = pager_write_pagelist(pPager, pList);
          if( rc==SQLITE_OK ){
            rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, 0);
          }
          if( rc!=SQLITE_OK ){
            sqlite3OsFileControlHint(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);
          }
        }

        if( (rc&0xFF)==SQLITE_IOERR && rc!=SQLITE_IOERR_NOMEM ){
          rc = sqlite3JournalCreate(pPager->jfd);
          if( rc!=SQLITE_OK ){
            sqlite3OsClose(pPager->jfd);
            goto commit_phase_one_exit;
          }
          bBatch = 0;
        }else{
          sqlite3OsClose(pPager->jfd);
        }
      }
#endif /* SQLITE_ENABLE_BATCH_ATOMIC_WRITE */

      
// ROR Label 1921
if((0 != 0) != (0 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1921);
}
if( bBatch==0 ){
        rc = pager_write_pagelist(pPager, pList);
      }
      
// ABS Label 1922
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1922);
}

// ROR Label 1923
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1923);
}
if( rc!=SQLITE_OK ){
        assert( rc!=SQLITE_IOERR_BLOCKED );
        goto commit_phase_one_exit;
      }
      
// ABS Label 1914
if(pPager->pPCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1914);
}
sqlite3PcacheCleanAll(pPager->pPCache);

      /* If the file on disk is smaller than the database image, use 
      ** pager_truncate to grow the file here. This can happen if the database
      ** image was extended as part of the current transaction and then the
      ** last page in the db image moved to the free-list. In this case the
      ** last page is never written out to disk, leaving the database file
      ** undersized. Fix this now if it is the case.  */
      
// ABS Label 1924
if(pPager->dbFileSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1924);
}
// ABS Label 1925
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1925);
}

// ROR Label 1926
if((pPager->dbSize <= pPager->dbFileSize) != (pPager->dbSize > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1926);
}
// ROR Label 1927
if((pPager->dbSize < pPager->dbFileSize) != (pPager->dbSize > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1927);
}
// ROR Label 1928
if((pPager->dbSize >= pPager->dbFileSize) != (pPager->dbSize > pPager->dbFileSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1928);
}
if( pPager->dbSize>pPager->dbFileSize ){
        
// ABS Label 1929
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1929);
}

// AOR Label 1930
if(pPager->dbSize / (pPager->dbSize == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != pPager->dbSize - (pPager->dbSize == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1930);
}
// AOR Label 1931
if(pPager->dbSize + (pPager->dbSize == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != pPager->dbSize - (pPager->dbSize == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1931);
}
// AOR Label 1932
if(pPager->dbSize * (pPager->dbSize == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))) != pPager->dbSize - (pPager->dbSize == ((Pgno)((sqlite3PendingByte / ((pPager)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1932);
}
Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));
        assert( pPager->eState==PAGER_WRITER_DBMOD );
        rc = pager_truncate(pPager, nNew);
        
// ABS Label 1933
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1933);
}

// ROR Label 1934
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1934);
}
if( rc!=SQLITE_OK ) { goto commit_phase_one_exit;
}
      }
  
      /* Finally, sync the database file. */
      if( !noSync ){
        rc = sqlite3PagerSync(pPager, zSuper);
      }
      IOTRACE(("DBSYNC %p\n", pPager))
    }
  }

commit_phase_one_exit:
  
// ABS Label 1935
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1935);
}

// COR Label 1936
if((rc == 0 || !((pPager)->pWal != 0)) != (rc == 0 && !((pPager)->pWal != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1936);
}

// ROR Label 1937
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1937);
}

// MCC Label 1938
if(rc == 0 && !((pPager)->pWal != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1938);
}
// MCC Label 1939
if(rc == 0 && !(!((pPager)->pWal != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1939);
}
// MCC Label 1940
if(!(rc == 0) && !((pPager)->pWal != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1940);
}
// MCC Label 1941
if(!(rc == 0) && !(!((pPager)->pWal != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1941);
}
if( rc==SQLITE_OK && !pagerUseWal(pPager) ){
    pPager->eState = PAGER_WRITER_FINISHED;
  }
  
// ABS Label 1942
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1942);
}
return rc;
}


/*
** When this function is called, the database file has been completely
** updated to reflect the changes made by the current transaction and
** synced to disk. The journal file still exists in the file-system 
** though, and if a failure occurs at this point it will eventually
** be used as a hot-journal and the current transaction rolled back.
**
** This function finalizes the journal file, either by deleting, 
** truncating or partially zeroing it, so that it cannot be used 
** for hot-journal rollback. Once this is done the transaction is
** irrevocably committed.
**
** If an error occurs, an IO error code is returned and the pager
** moves into the error state. Otherwise, SQLITE_OK is returned.
*/
int sqlite3PagerCommitPhaseTwo(Pager *pPager){
  int rc = SQLITE_OK;                  /* Return code */

  /* This routine should not be called if a prior error has occurred.
  ** But if (due to a coding error elsewhere in the system) it does get
  ** called, just return the same error code without doing anything. */
  
// ABS Label 1943
if((pPager->errCode) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1943);
}
if( NEVER(pPager->errCode) ) { 
// ABS Label 1944
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1944);
}
return pPager->errCode;
}
  pPager->iDataVersion++;

  assert( pPager->eState==PAGER_WRITER_LOCKED
       || pPager->eState==PAGER_WRITER_FINISHED
       || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD)
  );
  assert( assert_pager_state(pPager) );

  /* An optimization. If the database was not actually modified during
  ** this transaction, the pager is running in exclusive-mode and is
  ** using persistent journals, then this function is a no-op.
  **
  ** The start of the journal file currently contains a single journal 
  ** header with the nRec field set to 0. If such a journal is used as
  ** a hot-journal during hot-journal rollback, 0 changes will be made
  ** to the database file. So there is no need to zero the journal 
  ** header. Since the pager is in exclusive mode, there is no need
  ** to drop any locks either.
  */
  
// COR Label 1945
if((pPager->eState == 2 && pPager->exclusiveMode || pPager->journalMode == 1) != (pPager->eState == 2 && pPager->exclusiveMode && pPager->journalMode == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1945);
}
// COR Label 1946
if((pPager->eState == 2 || pPager->exclusiveMode) != (pPager->eState == 2 && pPager->exclusiveMode))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1946);
}

// ROR Label 1947
if((pPager->eState != 2) != (pPager->eState == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1947);
}
// ROR Label 1948
if((pPager->journalMode != 1) != (pPager->journalMode == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1948);
}

// MCC Label 1949
if(pPager->eState == 2 && pPager->exclusiveMode && pPager->journalMode == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1949);
}
// MCC Label 1950
if(pPager->eState == 2 && pPager->exclusiveMode && !(pPager->journalMode == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1950);
}
// MCC Label 1951
if(pPager->eState == 2 && !(pPager->exclusiveMode) && pPager->journalMode == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1951);
}
// MCC Label 1952
if(pPager->eState == 2 && !(pPager->exclusiveMode) && !(pPager->journalMode == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1952);
}
// MCC Label 1953
if(!(pPager->eState == 2) && pPager->exclusiveMode && pPager->journalMode == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1953);
}
// MCC Label 1954
if(!(pPager->eState == 2) && pPager->exclusiveMode && !(pPager->journalMode == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1954);
}
// MCC Label 1955
if(!(pPager->eState == 2) && !(pPager->exclusiveMode) && pPager->journalMode == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1955);
}
// MCC Label 1956
if(!(pPager->eState == 2) && !(pPager->exclusiveMode) && !(pPager->journalMode == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1956);
}
if( pPager->eState==PAGER_WRITER_LOCKED 
   && pPager->exclusiveMode 
   && pPager->journalMode==PAGER_JOURNALMODE_PERSIST
  ){
    assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );
    pPager->eState = PAGER_READER;
    return SQLITE_OK;
  }

  PAGERTRACE(("COMMIT %d\n", PAGERID(pPager)));
  rc = pager_end_transaction(pPager, pPager->setSuper, 1);
  return pager_error(pPager, rc);
}

/*
** If a write transaction is open, then all changes made within the 
** transaction are reverted and the current write-transaction is closed.
** The pager falls back to PAGER_READER state if successful, or PAGER_ERROR
** state if an error occurs.
**
** If the pager is already in PAGER_ERROR state when this function is called,
** it returns Pager.errCode immediately. No work is performed in this case.
**
** Otherwise, in rollback mode, this function performs two functions:
**
**   1) It rolls back the journal file, restoring all database file and 
**      in-memory cache pages to the state they were in when the transaction
**      was opened, and
**
**   2) It finalizes the journal file, so that it is not used for hot
**      rollback at any point in the future.
**
** Finalization of the journal file (task 2) is only performed if the 
** rollback is successful.
**
** In WAL mode, all cache-entries containing data modified within the
** current transaction are either expelled from the cache or reverted to
** their pre-transaction state by re-reading data from the database or
** WAL files. The WAL transaction is then closed.
*/
int sqlite3PagerRollback(Pager *pPager){
  int rc = SQLITE_OK;                  /* Return code */
  PAGERTRACE(("ROLLBACK %d\n", PAGERID(pPager)));

  /* PagerRollback() is a no-op if called in READER or OPEN state. If
  ** the pager is already in the ERROR state, the rollback is not 
  ** attempted here. Instead, the error code is returned to the caller.
  */
  assert( assert_pager_state(pPager) );
  
// ROR Label 1957
if((pPager->eState != 6) != (pPager->eState == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1957);
}
if( pPager->eState==PAGER_ERROR ) { 
// ABS Label 1958
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1958);
}
return pPager->errCode;
}
  
// ROR Label 1959
if((pPager->eState < 1) != (pPager->eState <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1959);
}
// ROR Label 1960
if((pPager->eState > 1) != (pPager->eState <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1960);
}
// ROR Label 1961
if((pPager->eState >= 1) != (pPager->eState <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1961);
}
if( pPager->eState<=PAGER_READER ) { return SQLITE_OK;
}

  
// MCC Label 1962
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1962);
}
// MCC Label 1963
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1963);
}
if( pagerUseWal(pPager) ){
    int rc2;
    rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);
    rc2 = pager_end_transaction(pPager, pPager->setSuper, 0);
    
// ABS Label 1964
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1964);
}

// ROR Label 1965
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1965);
}
if( rc==SQLITE_OK ) { rc = rc2;
}
  }else { 
// COR Label 1966
if((!((pPager->jfd)->pMethods != 0) && pPager->eState == 2) != (!((pPager->jfd)->pMethods != 0) || pPager->eState == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1966);
}

// ROR Label 1967
if((pPager->eState != 2) != (pPager->eState == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1967);
}

// MCC Label 1968
if(!((pPager->jfd)->pMethods != 0) && pPager->eState == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1968);
}
// MCC Label 1969
if(!((pPager->jfd)->pMethods != 0) && !(pPager->eState == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1969);
}
// MCC Label 1970
if(!(!((pPager->jfd)->pMethods != 0)) && pPager->eState == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1970);
}
// MCC Label 1971
if(!(!((pPager->jfd)->pMethods != 0)) && !(pPager->eState == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1971);
}
if( !isOpen(pPager->jfd) || pPager->eState==PAGER_WRITER_LOCKED ){
    int eState = pPager->eState;
    rc = pager_end_transaction(pPager, 0, 0);
    
// ABS Label 1972
if(eState < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1972);
}

// COR Label 1973
if((!pPager->memDb || eState > 2) != (!pPager->memDb && eState > 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1973);
}

// ROR Label 1974
if((eState <= 2) != (eState > 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1974);
}
// ROR Label 1975
if((eState < 2) != (eState > 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1975);
}
// ROR Label 1976
if((eState >= 2) != (eState > 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1976);
}

// MCC Label 1977
if(!pPager->memDb && eState > 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1977);
}
// MCC Label 1978
if(!pPager->memDb && !(eState > 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1978);
}
// MCC Label 1979
if(!(!pPager->memDb) && eState > 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1979);
}
// MCC Label 1980
if(!(!pPager->memDb) && !(eState > 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1980);
}
if( !MEMDB && eState>PAGER_WRITER_LOCKED ){
      /* This can happen using journal_mode=off. Move the pager to the error 
      ** state to indicate that the contents of the cache may not be trusted.
      ** Any active readers will get SQLITE_ABORT.
      */
      pPager->errCode = SQLITE_ABORT;
      pPager->eState = PAGER_ERROR;
      
// ABS Label 1981
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1981);
}
setGetterMethod(pPager);
      
// ABS Label 1982
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1982);
}
return rc;
    }
  }else{
    rc = pager_playback(pPager, 0);
  };}


  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );
  assert( rc==SQLITE_OK || rc==SQLITE_FULL || rc==SQLITE_CORRUPT
          || rc==SQLITE_NOMEM || (rc&0xFF)==SQLITE_IOERR 
          || rc==SQLITE_CANTOPEN
  );

  /* If an error occurs during a ROLLBACK, we can no longer trust the pager
  ** cache. So call pager_error() on the way out to make any error persistent.
  */
  return pager_error(pPager, rc);
}

/*
** Return TRUE if the database file is opened read-only.  Return FALSE
** if the database is (in theory) writable.
*/
u8 sqlite3PagerIsreadonly(Pager *pPager){
  
// ABS Label 1983
if(pPager->readOnly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1983);
}
return pPager->readOnly;
}

#ifdef SQLITE_DEBUG
/*
** Return the sum of the reference counts for all pages held by pPager.
*/
int sqlite3PagerRefcount(Pager *pPager){
  return sqlite3PcacheRefCount(pPager->pPCache);
}
#endif

/*
** Return the approximate number of bytes of memory currently
** used by the pager and its associated cache.
*/
int sqlite3PagerMemUsed(Pager *pPager){
  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)
                                     + 5*sizeof(void*);
  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)
           + sqlite3MallocSize(pPager)
           + pPager->pageSize;
}

/*
** Return the number of references to the specified page.
*/
int sqlite3PagerPageRefcount(DbPage *pPage){
  return sqlite3PcachePageRefcount(pPage);
}

#ifdef SQLITE_TEST
/*
** This routine is used for testing and analysis only.
*/
int *sqlite3PagerStats(Pager *pPager){
  static int a[11];
  a[0] = sqlite3PcacheRefCount(pPager->pPCache);
  a[1] = sqlite3PcachePagecount(pPager->pPCache);
  a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);
  a[3] = pPager->eState==PAGER_OPEN ? -1 : (int) pPager->dbSize;
  a[4] = pPager->eState;
  a[5] = pPager->errCode;
  a[6] = pPager->aStat[PAGER_STAT_HIT];
  a[7] = pPager->aStat[PAGER_STAT_MISS];
  a[8] = 0;  /* Used to be pPager->nOvfl */
  a[9] = pPager->nRead;
  a[10] = pPager->aStat[PAGER_STAT_WRITE];
  return a;
}
#endif

/*
** Parameter eStat must be one of SQLITE_DBSTATUS_CACHE_HIT, _MISS, _WRITE,
** or _WRITE+1.  The SQLITE_DBSTATUS_CACHE_WRITE+1 case is a translation
** of SQLITE_DBSTATUS_CACHE_SPILL.  The _SPILL case is not contiguous because
** it was added later.
**
** Before returning, *pnVal is incremented by the
** current cache hit or miss count, according to the value of eStat. If the 
** reset parameter is non-zero, the cache hit or miss count is zeroed before 
** returning.
*/
void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){

  assert( eStat==SQLITE_DBSTATUS_CACHE_HIT
       || eStat==SQLITE_DBSTATUS_CACHE_MISS
       || eStat==SQLITE_DBSTATUS_CACHE_WRITE
       || eStat==SQLITE_DBSTATUS_CACHE_WRITE+1
  );

  assert( SQLITE_DBSTATUS_CACHE_HIT+1==SQLITE_DBSTATUS_CACHE_MISS );
  assert( SQLITE_DBSTATUS_CACHE_HIT+2==SQLITE_DBSTATUS_CACHE_WRITE );
  assert( PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1
           && PAGER_STAT_WRITE==2 && PAGER_STAT_SPILL==3 );

  eStat -= SQLITE_DBSTATUS_CACHE_HIT;
  *pnVal += pPager->aStat[eStat];
  
// ABS Label 1984
if(reset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1984);
}
if( reset ){
    pPager->aStat[eStat] = 0;
  }
}

/*
** Return true if this is an in-memory or temp-file backed pager.
*/
int sqlite3PagerIsMemdb(Pager *pPager){
  return pPager->tempFile;
}

/*
** Check that there are at least nSavepoint savepoints open. If there are
** currently less than nSavepoints open, then open one or more savepoints
** to make up the difference. If the number of savepoints is already
** equal to nSavepoint, then this function is a no-op.
**
** If a memory allocation fails, SQLITE_NOMEM is returned. If an error 
** occurs while opening the sub-journal file, then an IO error code is
** returned. Otherwise, SQLITE_OK.
*/
static SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){
  int rc = SQLITE_OK;                       /* Return code */
  
// ABS Label 1985
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1985);
}
int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */
  int ii;                                   /* Iterator variable */
  PagerSavepoint *aNew;                     /* New Pager.aSavepoint array */

  assert( pPager->eState>=PAGER_WRITER_LOCKED );
  assert( assert_pager_state(pPager) );
  assert( nSavepoint>nCurrent && pPager->useJournal );

  /* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM
  ** if the allocation fails. Otherwise, zero the new portion in case a 
  ** malloc failure occurs while populating it in the for(...) loop below.
  */
  aNew = (PagerSavepoint *)sqlite3Realloc(
      pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint
  );
  if( !aNew ){
    return SQLITE_NOMEM_BKPT;
  }
  
// AOR Label 1986
if((nSavepoint - nCurrent) - sizeof(PagerSavepoint) != (nSavepoint - nCurrent) * sizeof(PagerSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1986);
}
// AOR Label 1987
if((nSavepoint - nCurrent) + sizeof(PagerSavepoint) != (nSavepoint - nCurrent) * sizeof(PagerSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1987);
}
// AOR Label 1988
if((nSavepoint - nCurrent) / sizeof(PagerSavepoint) != (nSavepoint - nCurrent) * sizeof(PagerSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1988);
}
memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
  pPager->aSavepoint = aNew;

  /* Populate the PagerSavepoint structures just allocated. */
  ii = nCurrent;

// ABS Label 1989
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1989);
}
// ABS Label 1990
if(nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1990);
}

// ROR Label 1991
if((ii <= nSavepoint) != (ii < nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1991);
}
// ROR Label 1992
if((ii > nSavepoint) != (ii < nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1992);
}
// ROR Label 1993
if((ii >= nSavepoint) != (ii < nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1993);
}
for(; ii<nSavepoint; ii++){
    aNew[ii].nOrig = pPager->dbSize;
    
// ABS Label 1999
if(pPager->journalOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1999);
}

// COR Label 2000
if((((pPager->jfd)->pMethods != 0) || pPager->journalOff > 0) != (((pPager->jfd)->pMethods != 0) && pPager->journalOff > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2000);
}

// ROR Label 2001
if((pPager->journalOff <= 0) != (pPager->journalOff > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2001);
}
// ROR Label 2002
if((pPager->journalOff < 0) != (pPager->journalOff > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2002);
}
// ROR Label 2003
if((pPager->journalOff >= 0) != (pPager->journalOff > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2003);
}

// MCC Label 2004
if(( (pPager->jfd)->pMethods != 0 ) && pPager->journalOff > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2004);
}
// MCC Label 2005
if(( (pPager->jfd)->pMethods != 0 ) && !(pPager->journalOff > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2005);
}
// MCC Label 2006
if(( !((pPager->jfd)->pMethods != 0) ) && pPager->journalOff > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2006);
}
// MCC Label 2007
if(( !((pPager->jfd)->pMethods != 0) ) && !(pPager->journalOff > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2007);
}
if( isOpen(pPager->jfd) && pPager->journalOff>0 ){
      aNew[ii].iOffset = pPager->journalOff;
    }else{
      aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);
    }
    aNew[ii].iSubRec = pPager->nSubRec;
    aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
    aNew[ii].bTruncateOnRelease = 1;
    if( !aNew[ii].pInSavepoint ){
      return SQLITE_NOMEM_BKPT;
    }
    
// MCC Label 2008
if(( (pPager)->pWal != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2008);
}
// MCC Label 2009
if(( !((pPager)->pWal != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2009);
}
if( pagerUseWal(pPager) ){
      
// ABS Label 2010
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2010);
}
sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
    }
    pPager->nSavepoint = ii+1;
  };
// ABS Label 1994
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1994);
}
// ABS Label 1995
if(nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1995);
}

// ROR Label 1996
if((ii <= nSavepoint) != (ii < nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1996);
}
// ROR Label 1997
if((ii > nSavepoint) != (ii < nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1997);
}
// ROR Label 1998
if((ii >= nSavepoint) != (ii < nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1998);
}

  assert( pPager->nSavepoint==nSavepoint );
  assertTruncateConstraint(pPager);
  
// ABS Label 2011
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2011);
}
return rc;
}
int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){
  assert( pPager->eState>=PAGER_WRITER_LOCKED );
  assert( assert_pager_state(pPager) );

  
// ABS Label 2012
if(nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2012);
}
// ABS Label 2013
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2013);
}

// COR Label 2014
if((nSavepoint > pPager->nSavepoint || pPager->useJournal) != (nSavepoint > pPager->nSavepoint && pPager->useJournal))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2014);
}

// ROR Label 2015
if((nSavepoint <= pPager->nSavepoint) != (nSavepoint > pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2015);
}
// ROR Label 2016
if((nSavepoint < pPager->nSavepoint) != (nSavepoint > pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2016);
}
// ROR Label 2017
if((nSavepoint >= pPager->nSavepoint) != (nSavepoint > pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2017);
}

// MCC Label 2018
if(nSavepoint > pPager->nSavepoint && pPager->useJournal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2018);
}
// MCC Label 2019
if(nSavepoint > pPager->nSavepoint && !(pPager->useJournal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2019);
}
// MCC Label 2020
if(!(nSavepoint > pPager->nSavepoint) && pPager->useJournal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2020);
}
// MCC Label 2021
if(!(nSavepoint > pPager->nSavepoint) && !(pPager->useJournal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2021);
}
if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){
    return pagerOpenSavepoint(pPager, nSavepoint);
  }else{
    return SQLITE_OK;
  }
}


/*
** This function is called to rollback or release (commit) a savepoint.
** The savepoint to release or rollback need not be the most recently 
** created savepoint.
**
** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.
** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint with
** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changes
** that have occurred since the specified savepoint was created.
**
** The savepoint to rollback or release is identified by parameter 
** iSavepoint. A value of 0 means to operate on the outermost savepoint
** (the first created). A value of (Pager.nSavepoint-1) means operate
** on the most recently created savepoint. If iSavepoint is greater than
** (Pager.nSavepoint-1), then this function is a no-op.
**
** If a negative value is passed to this function, then the current
** transaction is rolled back. This is different to calling 
** sqlite3PagerRollback() because this function does not terminate
** the transaction or unlock the database, it just restores the 
** contents of the database to its original state. 
**
** In any case, all savepoints with an index greater than iSavepoint 
** are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),
** then savepoint iSavepoint is also destroyed.
**
** This function may return SQLITE_NOMEM if a memory allocation fails,
** or an IO error code if an IO error occurs while rolling back a 
** savepoint. If no errors occur, SQLITE_OK is returned.
*/ 
int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){
  
// ABS Label 2022
if(pPager->errCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2022);
}
int rc = pPager->errCode;
  
#ifdef SQLITE_ENABLE_ZIPVFS
  if( op==SAVEPOINT_RELEASE ) rc = SQLITE_OK;
#endif

  assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );
  assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK );

  
// ABS Label 2023
if(iSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2023);
}
// ABS Label 2024
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2024);
}
// ABS Label 2025
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2025);
}

// COR Label 2026
if((rc == 0 || iSavepoint < pPager->nSavepoint) != (rc == 0 && iSavepoint < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2026);
}

// ROR Label 2027
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2027);
}
// ROR Label 2028
if((iSavepoint <= pPager->nSavepoint) != (iSavepoint < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2028);
}
// ROR Label 2029
if((iSavepoint > pPager->nSavepoint) != (iSavepoint < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2029);
}
// ROR Label 2030
if((iSavepoint >= pPager->nSavepoint) != (iSavepoint < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2030);
}

// MCC Label 2031
if(rc == 0 && iSavepoint < pPager->nSavepoint ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2031);
}
// MCC Label 2032
if(rc == 0 && !(iSavepoint < pPager->nSavepoint) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2032);
}
// MCC Label 2033
if(!(rc == 0) && iSavepoint < pPager->nSavepoint ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2033);
}
// MCC Label 2034
if(!(rc == 0) && !(iSavepoint < pPager->nSavepoint) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2034);
}
if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){
    int ii;            /* Iterator variable */
    int nNew;          /* Number of remaining savepoints after this op. */

    /* Figure out how many savepoints will still be active after this
    ** operation. Store this value in nNew. Then free resources associated 
    ** with any savepoints that are destroyed by this operation.
    */
    nNew = iSavepoint + (( op==SAVEPOINT_RELEASE ) ? 0 : 1);
    ii = nNew;

// ABS Label 2035
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2035);
}
// ABS Label 2036
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2036);
}

// ROR Label 2037
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2037);
}
// ROR Label 2038
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2038);
}
// ROR Label 2039
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2039);
}
for(; ii<pPager->nSavepoint; ii++){
      
// ABS Label 2045
if(pPager->aSavepoint[ii].pInSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2045);
}
sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
    };
// ABS Label 2040
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2040);
}
// ABS Label 2041
if(pPager->nSavepoint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2041);
}

// ROR Label 2042
if((ii <= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2042);
}
// ROR Label 2043
if((ii > pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2043);
}
// ROR Label 2044
if((ii >= pPager->nSavepoint) != (ii < pPager->nSavepoint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2044);
}

    pPager->nSavepoint = nNew;

    /* If this is a release of the outermost savepoint, truncate 
    ** the sub-journal to zero bytes in size. */
    
// ABS Label 2046
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2046);
}

// ROR Label 2047
if((op != 1) != (op == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2047);
}
if( op==SAVEPOINT_RELEASE ){
      PagerSavepoint *pRel = &pPager->aSavepoint[nNew];
      
// ABS Label 2048
if(pRel->bTruncateOnRelease < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2048);
}

// COR Label 2049
if((pRel->bTruncateOnRelease || ((pPager->sjfd)->pMethods != 0)) != (pRel->bTruncateOnRelease && ((pPager->sjfd)->pMethods != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2049);
}

// MCC Label 2050
if(pRel->bTruncateOnRelease && ( (pPager->sjfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2050);
}
// MCC Label 2051
if(pRel->bTruncateOnRelease && ( !((pPager->sjfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2051);
}
// MCC Label 2052
if(!(pRel->bTruncateOnRelease) && ( (pPager->sjfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2052);
}
// MCC Label 2053
if(!(pRel->bTruncateOnRelease) && ( !((pPager->sjfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2053);
}
if( pRel->bTruncateOnRelease && isOpen(pPager->sjfd) ){
        /* Only truncate if it is an in-memory sub-journal. */
        if( sqlite3JournalIsInMemory(pPager->sjfd) ){
          i64 sz = (pPager->pageSize+4)*pRel->iSubRec;
          rc = sqlite3OsTruncate(pPager->sjfd, sz);
          assert( rc==SQLITE_OK );
        }
        pPager->nSubRec = pRel->iSubRec;
      }
    }
    /* Else this is a rollback operation, playback the specified savepoint.
    ** If this is a temp-file, it is possible that the journal file has
    ** not yet been opened. In this case there have been no changes to
    ** the database file, so the playback operation can be skipped.
    */
    else { 
// COR Label 2054
if((((pPager)->pWal != 0) && ((pPager->jfd)->pMethods != 0)) != (((pPager)->pWal != 0) || ((pPager->jfd)->pMethods != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2054);
}

// MCC Label 2055
if(( (pPager)->pWal != 0 ) && ( (pPager->jfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2055);
}
// MCC Label 2056
if(( (pPager)->pWal != 0 ) && ( !((pPager->jfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2056);
}
// MCC Label 2057
if(( !((pPager)->pWal != 0) ) && ( (pPager->jfd)->pMethods != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2057);
}
// MCC Label 2058
if(( !((pPager)->pWal != 0) ) && ( !((pPager->jfd)->pMethods != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2058);
}
if( pagerUseWal(pPager) || isOpen(pPager->jfd) ){
      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];
      rc = pagerPlaybackSavepoint(pPager, pSavepoint);
      assert(rc!=SQLITE_DONE);
    };}

    
#ifdef SQLITE_ENABLE_ZIPVFS
    /* If the cache has been modified but the savepoint cannot be rolled 
    ** back journal_mode=off, put the pager in the error state. This way,
    ** if the VFS used by this pager includes ZipVFS, the entire transaction
    ** can be rolled back at the ZipVFS level.  */
    else if( 
        pPager->journalMode==PAGER_JOURNALMODE_OFF 
     && pPager->eState>=PAGER_WRITER_CACHEMOD
    ){
      pPager->errCode = SQLITE_ABORT;
      pPager->eState = PAGER_ERROR;
      setGetterMethod(pPager);
    }
#endif
  }

  
// ABS Label 2059
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2059);
}
return rc;
}

/*
** Return the full pathname of the database file.
**
** Except, if the pager is in-memory only, then return an empty string if
** nullIfMemDb is true.  This routine is called with nullIfMemDb==1 when
** used to report the filename to the user, for compatibility with legacy
** behavior.  But when the Btree needs to know the filename for matching to
** shared cache, it uses nullIfMemDb==0 so that in-memory databases can
** participate in shared-cache.
**
** The return value to this routine is always safe to use with
** sqlite3_uri_parameter() and sqlite3_filename_database() and friends.
*/
const char *sqlite3PagerFilename(const Pager *pPager, int nullIfMemDb){
  static const char zFake[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  return (nullIfMemDb && pPager->memDb) ? &zFake[4] : pPager->zFilename;
}

/*
** Return the VFS structure for the pager.
*/
sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){
  
// ABS Label 2060
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2060);
}
return pPager->pVfs;
}

/*
** Return the file handle for the database file associated
** with the pager.  This might return NULL if the file has
** not yet been opened.
*/
sqlite3_file *sqlite3PagerFile(Pager *pPager){
  
// ABS Label 2061
if(pPager->fd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2061);
}
return pPager->fd;
}

/*
** Return the file handle for the journal file (if it exists).
** This will be either the rollback journal or the WAL file.
*/
sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){
#if SQLITE_OMIT_WAL
  return pPager->jfd;
#else
  return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;
#endif
}

/*
** Return the full pathname of the journal file.
*/
const char *sqlite3PagerJournalname(Pager *pPager){
  return pPager->zJournal;
}

#ifndef SQLITE_OMIT_AUTOVACUUM
/*
** Move the page pPg to location pgno in the file.
**
** There must be no references to the page previously located at
** pgno (which we call pPgOld) though that page is allowed to be
** in cache.  If the page previously located at pgno is not already
** in the rollback journal, it is not put there by by this routine.
**
** References to the page pPg remain valid. Updating any
** meta-data associated with pPg (i.e. data stored in the nExtra bytes
** allocated along with the page) is the responsibility of the caller.
**
** A transaction must be active when this routine is called. It used to be
** required that a statement transaction was not active, but this restriction
** has been removed (CREATE INDEX needs to move a page when a statement
** transaction is active).
**
** If the fourth argument, isCommit, is non-zero, then this page is being
** moved as part of a database reorganization just before the transaction 
** is being committed. In this case, it is guaranteed that the database page 
** pPg refers to will not be written to again within this transaction.
**
** This function may return SQLITE_NOMEM or an IO error code if an error
** occurs. Otherwise, it returns SQLITE_OK.
*/
int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){
  PgHdr *pPgOld;               /* The page being overwritten. */
  Pgno needSyncPgno = 0;       /* Old value of pPg->pgno, if sync is required */
  int rc;                      /* Return code */
  Pgno origPgno;               /* The original page number */

  assert( pPg->nRef>0 );
  assert( pPager->eState==PAGER_WRITER_CACHEMOD
       || pPager->eState==PAGER_WRITER_DBMOD
  );
  assert( assert_pager_state(pPager) );

  /* In order to be able to rollback, an in-memory database must journal
  ** the page we are moving from.
  */
  assert( pPager->tempFile || !MEMDB );
  
// ABS Label 2065
if(pPager->tempFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2065);
}
if( pPager->tempFile ){
    rc = sqlite3PagerWrite(pPg);
    
// ABS Label 2066
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2066);
}
if( rc ) { 
// ABS Label 2067
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2067);
}
return rc;
}
  }

  /* If the page being moved is dirty and has not been saved by the latest
  ** savepoint, then save the current contents of the page into the 
  ** sub-journal now. This is required to handle the following scenario:
  **
  **   BEGIN;
  **     <journal page X, then modify it in memory>
  **     SAVEPOINT one;
  **       <Move page X to location Y>
  **     ROLLBACK TO one;
  **
  ** If page X were not written to the sub-journal here, it would not
  ** be possible to restore its contents when the "ROLLBACK TO one"
  ** statement were is processed.
  **
  ** subjournalPage() may need to allocate space to store pPg->pgno into
  ** one or more savepoint bitvecs. This is the reason this function
  ** may return SQLITE_NOMEM.
  */
  if( (pPg->flags & PGHDR_DIRTY)!=0
   && SQLITE_OK!=(rc = subjournalPageIfRequired(pPg))
  ){
    
// ABS Label 2068
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2068);
}
return rc;
  }

  PAGERTRACE(("MOVE %d page %d (needSync=%d) moves to %d\n", 
      PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC)?1:0, pgno));
  IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno))

  /* If the journal needs to be sync()ed before page pPg->pgno can
  ** be written to, store pPg->pgno in local variable needSyncPgno.
  **
  ** If the isCommit flag is set, there is no need to remember that
  ** the journal needs to be sync()ed before database page pPg->pgno 
  ** can be written to. The caller has already promised not to write to it.
  */
  
// COR Label 2069
if(((pPg->flags & 8) || !isCommit) != ((pPg->flags & 8) && !isCommit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2069);
}

// MCC Label 2070
if(( pPg->flags & 8 ) && !isCommit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2070);
}
// MCC Label 2071
if(( pPg->flags & 8 ) && !(!isCommit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2071);
}
// MCC Label 2072
if(( !(pPg->flags & 8) ) && !isCommit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2072);
}
// MCC Label 2073
if(( !(pPg->flags & 8) ) && !(!isCommit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2073);
}
if( (pPg->flags&PGHDR_NEED_SYNC) && !isCommit ){
    needSyncPgno = pPg->pgno;
    assert( pPager->journalMode==PAGER_JOURNALMODE_OFF ||
            pageInJournal(pPager, pPg) || pPg->pgno>pPager->dbOrigSize );
    assert( pPg->flags&PGHDR_DIRTY );
  }

  /* If the cache contains a page with page-number pgno, remove it
  ** from its hash chain. Also, if the PGHDR_NEED_SYNC flag was set for 
  ** page pgno before the 'move' operation, it needs to be retained 
  ** for the page moved there.
  */
  pPg->flags &= ~PGHDR_NEED_SYNC;
  pPgOld = sqlite3PagerLookup(pPager, pgno);
  assert( !pPgOld || pPgOld->nRef==1 || CORRUPT_DB );
  
// ABS Label 2074
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2074);
}
if( pPgOld ){
    
// ROR Label 2075
if((pPgOld->nRef <= 1) != (pPgOld->nRef > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2075);
}
// ROR Label 2076
if((pPgOld->nRef < 1) != (pPgOld->nRef > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2076);
}
// ROR Label 2077
if((pPgOld->nRef >= 1) != (pPgOld->nRef > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2077);
}
if( pPgOld->nRef>1 ){
      
// ABS Label 2078
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2078);
}
sqlite3PagerUnrefNotNull(pPgOld);
      return SQLITE_CORRUPT_BKPT;
    }
    pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC);
    
// ABS Label 2079
if(pPager->tempFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2079);
}
if( pPager->tempFile ){
      /* Do not discard pages from an in-memory database since we might
      ** need to rollback later.  Just move the page out of the way. */
      
// ABS Label 2080
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2080);
}

// ABS Label 2081
if(pPager->dbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2081);
}

// AOR Label 2082
if(pPager->dbSize - 1 != pPager->dbSize + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2082);
}
// AOR Label 2083
if(pPager->dbSize / 1 != pPager->dbSize + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2083);
}
// AOR Label 2084
if(pPager->dbSize * 1 != pPager->dbSize + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2084);
}
sqlite3PcacheMove(pPgOld, pPager->dbSize+1);
    }else{
      
// ABS Label 2085
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2085);
}
sqlite3PcacheDrop(pPgOld);
    }
  }

  origPgno = pPg->pgno;
  
// ABS Label 2062
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2062);
}

// ABS Label 2063
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2063);
}
sqlite3PcacheMove(pPg, pgno);
  
// ABS Label 2064
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2064);
}
sqlite3PcacheMakeDirty(pPg);

  /* For an in-memory database, make sure the original page continues
  ** to exist, in case the transaction needs to roll back.  Use pPgOld
  ** as the original page since it has already been allocated.
  */
  
// ABS Label 2086
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2086);
}

// COR Label 2087
if((pPager->tempFile || pPgOld) != (pPager->tempFile && pPgOld))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2087);
}

// MCC Label 2088
if(pPager->tempFile && pPgOld ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2088);
}
// MCC Label 2089
if(pPager->tempFile && !(pPgOld) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2089);
}
// MCC Label 2090
if(!(pPager->tempFile) && pPgOld ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2090);
}
// MCC Label 2091
if(!(pPager->tempFile) && !(pPgOld) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2091);
}
if( pPager->tempFile && pPgOld ){
    
// ABS Label 2092
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2092);
}

// ABS Label 2093
if(origPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2093);
}
sqlite3PcacheMove(pPgOld, origPgno);
    
// ABS Label 2094
if(pPgOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2094);
}
sqlite3PagerUnrefNotNull(pPgOld);
  }

  
// ABS Label 2095
if(needSyncPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2095);
}
if( needSyncPgno ){
    /* If needSyncPgno is non-zero, then the journal file needs to be 
    ** sync()ed before any data is written to database file page needSyncPgno.
    ** Currently, no such page exists in the page-cache and the 
    ** "is journaled" bitvec flag has been set. This needs to be remedied by
    ** loading the page into the pager-cache and setting the PGHDR_NEED_SYNC
    ** flag.
    **
    ** If the attempt to load the page into the page-cache fails, (due
    ** to a malloc() or IO failure), clear the bit in the pInJournal[]
    ** array. Otherwise, if the page is loaded and written again in
    ** this transaction, it may be written to the database file before
    ** it is synced into the journal file. This way, it may end up in
    ** the journal file twice, but that is not a problem.
    */
    PgHdr *pPgHdr;
    rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);
    
// ABS Label 2098
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2098);
}

// ROR Label 2099
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2099);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 2100
if(needSyncPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2100);
}
// ABS Label 2101
if(pPager->dbOrigSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2101);
}

// ROR Label 2102
if((needSyncPgno < pPager->dbOrigSize) != (needSyncPgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2102);
}
// ROR Label 2103
if((needSyncPgno > pPager->dbOrigSize) != (needSyncPgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2103);
}
// ROR Label 2104
if((needSyncPgno >= pPager->dbOrigSize) != (needSyncPgno <= pPager->dbOrigSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2104);
}
if( needSyncPgno<=pPager->dbOrigSize ){
        assert( pPager->pTmpSpace!=0 );
        
// ABS Label 2105
if(pPager->pInJournal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2105);
}

// ABS Label 2106
if(needSyncPgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2106);
}
sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
      }
      
// ABS Label 2107
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2107);
}
return rc;
    }
    pPgHdr->flags |= PGHDR_NEED_SYNC;
    
// ABS Label 2096
if(pPgHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2096);
}
sqlite3PcacheMakeDirty(pPgHdr);
    
// ABS Label 2097
if(pPgHdr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2097);
}
sqlite3PagerUnrefNotNull(pPgHdr);
  }

  return SQLITE_OK;
}
#endif

/*
** The page handle passed as the first argument refers to a dirty page 
** with a page number other than iNew. This function changes the page's 
** page number to iNew and sets the value of the PgHdr.flags field to 
** the value passed as the third parameter.
*/
void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){
  assert( pPg->pgno!=iNew );
  pPg->flags = flags;
  
// ABS Label 2108
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2108);
}

// ABS Label 2109
if(iNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2109);
}
sqlite3PcacheMove(pPg, iNew);
}

/*
** Return a pointer to the data for the specified page.
*/
void *sqlite3PagerGetData(DbPage *pPg){
  assert( pPg->nRef>0 || pPg->pPager->memDb );
  
// ABS Label 2110
if(pPg->pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2110);
}
return pPg->pData;
}

/*
** Return a pointer to the Pager.nExtra bytes of "extra" space 
** allocated along with the specified page.
*/
void *sqlite3PagerGetExtra(DbPage *pPg){
  
// ABS Label 2111
if(pPg->pExtra < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2111);
}
return pPg->pExtra;
}

/*
** Get/set the locking-mode for this pager. Parameter eMode must be one
** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or 
** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then
** the locking-mode is set to the value specified.
**
** The returned value is either PAGER_LOCKINGMODE_NORMAL or
** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)
** locking-mode.
*/
int sqlite3PagerLockingMode(Pager *pPager, int eMode){
  assert( eMode==PAGER_LOCKINGMODE_QUERY
            || eMode==PAGER_LOCKINGMODE_NORMAL
            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );
  assert( PAGER_LOCKINGMODE_QUERY<0 );
  assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );
  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );
  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){
    pPager->exclusiveMode = (u8)eMode;
  }
  return (int)pPager->exclusiveMode;
}

/*
** Set the journal-mode for this pager. Parameter eMode must be one of:
**
**    PAGER_JOURNALMODE_DELETE
**    PAGER_JOURNALMODE_TRUNCATE
**    PAGER_JOURNALMODE_PERSIST
**    PAGER_JOURNALMODE_OFF
**    PAGER_JOURNALMODE_MEMORY
**    PAGER_JOURNALMODE_WAL
**
** The journalmode is set to the value specified if the change is allowed.
** The change may be disallowed for the following reasons:
**
**   *  An in-memory database can only have its journal_mode set to _OFF
**      or _MEMORY.
**
**   *  Temporary databases cannot have _WAL journalmode.
**
** The returned indicate the current (possibly updated) journal-mode.
*/
int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){
  
// ABS Label 2112
if(pPager->journalMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2112);
}
u8 eOld = pPager->journalMode;    /* Prior journalmode */

  /* The eMode parameter is always valid */
  assert(      eMode==PAGER_JOURNALMODE_DELETE
            || eMode==PAGER_JOURNALMODE_TRUNCATE
            || eMode==PAGER_JOURNALMODE_PERSIST
            || eMode==PAGER_JOURNALMODE_OFF 
            || eMode==PAGER_JOURNALMODE_WAL 
            || eMode==PAGER_JOURNALMODE_MEMORY );

  /* This routine is only called from the OP_JournalMode opcode, and
  ** the logic there will never allow a temporary file to be changed
  ** to WAL mode.
  */
  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL );

  /* Do allow the journalmode of an in-memory database to be set to
  ** anything other than MEMORY or OFF
  */
  
// ABS Label 2113
if(pPager->memDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2113);
}
if( MEMDB ){
    assert( eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF );
    
// ABS Label 2114
if(eMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2114);
}

// COR Label 2115
if((eMode != 4 || eMode != 2) != (eMode != 4 && eMode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2115);
}

// ROR Label 2116
if((eMode == 4) != (eMode != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2116);
}
// ROR Label 2117
if((eMode == 2) != (eMode != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2117);
}

// MCC Label 2118
if(eMode != 4 && eMode != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2118);
}
// MCC Label 2119
if(eMode != 4 && !(eMode != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2119);
}
// MCC Label 2120
if(!(eMode != 4) && eMode != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2120);
}
// MCC Label 2121
if(!(eMode != 4) && !(eMode != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2121);
}
if( eMode!=PAGER_JOURNALMODE_MEMORY && eMode!=PAGER_JOURNALMODE_OFF ){
      eMode = eOld;
    }
  }

  
// ABS Label 2122
if(eMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2122);
}

// ROR Label 2123
if((eMode == eOld) != (eMode != eOld))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2123);
}
if( eMode!=eOld ){

    /* Change the journal mode. */
    assert( pPager->eState!=PAGER_ERROR );
    pPager->journalMode = (u8)eMode;

    /* When transistioning from TRUNCATE or PERSIST to any other journal
    ** mode except WAL, unless the pager is in locking_mode=exclusive mode,
    ** delete the journal file.
    */
    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );
    assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );
    assert( (PAGER_JOURNALMODE_DELETE & 5)==0 );
    assert( (PAGER_JOURNALMODE_MEMORY & 5)==4 );
    assert( (PAGER_JOURNALMODE_OFF & 5)==0 );
    assert( (PAGER_JOURNALMODE_WAL & 5)==5 );

    assert( isOpen(pPager->fd) || pPager->exclusiveMode );
    
// COR Label 2124
if((!pPager->exclusiveMode && (eOld & 5) == 1 || (eMode & 1) == 0) != (!pPager->exclusiveMode && (eOld & 5) == 1 && (eMode & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2124);
}
// COR Label 2125
if((!pPager->exclusiveMode || (eOld & 5) == 1) != (!pPager->exclusiveMode && (eOld & 5) == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2125);
}

// ROR Label 2126
if(((eOld & 5) != 1) != ((eOld & 5) == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2126);
}
// ROR Label 2127
if(((eMode & 1) != 0) != ((eMode & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2127);
}

// MCC Label 2128
if(!pPager->exclusiveMode && (eOld & 5) == 1 && (eMode & 1) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2128);
}
// MCC Label 2129
if(!pPager->exclusiveMode && (eOld & 5) == 1 && !((eMode & 1) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2129);
}
// MCC Label 2130
if(!pPager->exclusiveMode && !((eOld & 5) == 1) && (eMode & 1) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2130);
}
// MCC Label 2131
if(!pPager->exclusiveMode && !((eOld & 5) == 1) && !((eMode & 1) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2131);
}
// MCC Label 2132
if(!(!pPager->exclusiveMode) && (eOld & 5) == 1 && (eMode & 1) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2132);
}
// MCC Label 2133
if(!(!pPager->exclusiveMode) && (eOld & 5) == 1 && !((eMode & 1) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2133);
}
// MCC Label 2134
if(!(!pPager->exclusiveMode) && !((eOld & 5) == 1) && (eMode & 1) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2134);
}
// MCC Label 2135
if(!(!pPager->exclusiveMode) && !((eOld & 5) == 1) && !((eMode & 1) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2135);
}
if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){

      /* In this case we would like to delete the journal file. If it is
      ** not possible, then that is not a problem. Deleting the journal file
      ** here is an optimization only.
      **
      ** Before deleting the journal file, obtain a RESERVED lock on the
      ** database file. This ensures that the journal file is not deleted
      ** while it is in use by some other client.
      */
      
// ABS Label 2136
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2136);
}
sqlite3OsClose(pPager->jfd);
      
// ROR Label 2137
if((pPager->eLock < 2) != (pPager->eLock >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2137);
}
// ROR Label 2138
if((pPager->eLock > 2) != (pPager->eLock >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2138);
}
// ROR Label 2139
if((pPager->eLock <= 2) != (pPager->eLock >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2139);
}
if( pPager->eLock>=RESERVED_LOCK ){
        
// ABS Label 2140
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2140);
}
sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
      }else{
        int rc = SQLITE_OK;
        int state = pPager->eState;
        assert( state==PAGER_OPEN || state==PAGER_READER );
        
// ABS Label 2141
if(state < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2141);
}

// ROR Label 2142
if((state != 0) != (state == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2142);
}
if( state==PAGER_OPEN ){
          rc = sqlite3PagerSharedLock(pPager);
        }
        
// ROR Label 2143
if((pPager->eState != 1) != (pPager->eState == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2143);
}
if( pPager->eState==PAGER_READER ){
          assert( rc==SQLITE_OK );
          rc = pagerLockDb(pPager, RESERVED_LOCK);
        }
        
// ABS Label 2144
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2144);
}

// ROR Label 2145
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2145);
}
if( rc==SQLITE_OK ){
          
// ABS Label 2146
if(pPager->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2146);
}
sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
        }
        
// ABS Label 2147
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2147);
}
// ABS Label 2148
if(state < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2148);
}

// COR Label 2149
if((rc == 0 || state == 1) != (rc == 0 && state == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2149);
}

// ROR Label 2150
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2150);
}
// ROR Label 2151
if((state != 1) != (state == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2151);
}

// MCC Label 2152
if(rc == 0 && state == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2152);
}
// MCC Label 2153
if(rc == 0 && !(state == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2153);
}
// MCC Label 2154
if(!(rc == 0) && state == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2154);
}
// MCC Label 2155
if(!(rc == 0) && !(state == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2155);
}
if( rc==SQLITE_OK && state==PAGER_READER ){
          
// ABS Label 2156
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2156);
}
pagerUnlockDb(pPager, SHARED_LOCK);
        }else { 
// ABS Label 2157
if(state < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2157);
}

// ROR Label 2158
if((state != 0) != (state == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2158);
}
if( state==PAGER_OPEN ){
          
// ABS Label 2159
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2159);
}
pager_unlock(pPager);
        };}

        assert( state==pPager->eState );
      }
    }else { 
// ABS Label 2160
if(eMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2160);
}

// ROR Label 2161
if((eMode != 2) != (eMode == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2161);
}
if( eMode==PAGER_JOURNALMODE_OFF ){
      
// ABS Label 2162
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2162);
}
sqlite3OsClose(pPager->jfd);
    };}

  }

  /* Return the new journal mode */
  return (int)pPager->journalMode;
}

/*
** Return the current journal mode.
*/
int sqlite3PagerGetJournalMode(Pager *pPager){
  return (int)pPager->journalMode;
}

/*
** Return TRUE if the pager is in a state where it is OK to change the
** journalmode.  Journalmode changes can only happen when the database
** is unmodified.
*/
int sqlite3PagerOkToChangeJournalMode(Pager *pPager){
  assert( assert_pager_state(pPager) );
  
// ROR Label 2163
if((pPager->eState < 3) != (pPager->eState >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2163);
}
// ROR Label 2164
if((pPager->eState > 3) != (pPager->eState >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2164);
}
// ROR Label 2165
if((pPager->eState <= 3) != (pPager->eState >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2165);
}
if( pPager->eState>=PAGER_WRITER_CACHEMOD ) { return 0;
}
  
// MCC Label 2166
if(( ( (pPager->jfd)->pMethods != 0 ) && pPager->journalOff > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2166);
}
// MCC Label 2167
if(( ( (pPager->jfd)->pMethods != 0 ) && !(pPager->journalOff > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2167);
}
// MCC Label 2168
if(( ( !((pPager->jfd)->pMethods != 0) ) && pPager->journalOff > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2168);
}
// MCC Label 2169
if(( ( !((pPager->jfd)->pMethods != 0) ) && !(pPager->journalOff > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2169);
}
if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) { return 0;
}
  return 1;
}

/*
** Get/set the size-limit used for persistent journal files.
**
** Setting the size limit to -1 means no limit is enforced.
** An attempt to set a limit smaller than -1 is a no-op.
*/
i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){
  
// ABS Label 2170
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2170);
}

// ROR Label 2171
if((iLimit < -1) != (iLimit >= -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2171);
}
// ROR Label 2172
if((iLimit > -1) != (iLimit >= -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2172);
}
// ROR Label 2173
if((iLimit <= -1) != (iLimit >= -1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2173);
}
if( iLimit>=-1 ){
    pPager->journalSizeLimit = iLimit;
    
// ABS Label 2174
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2174);
}

// ABS Label 2175
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2175);
}
sqlite3WalLimit(pPager->pWal, iLimit);
  }
  
// ABS Label 2176
if(pPager->journalSizeLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2176);
}
return pPager->journalSizeLimit;
}

/*
** Return a pointer to the pPager->pBackup variable. The backup module
** in backup.c maintains the content of this variable. This module
** uses it opaquely as an argument to sqlite3BackupRestart() and
** sqlite3BackupUpdate() only.
*/
sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){
  return &pPager->pBackup;
}

#ifndef SQLITE_OMIT_VACUUM
/*
** Unless this is an in-memory or temporary database, clear the pager cache.
*/
void sqlite3PagerClearCache(Pager *pPager){
  assert( MEMDB==0 || pPager->tempFile );
  
// ROR Label 2177
if((pPager->tempFile != 0) != (pPager->tempFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2177);
}
if( pPager->tempFile==0 ) { 
// ABS Label 2178
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2178);
}
pager_reset(pPager);
}
}
#endif


#ifndef SQLITE_OMIT_WAL
/*
** This function is called when the user invokes "PRAGMA wal_checkpoint",
** "PRAGMA wal_blocking_checkpoint" or calls the sqlite3_wal_checkpoint()
** or wal_blocking_checkpoint() API functions.
**
** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.
*/
int sqlite3PagerCheckpoint(
  Pager *pPager,                  /* Checkpoint on this pager */
  sqlite3 *db,                    /* Db handle used to check for interrupts */
  int eMode,                      /* Type of checkpoint */
  int *pnLog,                     /* OUT: Final number of frames in log */
  int *pnCkpt                     /* OUT: Final number of checkpointed frames */
){
  int rc = SQLITE_OK;
  
// ABS Label 2179
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2179);
}
if( pPager->pWal ){
    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,
        (eMode==SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager->xBusyHandler),
        pPager->pBusyHandlerArg,
        pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
        pnLog, pnCkpt
    );
  }
  
// ABS Label 2180
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2180);
}
return rc;
}

int sqlite3PagerWalCallback(Pager *pPager){
  return sqlite3WalCallback(pPager->pWal);
}

/*
** Return true if the underlying VFS for the given pager supports the
** primitives necessary for write-ahead logging.
*/
int sqlite3PagerWalSupported(Pager *pPager){
  
// ABS Label 2181
if(pPager->fd->pMethods < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2181);
}
const sqlite3_io_methods *pMethods = pPager->fd->pMethods;
  
// ABS Label 2182
if(pPager->noLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2182);
}
if( pPager->noLock ) { return 0;
}
  
// COR Label 2183
if((pPager->exclusiveMode && (pMethods->iVersion >= 2 && pMethods->xShmMap)) != (pPager->exclusiveMode || (pMethods->iVersion >= 2 && pMethods->xShmMap)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2183);
}

// MCC Label 2184
if(pPager->exclusiveMode && ( pMethods->iVersion >= 2 && pMethods->xShmMap ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2184);
}
// MCC Label 2185
if(pPager->exclusiveMode && ( pMethods->iVersion >= 2 && !(pMethods->xShmMap) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2185);
}
// MCC Label 2186
if(pPager->exclusiveMode && ( !(pMethods->iVersion >= 2) && pMethods->xShmMap ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2186);
}
// MCC Label 2187
if(pPager->exclusiveMode && ( !(pMethods->iVersion >= 2) && !(pMethods->xShmMap) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2187);
}
// MCC Label 2188
if(!(pPager->exclusiveMode) && ( pMethods->iVersion >= 2 && pMethods->xShmMap ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2188);
}
// MCC Label 2189
if(!(pPager->exclusiveMode) && ( pMethods->iVersion >= 2 && !(pMethods->xShmMap) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2189);
}
// MCC Label 2190
if(!(pPager->exclusiveMode) && ( !(pMethods->iVersion >= 2) && pMethods->xShmMap ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2190);
}
// MCC Label 2191
if(!(pPager->exclusiveMode) && ( !(pMethods->iVersion >= 2) && !(pMethods->xShmMap) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2191);
}
return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);
}

/*
** Attempt to take an exclusive lock on the database file. If a PENDING lock
** is obtained instead, immediately release it.
*/
static int pagerExclusiveLock(Pager *pPager){
  int rc;                         /* Return code */

  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );
  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);
  
// ABS Label 2192
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2192);
}

// ROR Label 2193
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2193);
}
if( rc!=SQLITE_OK ){
    /* If the attempt to grab the exclusive lock failed, release the 
    ** pending lock that may have been obtained instead.  */
    
// ABS Label 2194
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2194);
}
pagerUnlockDb(pPager, SHARED_LOCK);
  }

  
// ABS Label 2195
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2195);
}
return rc;
}

/*
** Call sqlite3WalOpen() to open the WAL handle. If the pager is in 
** exclusive-locking mode when this function is called, take an EXCLUSIVE
** lock on the database file and use heap-memory to store the wal-index
** in. Otherwise, use the normal shared-memory.
*/
static int pagerOpenWal(Pager *pPager){
  int rc = SQLITE_OK;

  assert( pPager->pWal==0 && pPager->tempFile==0 );
  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );

  /* If the pager is already in exclusive-mode, the WAL module will use 
  ** heap-memory for the wal-index instead of the VFS shared-memory 
  ** implementation. Take the exclusive lock now, before opening the WAL
  ** file, to make sure this is safe.
  */
  
// ABS Label 2197
if(pPager->exclusiveMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2197);
}
if( pPager->exclusiveMode ){
    rc = pagerExclusiveLock(pPager);
  }

  /* Open the connection to the log file. If this operation fails, 
  ** (e.g. due to malloc() failure), return an error code.
  */
  
// ABS Label 2198
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2198);
}

// ROR Label 2199
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2199);
}
if( rc==SQLITE_OK ){
    rc = sqlite3WalOpen(pPager->pVfs,
        pPager->fd, pPager->zWal, pPager->exclusiveMode,
        pPager->journalSizeLimit, &pPager->pWal
    );
  }
  
// ABS Label 2196
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2196);
}
pagerFixMaplimit(pPager);

  
// ABS Label 2200
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2200);
}
return rc;
}


/*
** The caller must be holding a SHARED lock on the database file to call
** this function.
**
** If the pager passed as the first argument is open on a real database
** file (not a temp file or an in-memory database), and the WAL file
** is not already open, make an attempt to open it now. If successful,
** return SQLITE_OK. If an error occurs or the VFS used by the pager does 
** not support the xShmXXX() methods, return an error code. *pbOpen is
** not modified in either case.
**
** If the pager is open on a temp-file (or in-memory database), or if
** the WAL file is already open, set *pbOpen to 1 and return SQLITE_OK
** without doing anything.
*/
int sqlite3PagerOpenWal(
  Pager *pPager,                  /* Pager object */
  int *pbOpen                     /* OUT: Set to true if call is a no-op */
){
  int rc = SQLITE_OK;             /* Return code */

  assert( assert_pager_state(pPager) );
  assert( pPager->eState==PAGER_OPEN   || pbOpen );
  assert( pPager->eState==PAGER_READER || !pbOpen );
  assert( pbOpen==0 || *pbOpen==0 );
  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );

  
// COR Label 2201
if((!pPager->tempFile || !pPager->pWal) != (!pPager->tempFile && !pPager->pWal))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2201);
}

// MCC Label 2202
if(!pPager->tempFile && !pPager->pWal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2202);
}
// MCC Label 2203
if(!pPager->tempFile && !(!pPager->pWal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2203);
}
// MCC Label 2204
if(!(!pPager->tempFile) && !pPager->pWal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2204);
}
// MCC Label 2205
if(!(!pPager->tempFile) && !(!pPager->pWal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2205);
}
if( !pPager->tempFile && !pPager->pWal ){
    if( !sqlite3PagerWalSupported(pPager) ) { return SQLITE_CANTOPEN;
}

    /* Close any rollback journal previously open */
    
// ABS Label 2206
if(pPager->jfd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2206);
}
sqlite3OsClose(pPager->jfd);

    rc = pagerOpenWal(pPager);
    
// ABS Label 2207
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2207);
}

// ROR Label 2208
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2208);
}
if( rc==SQLITE_OK ){
      pPager->journalMode = PAGER_JOURNALMODE_WAL;
      pPager->eState = PAGER_OPEN;
    }
  }else{
    *pbOpen = 1;
  }

  
// ABS Label 2209
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2209);
}
return rc;
}

/*
** This function is called to close the connection to the log file prior
** to switching from WAL to rollback mode.
**
** Before closing the log file, this function attempts to take an 
** EXCLUSIVE lock on the database file. If this cannot be obtained, an
** error (SQLITE_BUSY) is returned and the log connection is not closed.
** If successful, the EXCLUSIVE lock is not released before returning.
*/
int sqlite3PagerCloseWal(Pager *pPager, sqlite3 *db){
  int rc = SQLITE_OK;

  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL );

  /* If the log file is not already open, but does exist in the file-system,
  ** it may need to be checkpointed before the connection can switch to
  ** rollback mode. Open it now so this can happen.
  */
  if( !pPager->pWal ){
    int logexists = 0;
    rc = pagerLockDb(pPager, SHARED_LOCK);
    
// ABS Label 2210
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2210);
}

// ROR Label 2211
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2211);
}
if( rc==SQLITE_OK ){
      rc = sqlite3OsAccess(
          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists
      );
    }
    
// ABS Label 2212
if(logexists < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2212);
}
// ABS Label 2213
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2213);
}

// COR Label 2214
if((rc == 0 || logexists) != (rc == 0 && logexists))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2214);
}

// ROR Label 2215
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2215);
}

// MCC Label 2216
if(rc == 0 && logexists ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2216);
}
// MCC Label 2217
if(rc == 0 && !(logexists) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2217);
}
// MCC Label 2218
if(!(rc == 0) && logexists ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2218);
}
// MCC Label 2219
if(!(rc == 0) && !(logexists) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2219);
}
if( rc==SQLITE_OK && logexists ){
      rc = pagerOpenWal(pPager);
    }
  }
    
  /* Checkpoint and close the log. Because an EXCLUSIVE lock is held on
  ** the database file, the log and log-summary files will be deleted.
  */
  
// ABS Label 2220
if(pPager->pWal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2220);
}
// ABS Label 2221
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2221);
}

// COR Label 2222
if((rc == 0 || pPager->pWal) != (rc == 0 && pPager->pWal))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2222);
}

// ROR Label 2223
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2223);
}

// MCC Label 2224
if(rc == 0 && pPager->pWal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2224);
}
// MCC Label 2225
if(rc == 0 && !(pPager->pWal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2225);
}
// MCC Label 2226
if(!(rc == 0) && pPager->pWal ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2226);
}
// MCC Label 2227
if(!(rc == 0) && !(pPager->pWal) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2227);
}
if( rc==SQLITE_OK && pPager->pWal ){
    rc = pagerExclusiveLock(pPager);
    
// ABS Label 2228
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2228);
}

// ROR Label 2229
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2229);
}
if( rc==SQLITE_OK ){
      rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,
                           pPager->pageSize, (u8*)pPager->pTmpSpace);
      pPager->pWal = 0;
      
// ABS Label 2230
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2230);
}
pagerFixMaplimit(pPager);
      
// ABS Label 2231
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2231);
}

// COR Label 2232
if((rc || !pPager->exclusiveMode) != (rc && !pPager->exclusiveMode))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2232);
}

// MCC Label 2233
if(rc && !pPager->exclusiveMode ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2233);
}
// MCC Label 2234
if(rc && !(!pPager->exclusiveMode) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2234);
}
// MCC Label 2235
if(!(rc) && !pPager->exclusiveMode ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2235);
}
// MCC Label 2236
if(!(rc) && !(!pPager->exclusiveMode) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2236);
}
if( rc && !pPager->exclusiveMode ) { 
// ABS Label 2237
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2237);
}
pagerUnlockDb(pPager, SHARED_LOCK);
}
    }
  }
  
// ABS Label 2238
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2238);
}
return rc;
}

#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
/*
** If pager pPager is a wal-mode database not in exclusive locking mode,
** invoke the sqlite3WalWriteLock() function on the associated Wal object 
** with the same db and bLock parameters as were passed to this function.
** Return an SQLite error code if an error occurs, or SQLITE_OK otherwise.
*/
int sqlite3PagerWalWriteLock(Pager *pPager, int bLock){
  int rc = SQLITE_OK;
  if( pagerUseWal(pPager) && pPager->exclusiveMode==0 ){
    rc = sqlite3WalWriteLock(pPager->pWal, bLock);
  }
  return rc;
}

/*
** Set the database handle used by the wal layer to determine if 
** blocking locks are required.
*/
void sqlite3PagerWalDb(Pager *pPager, sqlite3 *db){
  if( pagerUseWal(pPager) ){
    sqlite3WalDb(pPager->pWal, db);
  }
}
#endif

#ifdef SQLITE_ENABLE_SNAPSHOT
/*
** If this is a WAL database, obtain a snapshot handle for the snapshot
** currently open. Otherwise, return an error.
*/
int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot){
  int rc = SQLITE_ERROR;
  if( pPager->pWal ){
    rc = sqlite3WalSnapshotGet(pPager->pWal, ppSnapshot);
  }
  return rc;
}

/*
** If this is a WAL database, store a pointer to pSnapshot. Next time a
** read transaction is opened, attempt to read from the snapshot it 
** identifies. If this is not a WAL database, return an error.
*/
int sqlite3PagerSnapshotOpen(
  Pager *pPager, 
  sqlite3_snapshot *pSnapshot
){
  int rc = SQLITE_OK;
  if( pPager->pWal ){
    sqlite3WalSnapshotOpen(pPager->pWal, pSnapshot);
  }else{
    rc = SQLITE_ERROR;
  }
  return rc;
}

/*
** If this is a WAL database, call sqlite3WalSnapshotRecover(). If this 
** is not a WAL database, return an error.
*/
int sqlite3PagerSnapshotRecover(Pager *pPager){
  int rc;
  if( pPager->pWal ){
    rc = sqlite3WalSnapshotRecover(pPager->pWal);
  }else{
    rc = SQLITE_ERROR;
  }
  return rc;
}

/*
** The caller currently has a read transaction open on the database.
** If this is not a WAL database, SQLITE_ERROR is returned. Otherwise,
** this function takes a SHARED lock on the CHECKPOINTER slot and then
** checks if the snapshot passed as the second argument is still 
** available. If so, SQLITE_OK is returned.
**
** If the snapshot is not available, SQLITE_ERROR is returned. Or, if
** the CHECKPOINTER lock cannot be obtained, SQLITE_BUSY. If any error
** occurs (any value other than SQLITE_OK is returned), the CHECKPOINTER
** lock is released before returning.
*/
int sqlite3PagerSnapshotCheck(Pager *pPager, sqlite3_snapshot *pSnapshot){
  int rc;
  if( pPager->pWal ){
    rc = sqlite3WalSnapshotCheck(pPager->pWal, pSnapshot);
  }else{
    rc = SQLITE_ERROR;
  }
  return rc;
}

/*
** Release a lock obtained by an earlier successful call to
** sqlite3PagerSnapshotCheck().
*/
void sqlite3PagerSnapshotUnlock(Pager *pPager){
  assert( pPager->pWal );
  sqlite3WalSnapshotUnlock(pPager->pWal);
}

#endif /* SQLITE_ENABLE_SNAPSHOT */
#endif /* !SQLITE_OMIT_WAL */

#ifdef SQLITE_ENABLE_ZIPVFS
/*
** A read-lock must be held on the pager when this function is called. If
** the pager is in WAL mode and the WAL file currently contains one or more
** frames, return the size in bytes of the page images stored within the
** WAL frames. Otherwise, if this is not a WAL database or the WAL file
** is empty, return 0.
*/
int sqlite3PagerWalFramesize(Pager *pPager){
  assert( pPager->eState>=PAGER_READER );
  return sqlite3WalFramesize(pPager->pWal);
}
#endif

#endif /* SQLITE_OMIT_DISKIO */
