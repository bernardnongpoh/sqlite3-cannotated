/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2016-09-07
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file implements an in-memory VFS. A database is held as a contiguous
** block of memory.
**
** This file also implements interface sqlite3_serialize() and
** sqlite3_deserialize().
*/
#include "sqliteInt.h"
#ifndef SQLITE_OMIT_DESERIALIZE

/*
** Forward declaration of objects used by this utility
*/
typedef struct sqlite3_vfs MemVfs;
typedef struct MemFile MemFile;
typedef struct MemStore MemStore;

/* Access to a lower-level VFS that (might) implement dynamic loading,
** access to randomness, etc.
*/
#define ORIGVFS(p) ((sqlite3_vfs*)((p)->pAppData))

/* Storage for a memdb file.
**
** An memdb object can be shared or separate.  Shared memdb objects can be
** used by more than one database connection.  Mutexes are used by shared
** memdb objects to coordinate access.  Separate memdb objects are only
** connected to a single database connection and do not require additional
** mutexes.
**
** Shared memdb objects have .zFName!=0 and .pMutex!=0.  They are created
** using "file:/name?vfs=memdb".  The first character of the name must be
** "/" or else the object will be a separate memdb object.  All shared
** memdb objects are stored in memdb_g.apMemStore[] in an arbitrary order.
**
** Separate memdb objects are created using a name that does not begin
** with "/" or using sqlite3_deserialize().
**
** Access rules for shared MemStore objects:
**
**   *  .zFName is initialized when the object is created and afterwards
**      is unchanged until the object is destroyed.  So it can be accessed
**      at any time as long as we know the object is not being destroyed,
**      which means while either the SQLITE_MUTEX_STATIC_VFS1 or
**      .pMutex is held or the object is not part of memdb_g.apMemStore[].
**
**   *  Can .pMutex can only be changed while holding the 
**      SQLITE_MUTEX_STATIC_VFS1 mutex or while the object is not part
**      of memdb_g.apMemStore[].
**
**   *  Other fields can only be changed while holding the .pMutex mutex
**      or when the .nRef is less than zero and the object is not part of
**      memdb_g.apMemStore[].
**
**   *  The .aData pointer has the added requirement that it can can only
**      be changed (for resizing) when nMmap is zero.
**      
*/
struct MemStore {
  sqlite3_int64 sz;               /* Size of the file */
  sqlite3_int64 szAlloc;          /* Space allocated to aData */
  sqlite3_int64 szMax;            /* Maximum allowed size of the file */
  unsigned char *aData;           /* content of the file */
  sqlite3_mutex *pMutex;          /* Used by shared stores only */
  int nMmap;                      /* Number of memory mapped pages */
  unsigned mFlags;                /* Flags */
  int nRdLock;                    /* Number of readers */
  int nWrLock;                    /* Number of writers.  (Always 0 or 1) */
  int nRef;                       /* Number of users of this MemStore */
  char *zFName;                   /* The filename for shared stores */
};

/* An open file */
struct MemFile {
  sqlite3_file base;              /* IO methods */
  MemStore *pStore;               /* The storage */
  int eLock;                      /* Most recent lock against this file */
};

/*
** File-scope variables for holding the memdb files that are accessible
** to multiple database connections in separate threads.
**
** Must hold SQLITE_MUTEX_STATIC_VFS1 to access any part of this object.
*/
static struct MemFS {
  int nMemStore;                  /* Number of shared MemStore objects */
  MemStore **apMemStore;          /* Array of all shared MemStore objects */
} memdb_g;

/*
** Methods for MemFile
*/
static int memdbClose(sqlite3_file*);
static int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
static int memdbTruncate(sqlite3_file*, sqlite3_int64 size);
static int memdbSync(sqlite3_file*, int flags);
static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int memdbLock(sqlite3_file*, int);
/* static int memdbCheckReservedLock(sqlite3_file*, int *pResOut);// not used */
static int memdbFileControl(sqlite3_file*, int op, void *pArg);
/* static int memdbSectorSize(sqlite3_file*); // not used */
static int memdbDeviceCharacteristics(sqlite3_file*);
static int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
static int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);

/*
** Methods for MemVfs
*/
static int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
/* static int memdbDelete(sqlite3_vfs*, const char *zName, int syncDir); */
static int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);
static int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);
static void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);
static void memdbDlClose(sqlite3_vfs*, void*);
static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int memdbSleep(sqlite3_vfs*, int microseconds);
/* static int memdbCurrentTime(sqlite3_vfs*, double*); */
static int memdbGetLastError(sqlite3_vfs*, int, char *);
static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);

static sqlite3_vfs memdb_vfs = {
  2,                           /* iVersion */
  0,                           /* szOsFile (set when registered) */
  1024,                        /* mxPathname */
  0,                           /* pNext */
  "memdb",                     /* zName */
  0,                           /* pAppData (set when registered) */ 
  memdbOpen,                   /* xOpen */
  0, /* memdbDelete, */        /* xDelete */
  memdbAccess,                 /* xAccess */
  memdbFullPathname,           /* xFullPathname */
  memdbDlOpen,                 /* xDlOpen */
  memdbDlError,                /* xDlError */
  memdbDlSym,                  /* xDlSym */
  memdbDlClose,                /* xDlClose */
  memdbRandomness,             /* xRandomness */
  memdbSleep,                  /* xSleep */
  0, /* memdbCurrentTime, */   /* xCurrentTime */
  memdbGetLastError,           /* xGetLastError */
  memdbCurrentTimeInt64,       /* xCurrentTimeInt64 */
  0,                           /* xSetSystemCall */
  0,                           /* xGetSystemCall */
  0,                           /* xNextSystemCall */
};

static const sqlite3_io_methods memdb_io_methods = {
  3,                              /* iVersion */
  memdbClose,                      /* xClose */
  memdbRead,                       /* xRead */
  memdbWrite,                      /* xWrite */
  memdbTruncate,                   /* xTruncate */
  memdbSync,                       /* xSync */
  memdbFileSize,                   /* xFileSize */
  memdbLock,                       /* xLock */
  memdbLock,                       /* xUnlock - same as xLock in this case */ 
  0, /* memdbCheckReservedLock, */ /* xCheckReservedLock */
  memdbFileControl,                /* xFileControl */
  0, /* memdbSectorSize,*/         /* xSectorSize */
  memdbDeviceCharacteristics,      /* xDeviceCharacteristics */
  0,                               /* xShmMap */
  0,                               /* xShmLock */
  0,                               /* xShmBarrier */
  0,                               /* xShmUnmap */
  memdbFetch,                      /* xFetch */
  memdbUnfetch                     /* xUnfetch */
};

/*
** Enter/leave the mutex on a MemStore
*/
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE==0
static void memdbEnter(MemStore *p){
  UNUSED_PARAMETER(p);
}
static void memdbLeave(MemStore *p){
  UNUSED_PARAMETER(p);
}
#else
static void memdbEnter(MemStore *p){
  
// ABS Label 7
if(p->pMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
sqlite3_mutex_enter(p->pMutex);
}
static void memdbLeave(MemStore *p){
  
// ABS Label 8
if(p->pMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3_mutex_leave(p->pMutex);
}
#endif



/*
** Close an memdb-file.
** Free the underlying MemStore object when its refcount drops to zero
** or less.
*/
static int memdbClose(sqlite3_file *pFile){
  
// ABS Label 9
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  
// ABS Label 10
if(p->zFName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
if( p->zFName ){
    int i;
#ifndef SQLITE_MUTEX_OMIT
    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
#endif
    
// ABS Label 11
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
sqlite3_mutex_enter(pVfsMutex);
    i = 0;

// MCC Label 13
if(( i < memdb_g.nMemStore ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 13);
}
// MCC Label 14
if(( !(i < memdb_g.nMemStore) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 14);
}
for(; ALWAYS(i<memdb_g.nMemStore); i++){
      
// ABS Label 17
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
// ABS Label 18
if(memdb_g.apMemStore[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
// ABS Label 19
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}

// ROR Label 20
if((memdb_g.apMemStore[i] != p) != (memdb_g.apMemStore[i] == p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}
if( memdb_g.apMemStore[i]==p ){
        
// ABS Label 21
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
memdbEnter(p);
        
// ABS Label 22
if(p->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ROR Label 23
if((p->nRef != 1) != (p->nRef == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
if( p->nRef==1 ){
          memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];
          
// ABS Label 24
if(memdb_g.nMemStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// ROR Label 25
if((memdb_g.nMemStore != 0) != (memdb_g.nMemStore == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
if( memdb_g.nMemStore==0 ){
            sqlite3_free(memdb_g.apMemStore);
            memdb_g.apMemStore = 0;
          }
        }
        break;
      }
    };
// MCC Label 15
if(( i < memdb_g.nMemStore ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 15);
}
// MCC Label 16
if(( !(i < memdb_g.nMemStore) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}

    
// ABS Label 12
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3_mutex_leave(pVfsMutex);
  }else{
    
// ABS Label 26
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
memdbEnter(p);
  }
  p->nRef--;
  
// ABS Label 27
if(p->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}

// ROR Label 28
if((p->nRef < 0) != (p->nRef <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((p->nRef > 0) != (p->nRef <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((p->nRef >= 0) != (p->nRef <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
if( p->nRef<=0 ){
    
// ABS Label 33
if(p->mFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}

// AOR Label 34
if(p->mFlags | 1 != p->mFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 34);
}
// AOR Label 35
if(p->mFlags ^ 1 != p->mFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 35);
}
if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ){
      sqlite3_free(p->aData);
    }
    
// ABS Label 31
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
memdbLeave(p);
    
// ABS Label 32
if(p->pMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
sqlite3_mutex_free(p->pMutex);
    sqlite3_free(p);
  }else{
    
// ABS Label 36
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}
memdbLeave(p);
  }
  return SQLITE_OK;
}

/*
** Read data from an memdb-file.
*/
static int memdbRead(
  sqlite3_file *pFile, 
  void *zBuf, 
  int iAmt, 
  sqlite_int64 iOfst
){
  
// ABS Label 37
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  
// ABS Label 38
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
memdbEnter(p);
  
// ABS Label 41
if(iOfst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
// ABS Label 42
if(p->sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}

// AOR Label 43
if(iOfst - iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 43);
}
// AOR Label 44
if(iOfst / iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 44);
}
// AOR Label 45
if(iOfst * iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 45);
}

// ROR Label 46
if((iOfst + iAmt <= p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
// ROR Label 47
if((iOfst + iAmt < p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
// ROR Label 48
if((iOfst + iAmt >= p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
if( iOfst+iAmt>p->sz ){
    
// ABS Label 49
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
memset(zBuf, 0, iAmt);
    
// ABS Label 51
if(iOfst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
// ABS Label 52
if(p->sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}

// ROR Label 53
if((iOfst <= p->sz) != (iOfst < p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}
// ROR Label 54
if((iOfst > p->sz) != (iOfst < p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
// ROR Label 55
if((iOfst >= p->sz) != (iOfst < p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
if( iOfst<p->sz ) { 
// ABS Label 56
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}
memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);
}
    
// ABS Label 50
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
memdbLeave(p);
    
// MCC Label 57
if(( 10 | (2 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
// MCC Label 58
if(( !(10 | (2 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 58);
}
return SQLITE_IOERR_SHORT_READ;
  }
  
// ABS Label 39
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
memcpy(zBuf, p->aData+iOfst, iAmt);
  
// ABS Label 40
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
memdbLeave(p);
  return SQLITE_OK;
}

/*
** Try to enlarge the memory allocation to hold at least sz bytes
*/
static int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){
  unsigned char *pNew;
  
// ABS Label 59
if(p->nMmap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}

// COR Label 60
if(((p->mFlags & 2) == 0 && p->nMmap > 0) != ((p->mFlags & 2) == 0 || p->nMmap > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 60);
}

// ROR Label 61
if(((p->mFlags & 2) != 0) != ((p->mFlags & 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
// ROR Label 62
if((p->nMmap <= 0) != (p->nMmap > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}
// ROR Label 63
if((p->nMmap < 0) != (p->nMmap > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((p->nMmap >= 0) != (p->nMmap > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}

// MCC Label 65
if((p->mFlags & 2) == 0 && p->nMmap > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 65);
}
// MCC Label 66
if((p->mFlags & 2) == 0 && !(p->nMmap > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
// MCC Label 67
if(!((p->mFlags & 2) == 0) && p->nMmap > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 67);
}
// MCC Label 68
if(!((p->mFlags & 2) == 0) && !(p->nMmap > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 68);
}
if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || p->nMmap>0 ){
    return SQLITE_FULL;
  }
  
// ABS Label 69
if(newSz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}
// ABS Label 70
if(p->szMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((newSz <= p->szMax) != (newSz > p->szMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
// ROR Label 72
if((newSz < p->szMax) != (newSz > p->szMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}
// ROR Label 73
if((newSz >= p->szMax) != (newSz > p->szMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
if( newSz>p->szMax ){
    return SQLITE_FULL;
  }
  newSz *= 2;
  
// ABS Label 74
if(newSz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}
// ABS Label 75
if(p->szMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ROR Label 76
if((newSz <= p->szMax) != (newSz > p->szMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
// ROR Label 77
if((newSz < p->szMax) != (newSz > p->szMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
// ROR Label 78
if((newSz >= p->szMax) != (newSz > p->szMax))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
if( newSz>p->szMax ) { newSz = p->szMax;
}
  pNew = sqlite3Realloc(p->aData, newSz);
  
// ABS Label 79
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ROR Label 80
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
if( pNew==0 ) { 
// MCC Label 81
if(( 10 | (12 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 81);
}
// MCC Label 82
if(( !(10 | (12 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
return SQLITE_IOERR_NOMEM;
}
  p->aData = pNew;
  p->szAlloc = newSz;
  return SQLITE_OK;
}

/*
** Write data to an memdb-file.
*/
static int memdbWrite(
  sqlite3_file *pFile,
  const void *z,
  int iAmt,
  sqlite_int64 iOfst
){
  
// ABS Label 83
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  
// ABS Label 84
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
memdbEnter(p);
  
// MCC Label 87
if(( p->mFlags & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 87);
}
// MCC Label 88
if(( !(p->mFlags & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 88);
}
if( NEVER(p->mFlags & SQLITE_DESERIALIZE_READONLY) ){
    /* Can't happen: memdbLock() will return SQLITE_READONLY before
    ** reaching this point */
    
// ABS Label 89
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
memdbLeave(p);
    
// MCC Label 90
if(( 10 | (3 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}
// MCC Label 91
if(( !(10 | (3 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 91);
}
return SQLITE_IOERR_WRITE;
  }
  
// ABS Label 92
if(iOfst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}
// ABS Label 93
if(p->sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}

// AOR Label 94
if(iOfst - iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 94);
}
// AOR Label 95
if(iOfst / iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 95);
}
// AOR Label 96
if(iOfst * iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 96);
}

// ROR Label 97
if((iOfst + iAmt <= p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 97);
}
// ROR Label 98
if((iOfst + iAmt < p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
// ROR Label 99
if((iOfst + iAmt >= p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
if( iOfst+iAmt>p->sz ){
    int rc;
    if( iOfst+iAmt>p->szAlloc
     && (rc = memdbEnlarge(p, iOfst+iAmt))!=SQLITE_OK
    ){
      
// ABS Label 100
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
memdbLeave(p);
      
// ABS Label 101
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
return rc;
    }
    
// ABS Label 102
if(iOfst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
// ABS Label 103
if(p->sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}

// ROR Label 104
if((iOfst <= p->sz) != (iOfst > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
// ROR Label 105
if((iOfst < p->sz) != (iOfst > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
// ROR Label 106
if((iOfst >= p->sz) != (iOfst > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
if( iOfst>p->sz ) { memset(p->aData+p->sz, 0, iOfst-p->sz);
}
    p->sz = iOfst+iAmt;
  }
  
// ABS Label 85
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
memcpy(p->aData+iOfst, z, iAmt);
  
// ABS Label 86
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
memdbLeave(p);
  return SQLITE_OK;
}

/*
** Truncate an memdb-file.
**
** In rollback mode (which is always the case for memdb, as it does not
** support WAL mode) the truncate() method is only used to reduce
** the size of a file, never to increase the size.
*/
static int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){
  
// ABS Label 107
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  int rc = SQLITE_OK;
  
// ABS Label 108
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
memdbEnter(p);
  
// MCC Label 110
if(( size > p->sz ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(( !(size > p->sz) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
if( NEVER(size>p->sz) ){
    rc = SQLITE_FULL;
  }else{
    p->sz = size; 
  }
  
// ABS Label 109
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
memdbLeave(p);
  
// ABS Label 112
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}
return rc;
}

/*
** Sync an memdb-file.
*/
static int memdbSync(sqlite3_file *pFile, int flags){
  UNUSED_PARAMETER(pFile);
  UNUSED_PARAMETER(flags);
  return SQLITE_OK;
}

/*
** Return the current file-size of an memdb-file.
*/
static int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){
  
// ABS Label 113
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  
// ABS Label 114
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
memdbEnter(p);
  *pSize = p->sz;
  
// ABS Label 115
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
memdbLeave(p);
  return SQLITE_OK;
}

/*
** Lock an memdb-file.
*/
static int memdbLock(sqlite3_file *pFile, int eLock){
  MemFile *pThis = (MemFile*)pFile;
  
// ABS Label 116
if(pThis->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
MemStore *p = pThis->pStore;
  int rc = SQLITE_OK;
  
// ABS Label 119
if(eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}
// ABS Label 120
if(pThis->eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// ROR Label 121
if((eLock != pThis->eLock) != (eLock == pThis->eLock))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
if( eLock==pThis->eLock ) { return SQLITE_OK;
}
  
// ABS Label 117
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
memdbEnter(p);
  
// ABS Label 122
if(eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// ROR Label 123
if((eLock <= 1) != (eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
// ROR Label 124
if((eLock < 1) != (eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}
// ROR Label 125
if((eLock >= 1) != (eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}
if( eLock>SQLITE_LOCK_SHARED ){
    
// ABS Label 126
if(p->mFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// AOR Label 127
if(p->mFlags | 4 != p->mFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 127);
}
// AOR Label 128
if(p->mFlags ^ 4 != p->mFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 128);
}
if( p->mFlags & SQLITE_DESERIALIZE_READONLY ){
      rc = SQLITE_READONLY;
    }else { 
// ABS Label 129
if(pThis->eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}

// ROR Label 130
if((pThis->eLock < 1) != (pThis->eLock <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if((pThis->eLock > 1) != (pThis->eLock <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}
// ROR Label 132
if((pThis->eLock >= 1) != (pThis->eLock <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
if( pThis->eLock<=SQLITE_LOCK_SHARED ){
      
// ABS Label 133
if(p->nWrLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
if( p->nWrLock ){
        rc = SQLITE_BUSY;
      }else{
        p->nWrLock = 1;
      }
    };}

  }else { 
// ABS Label 134
if(eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}

// ROR Label 135
if((eLock != 1) != (eLock == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 135);
}
if( eLock==SQLITE_LOCK_SHARED ){
    
// ABS Label 136
if(pThis->eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}

// ROR Label 137
if((pThis->eLock <= 1) != (pThis->eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
// ROR Label 138
if((pThis->eLock < 1) != (pThis->eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 138);
}
// ROR Label 139
if((pThis->eLock >= 1) != (pThis->eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
if( pThis->eLock > SQLITE_LOCK_SHARED ){
      assert( p->nWrLock==1 );
      p->nWrLock = 0;
    }else { 
// ABS Label 140
if(p->nWrLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
if( p->nWrLock ){
      rc = SQLITE_BUSY;
    }else{
      p->nRdLock++;
    };}

  }else{
    assert( eLock==SQLITE_LOCK_NONE );
    
// ABS Label 141
if(pThis->eLock < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ROR Label 142
if((pThis->eLock <= 1) != (pThis->eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((pThis->eLock < 1) != (pThis->eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}
// ROR Label 144
if((pThis->eLock >= 1) != (pThis->eLock > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( pThis->eLock>SQLITE_LOCK_SHARED ){    
      assert( p->nWrLock==1 );
      p->nWrLock = 0;
    }
    assert( p->nRdLock>0 );
    p->nRdLock--;
  };}

  
// ABS Label 145
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}

// ROR Label 146
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 146);
}
if( rc==SQLITE_OK ) { pThis->eLock = eLock;
}
  
// ABS Label 118
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}
memdbLeave(p);
  
// ABS Label 147
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
return rc;
}

#if 0
/*
** This interface is only used for crash recovery, which does not
** occur on an in-memory database.
*/
static int memdbCheckReservedLock(sqlite3_file *pFile, int *pResOut){
  *pResOut = 0;
  return SQLITE_OK;
}
#endif


/*
** File control method. For custom operations on an memdb-file.
*/
static int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){
  
// ABS Label 148
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  int rc = SQLITE_NOTFOUND;
  
// ABS Label 149
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
memdbEnter(p);
  
// ABS Label 151
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// ROR Label 152
if((op != 12) != (op == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
if( op==SQLITE_FCNTL_VFSNAME ){
    *(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);
    rc = SQLITE_OK;
  }
  
// ABS Label 153
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ROR Label 154
if((op != 36) != (op == 36))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
if( op==SQLITE_FCNTL_SIZE_LIMIT ){
    
// ABS Label 155
if(*(sqlite3_int64 *)pArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}
sqlite3_int64 iLimit = *(sqlite3_int64*)pArg;
    
// ABS Label 156
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
// ABS Label 157
if(p->sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ROR Label 158
if((iLimit <= p->sz) != (iLimit < p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 158);
}
// ROR Label 159
if((iLimit > p->sz) != (iLimit < p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 159);
}
// ROR Label 160
if((iLimit >= p->sz) != (iLimit < p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
if( iLimit<p->sz ){
      
// ABS Label 161
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}

// ROR Label 162
if((iLimit <= 0) != (iLimit < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((iLimit > 0) != (iLimit < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
// ROR Label 164
if((iLimit >= 0) != (iLimit < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
if( iLimit<0 ){
        iLimit = p->szMax;
      }else{
        iLimit = p->sz;
      }
    }
    p->szMax = iLimit;
    *(sqlite3_int64*)pArg = iLimit;
    rc = SQLITE_OK;
  }
  
// ABS Label 150
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
memdbLeave(p);
  
// ABS Label 165
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}
return rc;
}

#if 0  /* Not used because of SQLITE_IOCAP_POWERSAFE_OVERWRITE */
/*
** Return the sector-size in bytes for an memdb-file.
*/
static int memdbSectorSize(sqlite3_file *pFile){
  return 1024;
}
#endif

/*
** Return the device characteristic flags supported by an memdb-file.
*/
static int memdbDeviceCharacteristics(sqlite3_file *pFile){
  UNUSED_PARAMETER(pFile);
  
// AOR Label 166
if(1 | 4096 | 512 & 1024 != 1 | 4096 | 512 | 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 166);
}
// AOR Label 167
if(1 | 4096 | 512 ^ 1024 != 1 | 4096 | 512 | 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 167);
}
// AOR Label 168
if(1 | 4096 & 512 != 1 | 4096 | 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 168);
}
// AOR Label 169
if(1 | 4096 ^ 512 != 1 | 4096 | 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 169);
}
// AOR Label 170
if(1 & 4096 != 1 | 4096)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 170);
}
// AOR Label 171
if(1 ^ 4096 != 1 | 4096)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 171);
}
return SQLITE_IOCAP_ATOMIC | 
         SQLITE_IOCAP_POWERSAFE_OVERWRITE |
         SQLITE_IOCAP_SAFE_APPEND |
         SQLITE_IOCAP_SEQUENTIAL;
}

/* Fetch a page of a memory-mapped file */
static int memdbFetch(
  sqlite3_file *pFile,
  sqlite3_int64 iOfst,
  int iAmt,
  void **pp
){
  
// ABS Label 172
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  
// ABS Label 173
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}
memdbEnter(p);
  
// ABS Label 175
if(iOfst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}
// ABS Label 176
if(p->sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// AOR Label 177
if(iOfst - iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 177);
}
// AOR Label 178
if(iOfst / iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 178);
}
// AOR Label 179
if(iOfst * iAmt != iOfst + iAmt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 179);
}

// ROR Label 180
if((iOfst + iAmt <= p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 180);
}
// ROR Label 181
if((iOfst + iAmt < p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 181);
}
// ROR Label 182
if((iOfst + iAmt >= p->sz) != (iOfst + iAmt > p->sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 182);
}
if( iOfst+iAmt>p->sz ){
    *pp = 0;
  }else{
    p->nMmap++;
    *pp = (void*)(p->aData + iOfst);
  }
  
// ABS Label 174
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}
memdbLeave(p);
  return SQLITE_OK;
}

/* Release a memory-mapped page */
static int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){
  
// ABS Label 183
if(((MemFile *)pFile)->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
MemStore *p = ((MemFile*)pFile)->pStore;
  UNUSED_PARAMETER(iOfst);
  UNUSED_PARAMETER(pPage);
  
// ABS Label 184
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}
memdbEnter(p);
  p->nMmap--;
  
// ABS Label 185
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
memdbLeave(p);
  return SQLITE_OK;
}

/*
** Open an mem file handle.
*/
static int memdbOpen(
  sqlite3_vfs *pVfs,
  const char *zName,
  sqlite3_file *pFd,
  int flags,
  int *pOutFlags
){
  MemFile *pFile = (MemFile*)pFd;
  MemStore *p = 0;
  int szName;
  
// ROR Label 187
if(((flags & 256) != 0) != ((flags & 256) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){
    return ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pFd, flags, pOutFlags);
  }
  memset(pFile, 0, sizeof(*p));
  szName = sqlite3Strlen30(zName);
  
// ABS Label 188
if(szName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// COR Label 189
if((szName > 1 || zName[0] == '/') != (szName > 1 && zName[0] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 189);
}

// ROR Label 190
if((szName <= 1) != (szName > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}
// ROR Label 191
if((szName < 1) != (szName > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
// ROR Label 192
if((szName >= 1) != (szName > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((zName[0] != '/') != (zName[0] == '/'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}

// MCC Label 194
if(szName > 1 && zName[0] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(szName > 1 && !(zName[0] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(!(szName > 1) && zName[0] == '/' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(!(szName > 1) && !(zName[0] == '/') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
if( szName>1 && zName[0]=='/' ){
    int i;
#ifndef SQLITE_MUTEX_OMIT
    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
#endif
    
// ABS Label 198
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
sqlite3_mutex_enter(pVfsMutex);
    i = 0;

// ABS Label 200
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
// ABS Label 201
if(memdb_g.nMemStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}

// ROR Label 202
if((i <= memdb_g.nMemStore) != (i < memdb_g.nMemStore))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
// ROR Label 203
if((i > memdb_g.nMemStore) != (i < memdb_g.nMemStore))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
// ROR Label 204
if((i >= memdb_g.nMemStore) != (i < memdb_g.nMemStore))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
for(; i<memdb_g.nMemStore; i++){
      if( strcmp(memdb_g.apMemStore[i]->zFName,zName)==0 ){
        p = memdb_g.apMemStore[i];
        break;
      }
    };
// ABS Label 205
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}
// ABS Label 206
if(memdb_g.nMemStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}

// ROR Label 207
if((i <= memdb_g.nMemStore) != (i < memdb_g.nMemStore))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
// ROR Label 208
if((i > memdb_g.nMemStore) != (i < memdb_g.nMemStore))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((i >= memdb_g.nMemStore) != (i < memdb_g.nMemStore))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}

    
// ABS Label 210
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 210);
}

// ROR Label 211
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
if( p==0 ){
      MemStore **apNew;
      p = sqlite3Malloc( sizeof(*p) + szName + 3 );
      
// ABS Label 213
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}

// ROR Label 214
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 214);
}
if( p==0 ){
        
// ABS Label 215
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
sqlite3_mutex_leave(pVfsMutex);
        return SQLITE_NOMEM;
      }
      apNew = sqlite3Realloc(memdb_g.apMemStore,
                             sizeof(apNew[0])*(memdb_g.nMemStore+1) );
      
// ABS Label 216
if(apNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// ROR Label 217
if((apNew != 0) != (apNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
if( apNew==0 ){
        sqlite3_free(p);
        
// ABS Label 218
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}
sqlite3_mutex_leave(pVfsMutex);
        return SQLITE_NOMEM;
      }
      apNew[memdb_g.nMemStore++] = p;
      memdb_g.apMemStore = apNew;
      memset(p, 0, sizeof(*p));
      p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE|SQLITE_DESERIALIZE_FREEONCLOSE;
      p->szMax = sqlite3GlobalConfig.mxMemdbSize;
      p->zFName = (char*)&p[1];
      memcpy(p->zFName, zName, szName+1);
      p->pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
      
// ABS Label 219
if(p->pMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}

// ROR Label 220
if((p->pMutex != 0) != (p->pMutex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 220);
}
if( p->pMutex==0 ){
        memdb_g.nMemStore--;
        sqlite3_free(p);
        
// ABS Label 221
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
sqlite3_mutex_leave(pVfsMutex);
        return SQLITE_NOMEM;
      }
      p->nRef = 1;
      
// ABS Label 212
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}
memdbEnter(p);
    }else{
      
// ABS Label 222
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}
memdbEnter(p);
      p->nRef++;
    }
    
// ABS Label 199
if(pVfsMutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}
sqlite3_mutex_leave(pVfsMutex);
  }else{
    p = sqlite3Malloc( sizeof(*p) );
    
// ABS Label 223
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}

// ROR Label 224
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 224);
}
if( p==0 ){
      return SQLITE_NOMEM;
    }
    memset(p, 0, sizeof(*p));
    p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;
    p->szMax = sqlite3GlobalConfig.mxMemdbSize;
  }
  pFile->pStore = p;
  assert( pOutFlags!=0 );  /* True because flags==SQLITE_OPEN_MAIN_DB */
  *pOutFlags = flags | SQLITE_OPEN_MEMORY;
  pFd->pMethods = &memdb_io_methods;
  
// ABS Label 186
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
memdbLeave(p);
  return SQLITE_OK;
}

#if 0 /* Only used to delete rollback journals, super-journals, and WAL
      ** files, none of which exist in memdb.  So this routine is never used */
/*
** Delete the file located at zPath. If the dirSync argument is true,
** ensure the file-system modifications are synced to disk before
** returning.
*/
static int memdbDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
  return SQLITE_IOERR_DELETE;
}
#endif

/*
** Test for access permissions. Return true if the requested permission
** is available, or false otherwise.
**
** With memdb, no files ever exist on disk.  So always return false.
*/
static int memdbAccess(
  sqlite3_vfs *pVfs, 
  const char *zPath, 
  int flags, 
  int *pResOut
){
  UNUSED_PARAMETER(pVfs);
  UNUSED_PARAMETER(zPath);
  UNUSED_PARAMETER(flags);
  *pResOut = 0;
  return SQLITE_OK;
}

/*
** Populate buffer zOut with the full canonical pathname corresponding
** to the pathname in zPath. zOut is guaranteed to point to a buffer
** of at least (INST_MAX_PATHNAME+1) bytes.
*/
static int memdbFullPathname(
  sqlite3_vfs *pVfs, 
  const char *zPath, 
  int nOut, 
  char *zOut
){
  UNUSED_PARAMETER(pVfs);
  
// ABS Label 225
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}

// ABS Label 226
if(zOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}

// ABS Label 227
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
sqlite3_snprintf(nOut, zOut, "%s", zPath);
  return SQLITE_OK;
}

/*
** Open the dynamic library located at zPath and return a handle.
*/
static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){
  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);
}

/*
** Populate the buffer zErrMsg (size nByte bytes) with a human readable
** utf-8 string describing the most recent error encountered associated 
** with dynamic libraries.
*/
static void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){
  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);
}

/*
** Return a pointer to the symbol zSymbol in the dynamic library pHandle.
*/
static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){
  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);
}

/*
** Close the dynamic library handle pHandle.
*/
static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){
  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);
}

/*
** Populate the buffer pointed to by zBufOut with nByte bytes of 
** random data.
*/
static int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);
}

/*
** Sleep for nMicro microseconds. Return the number of microseconds 
** actually slept.
*/
static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){
  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);
}

#if 0  /* Never used.  Modern cores only call xCurrentTimeInt64() */
/*
** Return the current time as a Julian Day number in *pTimeOut.
*/
static int memdbCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){
  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);
}
#endif

static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){
  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);
}
static int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){
  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);
}

/*
** Translate a database connection pointer and schema name into a
** MemFile pointer.
*/
static MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){
  MemFile *p = 0;
  MemStore *pStore;
  int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);
  
// ABS Label 233
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}
if( rc ) { return 0;
}
  
// ABS Label 234
if(p->base.pMethods < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}

// ROR Label 235
if((p->base.pMethods == &memdb_io_methods) != (p->base.pMethods != &memdb_io_methods))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
if( p->base.pMethods!=&memdb_io_methods ) { return 0;
}
  pStore = p->pStore;
  
// ABS Label 231
if(pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}
memdbEnter(pStore);
  
// ABS Label 236
if(pStore->zFName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}

// ROR Label 237
if((pStore->zFName == 0) != (pStore->zFName != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
if( pStore->zFName!=0 ) { p = 0;
}
  
// ABS Label 232
if(pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}
memdbLeave(pStore);
  
// ABS Label 238
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}
return p;
}

/*
** Return the serialization of a database
*/
unsigned char *sqlite3_serialize(
  sqlite3 *db,              /* The database connection */
  const char *zSchema,      /* Which database within the connection */
  sqlite3_int64 *piSize,    /* Write size here, if not NULL */
  unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */
){
  MemFile *p;
  int iDb;
  Btree *pBt;
  sqlite3_int64 sz;
  int szPage = 0;
  sqlite3_stmt *pStmt = 0;
  unsigned char *pOut;
  char *zSql;
  int rc;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(db) ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif

  
// ABS Label 240
if(zSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ROR Label 241
if((zSchema != 0) != (zSchema == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
if( zSchema==0 ) { zSchema = db->aDb[0].zDbSName;
}
  p = memdbFromDbSchema(db, zSchema);
  iDb = sqlite3FindDbName(db, zSchema);
  
// ABS Label 242
if(piSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}
if( piSize ) { *piSize = -1;
}
  
// ABS Label 243
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}

// ROR Label 244
if((iDb <= 0) != (iDb < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}
// ROR Label 245
if((iDb > 0) != (iDb < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 245);
}
// ROR Label 246
if((iDb >= 0) != (iDb < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
if( iDb<0 ) { return 0;
}
  
// ABS Label 247
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
if( p ){
    
// ABS Label 248
if(p->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
MemStore *pStore = p->pStore;
    assert( pStore->pMutex==0 );
    
// ABS Label 249
if(piSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
if( piSize ) { *piSize = pStore->sz;
}
    
// ABS Label 250
if(mFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

// AOR Label 251
if(mFlags | 1 != mFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 251);
}
// AOR Label 252
if(mFlags ^ 1 != mFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 252);
}
if( mFlags & SQLITE_SERIALIZE_NOCOPY ){
      pOut = pStore->aData;
    }else{
      pOut = sqlite3_malloc64( pStore->sz );
      
// ABS Label 253
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}
if( pOut ) { memcpy(pOut, pStore->aData, pStore->sz);
}
    }
    
// ABS Label 254
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}
return pOut;
  }
  pBt = db->aDb[iDb].pBt;
  
// ABS Label 255
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}

// ROR Label 256
if((pBt != 0) != (pBt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 256);
}
if( pBt==0 ) { return 0;
}
  szPage = sqlite3BtreeGetPageSize(pBt);
  zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);
  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;
  sqlite3_free(zSql);
  
// ABS Label 257
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}
if( rc ) { return 0;
}
  rc = sqlite3_step(pStmt);
  
// ABS Label 258
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// ROR Label 259
if((rc == 100) != (rc != 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}
if( rc!=SQLITE_ROW ){
    pOut = 0;
  }else{
    sz = sqlite3_column_int64(pStmt, 0)*szPage;
    
// ABS Label 260
if(piSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
if( piSize ) { *piSize = sz;
}
    
// ABS Label 261
if(mFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}

// AOR Label 262
if(mFlags | 1 != mFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 262);
}
// AOR Label 263
if(mFlags ^ 1 != mFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 263);
}
if( mFlags & SQLITE_SERIALIZE_NOCOPY ){
      pOut = 0;
    }else{
      pOut = sqlite3_malloc64( sz );
      
// ABS Label 264
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
if( pOut ){
        int nPage = sqlite3_column_int(pStmt, 0);
        Pager *pPager = sqlite3BtreePager(pBt);
        int pgno;
        pgno = 1;

// ABS Label 265
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}
// ABS Label 266
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}

// ROR Label 267
if((pgno < nPage) != (pgno <= nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((pgno > nPage) != (pgno <= nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}
// ROR Label 269
if((pgno >= nPage) != (pgno <= nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}
for(; pgno<=nPage; pgno++){
          DbPage *pPage = 0;
          
// ABS Label 275
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}

// AOR Label 276
if(pOut - szPage * (sqlite3_int64)(pgno - 1) != pOut + szPage * (sqlite3_int64)(pgno - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 276);
}
// AOR Label 277
if(pOut / szPage * (sqlite3_int64)(pgno - 1) != pOut + szPage * (sqlite3_int64)(pgno - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 277);
}
// AOR Label 278
if(pOut * szPage * (sqlite3_int64)(pgno - 1) != pOut + szPage * (sqlite3_int64)(pgno - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 278);
}
// AOR Label 279
if(szPage - (sqlite3_int64)(pgno - 1) != szPage * (sqlite3_int64)(pgno - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 279);
}
// AOR Label 280
if(szPage + (sqlite3_int64)(pgno - 1) != szPage * (sqlite3_int64)(pgno - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 280);
}
// AOR Label 281
if(szPage / (sqlite3_int64)(pgno - 1) != szPage * (sqlite3_int64)(pgno - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 281);
}
unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);
          rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);
          
// ABS Label 283
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
if( rc==SQLITE_OK ){
            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);
          }else{
            memset(pTo, 0, szPage);
          }
          
// ABS Label 282
if(pPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
sqlite3PagerUnref(pPage);       
        };
// ABS Label 270
if(nPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
// ABS Label 271
if(pgno < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}

// ROR Label 272
if((pgno < nPage) != (pgno <= nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 272);
}
// ROR Label 273
if((pgno > nPage) != (pgno <= nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
// ROR Label 274
if((pgno >= nPage) != (pgno <= nPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 274);
}

      }
    }
  }
  
// ABS Label 239
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}
sqlite3_finalize(pStmt);
  
// ABS Label 285
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
return pOut;
}

/* Convert zSchema to a MemDB and initialize its content.
*/
int sqlite3_deserialize(
  sqlite3 *db,            /* The database connection */
  const char *zSchema,    /* Which DB to reopen with the deserialization */
  unsigned char *pData,   /* The serialized database content */
  sqlite3_int64 szDb,     /* Number bytes in the deserialization */
  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */
  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */
){
  MemFile *p;
  char *zSql;
  sqlite3_stmt *pStmt = 0;
  int rc;
  int iDb;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(db) ){
    return SQLITE_MISUSE_BKPT;
  }
  if( szDb<0 ) return SQLITE_MISUSE_BKPT;
  if( szBuf<0 ) return SQLITE_MISUSE_BKPT;
#endif

  
// ABS Label 286
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}
sqlite3_mutex_enter(db->mutex);
  
// ABS Label 288
if(zSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}

// ROR Label 289
if((zSchema != 0) != (zSchema == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}
if( zSchema==0 ) { zSchema = db->aDb[0].zDbSName;
}
  iDb = sqlite3FindDbName(db, zSchema);
  
// ABS Label 290
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ROR Label 291
if((iDb <= 0) != (iDb < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 291);
}
// ROR Label 292
if((iDb > 0) != (iDb < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}
// ROR Label 293
if((iDb >= 0) != (iDb < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 293);
}
if( iDb<0 ){
    rc = SQLITE_ERROR;
    goto end_deserialize;
  }    
  zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);
  
// ABS Label 294
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}

// ROR Label 295
if((zSql != 0) != (zSql == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}
if( zSql==0 ){
    rc = SQLITE_NOMEM;
  }else{
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
    sqlite3_free(zSql);
  }
  
// ABS Label 296
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
if( rc ) { goto end_deserialize;
}
  db->init.iDb = (u8)iDb;
  db->init.reopenMemdb = 1;
  rc = sqlite3_step(pStmt);
  db->init.reopenMemdb = 0;
  
// ABS Label 297
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ROR Label 298
if((rc == 101) != (rc != 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
if( rc!=SQLITE_DONE ){
    rc = SQLITE_ERROR;
    goto end_deserialize;
  }
  p = memdbFromDbSchema(db, zSchema);
  
// ABS Label 299
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}

// ROR Label 300
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
if( p==0 ){
    rc = SQLITE_ERROR;
  }else{
    
// ABS Label 301
if(p->pStore < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}
MemStore *pStore = p->pStore;
    pStore->aData = pData;
    pData = 0;
    pStore->sz = szDb;
    pStore->szAlloc = szBuf;
    pStore->szMax = szBuf;
    
// ABS Label 302
if(pStore->szMax < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
// ABS Label 303
if(sqlite3Config.mxMemdbSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ROR Label 304
if((pStore->szMax <= sqlite3Config.mxMemdbSize) != (pStore->szMax < sqlite3Config.mxMemdbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
// ROR Label 305
if((pStore->szMax > sqlite3Config.mxMemdbSize) != (pStore->szMax < sqlite3Config.mxMemdbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}
// ROR Label 306
if((pStore->szMax >= sqlite3Config.mxMemdbSize) != (pStore->szMax < sqlite3Config.mxMemdbSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 306);
}
if( pStore->szMax<sqlite3GlobalConfig.mxMemdbSize ){
      pStore->szMax = sqlite3GlobalConfig.mxMemdbSize;
    }
    pStore->mFlags = mFlags;
    rc = SQLITE_OK;
  }

end_deserialize:
  sqlite3_finalize(pStmt);
  
// ABS Label 307
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}

// COR Label 308
if((pData || (mFlags & 1) != 0) != (pData && (mFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 308);
}

// ROR Label 309
if(((mFlags & 1) == 0) != ((mFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}

// MCC Label 310
if(pData && (mFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 310);
}
// MCC Label 311
if(pData && !((mFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 311);
}
// MCC Label 312
if(!(pData) && (mFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 312);
}
// MCC Label 313
if(!(pData) && !((mFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 313);
}
if( pData && (mFlags & SQLITE_DESERIALIZE_FREEONCLOSE)!=0 ){
    sqlite3_free(pData);
  }
  
// ABS Label 287
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 314
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
return rc;
}

/* 
** This routine is called when the extension is loaded.
** Register the new VFS.
*/
int sqlite3MemdbInit(void){
  sqlite3_vfs *pLower = sqlite3_vfs_find(0);
  unsigned int sz;
  
// MCC Label 315
if(( pLower == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 315);
}
// MCC Label 316
if(( !(pLower == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 316);
}
if( NEVER(pLower==0) ) { return SQLITE_ERROR;
}
  sz = pLower->szOsFile;
  memdb_vfs.pAppData = pLower;
  /* The following conditional can only be true when compiled for
  ** Windows x86 and SQLITE_MAX_MMAP_SIZE=0.  We always leave
  ** it in, to be safe, but it is marked as NO_TEST since there
  ** is no way to reach it under most builds. */
  
// ROR Label 317
if((sz <= sizeof(MemFile)) != (sz < sizeof(MemFile)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}
// ROR Label 318
if((sz > sizeof(MemFile)) != (sz < sizeof(MemFile)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
// ROR Label 319
if((sz >= sizeof(MemFile)) != (sz < sizeof(MemFile)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 319);
}
if( sz<sizeof(MemFile) ) { sz = sizeof(MemFile); /*NO_TEST*/
}
  memdb_vfs.szOsFile = sz;
  return sqlite3_vfs_register(&memdb_vfs, 0);
}
#endif /* SQLITE_OMIT_DESERIALIZE */
