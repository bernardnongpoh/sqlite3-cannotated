/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2015-06-06
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This module contains C code that generates VDBE code used to process
** the WHERE clause of SQL statements.
**
** This file was split off from where.c on 2015-06-06 in order to reduce the
** size of where.c and make it easier to edit.  This file contains the routines
** that actually generate the bulk of the WHERE loop code.  The original where.c
** file retains the code that does query planning and analysis.
*/
#include "sqliteInt.h"
#include "whereInt.h"

#ifndef SQLITE_OMIT_EXPLAIN

/*
** Return the name of the i-th column of the pIdx index.
*/
static const char *explainIndexColumnName(Index *pIdx, int i){
  i = pIdx->aiColumn[i];
  
// ABS Label 7
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ROR Label 8
if((i != (-2)) != (i == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
if( i==XN_EXPR ) { return "<expr>";
}
  
// ABS Label 9
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

// ROR Label 10
if((i != (-1)) != (i == (-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( i==XN_ROWID ) { return "rowid";
}
  return pIdx->pTable->aCol[i].zName;
}

/*
** This routine is a helper for explainIndexRange() below
**
** pStr holds the text of an expression that we are building up one term
** at a time.  This routine adds a new term to the end of the expression.
** Terms are separated by AND so add the "AND" text for second and subsequent
** terms only.
*/
static void explainAppendTerm(
  StrAccum *pStr,             /* The text expression being built */
  Index *pIdx,                /* Index to read column names from */
  int nTerm,                  /* Number of terms */
  int iTerm,                  /* Zero-based index of first term. */
  int bAnd,                   /* Non-zero to append " AND " */
  const char *zOp             /* Name of the operator */
){
  int i;

  assert( nTerm>=1 );
  
// ABS Label 13
if(bAnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
if( bAnd ) { 
// ABS Label 14
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
sqlite3_str_append(pStr, " AND ", 5);
}

  
// ABS Label 15
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}

// ROR Label 16
if((nTerm <= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
// ROR Label 17
if((nTerm < 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
// ROR Label 18
if((nTerm >= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
if( nTerm>1 ) { 
// ABS Label 19
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3_str_append(pStr, "(", 1);
}
  i = 0;

// ABS Label 20
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
// ABS Label 21
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}

// ROR Label 22
if((i <= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}
// ROR Label 23
if((i > nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
// ROR Label 24
if((i >= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
for(; i<nTerm; i++){
    
// ABS Label 31
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
if( i ) { 
// ABS Label 32
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
sqlite3_str_append(pStr, ",", 1);
}
    
// ABS Label 30
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, iTerm+i));
  };
// ABS Label 25
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
// ABS Label 26
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// ROR Label 27
if((i <= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
// ROR Label 28
if((i > nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((i >= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}

  
// ABS Label 33
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}

// ROR Label 34
if((nTerm <= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
// ROR Label 35
if((nTerm < 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
// ROR Label 36
if((nTerm >= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
if( nTerm>1 ) { 
// ABS Label 37
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
sqlite3_str_append(pStr, ")", 1);
}

  
// ABS Label 11
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ABS Label 12
if(zOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3_str_append(pStr, zOp, 1);

  
// ABS Label 38
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}

// ROR Label 39
if((nTerm <= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
// ROR Label 40
if((nTerm < 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
// ROR Label 41
if((nTerm >= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
if( nTerm>1 ) { 
// ABS Label 42
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}
sqlite3_str_append(pStr, "(", 1);
}
  i = 0;

// ABS Label 43
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}
// ABS Label 44
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// ROR Label 45
if((i <= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
// ROR Label 46
if((i > nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
// ROR Label 47
if((i >= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
for(; i<nTerm; i++){
    
// ABS Label 54
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}
if( i ) { 
// ABS Label 55
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}
sqlite3_str_append(pStr, ",", 1);
}
    
// ABS Label 53
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
sqlite3_str_append(pStr, "?", 1);
  };
// ABS Label 48
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}
// ABS Label 49
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}

// ROR Label 50
if((i <= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
// ROR Label 51
if((i > nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
// ROR Label 52
if((i >= nTerm) != (i < nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}

  
// ABS Label 56
if(nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}

// ROR Label 57
if((nTerm <= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if((nTerm < 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((nTerm >= 1) != (nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
if( nTerm>1 ) { 
// ABS Label 60
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
sqlite3_str_append(pStr, ")", 1);
}
}

/*
** Argument pLevel describes a strategy for scanning table pTab. This 
** function appends text to pStr that describes the subset of table
** rows scanned by the strategy in the form of an SQL expression.
**
** For example, if the query:
**
**   SELECT * FROM t1 WHERE a=1 AND b>2;
**
** is run and there is an index on (a, b), then this function returns a
** string similar to:
**
**   "a=? AND b>?"
*/
static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){
  
// ABS Label 61
if(pLoop->u.btree.pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
Index *pIndex = pLoop->u.btree.pIndex;
  
// ABS Label 62
if(pLoop->u.btree.nEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}
u16 nEq = pLoop->u.btree.nEq;
  
// ABS Label 63
if(pLoop->nSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}
u16 nSkip = pLoop->nSkip;
  int i, j;

  
// COR Label 66
if((nEq == 0 || (pLoop->wsFlags & (32 | 16)) == 0) != (nEq == 0 && (pLoop->wsFlags & (32 | 16)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 66);
}

// ROR Label 67
if((nEq != 0) != (nEq == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
// ROR Label 68
if(((pLoop->wsFlags & (32 | 16)) != 0) != ((pLoop->wsFlags & (32 | 16)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}

// MCC Label 69
if(nEq == 0 && (pLoop->wsFlags & (32 | 16)) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 69);
}
// MCC Label 70
if(nEq == 0 && !((pLoop->wsFlags & (32 | 16)) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 70);
}
// MCC Label 71
if(!(nEq == 0) && (pLoop->wsFlags & (32 | 16)) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if(!(nEq == 0) && !((pLoop->wsFlags & (32 | 16)) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
if( nEq==0 && (pLoop->wsFlags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))==0 ) { return;
}
  
// ABS Label 64
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}
sqlite3_str_append(pStr, " (", 2);
  i = 0;

// ABS Label 73
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// ROR Label 74
if((i <= nEq) != (i < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
// ROR Label 75
if((i > nEq) != (i < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
// ROR Label 76
if((i >= nEq) != (i < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
for(; i<nEq; i++){
    const char *z = explainIndexColumnName(pIndex, i);
    
// ABS Label 83
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
if( i ) { 
// ABS Label 84
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
sqlite3_str_append(pStr, " AND ", 5);
}
    
// ABS Label 81
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ABS Label 82
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
sqlite3_str_appendf(pStr, i>=nSkip ? "%s=?" : "ANY(%s)", z);
  };
// ABS Label 77
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((i <= nEq) != (i < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
// ROR Label 79
if((i > nEq) != (i < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
// ROR Label 80
if((i >= nEq) != (i < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}


  j = i;
  
// ABS Label 85
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}

// AOR Label 86
if(pLoop->wsFlags | 32 != pLoop->wsFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 86);
}
// AOR Label 87
if(pLoop->wsFlags ^ 32 != pLoop->wsFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 87);
}
if( pLoop->wsFlags&WHERE_BTM_LIMIT ){
    
// ABS Label 88
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// ABS Label 89
if(pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}

// ABS Label 90
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ABS Label 91
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
explainAppendTerm(pStr, pIndex, pLoop->u.btree.nBtm, j, i, ">");
    i = 1;
  }
  
// ABS Label 92
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// AOR Label 93
if(pLoop->wsFlags | 16 != pLoop->wsFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 93);
}
// AOR Label 94
if(pLoop->wsFlags ^ 16 != pLoop->wsFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 94);
}
if( pLoop->wsFlags&WHERE_TOP_LIMIT ){
    
// ABS Label 95
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}

// ABS Label 96
if(pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}

// ABS Label 97
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// ABS Label 98
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
explainAppendTerm(pStr, pIndex, pLoop->u.btree.nTop, j, i, "<");
  }
  
// ABS Label 65
if(pStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
sqlite3_str_append(pStr, ")", 1);
}

/*
** This function is a no-op unless currently processing an EXPLAIN QUERY PLAN
** command, or if either SQLITE_DEBUG or SQLITE_ENABLE_STMT_SCANSTATUS was
** defined at compile-time. If it is not a no-op, a single OP_Explain opcode 
** is added to the output to describe the table scan strategy in pLevel.
**
** If an OP_Explain opcode is added to the VM, its address is returned.
** Otherwise, if no OP_Explain is coded, zero is returned.
*/
int sqlite3WhereExplainOneScan(
  Parse *pParse,                  /* Parse context */
  SrcList *pTabList,              /* Table list this loop refers to */
  WhereLevel *pLevel,             /* Scan to write OP_Explain opcode for */
  u16 wctrlFlags                  /* Flags passed to sqlite3WhereBegin() */
){
  int ret = 0;
#if !defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_STMT_SCANSTATUS)
  
// ROR Label 99
if((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->explain != 2) != (((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->explain == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
if( sqlite3ParseToplevel(pParse)->explain==2 )
#endif
  {
    SrcItem *pItem = &pTabList->a[pLevel->iFrom];
    
// ABS Label 100
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
Vdbe *v = pParse->pVdbe;      /* VM being constructed */
    
// ABS Label 101
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
sqlite3 *db = pParse->db;     /* Database handle */
    int isSearch;                 /* True for a SEARCH. False for SCAN. */
    WhereLoop *pLoop;             /* The controlling WhereLoop object */
    u32 flags;                    /* Flags that describe this loop */
    char *zMsg;                   /* Text to add to EQP output */
    StrAccum str;                 /* EQP output string */
    char zBuf[100];               /* Initial space for EQP output string */

    pLoop = pLevel->pWLoop;
    flags = pLoop->wsFlags;
    
// COR Label 104
if(((flags & 8192) && (wctrlFlags & 32)) != ((flags & 8192) || (wctrlFlags & 32)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 104);
}

// MCC Label 105
if(( flags & 8192 ) && ( wctrlFlags & 32 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 105);
}
// MCC Label 106
if(( flags & 8192 ) && ( !(wctrlFlags & 32) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 106);
}
// MCC Label 107
if(( !(flags & 8192) ) && ( wctrlFlags & 32 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 107);
}
// MCC Label 108
if(( !(flags & 8192) ) && ( !(wctrlFlags & 32) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
if( (flags&WHERE_MULTI_OR) || (wctrlFlags&WHERE_OR_SUBCLAUSE) ) { return 0;
}

    isSearch = (flags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))!=0
            || ((flags&WHERE_VIRTUALTABLE)==0 && (pLoop->u.btree.nEq>0))
            || (wctrlFlags&(WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX));

    
// ABS Label 102
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), SQLITE_MAX_LENGTH);
    str.printfFlags = SQLITE_PRINTF_INTERNAL;
    
// ABS Label 103
if(pItem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
sqlite3_str_appendf(&str, "%s %S", isSearch ? "SEARCH" : "SCAN", pItem);
    
// ROR Label 109
if(((flags & (256 | 1024)) != 0) != ((flags & (256 | 1024)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}
if( (flags & (WHERE_IPK|WHERE_VIRTUALTABLE))==0 ){
      const char *zFmt = 0;
      Index *pIdx;

      assert( pLoop->u.btree.pIndex!=0 );
      pIdx = pLoop->u.btree.pIndex;
      assert( !(flags&WHERE_AUTO_INDEX) || (flags&WHERE_IDX_ONLY) );
      
// COR Label 110
if((!(((pItem->pTab)->tabFlags & 128) == 0) || ((pIdx)->idxType == 2)) != (!(((pItem->pTab)->tabFlags & 128) == 0) && ((pIdx)->idxType == 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 110);
}

// MCC Label 111
if(!(((pItem->pTab)->tabFlags & 128) == 0) && ( (pIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
// MCC Label 112
if(!(((pItem->pTab)->tabFlags & 128) == 0) && ( !((pIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(!(!(((pItem->pTab)->tabFlags & 128) == 0)) && ( (pIdx)->idxType == 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
// MCC Label 114
if(!(!(((pItem->pTab)->tabFlags & 128) == 0)) && ( !((pIdx)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 114);
}
if( !HasRowid(pItem->pTab) && IsPrimaryKeyIndex(pIdx) ){
        
// ABS Label 115
if(isSearch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
if( isSearch ){
          zFmt = "PRIMARY KEY";
        }
      }else { 
// ABS Label 116
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// AOR Label 117
if(flags | 131072 != flags & 131072)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 117);
}
// AOR Label 118
if(flags ^ 131072 != flags & 131072)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 118);
}
if( flags & WHERE_PARTIALIDX ){
        zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
      }else { 
// ABS Label 119
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}

// AOR Label 120
if(flags | 16384 != flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 120);
}
// AOR Label 121
if(flags ^ 16384 != flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 121);
}
if( flags & WHERE_AUTO_INDEX ){
        zFmt = "AUTOMATIC COVERING INDEX";
      }else { 
// ABS Label 122
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// AOR Label 123
if(flags | 64 != flags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 123);
}
// AOR Label 124
if(flags ^ 64 != flags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 124);
}
if( flags & WHERE_IDX_ONLY ){
        zFmt = "COVERING INDEX %s";
      }else{
        zFmt = "INDEX %s";
      };}
;}
;}

      
// ABS Label 125
if(zFmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
if( zFmt ){
        sqlite3_str_append(&str, " USING ", 7);
        
// ABS Label 126
if(zFmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// ABS Label 127
if(pIdx->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}
sqlite3_str_appendf(&str, zFmt, pIdx->zName);
        
// ABS Label 128
if(pLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}
explainIndexRange(&str, pLoop);
      }
    }else { 
// COR Label 129
if(((flags & 256) != 0 || (flags & 15) != 0) != ((flags & 256) != 0 && (flags & 15) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 129);
}

// ROR Label 130
if(((flags & 256) == 0) != ((flags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if(((flags & 15) == 0) != ((flags & 15) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}

// MCC Label 132
if((flags & 256) != 0 && (flags & 15) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
// MCC Label 133
if((flags & 256) != 0 && !((flags & 15) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 133);
}
// MCC Label 134
if(!((flags & 256) != 0) && (flags & 15) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 134);
}
// MCC Label 135
if(!((flags & 256) != 0) && !((flags & 15) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
if( (flags & WHERE_IPK)!=0 && (flags & WHERE_CONSTRAINT)!=0 ){
      const char *zRangeOp;
      
// ABS Label 137
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}

// AOR Label 138
if(flags | (1 | 4) != flags & (1 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 138);
}
// AOR Label 139
if(flags ^ (1 | 4) != flags & (1 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 139);
}
if( flags&(WHERE_COLUMN_EQ|WHERE_COLUMN_IN) ){
        zRangeOp = "=";
      }else { 
// ROR Label 140
if(((flags & 48) != 48) != ((flags & 48) == 48))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 140);
}
if( (flags&WHERE_BOTH_LIMIT)==WHERE_BOTH_LIMIT ){
        zRangeOp = ">? AND rowid<";
      }else { 
// ABS Label 141
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// AOR Label 142
if(flags | 32 != flags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 142);
}
// AOR Label 143
if(flags ^ 32 != flags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 143);
}
if( flags&WHERE_BTM_LIMIT ){
        zRangeOp = ">";
      }else{
        assert( flags&WHERE_TOP_LIMIT);
        zRangeOp = "<";
      };}
;}

      
// ABS Label 136
if(zRangeOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
sqlite3_str_appendf(&str, 
          " USING INTEGER PRIMARY KEY (rowid%s?)",zRangeOp);
    }
#ifndef SQLITE_OMIT_VIRTUALTABLE
    else { 
// ROR Label 144
if(((flags & 1024) == 0) != ((flags & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( (flags & WHERE_VIRTUALTABLE)!=0 ){
      
// ABS Label 145
if(pLoop->u.vtab.idxNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}

// ABS Label 146
if(pLoop->u.vtab.idxStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
sqlite3_str_appendf(&str, " VIRTUAL TABLE INDEX %d:%s",
                  pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr);
    };}
;}

#endif
#ifdef SQLITE_EXPLAIN_ESTIMATED_ROWS
    if( pLoop->nOut>=10 ){
      sqlite3_str_appendf(&str, " (~%llu rows)",
             sqlite3LogEstToInt(pLoop->nOut));
    }else{
      sqlite3_str_append(&str, " (~1 row)", 9);
    }
#endif
    zMsg = sqlite3StrAccumFinish(&str);
    sqlite3ExplainBreakpoint("",zMsg);
    ret = sqlite3VdbeAddOp4(v, OP_Explain, sqlite3VdbeCurrentAddr(v),
                            pParse->addrExplain, 0, zMsg,P4_DYNAMIC);
  }
  
// ABS Label 147
if(ret < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
return ret;
}
#endif /* SQLITE_OMIT_EXPLAIN */

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
/*
** Configure the VM passed as the first argument with an
** sqlite3_stmt_scanstatus() entry corresponding to the scan used to 
** implement level pLvl. Argument pSrclist is a pointer to the FROM 
** clause that the scan reads data from.
**
** If argument addrExplain is not 0, it must be the address of an 
** OP_Explain instruction that describes the same loop.
*/
void sqlite3WhereAddScanStatus(
  Vdbe *v,                        /* Vdbe to add scanstatus entry to */
  SrcList *pSrclist,              /* FROM clause pLvl reads data from */
  WhereLevel *pLvl,               /* Level to add scanstatus() entry for */
  int addrExplain                 /* Address of OP_Explain (or 0) */
){
  const char *zObj = 0;
  WhereLoop *pLoop = pLvl->pWLoop;
  if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0  &&  pLoop->u.btree.pIndex!=0 ){
    zObj = pLoop->u.btree.pIndex->zName;
  }else{
    zObj = pSrclist->a[pLvl->iFrom].zName;
  }
  sqlite3VdbeScanStatus(
      v, addrExplain, pLvl->addrBody, pLvl->addrVisit, pLoop->nOut, zObj
  );
}
#endif


/*
** Disable a term in the WHERE clause.  Except, do not disable the term
** if it controls a LEFT OUTER JOIN and it did not originate in the ON
** or USING clause of that join.
**
** Consider the term t2.z='ok' in the following queries:
**
**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'
**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'
**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'
**
** The t2.z='ok' is disabled in the in (2) because it originates
** in the ON clause.  The term is disabled in (3) because it is not part
** of a LEFT OUTER JOIN.  In (1), the term is not disabled.
**
** Disabling a term causes that term to not be tested in the inner loop
** of the join.  Disabling is an optimization.  When terms are satisfied
** by indices, we disable them to prevent redundant tests in the inner
** loop.  We would get the correct results if nothing were ever disabled,
** but joins might run a little slower.  The trick is to disable as much
** as we can without disabling too much.  If we disabled in (1), we'd get
** the wrong answer.  See ticket #813.
**
** If all the children of a term are disabled, then that term is also
** automatically disabled.  In this way, terms get disabled if derived
** virtual terms are tested first.  For example:
**
**      x GLOB 'abc*' AND x>='abc' AND x<'acd'
**      \___________/     \______/     \_____/
**         parent          child1       child2
**
** Only the parent term was in the original WHERE clause.  The child1
** and child2 terms were added by the LIKE optimization.  If both of
** the virtual child terms are valid, then testing of the parent can be 
** skipped.
**
** Usually the parent term is marked as TERM_CODED.  But if the parent
** term was originally TERM_LIKE, then the parent gets TERM_LIKECOND instead.
** The TERM_LIKECOND marking indicates that the term should be coded inside
** a conditional such that is only evaluated on the second pass of a
** LIKE-optimization loop, when scanning BLOBs instead of strings.
*/
static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){
  int nLoop = 0;
  assert( pTerm!=0 );
  
// COR Label 148
if(((pTerm->wtFlags & 4) == 0 && (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0)) || (pLevel->notReady & pTerm->prereqAll) == 0) != ((pTerm->wtFlags & 4) == 0 && (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0)) && (pLevel->notReady & pTerm->prereqAll) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 148);
}
// COR Label 149
if(((pTerm->wtFlags & 4) == 0 || (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0))) != ((pTerm->wtFlags & 4) == 0 && (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 149);
}

// ROR Label 150
if(((pTerm->wtFlags & 4) != 0) != ((pTerm->wtFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if(((pLevel->notReady & pTerm->prereqAll) != 0) != ((pLevel->notReady & pTerm->prereqAll) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}

// MCC Label 152
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 152);
}
// MCC Label 153
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 153);
}
// MCC Label 154
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 154);
}
// MCC Label 155
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 155);
}
// MCC Label 156
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 156);
}
// MCC Label 157
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
// MCC Label 158
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
// MCC Label 159
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 159);
}
// MCC Label 160
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 160);
}
// MCC Label 161
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 161);
}
// MCC Label 162
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 162);
}
// MCC Label 163
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 163);
}
// MCC Label 164
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
// MCC Label 166
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
while( (pTerm->wtFlags & TERM_CODED)==0
      && (pLevel->iLeftJoin==0 || ExprHasProperty(pTerm->pExpr, EP_FromJoin))
      && (pLevel->notReady & pTerm->prereqAll)==0
  ){
    
// ABS Label 188
if(nLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// COR Label 189
if((nLoop || (pTerm->wtFlags & 1024) != 0) != (nLoop && (pTerm->wtFlags & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 189);
}

// ROR Label 190
if(((pTerm->wtFlags & 1024) == 0) != ((pTerm->wtFlags & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}

// MCC Label 191
if(nLoop && (pTerm->wtFlags & 1024) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 191);
}
// MCC Label 192
if(nLoop && !((pTerm->wtFlags & 1024) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 192);
}
// MCC Label 193
if(!(nLoop) && (pTerm->wtFlags & 1024) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 193);
}
// MCC Label 194
if(!(nLoop) && !((pTerm->wtFlags & 1024) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
if( nLoop && (pTerm->wtFlags & TERM_LIKE)!=0 ){
      pTerm->wtFlags |= TERM_LIKECOND;
    }else{
      pTerm->wtFlags |= TERM_CODED;
    }
#ifdef WHERETRACE_ENABLED
    if( sqlite3WhereTrace & 0x20000 ){
      sqlite3DebugPrintf("DISABLE-");
      sqlite3WhereTermPrint(pTerm, (int)(pTerm - (pTerm->pWC->a)));
    }
#endif
    
// ABS Label 195
if(pTerm->iParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}

// ROR Label 196
if((pTerm->iParent <= 0) != (pTerm->iParent < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}
// ROR Label 197
if((pTerm->iParent > 0) != (pTerm->iParent < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 197);
}
// ROR Label 198
if((pTerm->iParent >= 0) != (pTerm->iParent < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 198);
}
if( pTerm->iParent<0 ) { break;
}
    pTerm = &pTerm->pWC->a[pTerm->iParent];
    assert( pTerm!=0 );
    pTerm->nChild--;
    
// ROR Label 199
if((pTerm->nChild == 0) != (pTerm->nChild != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
if( pTerm->nChild!=0 ) { break;
}
    nLoop++;
  };
// COR Label 168
if(((pTerm->wtFlags & 4) == 0 && (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0)) || (pLevel->notReady & pTerm->prereqAll) == 0) != ((pTerm->wtFlags & 4) == 0 && (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0)) && (pLevel->notReady & pTerm->prereqAll) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 168);
}
// COR Label 169
if(((pTerm->wtFlags & 4) == 0 || (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0))) != ((pTerm->wtFlags & 4) == 0 && (pLevel->iLeftJoin == 0 || (((pTerm->pExpr)->flags & (1)) != 0))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 169);
}

// ROR Label 170
if(((pTerm->wtFlags & 4) != 0) != ((pTerm->wtFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 170);
}
// ROR Label 171
if(((pLevel->notReady & pTerm->prereqAll) != 0) != ((pLevel->notReady & pTerm->prereqAll) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 171);
}

// MCC Label 172
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}
// MCC Label 173
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 173);
}
// MCC Label 174
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 174);
}
// MCC Label 175
if((pTerm->wtFlags & 4) == 0 && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 175);
}
// MCC Label 176
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if((pTerm->wtFlags & 4) == 0 && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(!((pTerm->wtFlags & 4) == 0) && ( pLevel->iLeftJoin == 0 && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}
// MCC Label 185
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( ((pTerm->pExpr)->flags & (1)) != 0 ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 185);
}
// MCC Label 186
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && (pLevel->notReady & pTerm->prereqAll) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 186);
}
// MCC Label 187
if(!((pTerm->wtFlags & 4) == 0) && ( !(pLevel->iLeftJoin == 0) && ( !(((pTerm->pExpr)->flags & (1)) != 0) ) ) && !((pLevel->notReady & pTerm->prereqAll) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}

}

/*
** Code an OP_Affinity opcode to apply the column affinity string zAff
** to the n registers starting at base. 
**
** As an optimization, SQLITE_AFF_BLOB and SQLITE_AFF_NONE entries (which
** are no-ops) at the beginning and end of zAff are ignored.  If all entries
** in zAff are SQLITE_AFF_BLOB or SQLITE_AFF_NONE, then no code gets generated.
**
** This routine makes its own copy of zAff so that the caller is free
** to modify zAff after this routine returns.
*/
static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){
  
// ABS Label 200
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
Vdbe *v = pParse->pVdbe;
  
// ABS Label 201
if(zAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}

// ROR Label 202
if((zAff != 0) != (zAff == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
if( zAff==0 ){
    assert( pParse->db->mallocFailed );
    return;
  }
  assert( v!=0 );

  /* Adjust base and n to skip over SQLITE_AFF_BLOB and SQLITE_AFF_NONE
  ** entries at the beginning and end of the affinity string.
  */
  assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );
  
// ABS Label 203
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}

// COR Label 204
if((n > 0 || zAff[0] <= 65) != (n > 0 && zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 204);
}

// ROR Label 205
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
// ROR Label 208
if((zAff[0] < 65) != (zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((zAff[0] > 65) != (zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((zAff[0] >= 65) != (zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}

// MCC Label 211
if(n > 0 && zAff[0] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if(n > 0 && !(zAff[0] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(!(n > 0) && zAff[0] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(!(n > 0) && !(zAff[0] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
while( n>0 && zAff[0]<=SQLITE_AFF_BLOB ){
    n--;
    base++;
    zAff++;
  };
// ABS Label 215
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}

// COR Label 216
if((n > 0 || zAff[0] <= 65) != (n > 0 && zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 216);
}

// ROR Label 217
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
// ROR Label 218
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
// ROR Label 219
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
// ROR Label 220
if((zAff[0] < 65) != (zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 220);
}
// ROR Label 221
if((zAff[0] > 65) != (zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 221);
}
// ROR Label 222
if((zAff[0] >= 65) != (zAff[0] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}

// MCC Label 223
if(n > 0 && zAff[0] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(n > 0 && !(zAff[0] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(!(n > 0) && zAff[0] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(!(n > 0) && !(zAff[0] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}

  
// ABS Label 227
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}

// COR Label 228
if((n > 1 || zAff[n - 1] <= 65) != (n > 1 && zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 228);
}

// ROR Label 229
if((n <= 1) != (n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 229);
}
// ROR Label 230
if((n < 1) != (n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 230);
}
// ROR Label 231
if((n >= 1) != (n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 231);
}
// ROR Label 232
if((zAff[n - 1] < 65) != (zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
// ROR Label 233
if((zAff[n - 1] > 65) != (zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 233);
}
// ROR Label 234
if((zAff[n - 1] >= 65) != (zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}

// MCC Label 235
if(n > 1 && zAff[n - 1] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
// MCC Label 236
if(n > 1 && !(zAff[n - 1] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
// MCC Label 237
if(!(n > 1) && zAff[n - 1] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 237);
}
// MCC Label 238
if(!(n > 1) && !(zAff[n - 1] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 238);
}
while( n>1 && zAff[n-1]<=SQLITE_AFF_BLOB ){
    n--;
  };
// ABS Label 239
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// COR Label 240
if((n > 1 || zAff[n - 1] <= 65) != (n > 1 && zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 240);
}

// ROR Label 241
if((n <= 1) != (n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((n < 1) != (n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
// ROR Label 243
if((n >= 1) != (n > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
// ROR Label 244
if((zAff[n - 1] < 65) != (zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}
// ROR Label 245
if((zAff[n - 1] > 65) != (zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 245);
}
// ROR Label 246
if((zAff[n - 1] >= 65) != (zAff[n - 1] <= 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}

// MCC Label 247
if(n > 1 && zAff[n - 1] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(n > 1 && !(zAff[n - 1] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
// MCC Label 249
if(!(n > 1) && zAff[n - 1] <= 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 249);
}
// MCC Label 250
if(!(n > 1) && !(zAff[n - 1] <= 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 250);
}


  /* Code the OP_Affinity opcode if there is anything left to do. */
  
// ABS Label 251
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ROR Label 252
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
// ROR Label 254
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
if( n>0 ){
    
// ABS Label 255
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}

// ABS Label 256
if(base < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ABS Label 257
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}

// ABS Label 258
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}
sqlite3VdbeAddOp4(v, OP_Affinity, base, n, 0, zAff, n);
  }
}

/*
** Expression pRight, which is the RHS of a comparison operation, is 
** either a vector of n elements or, if n==1, a scalar expression.
** Before the comparison operation, affinity zAff is to be applied
** to the pRight values. This function modifies characters within the
** affinity string to SQLITE_AFF_BLOB if either:
**
**   * the comparison will be performed with no affinity, or
**   * the affinity change in zAff is guaranteed not to change the value.
*/
static void updateRangeAffinityStr(
  Expr *pRight,                   /* RHS of comparison */
  int n,                          /* Number of vector elements in comparison */
  char *zAff                      /* Affinity string to modify */
){
  int i;
  i = 0;

// ABS Label 259
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}
// ABS Label 260
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}

// ROR Label 261
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 261);
}
// ROR Label 262
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}
for(; i<n; i++){
    Expr *p = sqlite3VectorFieldSubexpr(pRight, i);
    if( sqlite3CompareAffinity(p, zAff[i])==SQLITE_AFF_BLOB
     || sqlite3ExprNeedsNoAffinityChange(p, zAff[i])
    ){
      zAff[i] = SQLITE_AFF_BLOB;
    }
  };
// ABS Label 264
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
// ABS Label 265
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}

// ROR Label 266
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}
// ROR Label 267
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}

}


/*
** pX is an expression of the form:  (vector) IN (SELECT ...)
** In other words, it is a vector IN operator with a SELECT clause on the
** LHS.  But not all terms in the vector are indexable and the terms might
** not be in the correct order for indexing.
**
** This routine makes a copy of the input pX expression and then adjusts
** the vector on the LHS with corresponding changes to the SELECT so that
** the vector contains only index terms and those terms are in the correct
** order.  The modified IN expression is returned.  The caller is responsible
** for deleting the returned expression.
**
** Example:
**
**    CREATE TABLE t1(a,b,c,d,e,f);
**    CREATE INDEX t1x1 ON t1(e,c);
**    SELECT * FROM t1 WHERE (a,b,c,d,e) IN (SELECT v,w,x,y,z FROM t2)
**                           \_______________________________________/
**                                     The pX expression
**
** Since only columns e and c can be used with the index, in that order,
** the modified IN expression that is returned will be:
**
**        (e,c) IN (SELECT z,x FROM t2)
**
** The reduced pX is different from the original (obviously) and thus is
** only used for indexing, to improve performance.  The original unaltered
** IN expression must also be run on each output row for correctness.
*/
static Expr *removeUnindexableInClauseTerms(
  Parse *pParse,        /* The parsing context */
  int iEq,              /* Look at loop terms starting here */
  WhereLoop *pLoop,     /* The current loop */
  Expr *pX              /* The IN expression to be reduced */
){
  
// ABS Label 269
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
sqlite3 *db = pParse->db;
  Expr *pNew;
  pNew = sqlite3ExprDup(db, pX, 0);
  
// ROR Label 270
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 270);
}
if( db->mallocFailed==0 ){
    
// ABS Label 271
if(pNew->x.pSelect->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
ExprList *pOrigRhs = pNew->x.pSelect->pEList;  /* Original unmodified RHS */
    
// ABS Label 272
if(pNew->pLeft->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
ExprList *pOrigLhs = pNew->pLeft->x.pList;     /* Original unmodified LHS */
    ExprList *pRhs = 0;         /* New RHS after modifications */
    ExprList *pLhs = 0;         /* New LHS after mods */
    int i;                      /* Loop counter */
    Select *pSelect;            /* Pointer to the SELECT on the RHS */

    i = iEq;

// ABS Label 277
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}

// ROR Label 278
if((i <= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 278);
}
// ROR Label 279
if((i > pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((i >= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
for(; i<pLoop->nLTerm; i++){
      
// ABS Label 285
if(pLoop->aLTerm[i]->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
// ABS Label 286
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ROR Label 287
if((pLoop->aLTerm[i]->pExpr != pX) != (pLoop->aLTerm[i]->pExpr == pX))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
if( pLoop->aLTerm[i]->pExpr==pX ){
        
// ABS Label 288
if(pLoop->aLTerm[i]->u.x.iField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}

// AOR Label 289
if(pLoop->aLTerm[i]->u.x.iField / 1 != pLoop->aLTerm[i]->u.x.iField - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 289);
}
// AOR Label 290
if(pLoop->aLTerm[i]->u.x.iField + 1 != pLoop->aLTerm[i]->u.x.iField - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 290);
}
// AOR Label 291
if(pLoop->aLTerm[i]->u.x.iField * 1 != pLoop->aLTerm[i]->u.x.iField - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 291);
}
int iField = pLoop->aLTerm[i]->u.x.iField - 1;
        
// ABS Label 292
if(pOrigRhs->a[iField].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}

// ROR Label 293
if((pOrigRhs->a[iField].pExpr != 0) != (pOrigRhs->a[iField].pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 293);
}
if( pOrigRhs->a[iField].pExpr==0 ) { continue; /* Duplicate PK column */
}
        pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);
        pOrigRhs->a[iField].pExpr = 0;
        assert( pOrigLhs->a[iField].pExpr!=0 );
        pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs->a[iField].pExpr);
        pOrigLhs->a[iField].pExpr = 0;
      }
    };
// ABS Label 281
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// ROR Label 282
if((i <= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
// ROR Label 283
if((i > pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 283);
}
// ROR Label 284
if((i >= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}

    
// ABS Label 273
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

// ABS Label 274
if(pOrigRhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
sqlite3ExprListDelete(db, pOrigRhs);
    
// ABS Label 275
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}

// ABS Label 276
if(pOrigLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
sqlite3ExprListDelete(db, pOrigLhs);
    pNew->pLeft->x.pList = pLhs;
    pNew->x.pSelect->pEList = pRhs;
    
// ABS Label 294
if(pLhs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
// ABS Label 295
if(pLhs->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// COR Label 296
if((pLhs || pLhs->nExpr == 1) != (pLhs && pLhs->nExpr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 296);
}

// ROR Label 297
if((pLhs->nExpr != 1) != (pLhs->nExpr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}

// MCC Label 298
if(pLhs && pLhs->nExpr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 298);
}
// MCC Label 299
if(pLhs && !(pLhs->nExpr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 299);
}
// MCC Label 300
if(!(pLhs) && pLhs->nExpr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 300);
}
// MCC Label 301
if(!(pLhs) && !(pLhs->nExpr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 301);
}
if( pLhs && pLhs->nExpr==1 ){
      /* Take care here not to generate a TK_VECTOR containing only a
      ** single value. Since the parser never creates such a vector, some
      ** of the subroutines do not handle this case.  */
      
// ABS Label 302
if(pLhs->a[0].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
Expr *p = pLhs->a[0].pExpr;
      pLhs->a[0].pExpr = 0;
      
// ABS Label 303
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ABS Label 304
if(pNew->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
sqlite3ExprDelete(db, pNew->pLeft);
      pNew->pLeft = p;
    }
    pSelect = pNew->x.pSelect;
    
// ABS Label 305
if(pSelect->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
if( pSelect->pOrderBy ){
      /* If the SELECT statement has an ORDER BY clause, zero the 
      ** iOrderByCol variables. These are set to non-zero when an 
      ** ORDER BY term exactly matches one of the terms of the 
      ** result-set. Since the result-set of the SELECT statement may
      ** have been modified or reordered, these variables are no longer 
      ** set correctly.  Since setting them is just an optimization, 
      ** it's easiest just to zero them here.  */
      
// ABS Label 306
if(pSelect->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
ExprList *pOrderBy = pSelect->pOrderBy;
      i = 0;

// ABS Label 307
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
// ABS Label 308
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// ROR Label 309
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
// ROR Label 310
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
for(; i<pOrderBy->nExpr; i++){
        pOrderBy->a[i].u.x.iOrderByCol = 0;
      };
// ABS Label 312
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
// ABS Label 313
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}

// ROR Label 314
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
// ROR Label 315
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}
// ROR Label 316
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}

    }

#if 0
    printf("For indexing, change the IN expr:\n");
    sqlite3TreeViewExpr(0, pX, 0);
    printf("Into:\n");
    sqlite3TreeViewExpr(0, pNew, 0);
#endif
  }
  
// ABS Label 317
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
return pNew;
}


/*
** Generate code for a single equality term of the WHERE clause.  An equality
** term can be either X=expr or X IN (...).   pTerm is the term to be 
** coded.
**
** The current value for the constraint is left in a register, the index
** of which is returned.  An attempt is made store the result in iTarget but
** this is only guaranteed for TK_ISNULL and TK_IN constraints.  If the
** constraint is a TK_EQ or TK_IS, then the current value might be left in
** some other register and it is the caller's responsibility to compensate.
**
** For a constraint of the form X=expr, the expression is evaluated in
** straight-line code.  For constraints of the form X IN (...)
** this routine sets up a loop that will iterate over all values of X.
*/
static int codeEqualityTerm(
  Parse *pParse,      /* The parsing context */
  WhereTerm *pTerm,   /* The term of the WHERE clause to be coded */
  WhereLevel *pLevel, /* The level of the FROM clause we are working on */
  int iEq,            /* Index of the equality term within this level */
  int bRev,           /* True for reverse-order IN operations */
  int iTarget         /* Attempt to leave results in this register */
){
  
// ABS Label 318
if(pTerm->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
Expr *pX = pTerm->pExpr;
  
// ABS Label 319
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
Vdbe *v = pParse->pVdbe;
  int iReg;                  /* Register holding results */

  assert( pLevel->pWLoop->aLTerm[iEq]==pTerm );
  assert( iTarget>0 );
  
// COR Label 320
if((pX->op == 53 && pX->op == 45) != (pX->op == 53 || pX->op == 45))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 320);
}

// ROR Label 321
if((pX->op != 53) != (pX->op == 53))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 321);
}
// ROR Label 322
if((pX->op != 45) != (pX->op == 45))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}

// MCC Label 323
if(pX->op == 53 && pX->op == 45 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
// MCC Label 324
if(pX->op == 53 && !(pX->op == 45) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 324);
}
// MCC Label 325
if(!(pX->op == 53) && pX->op == 45 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 325);
}
// MCC Label 326
if(!(pX->op == 53) && !(pX->op == 45) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 326);
}
if( pX->op==TK_EQ || pX->op==TK_IS ){
    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
  }else { 
// ROR Label 327
if((pX->op != 50) != (pX->op == 50))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
if( pX->op==TK_ISNULL ){
    iReg = iTarget;
    
// ABS Label 328
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ABS Label 329
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, iReg);
#ifndef SQLITE_OMIT_SUBQUERY
  }else{
    int eType = IN_INDEX_NOOP;
    int iTab;
    struct InLoop *pIn;
    
// ABS Label 330
if(pLevel->pWLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
WhereLoop *pLoop = pLevel->pWLoop;
    int i;
    int nEq = 0;
    int *aiMap = 0;

    
// ABS Label 334
if(pLoop->u.btree.pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}

// COR Label 335
if(((pLoop->wsFlags & 1024) == 0 && pLoop->u.btree.pIndex != 0 || pLoop->u.btree.pIndex->aSortOrder[iEq]) != ((pLoop->wsFlags & 1024) == 0 && pLoop->u.btree.pIndex != 0 && pLoop->u.btree.pIndex->aSortOrder[iEq]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 335);
}
// COR Label 336
if(((pLoop->wsFlags & 1024) == 0 || pLoop->u.btree.pIndex != 0) != ((pLoop->wsFlags & 1024) == 0 && pLoop->u.btree.pIndex != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 336);
}

// ROR Label 337
if(((pLoop->wsFlags & 1024) != 0) != ((pLoop->wsFlags & 1024) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
// ROR Label 338
if((pLoop->u.btree.pIndex == 0) != (pLoop->u.btree.pIndex != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}

// MCC Label 339
if((pLoop->wsFlags & 1024) == 0 && pLoop->u.btree.pIndex != 0 && pLoop->u.btree.pIndex->aSortOrder[iEq] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 339);
}
// MCC Label 340
if((pLoop->wsFlags & 1024) == 0 && pLoop->u.btree.pIndex != 0 && !(pLoop->u.btree.pIndex->aSortOrder[iEq]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 340);
}
// MCC Label 341
if((pLoop->wsFlags & 1024) == 0 && !(pLoop->u.btree.pIndex != 0) && pLoop->u.btree.pIndex->aSortOrder[iEq] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 341);
}
// MCC Label 342
if((pLoop->wsFlags & 1024) == 0 && !(pLoop->u.btree.pIndex != 0) && !(pLoop->u.btree.pIndex->aSortOrder[iEq]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 342);
}
// MCC Label 343
if(!((pLoop->wsFlags & 1024) == 0) && pLoop->u.btree.pIndex != 0 && pLoop->u.btree.pIndex->aSortOrder[iEq] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 343);
}
// MCC Label 344
if(!((pLoop->wsFlags & 1024) == 0) && pLoop->u.btree.pIndex != 0 && !(pLoop->u.btree.pIndex->aSortOrder[iEq]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 344);
}
// MCC Label 345
if(!((pLoop->wsFlags & 1024) == 0) && !(pLoop->u.btree.pIndex != 0) && pLoop->u.btree.pIndex->aSortOrder[iEq] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 345);
}
// MCC Label 346
if(!((pLoop->wsFlags & 1024) == 0) && !(pLoop->u.btree.pIndex != 0) && !(pLoop->u.btree.pIndex->aSortOrder[iEq]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 346);
}
if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0
      && pLoop->u.btree.pIndex!=0
      && pLoop->u.btree.pIndex->aSortOrder[iEq]
    ){
      testcase( iEq==0 );
      testcase( bRev );
      bRev = !bRev;
    }
    assert( pX->op==TK_IN );
    iReg = iTarget;

    i = 0;

// ABS Label 347
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}
// ABS Label 348
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}

// ROR Label 349
if((i <= iEq) != (i < iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 349);
}
// ROR Label 350
if((i > iEq) != (i < iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 350);
}
// ROR Label 351
if((i >= iEq) != (i < iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 351);
}
for(; i<iEq; i++){
      
// ABS Label 357
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}
// ABS Label 358
if(pLoop->aLTerm[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}
// ABS Label 359
if(pLoop->aLTerm[i]->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}
// ABS Label 360
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}

// COR Label 361
if((pLoop->aLTerm[i] || pLoop->aLTerm[i]->pExpr == pX) != (pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr == pX))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 361);
}

// ROR Label 362
if((pLoop->aLTerm[i]->pExpr != pX) != (pLoop->aLTerm[i]->pExpr == pX))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}

// MCC Label 363
if(pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr == pX ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
// MCC Label 364
if(pLoop->aLTerm[i] && !(pLoop->aLTerm[i]->pExpr == pX) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 364);
}
// MCC Label 365
if(!(pLoop->aLTerm[i]) && pLoop->aLTerm[i]->pExpr == pX ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 365);
}
// MCC Label 366
if(!(pLoop->aLTerm[i]) && !(pLoop->aLTerm[i]->pExpr == pX) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 366);
}
if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){
        
// ABS Label 367
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}

// ABS Label 368
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}
disableTerm(pLevel, pTerm);
        
// ABS Label 369
if(iTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
return iTarget;
      }
    };
// ABS Label 352
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}
// ABS Label 353
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}

// ROR Label 354
if((i <= iEq) != (i < iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}
// ROR Label 355
if((i > iEq) != (i < iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}
// ROR Label 356
if((i >= iEq) != (i < iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 356);
}

    i = iEq;

// ABS Label 370
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}

// ROR Label 371
if((i <= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 371);
}
// ROR Label 372
if((i > pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 372);
}
// ROR Label 373
if((i >= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 373);
}
for(;i<pLoop->nLTerm; i++){
      assert( pLoop->aLTerm[i]!=0 );
      
// ABS Label 378
if(pLoop->aLTerm[i]->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 378);
}
// ABS Label 379
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// ROR Label 380
if((pLoop->aLTerm[i]->pExpr != pX) != (pLoop->aLTerm[i]->pExpr == pX))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 380);
}
if( pLoop->aLTerm[i]->pExpr==pX ) { nEq++;
}
    };
// ABS Label 374
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}

// ROR Label 375
if((i <= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
// ROR Label 376
if((i > pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((i >= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}


    iTab = 0;
    
// ABS Label 381
if(pX->x.pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 381);
}

// COR Label 382
if(((pX->flags & 2048) == 0 && pX->x.pSelect->pEList->nExpr == 1) != ((pX->flags & 2048) == 0 || pX->x.pSelect->pEList->nExpr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 382);
}

// ROR Label 383
if(((pX->flags & 2048) != 0) != ((pX->flags & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 383);
}
// ROR Label 384
if((pX->x.pSelect->pEList->nExpr != 1) != (pX->x.pSelect->pEList->nExpr == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 384);
}

// MCC Label 385
if((pX->flags & 2048) == 0 && pX->x.pSelect->pEList->nExpr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
// MCC Label 386
if((pX->flags & 2048) == 0 && !(pX->x.pSelect->pEList->nExpr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 386);
}
// MCC Label 387
if(!((pX->flags & 2048) == 0) && pX->x.pSelect->pEList->nExpr == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 387);
}
// MCC Label 388
if(!((pX->flags & 2048) == 0) && !(pX->x.pSelect->pEList->nExpr == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 388);
}
if( (pX->flags & EP_xIsSelect)==0 || pX->x.pSelect->pEList->nExpr==1 ){
      eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, 0, &iTab);
    }else{
      
// ABS Label 389
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}
sqlite3 *db = pParse->db;
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);

      if( !db->mallocFailed ){
        aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*nEq);
        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);
        pTerm->pExpr->iTable = iTab;
      }
      
// ABS Label 390
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}

// ABS Label 391
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}
sqlite3ExprDelete(db, pX);
      pX = pTerm->pExpr;
    }

    
// ABS Label 392
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

// ROR Label 393
if((eType != 4) != (eType == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 393);
}
if( eType==IN_INDEX_INDEX_DESC ){
      testcase( bRev );
      bRev = !bRev;
    }
    
// ABS Label 331
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}

// ABS Label 332
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}
sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iTab, 0);
    VdbeCoverageIf(v, bRev);
    VdbeCoverageIf(v, !bRev);
    assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );

    pLoop->wsFlags |= WHERE_IN_ABLE;
    
// ABS Label 394
if(pLevel->u.in.nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}

// ROR Label 395
if((pLevel->u.in.nIn != 0) != (pLevel->u.in.nIn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 395);
}
if( pLevel->u.in.nIn==0 ){
      pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);
    }
    
// ABS Label 396
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}

// COR Label 397
if((iEq > 0 || (pLoop->wsFlags & 1048576) == 0) != (iEq > 0 && (pLoop->wsFlags & 1048576) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 397);
}

// ROR Label 398
if((iEq <= 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 398);
}
// ROR Label 399
if((iEq < 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 399);
}
// ROR Label 400
if((iEq >= 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 400);
}
// ROR Label 401
if(((pLoop->wsFlags & 1048576) != 0) != ((pLoop->wsFlags & 1048576) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 401);
}

// MCC Label 402
if(iEq > 0 && (pLoop->wsFlags & 1048576) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 402);
}
// MCC Label 403
if(iEq > 0 && !((pLoop->wsFlags & 1048576) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 403);
}
// MCC Label 404
if(!(iEq > 0) && (pLoop->wsFlags & 1048576) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 404);
}
// MCC Label 405
if(!(iEq > 0) && !((pLoop->wsFlags & 1048576) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 405);
}
if( iEq>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0 ){
      pLoop->wsFlags |= WHERE_IN_EARLYOUT;
    }

    i = pLevel->u.in.nIn;
    pLevel->u.in.nIn += nEq;
    pLevel->u.in.aInLoop =
       sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop,
                              sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);
    pIn = pLevel->u.in.aInLoop;
    
// ABS Label 406
if(pIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
if( pIn ){
      int iMap = 0;               /* Index in aiMap[] */
      pIn += i;
      i = iEq;

// ABS Label 407
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// ROR Label 408
if((i <= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}
// ROR Label 409
if((i > pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 409);
}
// ROR Label 410
if((i >= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
for(;i<pLoop->nLTerm; i++){
        
// ABS Label 415
if(pLoop->aLTerm[i]->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}
// ABS Label 416
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}

// ROR Label 417
if((pLoop->aLTerm[i]->pExpr != pX) != (pLoop->aLTerm[i]->pExpr == pX))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 417);
}
if( pLoop->aLTerm[i]->pExpr==pX ){
          
// ABS Label 418
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
// ABS Label 419
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}
// ABS Label 420
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 420);
}

// AOR Label 421
if(iReg + i / iEq != iReg + i - iEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 421);
}
// AOR Label 422
if(iReg + i + iEq != iReg + i - iEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 422);
}
// AOR Label 423
if(iReg + i * iEq != iReg + i - iEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 423);
}
// AOR Label 424
if(iReg - i != iReg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 424);
}
// AOR Label 425
if(iReg / i != iReg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 425);
}
// AOR Label 426
if(iReg * i != iReg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 426);
}
int iOut = iReg + i - iEq;
          
// ABS Label 429
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}

// ROR Label 430
if((eType != 1) != (eType == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}
if( eType==IN_INDEX_ROWID ){
            pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iOut);
          }else{
            int iCol = aiMap ? aiMap[iMap++] : 0;
            pIn->addrInTop = sqlite3VdbeAddOp3(v,OP_Column,iTab, iCol, iOut);
          }
          
// ABS Label 427
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}

// ABS Label 428
if(iOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}
sqlite3VdbeAddOp1(v, OP_IsNull, iOut); VdbeCoverage(v);
          
// ABS Label 431
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
// ABS Label 432
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}

// ROR Label 433
if((i != iEq) != (i == iEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 433);
}
if( i==iEq ){
            pIn->iCur = iTab;
            pIn->eEndLoopOp = bRev ? OP_Prev : OP_Next;
            
// ABS Label 434
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}

// ROR Label 435
if((iEq <= 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 435);
}
// ROR Label 436
if((iEq < 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((iEq >= 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
if( iEq>0 ){
              pIn->iBase = iReg - i;
              pIn->nPrefix = i;
            }else{
              pIn->nPrefix = 0;
            }
          }else{
            pIn->eEndLoopOp = OP_Noop;
          }
          pIn++;
        }
      };
// ABS Label 411
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}

// ROR Label 412
if((i <= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 412);
}
// ROR Label 413
if((i > pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 413);
}
// ROR Label 414
if((i >= pLoop->nLTerm) != (i < pLoop->nLTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 414);
}

      testcase( iEq>0
                && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0
                && (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 );
      
// ABS Label 438
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}

// COR Label 439
if((iEq > 0 || (pLoop->wsFlags & (1048576 | 1024)) == 0) != (iEq > 0 && (pLoop->wsFlags & (1048576 | 1024)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 439);
}

// ROR Label 440
if((iEq <= 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 440);
}
// ROR Label 441
if((iEq < 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 441);
}
// ROR Label 442
if((iEq >= 0) != (iEq > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 442);
}
// ROR Label 443
if(((pLoop->wsFlags & (1048576 | 1024)) != 0) != ((pLoop->wsFlags & (1048576 | 1024)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 443);
}

// MCC Label 444
if(iEq > 0 && (pLoop->wsFlags & (1048576 | 1024)) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 444);
}
// MCC Label 445
if(iEq > 0 && !((pLoop->wsFlags & (1048576 | 1024)) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 445);
}
// MCC Label 446
if(!(iEq > 0) && (pLoop->wsFlags & (1048576 | 1024)) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 446);
}
// MCC Label 447
if(!(iEq > 0) && !((pLoop->wsFlags & (1048576 | 1024)) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 447);
}
if( iEq>0 
       && (pLoop->wsFlags & (WHERE_IN_SEEKSCAN|WHERE_VIRTUALTABLE))==0
      ){
        
// ABS Label 448
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 448);
}

// ABS Label 449
if(pLevel->iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}

// ABS Label 450
if(iEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}
sqlite3VdbeAddOp3(v, OP_SeekHit, pLevel->iIdxCur, 0, iEq);
      }
    }else{
      pLevel->u.in.nIn = 0;
    }
    
// ABS Label 333
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
sqlite3DbFree(pParse->db, aiMap);
#endif
  };}


  /* As an optimization, try to disable the WHERE clause term that is
  ** driving the index as it will always be true.  The correct answer is
  ** obtained regardless, but we might get the answer with fewer CPU cycles
  ** by omitting the term.
  **
  ** But do not disable the term unless we are certain that the term is
  ** not a transitive constraint.  For an example of where that does not
  ** work, see https://sqlite.org/forum/forumpost/eb8613976a (2021-05-04)
  */
  
// COR Label 451
if(((pLevel->pWLoop->wsFlags & 2097152) == 0 && (pTerm->eOperator & 2048) == 0) != ((pLevel->pWLoop->wsFlags & 2097152) == 0 || (pTerm->eOperator & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 451);
}

// ROR Label 452
if(((pLevel->pWLoop->wsFlags & 2097152) != 0) != ((pLevel->pWLoop->wsFlags & 2097152) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 452);
}
// ROR Label 453
if(((pTerm->eOperator & 2048) != 0) != ((pTerm->eOperator & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 453);
}

// MCC Label 454
if((pLevel->pWLoop->wsFlags & 2097152) == 0 && (pTerm->eOperator & 2048) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 454);
}
// MCC Label 455
if((pLevel->pWLoop->wsFlags & 2097152) == 0 && !((pTerm->eOperator & 2048) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 455);
}
// MCC Label 456
if(!((pLevel->pWLoop->wsFlags & 2097152) == 0) && (pTerm->eOperator & 2048) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 456);
}
// MCC Label 457
if(!((pLevel->pWLoop->wsFlags & 2097152) == 0) && !((pTerm->eOperator & 2048) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 457);
}
if( (pLevel->pWLoop->wsFlags & WHERE_TRANSCONS)==0
   || (pTerm->eOperator & WO_EQUIV)==0
  ){
    
// ABS Label 458
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}

// ABS Label 459
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}
disableTerm(pLevel, pTerm);
  }

  
// ABS Label 460
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 460);
}
return iReg;
}

/*
** Generate code that will evaluate all == and IN constraints for an
** index scan.
**
** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).
** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c>5 AND c<10
** The index has as many as three equality constraints, but in this
** example, the third "c" value is an inequality.  So only two 
** constraints are coded.  This routine will generate code to evaluate
** a==5 and b IN (1,2,3).  The current values for a and b will be stored
** in consecutive registers and the index of the first register is returned.
**
** In the example above nEq==2.  But this subroutine works for any value
** of nEq including 0.  If nEq==0, this routine is nearly a no-op.
** The only thing it does is allocate the pLevel->iMem memory cell and
** compute the affinity string.
**
** The nExtraReg parameter is 0 or 1.  It is 0 if all WHERE clause constraints
** are == or IN and are covered by the nEq.  nExtraReg is 1 if there is
** an inequality constraint (such as the "c>=5 AND c<10" in the example) that
** occurs after the nEq quality constraints.
**
** This routine allocates a range of nEq+nExtraReg memory cells and returns
** the index of the first memory cell in that range. The code that
** calls this routine will use that memory range to store keys for
** start and termination conditions of the loop.
** key value of the loop.  If one or more IN operators appear, then
** this routine allocates an additional nEq memory cells for internal
** use.
**
** Before returning, *pzAff is set to point to a buffer containing a
** copy of the column affinity string of the index allocated using
** sqlite3DbMalloc(). Except, entries in the copy of the string associated
** with equality constraints that use BLOB or NONE affinity are set to
** SQLITE_AFF_BLOB. This is to deal with SQL such as the following:
**
**   CREATE TABLE t1(a TEXT PRIMARY KEY, b);
**   SELECT ... FROM t1 AS t2, t1 WHERE t1.a = t2.b;
**
** In the example above, the index on t1(a) has TEXT affinity. But since
** the right hand side of the equality constraint (t2.b) has BLOB/NONE affinity,
** no conversion should be attempted before using a t2.b value as part of
** a key to search the index. Hence the first byte in the returned affinity
** string in this example would be set to SQLITE_AFF_BLOB.
*/
static int codeAllEqualityTerms(
  Parse *pParse,        /* Parsing context */
  WhereLevel *pLevel,   /* Which nested loop of the FROM we are coding */
  int bRev,             /* Reverse the order of IN operators */
  int nExtraReg,        /* Number of extra registers to allocate */
  char **pzAff          /* OUT: Set to point to affinity string */
){
  u16 nEq;                      /* The number of == or IN constraints to code */
  u16 nSkip;                    /* Number of left-most columns to skip */
  
// ABS Label 461
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 461);
}
Vdbe *v = pParse->pVdbe;      /* The vm under construction */
  Index *pIdx;                  /* The index being used for this loop */
  WhereTerm *pTerm;             /* A single constraint term */
  WhereLoop *pLoop;             /* The WhereLoop object */
  int j;                        /* Loop counter */
  int regBase;                  /* Base register */
  int nReg;                     /* Number of registers to allocate */
  char *zAff;                   /* Affinity string to return */

  /* This module is only called on query plans that use an index. */
  pLoop = pLevel->pWLoop;
  assert( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0 );
  nEq = pLoop->u.btree.nEq;
  nSkip = pLoop->nSkip;
  pIdx = pLoop->u.btree.pIndex;
  assert( pIdx!=0 );

  /* Figure out how many memory cells we will need then allocate them.
  */
  regBase = pParse->nMem + 1;
  nReg = pLoop->u.btree.nEq + nExtraReg;
  pParse->nMem += nReg;

  zAff = sqlite3DbStrDup(pParse->db,sqlite3IndexAffinityStr(pParse->db,pIdx));
  assert( zAff!=0 || pParse->db->mallocFailed );

  
// ABS Label 462
if(nSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 462);
}
if( nSkip ){
    
// ABS Label 463
if(pLevel->iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}
int iIdxCur = pLevel->iIdxCur;
    
// ABS Label 464
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 464);
}

// ABS Label 465
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 465);
}

// ABS Label 466
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}

// AOR Label 467
if(regBase + nSkip / 1 != regBase + nSkip - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 467);
}
// AOR Label 468
if(regBase + nSkip + 1 != regBase + nSkip - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 468);
}
// AOR Label 469
if(regBase + nSkip * 1 != regBase + nSkip - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 469);
}
// AOR Label 470
if(regBase - nSkip != regBase + nSkip)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 470);
}
// AOR Label 471
if(regBase / nSkip != regBase + nSkip)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 471);
}
// AOR Label 472
if(regBase * nSkip != regBase + nSkip)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 472);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, regBase, regBase+nSkip-1);
    
// ABS Label 473
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}

// ABS Label 474
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}
sqlite3VdbeAddOp1(v, (bRev?OP_Last:OP_Rewind), iIdxCur);
    VdbeCoverageIf(v, bRev==0);
    VdbeCoverageIf(v, bRev!=0);
    VdbeComment((v, "begin skip-scan on %s", pIdx->zName));
    j = sqlite3VdbeAddOp0(v, OP_Goto);
    pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, (bRev?OP_SeekLT:OP_SeekGT),
                            iIdxCur, 0, regBase, nSkip);
    VdbeCoverageIf(v, bRev==0);
    VdbeCoverageIf(v, bRev!=0);
    
// ABS Label 475
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}

// ABS Label 476
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}
sqlite3VdbeJumpHere(v, j);
    j = 0;

// ABS Label 477
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}

// ROR Label 478
if((j <= nSkip) != (j < nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 478);
}
// ROR Label 479
if((j > nSkip) != (j < nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 479);
}
// ROR Label 480
if((j >= nSkip) != (j < nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
for(; j<nSkip; j++){
      
// ABS Label 485
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}

// ABS Label 486
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}

// ABS Label 487
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}

// ABS Label 488
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
// ABS Label 489
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}

// AOR Label 490
if(regBase - j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 490);
}
// AOR Label 491
if(regBase / j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 491);
}
// AOR Label 492
if(regBase * j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 492);
}
sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, j, regBase+j);
      testcase( pIdx->aiColumn[j]==XN_EXPR );
      VdbeComment((v, "%s", explainIndexColumnName(pIdx, j)));
    };
// ABS Label 481
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}

// ROR Label 482
if((j <= nSkip) != (j < nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 482);
}
// ROR Label 483
if((j > nSkip) != (j < nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 483);
}
// ROR Label 484
if((j >= nSkip) != (j < nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 484);
}

  }    

  /* Evaluate the equality constraints
  */
  assert( zAff==0 || (int)strlen(zAff)>=nEq );
  j = nSkip;

// ABS Label 493
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}

// ROR Label 494
if((j <= nEq) != (j < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
// ROR Label 495
if((j > nEq) != (j < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}
// ROR Label 496
if((j >= nEq) != (j < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 496);
}
for(; j<nEq; j++){
    int r1;
    pTerm = pLoop->aLTerm[j];
    assert( pTerm!=0 );
    /* The following testcase is true for indices with redundant columns. 
    ** Ex: CREATE INDEX i1 ON t1(a,b,a); SELECT * FROM t1 WHERE a=0 AND b=0; */
    testcase( (pTerm->wtFlags & TERM_CODED)!=0 );
    testcase( pTerm->wtFlags & TERM_VIRTUAL );
    r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase+j);
    
// ABS Label 501
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}
// ABS Label 502
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 502);
}
// ABS Label 503
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 503);
}

// AOR Label 504
if(regBase - j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 504);
}
// AOR Label 505
if(regBase / j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 505);
}
// AOR Label 506
if(regBase * j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 506);
}

// ROR Label 507
if((r1 == regBase + j) != (r1 != regBase + j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 507);
}
if( r1!=regBase+j ){
      
// ABS Label 508
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}

// ROR Label 509
if((nReg != 1) != (nReg == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 509);
}
if( nReg==1 ){
        
// ABS Label 510
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}

// ABS Label 511
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}
sqlite3ReleaseTempReg(pParse, regBase);
        regBase = r1;
      }else{
        
// ABS Label 512
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}

// ABS Label 513
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}

// ABS Label 514
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}
// ABS Label 515
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}

// AOR Label 516
if(regBase - j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 516);
}
// AOR Label 517
if(regBase / j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 517);
}
// AOR Label 518
if(regBase * j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 518);
}
sqlite3VdbeAddOp2(v, OP_Copy, r1, regBase+j);
      }
    }
    
// AOR Label 519
if(pTerm->eOperator | 1 != pTerm->eOperator & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 519);
}
// AOR Label 520
if(pTerm->eOperator ^ 1 != pTerm->eOperator & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 520);
}
if( pTerm->eOperator & WO_IN ){
      
// ABS Label 521
if(pTerm->pExpr->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}

// AOR Label 522
if(pTerm->pExpr->flags | 2048 != pTerm->pExpr->flags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 522);
}
// AOR Label 523
if(pTerm->pExpr->flags ^ 2048 != pTerm->pExpr->flags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 523);
}
if( pTerm->pExpr->flags & EP_xIsSelect ){
        /* No affinity ever needs to be (or should be) applied to a value
        ** from the RHS of an "? IN (SELECT ...)" expression. The 
        ** sqlite3FindInIndex() routine has already ensured that the 
        ** affinity of the comparison has been applied to the value.  */
        
// ABS Label 524
if(zAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}
if( zAff ) { zAff[j] = SQLITE_AFF_BLOB;
}
      }
    }else { 
// ROR Label 525
if(((pTerm->eOperator & 256) != 0) != ((pTerm->eOperator & 256) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 525);
}
if( (pTerm->eOperator & WO_ISNULL)==0 ){
      
// ABS Label 526
if(pTerm->pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}
Expr *pRight = pTerm->pExpr->pRight;
      if( (pTerm->wtFlags & TERM_IS)==0 && sqlite3ExprCanBeNull(pRight) ){
        
// ABS Label 527
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}

// ABS Label 528
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}
// ABS Label 529
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}

// AOR Label 530
if(regBase - j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 530);
}
// AOR Label 531
if(regBase / j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 531);
}
// AOR Label 532
if(regBase * j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 532);
}

// ABS Label 533
if(pLevel->addrBrk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regBase+j, pLevel->addrBrk);
        VdbeCoverage(v);
      }
      
// ABS Label 534
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}

// COR Label 535
if((pParse->db->mallocFailed == 0 || pParse->nErr == 0) != (pParse->db->mallocFailed == 0 && pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 535);
}

// ROR Label 536
if((pParse->db->mallocFailed != 0) != (pParse->db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 536);
}
// ROR Label 537
if((pParse->nErr != 0) != (pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 537);
}

// MCC Label 538
if(pParse->db->mallocFailed == 0 && pParse->nErr == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 538);
}
// MCC Label 539
if(pParse->db->mallocFailed == 0 && !(pParse->nErr == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 539);
}
// MCC Label 540
if(!(pParse->db->mallocFailed == 0) && pParse->nErr == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 540);
}
// MCC Label 541
if(!(pParse->db->mallocFailed == 0) && !(pParse->nErr == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
if( pParse->db->mallocFailed==0 && pParse->nErr==0 ){
        if( sqlite3CompareAffinity(pRight, zAff[j])==SQLITE_AFF_BLOB ){
          zAff[j] = SQLITE_AFF_BLOB;
        }
        if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){
          zAff[j] = SQLITE_AFF_BLOB;
        }
      }
    };}

  };
// ABS Label 497
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// ROR Label 498
if((j <= nEq) != (j < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}
// ROR Label 499
if((j > nEq) != (j < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 499);
}
// ROR Label 500
if((j >= nEq) != (j < nEq))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 500);
}

  *pzAff = zAff;
  
// ABS Label 542
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
return regBase;
}

#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
/*
** If the most recently coded instruction is a constant range constraint
** (a string literal) that originated from the LIKE optimization, then 
** set P3 and P5 on the OP_String opcode so that the string will be cast
** to a BLOB at appropriate times.
**
** The LIKE optimization trys to evaluate "x LIKE 'abc%'" as a range
** expression: "x>='ABC' AND x<'abd'".  But this requires that the range
** scan loop run twice, once for strings and a second time for BLOBs.
** The OP_String opcodes on the second pass convert the upper and lower
** bound string constants to blobs.  This routine makes the necessary changes
** to the OP_String opcodes for that to happen.
**
** Except, of course, if SQLITE_LIKE_DOESNT_MATCH_BLOBS is defined, then
** only the one pass through the string space is required, so this routine
** becomes a no-op.
*/
static void whereLikeOptimizationStringFixup(
  Vdbe *v,                /* prepared statement under construction */
  WhereLevel *pLevel,     /* The loop that contains the LIKE operator */
  WhereTerm *pTerm        /* The upper or lower bound just coded */
){
  
// AOR Label 543
if(pTerm->wtFlags | 256 != pTerm->wtFlags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 543);
}
// AOR Label 544
if(pTerm->wtFlags ^ 256 != pTerm->wtFlags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 544);
}
if( pTerm->wtFlags & TERM_LIKEOPT ){
    VdbeOp *pOp;
    assert( pLevel->iLikeRepCntr>0 );
    pOp = sqlite3VdbeGetOp(v, -1);
    assert( pOp!=0 );
    assert( pOp->opcode==OP_String8 
            || pTerm->pWC->pWInfo->pParse->db->mallocFailed );
    pOp->p3 = (int)(pLevel->iLikeRepCntr>>1);  /* Register holding counter */
    pOp->p5 = (u8)(pLevel->iLikeRepCntr&1);    /* ASC or DESC */
  }
}
#else
# define whereLikeOptimizationStringFixup(A,B,C)
#endif

#ifdef SQLITE_ENABLE_CURSOR_HINTS
/*
** Information is passed from codeCursorHint() down to individual nodes of
** the expression tree (by sqlite3WalkExpr()) using an instance of this
** structure.
*/
struct CCurHint {
  int iTabCur;    /* Cursor for the main table */
  int iIdxCur;    /* Cursor for the index, if pIdx!=0.  Unused otherwise */
  Index *pIdx;    /* The index used to access the table */
};

/*
** This function is called for every node of an expression that is a candidate
** for a cursor hint on an index cursor.  For TK_COLUMN nodes that reference
** the table CCurHint.iTabCur, verify that the same column can be
** accessed through the index.  If it cannot, then set pWalker->eCode to 1.
*/
static int codeCursorHintCheckExpr(Walker *pWalker, Expr *pExpr){
  struct CCurHint *pHint = pWalker->u.pCCurHint;
  assert( pHint->pIdx!=0 );
  if( pExpr->op==TK_COLUMN
   && pExpr->iTable==pHint->iTabCur
   && sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn)<0
  ){
    pWalker->eCode = 1;
  }
  return WRC_Continue;
}

/*
** Test whether or not expression pExpr, which was part of a WHERE clause,
** should be included in the cursor-hint for a table that is on the rhs
** of a LEFT JOIN. Set Walker.eCode to non-zero before returning if the 
** expression is not suitable.
**
** An expression is unsuitable if it might evaluate to non NULL even if
** a TK_COLUMN node that does affect the value of the expression is set
** to NULL. For example:
**
**   col IS NULL
**   col IS NOT NULL
**   coalesce(col, 1)
**   CASE WHEN col THEN 0 ELSE 1 END
*/
static int codeCursorHintIsOrFunction(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==TK_IS 
   || pExpr->op==TK_ISNULL || pExpr->op==TK_ISNOT 
   || pExpr->op==TK_NOTNULL || pExpr->op==TK_CASE 
  ){
    pWalker->eCode = 1;
  }else if( pExpr->op==TK_FUNCTION ){
    int d1;
    char d2[4];
    if( 0==sqlite3IsLikeFunction(pWalker->pParse->db, pExpr, &d1, d2) ){
      pWalker->eCode = 1;
    }
  }

  return WRC_Continue;
}


/*
** This function is called on every node of an expression tree used as an
** argument to the OP_CursorHint instruction. If the node is a TK_COLUMN
** that accesses any table other than the one identified by
** CCurHint.iTabCur, then do the following:
**
**   1) allocate a register and code an OP_Column instruction to read 
**      the specified column into the new register, and
**
**   2) transform the expression node to a TK_REGISTER node that reads 
**      from the newly populated register.
**
** Also, if the node is a TK_COLUMN that does access the table idenified
** by pCCurHint.iTabCur, and an index is being used (which we will
** know because CCurHint.pIdx!=0) then transform the TK_COLUMN into
** an access of the index rather than the original table.
*/
static int codeCursorHintFixExpr(Walker *pWalker, Expr *pExpr){
  int rc = WRC_Continue;
  struct CCurHint *pHint = pWalker->u.pCCurHint;
  if( pExpr->op==TK_COLUMN ){
    if( pExpr->iTable!=pHint->iTabCur ){
      int reg = ++pWalker->pParse->nMem;   /* Register for column value */
      sqlite3ExprCode(pWalker->pParse, pExpr, reg);
      pExpr->op = TK_REGISTER;
      pExpr->iTable = reg;
    }else if( pHint->pIdx!=0 ){
      pExpr->iTable = pHint->iIdxCur;
      pExpr->iColumn = sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn);
      assert( pExpr->iColumn>=0 );
    }
  }else if( pExpr->op==TK_AGG_FUNCTION ){
    /* An aggregate function in the WHERE clause of a query means this must
    ** be a correlated sub-query, and expression pExpr is an aggregate from
    ** the parent context. Do not walk the function arguments in this case.
    **
    ** todo: It should be possible to replace this node with a TK_REGISTER
    ** expression, as the result of the expression must be stored in a 
    ** register at this point. The same holds for TK_AGG_COLUMN nodes. */
    rc = WRC_Prune;
  }
  return rc;
}

/*
** Insert an OP_CursorHint instruction if it is appropriate to do so.
*/
static void codeCursorHint(
  SrcItem *pTabItem,  /* FROM clause item */
  WhereInfo *pWInfo,    /* The where clause */
  WhereLevel *pLevel,   /* Which loop to provide hints for */
  WhereTerm *pEndRange  /* Hint this end-of-scan boundary term if not NULL */
){
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  Vdbe *v = pParse->pVdbe;
  Expr *pExpr = 0;
  WhereLoop *pLoop = pLevel->pWLoop;
  int iCur;
  WhereClause *pWC;
  WhereTerm *pTerm;
  int i, j;
  struct CCurHint sHint;
  Walker sWalker;

  if( OptimizationDisabled(db, SQLITE_CursorHints) ) return;
  iCur = pLevel->iTabCur;
  assert( iCur==pWInfo->pTabList->a[pLevel->iFrom].iCursor );
  sHint.iTabCur = iCur;
  sHint.iIdxCur = pLevel->iIdxCur;
  sHint.pIdx = pLoop->u.btree.pIndex;
  memset(&sWalker, 0, sizeof(sWalker));
  sWalker.pParse = pParse;
  sWalker.u.pCCurHint = &sHint;
  pWC = &pWInfo->sWC;
  for(i=0; i<pWC->nTerm; i++){
    pTerm = &pWC->a[i];
    if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;
    if( pTerm->prereqAll & pLevel->notReady ) continue;

    /* Any terms specified as part of the ON(...) clause for any LEFT 
    ** JOIN for which the current table is not the rhs are omitted
    ** from the cursor-hint. 
    **
    ** If this table is the rhs of a LEFT JOIN, "IS" or "IS NULL" terms 
    ** that were specified as part of the WHERE clause must be excluded.
    ** This is to address the following:
    **
    **   SELECT ... t1 LEFT JOIN t2 ON (t1.a=t2.b) WHERE t2.c IS NULL;
    **
    ** Say there is a single row in t2 that matches (t1.a=t2.b), but its
    ** t2.c values is not NULL. If the (t2.c IS NULL) constraint is 
    ** pushed down to the cursor, this row is filtered out, causing
    ** SQLite to synthesize a row of NULL values. Which does match the
    ** WHERE clause, and so the query returns a row. Which is incorrect.
    **
    ** For the same reason, WHERE terms such as:
    **
    **   WHERE 1 = (t2.c IS NULL)
    **
    ** are also excluded. See codeCursorHintIsOrFunction() for details.
    */
    if( pTabItem->fg.jointype & JT_LEFT ){
      Expr *pExpr = pTerm->pExpr;
      if( !ExprHasProperty(pExpr, EP_FromJoin) 
       || pExpr->iRightJoinTable!=pTabItem->iCursor
      ){
        sWalker.eCode = 0;
        sWalker.xExprCallback = codeCursorHintIsOrFunction;
        sqlite3WalkExpr(&sWalker, pTerm->pExpr);
        if( sWalker.eCode ) continue;
      }
    }else{
      if( ExprHasProperty(pTerm->pExpr, EP_FromJoin) ) continue;
    }

    /* All terms in pWLoop->aLTerm[] except pEndRange are used to initialize
    ** the cursor.  These terms are not needed as hints for a pure range
    ** scan (that has no == terms) so omit them. */
    if( pLoop->u.btree.nEq==0 && pTerm!=pEndRange ){
      for(j=0; j<pLoop->nLTerm && pLoop->aLTerm[j]!=pTerm; j++){}
      if( j<pLoop->nLTerm ) continue;
    }

    /* No subqueries or non-deterministic functions allowed */
    if( sqlite3ExprContainsSubquery(pTerm->pExpr) ) continue;

    /* For an index scan, make sure referenced columns are actually in
    ** the index. */
    if( sHint.pIdx!=0 ){
      sWalker.eCode = 0;
      sWalker.xExprCallback = codeCursorHintCheckExpr;
      sqlite3WalkExpr(&sWalker, pTerm->pExpr);
      if( sWalker.eCode ) continue;
    }

    /* If we survive all prior tests, that means this term is worth hinting */
    pExpr = sqlite3ExprAnd(pParse, pExpr, sqlite3ExprDup(db, pTerm->pExpr, 0));
  }
  if( pExpr!=0 ){
    sWalker.xExprCallback = codeCursorHintFixExpr;
    sqlite3WalkExpr(&sWalker, pExpr);
    sqlite3VdbeAddOp4(v, OP_CursorHint, 
                      (sHint.pIdx ? sHint.iIdxCur : sHint.iTabCur), 0, 0,
                      (const char*)pExpr, P4_EXPR);
  }
}
#else
# define codeCursorHint(A,B,C,D)  /* No-op */
#endif /* SQLITE_ENABLE_CURSOR_HINTS */

/*
** Cursor iCur is open on an intkey b-tree (a table). Register iRowid contains
** a rowid value just read from cursor iIdxCur, open on index pIdx. This
** function generates code to do a deferred seek of cursor iCur to the 
** rowid stored in register iRowid.
**
** Normally, this is just:
**
**   OP_DeferredSeek $iCur $iRowid
**
** However, if the scan currently being coded is a branch of an OR-loop and
** the statement currently being coded is a SELECT, then P3 of OP_DeferredSeek
** is set to iIdxCur and P4 is set to point to an array of integers
** containing one entry for each column of the table cursor iCur is open 
** on. For each table column, if the column is the i'th column of the 
** index, then the corresponding array entry is set to (i+1). If the column
** does not appear in the index at all, the array entry is set to 0.
*/
static void codeDeferredSeek(
  WhereInfo *pWInfo,              /* Where clause context */
  Index *pIdx,                    /* Index scan is using */
  int iCur,                       /* Cursor for IPK b-tree */
  int iIdxCur                     /* Index cursor */
){
  
// ABS Label 545
if(pWInfo->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}
Parse *pParse = pWInfo->pParse; /* Parse context */
  
// ABS Label 546
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}
Vdbe *v = pParse->pVdbe;        /* Vdbe to generate code within */

  assert( iIdxCur>0 );
  assert( pIdx->aiColumn[pIdx->nColumn-1]==-1 );
  
  pWInfo->bDeferredSeek = 1;
  
// ABS Label 547
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}

// ABS Label 548
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}

// ABS Label 549
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}
sqlite3VdbeAddOp3(v, OP_DeferredSeek, iIdxCur, 0, iCur);
  
// ABS Label 550
if((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}

// COR Label 551
if(((pWInfo->wctrlFlags & 32) || (((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0) != ((pWInfo->wctrlFlags & 32) && (((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 551);
}

// ROR Label 552
if(((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) != 0) != ((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 552);
}

// MCC Label 553
if(( pWInfo->wctrlFlags & 32 ) && (((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 553);
}
// MCC Label 554
if(( pWInfo->wctrlFlags & 32 ) && !((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 554);
}
// MCC Label 555
if(( !(pWInfo->wctrlFlags & 32) ) && (((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 555);
}
// MCC Label 556
if(( !(pWInfo->wctrlFlags & 32) ) && !((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 556);
}
if( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)
   && DbMaskAllZero(sqlite3ParseToplevel(pParse)->writeMask)
  ){
    int i;
    
// ABS Label 557
if(pIdx->pTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}
Table *pTab = pIdx->pTable;
    u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));
    
// ABS Label 558
if(ai < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}
if( ai ){
      ai[0] = pTab->nCol;
      i = 0;

// ABS Label 560
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 560);
}

// AOR Label 561
if(pIdx->nColumn / 1 != pIdx->nColumn - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 561);
}
// AOR Label 562
if(pIdx->nColumn + 1 != pIdx->nColumn - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 562);
}
// AOR Label 563
if(pIdx->nColumn * 1 != pIdx->nColumn - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 563);
}

// ROR Label 564
if((i <= pIdx->nColumn - 1) != (i < pIdx->nColumn - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}
// ROR Label 565
if((i > pIdx->nColumn - 1) != (i < pIdx->nColumn - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 565);
}
// ROR Label 566
if((i >= pIdx->nColumn - 1) != (i < pIdx->nColumn - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 566);
}
for(; i<pIdx->nColumn-1; i++){
        int x1, x2;
        assert( pIdx->aiColumn[i]<pTab->nCol );
        x1 = pIdx->aiColumn[i];
        x2 = sqlite3TableColumnToStorage(pTab, x1);
        testcase( x1!=x2 );
        
// ABS Label 574
if(x1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}

// ROR Label 575
if((x1 < 0) != (x1 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 575);
}
// ROR Label 576
if((x1 > 0) != (x1 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 576);
}
// ROR Label 577
if((x1 <= 0) != (x1 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 577);
}
if( x1>=0 ) { ai[x2+1] = i+1;
}
      };
// ABS Label 567
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}

// AOR Label 568
if(pIdx->nColumn / 1 != pIdx->nColumn - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 568);
}
// AOR Label 569
if(pIdx->nColumn + 1 != pIdx->nColumn - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 569);
}
// AOR Label 570
if(pIdx->nColumn * 1 != pIdx->nColumn - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 570);
}

// ROR Label 571
if((i <= pIdx->nColumn - 1) != (i < pIdx->nColumn - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}
// ROR Label 572
if((i > pIdx->nColumn - 1) != (i < pIdx->nColumn - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
// ROR Label 573
if((i >= pIdx->nColumn - 1) != (i < pIdx->nColumn - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 573);
}

      
// ABS Label 559
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 559);
}
sqlite3VdbeChangeP4(v, -1, (char*)ai, P4_INTARRAY);
    }
  }
}

/*
** If the expression passed as the second argument is a vector, generate
** code to write the first nReg elements of the vector into an array
** of registers starting with iReg.
**
** If the expression is not a vector, then nReg must be passed 1. In
** this case, generate code to evaluate the expression and leave the
** result in register iReg.
*/
static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg){
  assert( nReg>0 );
  if( p && sqlite3ExprIsVector(p) ){
#ifndef SQLITE_OMIT_SUBQUERY
    
// MCC Label 578
if(( p->flags & 2048 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
// MCC Label 579
if(( !(p->flags & 2048) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 579);
}
if( (p->flags & EP_xIsSelect) ){
      
// ABS Label 580
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 580);
}
Vdbe *v = pParse->pVdbe;
      int iSelect;
      assert( p->op==TK_SELECT );
      iSelect = sqlite3CodeSubselect(pParse, p);
      
// ABS Label 581
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 581);
}

// ABS Label 582
if(iSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 582);
}

// ABS Label 583
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 583);
}

// ABS Label 584
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 584);
}

// AOR Label 585
if(nReg / 1 != nReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 585);
}
// AOR Label 586
if(nReg + 1 != nReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 586);
}
// AOR Label 587
if(nReg * 1 != nReg - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 587);
}
sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);
    }else
#endif
    {
      int i;
      
// ABS Label 588
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 588);
}
ExprList *pList = p->x.pList;
      assert( nReg<=pList->nExpr );
      i = 0;

// ABS Label 589
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}
// ABS Label 590
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 590);
}

// ROR Label 591
if((i <= nReg) != (i < nReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 591);
}
// ROR Label 592
if((i > nReg) != (i < nReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}
// ROR Label 593
if((i >= nReg) != (i < nReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
for(; i<nReg; i++){
        
// ABS Label 599
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}

// ABS Label 600
if(pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 600);
}

// ABS Label 601
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 601);
}
// ABS Label 602
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}

// AOR Label 603
if(iReg - i != iReg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 603);
}
// AOR Label 604
if(iReg / i != iReg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 604);
}
// AOR Label 605
if(iReg * i != iReg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 605);
}
sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg+i);
      };
// ABS Label 594
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 594);
}
// ABS Label 595
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 595);
}

// ROR Label 596
if((i <= nReg) != (i < nReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 596);
}
// ROR Label 597
if((i > nReg) != (i < nReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 597);
}
// ROR Label 598
if((i >= nReg) != (i < nReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 598);
}

    }
  }else{
    assert( nReg==1 || pParse->nErr );
    
// ABS Label 606
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}

// ABS Label 607
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}

// ABS Label 608
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}
sqlite3ExprCode(pParse, p, iReg);
  }
}

/* An instance of the IdxExprTrans object carries information about a
** mapping from an expression on table columns into a column in an index
** down through the Walker.
*/
typedef struct IdxExprTrans {
  Expr *pIdxExpr;    /* The index expression */
  int iTabCur;       /* The cursor of the corresponding table */
  int iIdxCur;       /* The cursor for the index */
  int iIdxCol;       /* The column for the index */
  int iTabCol;       /* The column for the table */
  WhereInfo *pWInfo; /* Complete WHERE clause information */
  sqlite3 *db;       /* Database connection (for malloc()) */
} IdxExprTrans;

/*
** Preserve pExpr on the WhereETrans list of the WhereInfo.
*/
static void preserveExpr(IdxExprTrans *pTrans, Expr *pExpr){
  WhereExprMod *pNew;
  pNew = sqlite3DbMallocRaw(pTrans->db, sizeof(*pNew));
  
// ABS Label 609
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}

// ROR Label 610
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}
if( pNew==0 ) { return;
}
  pNew->pNext = pTrans->pWInfo->pExprMods;
  pTrans->pWInfo->pExprMods = pNew;
  pNew->pExpr = pExpr;
  memcpy(&pNew->orig, pExpr, sizeof(*pExpr));
}

/* The walker node callback used to transform matching expressions into
** a reference to an index column for an index on an expression.
**
** If pExpr matches, then transform it into a reference to the index column
** that contains the value of pExpr.
*/
static int whereIndexExprTransNode(Walker *p, Expr *pExpr){
  
// ABS Label 611
if(p->u.pIdxTrans < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}
IdxExprTrans *pX = p->u.pIdxTrans;
  if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){
    
// ABS Label 612
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}

// ABS Label 613
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}
preserveExpr(pX, pExpr);
    pExpr->affExpr = sqlite3ExprAffinity(pExpr);
    pExpr->op = TK_COLUMN;
    pExpr->iTable = pX->iIdxCur;
    pExpr->iColumn = pX->iIdxCol;
    pExpr->y.pTab = 0;
    testcase( ExprHasProperty(pExpr, EP_Skip) );
    testcase( ExprHasProperty(pExpr, EP_Unlikely) );
    ExprClearProperty(pExpr, EP_Skip|EP_Unlikely);
    return WRC_Prune;
  }else{
    return WRC_Continue;
  }
}

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
/* A walker node callback that translates a column reference to a table
** into a corresponding column reference of an index.
*/
static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){
  
// ROR Label 614
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 614);
}
if( pExpr->op==TK_COLUMN ){
    
// ABS Label 615
if(p->u.pIdxTrans < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 615);
}
IdxExprTrans *pX = p->u.pIdxTrans;
    
// ABS Label 616
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 616);
}
// ABS Label 617
if(pX->iTabCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}
// ABS Label 618
if(pX->iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}

// COR Label 619
if((pExpr->iTable == pX->iTabCur || pExpr->iColumn == pX->iTabCol) != (pExpr->iTable == pX->iTabCur && pExpr->iColumn == pX->iTabCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 619);
}

// ROR Label 620
if((pExpr->iTable != pX->iTabCur) != (pExpr->iTable == pX->iTabCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
// ROR Label 621
if((pExpr->iColumn != pX->iTabCol) != (pExpr->iColumn == pX->iTabCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}

// MCC Label 622
if(pExpr->iTable == pX->iTabCur && pExpr->iColumn == pX->iTabCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 622);
}
// MCC Label 623
if(pExpr->iTable == pX->iTabCur && !(pExpr->iColumn == pX->iTabCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 623);
}
// MCC Label 624
if(!(pExpr->iTable == pX->iTabCur) && pExpr->iColumn == pX->iTabCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(!(pExpr->iTable == pX->iTabCur) && !(pExpr->iColumn == pX->iTabCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){
      assert( pExpr->y.pTab!=0 );
      
// ABS Label 626
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 626);
}

// ABS Label 627
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 627);
}
preserveExpr(pX, pExpr);
      pExpr->affExpr = sqlite3TableColumnAffinity(pExpr->y.pTab,pExpr->iColumn);
      pExpr->iTable = pX->iIdxCur;
      pExpr->iColumn = pX->iIdxCol;
      pExpr->y.pTab = 0;
    }
  }
  return WRC_Continue;
}
#endif /* SQLITE_OMIT_GENERATED_COLUMNS */

/*
** For an indexes on expression X, locate every instance of expression X
** in pExpr and change that subexpression into a reference to the appropriate
** column of the index.
**
** 2019-10-24: Updated to also translate references to a VIRTUAL column in
** the table into references to the corresponding (stored) column of the
** index.
*/
static void whereIndexExprTrans(
  Index *pIdx,      /* The Index */
  int iTabCur,      /* Cursor of the table that is being indexed */
  int iIdxCur,      /* Cursor of the index itself */
  WhereInfo *pWInfo /* Transform expressions in this WHERE clause */
){
  int iIdxCol;               /* Column number of the index */
  ExprList *aColExpr;        /* Expressions that are indexed */
  Table *pTab;
  Walker w;
  IdxExprTrans x;
  aColExpr = pIdx->aColExpr;
  
// ABS Label 628
if(aColExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}

// COR Label 629
if((aColExpr == 0 || !pIdx->bHasVCol) != (aColExpr == 0 && !pIdx->bHasVCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 629);
}

// ROR Label 630
if((aColExpr != 0) != (aColExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 630);
}

// MCC Label 631
if(aColExpr == 0 && !pIdx->bHasVCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 631);
}
// MCC Label 632
if(aColExpr == 0 && !(!pIdx->bHasVCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 632);
}
// MCC Label 633
if(!(aColExpr == 0) && !pIdx->bHasVCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 633);
}
// MCC Label 634
if(!(aColExpr == 0) && !(!pIdx->bHasVCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 634);
}
if( aColExpr==0 && !pIdx->bHasVCol ){
    /* The index does not reference any expressions or virtual columns
    ** so no translations are needed. */
    return;
  }
  pTab = pIdx->pTable;
  memset(&w, 0, sizeof(w));
  w.u.pIdxTrans = &x;
  x.iTabCur = iTabCur;
  x.iIdxCur = iIdxCur;
  x.pWInfo = pWInfo;
  x.db = pWInfo->pParse->db;
  iIdxCol = 0;

// ABS Label 635
if(iIdxCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}

// ROR Label 636
if((iIdxCol <= pIdx->nColumn) != (iIdxCol < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
// ROR Label 637
if((iIdxCol > pIdx->nColumn) != (iIdxCol < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}
// ROR Label 638
if((iIdxCol >= pIdx->nColumn) != (iIdxCol < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 638);
}
for(; iIdxCol<pIdx->nColumn; iIdxCol++){
    
// ABS Label 643
if(iIdxCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}
// ABS Label 644
if(pIdx->aiColumn[iIdxCol] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}
i16 iRef = pIdx->aiColumn[iIdxCol];
    
// ROR Label 648
if((iRef != (-2)) != (iRef == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 648);
}
if( iRef==XN_EXPR ){
      assert( aColExpr->a[iIdxCol].pExpr!=0 );
      x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;
      if( sqlite3ExprIsConstant(x.pIdxExpr) ) { continue;
}
      w.xExprCallback = whereIndexExprTransNode;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
    }else { if( iRef>=0
       && (pTab->aCol[iRef].colFlags & COLFLAG_VIRTUAL)!=0
       && (pTab->aCol[iRef].zColl==0
           || sqlite3StrICmp(pTab->aCol[iRef].zColl, sqlite3StrBINARY)==0)
    ){
      /* Check to see if there are direct references to generated columns
      ** that are contained in the index.  Pulling the generated column
      ** out of the index is an optimization only - the main table is always
      ** available if the index cannot be used.  To avoid unnecessary
      ** complication, omit this optimization if the collating sequence for
      ** the column is non-standard */
      x.iTabCol = iRef;
      w.xExprCallback = whereIndexExprTransColumn;
#endif /* SQLITE_OMIT_GENERATED_COLUMNS */
    }else{
      continue;
    };}

    x.iIdxCol = iIdxCol;
    
// ABS Label 645
if(pWInfo->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}
sqlite3WalkExpr(&w, pWInfo->pWhere);
    
// ABS Label 646
if(pWInfo->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}
sqlite3WalkExprList(&w, pWInfo->pOrderBy);
    
// ABS Label 647
if(pWInfo->pResultSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}
sqlite3WalkExprList(&w, pWInfo->pResultSet);
  };
// ABS Label 639
if(iIdxCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// ROR Label 640
if((iIdxCol <= pIdx->nColumn) != (iIdxCol < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 640);
}
// ROR Label 641
if((iIdxCol > pIdx->nColumn) != (iIdxCol < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 641);
}
// ROR Label 642
if((iIdxCol >= pIdx->nColumn) != (iIdxCol < pIdx->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}

}

/*
** The pTruth expression is always true because it is the WHERE clause
** a partial index that is driving a query loop.  Look through all of the
** WHERE clause terms on the query, and if any of those terms must be
** true because pTruth is true, then mark those WHERE clause terms as
** coded.
*/
static void whereApplyPartialIndexConstraints(
  Expr *pTruth,
  int iTabCur,
  WhereClause *pWC
){
  int i;
  WhereTerm *pTerm;
  
// ROR Label 649
if((pTruth->op != 44) != (pTruth->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 649);
}
while( pTruth->op==TK_AND ){
    
// ABS Label 651
if(pTruth->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}

// ABS Label 652
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}

// ABS Label 653
if(pWC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}
whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);
    pTruth = pTruth->pRight;
  };
// ROR Label 650
if((pTruth->op != 44) != (pTruth->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 650);
}

  i = 0 , pTerm = pWC->a;

// ABS Label 654
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}
// ABS Label 655
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 655);
}

// ROR Label 656
if((i <= pWC->nTerm) != (i < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 656);
}
// ROR Label 657
if((i > pWC->nTerm) != (i < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 657);
}
// ROR Label 658
if((i >= pWC->nTerm) != (i < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 658);
}
for(; i<pWC->nTerm; i++, pTerm++){
    Expr *pExpr;
    
// AOR Label 664
if(pTerm->wtFlags | 4 != pTerm->wtFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 664);
}
// AOR Label 665
if(pTerm->wtFlags ^ 4 != pTerm->wtFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 665);
}
if( pTerm->wtFlags & TERM_CODED ) { continue;
}
    pExpr = pTerm->pExpr;
    if( sqlite3ExprCompare(0, pExpr, pTruth, iTabCur)==0 ){
      pTerm->wtFlags |= TERM_CODED;
    }
  };
// ABS Label 659
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}
// ABS Label 660
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}

// ROR Label 661
if((i <= pWC->nTerm) != (i < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 661);
}
// ROR Label 662
if((i > pWC->nTerm) != (i < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
// ROR Label 663
if((i >= pWC->nTerm) != (i < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 663);
}

}

/*
** Generate code for the start of the iLevel-th loop in the WHERE clause
** implementation described by pWInfo.
*/
Bitmask sqlite3WhereCodeOneLoopStart(
  Parse *pParse,       /* Parsing context */
  Vdbe *v,             /* Prepared statement under construction */
  WhereInfo *pWInfo,   /* Complete information about the WHERE clause */
  int iLevel,          /* Which level of pWInfo->a[] should be coded */
  WhereLevel *pLevel,  /* The current level pointer */
  Bitmask notReady     /* Which tables are currently available */
){
  int j, k;            /* Loop counters */
  int iCur;            /* The VDBE cursor for the table */
  int addrNxt;         /* Where to jump to continue with the next IN case */
  int bRev;            /* True if we need to scan in reverse order */
  WhereLoop *pLoop;    /* The WhereLoop object being coded */
  WhereClause *pWC;    /* Decomposition of the entire WHERE clause */
  WhereTerm *pTerm;               /* A WHERE clause term */
  sqlite3 *db;                    /* Database connection */
  SrcItem *pTabItem;              /* FROM clause term being coded */
  int addrBrk;                    /* Jump here to break out of the loop */
  int addrHalt;                   /* addrBrk for the outermost loop */
  int addrCont;                   /* Jump here to continue with next cycle */
  int iRowidReg = 0;        /* Rowid is stored in this register, if not zero */
  int iReleaseReg = 0;      /* Temp register to free before returning */
  Index *pIdx = 0;          /* Index used by loop (if any) */
  int iLoop;                /* Iteration of constraint generator loop */

  pWC = &pWInfo->sWC;
  db = pParse->db;
  pLoop = pLevel->pWLoop;
  pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
  iCur = pTabItem->iCursor;
  pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);
  bRev = (pWInfo->revMask>>iLevel)&1;
  VdbeModuleComment((v, "Begin WHERE-loop%d: %s",iLevel,pTabItem->pTab->zName));
#if WHERETRACE_ENABLED /* 0x20800 */
  if( sqlite3WhereTrace & 0x800 ){
    sqlite3DebugPrintf("Coding level %d of %d:  notReady=%llx  iFrom=%d\n",
       iLevel, pWInfo->nLevel, (u64)notReady, pLevel->iFrom);
    sqlite3WhereLoopPrint(pLoop, pWC);
  }
  if( sqlite3WhereTrace & 0x20000 ){
    if( iLevel==0 ){
      sqlite3DebugPrintf("WHERE clause being coded:\n");
      sqlite3TreeViewExpr(0, pWInfo->pWhere, 0);
    }
    sqlite3DebugPrintf("All WHERE-clause terms before coding:\n");
    sqlite3WhereClausePrint(pWC);
  }
#endif

  /* Create labels for the "break" and "continue" instructions
  ** for the current loop.  Jump to addrBrk to break out of a loop.
  ** Jump to cont to go immediately to the next iteration of the
  ** loop.
  **
  ** When there is an IN operator, we also have a "addrNxt" label that
  ** means to continue with the next IN value combination.  When
  ** there are no IN operators in the constraints, the "addrNxt" label
  ** is the same as "addrBrk".
  */
  addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);
  addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);

  /* If this is the right table of a LEFT OUTER JOIN, allocate and
  ** initialize a memory cell that records if this table matches any
  ** row of the left table of the join.
  */
  assert( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)
       || pLevel->iFrom>0 || (pTabItem[0].fg.jointype & JT_LEFT)==0
  );
  
// COR Label 666
if((pLevel->iFrom > 0 || (pTabItem[0].fg.jointype & 8) != 0) != (pLevel->iFrom > 0 && (pTabItem[0].fg.jointype & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 666);
}

// ROR Label 667
if((pLevel->iFrom <= 0) != (pLevel->iFrom > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
// ROR Label 668
if((pLevel->iFrom < 0) != (pLevel->iFrom > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 668);
}
// ROR Label 669
if((pLevel->iFrom >= 0) != (pLevel->iFrom > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 669);
}
// ROR Label 670
if(((pTabItem[0].fg.jointype & 8) == 0) != ((pTabItem[0].fg.jointype & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 670);
}

// MCC Label 671
if(pLevel->iFrom > 0 && (pTabItem[0].fg.jointype & 8) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 671);
}
// MCC Label 672
if(pLevel->iFrom > 0 && !((pTabItem[0].fg.jointype & 8) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 672);
}
// MCC Label 673
if(!(pLevel->iFrom > 0) && (pTabItem[0].fg.jointype & 8) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 673);
}
// MCC Label 674
if(!(pLevel->iFrom > 0) && !((pTabItem[0].fg.jointype & 8) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 674);
}
if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){
    pLevel->iLeftJoin = ++pParse->nMem;
    
// ABS Label 675
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}

// ABS Label 676
if(pLevel->iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, pLevel->iLeftJoin);
    VdbeComment((v, "init LEFT JOIN no-match flag"));
  }

  /* Compute a safe address to jump to if we discover that the table for
  ** this loop is empty and can never contribute content. */
  j = iLevel;

// ABS Label 677
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}
// ABS Label 678
if(pWInfo->a[j].iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}

// COR Label 679
if((j > 0 || pWInfo->a[j].iLeftJoin == 0) != (j > 0 && pWInfo->a[j].iLeftJoin == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 679);
}

// ROR Label 680
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 680);
}
// ROR Label 681
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 681);
}
// ROR Label 682
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 682);
}
// ROR Label 683
if((pWInfo->a[j].iLeftJoin != 0) != (pWInfo->a[j].iLeftJoin == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 683);
}

// MCC Label 684
if(j > 0 && pWInfo->a[j].iLeftJoin == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 684);
}
// MCC Label 685
if(j > 0 && !(pWInfo->a[j].iLeftJoin == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 685);
}
// MCC Label 686
if(!(j > 0) && pWInfo->a[j].iLeftJoin == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 686);
}
// MCC Label 687
if(!(j > 0) && !(pWInfo->a[j].iLeftJoin == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 687);
}
for(; j>0 && pWInfo->a[j].iLeftJoin==0; j--){};
// ABS Label 688
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}
// ABS Label 689
if(pWInfo->a[j].iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}

// COR Label 690
if((j > 0 || pWInfo->a[j].iLeftJoin == 0) != (j > 0 && pWInfo->a[j].iLeftJoin == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 690);
}

// ROR Label 691
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 691);
}
// ROR Label 692
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 692);
}
// ROR Label 693
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 693);
}
// ROR Label 694
if((pWInfo->a[j].iLeftJoin != 0) != (pWInfo->a[j].iLeftJoin == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 694);
}

// MCC Label 695
if(j > 0 && pWInfo->a[j].iLeftJoin == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 695);
}
// MCC Label 696
if(j > 0 && !(pWInfo->a[j].iLeftJoin == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 696);
}
// MCC Label 697
if(!(j > 0) && pWInfo->a[j].iLeftJoin == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 697);
}
// MCC Label 698
if(!(j > 0) && !(pWInfo->a[j].iLeftJoin == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 698);
}

  addrHalt = pWInfo->a[j].addrBrk;

  /* Special case of a FROM clause subquery implemented as a co-routine */
  
// ABS Label 699
if(pTabItem->fg.viaCoroutine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 699);
}
if( pTabItem->fg.viaCoroutine ){
    
// ABS Label 700
if(pTabItem->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}
int regYield = pTabItem->regReturn;
    
// ABS Label 701
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}

// ABS Label 702
if(regYield < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}

// ABS Label 703
if(pTabItem->addrFillSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 703);
}
sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);
    pLevel->p2 =  sqlite3VdbeAddOp2(v, OP_Yield, regYield, addrBrk);
    VdbeCoverage(v);
    VdbeComment((v, "next row of %s", pTabItem->pTab->zName));
    pLevel->op = OP_Goto;
  }else {

#ifndef SQLITE_OMIT_VIRTUALTABLE
  
// ROR Label 704
if(((pLoop->wsFlags & 1024) == 0) != ((pLoop->wsFlags & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 704);
}
if(  (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){
    /* Case 1:  The table is a virtual-table.  Use the VFilter and VNext
    **          to access the data.
    */
    int iReg;   /* P3 Value for OP_VFilter */
    int addrNotFound;
    int nConstraint = pLoop->nLTerm;
    int iIn;    /* Counter for IN constraints */

    iReg = sqlite3GetTempRange(pParse, nConstraint+2);
    addrNotFound = pLevel->addrBrk;
    j = 0;

// ABS Label 718
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 718);
}
// ABS Label 719
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}

// ROR Label 720
if((j <= nConstraint) != (j < nConstraint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}
// ROR Label 721
if((j > nConstraint) != (j < nConstraint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 721);
}
// ROR Label 722
if((j >= nConstraint) != (j < nConstraint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 722);
}
for(; j<nConstraint; j++){
      
// ABS Label 728
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}
// ABS Label 729
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}

// AOR Label 730
if(iReg + j - 2 != iReg + j + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 730);
}
// AOR Label 731
if(iReg + j / 2 != iReg + j + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 731);
}
// AOR Label 732
if(iReg + j * 2 != iReg + j + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 732);
}
// AOR Label 733
if(iReg - j != iReg + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 733);
}
// AOR Label 734
if(iReg / j != iReg + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 734);
}
// AOR Label 735
if(iReg * j != iReg + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 735);
}
int iTarget = iReg+j+2;
      pTerm = pLoop->aLTerm[j];
      
// MCC Label 736
if(( pTerm == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 736);
}
// MCC Label 737
if(( !(pTerm == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 737);
}
if( NEVER(pTerm==0) ) { continue;
}
      
// AOR Label 738
if(pTerm->eOperator | 1 != pTerm->eOperator & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 738);
}
// AOR Label 739
if(pTerm->eOperator ^ 1 != pTerm->eOperator & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 739);
}
if( pTerm->eOperator & WO_IN ){
        
// ABS Label 740
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}

// ABS Label 741
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}

// ABS Label 742
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}

// ABS Label 743
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}

// ABS Label 744
if(bRev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 744);
}

// ABS Label 745
if(iTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}
codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
        addrNotFound = pLevel->addrNxt;
      }else{
        
// ABS Label 746
if(pTerm->pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}
Expr *pRight = pTerm->pExpr->pRight;
        
// ABS Label 747
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// ABS Label 748
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// ABS Label 749
if(iTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}
codeExprOrVector(pParse, pRight, iTarget, 1);
      }
    };
// ABS Label 723
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 723);
}
// ABS Label 724
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 724);
}

// ROR Label 725
if((j <= nConstraint) != (j < nConstraint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 725);
}
// ROR Label 726
if((j > nConstraint) != (j < nConstraint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 726);
}
// ROR Label 727
if((j >= nConstraint) != (j < nConstraint))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 727);
}

    
// ABS Label 705
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}

// ABS Label 706
if(pLoop->u.vtab.idxNum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}

// ABS Label 707
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}
sqlite3VdbeAddOp2(v, OP_Integer, pLoop->u.vtab.idxNum, iReg);
    
// ABS Label 708
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 708);
}

// ABS Label 709
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}

// ABS Label 710
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}

// AOR Label 711
if(iReg - 1 != iReg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 711);
}
// AOR Label 712
if(iReg / 1 != iReg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 712);
}
// AOR Label 713
if(iReg * 1 != iReg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 713);
}
sqlite3VdbeAddOp2(v, OP_Integer, nConstraint, iReg+1);
    
// ABS Label 714
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}

// ABS Label 715
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 715);
}

// ABS Label 716
if(addrNotFound < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}

// ABS Label 717
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}
sqlite3VdbeAddOp4(v, OP_VFilter, iCur, addrNotFound, iReg,
                      pLoop->u.vtab.idxStr,
                      pLoop->u.vtab.needFree ? P4_DYNAMIC : P4_STATIC);
    VdbeCoverage(v);
    pLoop->u.vtab.needFree = 0;
    /* An OOM inside of AddOp4(OP_VFilter) instruction above might have freed
    ** the u.vtab.idxStr.  NULL it out to prevent a use-after-free */
    
// ABS Label 750
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 750);
}
if( db->mallocFailed ) { pLoop->u.vtab.idxStr = 0;
}
    pLevel->p1 = iCur;
    pLevel->op = pWInfo->eOnePass ? OP_Noop : OP_VNext;
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);
    iIn = pLevel->u.in.nIn;
    j = nConstraint - 1;

// ABS Label 751
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 751);
}

// ROR Label 752
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 752);
}
// ROR Label 753
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 753);
}
// ROR Label 754
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 754);
}
for(; j>=0; j--){
      pTerm = pLoop->aLTerm[j];
      
// ROR Label 759
if(((pTerm->eOperator & 1) == 0) != ((pTerm->eOperator & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 759);
}
if( (pTerm->eOperator & WO_IN)!=0 ) { iIn--;
}
      
// ABS Label 760
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}

// AOR Label 761
if((pLoop->u.vtab.omitMask >> j) | 1 != (pLoop->u.vtab.omitMask >> j) & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 761);
}
// AOR Label 762
if((pLoop->u.vtab.omitMask >> j) ^ 1 != (pLoop->u.vtab.omitMask >> j) & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 762);
}

// COR Label 763
if((j < 16 || (pLoop->u.vtab.omitMask >> j) & 1) != (j < 16 && (pLoop->u.vtab.omitMask >> j) & 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 763);
}

// ROR Label 764
if((j <= 16) != (j < 16))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 764);
}
// ROR Label 765
if((j > 16) != (j < 16))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 765);
}
// ROR Label 766
if((j >= 16) != (j < 16))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 766);
}

// MCC Label 767
if(j < 16 && (pLoop->u.vtab.omitMask >> j) & 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 767);
}
// MCC Label 768
if(j < 16 && !((pLoop->u.vtab.omitMask >> j) & 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 768);
}
// MCC Label 769
if(!(j < 16) && (pLoop->u.vtab.omitMask >> j) & 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 769);
}
// MCC Label 770
if(!(j < 16) && !((pLoop->u.vtab.omitMask >> j) & 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
if( j<16 && (pLoop->u.vtab.omitMask>>j)&1 ){
        
// ABS Label 771
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 771);
}

// ABS Label 772
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 772);
}
disableTerm(pLevel, pTerm);
      }else { if( (pTerm->eOperator & WO_IN)!=0
        && sqlite3ExprVectorSize(pTerm->pExpr->pLeft)==1
      ){
        Expr *pCompare;  /* The comparison operator */
        Expr *pRight;    /* RHS of the comparison */
        VdbeOp *pOp;     /* Opcode to access the value of the IN constraint */

        /* Reload the constraint value into reg[iReg+j+2].  The same value
        ** was loaded into the same register prior to the OP_VFilter, but
        ** the xFilter implementation might have changed the datatype or
        ** encoding of the value in the register, so it *must* be reloaded. */
        assert( pLevel->u.in.aInLoop!=0 || db->mallocFailed );
        if( !db->mallocFailed ){
          assert( iIn>=0 && iIn<pLevel->u.in.nIn );
          pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[iIn].addrInTop);
          assert( pOp->opcode==OP_Column || pOp->opcode==OP_Rowid );
          assert( pOp->opcode!=OP_Column || pOp->p3==iReg+j+2 );
          assert( pOp->opcode!=OP_Rowid || pOp->p2==iReg+j+2 );
          testcase( pOp->opcode==OP_Rowid );
          
// ABS Label 773
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}

// ABS Label 774
if(pOp->p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}

// ABS Label 775
if(pOp->p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// ABS Label 776
if(pOp->p3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}
sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);
        }

        /* Generate code that will continue to the next row if 
        ** the IN constraint is not satisfied */
        pCompare = sqlite3PExpr(pParse, TK_EQ, 0, 0);
        assert( pCompare!=0 || db->mallocFailed );
        
// ABS Label 777
if(pCompare < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}
if( pCompare ){
          pCompare->pLeft = pTerm->pExpr->pLeft;
          pCompare->pRight = pRight = sqlite3Expr(db, TK_REGISTER, 0);
          
// ABS Label 780
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}
if( pRight ){
            pRight->iTable = iReg+j+2;
            
// ABS Label 781
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}

// ABS Label 782
if(pCompare < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}

// ABS Label 783
if(pLevel->addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}
sqlite3ExprIfFalse(
                pParse, pCompare, pLevel->addrCont, SQLITE_JUMPIFNULL
            );
          }
          pCompare->pLeft = 0;
          
// ABS Label 778
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}

// ABS Label 779
if(pCompare < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 779);
}
sqlite3ExprDelete(db, pCompare);
        }
      };}

    };
// ABS Label 755
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}

// ROR Label 756
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 756);
}
// ROR Label 757
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 757);
}
// ROR Label 758
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 758);
}

    assert( iIn==0 || db->mallocFailed );
    /* These registers need to be preserved in case there is an IN operator
    ** loop.  So we could deallocate the registers here (and potentially
    ** reuse them later) if (pLoop->wsFlags & WHERE_IN_ABLE)==0.  But it seems
    ** simpler and safer to simply not reuse the registers.
    **
    **    sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2);
    */
  }else {
#endif /* SQLITE_OMIT_VIRTUALTABLE */

  
// COR Label 784
if(((pLoop->wsFlags & 256) != 0 || (pLoop->wsFlags & (4 | 1)) != 0) != ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & (4 | 1)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 784);
}

// ROR Label 785
if(((pLoop->wsFlags & 256) == 0) != ((pLoop->wsFlags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 785);
}
// ROR Label 786
if(((pLoop->wsFlags & (4 | 1)) == 0) != ((pLoop->wsFlags & (4 | 1)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 786);
}

// MCC Label 787
if((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & (4 | 1)) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 787);
}
// MCC Label 788
if((pLoop->wsFlags & 256) != 0 && !((pLoop->wsFlags & (4 | 1)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 788);
}
// MCC Label 789
if(!((pLoop->wsFlags & 256) != 0) && (pLoop->wsFlags & (4 | 1)) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 789);
}
// MCC Label 790
if(!((pLoop->wsFlags & 256) != 0) && !((pLoop->wsFlags & (4 | 1)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 790);
}
if( (pLoop->wsFlags & WHERE_IPK)!=0
   && (pLoop->wsFlags & (WHERE_COLUMN_IN|WHERE_COLUMN_EQ))!=0
  ){
    /* Case 2:  We can directly reference a single row using an
    **          equality comparison against the ROWID field.  Or
    **          we reference multiple rows using a "rowid IN (...)"
    **          construct.
    */
    assert( pLoop->u.btree.nEq==1 );
    pTerm = pLoop->aLTerm[0];
    assert( pTerm!=0 );
    assert( pTerm->pExpr!=0 );
    testcase( pTerm->wtFlags & TERM_VIRTUAL );
    iReleaseReg = ++pParse->nMem;
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
    
// ABS Label 795
if(iReleaseReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}
// ABS Label 796
if(iRowidReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}

// ROR Label 797
if((iRowidReg == iReleaseReg) != (iRowidReg != iReleaseReg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 797);
}
if( iRowidReg!=iReleaseReg ) { 
// ABS Label 798
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}

// ABS Label 799
if(iReleaseReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}
sqlite3ReleaseTempReg(pParse, iReleaseReg);
}
    addrNxt = pLevel->addrNxt;
    
// ABS Label 791
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}

// ABS Label 792
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}

// ABS Label 793
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}

// ABS Label 794
if(iRowidReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}
sqlite3VdbeAddOp3(v, OP_SeekRowid, iCur, addrNxt, iRowidReg);
    VdbeCoverage(v);
    pLevel->op = OP_Noop;
    
// ROR Label 800
if(((pTerm->prereqAll & pLevel->notReady) != 0) != ((pTerm->prereqAll & pLevel->notReady) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 800);
}
if( (pTerm->prereqAll & pLevel->notReady)==0 ){
      pTerm->wtFlags |= TERM_CODED;
    }
  }else { 
// COR Label 801
if(((pLoop->wsFlags & 256) != 0 || (pLoop->wsFlags & 2) != 0) != ((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & 2) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 801);
}

// ROR Label 802
if(((pLoop->wsFlags & 256) == 0) != ((pLoop->wsFlags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 802);
}
// ROR Label 803
if(((pLoop->wsFlags & 2) == 0) != ((pLoop->wsFlags & 2) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 803);
}

// MCC Label 804
if((pLoop->wsFlags & 256) != 0 && (pLoop->wsFlags & 2) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 804);
}
// MCC Label 805
if((pLoop->wsFlags & 256) != 0 && !((pLoop->wsFlags & 2) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 805);
}
// MCC Label 806
if(!((pLoop->wsFlags & 256) != 0) && (pLoop->wsFlags & 2) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 806);
}
// MCC Label 807
if(!((pLoop->wsFlags & 256) != 0) && !((pLoop->wsFlags & 2) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 807);
}
if( (pLoop->wsFlags & WHERE_IPK)!=0
         && (pLoop->wsFlags & WHERE_COLUMN_RANGE)!=0
  ){
    /* Case 3:  We have an inequality comparison against the ROWID field.
    */
    int testOp = OP_Noop;
    int start;
    int memEndValue = 0;
    WhereTerm *pStart, *pEnd;

    j = 0;
    pStart = pEnd = 0;
    
// ABS Label 808
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}

// AOR Label 809
if(pLoop->wsFlags | 32 != pLoop->wsFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 809);
}
// AOR Label 810
if(pLoop->wsFlags ^ 32 != pLoop->wsFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 810);
}
if( pLoop->wsFlags & WHERE_BTM_LIMIT ) { pStart = pLoop->aLTerm[j++];
}
    
// ABS Label 811
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}

// AOR Label 812
if(pLoop->wsFlags | 16 != pLoop->wsFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 812);
}
// AOR Label 813
if(pLoop->wsFlags ^ 16 != pLoop->wsFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 813);
}
if( pLoop->wsFlags & WHERE_TOP_LIMIT ) { pEnd = pLoop->aLTerm[j++];
}
    assert( pStart!=0 || pEnd!=0 );
    
// ABS Label 814
if(bRev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}
if( bRev ){
      pTerm = pStart;
      pStart = pEnd;
      pEnd = pTerm;
    }
    codeCursorHint(pTabItem, pWInfo, pLevel, pEnd);
    
// ABS Label 815
if(pStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}
if( pStart ){
      Expr *pX;             /* The expression that defines the start bound */
      int r1, rTemp;        /* Registers for holding the start boundary */
      int op;               /* Cursor seek operation */

      /* The following constant maps TK_xx codes into corresponding 
      ** seek opcodes.  It depends on a particular ordering of TK_xx
      */
      const u8 aMoveOp[] = {
           /* TK_GT */  OP_SeekGT,
           /* TK_LE */  OP_SeekLE,
           /* TK_LT */  OP_SeekLT,
           /* TK_GE */  OP_SeekGE
      };
      assert( TK_LE==TK_GT+1 );      /* Make sure the ordering.. */
      assert( TK_LT==TK_GT+2 );      /*  ... of the TK_xx values... */
      assert( TK_GE==TK_GT+3 );      /*  ... is correcct. */

      assert( (pStart->wtFlags & TERM_VNULL)==0 );
      testcase( pStart->wtFlags & TERM_VIRTUAL );
      pX = pStart->pExpr;
      assert( pX!=0 );
      testcase( pStart->leftCursor!=iCur ); /* transitive constraints */
      if( sqlite3ExprIsVector(pX->pRight) ){
        r1 = rTemp = sqlite3GetTempReg(pParse);
        
// ABS Label 823
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}

// ABS Label 824
if(pX->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ABS Label 825
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}
codeExprOrVector(pParse, pX->pRight, r1, 1);
        testcase( pX->op==TK_GT );
        testcase( pX->op==TK_GE );
        testcase( pX->op==TK_LT );
        testcase( pX->op==TK_LE );
        op = aMoveOp[((pX->op - TK_GT - 1) & 0x3) | 0x1];
        assert( pX->op!=TK_GT || op==OP_SeekGE );
        assert( pX->op!=TK_GE || op==OP_SeekGE );
        assert( pX->op!=TK_LT || op==OP_SeekLE );
        assert( pX->op!=TK_LE || op==OP_SeekLE );
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);
        
// ABS Label 826
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}

// ABS Label 827
if(pStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
disableTerm(pLevel, pStart);
        op = aMoveOp[(pX->op - TK_GT)];
      }
      
// ABS Label 816
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// ABS Label 817
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}

// ABS Label 818
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}

// ABS Label 819
if(addrBrk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}

// ABS Label 820
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);
      VdbeComment((v, "pk"));
      VdbeCoverageIf(v, pX->op==TK_GT);
      VdbeCoverageIf(v, pX->op==TK_LE);
      VdbeCoverageIf(v, pX->op==TK_LT);
      VdbeCoverageIf(v, pX->op==TK_GE);
      
// ABS Label 821
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}

// ABS Label 822
if(rTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}
sqlite3ReleaseTempReg(pParse, rTemp);
    }else{
      
// ABS Label 828
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// ABS Label 829
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}

// ABS Label 830
if(addrHalt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}
sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iCur, addrHalt);
      VdbeCoverageIf(v, bRev==0);
      VdbeCoverageIf(v, bRev!=0);
    }
    
// ABS Label 831
if(pEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 831);
}
if( pEnd ){
      Expr *pX;
      pX = pEnd->pExpr;
      assert( pX!=0 );
      assert( (pEnd->wtFlags & TERM_VNULL)==0 );
      testcase( pEnd->leftCursor!=iCur ); /* Transitive constraints */
      testcase( pEnd->wtFlags & TERM_VIRTUAL );
      memEndValue = ++pParse->nMem;
      
// ABS Label 832
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 832);
}

// ABS Label 833
if(pX->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}

// ABS Label 834
if(memEndValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 834);
}
codeExprOrVector(pParse, pX->pRight, memEndValue, 1);
      if( 0==sqlite3ExprIsVector(pX->pRight) 
       && (pX->op==TK_LT || pX->op==TK_GT) 
      ){
        testOp = bRev ? OP_Le : OP_Ge;
      }else{
        testOp = bRev ? OP_Lt : OP_Gt;
      }
      if( 0==sqlite3ExprIsVector(pX->pRight) ){
        
// ABS Label 835
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}

// ABS Label 836
if(pEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 836);
}
disableTerm(pLevel, pEnd);
      }
    }
    start = sqlite3VdbeCurrentAddr(v);
    pLevel->op = bRev ? OP_Prev : OP_Next;
    pLevel->p1 = iCur;
    pLevel->p2 = start;
    assert( pLevel->p5==0 );
    
// ABS Label 837
if(testOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 837);
}

// ROR Label 838
if((testOp == 177) != (testOp != 177))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 838);
}
if( testOp!=OP_Noop ){
      iRowidReg = ++pParse->nMem;
      
// ABS Label 839
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}

// ABS Label 840
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 840);
}

// ABS Label 841
if(iRowidReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 841);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iCur, iRowidReg);
      
// ABS Label 842
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 842);
}

// ABS Label 843
if(testOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 843);
}

// ABS Label 844
if(memEndValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 844);
}

// ABS Label 845
if(addrBrk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}

// ABS Label 846
if(iRowidReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}
sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
      VdbeCoverageIf(v, testOp==OP_Le);
      VdbeCoverageIf(v, testOp==OP_Lt);
      VdbeCoverageIf(v, testOp==OP_Ge);
      VdbeCoverageIf(v, testOp==OP_Gt);
      
// ABS Label 847
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}
sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL);
    }
  }else { 
// ABS Label 848
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}

// AOR Label 849
if(pLoop->wsFlags | 512 != pLoop->wsFlags & 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 849);
}
// AOR Label 850
if(pLoop->wsFlags ^ 512 != pLoop->wsFlags & 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 850);
}
if( pLoop->wsFlags & WHERE_INDEXED ){
    /* Case 4: A scan using an index.
    **
    **         The WHERE clause may contain zero or more equality 
    **         terms ("==" or "IN" operators) that refer to the N
    **         left-most columns of the index. It may also contain
    **         inequality constraints (>, <, >= or <=) on the indexed
    **         column that immediately follows the N equalities. Only 
    **         the right-most column can be an inequality - the rest must
    **         use the "==" and "IN" operators. For example, if the 
    **         index is on (x,y,z), then the following clauses are all 
    **         optimized:
    **
    **            x=5
    **            x=5 AND y=10
    **            x=5 AND y<10
    **            x=5 AND y>5 AND y<10
    **            x=5 AND y=5 AND z<=10
    **
    **         The z<10 term of the following cannot be used, only
    **         the x=5 term:
    **
    **            x=5 AND z<10
    **
    **         N may be zero if there are inequality constraints.
    **         If there are no inequality constraints, then N is at
    **         least one.
    **
    **         This case is also used when there are no WHERE clause
    **         constraints but an index is selected anyway, in order
    **         to force the output order to conform to an ORDER BY.
    */  
    static const u8 aStartOp[] = {
      0,
      0,
      OP_Rewind,           /* 2: (!start_constraints && startEq &&  !bRev) */
      OP_Last,             /* 3: (!start_constraints && startEq &&   bRev) */
      OP_SeekGT,           /* 4: (start_constraints  && !startEq && !bRev) */
      OP_SeekLT,           /* 5: (start_constraints  && !startEq &&  bRev) */
      OP_SeekGE,           /* 6: (start_constraints  &&  startEq && !bRev) */
      OP_SeekLE            /* 7: (start_constraints  &&  startEq &&  bRev) */
    };
    static const u8 aEndOp[] = {
      OP_IdxGE,            /* 0: (end_constraints && !bRev && !endEq) */
      OP_IdxGT,            /* 1: (end_constraints && !bRev &&  endEq) */
      OP_IdxLE,            /* 2: (end_constraints &&  bRev && !endEq) */
      OP_IdxLT,            /* 3: (end_constraints &&  bRev &&  endEq) */
    };
    
// ABS Label 851
if(pLoop->u.btree.nEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}
u16 nEq = pLoop->u.btree.nEq;     /* Number of == or IN terms */
    
// ABS Label 852
if(pLoop->u.btree.nBtm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}
u16 nBtm = pLoop->u.btree.nBtm;   /* Length of BTM vector */
    
// ABS Label 853
if(pLoop->u.btree.nTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 853);
}
u16 nTop = pLoop->u.btree.nTop;   /* Length of TOP vector */
    int regBase;                 /* Base register holding constraint values */
    WhereTerm *pRangeStart = 0;  /* Inequality constraint at range start */
    WhereTerm *pRangeEnd = 0;    /* Inequality constraint at range end */
    int startEq;                 /* True if range start uses ==, >= or <= */
    int endEq;                   /* True if range end uses ==, >= or <= */
    int start_constraints;       /* Start of range is constrained */
    int nConstraint;             /* Number of constraint terms */
    int iIdxCur;                 /* The VDBE cursor for the index */
    int nExtraReg = 0;           /* Number of extra registers needed */
    int op;                      /* Instruction opcode */
    char *zStartAff;             /* Affinity for start of range constraint */
    char *zEndAff = 0;           /* Affinity for end of range constraint */
    u8 bSeekPastNull = 0;        /* True to seek past initial nulls */
    u8 bStopAtNull = 0;          /* Add condition to terminate at NULLs */
    int omitTable;               /* True if we use the index only */
    int regBignull = 0;          /* big-null flag register */
    int addrSeekScan = 0;        /* Opcode of the OP_SeekScan, if any */

    pIdx = pLoop->u.btree.pIndex;
    iIdxCur = pLevel->iIdxCur;
    assert( nEq>=pLoop->nSkip );

    /* Find any inequality constraint terms for the start and end 
    ** of the range. 
    */
    j = nEq;
    
// ABS Label 863
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}

// AOR Label 864
if(pLoop->wsFlags | 32 != pLoop->wsFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 864);
}
// AOR Label 865
if(pLoop->wsFlags ^ 32 != pLoop->wsFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 865);
}
if( pLoop->wsFlags & WHERE_BTM_LIMIT ){
      pRangeStart = pLoop->aLTerm[j++];
      nExtraReg = MAX(nExtraReg, pLoop->u.btree.nBtm);
      /* Like optimization range constraints always occur in pairs */
      assert( (pRangeStart->wtFlags & TERM_LIKEOPT)==0 || 
              (pLoop->wsFlags & WHERE_TOP_LIMIT)!=0 );
    }
    
// ABS Label 866
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 866);
}

// AOR Label 867
if(pLoop->wsFlags | 16 != pLoop->wsFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 867);
}
// AOR Label 868
if(pLoop->wsFlags ^ 16 != pLoop->wsFlags & 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 868);
}
if( pLoop->wsFlags & WHERE_TOP_LIMIT ){
      pRangeEnd = pLoop->aLTerm[j++];
      nExtraReg = MAX(nExtraReg, pLoop->u.btree.nTop);
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
      
// ROR Label 869
if(((pRangeEnd->wtFlags & 256) == 0) != ((pRangeEnd->wtFlags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 869);
}
if( (pRangeEnd->wtFlags & TERM_LIKEOPT)!=0 ){
        assert( pRangeStart!=0 );                     /* LIKE opt constraints */
        assert( pRangeStart->wtFlags & TERM_LIKEOPT );   /* occur in pairs */
        pLevel->iLikeRepCntr = (u32)++pParse->nMem;
        
// ABS Label 870
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, (int)pLevel->iLikeRepCntr);
        VdbeComment((v, "LIKE loop counter"));
        pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);
        /* iLikeRepCntr actually stores 2x the counter register number.  The
        ** bottom bit indicates whether the search order is ASC or DESC. */
        testcase( bRev );
        testcase( pIdx->aSortOrder[nEq]==SQLITE_SO_DESC );
        assert( (bRev & ~1)==0 );
        pLevel->iLikeRepCntr <<=1;
        pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq]==SQLITE_SO_DESC);
      }
#endif
      
// ABS Label 871
if(pRangeStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}

// ROR Label 872
if((pRangeStart != 0) != (pRangeStart == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 872);
}
if( pRangeStart==0 ){
        j = pIdx->aiColumn[nEq];
        
// ABS Label 873
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// COR Label 874
if(((j >= 0 && pIdx->pTable->aCol[j].notNull == 0) && j == (-2)) != ((j >= 0 && pIdx->pTable->aCol[j].notNull == 0) || j == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 874);
}

// ROR Label 875
if((j != (-2)) != (j == (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}

// MCC Label 876
if(( j >= 0 && pIdx->pTable->aCol[j].notNull == 0 ) && j == (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 876);
}
// MCC Label 877
if(( j >= 0 && pIdx->pTable->aCol[j].notNull == 0 ) && !(j == (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 877);
}
// MCC Label 878
if(( j >= 0 && !(pIdx->pTable->aCol[j].notNull == 0) ) && j == (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 878);
}
// MCC Label 879
if(( j >= 0 && !(pIdx->pTable->aCol[j].notNull == 0) ) && !(j == (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 879);
}
// MCC Label 880
if(( !(j >= 0) && pIdx->pTable->aCol[j].notNull == 0 ) && j == (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 880);
}
// MCC Label 881
if(( !(j >= 0) && pIdx->pTable->aCol[j].notNull == 0 ) && !(j == (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 881);
}
// MCC Label 882
if(( !(j >= 0) && !(pIdx->pTable->aCol[j].notNull == 0) ) && j == (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 882);
}
// MCC Label 883
if(( !(j >= 0) && !(pIdx->pTable->aCol[j].notNull == 0) ) && !(j == (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 883);
}
if( (j>=0 && pIdx->pTable->aCol[j].notNull==0) || j==XN_EXPR ){
          bSeekPastNull = 1;
        }
      }
    }
    assert( pRangeEnd==0 || (pRangeEnd->wtFlags & TERM_VNULL)==0 );

    /* If the WHERE_BIGNULL_SORT flag is set, then index column nEq uses
    ** a non-default "big-null" sort (either ASC NULLS LAST or DESC NULLS 
    ** FIRST). In both cases separate ordered scans are made of those
    ** index entries for which the column is null and for those for which
    ** it is not. For an ASC sort, the non-NULL entries are scanned first.
    ** For DESC, NULL entries are scanned first.
    */
    
// COR Label 884
if(((pLoop->wsFlags & (16 | 32)) == 0 || (pLoop->wsFlags & 524288) != 0) != ((pLoop->wsFlags & (16 | 32)) == 0 && (pLoop->wsFlags & 524288) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 884);
}

// ROR Label 885
if(((pLoop->wsFlags & (16 | 32)) != 0) != ((pLoop->wsFlags & (16 | 32)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 885);
}
// ROR Label 886
if(((pLoop->wsFlags & 524288) == 0) != ((pLoop->wsFlags & 524288) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}

// MCC Label 887
if((pLoop->wsFlags & (16 | 32)) == 0 && (pLoop->wsFlags & 524288) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 887);
}
// MCC Label 888
if((pLoop->wsFlags & (16 | 32)) == 0 && !((pLoop->wsFlags & 524288) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 888);
}
// MCC Label 889
if(!((pLoop->wsFlags & (16 | 32)) == 0) && (pLoop->wsFlags & 524288) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 889);
}
// MCC Label 890
if(!((pLoop->wsFlags & (16 | 32)) == 0) && !((pLoop->wsFlags & 524288) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 890);
}
if( (pLoop->wsFlags & (WHERE_TOP_LIMIT|WHERE_BTM_LIMIT))==0
     && (pLoop->wsFlags & WHERE_BIGNULL_SORT)!=0
    ){
      assert( bSeekPastNull==0 && nExtraReg==0 && nBtm==0 && nTop==0 );
      assert( pRangeEnd==0 && pRangeStart==0 );
      testcase( pLoop->nSkip>0 );
      nExtraReg = 1;
      bSeekPastNull = 1;
      pLevel->regBignull = regBignull = ++pParse->nMem;
      
// ABS Label 891
if(pLevel->iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}
if( pLevel->iLeftJoin ){
        
// ABS Label 892
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 892);
}

// ABS Label 893
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regBignull);
      }
      pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);
    }

    /* If we are doing a reverse order scan on an ascending index, or
    ** a forward order scan on a descending index, interchange the 
    ** start and end terms (pRangeStart and pRangeEnd).
    */
    
// MCC Label 894
if(( nEq < pIdx->nColumn && bRev == (pIdx->aSortOrder[nEq] == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 894);
}
// MCC Label 895
if(( nEq < pIdx->nColumn && !(bRev == (pIdx->aSortOrder[nEq] == 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 895);
}
// MCC Label 896
if(( !(nEq < pIdx->nColumn) && bRev == (pIdx->aSortOrder[nEq] == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 896);
}
// MCC Label 897
if(( !(nEq < pIdx->nColumn) && !(bRev == (pIdx->aSortOrder[nEq] == 0)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 897);
}
if( (nEq<pIdx->nColumn && bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC)) ){
      SWAP(WhereTerm *, pRangeEnd, pRangeStart);
      SWAP(u8, bSeekPastNull, bStopAtNull);
      SWAP(u8, nBtm, nTop);
    }

    
// ABS Label 900
if(iLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 900);
}

// COR Label 901
if((iLevel > 0 || (pLoop->wsFlags & 1048576) != 0) != (iLevel > 0 && (pLoop->wsFlags & 1048576) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 901);
}

// ROR Label 902
if((iLevel <= 0) != (iLevel > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 902);
}
// ROR Label 903
if((iLevel < 0) != (iLevel > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 903);
}
// ROR Label 904
if((iLevel >= 0) != (iLevel > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 904);
}
// ROR Label 905
if(((pLoop->wsFlags & 1048576) == 0) != ((pLoop->wsFlags & 1048576) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 905);
}

// MCC Label 906
if(iLevel > 0 && (pLoop->wsFlags & 1048576) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 906);
}
// MCC Label 907
if(iLevel > 0 && !((pLoop->wsFlags & 1048576) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(!(iLevel > 0) && (pLoop->wsFlags & 1048576) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
// MCC Label 909
if(!(iLevel > 0) && !((pLoop->wsFlags & 1048576) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 909);
}
if( iLevel>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)!=0 ){
      /* In case OP_SeekScan is used, ensure that the index cursor does not
      ** point to a valid row for the first iteration of this loop. */
      
// ABS Label 910
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}

// ABS Label 911
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}
sqlite3VdbeAddOp1(v, OP_NullRow, iIdxCur);
    }

    /* Generate code to evaluate all constraint terms using == or IN
    ** and store the values of those terms in an array of registers
    ** starting at regBase.
    */
    codeCursorHint(pTabItem, pWInfo, pLevel, pRangeEnd);
    regBase = codeAllEqualityTerms(pParse,pLevel,bRev,nExtraReg,&zStartAff);
    assert( zStartAff==0 || sqlite3Strlen30(zStartAff)>=nEq );
    
// ABS Label 912
if(zStartAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 912);
}

// COR Label 913
if((zStartAff || nTop) != (zStartAff && nTop))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 913);
}

// MCC Label 914
if(zStartAff && nTop ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(zStartAff && !(nTop) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(!(zStartAff) && nTop ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}
// MCC Label 917
if(!(zStartAff) && !(nTop) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 917);
}
if( zStartAff && nTop ){
      zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
    }
    addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);

    testcase( pRangeStart && (pRangeStart->eOperator & WO_LE)!=0 );
    testcase( pRangeStart && (pRangeStart->eOperator & WO_GE)!=0 );
    testcase( pRangeEnd && (pRangeEnd->eOperator & WO_LE)!=0 );
    testcase( pRangeEnd && (pRangeEnd->eOperator & WO_GE)!=0 );
    startEq = !pRangeStart || pRangeStart->eOperator & (WO_LE|WO_GE);
    endEq =   !pRangeEnd || pRangeEnd->eOperator & (WO_LE|WO_GE);
    start_constraints = pRangeStart || nEq>0;

    /* Seek the index cursor to the start of the range. */
    nConstraint = nEq;
    
// ABS Label 918
if(pRangeStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 918);
}
if( pRangeStart ){
      
// ABS Label 919
if(pRangeStart->pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}
Expr *pRight = pRangeStart->pExpr->pRight;
      
// ABS Label 920
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}

// ABS Label 921
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}

// ABS Label 922
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}

// AOR Label 923
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 923);
}
// AOR Label 924
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 924);
}
// AOR Label 925
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 925);
}
codeExprOrVector(pParse, pRight, regBase+nEq, nBtm);
      
// ABS Label 926
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 926);
}

// ABS Label 927
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 927);
}

// ABS Label 928
if(pRangeStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 928);
}
whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
      if( (pRangeStart->wtFlags & TERM_VNULL)==0
       && sqlite3ExprCanBeNull(pRight)
      ){
        
// ABS Label 929
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 929);
}

// ABS Label 930
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}

// AOR Label 931
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 931);
}
// AOR Label 932
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 932);
}
// AOR Label 933
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 933);
}

// ABS Label 934
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regBase+nEq, addrNxt);
        VdbeCoverage(v);
      }
      
// ABS Label 935
if(zStartAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 935);
}
if( zStartAff ){
        
// ABS Label 936
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 936);
}
updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);
      }  
      nConstraint += nBtm;
      testcase( pRangeStart->wtFlags & TERM_VIRTUAL );
      if( sqlite3ExprIsVector(pRight)==0 ){
        
// ABS Label 937
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}

// ABS Label 938
if(pRangeStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}
disableTerm(pLevel, pRangeStart);
      }else{
        startEq = 1;
      }
      bSeekPastNull = 0;
    }else { 
// ABS Label 939
if(bSeekPastNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}
if( bSeekPastNull ){
      startEq = 0;
      
// ABS Label 940
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}

// ABS Label 941
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 941);
}

// AOR Label 942
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 942);
}
// AOR Label 943
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 943);
}
// AOR Label 944
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 944);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
      start_constraints = 1;
      nConstraint++;
    }else { 
// ABS Label 945
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}
if( regBignull ){
      
// ABS Label 946
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}

// ABS Label 947
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}

// AOR Label 948
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 948);
}
// AOR Label 949
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 949);
}
// AOR Label 950
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 950);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
      start_constraints = 1;
      nConstraint++;
    };}
;}

    
// ABS Label 854
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}

// ABS Label 855
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}

// ABS Label 856
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}

// AOR Label 857
if(nConstraint / bSeekPastNull != nConstraint - bSeekPastNull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 857);
}
// AOR Label 858
if(nConstraint + bSeekPastNull != nConstraint - bSeekPastNull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 858);
}
// AOR Label 859
if(nConstraint * bSeekPastNull != nConstraint - bSeekPastNull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 859);
}

// ABS Label 860
if(zStartAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}
codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);
    
// ABS Label 951
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 951);
}

// COR Label 952
if((pLoop->nSkip > 0 || nConstraint == pLoop->nSkip) != (pLoop->nSkip > 0 && nConstraint == pLoop->nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 952);
}

// ROR Label 953
if((pLoop->nSkip <= 0) != (pLoop->nSkip > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 953);
}
// ROR Label 954
if((pLoop->nSkip < 0) != (pLoop->nSkip > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 954);
}
// ROR Label 955
if((pLoop->nSkip >= 0) != (pLoop->nSkip > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 955);
}
// ROR Label 956
if((nConstraint != pLoop->nSkip) != (nConstraint == pLoop->nSkip))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 956);
}

// MCC Label 957
if(pLoop->nSkip > 0 && nConstraint == pLoop->nSkip ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 957);
}
// MCC Label 958
if(pLoop->nSkip > 0 && !(nConstraint == pLoop->nSkip) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 958);
}
// MCC Label 959
if(!(pLoop->nSkip > 0) && nConstraint == pLoop->nSkip ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 959);
}
// MCC Label 960
if(!(pLoop->nSkip > 0) && !(nConstraint == pLoop->nSkip) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 960);
}
if( pLoop->nSkip>0 && nConstraint==pLoop->nSkip ){
      /* The skip-scan logic inside the call to codeAllEqualityConstraints()
      ** above has already left the cursor sitting on the correct row,
      ** so no further seeking is needed */
    }else{
      
// ABS Label 967
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 967);
}
if( regBignull ){
        
// ABS Label 968
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 968);
}

// ABS Label 969
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 969);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, regBignull);
        VdbeComment((v, "NULL-scan pass ctr"));
      }

      op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];
      assert( op!=0 );
      
// ABS Label 970
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}

// COR Label 971
if(((pLoop->wsFlags & 1048576) != 0 || op == 24) != ((pLoop->wsFlags & 1048576) != 0 && op == 24))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 971);
}

// ROR Label 972
if(((pLoop->wsFlags & 1048576) == 0) != ((pLoop->wsFlags & 1048576) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 972);
}
// ROR Label 973
if((op != 24) != (op == 24))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 973);
}

// MCC Label 974
if((pLoop->wsFlags & 1048576) != 0 && op == 24 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 974);
}
// MCC Label 975
if((pLoop->wsFlags & 1048576) != 0 && !(op == 24) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 975);
}
// MCC Label 976
if(!((pLoop->wsFlags & 1048576) != 0) && op == 24 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 976);
}
// MCC Label 977
if(!((pLoop->wsFlags & 1048576) != 0) && !(op == 24) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 977);
}
if( (pLoop->wsFlags & WHERE_IN_SEEKSCAN)!=0 && op==OP_SeekGE ){
        assert( regBignull==0 );
        /* TUNING:  The OP_SeekScan opcode seeks to reduce the number
        ** of expensive seek operations by replacing a single seek with
        ** 1 or more step operations.  The question is, how many steps
        ** should we try before giving up and going with a seek.  The cost
        ** of a seek is proportional to the logarithm of the of the number
        ** of entries in the tree, so basing the number of steps to try
        ** on the estimated number of rows in the btree seems like a good
        ** guess. */
        addrSeekScan = sqlite3VdbeAddOp1(v, OP_SeekScan, 
                                         (pIdx->aiRowLogEst[0]+9)/10);
        VdbeCoverage(v);
      }
      
// ABS Label 961
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 961);
}

// ABS Label 962
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 962);
}

// ABS Label 963
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}

// ABS Label 964
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 964);
}

// ABS Label 965
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// ABS Label 966
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 966);
}
sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      VdbeCoverage(v);
      VdbeCoverageIf(v, op==OP_Rewind);  testcase( op==OP_Rewind );
      VdbeCoverageIf(v, op==OP_Last);    testcase( op==OP_Last );
      VdbeCoverageIf(v, op==OP_SeekGT);  testcase( op==OP_SeekGT );
      VdbeCoverageIf(v, op==OP_SeekGE);  testcase( op==OP_SeekGE );
      VdbeCoverageIf(v, op==OP_SeekLE);  testcase( op==OP_SeekLE );
      VdbeCoverageIf(v, op==OP_SeekLT);  testcase( op==OP_SeekLT );

      assert( bSeekPastNull==0 || bStopAtNull==0 );
      
// ABS Label 978
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}
if( regBignull ){
        assert( bSeekPastNull==1 || bStopAtNull==1 );
        assert( bSeekPastNull==!bStopAtNull );
        assert( bStopAtNull==startEq );
        
// ABS Label 979
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 979);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+2);
        op = aStartOp[(nConstraint>1)*4 + 2 + bRev];
        
// ABS Label 980
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}

// ABS Label 981
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 981);
}

// ABS Label 982
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}

// ABS Label 983
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 983);
}

// ABS Label 984
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 984);
}

// ABS Label 985
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}
// ABS Label 986
if(startEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}

// AOR Label 987
if(nConstraint / startEq != nConstraint - startEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 987);
}
// AOR Label 988
if(nConstraint + startEq != nConstraint - startEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 988);
}
// AOR Label 989
if(nConstraint * startEq != nConstraint - startEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 989);
}
sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, 
                             nConstraint-startEq);
        VdbeCoverage(v);
        VdbeCoverageIf(v, op==OP_Rewind);  testcase( op==OP_Rewind );
        VdbeCoverageIf(v, op==OP_Last);    testcase( op==OP_Last );
        VdbeCoverageIf(v, op==OP_SeekGE);  testcase( op==OP_SeekGE );
        VdbeCoverageIf(v, op==OP_SeekLE);  testcase( op==OP_SeekLE );
        assert( op==OP_Rewind || op==OP_Last || op==OP_SeekGE || op==OP_SeekLE);
      }
    }

    /* Load the value for the inequality constraint at the end of the
    ** range (if any).
    */
    nConstraint = nEq;
    
// ABS Label 990
if(pRangeEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 990);
}
if( pRangeEnd ){
      
// ABS Label 991
if(pRangeEnd->pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 991);
}
Expr *pRight = pRangeEnd->pExpr->pRight;
      
// ABS Label 992
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 992);
}

// ABS Label 993
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 993);
}

// ABS Label 994
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 994);
}

// AOR Label 995
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 995);
}
// AOR Label 996
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 996);
}
// AOR Label 997
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 997);
}
codeExprOrVector(pParse, pRight, regBase+nEq, nTop);
      
// ABS Label 998
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}

// ABS Label 999
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}

// ABS Label 1000
if(pRangeEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}
whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
      if( (pRangeEnd->wtFlags & TERM_VNULL)==0
       && sqlite3ExprCanBeNull(pRight)
      ){
        
// ABS Label 1001
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1001);
}

// ABS Label 1002
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}

// AOR Label 1003
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1003);
}
// AOR Label 1004
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1004);
}
// AOR Label 1005
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1005);
}

// ABS Label 1006
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regBase+nEq, addrNxt);
        VdbeCoverage(v);
      }
      
// ABS Label 1007
if(zEndAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1007);
}
if( zEndAff ){
        
// ABS Label 1008
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1008);
}

// ABS Label 1009
if(zEndAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1009);
}
updateRangeAffinityStr(pRight, nTop, zEndAff);
        
// ABS Label 1010
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1010);
}

// ABS Label 1011
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1011);
}

// AOR Label 1012
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1012);
}
// AOR Label 1013
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1013);
}
// AOR Label 1014
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1014);
}

// ABS Label 1015
if(zEndAff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}
codeApplyAffinity(pParse, regBase+nEq, nTop, zEndAff);
      }else{
        assert( pParse->db->mallocFailed );
      }
      nConstraint += nTop;
      testcase( pRangeEnd->wtFlags & TERM_VIRTUAL );

      if( sqlite3ExprIsVector(pRight)==0 ){
        
// ABS Label 1016
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}

// ABS Label 1017
if(pRangeEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}
disableTerm(pLevel, pRangeEnd);
      }else{
        endEq = 1;
      }
    }else { 
// ABS Label 1018
if(bStopAtNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1018);
}
if( bStopAtNull ){
      
// ABS Label 1019
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}

// ROR Label 1020
if((regBignull != 0) != (regBignull == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1020);
}
if( regBignull==0 ){
        
// ABS Label 1021
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1021);
}

// ABS Label 1022
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1022);
}

// AOR Label 1023
if(regBase - nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1023);
}
// AOR Label 1024
if(regBase / nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1024);
}
// AOR Label 1025
if(regBase * nEq != regBase + nEq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1025);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);
        endEq = 0;
      }
      nConstraint++;
    };}

    
// ABS Label 861
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 861);
}
sqlite3DbFree(db, zStartAff);
    
// ABS Label 862
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 862);
}
sqlite3DbFree(db, zEndAff);

    /* Top of the loop body */
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);

    /* Check if the index cursor is past the end of the range. */
    
// ABS Label 1026
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1026);
}
if( nConstraint ){
      
// ABS Label 1033
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}
if( regBignull ){
        /* Except, skip the end-of-range check while doing the NULL-scan */
        
// ABS Label 1034
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1034);
}

// ABS Label 1035
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1035);
}
sqlite3VdbeAddOp2(v, OP_IfNot, regBignull, sqlite3VdbeCurrentAddr(v)+3);
        VdbeComment((v, "If NULL-scan 2nd pass"));
        VdbeCoverage(v);
      }
      op = aEndOp[bRev*2 + endEq];
      
// ABS Label 1027
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1027);
}

// ABS Label 1028
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1028);
}

// ABS Label 1029
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}

// ABS Label 1030
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1030);
}

// ABS Label 1031
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}

// ABS Label 1032
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}
sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      testcase( op==OP_IdxGT );  VdbeCoverageIf(v, op==OP_IdxGT );
      testcase( op==OP_IdxGE );  VdbeCoverageIf(v, op==OP_IdxGE );
      testcase( op==OP_IdxLT );  VdbeCoverageIf(v, op==OP_IdxLT );
      testcase( op==OP_IdxLE );  VdbeCoverageIf(v, op==OP_IdxLE );
      
// ABS Label 1036
if(addrSeekScan < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1036);
}
if( addrSeekScan ) { 
// ABS Label 1037
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1037);
}

// ABS Label 1038
if(addrSeekScan < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1038);
}
sqlite3VdbeJumpHere(v, addrSeekScan);
}
    }
    
// ABS Label 1039
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1039);
}
if( regBignull ){
      /* During a NULL-scan, check to see if we have reached the end of
      ** the NULLs */
      assert( bSeekPastNull==!bStopAtNull );
      assert( bSeekPastNull+bStopAtNull==1 );
      assert( nConstraint+bSeekPastNull>0 );
      
// ABS Label 1040
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1040);
}

// ABS Label 1041
if(regBignull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}
sqlite3VdbeAddOp2(v, OP_If, regBignull, sqlite3VdbeCurrentAddr(v)+2);
      VdbeComment((v, "If NULL-scan 1st pass"));
      VdbeCoverage(v);
      op = aEndOp[bRev*2 + bSeekPastNull];
      
// ABS Label 1042
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}

// ABS Label 1043
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}

// ABS Label 1044
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// ABS Label 1045
if(addrNxt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1045);
}

// ABS Label 1046
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1046);
}

// ABS Label 1047
if(nConstraint < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1047);
}

// AOR Label 1048
if(nConstraint - bSeekPastNull != nConstraint + bSeekPastNull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1048);
}
// AOR Label 1049
if(nConstraint / bSeekPastNull != nConstraint + bSeekPastNull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1049);
}
// AOR Label 1050
if(nConstraint * bSeekPastNull != nConstraint + bSeekPastNull)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1050);
}
sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
                           nConstraint+bSeekPastNull);
      testcase( op==OP_IdxGT );  VdbeCoverageIf(v, op==OP_IdxGT );
      testcase( op==OP_IdxGE );  VdbeCoverageIf(v, op==OP_IdxGE );
      testcase( op==OP_IdxLT );  VdbeCoverageIf(v, op==OP_IdxLT );
      testcase( op==OP_IdxLE );  VdbeCoverageIf(v, op==OP_IdxLE );
    }

    
// ROR Label 1051
if(((pLoop->wsFlags & 262144) == 0) != ((pLoop->wsFlags & 262144) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1051);
}
if( (pLoop->wsFlags & WHERE_IN_EARLYOUT)!=0 ){
      
// ABS Label 1052
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}

// ABS Label 1053
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
sqlite3VdbeAddOp3(v, OP_SeekHit, iIdxCur, nEq, nEq);
    }

    /* Seek the table cursor, if required */
    omitTable = (pLoop->wsFlags & WHERE_IDX_ONLY)!=0 
           && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0;
    
// ABS Label 1054
if(omitTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}
if( omitTable ){
      /* pIdx is a covering index.  No need to access the main table. */
    }else { 
// MCC Label 1055
if(( ((pIdx->pTable)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1055);
}
// MCC Label 1056
if(( !(((pIdx->pTable)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1056);
}
if( HasRowid(pIdx->pTable) ){
      
// ABS Label 1057
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}

// ABS Label 1058
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}

// ABS Label 1059
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}

// ABS Label 1060
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}
codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);
    }else { 
// ABS Label 1061
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1061);
}
// ABS Label 1062
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1062);
}

// ROR Label 1063
if((iCur == iIdxCur) != (iCur != iIdxCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1063);
}
if( iCur!=iIdxCur ){
      Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
      iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);
      j = 0;

// ABS Label 1068
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1068);
}

// ROR Label 1069
if((j <= pPk->nKeyCol) != (j < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1069);
}
// ROR Label 1070
if((j > pPk->nKeyCol) != (j < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1070);
}
// ROR Label 1071
if((j >= pPk->nKeyCol) != (j < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1071);
}
for(; j<pPk->nKeyCol; j++){
        k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);
        
// ABS Label 1076
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1076);
}

// ABS Label 1077
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1077);
}

// ABS Label 1078
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1078);
}

// ABS Label 1079
if(iRowidReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1079);
}
// ABS Label 1080
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}

// AOR Label 1081
if(iRowidReg - j != iRowidReg + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1081);
}
// AOR Label 1082
if(iRowidReg / j != iRowidReg + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1082);
}
// AOR Label 1083
if(iRowidReg * j != iRowidReg + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1083);
}
sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, iRowidReg+j);
      };
// ABS Label 1072
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1072);
}

// ROR Label 1073
if((j <= pPk->nKeyCol) != (j < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1073);
}
// ROR Label 1074
if((j > pPk->nKeyCol) != (j < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1074);
}
// ROR Label 1075
if((j >= pPk->nKeyCol) != (j < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1075);
}

      
// ABS Label 1064
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1064);
}

// ABS Label 1065
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1065);
}

// ABS Label 1066
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1066);
}

// ABS Label 1067
if(iRowidReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound, iCur, addrCont,
                           iRowidReg, pPk->nKeyCol); VdbeCoverage(v);
    };}
;}


    
// ABS Label 1084
if(pLevel->iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1084);
}

// ROR Label 1085
if((pLevel->iLeftJoin != 0) != (pLevel->iLeftJoin == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1085);
}
if( pLevel->iLeftJoin==0 ){
      /* If pIdx is an index on one or more expressions, then look through
      ** all the expressions in pWInfo and try to transform matching expressions
      ** into reference to index columns.  Also attempt to translate references
      ** to virtual columns in the table into references to (stored) columns
      ** of the index.
      **
      ** Do not do this for the RHS of a LEFT JOIN. This is because the 
      ** expression may be evaluated after OP_NullRow has been executed on
      ** the cursor. In this case it is important to do the full evaluation,
      ** as the result of the expression may not be NULL, even if all table
      ** column values are.  https://www.sqlite.org/src/info/7fa8049685b50b5a
      **
      ** Also, do not do this when processing one index an a multi-index
      ** OR clause, since the transformation will become invalid once we
      ** move forward to the next index.
      ** https://sqlite.org/src/info/4e8e4857d32d401f
      */
      
// ROR Label 1086
if(((pWInfo->wctrlFlags & 32) != 0) != ((pWInfo->wctrlFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1086);
}
if( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0 ){
        
// ABS Label 1087
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1087);
}

// ABS Label 1088
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}

// ABS Label 1089
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}

// ABS Label 1090
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}
whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo);
      }
  
      /* If a partial index is driving the loop, try to eliminate WHERE clause
      ** terms from the query that must be true due to the WHERE clause of
      ** the partial index.
      **
      ** 2019-11-02 ticket 623eff57e76d45f6: This optimization does not work
      ** for a LEFT JOIN.
      */
      
// ABS Label 1091
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}
if( pIdx->pPartIdxWhere ){
        
// ABS Label 1092
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// ABS Label 1093
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1093);
}

// ABS Label 1094
if(pWC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1094);
}
whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);
      }
    }else{
      testcase( pIdx->pPartIdxWhere );
      /* The following assert() is not a requirement, merely an observation:
      ** The OR-optimization doesn't work for the right hand table of
      ** a LEFT JOIN: */
      assert( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0 );
    }
  
    /* Record the instruction used to terminate the loop. */
    
// ABS Label 1095
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}

// AOR Label 1096
if(pLoop->wsFlags | 4096 != pLoop->wsFlags & 4096)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1096);
}
// AOR Label 1097
if(pLoop->wsFlags ^ 4096 != pLoop->wsFlags & 4096)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1097);
}
if( pLoop->wsFlags & WHERE_ONEROW ){
      pLevel->op = OP_Noop;
    }else { 
// ABS Label 1098
if(bRev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1098);
}
if( bRev ){
      pLevel->op = OP_Prev;
    }else{
      pLevel->op = OP_Next;
    };}

    pLevel->p1 = iIdxCur;
    pLevel->p3 = (pLoop->wsFlags&WHERE_UNQ_WANTED)!=0 ? 1:0;
    
// ROR Label 1099
if(((pLoop->wsFlags & 15) != 0) != ((pLoop->wsFlags & 15) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1099);
}
if( (pLoop->wsFlags & WHERE_CONSTRAINT)==0 ){
      pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;
    }else{
      assert( pLevel->p5==0 );
    }
    
// ABS Label 1100
if(omitTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}
if( omitTable ) { pIdx = 0;
}
  }else {

#ifndef SQLITE_OMIT_OR_OPTIMIZATION
  
// ABS Label 1101
if(pLoop->wsFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}

// AOR Label 1102
if(pLoop->wsFlags | 8192 != pLoop->wsFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1102);
}
// AOR Label 1103
if(pLoop->wsFlags ^ 8192 != pLoop->wsFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1103);
}
if( pLoop->wsFlags & WHERE_MULTI_OR ){
    /* Case 5:  Two or more separately indexed terms connected by OR
    **
    ** Example:
    **
    **   CREATE TABLE t1(a,b,c,d);
    **   CREATE INDEX i1 ON t1(a);
    **   CREATE INDEX i2 ON t1(b);
    **   CREATE INDEX i3 ON t1(c);
    **
    **   SELECT * FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)
    **
    ** In the example, there are three indexed terms connected by OR.
    ** The top of the loop looks like this:
    **
    **          Null       1                # Zero the rowset in reg 1
    **
    ** Then, for each indexed term, the following. The arguments to
    ** RowSetTest are such that the rowid of the current row is inserted
    ** into the RowSet. If it is already present, control skips the
    ** Gosub opcode and jumps straight to the code generated by WhereEnd().
    **
    **        sqlite3WhereBegin(<term>)
    **          RowSetTest                  # Insert rowid into rowset
    **          Gosub      2 A
    **        sqlite3WhereEnd()
    **
    ** Following the above, code to terminate the loop. Label A, the target
    ** of the Gosub above, jumps to the instruction right after the Goto.
    **
    **          Null       1                # Zero the rowset in reg 1
    **          Goto       B                # The loop is finished.
    **
    **       A: <loop body>                 # Return data, whatever.
    **
    **          Return     2                # Jump back to the Gosub
    **
    **       B: <after the loop>
    **
    ** Added 2014-05-26: If the table is a WITHOUT ROWID table, then
    ** use an ephemeral index instead of a RowSet to record the primary
    ** keys of the rows we have already seen.
    **
    */
    WhereClause *pOrWc;    /* The OR-clause broken out into subterms */
    SrcList *pOrTab;       /* Shortened table list or OR-clause generation */
    Index *pCov = 0;             /* Potential covering index (or NULL) */
    int iCovCur = pParse->nTab++;  /* Cursor used for index scans (if any) */

    int regReturn = ++pParse->nMem;           /* Register used with OP_Gosub */
    int regRowset = 0;                        /* Register for RowSet object */
    int regRowid = 0;                         /* Register holding rowid */
    int iLoopBody = sqlite3VdbeMakeLabel(pParse);/* Start of loop body */
    int iRetInit;                             /* Address of regReturn init */
    int untestedTerms = 0;             /* Some terms not completely tested */
    int ii;                            /* Loop counter */
    Expr *pAndExpr = 0;                /* An ".. AND (...)" expression */
    
// ABS Label 1104
if(pTabItem->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}
Table *pTab = pTabItem->pTab;

    pTerm = pLoop->aLTerm[0];
    assert( pTerm!=0 );
    assert( pTerm->eOperator & WO_OR );
    assert( (pTerm->wtFlags & TERM_ORINFO)!=0 );
    pOrWc = &pTerm->u.pOrInfo->wc;
    pLevel->op = OP_Return;
    pLevel->p1 = regReturn;

    /* Set up a new SrcList in pOrTab containing the table being scanned
    ** by this loop in the a[0] slot and all notReady tables in a[1..] slots.
    ** This becomes the SrcList in the recursive call to sqlite3WhereBegin().
    */
    
// ROR Label 1113
if((pWInfo->nLevel <= 1) != (pWInfo->nLevel > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1113);
}
// ROR Label 1114
if((pWInfo->nLevel < 1) != (pWInfo->nLevel > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1114);
}
// ROR Label 1115
if((pWInfo->nLevel >= 1) != (pWInfo->nLevel > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1115);
}
if( pWInfo->nLevel>1 ){
      int nNotReady;                 /* The number of notReady tables */
      SrcItem *origSrc;              /* Original list of tables */
      nNotReady = pWInfo->nLevel - iLevel - 1;
      pOrTab = sqlite3StackAllocRaw(db,
                            sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]));
      
// ABS Label 1116
if(pOrTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1116);
}

// ROR Label 1117
if((pOrTab != 0) != (pOrTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1117);
}
if( pOrTab==0 ) { 
// ABS Label 1118
if(notReady < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1118);
}
return notReady;
}
      pOrTab->nAlloc = (u8)(nNotReady + 1);
      pOrTab->nSrc = pOrTab->nAlloc;
      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
      origSrc = pWInfo->pTabList->a;
      k = 1;

// ABS Label 1119
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1119);
}
// ABS Label 1120
if(nNotReady < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1120);
}

// ROR Label 1121
if((k < nNotReady) != (k <= nNotReady))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1121);
}
// ROR Label 1122
if((k > nNotReady) != (k <= nNotReady))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1122);
}
// ROR Label 1123
if((k >= nNotReady) != (k <= nNotReady))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1123);
}
for(; k<=nNotReady; k++){
        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
      };
// ABS Label 1124
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1124);
}
// ABS Label 1125
if(nNotReady < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1125);
}

// ROR Label 1126
if((k < nNotReady) != (k <= nNotReady))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1126);
}
// ROR Label 1127
if((k > nNotReady) != (k <= nNotReady))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1127);
}
// ROR Label 1128
if((k >= nNotReady) != (k <= nNotReady))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1128);
}

    }else{
      pOrTab = pWInfo->pTabList;
    }

    /* Initialize the rowset register to contain NULL. An SQL NULL is 
    ** equivalent to an empty rowset.  Or, create an ephemeral index
    ** capable of holding primary keys in the case of a WITHOUT ROWID.
    **
    ** Also initialize regReturn to contain the address of the instruction 
    ** immediately following the OP_Return at the bottom of the loop. This
    ** is required in a few obscure LEFT JOIN cases where control jumps
    ** over the top of the loop into the body of it. In this case the 
    ** correct response for the end-of-loop code (the OP_Return) is to 
    ** fall through to the next instruction, just as an OP_Next does if
    ** called on an uninitialized cursor.
    */
    
// ROR Label 1129
if(((pWInfo->wctrlFlags & 16) != 0) != ((pWInfo->wctrlFlags & 16) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1129);
}
if( (pWInfo->wctrlFlags & WHERE_DUPLICATES_OK)==0 ){
      
// MCC Label 1130
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1130);
}
// MCC Label 1131
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1131);
}
if( HasRowid(pTab) ){
        regRowset = ++pParse->nMem;
        
// ABS Label 1132
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1132);
}

// ABS Label 1133
if(regRowset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1133);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regRowset);
      }else{
        Index *pPk = sqlite3PrimaryKeyIndex(pTab);
        regRowset = pParse->nTab++;
        
// ABS Label 1134
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}

// ABS Label 1135
if(regRowset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1135);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, regRowset, pPk->nKeyCol);
        
// ABS Label 1136
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1136);
}

// ABS Label 1137
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1137);
}
sqlite3VdbeSetP4KeyInfo(pParse, pPk);
      }
      regRowid = ++pParse->nMem;
    }
    iRetInit = sqlite3VdbeAddOp2(v, OP_Integer, 0, regReturn);

    /* If the original WHERE clause is z of the form:  (x1 OR x2 OR ...) AND y
    ** Then for every term xN, evaluate as the subexpression: xN AND z
    ** That way, terms in y that are factored into the disjunction will
    ** be picked up by the recursive calls to sqlite3WhereBegin() below.
    **
    ** Actually, each subexpression is converted to "xN AND w" where w is
    ** the "interesting" terms of z - terms that did not originate in the
    ** ON or USING clause of a LEFT JOIN, and terms that are usable as 
    ** indices.
    **
    ** This optimization also only applies if the (x1 OR x2 OR ...) term
    ** is not contained in the ON clause of a LEFT JOIN.
    ** See ticket http://www.sqlite.org/src/info/f2369304e4
    */
    
// ABS Label 1138
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1138);
}

// ROR Label 1139
if((pWC->nTerm <= 1) != (pWC->nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1139);
}
// ROR Label 1140
if((pWC->nTerm < 1) != (pWC->nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1140);
}
// ROR Label 1141
if((pWC->nTerm >= 1) != (pWC->nTerm > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1141);
}
if( pWC->nTerm>1 ){
      int iTerm;
      iTerm = 0;

// ABS Label 1142
if(iTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1142);
}
// ABS Label 1143
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1143);
}

// ROR Label 1144
if((iTerm <= pWC->nTerm) != (iTerm < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1144);
}
// ROR Label 1145
if((iTerm > pWC->nTerm) != (iTerm < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1145);
}
// ROR Label 1146
if((iTerm >= pWC->nTerm) != (iTerm < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1146);
}
for(; iTerm<pWC->nTerm; iTerm++){
        
// ABS Label 1152
if(pWC->a[iTerm].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}
Expr *pExpr = pWC->a[iTerm].pExpr;
        
// ABS Label 1153
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1153);
}

// ROR Label 1154
if((&pWC->a[iTerm] != pTerm) != (&pWC->a[iTerm] == pTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1154);
}
if( &pWC->a[iTerm] == pTerm ) { continue;
}
        testcase( pWC->a[iTerm].wtFlags & TERM_VIRTUAL );
        testcase( pWC->a[iTerm].wtFlags & TERM_CODED );
        
// ROR Label 1155
if(((pWC->a[iTerm].wtFlags & (2 | 4)) == 0) != ((pWC->a[iTerm].wtFlags & (2 | 4)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1155);
}
if( (pWC->a[iTerm].wtFlags & (TERM_VIRTUAL|TERM_CODED))!=0 ) { continue;
}
        
// ROR Label 1156
if(((pWC->a[iTerm].eOperator & 8191) != 0) != ((pWC->a[iTerm].eOperator & 8191) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1156);
}
if( (pWC->a[iTerm].eOperator & WO_ALL)==0 ) { continue;
}
        testcase( pWC->a[iTerm].wtFlags & TERM_ORINFO );
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
      };
// ABS Label 1147
if(iTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1147);
}
// ABS Label 1148
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1148);
}

// ROR Label 1149
if((iTerm <= pWC->nTerm) != (iTerm < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1149);
}
// ROR Label 1150
if((iTerm > pWC->nTerm) != (iTerm < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1150);
}
// ROR Label 1151
if((iTerm >= pWC->nTerm) != (iTerm < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1151);
}

      
// ABS Label 1157
if(pAndExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}
if( pAndExpr ){
        /* The extra 0x10000 bit on the opcode is masked off and does not
        ** become part of the new Expr.op.  However, it does make the
        ** op==TK_AND comparison inside of sqlite3PExpr() false, and this
        ** prevents sqlite3PExpr() from applying the AND short-circuit 
        ** optimization, which we do not want here. */
        pAndExpr = sqlite3PExpr(pParse, TK_AND|0x10000, 0, pAndExpr);
      }
    }

    /* Run a separate WHERE clause for each term of the OR clause.  After
    ** eliminating duplicates from other WHERE clauses, the action for each
    ** sub-WHERE clause is to to invoke the main loop body as a subroutine.
    */
    ExplainQueryPlan((pParse, 1, "MULTI-INDEX OR"));
    ii = 0;

// ABS Label 1158
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1158);
}
// ABS Label 1159
if(pOrWc->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1159);
}

// ROR Label 1160
if((ii <= pOrWc->nTerm) != (ii < pOrWc->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1160);
}
// ROR Label 1161
if((ii > pOrWc->nTerm) != (ii < pOrWc->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1161);
}
// ROR Label 1162
if((ii >= pOrWc->nTerm) != (ii < pOrWc->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1162);
}
for(; ii<pOrWc->nTerm; ii++){
      WhereTerm *pOrTerm = &pOrWc->a[ii];
      
// ABS Label 1168
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1168);
}
// ABS Label 1169
if(pOrTerm->leftCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1169);
}

// COR Label 1170
if((pOrTerm->leftCursor == iCur && (pOrTerm->eOperator & 1024) != 0) != (pOrTerm->leftCursor == iCur || (pOrTerm->eOperator & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1170);
}

// ROR Label 1171
if((pOrTerm->leftCursor != iCur) != (pOrTerm->leftCursor == iCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1171);
}
// ROR Label 1172
if(((pOrTerm->eOperator & 1024) == 0) != ((pOrTerm->eOperator & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1172);
}

// MCC Label 1173
if(pOrTerm->leftCursor == iCur && (pOrTerm->eOperator & 1024) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1173);
}
// MCC Label 1174
if(pOrTerm->leftCursor == iCur && !((pOrTerm->eOperator & 1024) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1174);
}
// MCC Label 1175
if(!(pOrTerm->leftCursor == iCur) && (pOrTerm->eOperator & 1024) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1175);
}
// MCC Label 1176
if(!(pOrTerm->leftCursor == iCur) && !((pOrTerm->eOperator & 1024) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1176);
}
if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & WO_AND)!=0 ){
        WhereInfo *pSubWInfo;           /* Info for single OR-term scan */
        
// ABS Label 1177
if(pOrTerm->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1177);
}
Expr *pOrExpr = pOrTerm->pExpr; /* Current OR clause term */
        Expr *pDelete;                  /* Local copy of OR clause term */
        int jmp1 = 0;                   /* Address of jump operation */
        testcase( (pTabItem[0].fg.jointype & JT_LEFT)!=0
               && !ExprHasProperty(pOrExpr, EP_FromJoin)
        ); /* See TH3 vtab25.400 and ticket 614b25314c766238 */
        pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);
        
// ABS Label 1185
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}
if( db->mallocFailed ){
          
// ABS Label 1186
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1186);
}

// ABS Label 1187
if(pDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}
sqlite3ExprDelete(db, pDelete);
          continue;
        }
        
// ABS Label 1188
if(pAndExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1188);
}
if( pAndExpr ){
          pAndExpr->pLeft = pOrExpr;
          pOrExpr = pAndExpr;
        }
        /* Loop through table entries that match term pOrTerm. */
        ExplainQueryPlan((pParse, 1, "INDEX %d", ii+1));
        WHERETRACE(0xffff, ("Subplan for OR-clause:\n"));
        pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0,
                                      WHERE_OR_SUBCLAUSE, iCovCur);
        assert( pSubWInfo || pParse->nErr || db->mallocFailed );
        
// ABS Label 1189
if(pSubWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1189);
}
if( pSubWInfo ){
          WhereLoop *pSubLoop;
          int addrExplain = sqlite3WhereExplainOneScan(
              pParse, pOrTab, &pSubWInfo->a[0], 0
          );
          sqlite3WhereAddScanStatus(v, pOrTab, &pSubWInfo->a[0], addrExplain);

          /* This is the sub-WHERE clause body.  First skip over
          ** duplicate rows from prior sub-WHERE clauses, and record the
          ** rowid (or PRIMARY KEY) for the current row so that the same
          ** row will be skipped in subsequent sub-WHERE clauses.
          */
          
// ROR Label 1195
if(((pWInfo->wctrlFlags & 16) != 0) != ((pWInfo->wctrlFlags & 16) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1195);
}
if( (pWInfo->wctrlFlags & WHERE_DUPLICATES_OK)==0 ){
            int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);
            
// MCC Label 1196
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1196);
}
// MCC Label 1197
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1197);
}
if( HasRowid(pTab) ){
              
// ABS Label 1198
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1198);
}

// ABS Label 1199
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}

// ABS Label 1200
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1200);
}

// ABS Label 1201
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1201);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);
              jmp1 = sqlite3VdbeAddOp4Int(v, OP_RowSetTest, regRowset, 0,
                                          regRowid, iSet);
              VdbeCoverage(v);
            }else{
              Index *pPk = sqlite3PrimaryKeyIndex(pTab);
              int nPk = pPk->nKeyCol;
              int iPk;
              int r;

              /* Read the PK into an array of temp registers. */
              r = sqlite3GetTempRange(pParse, nPk);
              iPk = 0;

// ABS Label 1205
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1205);
}
// ABS Label 1206
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1206);
}

// ROR Label 1207
if((iPk <= nPk) != (iPk < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1207);
}
// ROR Label 1208
if((iPk > nPk) != (iPk < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1208);
}
// ROR Label 1209
if((iPk >= nPk) != (iPk < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1209);
}
for(; iPk<nPk; iPk++){
                int iCol = pPk->aiColumn[iPk];
                
// ABS Label 1215
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1215);
}

// ABS Label 1216
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1216);
}

// ABS Label 1217
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1217);
}

// ABS Label 1218
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1218);
}

// ABS Label 1219
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1219);
}
// ABS Label 1220
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1220);
}

// AOR Label 1221
if(r - iPk != r + iPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1221);
}
// AOR Label 1222
if(r / iPk != r + iPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1222);
}
// AOR Label 1223
if(r * iPk != r + iPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1223);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol,r+iPk);
              };
// ABS Label 1210
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1210);
}
// ABS Label 1211
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1211);
}

// ROR Label 1212
if((iPk <= nPk) != (iPk < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1212);
}
// ROR Label 1213
if((iPk > nPk) != (iPk < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1213);
}
// ROR Label 1214
if((iPk >= nPk) != (iPk < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1214);
}


              /* Check if the temp table already contains this key. If so,
              ** the row has already been included in the result set and
              ** can be ignored (by jumping past the Gosub below). Otherwise,
              ** insert the key into the temp table and proceed with processing
              ** the row.
              **
              ** Use some of the same optimizations as OP_RowSetTest: If iSet
              ** is zero, assume that the key cannot already be present in
              ** the temp table. And if iSet is -1, assume that there is no 
              ** need to insert the key into the temp table, as it will never 
              ** be tested for.  */ 
              
// ABS Label 1224
if(iSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1224);
}
if( iSet ){
                jmp1 = sqlite3VdbeAddOp4Int(v, OP_Found, regRowset, 0, r, nPk);
                VdbeCoverage(v);
              }
              
// ABS Label 1225
if(iSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1225);
}

// ROR Label 1226
if((iSet < 0) != (iSet >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1226);
}
// ROR Label 1227
if((iSet > 0) != (iSet >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1227);
}
// ROR Label 1228
if((iSet <= 0) != (iSet >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1228);
}
if( iSet>=0 ){
                
// ABS Label 1229
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1229);
}

// ABS Label 1230
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1230);
}

// ABS Label 1231
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1231);
}

// ABS Label 1232
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1232);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, r, nPk, regRowid);
                
// ABS Label 1233
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1233);
}

// ABS Label 1234
if(regRowset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1234);
}

// ABS Label 1235
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1235);
}

// ABS Label 1236
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1236);
}

// ABS Label 1237
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1237);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, regRowset, regRowid,
                                     r, nPk);
                
// ABS Label 1238
if(iSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1238);
}
if( iSet ) { 
// ABS Label 1239
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1239);
}
sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
}
              }

              /* Release the array of temp registers */
              
// ABS Label 1202
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1202);
}

// ABS Label 1203
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1203);
}

// ABS Label 1204
if(nPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1204);
}
sqlite3ReleaseTempRange(pParse, r, nPk);
            }
          }

          /* Invoke the main loop body as a subroutine */
          
// ABS Label 1190
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}

// ABS Label 1191
if(regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}

// ABS Label 1192
if(iLoopBody < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1192);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regReturn, iLoopBody);

          /* Jump here (skipping the main loop body subroutine) if the
          ** current sub-WHERE row is a duplicate from prior sub-WHEREs. */
          
// ABS Label 1240
if(jmp1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1240);
}
if( jmp1 ) { 
// ABS Label 1241
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1241);
}

// ABS Label 1242
if(jmp1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1242);
}
sqlite3VdbeJumpHere(v, jmp1);
}

          /* The pSubWInfo->untestedTerms flag means that this OR term
          ** contained one or more AND term from a notReady table.  The
          ** terms from the notReady table could not be tested and will
          ** need to be tested later.
          */
          
// ABS Label 1243
if(pSubWInfo->untestedTerms < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1243);
}
if( pSubWInfo->untestedTerms ) { untestedTerms = 1;
}

          /* If all of the OR-connected terms are optimized using the same
          ** index, and the index is opened using the same cursor number
          ** by each call to sqlite3WhereBegin() made by this loop, it may
          ** be possible to use that index as a covering index.
          **
          ** If the call to sqlite3WhereBegin() above resulted in a scan that
          ** uses an index, and this is either the first OR-connected term
          ** processed or the index is the same as that used by all previous
          ** terms, set pCov to the candidate covering index. Otherwise, set 
          ** pCov to NULL to indicate that no candidate covering index will 
          ** be available.
          */
          pSubLoop = pSubWInfo->a[0].pWLoop;
          assert( (pSubLoop->wsFlags & WHERE_AUTO_INDEX)==0 );
          
// COR Label 1244
if(((pSubLoop->wsFlags & 512) != 0 && (ii == 0 || pSubLoop->u.btree.pIndex == pCov) || ((((pTab)->tabFlags & 128) == 0) || !((pSubLoop->u.btree.pIndex)->idxType == 2))) != ((pSubLoop->wsFlags & 512) != 0 && (ii == 0 || pSubLoop->u.btree.pIndex == pCov) && ((((pTab)->tabFlags & 128) == 0) || !((pSubLoop->u.btree.pIndex)->idxType == 2))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1244);
}
// COR Label 1245
if(((pSubLoop->wsFlags & 512) != 0 || (ii == 0 || pSubLoop->u.btree.pIndex == pCov)) != ((pSubLoop->wsFlags & 512) != 0 && (ii == 0 || pSubLoop->u.btree.pIndex == pCov)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1245);
}

// ROR Label 1246
if(((pSubLoop->wsFlags & 512) == 0) != ((pSubLoop->wsFlags & 512) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1246);
}

// MCC Label 1247
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1247);
}
// MCC Label 1248
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1248);
}
// MCC Label 1249
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1249);
}
// MCC Label 1250
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1250);
}
// MCC Label 1251
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1251);
}
// MCC Label 1252
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1252);
}
// MCC Label 1253
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1253);
}
// MCC Label 1254
if((pSubLoop->wsFlags & 512) != 0 && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1254);
}
// MCC Label 1255
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1255);
}
// MCC Label 1256
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1256);
}
// MCC Label 1257
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1257);
}
// MCC Label 1258
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1258);
}
// MCC Label 1259
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1259);
}
// MCC Label 1260
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1260);
}
// MCC Label 1261
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1261);
}
// MCC Label 1262
if((pSubLoop->wsFlags & 512) != 0 && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1262);
}
// MCC Label 1263
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1263);
}
// MCC Label 1264
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1264);
}
// MCC Label 1265
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1265);
}
// MCC Label 1266
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1266);
}
// MCC Label 1267
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1267);
}
// MCC Label 1268
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1268);
}
// MCC Label 1269
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1269);
}
// MCC Label 1270
if(!((pSubLoop->wsFlags & 512) != 0) && ( ii == 0 && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1270);
}
// MCC Label 1271
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1271);
}
// MCC Label 1272
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1272);
}
// MCC Label 1273
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1273);
}
// MCC Label 1274
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && pSubLoop->u.btree.pIndex == pCov ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1274);
}
// MCC Label 1275
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1275);
}
// MCC Label 1276
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( ((pTab)->tabFlags & 128) == 0 ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1276);
}
// MCC Label 1277
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !((pSubLoop->u.btree.pIndex)->idxType == 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1277);
}
// MCC Label 1278
if(!((pSubLoop->wsFlags & 512) != 0) && ( !(ii == 0) && !(pSubLoop->u.btree.pIndex == pCov) ) && ( ( !(((pTab)->tabFlags & 128) == 0) ) && !(!((pSubLoop->u.btree.pIndex)->idxType == 2)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1278);
}
if( (pSubLoop->wsFlags & WHERE_INDEXED)!=0
           && (ii==0 || pSubLoop->u.btree.pIndex==pCov)
           && (HasRowid(pTab) || !IsPrimaryKeyIndex(pSubLoop->u.btree.pIndex))
          ){
            assert( pSubWInfo->a[0].iIdxCur==iCovCur );
            pCov = pSubLoop->u.btree.pIndex;
          }else{
            pCov = 0;
          }
          if( sqlite3WhereUsesDeferredSeek(pSubWInfo) ){
            pWInfo->bDeferredSeek = 1;
          }

          /* Finish the loop through table entries that match term pOrTerm. */
          
// ABS Label 1193
if(pSubWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1193);
}
sqlite3WhereEnd(pSubWInfo);
          ExplainQueryPlanPop(pParse);
        }
        
// ABS Label 1183
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1183);
}

// ABS Label 1184
if(pDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1184);
}
sqlite3ExprDelete(db, pDelete);
      }
    };
// ABS Label 1163
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}
// ABS Label 1164
if(pOrWc->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1164);
}

// ROR Label 1165
if((ii <= pOrWc->nTerm) != (ii < pOrWc->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1165);
}
// ROR Label 1166
if((ii > pOrWc->nTerm) != (ii < pOrWc->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1166);
}
// ROR Label 1167
if((ii >= pOrWc->nTerm) != (ii < pOrWc->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1167);
}

    ExplainQueryPlanPop(pParse);
    pLevel->u.pCovidx = pCov;
    
// ABS Label 1279
if(pCov < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1279);
}
if( pCov ) { pLevel->iIdxCur = iCovCur;
}
    
// ABS Label 1280
if(pAndExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1280);
}
if( pAndExpr ){
      pAndExpr->pLeft = 0;
      
// ABS Label 1281
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1281);
}

// ABS Label 1282
if(pAndExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1282);
}
sqlite3ExprDelete(db, pAndExpr);
    }
    
// ABS Label 1107
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1107);
}

// ABS Label 1108
if(iRetInit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1108);
}
sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
    
// ABS Label 1109
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1109);
}

// ABS Label 1110
if(pLevel->addrBrk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1110);
}
sqlite3VdbeGoto(v, pLevel->addrBrk);
    
// ABS Label 1111
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1111);
}

// ABS Label 1112
if(iLoopBody < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1112);
}
sqlite3VdbeResolveLabel(v, iLoopBody);

    
// ROR Label 1283
if((pWInfo->nLevel <= 1) != (pWInfo->nLevel > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1283);
}
// ROR Label 1284
if((pWInfo->nLevel < 1) != (pWInfo->nLevel > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1284);
}
// ROR Label 1285
if((pWInfo->nLevel >= 1) != (pWInfo->nLevel > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1285);
}
if( pWInfo->nLevel>1 ){ sqlite3StackFree(db, pOrTab); }
    if( !untestedTerms ) { 
// ABS Label 1287
if(pLevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1287);
}

// ABS Label 1288
if(pTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1288);
}
disableTerm(pLevel, pTerm);
}
  }else
#endif /* SQLITE_OMIT_OR_OPTIMIZATION */

  {
    /* Case 6:  There is no usable index.  We must do a complete
    **          scan of the entire table.
    */
    static const u8 aStep[] = { OP_Next, OP_Prev };
    static const u8 aStart[] = { OP_Rewind, OP_Last };
    assert( bRev==0 || bRev==1 );
    
// ABS Label 1289
if(pTabItem->fg.isRecursive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1289);
}
if( pTabItem->fg.isRecursive ){
      /* Tables marked isRecursive have only a single row that is stored in
      ** a pseudo-cursor.  No need to Rewind or Next such cursors. */
      pLevel->op = OP_Noop;
    }else{
      codeCursorHint(pTabItem, pWInfo, pLevel, 0);
      pLevel->op = aStep[bRev];
      pLevel->p1 = iCur;
      pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrHalt);
      VdbeCoverageIf(v, bRev==0);
      VdbeCoverageIf(v, bRev!=0);
      pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;
    }
  };}
;}
;}
;}
;}


#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
  pLevel->addrVisit = sqlite3VdbeCurrentAddr(v);
#endif

  /* Insert code to test every subexpression that can be completely
  ** computed using the current set of tables.
  **
  ** This loop may run between one and three times, depending on the
  ** constraints to be generated. The value of stack variable iLoop
  ** determines the constraints coded by each iteration, as follows:
  **
  ** iLoop==1: Code only expressions that are entirely covered by pIdx.
  ** iLoop==2: Code remaining expressions that do not contain correlated
  **           sub-queries.  
  ** iLoop==3: Code all remaining expressions.
  **
  ** An effort is made to skip unnecessary iterations of the loop.
  */
  iLoop = (pIdx ? 1 : 2);
  
// ABS Label 1290
if(iLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1290);
}

// ROR Label 1291
if((iLoop <= 0) != (iLoop > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1291);
}
// ROR Label 1292
if((iLoop < 0) != (iLoop > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1292);
}
// ROR Label 1293
if((iLoop >= 0) != (iLoop > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1293);
}
do{
    int iNext = 0;                /* Next value for iLoop */
    pTerm = pWC->a , j = pWC->nTerm;

// ABS Label 1298
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1298);
}

// ROR Label 1299
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1299);
}
// ROR Label 1300
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1300);
}
// ROR Label 1301
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1301);
}
for(; j>0; j--, pTerm++){
      Expr *pE;
      int skipLikeAddr = 0;
      testcase( pTerm->wtFlags & TERM_VIRTUAL );
      testcase( pTerm->wtFlags & TERM_CODED );
      
// AOR Label 1309
if(pTerm->wtFlags | (2 | 4) != pTerm->wtFlags & (2 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1309);
}
// AOR Label 1310
if(pTerm->wtFlags ^ (2 | 4) != pTerm->wtFlags & (2 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1310);
}
if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) { continue;
}
      
// ROR Label 1311
if(((pTerm->prereqAll & pLevel->notReady) == 0) != ((pTerm->prereqAll & pLevel->notReady) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1311);
}
if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
        testcase( pWInfo->untestedTerms==0
            && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)!=0 );
        pWInfo->untestedTerms = 1;
        continue;
      }
      pE = pTerm->pExpr;
      assert( pE!=0 );
      
// COR Label 1312
if(((pTabItem->fg.jointype & 8) || !(((pE)->flags & (1)) != 0)) != ((pTabItem->fg.jointype & 8) && !(((pE)->flags & (1)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1312);
}

// MCC Label 1313
if(( pTabItem->fg.jointype & 8 ) && !(((pE)->flags & (1)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1313);
}
// MCC Label 1314
if(( pTabItem->fg.jointype & 8 ) && !(!(((pE)->flags & (1)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1314);
}
// MCC Label 1315
if(( !(pTabItem->fg.jointype & 8) ) && !(((pE)->flags & (1)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1315);
}
// MCC Label 1316
if(( !(pTabItem->fg.jointype & 8) ) && !(!(((pE)->flags & (1)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1316);
}
if( (pTabItem->fg.jointype&JT_LEFT) && !ExprHasProperty(pE,EP_FromJoin) ){
        continue;
      }
      
      if( iLoop==1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx) ){
        iNext = 2;
        continue;
      }
      
// ABS Label 1317
if(iLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1317);
}

// COR Label 1318
if((iLoop < 3 || (pTerm->wtFlags & 4096)) != (iLoop < 3 && (pTerm->wtFlags & 4096)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1318);
}

// ROR Label 1319
if((iLoop <= 3) != (iLoop < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1319);
}
// ROR Label 1320
if((iLoop > 3) != (iLoop < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1320);
}
// ROR Label 1321
if((iLoop >= 3) != (iLoop < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1321);
}

// MCC Label 1322
if(iLoop < 3 && ( pTerm->wtFlags & 4096 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1322);
}
// MCC Label 1323
if(iLoop < 3 && ( !(pTerm->wtFlags & 4096) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1323);
}
// MCC Label 1324
if(!(iLoop < 3) && ( pTerm->wtFlags & 4096 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1324);
}
// MCC Label 1325
if(!(iLoop < 3) && ( !(pTerm->wtFlags & 4096) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1325);
}
if( iLoop<3 && (pTerm->wtFlags & TERM_VARSELECT) ){
        
// ABS Label 1326
if(iNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1326);
}

// ROR Label 1327
if((iNext != 0) != (iNext == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1327);
}
if( iNext==0 ) { iNext = 3;
}
        continue;
      }

      
// ROR Label 1328
if(((pTerm->wtFlags & 512) == 0) != ((pTerm->wtFlags & 512) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1328);
}
if( (pTerm->wtFlags & TERM_LIKECOND)!=0 ){
        /* If the TERM_LIKECOND flag is set, that means that the range search
        ** is sufficient to guarantee that the LIKE operator is true, so we
        ** can skip the call to the like(A,B) function.  But this only works
        ** for strings.  So do not skip the call to the function on the pass
        ** that compares BLOBs. */
#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
        continue;
#else
        
// ABS Label 1329
if(pLevel->iLikeRepCntr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1329);
}
u32 x = pLevel->iLikeRepCntr;
        
// ABS Label 1330
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1330);
}

// ROR Label 1331
if((x <= 0) != (x > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1331);
}
// ROR Label 1332
if((x < 0) != (x > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1332);
}
// ROR Label 1333
if((x >= 0) != (x > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1333);
}
if( x>0 ){
          skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?OP_IfNot:OP_If,(int)(x>>1));
          VdbeCoverageIf(v, (x&1)==1);
          VdbeCoverageIf(v, (x&1)==0);
        }
#endif
      }
#ifdef WHERETRACE_ENABLED /* 0xffff */
      if( sqlite3WhereTrace ){
        VdbeNoopComment((v, "WhereTerm[%d] (%p) priority=%d",
                         pWC->nTerm-j, pTerm, iLoop));
      }
      if( sqlite3WhereTrace & 0x800 ){
        sqlite3DebugPrintf("Coding auxiliary constraint:\n");
        sqlite3WhereTermPrint(pTerm, pWC->nTerm-j);
      }
#endif
      
// ABS Label 1306
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1306);
}

// ABS Label 1307
if(pE < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1307);
}

// ABS Label 1308
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1308);
}
sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);
      
// ABS Label 1334
if(skipLikeAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1334);
}
if( skipLikeAddr ) { 
// ABS Label 1335
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1335);
}

// ABS Label 1336
if(skipLikeAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1336);
}
sqlite3VdbeJumpHere(v, skipLikeAddr);
}
      pTerm->wtFlags |= TERM_CODED;
    };
// ABS Label 1302
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1302);
}

// ROR Label 1303
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1303);
}
// ROR Label 1304
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1304);
}
// ROR Label 1305
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1305);
}

    iLoop = iNext;
  }while( iLoop>0 );
// ABS Label 1294
if(iLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1294);
}

// ROR Label 1295
if((iLoop <= 0) != (iLoop > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1295);
}
// ROR Label 1296
if((iLoop < 0) != (iLoop > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1296);
}
// ROR Label 1297
if((iLoop >= 0) != (iLoop > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1297);
}
;

  /* Insert code to test for implied constraints based on transitivity
  ** of the "==" operator.
  **
  ** Example: If the WHERE clause contains "t1.a=t2.b" and "t2.b=123"
  ** and we are coding the t1 loop and the t2 loop has not yet coded,
  ** then we cannot use the "t1.a=t2.b" constraint, but we can code
  ** the implied "t1.a=123" constraint.
  */
  pTerm = pWC->a , j = pWC->nTerm;

// ABS Label 1337
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1337);
}

// ROR Label 1338
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1338);
}
// ROR Label 1339
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1339);
}
// ROR Label 1340
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1340);
}
for(; j>0; j--, pTerm++){
    Expr *pE, sEAlt;
    WhereTerm *pAlt;
    
// AOR Label 1347
if(pTerm->wtFlags | (2 | 4) != pTerm->wtFlags & (2 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1347);
}
// AOR Label 1348
if(pTerm->wtFlags ^ (2 | 4) != pTerm->wtFlags & (2 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1348);
}
if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) { continue;
}
    
// ROR Label 1349
if(((pTerm->eOperator & (2 | 128)) != 0) != ((pTerm->eOperator & (2 | 128)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1349);
}
if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) { continue;
}
    
// ROR Label 1350
if(((pTerm->eOperator & 2048) != 0) != ((pTerm->eOperator & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1350);
}
if( (pTerm->eOperator & WO_EQUIV)==0 ) { continue;
}
    
// ABS Label 1351
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1351);
}
// ABS Label 1352
if(pTerm->leftCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}

// ROR Label 1353
if((pTerm->leftCursor == iCur) != (pTerm->leftCursor != iCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1353);
}
if( pTerm->leftCursor!=iCur ) { continue;
}
    
// AOR Label 1354
if(pTabItem->fg.jointype | 8 != pTabItem->fg.jointype & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1354);
}
// AOR Label 1355
if(pTabItem->fg.jointype ^ 8 != pTabItem->fg.jointype & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1355);
}
if( pTabItem->fg.jointype & JT_LEFT ) { continue;
}
    pE = pTerm->pExpr;
#ifdef WHERETRACE_ENABLED /* 0x800 */
    if( sqlite3WhereTrace & 0x800 ){
      sqlite3DebugPrintf("Coding transitive constraint:\n");
      sqlite3WhereTermPrint(pTerm, pWC->nTerm-j);
    }
#endif
    assert( !ExprHasProperty(pE, EP_FromJoin) );
    assert( (pTerm->prereqRight & pLevel->notReady)!=0 );
    pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady,
                    WO_EQ|WO_IN|WO_IS, 0);
    
// ABS Label 1356
if(pAlt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1356);
}

// ROR Label 1357
if((pAlt != 0) != (pAlt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1357);
}
if( pAlt==0 ) { continue;
}
    
// AOR Label 1358
if(pAlt->wtFlags | (4) != pAlt->wtFlags & (4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1358);
}
// AOR Label 1359
if(pAlt->wtFlags ^ (4) != pAlt->wtFlags & (4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1359);
}
if( pAlt->wtFlags & (TERM_CODED) ) { continue;
}
    
// COR Label 1360
if(((pAlt->eOperator & 1) && (pAlt->pExpr->flags & 2048) || (pAlt->pExpr->x.pSelect->pEList->nExpr > 1)) != ((pAlt->eOperator & 1) && (pAlt->pExpr->flags & 2048) && (pAlt->pExpr->x.pSelect->pEList->nExpr > 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1360);
}
// COR Label 1361
if(((pAlt->eOperator & 1) || (pAlt->pExpr->flags & 2048)) != ((pAlt->eOperator & 1) && (pAlt->pExpr->flags & 2048)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1361);
}

// MCC Label 1362
if(( pAlt->eOperator & 1 ) && ( pAlt->pExpr->flags & 2048 ) && ( pAlt->pExpr->x.pSelect->pEList->nExpr > 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1362);
}
// MCC Label 1363
if(( pAlt->eOperator & 1 ) && ( pAlt->pExpr->flags & 2048 ) && ( !(pAlt->pExpr->x.pSelect->pEList->nExpr > 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1363);
}
// MCC Label 1364
if(( pAlt->eOperator & 1 ) && ( !(pAlt->pExpr->flags & 2048) ) && ( pAlt->pExpr->x.pSelect->pEList->nExpr > 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1364);
}
// MCC Label 1365
if(( pAlt->eOperator & 1 ) && ( !(pAlt->pExpr->flags & 2048) ) && ( !(pAlt->pExpr->x.pSelect->pEList->nExpr > 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1365);
}
// MCC Label 1366
if(( !(pAlt->eOperator & 1) ) && ( pAlt->pExpr->flags & 2048 ) && ( pAlt->pExpr->x.pSelect->pEList->nExpr > 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1366);
}
// MCC Label 1367
if(( !(pAlt->eOperator & 1) ) && ( pAlt->pExpr->flags & 2048 ) && ( !(pAlt->pExpr->x.pSelect->pEList->nExpr > 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1367);
}
// MCC Label 1368
if(( !(pAlt->eOperator & 1) ) && ( !(pAlt->pExpr->flags & 2048) ) && ( pAlt->pExpr->x.pSelect->pEList->nExpr > 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1368);
}
// MCC Label 1369
if(( !(pAlt->eOperator & 1) ) && ( !(pAlt->pExpr->flags & 2048) ) && ( !(pAlt->pExpr->x.pSelect->pEList->nExpr > 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1369);
}
if( (pAlt->eOperator & WO_IN) 
     && (pAlt->pExpr->flags & EP_xIsSelect)
     && (pAlt->pExpr->x.pSelect->pEList->nExpr>1)
    ){
      continue;
    }
    testcase( pAlt->eOperator & WO_EQ );
    testcase( pAlt->eOperator & WO_IS );
    testcase( pAlt->eOperator & WO_IN );
    VdbeModuleComment((v, "begin transitive constraint"));
    sEAlt = *pAlt->pExpr;
    sEAlt.pLeft = pE->pLeft;
    
// ABS Label 1345
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1345);
}

// ABS Label 1346
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1346);
}
sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, SQLITE_JUMPIFNULL);
    pAlt->wtFlags |= TERM_CODED;
  };
// ABS Label 1341
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1341);
}

// ROR Label 1342
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1342);
}
// ROR Label 1343
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1343);
}
// ROR Label 1344
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1344);
}


  /* For a LEFT OUTER JOIN, generate code that will record the fact that
  ** at least one row of the right table has matched the left table.  
  */
  
// ABS Label 1370
if(pLevel->iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1370);
}
if( pLevel->iLeftJoin ){
    pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);
    
// ABS Label 1371
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1371);
}

// ABS Label 1372
if(pLevel->iLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1372);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, pLevel->iLeftJoin);
    VdbeComment((v, "record LEFT JOIN hit"));
    pTerm = pWC->a , j = 0;

// ABS Label 1373
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1373);
}
// ABS Label 1374
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1374);
}

// ROR Label 1375
if((j <= pWC->nTerm) != (j < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1375);
}
// ROR Label 1376
if((j > pWC->nTerm) != (j < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1376);
}
// ROR Label 1377
if((j >= pWC->nTerm) != (j < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1377);
}
for(; j<pWC->nTerm; j++, pTerm++){
      testcase( pTerm->wtFlags & TERM_VIRTUAL );
      testcase( pTerm->wtFlags & TERM_CODED );
      
// AOR Label 1386
if(pTerm->wtFlags | (2 | 4) != pTerm->wtFlags & (2 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1386);
}
// AOR Label 1387
if(pTerm->wtFlags ^ (2 | 4) != pTerm->wtFlags & (2 | 4))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1387);
}
if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) { continue;
}
      
// ROR Label 1388
if(((pTerm->prereqAll & pLevel->notReady) == 0) != ((pTerm->prereqAll & pLevel->notReady) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1388);
}
if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
        assert( pWInfo->untestedTerms );
        continue;
      }
      assert( pTerm->pExpr );
      
// ABS Label 1383
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1383);
}

// ABS Label 1384
if(pTerm->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1384);
}

// ABS Label 1385
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1385);
}
sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, SQLITE_JUMPIFNULL);
      pTerm->wtFlags |= TERM_CODED;
    };
// ABS Label 1378
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1378);
}
// ABS Label 1379
if(pWC->nTerm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1379);
}

// ROR Label 1380
if((j <= pWC->nTerm) != (j < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1380);
}
// ROR Label 1381
if((j > pWC->nTerm) != (j < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1381);
}
// ROR Label 1382
if((j >= pWC->nTerm) != (j < pWC->nTerm))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1382);
}

  }

#if WHERETRACE_ENABLED /* 0x20800 */
  if( sqlite3WhereTrace & 0x20000 ){
    sqlite3DebugPrintf("All WHERE-clause terms after coding level %d:\n",
                       iLevel);
    sqlite3WhereClausePrint(pWC);
  }
  if( sqlite3WhereTrace & 0x800 ){
    sqlite3DebugPrintf("End Coding level %d:  notReady=%llx\n",
       iLevel, (u64)pLevel->notReady);
  }
#endif
  
// ABS Label 1389
if(pLevel->notReady < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1389);
}
return pLevel->notReady;
}
