/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle UPDATE statements.
*/
#include "sqliteInt.h"

#ifndef SQLITE_OMIT_VIRTUALTABLE
/* Forward declaration */
static void updateVirtualTable(
  Parse *pParse,       /* The parsing context */
  SrcList *pSrc,       /* The virtual table to be modified */
  Table *pTab,         /* The virtual table */
  ExprList *pChanges,  /* The columns to change in the UPDATE statement */
  Expr *pRowidExpr,    /* Expression used to recompute the rowid */
  int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */
  Expr *pWhere,        /* WHERE clause of the UPDATE statement */
  int onError          /* ON CONFLICT strategy */
);
#endif /* SQLITE_OMIT_VIRTUALTABLE */

/*
** The most recently coded instruction was an OP_Column to retrieve the
** i-th column of table pTab. This routine sets the P4 parameter of the 
** OP_Column to the default value, if any.
**
** The default value of a column is specified by a DEFAULT clause in the 
** column definition. This was either supplied by the user when the table
** was created, or added later to the table definition by an ALTER TABLE
** command. If the latter, then the row-records in the table btree on disk
** may not contain a value for the column and the default value, taken
** from the P4 parameter of the OP_Column instruction, is returned instead.
** If the former, then all row-records are guaranteed to include a value
** for the column and the P4 value is not required.
**
** Column definitions created by an ALTER TABLE command may only have 
** literal default values specified: a number, null or a string. (If a more
** complicated default expression value was provided, it is evaluated 
** when the ALTER TABLE is executed and one of the literal values written
** into the sqlite_schema table.)
**
** Therefore, the P4 parameter is only required if the default value for
** the column is a literal number, string or null. The sqlite3ValueFromExpr()
** function is capable of transforming these types of expressions into
** sqlite3_value objects.
**
** If column as REAL affinity and the table is an ordinary b-tree table
** (not a virtual table) then the value might have been stored as an
** integer.  In that case, add an OP_RealAffinity opcode to make sure
** it has been converted into REAL.
*/
void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){
  assert( pTab!=0 );
  if( !pTab->pSelect ){
    sqlite3_value *pValue = 0;
    u8 enc = ENC(sqlite3VdbeDb(v));
    Column *pCol = &pTab->aCol[i];
    VdbeComment((v, "%s.%s", pTab->zName, pCol->zName));
    assert( i<pTab->nCol );
    
// ABS Label 7
if(pCol->pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ABS Label 8
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc, 
                         pCol->affinity, &pValue);
    
// ABS Label 9
if(pValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
if( pValue ){
      
// ABS Label 10
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
sqlite3VdbeAppendP4(v, pValue, P4_MEM);
    }
  }
#ifndef SQLITE_OMIT_FLOATING_POINT
  
// COR Label 11
if((pTab->aCol[i].affinity == 69 || !((pTab)->nModuleArg)) != (pTab->aCol[i].affinity == 69 && !((pTab)->nModuleArg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 11);
}

// ROR Label 12
if((pTab->aCol[i].affinity != 69) != (pTab->aCol[i].affinity == 69))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}

// MCC Label 13
if(pTab->aCol[i].affinity == 69 && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 13);
}
// MCC Label 14
if(pTab->aCol[i].affinity == 69 && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 14);
}
// MCC Label 15
if(!(pTab->aCol[i].affinity == 69) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 15);
}
// MCC Label 16
if(!(pTab->aCol[i].affinity == 69) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}
if( pTab->aCol[i].affinity==SQLITE_AFF_REAL && !IsVirtual(pTab) ){
    
// ABS Label 17
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// ABS Label 18
if(iReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);
  }
#endif
}

/*
** Check to see if column iCol of index pIdx references any of the
** columns defined by aXRef and chngRowid.  Return true if it does
** and false if not.  This is an optimization.  False-positives are a
** performance degradation, but false-negatives can result in a corrupt
** index and incorrect answers.
**
** aXRef[j] will be non-negative if column j of the original table is
** being updated.  chngRowid will be true if the rowid of the table is
** being updated.
*/
static int indexColumnIsBeingUpdated(
  Index *pIdx,      /* The index to check */
  int iCol,         /* Which column of the index to check */
  int *aXRef,       /* aXRef[j]>=0 if column j is being updated */
  int chngRowid     /* true if the rowid is being updated */
){
  
// ABS Label 19
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
// ABS Label 20
if(pIdx->aiColumn[iCol] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
i16 iIdxCol = pIdx->aiColumn[iCol];
  assert( iIdxCol!=XN_ROWID ); /* Cannot index rowid */
  
// ROR Label 21
if((iIdxCol < 0) != (iIdxCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
// ROR Label 22
if((iIdxCol > 0) != (iIdxCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}
// ROR Label 23
if((iIdxCol <= 0) != (iIdxCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
if( iIdxCol>=0 ){
    
// ABS Label 24
if(aXRef[iIdxCol] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
// ABS Label 25
if(iIdxCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}

// ROR Label 26
if((aXRef[iIdxCol] < 0) != (aXRef[iIdxCol] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
// ROR Label 27
if((aXRef[iIdxCol] > 0) != (aXRef[iIdxCol] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
// ROR Label 28
if((aXRef[iIdxCol] <= 0) != (aXRef[iIdxCol] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
return aXRef[iIdxCol]>=0;
  }
  assert( iIdxCol==XN_EXPR );
  assert( pIdx->aColExpr!=0 );
  assert( pIdx->aColExpr->a[iCol].pExpr!=0 );
  return sqlite3ExprReferencesUpdatedColumn(pIdx->aColExpr->a[iCol].pExpr,
                                            aXRef,chngRowid);
}

/*
** Check to see if index pIdx is a partial index whose conditional
** expression might change values due to an UPDATE.  Return true if
** the index is subject to change and false if the index is guaranteed
** to be unchanged.  This is an optimization.  False-positives are a
** performance degradation, but false-negatives can result in a corrupt
** index and incorrect answers.
**
** aXRef[j] will be non-negative if column j of the original table is
** being updated.  chngRowid will be true if the rowid of the table is
** being updated.
*/
static int indexWhereClauseMightChange(
  Index *pIdx,      /* The index to check */
  int *aXRef,       /* aXRef[j]>=0 if column j is being updated */
  int chngRowid     /* true if the rowid is being updated */
){
  
// ABS Label 29
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}

// ROR Label 30
if((pIdx->pPartIdxWhere != 0) != (pIdx->pPartIdxWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
if( pIdx->pPartIdxWhere==0 ) { return 0;
}
  return sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere,
                                            aXRef, chngRowid);
}

/*
** Allocate and return a pointer to an expression of type TK_ROW with
** Expr.iColumn set to value (iCol+1). The resolver will modify the
** expression to be a TK_COLUMN reading column iCol of the first
** table in the source-list (pSrc->a[0]).
*/
static Expr *exprRowColumn(Parse *pParse, int iCol){
  Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);
  
// ABS Label 31
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
if( pRet ) { pRet->iColumn = iCol+1;
}
  
// ABS Label 32
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
return pRet;
}

/*
** Assuming both the pLimit and pOrderBy parameters are NULL, this function
** generates VM code to run the query:
**
**   SELECT <other-columns>, pChanges FROM pTabList WHERE pWhere 
**
** and write the results to the ephemeral table already opened as cursor 
** iEph. None of pChanges, pTabList or pWhere are modified or consumed by 
** this function, they must be deleted by the caller.
**
** Or, if pLimit and pOrderBy are not NULL, and pTab is not a view:
**
**   SELECT <other-columns>, pChanges FROM pTabList 
**   WHERE pWhere
**   GROUP BY <other-columns> 
**   ORDER BY pOrderBy LIMIT pLimit
**
** If pTab is a view, the GROUP BY clause is omitted.
**
** Exactly how results are written to table iEph, and exactly what
** the <other-columns> in the query above are is determined by the type
** of table pTabList->a[0].pTab.
**
** If the table is a WITHOUT ROWID table, then argument pPk must be its
** PRIMARY KEY. In this case <other-columns> are the primary key columns
** of the table, in order. The results of the query are written to ephemeral
** table iEph as index keys, using OP_IdxInsert.
**
** If the table is actually a view, then <other-columns> are all columns of
** the view. The results are written to the ephemeral table iEph as records
** with automatically assigned integer keys.
**
** If the table is a virtual or ordinary intkey table, then <other-columns> 
** is its rowid. For a virtual table, the results are written to iEph as
** records with automatically assigned integer keys For intkey tables, the
** rowid value in <other-columns> is used as the integer key, and the 
** remaining fields make up the table record. 
*/
static void updateFromSelect(
  Parse *pParse,                  /* Parse context */
  int iEph,                       /* Cursor for open eph. table */
  Index *pPk,                     /* PK if table 0 is WITHOUT ROWID */
  ExprList *pChanges,             /* List of expressions to return */
  SrcList *pTabList,              /* List of tables to select from */
  Expr *pWhere,                   /* WHERE clause for query */
  ExprList *pOrderBy,             /* ORDER BY clause */
  Expr *pLimit                    /* LIMIT clause */
){
  int i;
  SelectDest dest;
  Select *pSelect = 0;
  ExprList *pList = 0;
  ExprList *pGrp = 0;
  Expr *pLimit2 = 0;
  ExprList *pOrderBy2 = 0;
  
// ABS Label 33
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3 *db = pParse->db;
  
// ABS Label 34
if(pTabList->a[0].pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
Table *pTab = pTabList->a[0].pTab;
  SrcList *pSrc;
  Expr *pWhere2;
  int eDest;

#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
  if( pOrderBy && pLimit==0 ) {
    sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on UPDATE");
    return;
  }
  pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);
  pLimit2 = sqlite3ExprDup(db, pLimit, 0);
#else
  UNUSED_PARAMETER(pOrderBy);
  UNUSED_PARAMETER(pLimit);
#endif

  pSrc = sqlite3SrcListDup(db, pTabList, 0);
  pWhere2 = sqlite3ExprDup(db, pWhere, 0);

  assert( pTabList->nSrc>1 );
  
// ABS Label 41
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
if( pSrc ){
    pSrc->a[0].fg.notCte = 1;
    pSrc->a[0].iCursor = -1;
    pSrc->a[0].pTab->nTabRef--;
    pSrc->a[0].pTab = 0;
  }
  
// ABS Label 42
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}
if( pPk ){
    i = 0;

// ABS Label 43
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// ROR Label 44
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
// ROR Label 45
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
// ROR Label 46
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
for(; i<pPk->nKeyCol; i++){
      Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
      if( pLimit ){
        pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));
      }
#endif
      pList = sqlite3ExprListAppend(pParse, pList, pNew);
    };
// ABS Label 47
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ROR Label 48
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
// ROR Label 49
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
// ROR Label 50
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}

    eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;
  }else { 
// ABS Label 51
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
if( pTab->pSelect ){
    i = 0;

// ABS Label 52
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}

// ROR Label 53
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}
// ROR Label 54
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
// ROR Label 55
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
for(; i<pTab->nCol; i++){
      pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));
    };
// ABS Label 56
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}

// ROR Label 57
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}

    eDest = SRT_Table;
  }else{
    eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;
    pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
    if( pLimit ){
      pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));
    }
#endif
  };}

  assert( pChanges!=0 || pParse->db->mallocFailed );
  
// ABS Label 60
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
if( pChanges ){
    i = 0;

// ABS Label 61
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
// ABS Label 62
if(pChanges->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// ROR Label 63
if((i <= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((i > pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((i >= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
for(; i<pChanges->nExpr; i++){
      pList = sqlite3ExprListAppend(pParse, pList, 
          sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)
      );
    };
// ABS Label 66
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
// ABS Label 67
if(pChanges->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}

// ROR Label 68
if((i <= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
// ROR Label 69
if((i > pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((i >= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}

  }
  pSelect = sqlite3SelectNew(pParse, pList, 
      pSrc, pWhere2, pGrp, 0, pOrderBy2, SF_UFSrcCheck|SF_IncludeHidden, pLimit2
  );
  
// ABS Label 35
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// ABS Label 36
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}
sqlite3SelectDestInit(&dest, eDest, iEph);
  dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);
  
// ABS Label 37
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}

// ABS Label 38
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
sqlite3Select(pParse, pSelect, &dest);
  
// ABS Label 39
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}

// ABS Label 40
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
sqlite3SelectDelete(db, pSelect);
}

/*
** Process an UPDATE statement.
**
**   UPDATE OR IGNORE tbl SET a=b, c=d FROM tbl2... WHERE e<5 AND f NOT NULL;
**          \_______/ \_/     \______/      \_____/       \________________/
**           onError   |      pChanges         |                pWhere
**                     \_______________________/
**                               pTabList
*/
void sqlite3Update(
  Parse *pParse,         /* The parser context */
  SrcList *pTabList,     /* The table in which we should change things */
  ExprList *pChanges,    /* Things to be changed */
  Expr *pWhere,          /* The WHERE clause.  May be null */
  int onError,           /* How to handle constraint errors */
  ExprList *pOrderBy,    /* ORDER BY clause. May be null */
  Expr *pLimit,          /* LIMIT clause. May be null */
  Upsert *pUpsert        /* ON CONFLICT clause, or null */
){
  int i, j, k;           /* Loop counters */
  Table *pTab;           /* The table to be updated */
  int addrTop = 0;       /* VDBE instruction address of the start of the loop */
  WhereInfo *pWInfo = 0; /* Information about the WHERE clause */
  Vdbe *v;               /* The virtual database engine */
  Index *pIdx;           /* For looping over indices */
  Index *pPk;            /* The PRIMARY KEY index for WITHOUT ROWID tables */
  int nIdx;              /* Number of indices that need updating */
  int nAllIdx;           /* Total number of indexes */
  int iBaseCur;          /* Base cursor number */
  int iDataCur;          /* Cursor for the canonical data btree */
  int iIdxCur;           /* Cursor for the first index */
  sqlite3 *db;           /* The database structure */
  int *aRegIdx = 0;      /* Registers for to each index and the main table */
  int *aXRef = 0;        /* aXRef[i] is the index in pChanges->a[] of the
                         ** an expression for the i-th column of the table.
                         ** aXRef[i]==-1 if the i-th column is not changed. */
  u8 *aToOpen;           /* 1 for tables and indices to be opened */
  u8 chngPk;             /* PRIMARY KEY changed in a WITHOUT ROWID table */
  u8 chngRowid;          /* Rowid changed in a normal table */
  u8 chngKey;            /* Either chngPk or chngRowid */
  Expr *pRowidExpr = 0;  /* Expression defining the new record number */
  int iRowidExpr = -1;   /* Index of "rowid=" (or IPK) assignment in pChanges */
  AuthContext sContext;  /* The authorization context */
  NameContext sNC;       /* The name-context to resolve expressions in */
  int iDb;               /* Database containing the table being updated */
  int eOnePass;          /* ONEPASS_XXX value from where.c */
  int hasFK;             /* True if foreign key processing is required */
  int labelBreak;        /* Jump here to break out of UPDATE loop */
  int labelContinue;     /* Jump here to continue next step of UPDATE loop */
  int flags;             /* Flags for sqlite3WhereBegin() */

#ifndef SQLITE_OMIT_TRIGGER
  int isView;            /* True when updating a view (INSTEAD OF trigger) */
  Trigger *pTrigger;     /* List of triggers on pTab, if required */
  int tmask;             /* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */
#endif
  int newmask;           /* Mask of NEW.* columns accessed by BEFORE triggers */
  int iEph = 0;          /* Ephemeral table holding all primary key values */
  int nKey = 0;          /* Number of elements in regKey for WITHOUT ROWID */
  int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */
  int addrOpen = 0;      /* Address of OP_OpenEphemeral */
  int iPk = 0;           /* First of nPk cells holding PRIMARY KEY value */
  i16 nPk = 0;           /* Number of components of the PRIMARY KEY */
  int bReplace = 0;      /* True if REPLACE conflict resolution might happen */
  int bFinishSeek = 1;   /* The OP_FinishSeek opcode is needed */
  int nChangeFrom = 0;   /* If there is a FROM, pChanges->nExpr, else 0 */

  /* Register Allocations */
  int regRowCount = 0;   /* A count of rows changed */
  int regOldRowid = 0;   /* The old rowid */
  int regNewRowid = 0;   /* The new rowid */
  int regNew = 0;        /* Content of the NEW.* table in triggers */
  int regOld = 0;        /* Content of OLD.* table in triggers */
  int regRowSet = 0;     /* Rowset of rows to be updated */
  int regKey = 0;        /* composite PRIMARY KEY value */

  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  
// ABS Label 92
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// COR Label 93
if((pParse->nErr && db->mallocFailed) != (pParse->nErr || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 93);
}

// MCC Label 94
if(pParse->nErr && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(pParse->nErr && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(!(pParse->nErr) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(!(pParse->nErr) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
if( pParse->nErr || db->mallocFailed ){
    goto update_cleanup;
  }

  /* Locate the table which we want to update. 
  */
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  
// ABS Label 98
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}

// ROR Label 99
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
if( pTab==0 ) { goto update_cleanup;
}
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);

  /* Figure out if we have any triggers and if the table being
  ** updated is a view.
  */
#ifndef SQLITE_OMIT_TRIGGER
  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_UPDATE, pChanges, &tmask);
  isView = pTab->pSelect!=0;
  assert( pTrigger || tmask==0 );
#else
# define pTrigger 0
# define isView 0
# define tmask 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif

  /* If there was a FROM clause, set nChangeFrom to the number of expressions
  ** in the change-list. Otherwise, set it to 0. There cannot be a FROM
  ** clause if this function is being called to generate code for part of
  ** an UPSERT statement.  */
  nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;
  assert( nChangeFrom==0 || pUpsert==0 );

#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
  if( !isView && nChangeFrom==0 ){
    pWhere = sqlite3LimitWhere(
        pParse, pTabList, pWhere, pOrderBy, pLimit, "UPDATE"
    );
    pOrderBy = 0;
    pLimit = 0;
  }
#endif

  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto update_cleanup;
  }
  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){
    goto update_cleanup;
  }

  /* Allocate a cursors for the main database table and for all indices.
  ** The index cursors might not be used, but if they are used they
  ** need to occur right after the database cursor.  So go ahead and
  ** allocate enough space, just in case.
  */
  iBaseCur = iDataCur = pParse->nTab++;
  iIdxCur = iDataCur+1;
  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
  testcase( pPk!=0 && pPk!=pTab->pIndex );
  nIdx = 0 , pIdx = pTab->pIndex;

// ABS Label 100
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
for(; pIdx; pIdx=pIdx->pNext, nIdx++){
    
// ABS Label 102
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
// ABS Label 103
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}

// ROR Label 104
if((pPk != pIdx) != (pPk == pIdx))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
if( pPk==pIdx ){
      iDataCur = pParse->nTab;
    }
    pParse->nTab++;
  };
// ABS Label 101
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}

  
// ABS Label 105
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}
if( pUpsert ){
    /* On an UPSERT, reuse the same cursors already opened by INSERT */
    iDataCur = pUpsert->iDataCur;
    iIdxCur = pUpsert->iIdxCur;
    pParse->nTab = iBaseCur;
  }
  pTabList->a[0].iCursor = iDataCur;

  /* Allocate space for aXRef[], aRegIdx[], and aToOpen[].  
  ** Initialize aXRef[] and aToOpen[] to their default values.
  */
  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );
  
// ABS Label 106
if(aXRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// ROR Label 107
if((aXRef != 0) != (aXRef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
if( aXRef==0 ) { goto update_cleanup;
}
  aRegIdx = aXRef+pTab->nCol;
  aToOpen = (u8*)(aRegIdx+nIdx+1);
  memset(aToOpen, 1, nIdx+1);
  aToOpen[nIdx+1] = 0;
  i = 0;

// ABS Label 108
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}

// ROR Label 109
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}
// ROR Label 110
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
// ROR Label 111
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 111);
}
for(; i<pTab->nCol; i++) { aXRef[i] = -1;
};
// ABS Label 112
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ROR Label 113
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
// ROR Label 114
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}
// ROR Label 115
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}


  /* Initialize the name-context */
  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  sNC.uNC.pUpsert = pUpsert;
  sNC.ncFlags = NC_UUpsert;

  /* Begin generating code. */
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 116
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ROR Label 117
if((v != 0) != (v == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
if( v==0 ) { goto update_cleanup;
}

  /* Resolve the column names in all the expressions of the
  ** of the UPDATE statement.  Also find the column index
  ** for each column to be updated in the pChanges array.  For each
  ** column to be updated, make sure we have authorization to change
  ** that column.
  */
  chngRowid = chngPk = 0;
  i = 0;

// ABS Label 118
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}
// ABS Label 119
if(pChanges->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}

// ROR Label 120
if((i <= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
// ROR Label 121
if((i > pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
// ROR Label 122
if((i >= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
for(; i<pChanges->nExpr; i++){
    /* If this is an UPDATE with a FROM clause, do not resolve expressions
    ** here. The call to sqlite3Select() below will do that. */
    if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){
      goto update_cleanup;
    }
    j = 0;

// ABS Label 128
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}

// ROR Label 129
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 129);
}
// ROR Label 130
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}
for(; j<pTab->nCol; j++){
      if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zEName)==0 ){
        
// ABS Label 136
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}

// ROR Label 137
if((j != pTab->iPKey) != (j == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
if( j==pTab->iPKey ){
          chngRowid = 1;
          pRowidExpr = pChanges->a[i].pExpr;
          iRowidExpr = i;
        }else { 
// ABS Label 138
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// COR Label 139
if((pPk || (pTab->aCol[j].colFlags & 1) != 0) != (pPk && (pTab->aCol[j].colFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 139);
}

// ROR Label 140
if(((pTab->aCol[j].colFlags & 1) == 0) != ((pTab->aCol[j].colFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 140);
}

// MCC Label 141
if(pPk && (pTab->aCol[j].colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 141);
}
// MCC Label 142
if(pPk && !((pTab->aCol[j].colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 142);
}
// MCC Label 143
if(!(pPk) && (pTab->aCol[j].colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 143);
}
// MCC Label 144
if(!(pPk) && !((pTab->aCol[j].colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 144);
}
if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){
          chngPk = 1;
        }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
        else { 
// AOR Label 145
if(pTab->aCol[j].colFlags | 96 != pTab->aCol[j].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 145);
}
// AOR Label 146
if(pTab->aCol[j].colFlags ^ 96 != pTab->aCol[j].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 146);
}
if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){
          testcase( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL );
          testcase( pTab->aCol[j].colFlags & COLFLAG_STORED );
          
// ABS Label 147
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}

// ABS Label 148
if(pTab->aCol[j].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
sqlite3ErrorMsg(pParse, 
             "cannot UPDATE generated column \"%s\"",
             pTab->aCol[j].zName);
          goto update_cleanup;
        };}
;}

#endif
        aXRef[j] = i;
        break;
      }
    };
// ABS Label 132
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}

// ROR Label 133
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
// ROR Label 134
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}
// ROR Label 135
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 135);
}

    
// ABS Label 149
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}

// ROR Label 150
if((j < pTab->nCol) != (j >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if((j > pTab->nCol) != (j >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((j <= pTab->nCol) != (j >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
if( j>=pTab->nCol ){
      if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zEName) ){
        j = -1;
        chngRowid = 1;
        pRowidExpr = pChanges->a[i].pExpr;
        iRowidExpr = i;
      }else{
        
// ABS Label 153
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ABS Label 154
if(pChanges->a[i].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}
sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zEName);
        pParse->checkSchema = 1;
        goto update_cleanup;
      }
    }
#ifndef SQLITE_OMIT_AUTHORIZATION
    {
      int rc;
      rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName,
                            j<0 ? "ROWID" : pTab->aCol[j].zName,
                            db->aDb[iDb].zDbSName);
      
// ABS Label 155
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}

// ROR Label 156
if((rc != 1) != (rc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
if( rc==SQLITE_DENY ){
        goto update_cleanup;
      }else { 
// ABS Label 157
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ROR Label 158
if((rc != 2) != (rc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 158);
}
if( rc==SQLITE_IGNORE ){
        aXRef[j] = -1;
      };}

    }
#endif
  };
// ABS Label 123
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}
// ABS Label 124
if(pChanges->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}

// ROR Label 125
if((i <= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}
// ROR Label 126
if((i > pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
// ROR Label 127
if((i >= pChanges->nExpr) != (i < pChanges->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 127);
}

  assert( (chngRowid & chngPk)==0 );
  assert( chngRowid==0 || chngRowid==1 );
  assert( chngPk==0 || chngPk==1 );
  chngKey = chngRowid + chngPk;

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
  /* Mark generated columns as changing if their generator expressions
  ** reference any changing column.  The actual aXRef[] value for 
  ** generated expressions is not used, other than to check to see that it
  ** is non-negative, so the value of aXRef[] for generated columns can be
  ** set to any non-negative number.  We use 99999 so that the value is
  ** obvious when looking at aXRef[] in a symbolic debugger. 
  */
  
// ABS Label 159
if(pTab->tabFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}

// AOR Label 160
if(pTab->tabFlags | 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 160);
}
// AOR Label 161
if(pTab->tabFlags ^ 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 161);
}
if( pTab->tabFlags & TF_HasGenerated ){
    int bProgress;
    testcase( pTab->tabFlags & TF_HasVirtual );
    testcase( pTab->tabFlags & TF_HasStored );
    
// ABS Label 162
if(bProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}
do{
      bProgress = 0;
      i = 0;

// ABS Label 164
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}

// ROR Label 165
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
for(; i<pTab->nCol; i++){
        
// ABS Label 172
if(aXRef[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}
// ABS Label 173
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}

// ROR Label 174
if((aXRef[i] < 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((aXRef[i] > 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
// ROR Label 176
if((aXRef[i] <= 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
if( aXRef[i]>=0 ) { continue;
}
        
// ROR Label 177
if(((pTab->aCol[i].colFlags & 96) != 0) != ((pTab->aCol[i].colFlags & 96) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 177);
}
if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 ) { continue;
}
        if( sqlite3ExprReferencesUpdatedColumn(pTab->aCol[i].pDflt,
                                               aXRef, chngRowid) ){
          aXRef[i] = 99999;
          bProgress = 1;
        }
      };
// ABS Label 168
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}

// ROR Label 169
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}
// ROR Label 170
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 170);
}
// ROR Label 171
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 171);
}

    }while( bProgress );
// ABS Label 163
if(bProgress < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}
;
  }
#endif

  /* The SET expressions are not actually used inside the WHERE loop.  
  ** So reset the colUsed mask. Unless this is a virtual table. In that
  ** case, set all bits of the colUsed mask (to ensure that the virtual
  ** table implementation makes all columns available).
  */
  pTabList->a[0].colUsed = IsVirtual(pTab) ? ALLBITS : 0;

  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);

  /* There is one entry in the aRegIdx[] array for each index on the table
  ** being updated.  Fill in aRegIdx[] with a register number that will hold
  ** the key for accessing each index.
  */
  
// ABS Label 178
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}

// ROR Label 179
if((onError != 5) != (onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}
if( onError==OE_Replace ) { bReplace = 1;
}
  nAllIdx = 0 , pIdx = pTab->pIndex;

// ABS Label 180
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
for(; pIdx; pIdx=pIdx->pNext, nAllIdx++){
    int reg;
    if( chngKey || hasFK>1 || pIdx==pPk
     || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)
    ){
      reg = ++pParse->nMem;
      pParse->nMem += pIdx->nColumn;
    }else{
      reg = 0;
      i = 0;

// ABS Label 182
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}

// ROR Label 183
if((i <= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((i > pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
// ROR Label 185
if((i >= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
for(; i<pIdx->nKeyCol; i++){
        if( indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid) ){
          reg = ++pParse->nMem;
          pParse->nMem += pIdx->nColumn;
          
// ABS Label 190
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}

// COR Label 191
if((onError == 11 || pIdx->onError == 5) != (onError == 11 && pIdx->onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 191);
}

// ROR Label 192
if((onError != 11) != (onError == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((pIdx->onError != 5) != (pIdx->onError == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}

// MCC Label 194
if(onError == 11 && pIdx->onError == 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(onError == 11 && !(pIdx->onError == 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(!(onError == 11) && pIdx->onError == 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(!(onError == 11) && !(pIdx->onError == 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
if( onError==OE_Default && pIdx->onError==OE_Replace ){
            bReplace = 1;
          }
          break;
        }
      };
// ABS Label 186
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ROR Label 187
if((i <= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
// ROR Label 188
if((i > pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
// ROR Label 189
if((i >= pIdx->nKeyCol) != (i < pIdx->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}

    }
    
// ABS Label 198
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}

// ROR Label 199
if((reg != 0) != (reg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
if( reg==0 ) { aToOpen[nAllIdx+1] = 0;
}
    aRegIdx[nAllIdx] = reg;
  };
// ABS Label 181
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}

  aRegIdx[nAllIdx] = ++pParse->nMem;  /* Register storing the table record */
  
// ABS Label 200
if(bReplace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
if( bReplace ){
    /* If REPLACE conflict resolution might be invoked, open cursors on all 
    ** indexes in case they are needed to delete records.  */
    memset(aToOpen, 1, nIdx+1);
  }

  
// ROR Label 201
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
if( pParse->nested==0 ) { 
// ABS Label 202
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}
sqlite3VdbeCountChanges(v);
}
  
// ABS Label 71
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}

// ABS Label 72
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
// ABS Label 73
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// COR Label 74
if((pTrigger && hasFK) != (pTrigger || hasFK))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 74);
}

// ABS Label 75
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}
sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);

  /* Allocate required registers. */
  if( !IsVirtual(pTab) ){
    /* For now, regRowSet and aRegIdx[nAllIdx] share the same register.
    ** If regRowSet turns out to be needed, then aRegIdx[nAllIdx] will be
    ** reallocated.  aRegIdx[nAllIdx] is the register in which the main
    ** table record is written.  regRowSet holds the RowSet for the
    ** two-pass update algorithm. */
    assert( aRegIdx[nAllIdx]==pParse->nMem );
    regRowSet = aRegIdx[nAllIdx];
    regOldRowid = regNewRowid = ++pParse->nMem;
    
// ABS Label 203
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}
// ABS Label 204
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}

// COR Label 205
if((chngPk || pTrigger && hasFK) != (chngPk || pTrigger || hasFK))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 205);
}
// COR Label 206
if((chngPk && pTrigger) != (chngPk || pTrigger))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 206);
}

// MCC Label 207
if(chngPk && pTrigger && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 207);
}
// MCC Label 208
if(chngPk && pTrigger && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(chngPk && !(pTrigger) && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(chngPk && !(pTrigger) && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(!(chngPk) && pTrigger && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if(!(chngPk) && pTrigger && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(!(chngPk) && !(pTrigger) && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(!(chngPk) && !(pTrigger) && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
if( chngPk || pTrigger || hasFK ){
      regOld = pParse->nMem + 1;
      pParse->nMem += pTab->nCol;
    }
    
// ABS Label 215
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
// ABS Label 216
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// COR Label 217
if((chngKey || pTrigger && hasFK) != (chngKey || pTrigger || hasFK))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 217);
}
// COR Label 218
if((chngKey && pTrigger) != (chngKey || pTrigger))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 218);
}

// MCC Label 219
if(chngKey && pTrigger && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(chngKey && pTrigger && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(chngKey && !(pTrigger) && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
// MCC Label 222
if(chngKey && !(pTrigger) && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
// MCC Label 223
if(!(chngKey) && pTrigger && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(!(chngKey) && pTrigger && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(!(chngKey) && !(pTrigger) && hasFK ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(!(chngKey) && !(pTrigger) && !(hasFK) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
if( chngKey || pTrigger || hasFK ){
      regNewRowid = ++pParse->nMem;
    }
    regNew = pParse->nMem + 1;
    pParse->nMem += pTab->nCol;
  }

  /* Start the view context. */
  
// ABS Label 227
if(isView < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
if( isView ){
    
// ABS Label 228
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}
sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }

  /* If we are trying to update a view, realize that view into
  ** an ephemeral table.
  */
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
  
// ABS Label 229
if(isView < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}
// ABS Label 230
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}

// COR Label 231
if((nChangeFrom == 0 || isView) != (nChangeFrom == 0 && isView))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 231);
}

// ROR Label 232
if((nChangeFrom != 0) != (nChangeFrom == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}

// MCC Label 233
if(nChangeFrom == 0 && isView ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
// MCC Label 234
if(nChangeFrom == 0 && !(isView) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
// MCC Label 235
if(!(nChangeFrom == 0) && isView ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
// MCC Label 236
if(!(nChangeFrom == 0) && !(isView) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
if( nChangeFrom==0 && isView ){
    
// ABS Label 237
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}

// ABS Label 238
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ABS Label 239
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// ABS Label 240
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ABS Label 241
if(pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}

// ABS Label 242
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}
sqlite3MaterializeView(pParse, pTab, 
        pWhere, pOrderBy, pLimit, iDataCur
    );
    pOrderBy = 0;
    pLimit = 0;
  }
#endif

  /* Resolve the column names in all the expressions in the
  ** WHERE clause.
  */
  if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto update_cleanup;
  }

#ifndef SQLITE_OMIT_VIRTUALTABLE
  /* Virtual tables must be handled separately */
  
// ABS Label 243
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}
if( IsVirtual(pTab) ){
    
// ABS Label 244
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ABS Label 245
if(pTabList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}

// ABS Label 246
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}

// ABS Label 247
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}

// ABS Label 248
if(pRowidExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}

// ABS Label 249
if(aXRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}

// ABS Label 250
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

// ABS Label 251
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}
updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
                       pWhere, onError);
    goto update_cleanup;
  }
#endif

  /* Jump to labelBreak to abandon further processing of this UPDATE */
  labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);

  /* Not an UPSERT.  Normal processing.  Begin by
  ** initialize the count of updated rows */
  
// ABS Label 252
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}

// COR Label 253
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning || pUpsert == 0) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && pUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 253);
}
// COR Label 254
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested || !pParse->bReturning) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 254);
}
// COR Label 255
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab || !pParse->nested) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 255);
}
// COR Label 256
if(((db->flags & ((u64)(1) << 32)) != 0 || !pParse->pTriggerTab) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 256);
}

// ROR Label 257
if(((db->flags & ((u64)(1) << 32)) == 0) != ((db->flags & ((u64)(1) << 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
// ROR Label 258
if((pUpsert != 0) != (pUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}

// MCC Label 259
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 259);
}
// MCC Label 260
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !pParse->nested && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !(!pParse->nested) && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
// MCC Label 264
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !(!pParse->nested) && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !(!pParse->nested) && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->pTriggerTab && !(!pParse->nested) && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !pParse->nested && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !pParse->nested && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !pParse->nested && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !pParse->nested && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
// MCC Label 271
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !(!pParse->nested) && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 271);
}
// MCC Label 272
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !(!pParse->nested) && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 272);
}
// MCC Label 273
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !(!pParse->nested) && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 273);
}
// MCC Label 274
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->pTriggerTab) && !(!pParse->nested) && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 274);
}
// MCC Label 275
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
// MCC Label 276
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !pParse->nested && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 276);
}
// MCC Label 277
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !pParse->nested && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 277);
}
// MCC Label 278
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !pParse->nested && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}
// MCC Label 279
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !(!pParse->nested) && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 279);
}
// MCC Label 280
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !(!pParse->nested) && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 280);
}
// MCC Label 281
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !(!pParse->nested) && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 281);
}
// MCC Label 282
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->pTriggerTab && !(!pParse->nested) && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 282);
}
// MCC Label 283
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !pParse->nested && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}
// MCC Label 284
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !pParse->nested && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 284);
}
// MCC Label 285
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !pParse->nested && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 285);
}
// MCC Label 286
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !pParse->nested && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 286);
}
// MCC Label 287
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !(!pParse->nested) && !pParse->bReturning && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 287);
}
// MCC Label 288
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !(!pParse->nested) && !pParse->bReturning && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 288);
}
// MCC Label 289
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !(!pParse->nested) && !(!pParse->bReturning) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 289);
}
// MCC Label 290
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->pTriggerTab) && !(!pParse->nested) && !(!pParse->bReturning) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 290);
}
if( (db->flags&SQLITE_CountRows)!=0
   && !pParse->pTriggerTab
   && !pParse->nested
   && !pParse->bReturning
   && pUpsert==0
  ){
    regRowCount = ++pParse->nMem;
    
// ABS Label 291
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ABS Label 292
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);
  }

  
// ABS Label 293
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// COR Label 294
if((nChangeFrom == 0 || (((pTab)->tabFlags & 128) == 0)) != (nChangeFrom == 0 && (((pTab)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 294);
}

// ROR Label 295
if((nChangeFrom != 0) != (nChangeFrom == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}

// MCC Label 296
if(nChangeFrom == 0 && ( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 296);
}
// MCC Label 297
if(nChangeFrom == 0 && ( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 297);
}
// MCC Label 298
if(!(nChangeFrom == 0) && ( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 298);
}
// MCC Label 299
if(!(nChangeFrom == 0) && ( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 299);
}
if( nChangeFrom==0 && HasRowid(pTab) ){
    
// ABS Label 300
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}

// ABS Label 301
if(regRowSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ABS Label 302
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);
    iEph = pParse->nTab++;
    addrOpen = sqlite3VdbeAddOp3(v, OP_OpenEphemeral, iEph, 0, regRowSet);
  }else{
    assert( pPk!=0 || HasRowid(pTab) );
    nPk = pPk ? pPk->nKeyCol : 0;
    iPk = pParse->nMem+1;
    pParse->nMem += nPk;
    pParse->nMem += nChangeFrom;
    regKey = ++pParse->nMem;
    
// ABS Label 303
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}

// ROR Label 304
if((pUpsert != 0) != (pUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
if( pUpsert==0 ){
      
// ABS Label 305
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}

// AOR Label 306
if(nPk + nChangeFrom - (isView ? pTab->nCol : 0) != nPk + nChangeFrom + (isView ? pTab->nCol : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 306);
}
// AOR Label 307
if(nPk + nChangeFrom / (isView ? pTab->nCol : 0) != nPk + nChangeFrom + (isView ? pTab->nCol : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 307);
}
// AOR Label 308
if(nPk + nChangeFrom * (isView ? pTab->nCol : 0) != nPk + nChangeFrom + (isView ? pTab->nCol : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 308);
}
// AOR Label 309
if(nPk - nChangeFrom != nPk + nChangeFrom)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 309);
}
// AOR Label 310
if(nPk / nChangeFrom != nPk + nChangeFrom)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 310);
}
// AOR Label 311
if(nPk * nChangeFrom != nPk + nChangeFrom)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 311);
}
int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);
      iEph = pParse->nTab++;
      
// ABS Label 312
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
if( pPk ) { 
// ABS Label 313
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}

// ABS Label 314
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}

// ABS Label 315
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}

// AOR Label 316
if(iPk + nPk / 1 != iPk + nPk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 316);
}
// AOR Label 317
if(iPk + nPk + 1 != iPk + nPk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 317);
}
// AOR Label 318
if(iPk + nPk * 1 != iPk + nPk - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 318);
}
// AOR Label 319
if(iPk - nPk != iPk + nPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 319);
}
// AOR Label 320
if(iPk / nPk != iPk + nPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 320);
}
// AOR Label 321
if(iPk * nPk != iPk + nPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 321);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);
}
      addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);
      
// ABS Label 322
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
if( pPk ){
        KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);
        
// ABS Label 323
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
if( pKeyInfo ){
          pKeyInfo->nAllField = nEphCol;
          
// ABS Label 324
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}
sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);
        }
      }
      
// ABS Label 325
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
if( nChangeFrom ){
        
// ABS Label 326
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ABS Label 327
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}

// ABS Label 328
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ABS Label 329
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}

// ABS Label 330
if(pTabList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ABS Label 331
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}

// ABS Label 332
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// ABS Label 333
if(pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
updateFromSelect(
            pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit
        );
#ifndef SQLITE_OMIT_SUBQUERY
        
// ABS Label 334
if(isView < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
if( isView ) { iDataCur = iEph;
}
#endif
      }
    }
  }
  
  
// ABS Label 335
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
if( nChangeFrom ){
    
// ABS Label 336
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}
sqlite3MultiWrite(pParse);
    eOnePass = ONEPASS_OFF;
    nKey = nPk;
    regKey = iPk;
  }else{
    
// ABS Label 337
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
if( pUpsert ){
      /* If this is an UPSERT, then all cursors have already been opened by
      ** the outer INSERT and the data cursor should be pointing at the row
      ** that is to be updated.  So bypass the code that searches for the
      ** row(s) to be updated.
      */
      pWInfo = 0;
      eOnePass = ONEPASS_SINGLE;
      
// ABS Label 338
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}

// ABS Label 339
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}

// ABS Label 340
if(labelBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}
sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);
      bFinishSeek = 0;
    }else{
      /* Begin the database scan. 
      **
      ** Do not consider a single-pass strategy for a multi-row update if
      ** there are any triggers or foreign keys to process, or rows may
      ** be deleted as a result of REPLACE conflict handling. Any of these
      ** things might disturb a cursor being used to scan through the table
      ** or index, causing a single-pass approach to malfunction.  */
      flags = WHERE_ONEPASS_DESIRED;
      
// COR Label 341
if((!pParse->nested && !pTrigger && !hasFK && !chngKey || !bReplace) != (!pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 341);
}
// COR Label 342
if((!pParse->nested && !pTrigger && !hasFK || !chngKey) != (!pParse->nested && !pTrigger && !hasFK && !chngKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 342);
}
// COR Label 343
if((!pParse->nested && !pTrigger || !hasFK) != (!pParse->nested && !pTrigger && !hasFK))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 343);
}
// COR Label 344
if((!pParse->nested || !pTrigger) != (!pParse->nested && !pTrigger))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 344);
}

// MCC Label 345
if(!pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 345);
}
// MCC Label 346
if(!pParse->nested && !pTrigger && !hasFK && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 346);
}
// MCC Label 347
if(!pParse->nested && !pTrigger && !hasFK && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 347);
}
// MCC Label 348
if(!pParse->nested && !pTrigger && !hasFK && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 348);
}
// MCC Label 349
if(!pParse->nested && !pTrigger && !(!hasFK) && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
// MCC Label 350
if(!pParse->nested && !pTrigger && !(!hasFK) && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
// MCC Label 351
if(!pParse->nested && !pTrigger && !(!hasFK) && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
// MCC Label 352
if(!pParse->nested && !pTrigger && !(!hasFK) && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 352);
}
// MCC Label 353
if(!pParse->nested && !(!pTrigger) && !hasFK && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 353);
}
// MCC Label 354
if(!pParse->nested && !(!pTrigger) && !hasFK && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 354);
}
// MCC Label 355
if(!pParse->nested && !(!pTrigger) && !hasFK && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 355);
}
// MCC Label 356
if(!pParse->nested && !(!pTrigger) && !hasFK && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 356);
}
// MCC Label 357
if(!pParse->nested && !(!pTrigger) && !(!hasFK) && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 357);
}
// MCC Label 358
if(!pParse->nested && !(!pTrigger) && !(!hasFK) && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 358);
}
// MCC Label 359
if(!pParse->nested && !(!pTrigger) && !(!hasFK) && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 359);
}
// MCC Label 360
if(!pParse->nested && !(!pTrigger) && !(!hasFK) && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 360);
}
// MCC Label 361
if(!(!pParse->nested) && !pTrigger && !hasFK && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
// MCC Label 362
if(!(!pParse->nested) && !pTrigger && !hasFK && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 362);
}
// MCC Label 363
if(!(!pParse->nested) && !pTrigger && !hasFK && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
// MCC Label 364
if(!(!pParse->nested) && !pTrigger && !hasFK && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 364);
}
// MCC Label 365
if(!(!pParse->nested) && !pTrigger && !(!hasFK) && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 365);
}
// MCC Label 366
if(!(!pParse->nested) && !pTrigger && !(!hasFK) && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 366);
}
// MCC Label 367
if(!(!pParse->nested) && !pTrigger && !(!hasFK) && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 367);
}
// MCC Label 368
if(!(!pParse->nested) && !pTrigger && !(!hasFK) && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
// MCC Label 369
if(!(!pParse->nested) && !(!pTrigger) && !hasFK && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 369);
}
// MCC Label 370
if(!(!pParse->nested) && !(!pTrigger) && !hasFK && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(!(!pParse->nested) && !(!pTrigger) && !hasFK && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}
// MCC Label 372
if(!(!pParse->nested) && !(!pTrigger) && !hasFK && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 372);
}
// MCC Label 373
if(!(!pParse->nested) && !(!pTrigger) && !(!hasFK) && !chngKey && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 373);
}
// MCC Label 374
if(!(!pParse->nested) && !(!pTrigger) && !(!hasFK) && !chngKey && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 374);
}
// MCC Label 375
if(!(!pParse->nested) && !(!pTrigger) && !(!hasFK) && !(!chngKey) && !bReplace ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 375);
}
// MCC Label 376
if(!(!pParse->nested) && !(!pTrigger) && !(!hasFK) && !(!chngKey) && !(!bReplace) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 376);
}
if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){
        flags |= WHERE_ONEPASS_MULTIROW;
      }
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags,iIdxCur);
      
// ABS Label 377
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}

// ROR Label 378
if((pWInfo != 0) != (pWInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
if( pWInfo==0 ) { goto update_cleanup;
}

      /* A one-pass strategy that might update more than one row may not
      ** be used if any column of the index used for the scan is being
      ** updated. Otherwise, if there is an index on "b", statements like
      ** the following could create an infinite loop:
      **
      **   UPDATE t1 SET b=b+1 WHERE b>?
      **
      ** Fall back to ONEPASS_OFF if where.c has selected a ONEPASS_MULTI
      ** strategy that uses an index for which one or more columns are being
      ** updated.  */
      eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
      bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);
      
// ABS Label 379
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// ROR Label 380
if((eOnePass == 1) != (eOnePass != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 380);
}
if( eOnePass!=ONEPASS_SINGLE ){
        
// ABS Label 381
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 381);
}
sqlite3MultiWrite(pParse);
        
// ABS Label 382
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}

// ROR Label 383
if((eOnePass != 2) != (eOnePass == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 383);
}
if( eOnePass==ONEPASS_MULTI ){
          
// ABS Label 384
if(aiCurOnePass[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}
int iCur = aiCurOnePass[1];
          
// ABS Label 385
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
// ABS Label 386
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}

// COR Label 387
if((iCur >= 0 && iCur != iDataCur || aToOpen[iCur - iBaseCur]) != (iCur >= 0 && iCur != iDataCur && aToOpen[iCur - iBaseCur]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 387);
}
// COR Label 388
if((iCur >= 0 || iCur != iDataCur) != (iCur >= 0 && iCur != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 388);
}

// ROR Label 389
if((iCur < 0) != (iCur >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 389);
}
// ROR Label 390
if((iCur > 0) != (iCur >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 390);
}
// ROR Label 391
if((iCur <= 0) != (iCur >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}
// ROR Label 392
if((iCur == iDataCur) != (iCur != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 392);
}

// MCC Label 393
if(iCur >= 0 && iCur != iDataCur && aToOpen[iCur - iBaseCur] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(iCur >= 0 && iCur != iDataCur && !(aToOpen[iCur - iBaseCur]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(iCur >= 0 && !(iCur != iDataCur) && aToOpen[iCur - iBaseCur] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(iCur >= 0 && !(iCur != iDataCur) && !(aToOpen[iCur - iBaseCur]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
// MCC Label 397
if(!(iCur >= 0) && iCur != iDataCur && aToOpen[iCur - iBaseCur] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 397);
}
// MCC Label 398
if(!(iCur >= 0) && iCur != iDataCur && !(aToOpen[iCur - iBaseCur]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 398);
}
// MCC Label 399
if(!(iCur >= 0) && !(iCur != iDataCur) && aToOpen[iCur - iBaseCur] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 399);
}
// MCC Label 400
if(!(iCur >= 0) && !(iCur != iDataCur) && !(aToOpen[iCur - iBaseCur]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 400);
}
if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){
            eOnePass = ONEPASS_OFF;
          }
          assert( iCur!=iDataCur || !HasRowid(pTab) );
        }
      }
    }

    
// MCC Label 401
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 401);
}
// MCC Label 402
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 402);
}
if( HasRowid(pTab) ){
      /* Read the rowid of the current row of the WHERE scan. In ONEPASS_OFF
      ** mode, write the rowid into the FIFO. In either of the one-pass modes,
      ** leave it in register regOldRowid.  */
      
// ABS Label 403
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}

// ABS Label 404
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}

// ABS Label 405
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);
      
// ABS Label 406
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}

// ROR Label 407
if((eOnePass != 0) != (eOnePass == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 407);
}
if( eOnePass==ONEPASS_OFF ){
        aRegIdx[nAllIdx] = ++pParse->nMem;
        
// ABS Label 408
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}

// ABS Label 409
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}

// ABS Label 410
if(regRowSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ABS Label 411
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}
sqlite3VdbeAddOp3(v, OP_Insert, iEph, regRowSet, regOldRowid);
      }else{
        
// ABS Label 412
if((addrOpen) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}
if( ALWAYS(addrOpen) ) { 
// ABS Label 413
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}

// ABS Label 414
if(addrOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}
sqlite3VdbeChangeToNoop(v, addrOpen);
}
      }
    }else{
      /* Read the PK of the current row into an array of registers. In
      ** ONEPASS_OFF mode, serialize the array into a record and store it in
      ** the ephemeral table. Or, in ONEPASS_SINGLE or MULTI mode, change
      ** the OP_OpenEphemeral instruction to a Noop (the ephemeral table 
      ** is not required) and leave the PK fields in the array of registers.  */
      i = 0;

// ABS Label 415
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}

// ROR Label 416
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 416);
}
// ROR Label 417
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 417);
}
// ROR Label 418
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 418);
}
for(; i<nPk; i++){
        assert( pPk->aiColumn[i]>=0 );
        
// ABS Label 423
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}

// ABS Label 424
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}

// ABS Label 425
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}

// ABS Label 426
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}
// ABS Label 427
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}

// AOR Label 428
if(iPk - i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 428);
}
// AOR Label 429
if(iPk / i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 429);
}
// AOR Label 430
if(iPk * i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 430);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,
                                        pPk->aiColumn[i], iPk+i);
      };
// ABS Label 419
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}

// ROR Label 420
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
// ROR Label 421
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 421);
}
// ROR Label 422
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 422);
}

      
// ABS Label 431
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
if( eOnePass ){
        
// ABS Label 432
if(addrOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}
if( addrOpen ) { 
// ABS Label 433
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 433);
}

// ABS Label 434
if(addrOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}
sqlite3VdbeChangeToNoop(v, addrOpen);
}
        nKey = nPk;
        regKey = iPk;
      }else{
        
// ABS Label 435
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}

// ABS Label 436
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 436);
}

// ABS Label 437
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 437);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,
                          sqlite3IndexAffinityStr(db, pPk), nPk);
        
// ABS Label 438
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}

// ABS Label 439
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 439);
}

// ABS Label 440
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 440);
}

// ABS Label 441
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 441);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);
      }
    }
  }

  
// ABS Label 442
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}

// ROR Label 443
if((pUpsert != 0) != (pUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 443);
}
if( pUpsert==0 ){
    
// ABS Label 444
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
// ABS Label 445
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// COR Label 446
if((nChangeFrom == 0 || eOnePass != 2) != (nChangeFrom == 0 && eOnePass != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 446);
}

// ROR Label 447
if((nChangeFrom != 0) != (nChangeFrom == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((eOnePass == 2) != (eOnePass != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}

// MCC Label 449
if(nChangeFrom == 0 && eOnePass != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 449);
}
// MCC Label 450
if(nChangeFrom == 0 && !(eOnePass != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 450);
}
// MCC Label 451
if(!(nChangeFrom == 0) && eOnePass != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 451);
}
// MCC Label 452
if(!(nChangeFrom == 0) && !(eOnePass != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 452);
}
if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){
      
// ABS Label 453
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
sqlite3WhereEnd(pWInfo);
    }
  
    if( !isView ){
      int addrOnce = 0;
  
      /* Open every index that needs updating. */
      
// ABS Label 458
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}

// ROR Label 459
if((eOnePass == 0) != (eOnePass != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 459);
}
if( eOnePass!=ONEPASS_OFF ){
        
// ABS Label 460
if(aiCurOnePass[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 460);
}

// ROR Label 461
if((aiCurOnePass[0] < 0) != (aiCurOnePass[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}
// ROR Label 462
if((aiCurOnePass[0] > 0) != (aiCurOnePass[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
// ROR Label 463
if((aiCurOnePass[0] <= 0) != (aiCurOnePass[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 463);
}
if( aiCurOnePass[0]>=0 ) { aToOpen[aiCurOnePass[0]-iBaseCur] = 0;
}
        
// ABS Label 464
if(aiCurOnePass[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 464);
}

// ROR Label 465
if((aiCurOnePass[1] < 0) != (aiCurOnePass[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
// ROR Label 466
if((aiCurOnePass[1] > 0) != (aiCurOnePass[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 466);
}
// ROR Label 467
if((aiCurOnePass[1] <= 0) != (aiCurOnePass[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 467);
}
if( aiCurOnePass[1]>=0 ) { aToOpen[aiCurOnePass[1]-iBaseCur] = 0;
}
      }
  
      
// ABS Label 468
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 468);
}

// COR Label 469
if((eOnePass == 2 || (nIdx - (aiCurOnePass[1] >= 0)) > 0) != (eOnePass == 2 && (nIdx - (aiCurOnePass[1] >= 0)) > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 469);
}

// ROR Label 470
if((eOnePass != 2) != (eOnePass == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 470);
}
// ROR Label 471
if(((nIdx - (aiCurOnePass[1] >= 0)) <= 0) != ((nIdx - (aiCurOnePass[1] >= 0)) > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 471);
}
// ROR Label 472
if(((nIdx - (aiCurOnePass[1] >= 0)) < 0) != ((nIdx - (aiCurOnePass[1] >= 0)) > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 472);
}
// ROR Label 473
if(((nIdx - (aiCurOnePass[1] >= 0)) >= 0) != ((nIdx - (aiCurOnePass[1] >= 0)) > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 473);
}

// MCC Label 474
if(eOnePass == 2 && (nIdx - (aiCurOnePass[1] >= 0)) > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 474);
}
// MCC Label 475
if(eOnePass == 2 && !((nIdx - (aiCurOnePass[1] >= 0)) > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 475);
}
// MCC Label 476
if(!(eOnePass == 2) && (nIdx - (aiCurOnePass[1] >= 0)) > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 476);
}
// MCC Label 477
if(!(eOnePass == 2) && !((nIdx - (aiCurOnePass[1] >= 0)) > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 477);
}
if( eOnePass==ONEPASS_MULTI && (nIdx-(aiCurOnePass[1]>=0))>0 ){
        addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
      }
      
// ABS Label 454
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}

// ABS Label 455
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}

// ABS Label 456
if(iBaseCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}

// ABS Label 457
if(aToOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, iBaseCur,
                                 aToOpen, 0, 0);
      
// ABS Label 478
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}
if( addrOnce ){
        
// ABS Label 479
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// ABS Label 480
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}
sqlite3VdbeJumpHereOrPopInst(v, addrOnce);
      }
    }
  
    /* Top of the update loop */
    
// ABS Label 481
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}

// ROR Label 482
if((eOnePass == 0) != (eOnePass != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 482);
}
if( eOnePass!=ONEPASS_OFF ){
      
// ABS Label 485
if(aiCurOnePass[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}
// ABS Label 486
if(aiCurOnePass[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
// ABS Label 487
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}

// COR Label 488
if((aiCurOnePass[0] != iDataCur || aiCurOnePass[1] != iDataCur) != (aiCurOnePass[0] != iDataCur && aiCurOnePass[1] != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 488);
}

// ROR Label 489
if((aiCurOnePass[0] == iDataCur) != (aiCurOnePass[0] != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 489);
}
// ROR Label 490
if((aiCurOnePass[1] == iDataCur) != (aiCurOnePass[1] != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 490);
}

// MCC Label 491
if(aiCurOnePass[0] != iDataCur && aiCurOnePass[1] != iDataCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 491);
}
// MCC Label 492
if(aiCurOnePass[0] != iDataCur && !(aiCurOnePass[1] != iDataCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 492);
}
// MCC Label 493
if(!(aiCurOnePass[0] != iDataCur) && aiCurOnePass[1] != iDataCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 493);
}
// MCC Label 494
if(!(aiCurOnePass[0] != iDataCur) && !(aiCurOnePass[1] != iDataCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
if( aiCurOnePass[0]!=iDataCur
       && aiCurOnePass[1]!=iDataCur
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
       && !isView
#endif
      ){
        assert( pPk );
        
// ABS Label 495
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 495);
}

// ABS Label 496
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 496);
}

// ABS Label 497
if(labelBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// ABS Label 498
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 498);
}

// ABS Label 499
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 499);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelBreak, regKey,nKey);
        VdbeCoverage(v);
      }
      
// ABS Label 500
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}

// ROR Label 501
if((eOnePass == 1) != (eOnePass != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 501);
}
if( eOnePass!=ONEPASS_SINGLE ){
        labelContinue = sqlite3VdbeMakeLabel(pParse);
      }
      
// ABS Label 483
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}

// ABS Label 484
if(labelBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}
sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);
      VdbeCoverageIf(v, pPk==0);
      VdbeCoverageIf(v, pPk!=0);
    }else { 
// ABS Label 502
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 502);
}
// ABS Label 503
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 503);
}

// COR Label 504
if((pPk && nChangeFrom) != (pPk || nChangeFrom))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 504);
}

// MCC Label 505
if(pPk && nChangeFrom ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(pPk && !(nChangeFrom) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(!(pPk) && nChangeFrom ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(!(pPk) && !(nChangeFrom) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
if( pPk || nChangeFrom ){
      labelContinue = sqlite3VdbeMakeLabel(pParse);
      
// ABS Label 509
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}

// ABS Label 510
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}

// ABS Label 511
if(labelBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}
sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);
      addrTop = sqlite3VdbeCurrentAddr(v);
      
// ABS Label 512
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}
if( nChangeFrom ){
        if( !isView ){
          
// ABS Label 513
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}
if( pPk ){
            i = 0;

// ABS Label 518
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}

// ROR Label 519
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 519);
}
// ROR Label 520
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 520);
}
// ROR Label 521
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 521);
}
for(; i<nPk; i++){
              
// ABS Label 526
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// ABS Label 527
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}

// ABS Label 528
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}

// ABS Label 529
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}
// ABS Label 530
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}

// AOR Label 531
if(iPk - i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 531);
}
// AOR Label 532
if(iPk / i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 532);
}
// AOR Label 533
if(iPk * i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 533);
}
sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);
            };
// ABS Label 522
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 522);
}

// ROR Label 523
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 523);
}
// ROR Label 524
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
// ROR Label 525
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 525);
}

            
// ABS Label 514
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}

// ABS Label 515
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}

// ABS Label 516
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}

// ABS Label 517
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}
sqlite3VdbeAddOp4Int(
                v, OP_NotFound, iDataCur, labelContinue, iPk, nPk
            ); VdbeCoverage(v);
          }else{
            
// ABS Label 534
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}

// ABS Label 535
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}

// ABS Label 536
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);
            
// ABS Label 537
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}

// ABS Label 538
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 538);
}

// ABS Label 539
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}

// ABS Label 540
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}
sqlite3VdbeAddOp3(
                v, OP_NotExists, iDataCur, labelContinue, regOldRowid
            ); VdbeCoverage(v);
          }
        }
      }else{
        
// ABS Label 541
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}

// ABS Label 542
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}

// ABS Label 543
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}
sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);
        
// ABS Label 544
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 544);
}

// ABS Label 545
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}

// ABS Label 546
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}

// ABS Label 547
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);
        VdbeCoverage(v);
      }
    }else{
      
// ABS Label 548
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}

// ABS Label 549
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}

// ABS Label 550
if(labelBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}
sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);
      labelContinue = sqlite3VdbeMakeLabel(pParse);
      addrTop = sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);
      VdbeCoverage(v);
      
// ABS Label 551
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 551);
}

// ABS Label 552
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}

// ABS Label 553
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}

// ABS Label 554
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}
sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);
      VdbeCoverage(v);
    };}

  }

  /* If the rowid value will change, set register regNewRowid to
  ** contain the new value. If the rowid is not being modified,
  ** then regNewRowid is the same register as regOldRowid, which is
  ** already populated.  */
  assert( chngKey || pTrigger || hasFK || regOldRowid==regNewRowid );
  
// ABS Label 555
if(chngRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 555);
}
if( chngRowid ){
    assert( iRowidExpr>=0 );
    
// ABS Label 558
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// ROR Label 559
if((nChangeFrom != 0) != (nChangeFrom == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 559);
}
if( nChangeFrom==0 ){
      
// ABS Label 560
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 560);
}

// ABS Label 561
if(pRowidExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}

// ABS Label 562
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}
sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
    }else{
      
// ABS Label 563
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 563);
}

// ABS Label 564
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 564);
}

// ABS Label 565
if(iRowidExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 565);
}

// ABS Label 566
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 566);
}
sqlite3VdbeAddOp3(v, OP_Column, iEph, iRowidExpr, regNewRowid);
    }
    
// ABS Label 556
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}

// ABS Label 557
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}
sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); VdbeCoverage(v);
  }

  /* Compute the old pre-UPDATE content of the row being changed, if that
  ** information is needed */
  
// ABS Label 567
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}
// ABS Label 568
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 568);
}

// COR Label 569
if((chngPk || hasFK && pTrigger) != (chngPk || hasFK || pTrigger))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 569);
}
// COR Label 570
if((chngPk && hasFK) != (chngPk || hasFK))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 570);
}

// MCC Label 571
if(chngPk && hasFK && pTrigger ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 571);
}
// MCC Label 572
if(chngPk && hasFK && !(pTrigger) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 572);
}
// MCC Label 573
if(chngPk && !(hasFK) && pTrigger ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 573);
}
// MCC Label 574
if(chngPk && !(hasFK) && !(pTrigger) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 574);
}
// MCC Label 575
if(!(chngPk) && hasFK && pTrigger ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(!(chngPk) && hasFK && !(pTrigger) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
// MCC Label 577
if(!(chngPk) && !(hasFK) && pTrigger ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 577);
}
// MCC Label 578
if(!(chngPk) && !(hasFK) && !(pTrigger) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
if( chngPk || hasFK || pTrigger ){
    u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);
    oldmask |= sqlite3TriggerColmask(pParse, 
        pTrigger, pChanges, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onError
    );
    i = 0;

// ABS Label 579
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}

// ROR Label 580
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 580);
}
// ROR Label 581
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 581);
}
// ROR Label 582
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 582);
}
for(; i<pTab->nCol; i++){
      u32 colFlags = pTab->aCol[i].colFlags;
      k = sqlite3TableColumnToStorage(pTab, i) + regOld;
      
// ABS Label 587
if(oldmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 587);
}

// COR Label 588
if((oldmask == 4294967295U || (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0) && (colFlags & 1) != 0) != (oldmask == 4294967295U || (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0) || (colFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 588);
}
// COR Label 589
if((oldmask == 4294967295U && (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0)) != (oldmask == 4294967295U || (i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 589);
}

// ROR Label 590
if((oldmask != 4294967295U) != (oldmask == 4294967295U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 590);
}
// ROR Label 591
if(((colFlags & 1) == 0) != ((colFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 591);
}

// MCC Label 592
if(oldmask == 4294967295U && ( i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0 ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 592);
}
// MCC Label 593
if(oldmask == 4294967295U && ( i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0 ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 593);
}
// MCC Label 594
if(oldmask == 4294967295U && ( i < 32 && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 594);
}
// MCC Label 595
if(oldmask == 4294967295U && ( i < 32 && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(oldmask == 4294967295U && ( !(i < 32) && (oldmask & (((unsigned int)1) << (i))) != 0 ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
// MCC Label 597
if(oldmask == 4294967295U && ( !(i < 32) && (oldmask & (((unsigned int)1) << (i))) != 0 ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(oldmask == 4294967295U && ( !(i < 32) && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}
// MCC Label 599
if(oldmask == 4294967295U && ( !(i < 32) && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 599);
}
// MCC Label 600
if(!(oldmask == 4294967295U) && ( i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0 ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 600);
}
// MCC Label 601
if(!(oldmask == 4294967295U) && ( i < 32 && (oldmask & (((unsigned int)1) << (i))) != 0 ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 601);
}
// MCC Label 602
if(!(oldmask == 4294967295U) && ( i < 32 && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 602);
}
// MCC Label 603
if(!(oldmask == 4294967295U) && ( i < 32 && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 603);
}
// MCC Label 604
if(!(oldmask == 4294967295U) && ( !(i < 32) && (oldmask & (((unsigned int)1) << (i))) != 0 ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 604);
}
// MCC Label 605
if(!(oldmask == 4294967295U) && ( !(i < 32) && (oldmask & (((unsigned int)1) << (i))) != 0 ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 605);
}
// MCC Label 606
if(!(oldmask == 4294967295U) && ( !(i < 32) && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && (colFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 606);
}
// MCC Label 607
if(!(oldmask == 4294967295U) && ( !(i < 32) && !((oldmask & (((unsigned int)1) << (i))) != 0) ) && !((colFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 607);
}
if( oldmask==0xffffffff
       || (i<32 && (oldmask & MASKBIT32(i))!=0)
       || (colFlags & COLFLAG_PRIMKEY)!=0
      ){
        testcase(  oldmask!=0xffffffff && i==31 );
        
// ABS Label 608
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}

// ABS Label 609
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}

// ABS Label 610
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}

// ABS Label 611
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 611);
}

// ABS Label 612
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);
      }else{
        
// ABS Label 613
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}

// ABS Label 614
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 614);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, k);
      }
    };
// ABS Label 583
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 583);
}

// ROR Label 584
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 584);
}
// ROR Label 585
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 585);
}
// ROR Label 586
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 586);
}

    
// ABS Label 615
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 615);
}

// COR Label 616
if((chngRowid == 0 || pPk == 0) != (chngRowid == 0 && pPk == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 616);
}

// ROR Label 617
if((chngRowid != 0) != (chngRowid == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 617);
}
// ROR Label 618
if((pPk != 0) != (pPk == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 618);
}

// MCC Label 619
if(chngRowid == 0 && pPk == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 619);
}
// MCC Label 620
if(chngRowid == 0 && !(pPk == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 620);
}
// MCC Label 621
if(!(chngRowid == 0) && pPk == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 621);
}
// MCC Label 622
if(!(chngRowid == 0) && !(pPk == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 622);
}
if( chngRowid==0 && pPk==0 ){
      
// ABS Label 623
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}

// ABS Label 624
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 624);
}

// ABS Label 625
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 625);
}
sqlite3VdbeAddOp2(v, OP_Copy, regOldRowid, regNewRowid);
    }
  }

  /* Populate the array of registers beginning at regNew with the new
  ** row data. This array is used to check constants, create the new
  ** table and index records, and as the values for any new.* references
  ** made by triggers.
  **
  ** If there are one or more BEFORE triggers, then do not populate the
  ** registers associated with columns that are (a) not modified by
  ** this UPDATE statement and (b) not accessed by new.* references. The
  ** values for registers not modified by the UPDATE must be reloaded from 
  ** the database after the BEFORE triggers are fired anyway (as the trigger 
  ** may have modified them). So not loading those that are not going to
  ** be used eliminates some redundant opcodes.
  */
  newmask = sqlite3TriggerColmask(
      pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError
  );
  i = 0 , k = regNew;

// ABS Label 626
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 626);
}

// ROR Label 627
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 627);
}
// ROR Label 628
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 628);
}
// ROR Label 629
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 629);
}
for(; i<pTab->nCol; i++, k++){
    
// ABS Label 634
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}

// ROR Label 635
if((i != pTab->iPKey) != (i == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 635);
}
if( i==pTab->iPKey ){
      
// ABS Label 636
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 636);
}

// ABS Label 637
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, k);
    }else { 
// ROR Label 638
if(((pTab->aCol[i].colFlags & 96) == 0) != ((pTab->aCol[i].colFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 638);
}
if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)!=0 ){
      
// AOR Label 639
if(pTab->aCol[i].colFlags | 32 != pTab->aCol[i].colFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 639);
}
// AOR Label 640
if(pTab->aCol[i].colFlags ^ 32 != pTab->aCol[i].colFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 640);
}
if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) { k--;
}
    }else{
      j = aXRef[i];
      
// ABS Label 641
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}

// ROR Label 642
if((j < 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}
// ROR Label 643
if((j > 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 643);
}
// ROR Label 644
if((j <= 0) != (j >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 644);
}
if( j>=0 ){
        
// ABS Label 645
if(nChangeFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}
if( nChangeFrom ){
          int nOff = (isView ? pTab->nCol : nPk);
          assert( eOnePass==ONEPASS_OFF );
          
// ABS Label 646
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}

// ABS Label 647
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}

// ABS Label 648
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}
// ABS Label 649
if(nOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}

// AOR Label 650
if(nOff - j != nOff + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 650);
}
// AOR Label 651
if(nOff / j != nOff + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 651);
}
// AOR Label 652
if(nOff * j != nOff + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 652);
}

// ABS Label 653
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}
sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);
        }else{
          
// ABS Label 654
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}

// ABS Label 655
if(pChanges->a[j].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 655);
}

// ABS Label 656
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}
sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);
        }
      }else { 
// ABS Label 657
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}

// COR Label 658
if((0 == (tmask & 1) || i > 31 && (newmask & (((unsigned int)1) << (i)))) != (0 == (tmask & 1) || i > 31 || (newmask & (((unsigned int)1) << (i)))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 658);
}
// COR Label 659
if((0 == (tmask & 1) && i > 31) != (0 == (tmask & 1) || i > 31))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 659);
}

// ROR Label 660
if((0 != (tmask & 1)) != (0 == (tmask & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 660);
}
// ROR Label 661
if((i <= 31) != (i > 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 661);
}
// ROR Label 662
if((i < 31) != (i > 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
// ROR Label 663
if((i >= 31) != (i > 31))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 663);
}

// MCC Label 664
if(0 == (tmask & 1) && i > 31 && ( newmask & (((unsigned int)1) << (i)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 664);
}
// MCC Label 665
if(0 == (tmask & 1) && i > 31 && ( !(newmask & (((unsigned int)1) << (i))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 665);
}
// MCC Label 666
if(0 == (tmask & 1) && !(i > 31) && ( newmask & (((unsigned int)1) << (i)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 666);
}
// MCC Label 667
if(0 == (tmask & 1) && !(i > 31) && ( !(newmask & (((unsigned int)1) << (i))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 667);
}
// MCC Label 668
if(!(0 == (tmask & 1)) && i > 31 && ( newmask & (((unsigned int)1) << (i)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 668);
}
// MCC Label 669
if(!(0 == (tmask & 1)) && i > 31 && ( !(newmask & (((unsigned int)1) << (i))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 669);
}
// MCC Label 670
if(!(0 == (tmask & 1)) && !(i > 31) && ( newmask & (((unsigned int)1) << (i)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 670);
}
// MCC Label 671
if(!(0 == (tmask & 1)) && !(i > 31) && ( !(newmask & (((unsigned int)1) << (i))) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 671);
}
if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){
        /* This branch loads the value of a column that will not be changed 
        ** into a register. This is done if there are no BEFORE triggers, or
        ** if there are one or more BEFORE triggers that use this value via
        ** a new.* reference in a trigger program.
        */
        testcase( i==31 );
        testcase( i==32 );
        
// ABS Label 672
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}

// ABS Label 673
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}

// ABS Label 674
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}

// ABS Label 675
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}

// ABS Label 676
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);
        bFinishSeek = 0;
      }else{
        
// ABS Label 677
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}

// ABS Label 678
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, k);
      };}

    };}

  };
// ABS Label 630
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}

// ROR Label 631
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}
// ROR Label 632
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 632);
}
// ROR Label 633
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 633);
}

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
  
// ABS Label 679
if(pTab->tabFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}

// AOR Label 680
if(pTab->tabFlags | 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 680);
}
// AOR Label 681
if(pTab->tabFlags ^ 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 681);
}
if( pTab->tabFlags & TF_HasGenerated ){
    testcase( pTab->tabFlags & TF_HasVirtual );
    testcase( pTab->tabFlags & TF_HasStored );
    
// ABS Label 682
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 682);
}

// ABS Label 683
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}

// ABS Label 684
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 684);
}
sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);
  }
#endif

  /* Fire any BEFORE UPDATE triggers. This happens before constraints are
  ** verified. One could argue that this is wrong.
  */
  
// ABS Label 685
if(tmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}

// AOR Label 686
if(tmask | 1 != tmask & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 686);
}
// AOR Label 687
if(tmask ^ 1 != tmask & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 687);
}
if( tmask&TRIGGER_BEFORE ){
    
// ABS Label 688
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}

// ABS Label 689
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}

// ABS Label 690
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}
sqlite3TableAffinity(v, pTab, regNew);
    
// ABS Label 691
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}

// ABS Label 692
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}

// ABS Label 693
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 693);
}

// ABS Label 694
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}

// ABS Label 695
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}

// ABS Label 696
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}

// ABS Label 697
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}
sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges, 
        TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);

    if( !isView ){
      /* The row-trigger may have deleted the row being updated. In this
      ** case, jump to the next row. No updates or AFTER triggers are 
      ** required. This behavior - what happens when the row being updated
      ** is deleted or renamed by a BEFORE trigger - is left undefined in the
      ** documentation.
      */
      
// ABS Label 698
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 698);
}
if( pPk ){
        
// ABS Label 699
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 699);
}

// ABS Label 700
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}

// ABS Label 701
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}

// ABS Label 702
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}

// ABS Label 703
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 703);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);
        VdbeCoverage(v);
      }else{
        
// ABS Label 704
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 704);
}

// ABS Label 705
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}

// ABS Label 706
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}

// ABS Label 707
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}
sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);
        VdbeCoverage(v);
      }

      /* After-BEFORE-trigger-reload-loop:
      ** If it did not delete it, the BEFORE trigger may still have modified 
      ** some of the columns of the row being updated. Load the values for 
      ** all columns not modified by the update statement into their registers
      ** in case this has happened. Only unmodified columns are reloaded.
      ** The values computed for modified columns use the values before the
      ** BEFORE trigger runs.  See test case trigger1-18.0 (added 2018-04-26)
      ** for an example.
      */
      i = 0 , k = regNew;

// ABS Label 708
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 708);
}

// ROR Label 709
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 709);
}
// ROR Label 710
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 710);
}
// ROR Label 711
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 711);
}
for(; i<pTab->nCol; i++, k++){
        
// AOR Label 716
if(pTab->aCol[i].colFlags | 96 != pTab->aCol[i].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 716);
}
// AOR Label 717
if(pTab->aCol[i].colFlags ^ 96 != pTab->aCol[i].colFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 717);
}
if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){
          
// AOR Label 718
if(pTab->aCol[i].colFlags | 32 != pTab->aCol[i].colFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 718);
}
// AOR Label 719
if(pTab->aCol[i].colFlags ^ 32 != pTab->aCol[i].colFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 719);
}
if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) { k--;
}
        }else { 
// ABS Label 720
if(aXRef[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 720);
}
// ABS Label 721
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}

// COR Label 722
if((aXRef[i] < 0 || i != pTab->iPKey) != (aXRef[i] < 0 && i != pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 722);
}

// ROR Label 723
if((aXRef[i] <= 0) != (aXRef[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}
// ROR Label 724
if((aXRef[i] > 0) != (aXRef[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 724);
}
// ROR Label 725
if((aXRef[i] >= 0) != (aXRef[i] < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 725);
}
// ROR Label 726
if((i == pTab->iPKey) != (i != pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 726);
}

// MCC Label 727
if(aXRef[i] < 0 && i != pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 727);
}
// MCC Label 728
if(aXRef[i] < 0 && !(i != pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 728);
}
// MCC Label 729
if(!(aXRef[i] < 0) && i != pTab->iPKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 729);
}
// MCC Label 730
if(!(aXRef[i] < 0) && !(i != pTab->iPKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 730);
}
if( aXRef[i]<0 && i!=pTab->iPKey ){
          
// ABS Label 731
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

// ABS Label 732
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}

// ABS Label 733
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 733);
}

// ABS Label 734
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 734);
}

// ABS Label 735
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 735);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);
        };}

      };
// ABS Label 712
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}

// ROR Label 713
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 713);
}
// ROR Label 714
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 714);
}
// ROR Label 715
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 715);
}

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
      
// ABS Label 736
if(pTab->tabFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// AOR Label 737
if(pTab->tabFlags | 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 737);
}
// AOR Label 738
if(pTab->tabFlags ^ 96 != pTab->tabFlags & 96)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 738);
}
if( pTab->tabFlags & TF_HasGenerated ){
        testcase( pTab->tabFlags & TF_HasVirtual );
        testcase( pTab->tabFlags & TF_HasStored );
        
// ABS Label 739
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 739);
}

// ABS Label 740
if(regNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}

// ABS Label 741
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}
sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);
      }
#endif 
    }
  }

  if( !isView ){
    /* Do constraint checks. */
    assert( regOldRowid>0 );
    
// ABS Label 742
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}

// ABS Label 743
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}

// ABS Label 744
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 744);
}

// ABS Label 745
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}

// ABS Label 746
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}

// ABS Label 747
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// ABS Label 748
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// ABS Label 749
if(chngKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}

// ABS Label 750
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 750);
}

// ABS Label 751
if(aXRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 751);
}
sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
        regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,
        aXRef, 0);

    /* If REPLACE conflict handling may have been used, or if the PK of the
    ** row is changing, then the GenerateConstraintChecks() above may have
    ** moved cursor iDataCur. Reseek it. */
    
// ABS Label 765
if(bReplace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}

// COR Label 766
if((bReplace && chngKey) != (bReplace || chngKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 766);
}

// MCC Label 767
if(bReplace && chngKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 767);
}
// MCC Label 768
if(bReplace && !(chngKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 768);
}
// MCC Label 769
if(!(bReplace) && chngKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 769);
}
// MCC Label 770
if(!(bReplace) && !(chngKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
if( bReplace || chngKey ){
      
// ABS Label 771
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 771);
}
if( pPk ){
        
// ABS Label 772
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 772);
}

// ABS Label 773
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}

// ABS Label 774
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}

// ABS Label 775
if(regKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// ABS Label 776
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);
      }else{
        
// ABS Label 777
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ABS Label 778
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}

// ABS Label 779
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 779);
}

// ABS Label 780
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}
sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);
      }
      VdbeCoverageNeverTaken(v);
    }

    /* Do FK constraint checks. */
    
// ABS Label 781
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}
if( hasFK ){
      
// ABS Label 782
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}

// ABS Label 783
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}

// ABS Label 784
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}

// ABS Label 785
if(aXRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}
sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);
    }

    /* Delete the index entries associated with the current record.  */
    
// ABS Label 752
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 752);
}

// ABS Label 753
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 753);
}

// ABS Label 754
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 754);
}

// ABS Label 755
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}

// ABS Label 756
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}
sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);

    /* We must run the OP_FinishSeek opcode to resolve a prior
    ** OP_DeferredSeek if there is any possibility that there have been
    ** no OP_Column opcodes since the OP_DeferredSeek was issued.  But
    ** we want to avoid the OP_FinishSeek if possible, as running it
    ** costs CPU cycles. */
    
// ABS Label 786
if(bFinishSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}
if( bFinishSeek ){
      
// ABS Label 787
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}

// ABS Label 788
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}
sqlite3VdbeAddOp1(v, OP_FinishSeek, iDataCur);
    }

    /* If changing the rowid value, or if there are foreign key constraints
    ** to process, delete the old record. Otherwise, add a noop OP_Delete
    ** to invoke the pre-update hook.
    **
    ** That (regNew==regnewRowid+1) is true is also important for the 
    ** pre-update hook. If the caller invokes preupdate_new(), the returned
    ** value is copied from memory cell (regNewRowid+1+iCol), where iCol
    ** is the column index supplied by the user.
    */
    assert( regNew==regNewRowid+1 );
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
    sqlite3VdbeAddOp3(v, OP_Delete, iDataCur,
        OPFLAG_ISUPDATE | ((hasFK>1 || chngKey) ? 0 : OPFLAG_ISNOOP),
        regNewRowid
    );
    if( eOnePass==ONEPASS_MULTI ){
      assert( hasFK==0 && chngKey==0 );
      sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);
    }
    if( !pParse->nested ){
      sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
    }
#else
    
// ABS Label 789
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}

// COR Label 790
if((hasFK > 1 && chngKey) != (hasFK > 1 || chngKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 790);
}

// ROR Label 791
if((hasFK <= 1) != (hasFK > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 791);
}
// ROR Label 792
if((hasFK < 1) != (hasFK > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 792);
}
// ROR Label 793
if((hasFK >= 1) != (hasFK > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 793);
}

// MCC Label 794
if(hasFK > 1 && chngKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 794);
}
// MCC Label 795
if(hasFK > 1 && !(chngKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 795);
}
// MCC Label 796
if(!(hasFK > 1) && chngKey ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 796);
}
// MCC Label 797
if(!(hasFK > 1) && !(chngKey) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 797);
}
if( hasFK>1 || chngKey ){
      
// ABS Label 798
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}

// ABS Label 799
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}
sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);
    }
#endif

    
// ABS Label 800
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}
if( hasFK ){
      
// ABS Label 801
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}

// ABS Label 802
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 802);
}

// ABS Label 803
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 803);
}

// ABS Label 804
if(aXRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}
sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);
    }
  
    /* Insert the new index entries and the new record. */
    
// ABS Label 757
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}

// ABS Label 758
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}

// ABS Label 759
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}

// ABS Label 760
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}

// ABS Label 761
if(regNewRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 761);
}

// ABS Label 762
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}

// AOR Label 763
if(4 & (eOnePass == 2 ? 2 : 0) != 4 | (eOnePass == 2 ? 2 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 763);
}
// AOR Label 764
if(4 ^ (eOnePass == 2 ? 2 : 0) != 4 | (eOnePass == 2 ? 2 : 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 764);
}
sqlite3CompleteInsertion(
        pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx, 
        OPFLAG_ISUPDATE | (eOnePass==ONEPASS_MULTI ? OPFLAG_SAVEPOSITION : 0), 
        0, 0
    );

    /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to
    ** handle rows (possibly in other tables) that refer via a foreign key
    ** to the row just updated. */ 
    
// ABS Label 805
if(hasFK < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}
if( hasFK ){
      
// ABS Label 806
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}

// ABS Label 807
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}

// ABS Label 808
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}

// ABS Label 809
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}

// ABS Label 810
if(aXRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}
sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);
    }
  }

  /* Increment the row counter 
  */
  
// ABS Label 811
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
if( regRowCount ){
    
// ABS Label 812
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}

// ABS Label 813
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}
sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);
  }

  
// ABS Label 76
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// ABS Label 77
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ABS Label 78
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}

// ABS Label 79
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ABS Label 80
if(regOldRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}

// ABS Label 81
if(onError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ABS Label 82
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges, 
      TRIGGER_AFTER, pTab, regOldRowid, onError, labelContinue);

  /* Repeat the above with the next record to be updated, until
  ** all record selected by the WHERE clause have been updated.
  */
  
// ABS Label 814
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ROR Label 815
if((eOnePass != 1) != (eOnePass == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 815);
}
if( eOnePass==ONEPASS_SINGLE ){
    /* Nothing to do at end-of-loop for a single-pass */
  }else { 
// ABS Label 816
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// ROR Label 817
if((eOnePass != 2) != (eOnePass == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 817);
}
if( eOnePass==ONEPASS_MULTI ){
    
// ABS Label 818
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}

// ABS Label 819
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}
sqlite3VdbeResolveLabel(v, labelContinue);
    
// ABS Label 820
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
sqlite3WhereEnd(pWInfo);
  }else{
    
// ABS Label 821
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}

// ABS Label 822
if(labelContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}
sqlite3VdbeResolveLabel(v, labelContinue);
    
// ABS Label 823
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}

// ABS Label 824
if(iEph < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ABS Label 825
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}
sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);
  };}

  
// ABS Label 83
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}

// ABS Label 84
if(labelBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
sqlite3VdbeResolveLabel(v, labelBreak);

  /* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */
  
// ABS Label 826
if(pParse->pTriggerTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}
// ABS Label 827
if(pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}

// COR Label 828
if((pParse->nested == 0 && pParse->pTriggerTab == 0 || pUpsert == 0) != (pParse->nested == 0 && pParse->pTriggerTab == 0 && pUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 828);
}
// COR Label 829
if((pParse->nested == 0 || pParse->pTriggerTab == 0) != (pParse->nested == 0 && pParse->pTriggerTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 829);
}

// ROR Label 830
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}
// ROR Label 831
if((pParse->pTriggerTab != 0) != (pParse->pTriggerTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 831);
}
// ROR Label 832
if((pUpsert != 0) != (pUpsert == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}

// MCC Label 833
if(pParse->nested == 0 && pParse->pTriggerTab == 0 && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 833);
}
// MCC Label 834
if(pParse->nested == 0 && pParse->pTriggerTab == 0 && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 834);
}
// MCC Label 835
if(pParse->nested == 0 && !(pParse->pTriggerTab == 0) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 835);
}
// MCC Label 836
if(pParse->nested == 0 && !(pParse->pTriggerTab == 0) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 836);
}
// MCC Label 837
if(!(pParse->nested == 0) && pParse->pTriggerTab == 0 && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 837);
}
// MCC Label 838
if(!(pParse->nested == 0) && pParse->pTriggerTab == 0 && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 838);
}
// MCC Label 839
if(!(pParse->nested == 0) && !(pParse->pTriggerTab == 0) && pUpsert == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 839);
}
// MCC Label 840
if(!(pParse->nested == 0) && !(pParse->pTriggerTab == 0) && !(pUpsert == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 840);
}
if( pParse->nested==0 && pParse->pTriggerTab==0 && pUpsert==0 ){
    
// ABS Label 841
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 841);
}
sqlite3AutoincrementEnd(pParse);
  }

  /*
  ** Return the number of rows that were changed, if we are tracking
  ** that information.
  */
  
// ABS Label 842
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 842);
}
if( regRowCount ){
    
// ABS Label 843
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 843);
}

// ABS Label 844
if(regRowCount < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 844);
}
sqlite3VdbeAddOp2(v, OP_ChngCntRow, regRowCount, 1);
    
// ABS Label 845
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}
sqlite3VdbeSetNumCols(v, 1);
    
// ABS Label 846
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}
sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows updated", SQLITE_STATIC);
  }

update_cleanup:
  sqlite3AuthContextPop(&sContext);
  
// ABS Label 85
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
sqlite3DbFree(db, aXRef); /* Also frees aRegIdx[] and aToOpen[] */
  
// ABS Label 86
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// ABS Label 87
if(pTabList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
sqlite3SrcListDelete(db, pTabList);
  
// ABS Label 88
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// ABS Label 89
if(pChanges < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
sqlite3ExprListDelete(db, pChanges);
  
// ABS Label 90
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ABS Label 91
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
sqlite3ExprDelete(db, pWhere);
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) 
  sqlite3ExprListDelete(db, pOrderBy);
  sqlite3ExprDelete(db, pLimit);
#endif
  return;
}
/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */
#ifdef isView
 #undef isView
#endif
#ifdef pTrigger
 #undef pTrigger
#endif

#ifndef SQLITE_OMIT_VIRTUALTABLE
/*
** Generate code for an UPDATE of a virtual table.
**
** There are two possible strategies - the default and the special 
** "onepass" strategy. Onepass is only used if the virtual table 
** implementation indicates that pWhere may match at most one row.
**
** The default strategy is to create an ephemeral table that contains
** for each row to be changed:
**
**   (A)  The original rowid of that row.
**   (B)  The revised rowid for the row.
**   (C)  The content of every column in the row.
**
** Then loop through the contents of this ephemeral table executing a
** VUpdate for each row. When finished, drop the ephemeral table.
**
** The "onepass" strategy does not use an ephemeral table. Instead, it
** stores the same values (A, B and C above) in a register array and
** makes a single invocation of VUpdate.
*/
static void updateVirtualTable(
  Parse *pParse,       /* The parsing context */
  SrcList *pSrc,       /* The virtual table to be modified */
  Table *pTab,         /* The virtual table */
  ExprList *pChanges,  /* The columns to change in the UPDATE statement */
  Expr *pRowid,        /* Expression used to recompute the rowid */
  int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */
  Expr *pWhere,        /* WHERE clause of the UPDATE statement */
  int onError          /* ON CONFLICT strategy */
){
  
// ABS Label 847
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}
Vdbe *v = pParse->pVdbe;  /* Virtual machine under construction */
  int ephemTab;             /* Table holding the result of the SELECT */
  int i;                    /* Loop counter */
  
// ABS Label 848
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}
sqlite3 *db = pParse->db; /* Database connection */
  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
  WhereInfo *pWInfo = 0;
  
// AOR Label 849
if(2 - pTab->nCol != 2 + pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 849);
}
// AOR Label 850
if(2 / pTab->nCol != 2 + pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 850);
}
// AOR Label 851
if(2 * pTab->nCol != 2 + pTab->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 851);
}
int nArg = 2 + pTab->nCol;      /* Number of arguments to VUpdate */
  int regArg;                     /* First register in VUpdate arg array */
  int regRec;                     /* Register in which to assemble record */
  int regRowid;                   /* Register for ephem table rowid */
  
// ABS Label 852
if(pSrc->a[0].iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}
int iCsr = pSrc->a[0].iCursor;  /* Cursor used for virtual table scan */
  int aDummy[2];                  /* Unused arg for sqlite3WhereOkOnePass() */
  int eOnePass;                   /* True to use onepass strategy */
  int addr;                       /* Address of OP_OpenEphemeral */

  /* Allocate nArg registers in which to gather the arguments for VUpdate. Then
  ** create and open the ephemeral table in which the records created from
  ** these arguments will be temporarily stored. */
  assert( v );
  ephemTab = pParse->nTab++;
  addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);
  regArg = pParse->nMem + 1;
  pParse->nMem += nArg;
  
// ABS Label 861
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 861);
}

// ROR Label 862
if((pSrc->nSrc <= 1) != (pSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
// ROR Label 863
if((pSrc->nSrc < 1) != (pSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 863);
}
// ROR Label 864
if((pSrc->nSrc >= 1) != (pSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}
if( pSrc->nSrc>1 ){
    Index *pPk = 0;
    Expr *pRow;
    ExprList *pList;
    
// MCC Label 873
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 873);
}
// MCC Label 874
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 874);
}
if( HasRowid(pTab) ){
      
// ABS Label 875
if(pRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 875);
}
if( pRowid ){
        pRow = sqlite3ExprDup(db, pRowid, 0);
      }else{
        pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);
      }
    }else{
      i16 iPk;      /* PRIMARY KEY column */
      pPk = sqlite3PrimaryKeyIndex(pTab);
      assert( pPk!=0 );
      assert( pPk->nKeyCol==1 );
      iPk = pPk->aiColumn[0];
      
// ABS Label 876
if(aXRef[iPk] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}
// ABS Label 877
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}

// ROR Label 878
if((aXRef[iPk] < 0) != (aXRef[iPk] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 878);
}
// ROR Label 879
if((aXRef[iPk] > 0) != (aXRef[iPk] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 879);
}
// ROR Label 880
if((aXRef[iPk] <= 0) != (aXRef[iPk] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 880);
}
if( aXRef[iPk]>=0 ){
        pRow = sqlite3ExprDup(db, pChanges->a[aXRef[iPk]].pExpr, 0);
      }else{
        pRow = exprRowColumn(pParse, iPk);
      }
    }
    pList = sqlite3ExprListAppend(pParse, 0, pRow);

    i = 0;

// ABS Label 881
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 881);
}

// ROR Label 882
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 882);
}
// ROR Label 883
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 883);
}
// ROR Label 884
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 884);
}
for(; i<pTab->nCol; i++){
      
// ABS Label 889
if(aXRef[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 889);
}
// ABS Label 890
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 890);
}

// ROR Label 891
if((aXRef[i] < 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 891);
}
// ROR Label 892
if((aXRef[i] > 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
// ROR Label 893
if((aXRef[i] <= 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 893);
}
if( aXRef[i]>=0 ){
        pList = sqlite3ExprListAppend(pParse, pList,
          sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)
        );
      }else{
        pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));
      }
    };
// ABS Label 885
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 885);
}

// ROR Label 886
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}
// ROR Label 887
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}
// ROR Label 888
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}


    
// ABS Label 865
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 865);
}

// ABS Label 866
if(ephemTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 866);
}

// ABS Label 867
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 867);
}

// ABS Label 868
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 868);
}

// ABS Label 869
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 869);
}

// ABS Label 870
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}
updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, 0, 0);
    
// ABS Label 871
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}

// ABS Label 872
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
sqlite3ExprListDelete(db, pList);
    eOnePass = ONEPASS_OFF;
  }else{
    regRec = ++pParse->nMem;
    regRowid = ++pParse->nMem;

    /* Start scanning the virtual table */
    pWInfo = sqlite3WhereBegin(pParse, pSrc,pWhere,0,0,WHERE_ONEPASS_DESIRED,0);
    
// ABS Label 894
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}

// ROR Label 895
if((pWInfo != 0) != (pWInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 895);
}
if( pWInfo==0 ) { return;
}

    /* Populate the argument registers. */
    i = 0;

// ABS Label 896
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}

// ROR Label 897
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 897);
}
// ROR Label 898
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 898);
}
// ROR Label 899
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 899);
}
for(; i<pTab->nCol; i++){
      assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );
      
// ABS Label 904
if(aXRef[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 904);
}
// ABS Label 905
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}

// ROR Label 906
if((aXRef[i] < 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 906);
}
// ROR Label 907
if((aXRef[i] > 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 907);
}
// ROR Label 908
if((aXRef[i] <= 0) != (aXRef[i] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 908);
}
if( aXRef[i]>=0 ){
        
// ABS Label 909
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 909);
}

// ABS Label 910
if(pChanges->a[aXRef[i]].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}

// ABS Label 911
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}
// ABS Label 912
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 912);
}

// AOR Label 913
if(regArg + 2 - i != regArg + 2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 913);
}
// AOR Label 914
if(regArg + 2 / i != regArg + 2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 914);
}
// AOR Label 915
if(regArg + 2 * i != regArg + 2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 915);
}
// AOR Label 916
if(regArg - 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 916);
}
// AOR Label 917
if(regArg / 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 917);
}
// AOR Label 918
if(regArg * 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 918);
}
sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);
      }else{
        
// ABS Label 919
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}

// ABS Label 920
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}

// ABS Label 921
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}

// ABS Label 922
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}
// ABS Label 923
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}

// AOR Label 924
if(regArg + 2 - i != regArg + 2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 924);
}
// AOR Label 925
if(regArg + 2 / i != regArg + 2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 925);
}
// AOR Label 926
if(regArg + 2 * i != regArg + 2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 926);
}
// AOR Label 927
if(regArg - 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 927);
}
// AOR Label 928
if(regArg / 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 928);
}
// AOR Label 929
if(regArg * 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 929);
}
sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);
        
// ABS Label 930
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG);/* For sqlite3_vtab_nochange() */
      }
    };
// ABS Label 900
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 900);
}

// ROR Label 901
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 901);
}
// ROR Label 902
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 902);
}
// ROR Label 903
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 903);
}

    
// MCC Label 931
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 931);
}
// MCC Label 932
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 932);
}
if( HasRowid(pTab) ){
      
// ABS Label 933
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}

// ABS Label 934
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}

// ABS Label 935
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 935);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);
      
// ABS Label 936
if(pRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 936);
}
if( pRowid ){
        
// ABS Label 937
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}

// ABS Label 938
if(pRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}

// ABS Label 939
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}

// AOR Label 940
if(regArg - 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 940);
}
// AOR Label 941
if(regArg / 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 941);
}
// AOR Label 942
if(regArg * 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 942);
}
sqlite3ExprCode(pParse, pRowid, regArg+1);
      }else{
        
// ABS Label 943
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}

// ABS Label 944
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}

// ABS Label 945
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}

// AOR Label 946
if(regArg - 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 946);
}
// AOR Label 947
if(regArg / 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 947);
}
// AOR Label 948
if(regArg * 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 948);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);
      }
    }else{
      Index *pPk;   /* PRIMARY KEY index */
      i16 iPk;      /* PRIMARY KEY column */
      pPk = sqlite3PrimaryKeyIndex(pTab);
      assert( pPk!=0 );
      assert( pPk->nKeyCol==1 );
      iPk = pPk->aiColumn[0];
      
// ABS Label 949
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 949);
}

// ABS Label 950
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 950);
}

// ABS Label 951
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 951);
}
sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);
      
// ABS Label 952
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 952);
}

// ABS Label 953
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 953);
}

// AOR Label 954
if(regArg + 2 - iPk != regArg + 2 + iPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 954);
}
// AOR Label 955
if(regArg + 2 / iPk != regArg + 2 + iPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 955);
}
// AOR Label 956
if(regArg + 2 * iPk != regArg + 2 + iPk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 956);
}
// AOR Label 957
if(regArg - 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 957);
}
// AOR Label 958
if(regArg / 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 958);
}
// AOR Label 959
if(regArg * 2 != regArg + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 959);
}

// ABS Label 960
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 960);
}

// AOR Label 961
if(regArg - 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 961);
}
// AOR Label 962
if(regArg / 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 962);
}
// AOR Label 963
if(regArg * 1 != regArg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 963);
}
sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);
    }

    eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);

    /* There is no ONEPASS_MULTI on virtual tables */
    assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );

    
// ABS Label 964
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 964);
}
if( eOnePass ){
      /* If using the onepass strategy, no-op out the OP_OpenEphemeral coded
      ** above. */
      
// ABS Label 965
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// ABS Label 966
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 966);
}
sqlite3VdbeChangeToNoop(v, addr);
      
// ABS Label 967
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 967);
}

// ABS Label 968
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 968);
}
sqlite3VdbeAddOp1(v, OP_Close, iCsr);
    }else{
      /* Create a record from the argument register contents and insert it into
      ** the ephemeral table. */
      
// ABS Label 969
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 969);
}
sqlite3MultiWrite(pParse);
      
// ABS Label 970
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}

// ABS Label 971
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 971);
}

// ABS Label 972
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 972);
}

// ABS Label 973
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 973);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);
#if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)
      /* Signal an assert() within OP_MakeRecord that it is allowed to
      ** accept no-change records with serial_type 10 */
      sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);
#endif
      
// ABS Label 974
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 974);
}

// ABS Label 975
if(ephemTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 975);
}

// ABS Label 976
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}
sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);
      
// ABS Label 977
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 977);
}

// ABS Label 978
if(ephemTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}

// ABS Label 979
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 979);
}

// ABS Label 980
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}
sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);
    }
  }


  
// ABS Label 981
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 981);
}

// ROR Label 982
if((eOnePass != 0) != (eOnePass == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 982);
}
if( eOnePass==ONEPASS_OFF ){
    /* End the virtual table scan */
    
// ABS Label 983
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 983);
}

// ROR Label 984
if((pSrc->nSrc != 1) != (pSrc->nSrc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 984);
}
if( pSrc->nSrc==1 ){
      
// ABS Label 985
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}
sqlite3WhereEnd(pWInfo);
    }

    /* Begin scannning through the ephemeral table. */
    addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);

    /* Extract arguments from the current row of the ephemeral table and 
    ** invoke the VUpdate method.  */
    i = 0;

// ABS Label 986
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}
// ABS Label 987
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 987);
}

// ROR Label 988
if((i <= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 988);
}
// ROR Label 989
if((i > nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 989);
}
// ROR Label 990
if((i >= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 990);
}
for(; i<nArg; i++){
      
// ABS Label 996
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 996);
}

// ABS Label 997
if(ephemTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}

// ABS Label 998
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}

// ABS Label 999
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}
// ABS Label 1000
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}

// AOR Label 1001
if(regArg - i != regArg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1001);
}
// AOR Label 1002
if(regArg / i != regArg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1002);
}
// AOR Label 1003
if(regArg * i != regArg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1003);
}
sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i, regArg+i);
    };
// ABS Label 991
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 991);
}
// ABS Label 992
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 992);
}

// ROR Label 993
if((i <= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 993);
}
// ROR Label 994
if((i > nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 994);
}
// ROR Label 995
if((i >= nArg) != (i < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 995);
}

  }
  
// ABS Label 853
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 853);
}

// ABS Label 854
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}
sqlite3VtabMakeWritable(pParse, pTab);
  
// ABS Label 855
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}

// ABS Label 856
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}

// ABS Label 857
if(regArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 857);
}

// ABS Label 858
if(pVTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
sqlite3VdbeAddOp4(v, OP_VUpdate, 0, nArg, regArg, pVTab, P4_VTAB);
  
// ABS Label 859
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}
sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);
  
// ABS Label 860
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}
sqlite3MayAbort(pParse);

  /* End of the ephemeral table scan. Or, if using the onepass strategy,
  ** jump to here if the scan visited zero rows. */
  
// ABS Label 1004
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1004);
}

// ROR Label 1005
if((eOnePass != 0) != (eOnePass == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1005);
}
if( eOnePass==ONEPASS_OFF ){
    
// ABS Label 1006
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1006);
}

// ABS Label 1007
if(ephemTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1007);
}

// ABS Label 1008
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1008);
}

// AOR Label 1009
if(addr - 1 != addr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1009);
}
// AOR Label 1010
if(addr / 1 != addr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1010);
}
// AOR Label 1011
if(addr * 1 != addr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1011);
}
sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1); VdbeCoverage(v);
    
// ABS Label 1012
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1012);
}

// ABS Label 1013
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1013);
}
sqlite3VdbeJumpHere(v, addr);
    
// ABS Label 1014
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1014);
}

// ABS Label 1015
if(ephemTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}
sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);
  }else{
    
// ABS Label 1016
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}
sqlite3WhereEnd(pWInfo);
  }
}
#endif /* SQLITE_OMIT_VIRTUALTABLE */
