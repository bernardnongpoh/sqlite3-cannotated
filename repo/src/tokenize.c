/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** An tokenizer for SQL
**
** This file contains C code that splits an SQL input string up into
** individual tokens and sends those tokens one-by-one over to the
** parser for analysis.
*/
#include "sqliteInt.h"
#include <stdlib.h>

/* Character classes for tokenizing
**
** In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented
** using a lookup table, whereas a switch() directly on c uses a binary search.
** The lookup table is much faster.  To maximize speed, and to ensure that
** a lookup table is used, all of the classes need to be small integers and
** all of them need to be used within the switch.
*/
#define CC_X          0    /* The letter 'x', or start of BLOB literal */
#define CC_KYWD0      1    /* First letter of a keyword */
#define CC_KYWD       2    /* Alphabetics or '_'.  Usable in a keyword */
#define CC_DIGIT      3    /* Digits */
#define CC_DOLLAR     4    /* '$' */
#define CC_VARALPHA   5    /* '@', '#', ':'.  Alphabetic SQL variables */
#define CC_VARNUM     6    /* '?'.  Numeric SQL variables */
#define CC_SPACE      7    /* Space characters */
#define CC_QUOTE      8    /* '"', '\'', or '`'.  String literals, quoted ids */
#define CC_QUOTE2     9    /* '['.   [...] style quoted ids */
#define CC_PIPE      10    /* '|'.   Bitwise OR or concatenate */
#define CC_MINUS     11    /* '-'.  Minus or SQL-style comment */
#define CC_LT        12    /* '<'.  Part of < or <= or <> */
#define CC_GT        13    /* '>'.  Part of > or >= */
#define CC_EQ        14    /* '='.  Part of = or == */
#define CC_BANG      15    /* '!'.  Part of != */
#define CC_SLASH     16    /* '/'.  / or c-style comment */
#define CC_LP        17    /* '(' */
#define CC_RP        18    /* ')' */
#define CC_SEMI      19    /* ';' */
#define CC_PLUS      20    /* '+' */
#define CC_STAR      21    /* '*' */
#define CC_PERCENT   22    /* '%' */
#define CC_COMMA     23    /* ',' */
#define CC_AND       24    /* '&' */
#define CC_TILDA     25    /* '~' */
#define CC_DOT       26    /* '.' */
#define CC_ID        27    /* unicode characters usable in IDs */
#define CC_ILLEGAL   28    /* Illegal character */
#define CC_NUL       29    /* 0x00 */
#define CC_BOM       30    /* First byte of UTF8 BOM:  0xEF 0xBB 0xBF */

static const unsigned char aiClass[] = {
#ifdef SQLITE_ASCII
/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */
/* 0x */   29, 28, 28, 28, 28, 28, 28, 28, 28,  7,  7, 28,  7,  7, 28, 28,
/* 1x */   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
/* 2x */    7, 15,  8,  5,  4, 22, 24,  8, 17, 18, 21, 20, 23, 11, 26, 16,
/* 3x */    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  5, 19, 12, 14, 13,  6,
/* 4x */    5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
/* 5x */    1,  1,  1,  1,  1,  1,  1,  1,  0,  2,  2,  9, 28, 28, 28,  2,
/* 6x */    8,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
/* 7x */    1,  1,  1,  1,  1,  1,  1,  1,  0,  2,  2, 28, 10, 28, 25, 28,
/* 8x */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
/* 9x */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
/* Ax */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
/* Bx */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
/* Cx */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
/* Dx */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
/* Ex */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 30,
/* Fx */   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27
#endif
#ifdef SQLITE_EBCDIC
/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */
/* 0x */   29, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28,  7,  7, 28, 28,
/* 1x */   28, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
/* 2x */   28, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
/* 3x */   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
/* 4x */    7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 26, 12, 17, 20, 10,
/* 5x */   24, 28, 28, 28, 28, 28, 28, 28, 28, 28, 15,  4, 21, 18, 19, 28,
/* 6x */   11, 16, 28, 28, 28, 28, 28, 28, 28, 28, 28, 23, 22,  2, 13,  6,
/* 7x */   28, 28, 28, 28, 28, 28, 28, 28, 28,  8,  5,  5,  5,  8, 14,  8,
/* 8x */   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,
/* 9x */   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,
/* Ax */   28, 25,  1,  1,  1,  1,  1,  0,  2,  2, 28, 28, 28, 28, 28, 28,
/* Bx */   28, 28, 28, 28, 28, 28, 28, 28, 28, 28,  9, 28, 28, 28, 28, 28,
/* Cx */   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,
/* Dx */   28,  1,  1,  1,  1,  1,  1,  1,  1,  1, 28, 28, 28, 28, 28, 28,
/* Ex */   28, 28,  1,  1,  1,  1,  1,  0,  2,  2, 28, 28, 28, 28, 28, 28,
/* Fx */    3,  3,  3,  3,  3,  3,  3,  3,  3,  3, 28, 28, 28, 28, 28, 28,
#endif
};

/*
** The charMap() macro maps alphabetic characters (only) into their
** lower-case ASCII equivalent.  On ASCII machines, this is just
** an upper-to-lower case map.  On EBCDIC machines we also need
** to adjust the encoding.  The mapping is only valid for alphabetics
** which are the only characters for which this feature is used. 
**
** Used by keywordhash.h
*/
#ifdef SQLITE_ASCII
# define charMap(X) sqlite3UpperToLower[(unsigned char)X]
#endif
#ifdef SQLITE_EBCDIC
# define charMap(X) ebcdicToAscii[(unsigned char)X]
const unsigned char ebcdicToAscii[] = {
/* 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 0x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 1x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 2x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 3x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 4x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 5x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  /* 6x */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 7x */
   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /* 8x */
   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /* 9x */
   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /* Ax */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* Bx */
   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /* Cx */
   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /* Dx */
   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /* Ex */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* Fx */
};
#endif

/*
** The sqlite3KeywordCode function looks up an identifier to determine if
** it is a keyword.  If it is a keyword, the token code of that keyword is 
** returned.  If the input is not a keyword, TK_ID is returned.
**
** The implementation of this routine was generated by a program,
** mkkeywordhash.c, located in the tool subdirectory of the distribution.
** The output of the mkkeywordhash.c program is written into a file
** named keywordhash.h and then included into this source file by
** the #include below.
*/
#include "keywordhash.h"


/*
** If X is a character that can be used in an identifier then
** IdChar(X) will be true.  Otherwise it is false.
**
** For ASCII, any character with the high-order bit set is
** allowed in an identifier.  For 7-bit characters, 
** sqlite3IsIdChar[X] must be 1.
**
** For EBCDIC, the rules are more complex but have the same
** end result.
**
** Ticket #1066.  the SQL standard does not allow '$' in the
** middle of identifiers.  But many SQL implementations do. 
** SQLite will allow '$' in identifiers for compatibility.
** But the feature is undocumented.
*/
#ifdef SQLITE_ASCII
#define IdChar(C)  ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
#endif
#ifdef SQLITE_EBCDIC
const char sqlite3IsEbcdicIdChar[] = {
/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 4x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  /* 5x */
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  /* 6x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  /* 7x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  /* 8x */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  /* 9x */
    1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  /* Ax */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* Bx */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Cx */
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Dx */
    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Ex */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,  /* Fx */
};
#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))
#endif

/* Make the IdChar function accessible from ctime.c and alter.c */
int sqlite3IsIdChar(u8 c){ 
// MCC Label 65
if(( (sqlite3CtypeMap[(unsigned char)c] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 65);
}
// MCC Label 66
if(( !((sqlite3CtypeMap[(unsigned char)c] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
return IdChar(c); }

#ifndef SQLITE_OMIT_WINDOWFUNC
/*
** Return the id of the next token in string (*pz). Before returning, set
** (*pz) to point to the byte following the parsed token.
*/
static int getToken(const unsigned char **pz){
  
// ABS Label 67
if(*pz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
const unsigned char *z = *pz;
  int t;                          /* Token type to return */
  
// ABS Label 68
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}

// ROR Label 69
if((t != 182) != (t == 182))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
do {
    z += sqlite3GetToken(z, &t);
  }while( t==TK_SPACE );
// ABS Label 70
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((t != 182) != (t == 182))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
;
  if( t==TK_ID 
   || t==TK_STRING 
   || t==TK_JOIN_KW 
   || t==TK_WINDOW 
   || t==TK_OVER 
   || sqlite3ParserFallback(t)==TK_ID 
  ){
    t = TK_ID;
  }
  *pz = z;
  
// ABS Label 72
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
return t;
}

/*
** The following three functions are called immediately after the tokenizer
** reads the keywords WINDOW, OVER and FILTER, respectively, to determine
** whether the token should be treated as a keyword or an SQL identifier.
** This cannot be handled by the usual lemon %fallback method, due to
** the ambiguity in some constructions. e.g.
**
**   SELECT sum(x) OVER ...
**
** In the above, "OVER" might be a keyword, or it might be an alias for the 
** sum(x) expression. If a "%fallback ID OVER" directive were added to 
** grammar, then SQLite would always treat "OVER" as an alias, making it
** impossible to call a window-function without a FILTER clause.
**
** WINDOW is treated as a keyword if:
**
**   * the following token is an identifier, or a keyword that can fallback
**     to being an identifier, and
**   * the token after than one is TK_AS.
**
** OVER is a keyword if:
**
**   * the previous token was TK_RP, and
**   * the next token is either TK_LP or an identifier.
**
** FILTER is a keyword if:
**
**   * the previous token was TK_RP, and
**   * the next token is TK_LP.
*/
static int analyzeWindowKeyword(const unsigned char *z){
  int t;
  t = getToken(&z);
  
// ABS Label 73
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// ROR Label 74
if((t == 59) != (t != 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
if( t!=TK_ID ) { return TK_ID;
}
  t = getToken(&z);
  
// ABS Label 75
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ROR Label 76
if((t == 24) != (t != 24))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
if( t!=TK_AS ) { return TK_ID;
}
  return TK_WINDOW;
}
static int analyzeOverKeyword(const unsigned char *z, int lastToken){
  
// ABS Label 77
if(lastToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((lastToken != 23) != (lastToken == 23))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
if( lastToken==TK_RP ){
    int t = getToken(&z);
    
// ABS Label 79
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// COR Label 80
if((t == 22 && t == 59) != (t == 22 || t == 59))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 80);
}

// ROR Label 81
if((t != 22) != (t == 22))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
// ROR Label 82
if((t != 59) != (t == 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}

// MCC Label 83
if(t == 22 && t == 59 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
// MCC Label 84
if(t == 22 && !(t == 59) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 84);
}
// MCC Label 85
if(!(t == 22) && t == 59 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 85);
}
// MCC Label 86
if(!(t == 22) && !(t == 59) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 86);
}
if( t==TK_LP || t==TK_ID ) { return TK_OVER;
}
  }
  return TK_ID;
}
static int analyzeFilterKeyword(const unsigned char *z, int lastToken){
  if( lastToken==TK_RP && getToken(&z)==TK_LP ){
    return TK_FILTER;
  }
  return TK_ID;
}
#endif /* SQLITE_OMIT_WINDOWFUNC */

/*
** Return the length (in bytes) of the token that begins at z[0]. 
** Store the token type in *tokenType before returning.
*/
int sqlite3GetToken(const unsigned char *z, int *tokenType){
  int i, c;
  switch( aiClass[*z] ){  /* Switch on the character-class of the first byte
                          ** of the token. See the comment on the CC_ defines
                          ** above. */
    case CC_SPACE: {
      testcase( z[0]==' ' );
      testcase( z[0]=='\t' );
      testcase( z[0]=='\n' );
      testcase( z[0]=='\f' );
      testcase( z[0]=='\r' );
      i = 1;

// MCC Label 87
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 87);
}
// MCC Label 88
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 88);
}
for(; sqlite3Isspace(z[i]); i++){};
// MCC Label 89
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 89);
}
// MCC Label 90
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}

      *tokenType = TK_SPACE;
      
// ABS Label 91
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
return i;
    }
    case CC_MINUS: {
      
// ROR Label 92
if((z[1] != '-') != (z[1] == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
if( z[1]=='-' ){
        i = 2;
for(; (c=z[i])!=0 && c!='\n'; i++){};
        *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */
        
// ABS Label 93
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
return i;
      }
      *tokenType = TK_MINUS;
      return 1;
    }
    case CC_LP: {
      *tokenType = TK_LP;
      return 1;
    }
    case CC_RP: {
      *tokenType = TK_RP;
      return 1;
    }
    case CC_SEMI: {
      *tokenType = TK_SEMI;
      return 1;
    }
    case CC_PLUS: {
      *tokenType = TK_PLUS;
      return 1;
    }
    case CC_STAR: {
      *tokenType = TK_STAR;
      return 1;
    }
    case CC_SLASH: {
      
// COR Label 94
if((z[1] != '*' && z[2] == 0) != (z[1] != '*' || z[2] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 94);
}

// ROR Label 95
if((z[1] == '*') != (z[1] != '*'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
// ROR Label 96
if((z[2] != 0) != (z[2] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}

// MCC Label 97
if(z[1] != '*' && z[2] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
// MCC Label 98
if(z[1] != '*' && !(z[2] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 98);
}
// MCC Label 99
if(!(z[1] != '*') && z[2] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 99);
}
// MCC Label 100
if(!(z[1] != '*') && !(z[2] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 100);
}
if( z[1]!='*' || z[2]==0 ){
        *tokenType = TK_SLASH;
        return 1;
      }
      i = 3 , c = z[2];
for(; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){};
      
// ABS Label 101
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
if( c ) { i++;
}
      *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */
      
// ABS Label 102
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
return i;
    }
    case CC_PERCENT: {
      *tokenType = TK_REM;
      return 1;
    }
    case CC_EQ: {
      *tokenType = TK_EQ;
      
// AOR Label 103
if(1 - (z[1] == '=') != 1 + (z[1] == '='))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 103);
}
// AOR Label 104
if(1 / (z[1] == '=') != 1 + (z[1] == '='))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 104);
}
// AOR Label 105
if(1 * (z[1] == '=') != 1 + (z[1] == '='))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 105);
}
return 1 + (z[1]=='=');
    }
    case CC_LT: {
      if( (c=z[1])=='=' ){
        *tokenType = TK_LE;
        return 2;
      }else { 
// ABS Label 106
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// ROR Label 107
if((c != '>') != (c == '>'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}
if( c=='>' ){
        *tokenType = TK_NE;
        return 2;
      }else { 
// ABS Label 108
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}

// ROR Label 109
if((c != '<') != (c == '<'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}
if( c=='<' ){
        *tokenType = TK_LSHIFT;
        return 2;
      }else{
        *tokenType = TK_LT;
        return 1;
      };}
;}

    }
    case CC_GT: {
      if( (c=z[1])=='=' ){
        *tokenType = TK_GE;
        return 2;
      }else { 
// ABS Label 110
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// ROR Label 111
if((c != '>') != (c == '>'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 111);
}
if( c=='>' ){
        *tokenType = TK_RSHIFT;
        return 2;
      }else{
        *tokenType = TK_GT;
        return 1;
      };}

    }
    case CC_BANG: {
      
// ROR Label 112
if((z[1] == '=') != (z[1] != '='))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 112);
}
if( z[1]!='=' ){
        *tokenType = TK_ILLEGAL;
        return 1;
      }else{
        *tokenType = TK_NE;
        return 2;
      }
    }
    case CC_PIPE: {
      
// ROR Label 113
if((z[1] == '|') != (z[1] != '|'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
if( z[1]!='|' ){
        *tokenType = TK_BITOR;
        return 1;
      }else{
        *tokenType = TK_CONCAT;
        return 2;
      }
    }
    case CC_COMMA: {
      *tokenType = TK_COMMA;
      return 1;
    }
    case CC_AND: {
      *tokenType = TK_BITAND;
      return 1;
    }
    case CC_TILDA: {
      *tokenType = TK_BITNOT;
      return 1;
    }
    case CC_QUOTE: {
      int delim = z[0];
      testcase( delim=='`' );
      testcase( delim=='\'' );
      testcase( delim=='"' );
      i = 1;
for(; (c=z[i])!=0; i++){
        
// ABS Label 114
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
// ABS Label 115
if(delim < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// ROR Label 116
if((c != delim) != (c == delim))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
if( c==delim ){
          
// ABS Label 117
if(delim < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// ROR Label 118
if((z[i + 1] != delim) != (z[i + 1] == delim))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
if( z[i+1]==delim ){
            i++;
          }else{
            break;
          }
        }
      };
      
// ABS Label 119
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}

// ROR Label 120
if((c != '\'') != (c == '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
if( c=='\'' ){
        *tokenType = TK_STRING;
        
// ABS Label 121
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}

// AOR Label 122
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 122);
}
// AOR Label 123
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 123);
}
// AOR Label 124
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 124);
}
return i+1;
      }else { 
// ABS Label 125
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}

// ROR Label 126
if((c == 0) != (c != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
if( c!=0 ){
        *tokenType = TK_ID;
        
// ABS Label 127
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}

// AOR Label 128
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 128);
}
// AOR Label 129
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 129);
}
// AOR Label 130
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 130);
}
return i+1;
      }else{
        *tokenType = TK_ILLEGAL;
        
// ABS Label 131
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}
return i;
      };}

    }
    case CC_DOT: {
#ifndef SQLITE_OMIT_FLOATING_POINT
      if( !sqlite3Isdigit(z[1]) )
#endif
      {
        *tokenType = TK_DOT;
        return 1;
      }
      /* If the next character is a digit, this is a floating point
      ** number that begins with ".".  Fall thru into the next case */
      /* no break */ deliberate_fall_through
    }
    case CC_DIGIT: {
      testcase( z[0]=='0' );  testcase( z[0]=='1' );  testcase( z[0]=='2' );
      testcase( z[0]=='3' );  testcase( z[0]=='4' );  testcase( z[0]=='5' );
      testcase( z[0]=='6' );  testcase( z[0]=='7' );  testcase( z[0]=='8' );
      testcase( z[0]=='9' );
      *tokenType = TK_INTEGER;
#ifndef SQLITE_OMIT_HEX_INTEGER
      
// COR Label 132
if((z[0] == '0' && (z[1] == 'x' || z[1] == 'X') || (sqlite3CtypeMap[(unsigned char)(z[2])] & 8)) != (z[0] == '0' && (z[1] == 'x' || z[1] == 'X') && (sqlite3CtypeMap[(unsigned char)(z[2])] & 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 132);
}
// COR Label 133
if((z[0] == '0' || (z[1] == 'x' || z[1] == 'X')) != (z[0] == '0' && (z[1] == 'x' || z[1] == 'X')))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 133);
}

// ROR Label 134
if((z[0] != '0') != (z[0] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}

// MCC Label 135
if(z[0] == '0' && ( z[1] == 'x' && z[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
// MCC Label 136
if(z[0] == '0' && ( z[1] == 'x' && z[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 136);
}
// MCC Label 137
if(z[0] == '0' && ( z[1] == 'x' && !(z[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
// MCC Label 138
if(z[0] == '0' && ( z[1] == 'x' && !(z[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
// MCC Label 139
if(z[0] == '0' && ( !(z[1] == 'x') && z[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 139);
}
// MCC Label 140
if(z[0] == '0' && ( !(z[1] == 'x') && z[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 140);
}
// MCC Label 141
if(z[0] == '0' && ( !(z[1] == 'x') && !(z[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 141);
}
// MCC Label 142
if(z[0] == '0' && ( !(z[1] == 'x') && !(z[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 142);
}
// MCC Label 143
if(!(z[0] == '0') && ( z[1] == 'x' && z[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 143);
}
// MCC Label 144
if(!(z[0] == '0') && ( z[1] == 'x' && z[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 144);
}
// MCC Label 145
if(!(z[0] == '0') && ( z[1] == 'x' && !(z[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 145);
}
// MCC Label 146
if(!(z[0] == '0') && ( z[1] == 'x' && !(z[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 146);
}
// MCC Label 147
if(!(z[0] == '0') && ( !(z[1] == 'x') && z[1] == 'X' ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(!(z[0] == '0') && ( !(z[1] == 'x') && z[1] == 'X' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
// MCC Label 149
if(!(z[0] == '0') && ( !(z[1] == 'x') && !(z[1] == 'X') ) && ( sqlite3CtypeMap[(unsigned char)(z[2])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 149);
}
// MCC Label 150
if(!(z[0] == '0') && ( !(z[1] == 'x') && !(z[1] == 'X') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[2])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 150);
}
if( z[0]=='0' && (z[1]=='x' || z[1]=='X') && sqlite3Isxdigit(z[2]) ){
        i = 3;

// MCC Label 151
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 151);
}
// MCC Label 152
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 152);
}
for(; sqlite3Isxdigit(z[i]); i++){};
// MCC Label 153
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 153);
}
// MCC Label 154
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 154);
}

        
// ABS Label 155
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}
return i;
      }
#endif
      i = 0;

// MCC Label 156
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 156);
}
// MCC Label 157
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
for(; sqlite3Isdigit(z[i]); i++){};
// MCC Label 158
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
// MCC Label 159
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 159);
}

#ifndef SQLITE_OMIT_FLOATING_POINT
      
// ROR Label 160
if((z[i] != '.') != (z[i] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
if( z[i]=='.' ){
        i++;
        
// MCC Label 161
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 161);
}
// MCC Label 162
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 162);
}
while( sqlite3Isdigit(z[i]) ){ i++; };
// MCC Label 163
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 163);
}
// MCC Label 164
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}

        *tokenType = TK_FLOAT;
      }
      
// COR Label 165
if(((z[i] == 'e' || z[i] == 'E') || ((sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) || ((z[i + 1] == '+' || z[i + 1] == '-') && (sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4)))) != ((z[i] == 'e' || z[i] == 'E') && ((sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) || ((z[i + 1] == '+' || z[i + 1] == '-') && (sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4)))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 165);
}

// MCC Label 166
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
// MCC Label 168
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
// MCC Label 169
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
// MCC Label 170
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
// MCC Label 171
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 171);
}
// MCC Label 172
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}
// MCC Label 173
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 173);
}
// MCC Label 174
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 174);
}
// MCC Label 175
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 175);
}
// MCC Label 176
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(( z[i] == 'e' && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}
// MCC Label 185
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 185);
}
// MCC Label 186
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 186);
}
// MCC Label 187
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}
// MCC Label 188
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 188);
}
// MCC Label 189
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 189);
}
// MCC Label 190
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 190);
}
// MCC Label 191
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 191);
}
// MCC Label 192
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 192);
}
// MCC Label 193
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 193);
}
// MCC Label 194
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(( z[i] == 'e' && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
// MCC Label 198
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 198);
}
// MCC Label 199
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 199);
}
// MCC Label 200
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 200);
}
// MCC Label 201
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 201);
}
// MCC Label 202
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}
// MCC Label 203
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 203);
}
// MCC Label 204
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 204);
}
// MCC Label 205
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 205);
}
// MCC Label 206
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 206);
}
// MCC Label 207
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 207);
}
// MCC Label 208
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(( !(z[i] == 'e') && z[i] == 'E' ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
// MCC Label 217
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 217);
}
// MCC Label 218
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 218);
}
// MCC Label 219
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 219);
}
// MCC Label 220
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 220);
}
// MCC Label 221
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4 ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 221);
}
// MCC Label 222
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
// MCC Label 223
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( z[i + 1] == '+' && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && z[i + 1] == '-' ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4 ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(( !(z[i] == 'e') && !(z[i] == 'E') ) && ( ( !(sqlite3CtypeMap[(unsigned char)(z[i + 1])] & 4) ) && ( ( !(z[i + 1] == '+') && !(z[i + 1] == '-') ) && ( !(sqlite3CtypeMap[(unsigned char)(z[i + 2])] & 4) ) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
if( (z[i]=='e' || z[i]=='E') &&
           ( sqlite3Isdigit(z[i+1]) 
            || ((z[i+1]=='+' || z[i+1]=='-') && sqlite3Isdigit(z[i+2]))
           )
      ){
        i += 2;
        
// MCC Label 230
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
while( sqlite3Isdigit(z[i]) ){ i++; };
// MCC Label 232
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}

        *tokenType = TK_FLOAT;
      }
#endif
      
// MCC Label 234
if(( (sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
// MCC Label 235
if(( !((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
while( IdChar(z[i]) ){
        *tokenType = TK_ILLEGAL;
        i++;
      };
// MCC Label 236
if(( (sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
// MCC Label 237
if(( !((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 237);
}

      
// ABS Label 238
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}
return i;
    }
    case CC_QUOTE2: {
      i = 1 , c = z[0];
for(; c!=']' && (c=z[i])!=0; i++){};
      *tokenType = c==']' ? TK_ID : TK_ILLEGAL;
      
// ABS Label 239
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}
return i;
    }
    case CC_VARNUM: {
      *tokenType = TK_VARIABLE;
      i = 1;

// MCC Label 240
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}
for(; sqlite3Isdigit(z[i]); i++){};
// MCC Label 242
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 242);
}
// MCC Label 243
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 243);
}

      
// ABS Label 244
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}
return i;
    }
    case CC_DOLLAR:
    case CC_VARALPHA: {
      int n = 0;
      testcase( z[0]=='$' );  testcase( z[0]=='@' );
      testcase( z[0]==':' );  testcase( z[0]=='#' );
      *tokenType = TK_VARIABLE;
      i = 1;
for(; (c=z[i])!=0; i++){
        
// MCC Label 245
if(( (sqlite3CtypeMap[(unsigned char)c] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(( !((sqlite3CtypeMap[(unsigned char)c] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
if( IdChar(c) ){
          n++;
#ifndef SQLITE_OMIT_TCL_VARIABLE
        }else { 
// ABS Label 247
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
// ABS Label 248
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}

// COR Label 249
if((c == '(' || n > 0) != (c == '(' && n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 249);
}

// ROR Label 250
if((c != '(') != (c == '('))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((n <= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}
// ROR Label 252
if((n < 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((n >= 0) != (n > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}

// MCC Label 254
if(c == '(' && n > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 254);
}
// MCC Label 255
if(c == '(' && !(n > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
// MCC Label 256
if(!(c == '(') && n > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 256);
}
// MCC Label 257
if(!(c == '(') && !(n > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 257);
}
if( c=='(' && n>0 ){
          do{
            i++;
          }while( (c=z[i])!=0 && !sqlite3Isspace(c) && c!=')' );;
          
// ABS Label 258
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// ROR Label 259
if((c != ')') != (c == ')'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}
if( c==')' ){
            i++;
          }else{
            *tokenType = TK_ILLEGAL;
          }
          break;
        }else { 
// ABS Label 260
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}

// COR Label 261
if((c == ':' || z[i + 1] == ':') != (c == ':' && z[i + 1] == ':'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 261);
}

// ROR Label 262
if((c != ':') != (c == ':'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((z[i + 1] != ':') != (z[i + 1] == ':'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}

// MCC Label 264
if(c == ':' && z[i + 1] == ':' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(c == ':' && !(z[i + 1] == ':') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(!(c == ':') && z[i + 1] == ':' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(!(c == ':') && !(z[i + 1] == ':') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
if( c==':' && z[i+1]==':' ){
          i++;
#endif
        }else{
          break;
        };}
;}

      };
      
// ABS Label 268
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}

// ROR Label 269
if((n != 0) != (n == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}
if( n==0 ) { *tokenType = TK_ILLEGAL;
}
      
// ABS Label 270
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
return i;
    }
    case CC_KYWD0: {
      i = 1;

// ROR Label 271
if((aiClass[z[i]] < 2) != (aiClass[z[i]] <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 271);
}
// ROR Label 272
if((aiClass[z[i]] > 2) != (aiClass[z[i]] <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 272);
}
// ROR Label 273
if((aiClass[z[i]] >= 2) != (aiClass[z[i]] <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
for(; aiClass[z[i]]<=CC_KYWD; i++){};
// ROR Label 274
if((aiClass[z[i]] < 2) != (aiClass[z[i]] <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 274);
}
// ROR Label 275
if((aiClass[z[i]] > 2) != (aiClass[z[i]] <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 275);
}
// ROR Label 276
if((aiClass[z[i]] >= 2) != (aiClass[z[i]] <= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 276);
}

      
// MCC Label 277
if(( (sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 277);
}
// MCC Label 278
if(( !((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}
if( IdChar(z[i]) ){
        /* This token started out using characters that can appear in keywords,
        ** but z[i] is a character not allowed within keywords, so this must
        ** be an identifier instead */
        i++;
        break;
      }
      *tokenType = TK_ID;
      return keywordCode((char*)z, i, tokenType);
    }
    case CC_X: {
#ifndef SQLITE_OMIT_BLOB_LITERAL
      testcase( z[0]=='x' ); testcase( z[0]=='X' );
      
// ROR Label 279
if((z[1] != '\'') != (z[1] == '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
if( z[1]=='\'' ){
        *tokenType = TK_BLOB;
        i = 2;

// MCC Label 280
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 280);
}
// MCC Label 281
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 281);
}
for(; sqlite3Isxdigit(z[i]); i++){};
// MCC Label 282
if(( sqlite3CtypeMap[(unsigned char)(z[i])] & 8 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 282);
}
// MCC Label 283
if(( !(sqlite3CtypeMap[(unsigned char)(z[i])] & 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}

        
// ABS Label 284
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}

// AOR Label 285
if(i - 2 != i % 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 285);
}
// AOR Label 286
if(i + 2 != i % 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 286);
}
// AOR Label 287
if(i * 2 != i % 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 287);
}

// COR Label 288
if((z[i] != '\'' && i % 2) != (z[i] != '\'' || i % 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 288);
}

// ROR Label 289
if((z[i] == '\'') != (z[i] != '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}

// MCC Label 290
if(z[i] != '\'' && i % 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 290);
}
// MCC Label 291
if(z[i] != '\'' && !(i % 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 291);
}
// MCC Label 292
if(!(z[i] != '\'') && i % 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 292);
}
// MCC Label 293
if(!(z[i] != '\'') && !(i % 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 293);
}
if( z[i]!='\'' || i%2 ){
          *tokenType = TK_ILLEGAL;
          
// COR Label 294
if((z[i] || z[i] != '\'') != (z[i] && z[i] != '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 294);
}

// ROR Label 295
if((z[i] == '\'') != (z[i] != '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}

// MCC Label 296
if(z[i] && z[i] != '\'' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 296);
}
// MCC Label 297
if(z[i] && !(z[i] != '\'') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 297);
}
// MCC Label 298
if(!(z[i]) && z[i] != '\'' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 298);
}
// MCC Label 299
if(!(z[i]) && !(z[i] != '\'') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 299);
}
while( z[i] && z[i]!='\'' ){ i++; };
// COR Label 300
if((z[i] || z[i] != '\'') != (z[i] && z[i] != '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 300);
}

// ROR Label 301
if((z[i] == '\'') != (z[i] != '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}

// MCC Label 302
if(z[i] && z[i] != '\'' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 302);
}
// MCC Label 303
if(z[i] && !(z[i] != '\'') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 303);
}
// MCC Label 304
if(!(z[i]) && z[i] != '\'' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 304);
}
// MCC Label 305
if(!(z[i]) && !(z[i] != '\'') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 305);
}

        }
        
// ABS Label 306
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
// ABS Label 307
if(z[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
if( z[i] ) { i++;
}
        
// ABS Label 308
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}
return i;
      }
#endif
      /* If it is not a BLOB literal, then it must be an ID, since no
      ** SQL keywords start with the letter 'x'.  Fall through */
      /* no break */ deliberate_fall_through
    }
    case CC_KYWD:
    case CC_ID: {
      i = 1;
      break;
    }
    case CC_BOM: {
      
// COR Label 309
if((z[1] == 187 || z[2] == 191) != (z[1] == 187 && z[2] == 191))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 309);
}

// ROR Label 310
if((z[1] != 187) != (z[1] == 187))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((z[2] != 191) != (z[2] == 191))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}

// MCC Label 312
if(z[1] == 187 && z[2] == 191 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 312);
}
// MCC Label 313
if(z[1] == 187 && !(z[2] == 191) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 313);
}
// MCC Label 314
if(!(z[1] == 187) && z[2] == 191 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 314);
}
// MCC Label 315
if(!(z[1] == 187) && !(z[2] == 191) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 315);
}
if( z[1]==0xbb && z[2]==0xbf ){
        *tokenType = TK_SPACE;
        return 3;
      }
      i = 1;
      break;
    }
    case CC_NUL: {
      *tokenType = TK_ILLEGAL;
      return 0;
    }
    default: {
      *tokenType = TK_ILLEGAL;
      return 1;
    }
  }
  
// MCC Label 316
if(( (sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 316);
}
// MCC Label 317
if(( !((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 317);
}
while( IdChar(z[i]) ){ i++; };
// MCC Label 318
if(( (sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 318);
}
// MCC Label 319
if(( !((sqlite3CtypeMap[(unsigned char)z[i]] & 70) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 319);
}

  *tokenType = TK_ID;
  
// ABS Label 320
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
return i;
}

/*
** Run the parser on the given SQL string.  The parser structure is
** passed in.  An SQLITE_ status code is returned.  If an error occurs
** then an and attempt is made to write an error message into 
** memory obtained from sqlite3_malloc() and to make *pzErrMsg point to that
** error message.
*/
int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){
  int nErr = 0;                   /* Number of errors encountered */
  void *pEngine;                  /* The LEMON-generated LALR(1) parser */
  int n = 0;                      /* Length of the next token token */
  int tokenType;                  /* type of the next token */
  int lastTokenParsed = -1;       /* type of the previous token */
  
// ABS Label 321
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
sqlite3 *db = pParse->db;       /* The database connection */
  int mxSqlLen;                   /* Max length of an SQL string */
#ifdef sqlite3Parser_ENGINEALWAYSONSTACK
  yyParser sEngine;    /* Space to hold the Lemon-generated Parser object */
#endif
  VVA_ONLY( u8 startedWithOom = db->mallocFailed );

  assert( zSql!=0 );
  mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];
  
// ABS Label 324
if(db->nVdbeActive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ROR Label 325
if((db->nVdbeActive != 0) != (db->nVdbeActive == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}
if( db->nVdbeActive==0 ){
    AtomicStore(&db->u1.isInterrupted, 0);
  }
  pParse->rc = SQLITE_OK;
  pParse->zTail = zSql;
  assert( pzErrMsg!=0 );
#ifdef SQLITE_DEBUG
  if( db->flags & SQLITE_ParserTrace ){
    printf("parser: [[[%s]]]\n", zSql);
    sqlite3ParserTrace(stdout, "parser: ");
  }else{
    sqlite3ParserTrace(0, 0);
  }
#endif
#ifdef sqlite3Parser_ENGINEALWAYSONSTACK
  pEngine = &sEngine;
  sqlite3ParserInit(pEngine, pParse);
#else
  pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);
  
// ABS Label 326
if(pEngine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ROR Label 327
if((pEngine != 0) != (pEngine == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
if( pEngine==0 ){
    
// ABS Label 328
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
sqlite3OomFault(db);
    return SQLITE_NOMEM_BKPT;
  }
#endif
  assert( pParse->pNewTable==0 );
  assert( pParse->pNewTrigger==0 );
  assert( pParse->nVar==0 );
  assert( pParse->pVList==0 );
  pParse->pParentParse = db->pParse;
  db->pParse = pParse;
  while( 1 ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    mxSqlLen -= n;
    
// ABS Label 332
if(mxSqlLen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// ROR Label 333
if((mxSqlLen <= 0) != (mxSqlLen < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 333);
}
// ROR Label 334
if((mxSqlLen > 0) != (mxSqlLen < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
// ROR Label 335
if((mxSqlLen >= 0) != (mxSqlLen < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 335);
}
if( mxSqlLen<0 ){
      pParse->rc = SQLITE_TOOBIG;
      break;
    }
#ifndef SQLITE_OMIT_WINDOWFUNC
    
// ABS Label 336
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ROR Label 337
if((tokenType < 163) != (tokenType >= 163))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
// ROR Label 338
if((tokenType > 163) != (tokenType >= 163))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}
// ROR Label 339
if((tokenType <= 163) != (tokenType >= 163))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
if( tokenType>=TK_WINDOW ){
      assert( tokenType==TK_SPACE || tokenType==TK_OVER || tokenType==TK_FILTER
           || tokenType==TK_ILLEGAL || tokenType==TK_WINDOW 
      );
#else
    if( tokenType>=TK_SPACE ){
      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );
#endif /* SQLITE_OMIT_WINDOWFUNC */
      if( AtomicLoad(&db->u1.isInterrupted) ){
        pParse->rc = SQLITE_INTERRUPT;
        break;
      }
      
// ABS Label 340
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// ROR Label 341
if((tokenType != 182) != (tokenType == 182))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 341);
}
if( tokenType==TK_SPACE ){
        zSql += n;
        continue;
      }
      
// ROR Label 342
if((zSql[0] != 0) != (zSql[0] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}
if( zSql[0]==0 ){
        /* Upon reaching the end of input, call the parser two more times
        ** with tokens TK_SEMI and 0, in that order. */
        
// ABS Label 343
if(lastTokenParsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}

// ROR Label 344
if((lastTokenParsed != 1) != (lastTokenParsed == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
if( lastTokenParsed==TK_SEMI ){
          tokenType = 0;
        }else { 
// ABS Label 345
if(lastTokenParsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}

// ROR Label 346
if((lastTokenParsed != 0) != (lastTokenParsed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 346);
}
if( lastTokenParsed==0 ){
          break;
        }else{
          tokenType = TK_SEMI;
        };}

        n = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
      }else { 
// ABS Label 347
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}

// ROR Label 348
if((tokenType != 163) != (tokenType == 163))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 348);
}
if( tokenType==TK_WINDOW ){
        assert( n==6 );
        tokenType = analyzeWindowKeyword((const u8*)&zSql[6]);
      }else { 
// ABS Label 349
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}

// ROR Label 350
if((tokenType != 164) != (tokenType == 164))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 350);
}
if( tokenType==TK_OVER ){
        assert( n==4 );
        tokenType = analyzeOverKeyword((const u8*)&zSql[4], lastTokenParsed);
      }else { 
// ABS Label 351
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}

// ROR Label 352
if((tokenType != 165) != (tokenType == 165))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 352);
}
if( tokenType==TK_FILTER ){
        assert( n==6 );
        tokenType = analyzeFilterKeyword((const u8*)&zSql[6], lastTokenParsed);
#endif /* SQLITE_OMIT_WINDOWFUNC */
      }else{
        
// ABS Label 353
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}

// ABS Label 354
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}

// ABS Label 355
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
sqlite3ErrorMsg(pParse, "unrecognized token: \"%.*s\"", n, zSql);
        break;
      };}
;}
;}

    }
    pParse->sLastToken.z = zSql;
    pParse->sLastToken.n = n;
    
// ABS Label 329
if(pEngine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}

// ABS Label 330
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ABS Label 331
if(pParse->sLastToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
sqlite3Parser(pEngine, tokenType, pParse->sLastToken);
    lastTokenParsed = tokenType;
    zSql += n;
    assert( db->mallocFailed==0 || pParse->rc!=SQLITE_OK || startedWithOom );
    
// ABS Label 356
if(pParse->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ROR Label 357
if((pParse->rc == 0) != (pParse->rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
if( pParse->rc!=SQLITE_OK ) { break;
}
  };
  assert( nErr==0 );
#ifdef YYTRACKMAXSTACKDEPTH
  sqlite3_mutex_enter(sqlite3MallocMutex());
  sqlite3StatusHighwater(SQLITE_STATUS_PARSER_STACK,
      sqlite3ParserStackPeak(pEngine)
  );
  sqlite3_mutex_leave(sqlite3MallocMutex());
#endif /* YYDEBUG */
#ifdef sqlite3Parser_ENGINEALWAYSONSTACK
  sqlite3ParserFinalize(pEngine);
#else
  
// ABS Label 322
if(pEngine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
sqlite3ParserFree(pEngine, sqlite3_free);
#endif
  
// ABS Label 358
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}
if( db->mallocFailed ){
    pParse->rc = SQLITE_NOMEM_BKPT;
  }
  
// ABS Label 359
if(pParse->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}
// ABS Label 360
if(pParse->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}

// COR Label 361
if((pParse->rc != 0 && pParse->rc != 101 || pParse->zErrMsg == 0) != (pParse->rc != 0 && pParse->rc != 101 && pParse->zErrMsg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 361);
}
// COR Label 362
if((pParse->rc != 0 || pParse->rc != 101) != (pParse->rc != 0 && pParse->rc != 101))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 362);
}

// ROR Label 363
if((pParse->rc == 0) != (pParse->rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}
// ROR Label 364
if((pParse->rc == 101) != (pParse->rc != 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}
// ROR Label 365
if((pParse->zErrMsg != 0) != (pParse->zErrMsg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 365);
}

// MCC Label 366
if(pParse->rc != 0 && pParse->rc != 101 && pParse->zErrMsg == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 366);
}
// MCC Label 367
if(pParse->rc != 0 && pParse->rc != 101 && !(pParse->zErrMsg == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 367);
}
// MCC Label 368
if(pParse->rc != 0 && !(pParse->rc != 101) && pParse->zErrMsg == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
// MCC Label 369
if(pParse->rc != 0 && !(pParse->rc != 101) && !(pParse->zErrMsg == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 369);
}
// MCC Label 370
if(!(pParse->rc != 0) && pParse->rc != 101 && pParse->zErrMsg == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(!(pParse->rc != 0) && pParse->rc != 101 && !(pParse->zErrMsg == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}
// MCC Label 372
if(!(pParse->rc != 0) && !(pParse->rc != 101) && pParse->zErrMsg == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 372);
}
// MCC Label 373
if(!(pParse->rc != 0) && !(pParse->rc != 101) && !(pParse->zErrMsg == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 373);
}
if( pParse->rc!=SQLITE_OK && pParse->rc!=SQLITE_DONE && pParse->zErrMsg==0 ){
    pParse->zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr(pParse->rc));
  }
  assert( pzErrMsg!=0 );
  
// ABS Label 374
if(pParse->zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
if( pParse->zErrMsg ){
    *pzErrMsg = pParse->zErrMsg;
    
// ABS Label 375
if(pParse->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}

// ABS Label 376
if(*pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 376);
}

// ABS Label 377
if(pParse->zTail < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}
sqlite3_log(pParse->rc, "%s in \"%s\"", 
                *pzErrMsg, pParse->zTail);
    pParse->zErrMsg = 0;
    nErr++;
  }
  pParse->zTail = zSql;
  
// ABS Label 378
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 378);
}
// ABS Label 379
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// COR Label 380
if((pParse->pVdbe && pParse->nErr > 0 || pParse->nested == 0) != (pParse->pVdbe && pParse->nErr > 0 && pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 380);
}
// COR Label 381
if((pParse->pVdbe || pParse->nErr > 0) != (pParse->pVdbe && pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 381);
}

// ROR Label 382
if((pParse->nErr <= 0) != (pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 382);
}
// ROR Label 383
if((pParse->nErr < 0) != (pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 383);
}
// ROR Label 384
if((pParse->nErr >= 0) != (pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 384);
}
// ROR Label 385
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 385);
}

// MCC Label 386
if(pParse->pVdbe && pParse->nErr > 0 && pParse->nested == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 386);
}
// MCC Label 387
if(pParse->pVdbe && pParse->nErr > 0 && !(pParse->nested == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 387);
}
// MCC Label 388
if(pParse->pVdbe && !(pParse->nErr > 0) && pParse->nested == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 388);
}
// MCC Label 389
if(pParse->pVdbe && !(pParse->nErr > 0) && !(pParse->nested == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 389);
}
// MCC Label 390
if(!(pParse->pVdbe) && pParse->nErr > 0 && pParse->nested == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 390);
}
// MCC Label 391
if(!(pParse->pVdbe) && pParse->nErr > 0 && !(pParse->nested == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 391);
}
// MCC Label 392
if(!(pParse->pVdbe) && !(pParse->nErr > 0) && pParse->nested == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
// MCC Label 393
if(!(pParse->pVdbe) && !(pParse->nErr > 0) && !(pParse->nested == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
if( pParse->pVdbe && pParse->nErr>0 && pParse->nested==0 ){
    
// ABS Label 394
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}
sqlite3VdbeDelete(pParse->pVdbe);
    pParse->pVdbe = 0;
  }
#ifndef SQLITE_OMIT_SHARED_CACHE
  
// ROR Label 395
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 395);
}
if( pParse->nested==0 ){
    
// ABS Label 396
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}
sqlite3DbFree(db, pParse->aTableLock);
    pParse->aTableLock = 0;
    pParse->nTableLock = 0;
  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
  sqlite3_free(pParse->apVtabLock);
#endif

  if( !IN_SPECIAL_PARSE ){
    /* If the pParse->declareVtab flag is set, do not delete any table 
    ** structure built up in pParse->pNewTable. The calling code (see vtab.c)
    ** will take responsibility for freeing the Table structure.
    */
    
// ABS Label 397
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}

// ABS Label 398
if(pParse->pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}
sqlite3DeleteTable(db, pParse->pNewTable);
  }
  if( !IN_RENAME_OBJECT ){
    
// ABS Label 399
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}

// ABS Label 400
if(pParse->pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  }
  
// ABS Label 323
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
sqlite3DbFree(db, pParse->pVList);
  db->pParse = pParse->pParentParse;
  pParse->pParentParse = 0;
  assert( nErr==0 || pParse->rc!=SQLITE_OK );
  
// ABS Label 401
if(nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}
return nErr;
}


#ifdef SQLITE_ENABLE_NORMALIZE
/*
** Insert a single space character into pStr if the current string
** ends with an identifier
*/
static void addSpaceSeparator(sqlite3_str *pStr){
  if( pStr->nChar && sqlite3IsIdChar(pStr->zText[pStr->nChar-1]) ){
    sqlite3_str_append(pStr, " ", 1);
  }
}

/*
** Compute a normalization of the SQL given by zSql[0..nSql-1].  Return
** the normalization in space obtained from sqlite3DbMalloc().  Or return
** NULL if anything goes wrong or if zSql is NULL.
*/
char *sqlite3Normalize(
  Vdbe *pVdbe,       /* VM being reprepared */
  const char *zSql   /* The original SQL string */
){
  sqlite3 *db;       /* The database connection */
  int i;             /* Next unread byte of zSql[] */
  int n;             /* length of current token */
  int tokenType;     /* type of current token */
  int prevType = 0;  /* Previous non-whitespace token */
  int nParen;        /* Number of nested levels of parentheses */
  int iStartIN;      /* Start of RHS of IN operator in z[] */
  int nParenAtIN;    /* Value of nParent at start of RHS of IN operator */
  u32 j;             /* Bytes of normalized SQL generated so far */
  sqlite3_str *pStr; /* The normalized SQL string under construction */

  db = sqlite3VdbeDb(pVdbe);
  tokenType = -1;
  nParen = iStartIN = nParenAtIN = 0;
  pStr = sqlite3_str_new(db);
  assert( pStr!=0 );  /* sqlite3_str_new() never returns NULL */
  for(i=0; zSql[i] && pStr->accError==0; i+=n){
    if( tokenType!=TK_SPACE ){
      prevType = tokenType;
    }
    n = sqlite3GetToken((unsigned char*)zSql+i, &tokenType);
    if( NEVER(n<=0) ) break;
    switch( tokenType ){
      case TK_SPACE: {
        break;
      }
      case TK_NULL: {
        if( prevType==TK_IS || prevType==TK_NOT ){
          sqlite3_str_append(pStr, " NULL", 5);
          break;
        }
        /* Fall through */
      }
      case TK_STRING:
      case TK_INTEGER:
      case TK_FLOAT:
      case TK_VARIABLE:
      case TK_BLOB: {
        sqlite3_str_append(pStr, "?", 1);
        break;
      }
      case TK_LP: {
        nParen++;
        if( prevType==TK_IN ){
          iStartIN = pStr->nChar;
          nParenAtIN = nParen;
        }
        sqlite3_str_append(pStr, "(", 1);
        break;
      }
      case TK_RP: {
        if( iStartIN>0 && nParen==nParenAtIN ){
          assert( pStr->nChar>=(u32)iStartIN );
          pStr->nChar = iStartIN+1;
          sqlite3_str_append(pStr, "?,?,?", 5);
          iStartIN = 0;
        }
        nParen--;
        sqlite3_str_append(pStr, ")", 1);
        break;
      }
      case TK_ID: {
        iStartIN = 0;
        j = pStr->nChar;
        if( sqlite3Isquote(zSql[i]) ){
          char *zId = sqlite3DbStrNDup(db, zSql+i, n);
          int nId;
          int eType = 0;
          if( zId==0 ) break;
          sqlite3Dequote(zId);
          if( zSql[i]=='"' && sqlite3VdbeUsesDoubleQuotedString(pVdbe, zId) ){
            sqlite3_str_append(pStr, "?", 1);
            sqlite3DbFree(db, zId);
            break;
          }
          nId = sqlite3Strlen30(zId);
          if( sqlite3GetToken((u8*)zId, &eType)==nId && eType==TK_ID ){
            addSpaceSeparator(pStr);
            sqlite3_str_append(pStr, zId, nId);
          }else{
            sqlite3_str_appendf(pStr, "\"%w\"", zId);
          }
          sqlite3DbFree(db, zId);
        }else{
          addSpaceSeparator(pStr);
          sqlite3_str_append(pStr, zSql+i, n);
        }
        while( j<pStr->nChar ){
          pStr->zText[j] = sqlite3Tolower(pStr->zText[j]);
          j++;
        }
        break;
      }
      case TK_SELECT: {
        iStartIN = 0;
        /* fall through */
      }
      default: {
        if( sqlite3IsIdChar(zSql[i]) ) addSpaceSeparator(pStr);
        j = pStr->nChar;
        sqlite3_str_append(pStr, zSql+i, n);
        while( j<pStr->nChar ){
          pStr->zText[j] = sqlite3Toupper(pStr->zText[j]);
          j++;
        }
        break;
      }
    }
  }
  if( tokenType!=TK_SEMI ) sqlite3_str_append(pStr, ";", 1);
  return sqlite3_str_finish(pStr);
}
#endif /* SQLITE_ENABLE_NORMALIZE */
