/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** in order to generate code for DELETE FROM statements.
*/
#include "sqliteInt.h"

/*
** While a SrcList can in general represent multiple tables and subqueries
** (as in the FROM clause of a SELECT statement) in this case it contains
** the name of a single table, as one might find in an INSERT, DELETE,
** or UPDATE statement.  Look up that table in the symbol table and
** return a pointer.  Set an error message and return NULL if the table 
** name is not found or if any other error occurs.
**
** The following fields are initialized appropriate in pSrc:
**
**    pSrc->a[0].pTab       Pointer to the Table object
**    pSrc->a[0].pIndex     Pointer to the INDEXED BY index, if there is one
**
*/
Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){
  SrcItem *pItem = pSrc->a;
  Table *pTab;
  assert( pItem && pSrc->nSrc>=1 );
  pTab = sqlite3LocateTableItem(pParse, 0, pItem);
  
// ABS Label 7
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ABS Label 8
if(pItem->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3DeleteTable(pParse->db, pItem->pTab);
  pItem->pTab = pTab;
  
// ABS Label 9
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
if( pTab ){
    pTab->nTabRef++;
    if( pItem->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pItem) ){
      pTab = 0;
    }
  }
  
// ABS Label 10
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
return pTab;
}

/* Return true if table pTab is read-only.
**
** A table is read-only if any of the following are true:
**
**   1) It is a virtual table and no implementation of the xUpdate method
**      has been provided
**
**   2) It is a system table (i.e. sqlite_schema), this call is not
**      part of a nested parse and writable_schema pragma has not 
**      been specified
**
**   3) The table is a shadow table, the database connection is in
**      defensive mode, and the current sqlite3_prepare()
**      is for a top-level SQL statement.
*/
static int tabIsReadOnly(Parse *pParse, Table *pTab){
  sqlite3 *db;
  
// ABS Label 11
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
if( IsVirtual(pTab) ){
    return sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0;
  }
  
// ROR Label 12
if(((pTab->tabFlags & (1 | 4096)) != 0) != ((pTab->tabFlags & (1 | 4096)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
if( (pTab->tabFlags & (TF_Readonly|TF_Shadow))==0 ) { return 0;
}
  db = pParse->db;
  
// ROR Label 13
if(((pTab->tabFlags & 1) == 0) != ((pTab->tabFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
if( (pTab->tabFlags & TF_Readonly)!=0 ){
    return sqlite3WritableSchema(db)==0 && pParse->nested==0;
  }
  assert( pTab->tabFlags & TF_Shadow );
  return sqlite3ReadOnlyShadowTables(db);
}

/*
** Check to make sure the given table is writable.  If it is not
** writable, generate an error message and return 1.  If it is
** writable return 0;
*/
int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){
  if( tabIsReadOnly(pParse, pTab) ){
    
// ABS Label 14
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ABS Label 15
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
    return 1;
  }
#ifndef SQLITE_OMIT_VIEW
  
// ABS Label 16
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// COR Label 17
if((!viewOk || pTab->pSelect) != (!viewOk && pTab->pSelect))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 17);
}

// MCC Label 18
if(!viewOk && pTab->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 18);
}
// MCC Label 19
if(!viewOk && !(pTab->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 19);
}
// MCC Label 20
if(!(!viewOk) && pTab->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 20);
}
// MCC Label 21
if(!(!viewOk) && !(pTab->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 21);
}
if( !viewOk && pTab->pSelect ){
    
// ABS Label 22
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ABS Label 23
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3ErrorMsg(pParse,"cannot modify %s because it is a view",pTab->zName);
    return 1;
  }
#endif
  return 0;
}


#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
/*
** Evaluate a view and store its result in an ephemeral table.  The
** pWhere argument is an optional WHERE clause that restricts the
** set of rows in the view that are to be added to the ephemeral table.
*/
void sqlite3MaterializeView(
  Parse *pParse,       /* Parsing context */
  Table *pView,        /* View definition */
  Expr *pWhere,        /* Optional WHERE clause to be added */
  ExprList *pOrderBy,  /* Optional ORDER BY clause */
  Expr *pLimit,        /* Optional LIMIT clause */
  int iCur             /* Cursor number for ephemeral table */
){
  SelectDest dest;
  Select *pSel;
  SrcList *pFrom;
  
// ABS Label 24
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
sqlite3 *db = pParse->db;
  int iDb = sqlite3SchemaToIndex(db, pView->pSchema);
  pWhere = sqlite3ExprDup(db, pWhere, 0);
  pFrom = sqlite3SrcListAppend(pParse, 0, 0, 0);
  
// ABS Label 30
if(pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
if( pFrom ){
    assert( pFrom->nSrc==1 );
    pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName);
    pFrom->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);
    assert( pFrom->a[0].pOn==0 );
    assert( pFrom->a[0].pUsing==0 );
  }
  pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, pOrderBy, 
                          SF_IncludeHidden, pLimit);
  
// ABS Label 25
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
sqlite3SelectDestInit(&dest, SRT_EphemTab, iCur);
  
// ABS Label 26
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// ABS Label 27
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
sqlite3Select(pParse, pSel, &dest);
  
// ABS Label 28
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ABS Label 29
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
sqlite3SelectDelete(db, pSel);
}
#endif /* !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) */

#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)
/*
** Generate an expression tree to implement the WHERE, ORDER BY,
** and LIMIT/OFFSET portion of DELETE and UPDATE statements.
**
**     DELETE FROM table_wxyz WHERE a<5 ORDER BY a LIMIT 1;
**                            \__________________________/
**                               pLimitWhere (pInClause)
*/
Expr *sqlite3LimitWhere(
  Parse *pParse,               /* The parser context */
  SrcList *pSrc,               /* the FROM clause -- which tables to scan */
  Expr *pWhere,                /* The WHERE clause.  May be null */
  ExprList *pOrderBy,          /* The ORDER BY clause.  May be null */
  Expr *pLimit,                /* The LIMIT clause.  May be null */
  char *zStmtType              /* Either DELETE or UPDATE.  For err msgs. */
){
  sqlite3 *db = pParse->db;
  Expr *pLhs = NULL;           /* LHS of IN(SELECT...) operator */
  Expr *pInClause = NULL;      /* WHERE rowid IN ( select ) */
  ExprList *pEList = NULL;     /* Expression list contaning only pSelectRowid */
  SrcList *pSelectSrc = NULL;  /* SELECT rowid FROM x ... (dup of pSrc) */
  Select *pSelect = NULL;      /* Complete SELECT tree */
  Table *pTab;

  /* Check that there isn't an ORDER BY without a LIMIT clause.
  */
  if( pOrderBy && pLimit==0 ) {
    sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on %s", zStmtType);
    sqlite3ExprDelete(pParse->db, pWhere);
    sqlite3ExprListDelete(pParse->db, pOrderBy);
    return 0;
  }

  /* We only need to generate a select expression if there
  ** is a limit/offset term to enforce.
  */
  if( pLimit == 0 ) {
    return pWhere;
  }

  /* Generate a select expression tree to enforce the limit/offset 
  ** term for the DELETE or UPDATE statement.  For example:
  **   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
  ** becomes:
  **   DELETE FROM table_a WHERE rowid IN ( 
  **     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1
  **   );
  */

  pTab = pSrc->a[0].pTab;
  if( HasRowid(pTab) ){
    pLhs = sqlite3PExpr(pParse, TK_ROW, 0, 0);
    pEList = sqlite3ExprListAppend(
        pParse, 0, sqlite3PExpr(pParse, TK_ROW, 0, 0)
    );
  }else{
    Index *pPk = sqlite3PrimaryKeyIndex(pTab);
    if( pPk->nKeyCol==1 ){
      const char *zName = pTab->aCol[pPk->aiColumn[0]].zName;
      pLhs = sqlite3Expr(db, TK_ID, zName);
      pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ID, zName));
    }else{
      int i;
      for(i=0; i<pPk->nKeyCol; i++){
        Expr *p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zName);
        pEList = sqlite3ExprListAppend(pParse, pEList, p);
      }
      pLhs = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);
      if( pLhs ){
        pLhs->x.pList = sqlite3ExprListDup(db, pEList, 0);
      }
    }
  }

  /* duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree
  ** and the SELECT subtree. */
  pSrc->a[0].pTab = 0;
  pSelectSrc = sqlite3SrcListDup(db, pSrc, 0);
  pSrc->a[0].pTab = pTab;
  if( pSrc->a[0].fg.isIndexedBy ){
    pSrc->a[0].u2.pIBIndex = 0;
    pSrc->a[0].fg.isIndexedBy = 0;
    sqlite3DbFree(db, pSrc->a[0].u1.zIndexedBy);
  }else if( pSrc->a[0].fg.isCte ){
    pSrc->a[0].u2.pCteUse->nUse++;
  }

  /* generate the SELECT expression tree. */
  pSelect = sqlite3SelectNew(pParse, pEList, pSelectSrc, pWhere, 0 ,0, 
      pOrderBy,0,pLimit
  );

  /* now generate the new WHERE rowid IN clause for the DELETE/UDPATE */
  pInClause = sqlite3PExpr(pParse, TK_IN, pLhs, 0);
  sqlite3PExprAddSelect(pParse, pInClause, pSelect);
  return pInClause;
}
#endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) */
       /*      && !defined(SQLITE_OMIT_SUBQUERY) */

/*
** Generate code for a DELETE FROM statement.
**
**     DELETE FROM table_wxyz WHERE a<5 AND b NOT NULL;
**                 \________/       \________________/
**                  pTabList              pWhere
*/
void sqlite3DeleteFrom(
  Parse *pParse,         /* The parser context */
  SrcList *pTabList,     /* The table from which we should delete things */
  Expr *pWhere,          /* The WHERE clause.  May be null */
  ExprList *pOrderBy,    /* ORDER BY clause. May be null */
  Expr *pLimit           /* LIMIT clause. May be null */
){
  Vdbe *v;               /* The virtual database engine */
  Table *pTab;           /* The table from which records will be deleted */
  int i;                 /* Loop counter */
  WhereInfo *pWInfo;     /* Information about the WHERE clause */
  Index *pIdx;           /* For looping over indices of the table */
  int iTabCur;           /* Cursor number for the table */
  int iDataCur = 0;      /* VDBE cursor for the canonical data source */
  int iIdxCur = 0;       /* Cursor number of the first index */
  int nIdx;              /* Number of indices */
  sqlite3 *db;           /* Main database structure */
  AuthContext sContext;  /* Authorization context */
  NameContext sNC;       /* Name context to resolve expressions in */
  int iDb;               /* Database number */
  int memCnt = 0;        /* Memory cell used for change counting */
  int rcauth;            /* Value returned by authorization callback */
  int eOnePass;          /* ONEPASS_OFF or _SINGLE or _MULTI */
  int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */
  u8 *aToOpen = 0;       /* Open cursor iTabCur+j if aToOpen[j] is true */
  Index *pPk;            /* The PRIMARY KEY index on the table */
  int iPk = 0;           /* First of nPk registers holding PRIMARY KEY value */
  i16 nPk = 1;           /* Number of columns in the PRIMARY KEY */
  int iKey;              /* Memory cell holding key of row to be deleted */
  i16 nKey;              /* Number of memory cells in the row key */
  int iEphCur = 0;       /* Ephemeral table holding all primary key values */
  int iRowSet = 0;       /* Register for rowset of rows to delete */
  int addrBypass = 0;    /* Address of jump over the delete logic */
  int addrLoop = 0;      /* Top of the delete loop */
  int addrEphOpen = 0;   /* Instruction to open the Ephemeral table */
  int bComplex;          /* True if there are triggers or FKs or
                         ** subqueries in the WHERE clause */
 
#ifndef SQLITE_OMIT_TRIGGER
  int isView;                  /* True if attempting to delete from a view */
  Trigger *pTrigger;           /* List of table triggers, if required */
#endif

  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  
// ABS Label 39
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}

// COR Label 40
if((pParse->nErr && db->mallocFailed) != (pParse->nErr || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 40);
}

// MCC Label 41
if(pParse->nErr && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(pParse->nErr && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
// MCC Label 43
if(!(pParse->nErr) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 43);
}
// MCC Label 44
if(!(pParse->nErr) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 44);
}
if( pParse->nErr || db->mallocFailed ){
    goto delete_from_cleanup;
  }
  assert( pTabList->nSrc==1 );


  /* Locate the table which we want to delete.  This table has to be
  ** put in an SrcList structure because some of the subroutines we
  ** will be calling are designed to work with multiple tables and expect
  ** an SrcList* parameter instead of just a Table* parameter.
  */
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  
// ABS Label 45
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// ROR Label 46
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
if( pTab==0 ) {  goto delete_from_cleanup;
}

  /* Figure out if we have any triggers and if the table being
  ** deleted from is a view
  */
#ifndef SQLITE_OMIT_TRIGGER
  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);
  isView = pTab->pSelect!=0;
#else
# define pTrigger 0
# define isView 0
#endif
  bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif

#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
  if( !isView ){
    pWhere = sqlite3LimitWhere(
        pParse, pTabList, pWhere, pOrderBy, pLimit, "DELETE"
    );
    pOrderBy = 0;
    pLimit = 0;
  }
#endif

  /* If pTab is really a view, make sure it has been initialized.
  */
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto delete_from_cleanup;
  }

  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){
    goto delete_from_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  assert( iDb<db->nDb );
  rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, 
                            db->aDb[iDb].zDbSName);
  assert( rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE );
  
// ABS Label 47
if(rcauth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ROR Label 48
if((rcauth != 1) != (rcauth == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
if( rcauth==SQLITE_DENY ){
    goto delete_from_cleanup;
  }
  assert(!isView || pTrigger);

  /* Assign cursor numbers to the table and all its indices.
  */
  assert( pTabList->nSrc==1 );
  iTabCur = pTabList->a[0].iCursor = pParse->nTab++;
  nIdx = 0 , pIdx = pTab->pIndex;

// ABS Label 49
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
for(; pIdx; pIdx=pIdx->pNext, nIdx++){
    pParse->nTab++;
  };
// ABS Label 50
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}


  /* Start the view context
  */
  
// ABS Label 51
if(isView < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
if( isView ){
    
// ABS Label 52
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }

  /* Begin generating code.
  */
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 53
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// ROR Label 54
if((v != 0) != (v == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
if( v==0 ){
    goto delete_from_cleanup;
  }
  
// ROR Label 55
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
if( pParse->nested==0 ) { 
// ABS Label 56
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}
sqlite3VdbeCountChanges(v);
}
  
// ABS Label 31
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// ABS Label 32
if(bComplex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}

// ABS Label 33
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3BeginWriteOperation(pParse, bComplex, iDb);

  /* If we are trying to delete from a view, realize that view into
  ** an ephemeral table.
  */
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
  
// ABS Label 57
if(isView < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
if( isView ){
    
// ABS Label 58
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}

// ABS Label 59
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}

// ABS Label 60
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}

// ABS Label 61
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}

// ABS Label 62
if(pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// ABS Label 63
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}
sqlite3MaterializeView(pParse, pTab, 
        pWhere, pOrderBy, pLimit, iTabCur
    );
    iDataCur = iIdxCur = iTabCur;
    pOrderBy = 0;
    pLimit = 0;
  }
#endif

  /* Resolve the column names in the WHERE clause.
  */
  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto delete_from_cleanup;
  }

  /* Initialize the counter of the number of rows deleted, if
  ** we are counting rows.
  */
  
// COR Label 64
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab || !pParse->bReturning) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 64);
}
// COR Label 65
if(((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested || !pParse->pTriggerTab) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 65);
}
// COR Label 66
if(((db->flags & ((u64)(1) << 32)) != 0 || !pParse->nested) != ((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 66);
}

// ROR Label 67
if(((db->flags & ((u64)(1) << 32)) == 0) != ((db->flags & ((u64)(1) << 32)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}

// MCC Label 68
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 68);
}
// MCC Label 69
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 69);
}
// MCC Label 70
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 70);
}
// MCC Label 71
if((db->flags & ((u64)(1) << 32)) != 0 && !pParse->nested && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
// MCC Label 73
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
// MCC Label 74
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 74);
}
// MCC Label 75
if((db->flags & ((u64)(1) << 32)) != 0 && !(!pParse->nested) && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 75);
}
// MCC Label 76
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 76);
}
// MCC Label 77
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 77);
}
// MCC Label 78
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 78);
}
// MCC Label 79
if(!((db->flags & ((u64)(1) << 32)) != 0) && !pParse->nested && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 79);
}
// MCC Label 80
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !pParse->pTriggerTab && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 80);
}
// MCC Label 81
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !pParse->pTriggerTab && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 81);
}
// MCC Label 82
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !(!pParse->pTriggerTab) && !pParse->bReturning ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
// MCC Label 83
if(!((db->flags & ((u64)(1) << 32)) != 0) && !(!pParse->nested) && !(!pParse->pTriggerTab) && !(!pParse->bReturning) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
if( (db->flags & SQLITE_CountRows)!=0
   && !pParse->nested
   && !pParse->pTriggerTab
   && !pParse->bReturning
  ){
    memCnt = ++pParse->nMem;
    
// ABS Label 84
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ABS Label 85
if(memCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, memCnt);
  }

#ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION
  /* Special case: A DELETE without a WHERE clause deletes everything.
  ** It is easier just to erase the whole table. Prior to version 3.6.5,
  ** this optimization caused the row change count (the value returned by 
  ** API function sqlite3_count_changes) to be set incorrectly.
  **
  ** The "rcauth==SQLITE_OK" terms is the
  ** IMPLEMENTATION-OF: R-17228-37124 If the action code is SQLITE_DELETE and
  ** the callback returns SQLITE_IGNORE then the DELETE operation proceeds but
  ** the truncate optimization is disabled and all rows are deleted
  ** individually.
  */
  
// ABS Label 86
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
// ABS Label 87
if(rcauth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// COR Label 88
if((rcauth == 0 && pWhere == 0 && !bComplex || !((pTab)->nModuleArg)) != (rcauth == 0 && pWhere == 0 && !bComplex && !((pTab)->nModuleArg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 88);
}
// COR Label 89
if((rcauth == 0 && pWhere == 0 || !bComplex) != (rcauth == 0 && pWhere == 0 && !bComplex))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 89);
}
// COR Label 90
if((rcauth == 0 || pWhere == 0) != (rcauth == 0 && pWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 90);
}

// ROR Label 91
if((rcauth != 0) != (rcauth == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((pWhere != 0) != (pWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}

// MCC Label 93
if(rcauth == 0 && pWhere == 0 && !bComplex && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 93);
}
// MCC Label 94
if(rcauth == 0 && pWhere == 0 && !bComplex && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(rcauth == 0 && pWhere == 0 && !(!bComplex) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(rcauth == 0 && pWhere == 0 && !(!bComplex) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(rcauth == 0 && !(pWhere == 0) && !bComplex && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
// MCC Label 98
if(rcauth == 0 && !(pWhere == 0) && !bComplex && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 98);
}
// MCC Label 99
if(rcauth == 0 && !(pWhere == 0) && !(!bComplex) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 99);
}
// MCC Label 100
if(rcauth == 0 && !(pWhere == 0) && !(!bComplex) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 100);
}
// MCC Label 101
if(!(rcauth == 0) && pWhere == 0 && !bComplex && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(!(rcauth == 0) && pWhere == 0 && !bComplex && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
// MCC Label 103
if(!(rcauth == 0) && pWhere == 0 && !(!bComplex) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 103);
}
// MCC Label 104
if(!(rcauth == 0) && pWhere == 0 && !(!bComplex) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 104);
}
// MCC Label 105
if(!(rcauth == 0) && !(pWhere == 0) && !bComplex && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 105);
}
// MCC Label 106
if(!(rcauth == 0) && !(pWhere == 0) && !bComplex && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 106);
}
// MCC Label 107
if(!(rcauth == 0) && !(pWhere == 0) && !(!bComplex) && !((pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 107);
}
// MCC Label 108
if(!(rcauth == 0) && !(pWhere == 0) && !(!bComplex) && !(!((pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
if( rcauth==SQLITE_OK
   && pWhere==0
   && !bComplex
   && !IsVirtual(pTab)
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
   && db->xPreUpdateCallback==0
#endif
  ){
    assert( !isView );
    
// ABS Label 109
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}

// ABS Label 110
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// ABS Label 111
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}
sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
    
// MCC Label 112
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
if( HasRowid(pTab) ){
      
// ABS Label 114
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// ABS Label 115
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
sqlite3VdbeAddOp4(v, OP_Clear, pTab->tnum, iDb, memCnt ? memCnt : -1,
                        pTab->zName, P4_STATIC);
    }
    pIdx = pTab->pIndex;

// ABS Label 116
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
for(; pIdx; pIdx=pIdx->pNext){
      assert( pIdx->pSchema==pTab->pSchema );
      
// ABS Label 118
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// ABS Label 119
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}
sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);
      
// COR Label 120
if((((pIdx)->idxType == 2) || !(((pTab)->tabFlags & 128) == 0)) != (((pIdx)->idxType == 2) && !(((pTab)->tabFlags & 128) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 120);
}

// MCC Label 121
if(( (pIdx)->idxType == 2 ) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 121);
}
// MCC Label 122
if(( (pIdx)->idxType == 2 ) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(( !((pIdx)->idxType == 2) ) && !(((pTab)->tabFlags & 128) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
// MCC Label 124
if(( !((pIdx)->idxType == 2) ) && !(!(((pTab)->tabFlags & 128) == 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 124);
}
if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){
        
// ABS Label 125
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
sqlite3VdbeChangeP3(v, -1, memCnt ? memCnt : -1);
      }
    };
// ABS Label 117
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

  }else
#endif /* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */
  {
    u16 wcf = WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK;
    
// ABS Label 126
if(sNC.ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// AOR Label 127
if(sNC.ncFlags | 64 != sNC.ncFlags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 127);
}
// AOR Label 128
if(sNC.ncFlags ^ 64 != sNC.ncFlags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 128);
}
if( sNC.ncFlags & NC_VarSelect ) { bComplex = 1;
}
    wcf |= (bComplex ? 0 : WHERE_ONEPASS_MULTIROW);
    
// MCC Label 129
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
// MCC Label 130
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
if( HasRowid(pTab) ){
      /* For a rowid table, initialize the RowSet to an empty set */
      pPk = 0;
      nPk = 1;
      iRowSet = ++pParse->nMem;
      
// ABS Label 131
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}

// ABS Label 132
if(iRowSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, iRowSet);
    }else{
      /* For a WITHOUT ROWID table, create an ephemeral table used to
      ** hold all primary keys for rows to be deleted. */
      pPk = sqlite3PrimaryKeyIndex(pTab);
      assert( pPk!=0 );
      nPk = pPk->nKeyCol;
      iPk = pParse->nMem+1;
      pParse->nMem += nPk;
      iEphCur = pParse->nTab++;
      addrEphOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEphCur, nPk);
      
// ABS Label 133
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}

// ABS Label 134
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}
sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
  
    /* Construct a query to find the rowid or primary key for every row
    ** to be deleted, based on the WHERE clause. Set variable eOnePass
    ** to indicate the strategy used to implement this delete:
    **
    **  ONEPASS_OFF:    Two-pass approach - use a FIFO for rowids/PK values.
    **  ONEPASS_SINGLE: One-pass approach - at most one row deleted.
    **  ONEPASS_MULTI:  One-pass approach - any number of rows may be deleted.
    */
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, wcf, iTabCur+1);
    
// ABS Label 135
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}

// ROR Label 136
if((pWInfo != 0) != (pWInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 136);
}
if( pWInfo==0 ) { goto delete_from_cleanup;
}
    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
    assert( IsVirtual(pTab)==0 || eOnePass!=ONEPASS_MULTI );
    assert( IsVirtual(pTab) || bComplex || eOnePass!=ONEPASS_OFF );
    
// ABS Label 137
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}

// ROR Label 138
if((eOnePass == 1) != (eOnePass != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 138);
}
if( eOnePass!=ONEPASS_SINGLE ) { 
// ABS Label 139
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
sqlite3MultiWrite(pParse);
}
    if( sqlite3WhereUsesDeferredSeek(pWInfo) ){
      
// ABS Label 140
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ABS Label 141
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
sqlite3VdbeAddOp1(v, OP_FinishSeek, iTabCur);
    }
  
    /* Keep track of the number of rows to be deleted */
    
// ABS Label 142
if(memCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
if( memCnt ){
      
// ABS Label 143
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}

// ABS Label 144
if(memCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}
sqlite3VdbeAddOp2(v, OP_AddImm, memCnt, 1);
    }
  
    /* Extract the rowid or primary key for the current row */
    
// ABS Label 145
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}
if( pPk ){
      i = 0;

// ABS Label 146
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ROR Label 147
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 147);
}
// ROR Label 148
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 148);
}
// ROR Label 149
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
for(; i<nPk; i++){
        assert( pPk->aiColumn[i]>=0 );
        
// ABS Label 154
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}

// ABS Label 155
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}

// ABS Label 156
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}

// ABS Label 157
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
// ABS Label 158
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// AOR Label 159
if(iPk - i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 159);
}
// AOR Label 160
if(iPk / i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 160);
}
// AOR Label 161
if(iPk * i != iPk + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 161);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,
                                        pPk->aiColumn[i], iPk+i);
      };
// ABS Label 150
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ROR Label 151
if((i <= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((i > nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
// ROR Label 153
if((i >= nPk) != (i < nPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 153);
}

      iKey = iPk;
    }else{
      iKey = ++pParse->nMem;
      
// ABS Label 162
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}

// ABS Label 163
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ABS Label 164
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}

// ABS Label 165
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);
    }
  
    
// ABS Label 166
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}

// ROR Label 167
if((eOnePass == 0) != (eOnePass != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
if( eOnePass!=ONEPASS_OFF ){
      /* For ONEPASS, no need to store the rowid/primary-key. There is only
      ** one, so just keep it in its register(s) and fall through to the
      ** delete code.  */
      nKey = nPk; /* OP_Found will use an unpacked key */
      aToOpen = sqlite3DbMallocRawNN(db, nIdx+2);
      
// ABS Label 168
if(aToOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}

// ROR Label 169
if((aToOpen != 0) != (aToOpen == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}
if( aToOpen==0 ){
        
// ABS Label 170
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}
sqlite3WhereEnd(pWInfo);
        goto delete_from_cleanup;
      }
      memset(aToOpen, 1, nIdx+1);
      aToOpen[nIdx+1] = 0;
      
// ABS Label 171
if(aiCurOnePass[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

// ROR Label 172
if((aiCurOnePass[0] < 0) != (aiCurOnePass[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 172);
}
// ROR Label 173
if((aiCurOnePass[0] > 0) != (aiCurOnePass[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
// ROR Label 174
if((aiCurOnePass[0] <= 0) != (aiCurOnePass[0] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
if( aiCurOnePass[0]>=0 ) { aToOpen[aiCurOnePass[0]-iTabCur] = 0;
}
      
// ABS Label 175
if(aiCurOnePass[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}

// ROR Label 176
if((aiCurOnePass[1] < 0) != (aiCurOnePass[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
// ROR Label 177
if((aiCurOnePass[1] > 0) != (aiCurOnePass[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 177);
}
// ROR Label 178
if((aiCurOnePass[1] <= 0) != (aiCurOnePass[1] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}
if( aiCurOnePass[1]>=0 ) { aToOpen[aiCurOnePass[1]-iTabCur] = 0;
}
      
// ABS Label 179
if(addrEphOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}
if( addrEphOpen ) { 
// ABS Label 180
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}

// ABS Label 181
if(addrEphOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
sqlite3VdbeChangeToNoop(v, addrEphOpen);
}
      addrBypass = sqlite3VdbeMakeLabel(pParse);
    }else{
      
// ABS Label 183
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
if( pPk ){
        /* Add the PK key for this row to the temporary table */
        iKey = ++pParse->nMem;
        nKey = 0;   /* Zero tells OP_Found to use a composite key */
        
// ABS Label 184
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}

// ABS Label 185
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}

// ABS Label 186
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, iKey,
            sqlite3IndexAffinityStr(pParse->db, pPk), nPk);
        
// ABS Label 187
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}

// ABS Label 188
if(iEphCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// ABS Label 189
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}

// ABS Label 190
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEphCur, iKey, iPk, nPk);
      }else{
        /* Add the rowid of the row to be deleted to the RowSet */
        nKey = 1;  /* OP_DeferredSeek always uses a single rowid */
        
// ABS Label 191
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// ABS Label 192
if(iRowSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}

// ABS Label 193
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}
sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);
      }
      
// ABS Label 182
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
sqlite3WhereEnd(pWInfo);
    }
  
    /* Unless this is a view, open cursors for the table we are 
    ** deleting from and all its indices. If this is a view, then the
    ** only effect this statement has is to fire the INSTEAD OF 
    ** triggers.
    */
    if( !isView ){
      int iAddrOnce = 0;
      
// ABS Label 198
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}

// ROR Label 199
if((eOnePass != 2) != (eOnePass == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
if( eOnePass==ONEPASS_MULTI ){
        iAddrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
      }
      testcase( IsVirtual(pTab) );
      
// ABS Label 194
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}

// ABS Label 195
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}

// ABS Label 196
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}

// ABS Label 197
if(aToOpen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, OPFLAG_FORDELETE,
                                 iTabCur, aToOpen, &iDataCur, &iIdxCur);
      assert( pPk || IsVirtual(pTab) || iDataCur==iTabCur );
      assert( pPk || IsVirtual(pTab) || iIdxCur==iDataCur+1 );
      
// ABS Label 200
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}

// ROR Label 201
if((eOnePass != 2) != (eOnePass == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
if( eOnePass==ONEPASS_MULTI ){
        
// ABS Label 202
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}

// ABS Label 203
if(iAddrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}
sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);
      }
    }
  
    /* Set up a loop over the rowids/primary-keys that were found in the
    ** where-clause loop above.
    */
    
// ABS Label 204
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}

// ROR Label 205
if((eOnePass == 0) != (eOnePass != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
if( eOnePass!=ONEPASS_OFF ){
      assert( nKey==nPk );  /* OP_Found will use an unpacked key */
      
// COR Label 206
if((!((pTab)->nModuleArg) || aToOpen[iDataCur - iTabCur]) != (!((pTab)->nModuleArg) && aToOpen[iDataCur - iTabCur]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 206);
}

// MCC Label 207
if(!((pTab)->nModuleArg) && aToOpen[iDataCur - iTabCur] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 207);
}
// MCC Label 208
if(!((pTab)->nModuleArg) && !(aToOpen[iDataCur - iTabCur]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(!(!((pTab)->nModuleArg)) && aToOpen[iDataCur - iTabCur] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(!(!((pTab)->nModuleArg)) && !(aToOpen[iDataCur - iTabCur]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){
        assert( pPk!=0 || pTab->pSelect!=0 );
        
// ABS Label 211
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}

// ABS Label 212
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// ABS Label 213
if(addrBypass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}

// ABS Label 214
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, addrBypass, iKey, nKey);
        VdbeCoverage(v);
      }
    }else { 
// ABS Label 215
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
if( pPk ){
      addrLoop = sqlite3VdbeAddOp1(v, OP_Rewind, iEphCur); VdbeCoverage(v);
      
// ABS Label 216
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}
if( IsVirtual(pTab) ){
        
// ABS Label 217
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}

// ABS Label 218
if(iEphCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}

// ABS Label 219
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
sqlite3VdbeAddOp3(v, OP_Column, iEphCur, 0, iKey);
      }else{
        
// ABS Label 220
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}

// ABS Label 221
if(iEphCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}

// ABS Label 222
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}
sqlite3VdbeAddOp2(v, OP_RowData, iEphCur, iKey);
      }
      assert( nKey==0 );  /* OP_Found will use a composite key */
    }else{
      addrLoop = sqlite3VdbeAddOp3(v, OP_RowSetRead, iRowSet, 0, iKey);
      VdbeCoverage(v);
      assert( nKey==1 );
    };}
  
  
    /* Delete the row */
#ifndef SQLITE_OMIT_VIRTUALTABLE
    
// ABS Label 223
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}
if( IsVirtual(pTab) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      
// ABS Label 224
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}

// ABS Label 225
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}
sqlite3VtabMakeWritable(pParse, pTab);
      assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );
      
// ABS Label 226
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
sqlite3MayAbort(pParse);
      
// ABS Label 231
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ROR Label 232
if((eOnePass != 1) != (eOnePass == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
if( eOnePass==ONEPASS_SINGLE ){
        
// ABS Label 233
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}

// ABS Label 234
if(iTabCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}
sqlite3VdbeAddOp1(v, OP_Close, iTabCur);
        
// MCC Label 235
if(( (pParse)->pToplevel == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
// MCC Label 236
if(( !((pParse)->pToplevel == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
if( sqlite3IsToplevel(pParse) ){
          pParse->isMultiWrite = 0;
        }
      }
      
// ABS Label 227
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}

// ABS Label 228
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}

// ABS Label 229
if(pVTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}
sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iKey, pVTab, P4_VTAB);
      
// ABS Label 230
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}
sqlite3VdbeChangeP5(v, OE_Abort);
    }else
#endif
    {
      int count = (pParse->nested==0);    /* True to count changes */
      
// ABS Label 237
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}

// ABS Label 238
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ABS Label 239
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// ABS Label 240
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ABS Label 241
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}

// ABS Label 242
if(iKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}

// ABS Label 243
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}

// ABS Label 244
if(aiCurOnePass[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}
sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
          iKey, nKey, count, OE_Default, eOnePass, aiCurOnePass[1]);
    }
  
    /* End of the loop over all rowids/primary-keys. */
    
// ABS Label 245
if(eOnePass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}

// ROR Label 246
if((eOnePass == 0) != (eOnePass != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
if( eOnePass!=ONEPASS_OFF ){
      
// ABS Label 247
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}

// ABS Label 248
if(addrBypass < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
sqlite3VdbeResolveLabel(v, addrBypass);
      
// ABS Label 249
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
sqlite3WhereEnd(pWInfo);
    }else { 
// ABS Label 250
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}
if( pPk ){
      
// ABS Label 251
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ABS Label 252
if(iEphCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}

// ABS Label 253
if(addrLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}

// AOR Label 254
if(addrLoop - 1 != addrLoop + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 254);
}
// AOR Label 255
if(addrLoop / 1 != addrLoop + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 255);
}
// AOR Label 256
if(addrLoop * 1 != addrLoop + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 256);
}
sqlite3VdbeAddOp2(v, OP_Next, iEphCur, addrLoop+1); VdbeCoverage(v);
      
// ABS Label 257
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}

// ABS Label 258
if(addrLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}
sqlite3VdbeJumpHere(v, addrLoop);
    }else{
      
// ABS Label 259
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}

// ABS Label 260
if(addrLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
sqlite3VdbeGoto(v, addrLoop);
      
// ABS Label 261
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}

// ABS Label 262
if(addrLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}
sqlite3VdbeJumpHere(v, addrLoop);
    };}
     
  } /* End non-truncate path */

  /* Update the sqlite_sequence table by storing the content of the
  ** maximum rowid counter values recorded while inserting into
  ** autoincrement tables.
  */
  
// ABS Label 263
if(pParse->pTriggerTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}

// COR Label 264
if((pParse->nested == 0 || pParse->pTriggerTab == 0) != (pParse->nested == 0 && pParse->pTriggerTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 264);
}

// ROR Label 265
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
// ROR Label 266
if((pParse->pTriggerTab != 0) != (pParse->pTriggerTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}

// MCC Label 267
if(pParse->nested == 0 && pParse->pTriggerTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(pParse->nested == 0 && !(pParse->pTriggerTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if(!(pParse->nested == 0) && pParse->pTriggerTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(!(pParse->nested == 0) && !(pParse->pTriggerTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    
// ABS Label 271
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
sqlite3AutoincrementEnd(pParse);
  }

  /* Return the number of rows that were deleted. If this routine is 
  ** generating code because of a call to sqlite3NestedParse(), do not
  ** invoke the callback function.
  */
  
// ABS Label 272
if(memCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
if( memCnt ){
    
// ABS Label 273
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

// ABS Label 274
if(memCnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
sqlite3VdbeAddOp2(v, OP_ChngCntRow, memCnt, 1);
    
// ABS Label 275
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
sqlite3VdbeSetNumCols(v, 1);
    
// ABS Label 276
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows deleted", SQLITE_STATIC);
  }

delete_from_cleanup:
  sqlite3AuthContextPop(&sContext);
  
// ABS Label 34
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ABS Label 35
if(pTabList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
sqlite3SrcListDelete(db, pTabList);
  
// ABS Label 36
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ABS Label 37
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
sqlite3ExprDelete(db, pWhere);
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) 
  sqlite3ExprListDelete(db, pOrderBy);
  sqlite3ExprDelete(db, pLimit);
#endif
  
// ABS Label 38
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
sqlite3DbFree(db, aToOpen);
  return;
}
/* Make sure "isView" and other macros defined above are undefined. Otherwise
** they may interfere with compilation of other functions in this file
** (or in another file, if this file becomes part of the amalgamation).  */
#ifdef isView
 #undef isView
#endif
#ifdef pTrigger
 #undef pTrigger
#endif

/*
** This routine generates VDBE code that causes a single row of a
** single table to be deleted.  Both the original table entry and
** all indices are removed.
**
** Preconditions:
**
**   1.  iDataCur is an open cursor on the btree that is the canonical data
**       store for the table.  (This will be either the table itself,
**       in the case of a rowid table, or the PRIMARY KEY index in the case
**       of a WITHOUT ROWID table.)
**
**   2.  Read/write cursors for all indices of pTab must be open as
**       cursor number iIdxCur+i for the i-th index.
**
**   3.  The primary key for the row to be deleted must be stored in a
**       sequence of nPk memory cells starting at iPk.  If nPk==0 that means
**       that a search record formed from OP_MakeRecord is contained in the
**       single memory location iPk.
**
** eMode:
**   Parameter eMode may be passed either ONEPASS_OFF (0), ONEPASS_SINGLE, or
**   ONEPASS_MULTI.  If eMode is not ONEPASS_OFF, then the cursor
**   iDataCur already points to the row to delete. If eMode is ONEPASS_OFF
**   then this function must seek iDataCur to the entry identified by iPk
**   and nPk before reading from it.
**
**   If eMode is ONEPASS_MULTI, then this call is being made as part
**   of a ONEPASS delete that affects multiple rows. In this case, if 
**   iIdxNoSeek is a valid cursor number (>=0) and is not the same as
**   iDataCur, then its position should be preserved following the delete
**   operation. Or, if iIdxNoSeek is not a valid cursor number, the
**   position of iDataCur should be preserved instead.
**
** iIdxNoSeek:
**   If iIdxNoSeek is a valid cursor number (>=0) not equal to iDataCur,
**   then it identifies an index cursor (from within array of cursors
**   starting at iIdxCur) that already points to the index entry to be deleted.
**   Except, this optimization is disabled if there are BEFORE triggers since
**   the trigger body might have moved the cursor.
*/
void sqlite3GenerateRowDelete(
  Parse *pParse,     /* Parsing context */
  Table *pTab,       /* Table containing the row to be deleted */
  Trigger *pTrigger, /* List of triggers to (potentially) fire */
  int iDataCur,      /* Cursor from which column data is extracted */
  int iIdxCur,       /* First index cursor */
  int iPk,           /* First memory cell containing the PRIMARY KEY */
  i16 nPk,           /* Number of PRIMARY KEY memory cells */
  u8 count,          /* If non-zero, increment the row change counter */
  u8 onconf,         /* Default ON CONFLICT policy for triggers */
  u8 eMode,          /* ONEPASS_OFF, _SINGLE, or _MULTI.  See above */
  int iIdxNoSeek     /* Cursor number of cursor that does not need seeking */
){
  
// ABS Label 277
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
Vdbe *v = pParse->pVdbe;        /* Vdbe */
  int iOld = 0;                   /* First register in OLD.* array */
  int iLabel;                     /* Label resolved to end of generated code */
  u8 opSeek;                      /* Seek opcode */

  /* Vdbe is guaranteed to have been allocated by this stage. */
  assert( v );
  VdbeModuleComment((v, "BEGIN: GenRowDel(%d,%d,%d,%d)",
                         iDataCur, iIdxCur, iPk, (int)nPk));

  /* Seek cursor iCur to the row to delete. If this row no longer exists 
  ** (this can happen if a trigger program has already deleted it), do
  ** not attempt to delete it or fire any DELETE triggers.  */
  iLabel = sqlite3VdbeMakeLabel(pParse);
  opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;
  
// ROR Label 288
if((eMode != 0) != (eMode == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
if( eMode==ONEPASS_OFF ){
    
// ABS Label 289
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// ABS Label 290
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ABS Label 291
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ABS Label 292
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
    VdbeCoverageIf(v, opSeek==OP_NotExists);
    VdbeCoverageIf(v, opSeek==OP_NotFound);
  }
 
  /* If there are any triggers to fire, allocate a range of registers to
  ** use for the old.* references in the triggers.  */
  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
    u32 mask;                     /* Mask of OLD.* columns in use */
    int iCol;                     /* Iterator used while populating OLD.* */
    int addrStart;                /* Start of BEFORE trigger programs */

    /* TODO: Could use temporary registers here. Also could attempt to
    ** avoid copying the contents of the rowid register.  */
    mask = sqlite3TriggerColmask(
        pParse, pTrigger, 0, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onconf
    );
    mask |= sqlite3FkOldmask(pParse, pTab);
    iOld = pParse->nMem+1;
    pParse->nMem += (1 + pTab->nCol);

    /* Populate the OLD.* pseudo-table register array. These values will be 
    ** used by any BEFORE and AFTER triggers that exist.  */
    
// ABS Label 293
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ABS Label 294
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}

// ABS Label 295
if(iOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
sqlite3VdbeAddOp2(v, OP_Copy, iPk, iOld);
    iCol = 0;

// ABS Label 304
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}

// ROR Label 305
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}
// ROR Label 306
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 306);
}
// ROR Label 307
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 307);
}
for(; iCol<pTab->nCol; iCol++){
      testcase( mask!=0xffffffff && iCol==31 );
      testcase( mask!=0xffffffff && iCol==32 );
      
// ABS Label 312
if(mask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}

// COR Label 313
if((mask == 4294967295U && (iCol <= 31 && (mask & (((unsigned int)1) << (iCol))) != 0)) != (mask == 4294967295U || (iCol <= 31 && (mask & (((unsigned int)1) << (iCol))) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 313);
}

// ROR Label 314
if((mask != 4294967295U) != (mask == 4294967295U))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}

// MCC Label 315
if(mask == 4294967295U && ( iCol <= 31 && (mask & (((unsigned int)1) << (iCol))) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 315);
}
// MCC Label 316
if(mask == 4294967295U && ( iCol <= 31 && !((mask & (((unsigned int)1) << (iCol))) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 316);
}
// MCC Label 317
if(mask == 4294967295U && ( !(iCol <= 31) && (mask & (((unsigned int)1) << (iCol))) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 317);
}
// MCC Label 318
if(mask == 4294967295U && ( !(iCol <= 31) && !((mask & (((unsigned int)1) << (iCol))) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 318);
}
// MCC Label 319
if(!(mask == 4294967295U) && ( iCol <= 31 && (mask & (((unsigned int)1) << (iCol))) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 319);
}
// MCC Label 320
if(!(mask == 4294967295U) && ( iCol <= 31 && !((mask & (((unsigned int)1) << (iCol))) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 320);
}
// MCC Label 321
if(!(mask == 4294967295U) && ( !(iCol <= 31) && (mask & (((unsigned int)1) << (iCol))) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 321);
}
// MCC Label 322
if(!(mask == 4294967295U) && ( !(iCol <= 31) && !((mask & (((unsigned int)1) << (iCol))) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){
        int kk = sqlite3TableColumnToStorage(pTab, iCol);
        
// ABS Label 323
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}

// ABS Label 324
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ABS Label 325
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}

// ABS Label 326
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ABS Label 327
if(iOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
// ABS Label 328
if(kk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// AOR Label 329
if(iOld + kk - 1 != iOld + kk + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 329);
}
// AOR Label 330
if(iOld + kk / 1 != iOld + kk + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 330);
}
// AOR Label 331
if(iOld + kk * 1 != iOld + kk + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 331);
}
// AOR Label 332
if(iOld - kk != iOld + kk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 332);
}
// AOR Label 333
if(iOld / kk != iOld + kk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 333);
}
// AOR Label 334
if(iOld * kk != iOld + kk)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 334);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
      }
    };
// ABS Label 308
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// ROR Label 309
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
// ROR Label 310
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}


    /* Invoke BEFORE DELETE trigger programs. */
    addrStart = sqlite3VdbeCurrentAddr(v);
    
// ABS Label 296
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// ABS Label 297
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ABS Label 298
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}

// ABS Label 299
if(iOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}

// ABS Label 300
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
sqlite3CodeRowTrigger(pParse, pTrigger, 
        TK_DELETE, 0, TRIGGER_BEFORE, pTab, iOld, onconf, iLabel
    );

    /* If any BEFORE triggers were coded, then seek the cursor to the 
    ** row to be deleted again. It may be that the BEFORE triggers moved
    ** the cursor or already deleted the row that the cursor was
    ** pointing to.
    **
    ** Also disable the iIdxNoSeek optimization since the BEFORE trigger
    ** may have moved that cursor.
    */
    if( addrStart<sqlite3VdbeCurrentAddr(v) ){
      
// ABS Label 335
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}

// ABS Label 336
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ABS Label 337
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}

// ABS Label 338
if(iPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
      VdbeCoverageIf(v, opSeek==OP_NotExists);
      VdbeCoverageIf(v, opSeek==OP_NotFound);
      testcase( iIdxNoSeek>=0 );
      iIdxNoSeek = -1;
    }

    /* Do FK processing. This call checks that any FK constraints that
    ** refer to this table (i.e. constraints attached to other tables) 
    ** are not violated by deleting this row.  */
    
// ABS Label 301
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ABS Label 302
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}

// ABS Label 303
if(iOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);
  }

  /* Delete the index and table entries. Skip this step if pTab is really
  ** a view (in which case the only effect of the DELETE statement is to
  ** fire the INSTEAD OF triggers).  
  **
  ** If variable 'count' is non-zero, then this OP_Delete instruction should
  ** invoke the update-hook. The pre-update-hook, on the other hand should
  ** be invoked unless table pTab is a system table. The difference is that
  ** the update-hook is not invoked for rows removed by REPLACE, but the 
  ** pre-update-hook is.
  */ 
  
// ABS Label 339
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}

// ROR Label 340
if((pTab->pSelect != 0) != (pTab->pSelect == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 340);
}
if( pTab->pSelect==0 ){
    u8 p5 = 0;
    
// ABS Label 341
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}

// ABS Label 342
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// ABS Label 343
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}

// ABS Label 344
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}

// ABS Label 345
if(iIdxNoSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}
sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,iIdxNoSeek);
    
// ABS Label 346
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}

// ABS Label 347
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}
sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, (count?OPFLAG_NCHANGE:0));
    if( pParse->nested==0 || 0==sqlite3_stricmp(pTab->zName, "sqlite_stat1") ){
      
// ABS Label 349
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
sqlite3VdbeAppendP4(v, (char*)pTab, P4_TABLE);
    }
    
// ROR Label 350
if((eMode == 0) != (eMode != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 350);
}
if( eMode!=ONEPASS_OFF ){
      
// ABS Label 351
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
sqlite3VdbeChangeP5(v, OPFLAG_AUXDELETE);
    }
    
// ABS Label 352
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}
// ABS Label 353
if(iIdxNoSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}

// COR Label 354
if((iIdxNoSeek >= 0 || iIdxNoSeek != iDataCur) != (iIdxNoSeek >= 0 && iIdxNoSeek != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 354);
}

// ROR Label 355
if((iIdxNoSeek < 0) != (iIdxNoSeek >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}
// ROR Label 356
if((iIdxNoSeek > 0) != (iIdxNoSeek >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 356);
}
// ROR Label 357
if((iIdxNoSeek <= 0) != (iIdxNoSeek >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
// ROR Label 358
if((iIdxNoSeek == iDataCur) != (iIdxNoSeek != iDataCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}

// MCC Label 359
if(iIdxNoSeek >= 0 && iIdxNoSeek != iDataCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 359);
}
// MCC Label 360
if(iIdxNoSeek >= 0 && !(iIdxNoSeek != iDataCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 360);
}
// MCC Label 361
if(!(iIdxNoSeek >= 0) && iIdxNoSeek != iDataCur ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
// MCC Label 362
if(!(iIdxNoSeek >= 0) && !(iIdxNoSeek != iDataCur) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 362);
}
if( iIdxNoSeek>=0 && iIdxNoSeek!=iDataCur ){
      
// ABS Label 363
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 363);
}

// ABS Label 364
if(iIdxNoSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
sqlite3VdbeAddOp1(v, OP_Delete, iIdxNoSeek);
    }
    
// ROR Label 365
if((eMode != 2) != (eMode == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 365);
}
if( eMode==ONEPASS_MULTI ) { p5 |= OPFLAG_SAVEPOSITION;
}
    
// ABS Label 348
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}
sqlite3VdbeChangeP5(v, p5);
  }

  /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to
  ** handle rows (possibly in other tables) that refer via a foreign key
  ** to the row just deleted. */ 
  
// ABS Label 278
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}

// ABS Label 279
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}

// ABS Label 280
if(iOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);

  /* Invoke AFTER DELETE trigger programs. */
  
// ABS Label 281
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// ABS Label 282
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}

// ABS Label 283
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ABS Label 284
if(iOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}

// ABS Label 285
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
sqlite3CodeRowTrigger(pParse, pTrigger, 
      TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel
  );

  /* Jump here if the row had already been deleted before any BEFORE
  ** trigger programs were invoked. Or if a trigger program throws a 
  ** RAISE(IGNORE) exception.  */
  
// ABS Label 286
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ABS Label 287
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
sqlite3VdbeResolveLabel(v, iLabel);
  VdbeModuleComment((v, "END: GenRowDel()"));
}

/*
** This routine generates VDBE code that causes the deletion of all
** index entries associated with a single row of a single table, pTab
**
** Preconditions:
**
**   1.  A read/write cursor "iDataCur" must be open on the canonical storage
**       btree for the table pTab.  (This will be either the table itself
**       for rowid tables or to the primary key index for WITHOUT ROWID
**       tables.)
**
**   2.  Read/write cursors for all indices of pTab must be open as
**       cursor number iIdxCur+i for the i-th index.  (The pTab->pIndex
**       index is the 0-th index.)
**
**   3.  The "iDataCur" cursor must be already be positioned on the row
**       that is to be deleted.
*/
void sqlite3GenerateRowIndexDelete(
  Parse *pParse,     /* Parsing and code generating context */
  Table *pTab,       /* Table containing the row to be deleted */
  int iDataCur,      /* Cursor of table holding data. */
  int iIdxCur,       /* First index cursor */
  int *aRegIdx,      /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */
  int iIdxNoSeek     /* Do not delete from this cursor */
){
  int i;             /* Index loop counter */
  int r1 = -1;       /* Register holding an index key */
  int iPartIdxLabel; /* Jump destination for skipping partial index entries */
  Index *pIdx;       /* Current index */
  Index *pPrior = 0; /* Prior index */
  Vdbe *v;           /* The prepared statement under construction */
  Index *pPk;        /* PRIMARY KEY index, or NULL for rowid tables */

  v = pParse->pVdbe;
  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);
  i = 0 , pIdx = pTab->pIndex;

// ABS Label 366
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}
for(; pIdx; i++, pIdx=pIdx->pNext){
    assert( iIdxCur+i!=iDataCur || pPk==pIdx );
    
// ABS Label 378
if(aRegIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 378);
}
// ABS Label 379
if(aRegIdx[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}
// ABS Label 380
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}

// COR Label 381
if((aRegIdx != 0 || aRegIdx[i] == 0) != (aRegIdx != 0 && aRegIdx[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 381);
}

// ROR Label 382
if((aRegIdx == 0) != (aRegIdx != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 382);
}
// ROR Label 383
if((aRegIdx[i] != 0) != (aRegIdx[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 383);
}

// MCC Label 384
if(aRegIdx != 0 && aRegIdx[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
// MCC Label 385
if(aRegIdx != 0 && !(aRegIdx[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
// MCC Label 386
if(!(aRegIdx != 0) && aRegIdx[i] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 386);
}
// MCC Label 387
if(!(aRegIdx != 0) && !(aRegIdx[i] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 387);
}
if( aRegIdx!=0 && aRegIdx[i]==0 ) { continue;
}
    
// ABS Label 388
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
// ABS Label 389
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}

// ROR Label 390
if((pIdx != pPk) != (pIdx == pPk))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 390);
}
if( pIdx==pPk ) { continue;
}
    
// ABS Label 391
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}
// ABS Label 392
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}
// ABS Label 393
if(iIdxNoSeek < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}

// AOR Label 394
if(iIdxCur - i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 394);
}
// AOR Label 395
if(iIdxCur / i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 395);
}
// AOR Label 396
if(iIdxCur * i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 396);
}

// ROR Label 397
if((iIdxCur + i != iIdxNoSeek) != (iIdxCur + i == iIdxNoSeek))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 397);
}
if( iIdxCur+i==iIdxNoSeek ) { continue;
}
    VdbeModuleComment((v, "GenRowIdxDel for %s", pIdx->zName));
    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,
        &iPartIdxLabel, pPrior, r1);
    
// ABS Label 368
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}

// ABS Label 369
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
// ABS Label 370
if(iIdxCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}

// AOR Label 371
if(iIdxCur - i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 371);
}
// AOR Label 372
if(iIdxCur / i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 372);
}
// AOR Label 373
if(iIdxCur * i != iIdxCur + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 373);
}

// ABS Label 374
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
sqlite3VdbeAddOp3(v, OP_IdxDelete, iIdxCur+i, r1,
        pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);
    
// ABS Label 375
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}
sqlite3VdbeChangeP5(v, 1);  /* Cause IdxDelete to error if no entry found */
    
// ABS Label 376
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 376);
}

// ABS Label 377
if(iPartIdxLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}
sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
    pPrior = pIdx;
  };
// ABS Label 367
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}

}

/*
** Generate code that will assemble an index key and stores it in register
** regOut.  The key with be for index pIdx which is an index on pTab.
** iCur is the index of a cursor open on the pTab table and pointing to
** the entry that needs indexing.  If pTab is a WITHOUT ROWID table, then
** iCur must be the cursor of the PRIMARY KEY index.
**
** Return a register number which is the first in a block of
** registers that holds the elements of the index key.  The
** block of registers has already been deallocated by the time
** this routine returns.
**
** If *piPartIdxLabel is not NULL, fill it in with a label and jump
** to that label if pIdx is a partial index that should be skipped.
** The label should be resolved using sqlite3ResolvePartIdxLabel().
** A partial index should be skipped if its WHERE clause evaluates
** to false or null.  If pIdx is not a partial index, *piPartIdxLabel
** will be set to zero which is an empty label that is ignored by
** sqlite3ResolvePartIdxLabel().
**
** The pPrior and regPrior parameters are used to implement a cache to
** avoid unnecessary register loads.  If pPrior is not NULL, then it is
** a pointer to a different index for which an index key has just been
** computed into register regPrior.  If the current pIdx index is generating
** its key into the same sequence of registers and if pPrior and pIdx share
** a column in common, then the register corresponding to that column already
** holds the correct value and the loading of that register is skipped.
** This optimization is helpful when doing a DELETE or an INTEGRITY_CHECK 
** on a table with multiple indices, and especially with the ROWID or
** PRIMARY KEY columns of the index.
*/
int sqlite3GenerateIndexKey(
  Parse *pParse,       /* Parsing context */
  Index *pIdx,         /* The index for which to generate a key */
  int iDataCur,        /* Cursor number from which to take column data */
  int regOut,          /* Put the new key into this register if not 0 */
  int prefixOnly,      /* Compute only a unique prefix of the key */
  int *piPartIdxLabel, /* OUT: Jump to this label to skip partial index */
  Index *pPrior,       /* Previously generated index key */
  int regPrior         /* Register holding previous generated key */
){
  
// ABS Label 398
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}
Vdbe *v = pParse->pVdbe;
  int j;
  int regBase;
  int nCol;

  
// ABS Label 402
if(piPartIdxLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}
if( piPartIdxLabel ){
    
// ABS Label 403
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}
if( pIdx->pPartIdxWhere ){
      *piPartIdxLabel = sqlite3VdbeMakeLabel(pParse);
      pParse->iSelfTab = iDataCur + 1;
      
// ABS Label 404
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}

// ABS Label 405
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}

// ABS Label 406
if(*piPartIdxLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel, 
                            SQLITE_JUMPIFNULL);
      pParse->iSelfTab = 0;
      pPrior = 0; /* Ticket a9efb42811fa41ee 2019-11-02;
                  ** pPartIdxWhere may have corrupted regPrior registers */
    }else{
      *piPartIdxLabel = 0;
    }
  }
  nCol = (prefixOnly && pIdx->uniqNotNull) ? pIdx->nKeyCol : pIdx->nColumn;
  regBase = sqlite3GetTempRange(pParse, nCol);
  
// ABS Label 407
if(pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// COR Label 408
if((pPrior || (regBase != regPrior || pPrior->pPartIdxWhere)) != (pPrior && (regBase != regPrior || pPrior->pPartIdxWhere)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 408);
}

// MCC Label 409
if(pPrior && ( regBase != regPrior && pPrior->pPartIdxWhere ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 409);
}
// MCC Label 410
if(pPrior && ( regBase != regPrior && !(pPrior->pPartIdxWhere) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 410);
}
// MCC Label 411
if(pPrior && ( !(regBase != regPrior) && pPrior->pPartIdxWhere ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
// MCC Label 412
if(pPrior && ( !(regBase != regPrior) && !(pPrior->pPartIdxWhere) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
// MCC Label 413
if(!(pPrior) && ( regBase != regPrior && pPrior->pPartIdxWhere ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 413);
}
// MCC Label 414
if(!(pPrior) && ( regBase != regPrior && !(pPrior->pPartIdxWhere) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 414);
}
// MCC Label 415
if(!(pPrior) && ( !(regBase != regPrior) && pPrior->pPartIdxWhere ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 415);
}
// MCC Label 416
if(!(pPrior) && ( !(regBase != regPrior) && !(pPrior->pPartIdxWhere) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 416);
}
if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) { pPrior = 0;
}
  j = 0;

// ABS Label 417
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
// ABS Label 418
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}

// ROR Label 419
if((j <= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}
// ROR Label 420
if((j > nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
// ROR Label 421
if((j >= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 421);
}
for(; j<nCol; j++){
    
// ABS Label 436
if(pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 436);
}

// COR Label 437
if((pPrior && pPrior->aiColumn[j] == pIdx->aiColumn[j] || pPrior->aiColumn[j] != (-2)) != (pPrior && pPrior->aiColumn[j] == pIdx->aiColumn[j] && pPrior->aiColumn[j] != (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 437);
}
// COR Label 438
if((pPrior || pPrior->aiColumn[j] == pIdx->aiColumn[j]) != (pPrior && pPrior->aiColumn[j] == pIdx->aiColumn[j]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 438);
}

// ROR Label 439
if((pPrior->aiColumn[j] != pIdx->aiColumn[j]) != (pPrior->aiColumn[j] == pIdx->aiColumn[j]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 439);
}
// ROR Label 440
if((pPrior->aiColumn[j] == (-2)) != (pPrior->aiColumn[j] != (-2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 440);
}

// MCC Label 441
if(pPrior && pPrior->aiColumn[j] == pIdx->aiColumn[j] && pPrior->aiColumn[j] != (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(pPrior && pPrior->aiColumn[j] == pIdx->aiColumn[j] && !(pPrior->aiColumn[j] != (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(pPrior && !(pPrior->aiColumn[j] == pIdx->aiColumn[j]) && pPrior->aiColumn[j] != (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}
// MCC Label 444
if(pPrior && !(pPrior->aiColumn[j] == pIdx->aiColumn[j]) && !(pPrior->aiColumn[j] != (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 444);
}
// MCC Label 445
if(!(pPrior) && pPrior->aiColumn[j] == pIdx->aiColumn[j] && pPrior->aiColumn[j] != (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 445);
}
// MCC Label 446
if(!(pPrior) && pPrior->aiColumn[j] == pIdx->aiColumn[j] && !(pPrior->aiColumn[j] != (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 446);
}
// MCC Label 447
if(!(pPrior) && !(pPrior->aiColumn[j] == pIdx->aiColumn[j]) && pPrior->aiColumn[j] != (-2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 447);
}
// MCC Label 448
if(!(pPrior) && !(pPrior->aiColumn[j] == pIdx->aiColumn[j]) && !(pPrior->aiColumn[j] != (-2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 448);
}
if( pPrior
     && pPrior->aiColumn[j]==pIdx->aiColumn[j]
     && pPrior->aiColumn[j]!=XN_EXPR
    ){
      /* This column was already computed by the previous index */
      continue;
    }
    
// ABS Label 427
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}

// ABS Label 428
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// ABS Label 429
if(iDataCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}

// ABS Label 430
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}

// ABS Label 431
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
// ABS Label 432
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}

// AOR Label 433
if(regBase - j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 433);
}
// AOR Label 434
if(regBase / j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 434);
}
// AOR Label 435
if(regBase * j != regBase + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 435);
}
sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j);
    
// ROR Label 449
if((pIdx->aiColumn[j] < 0) != (pIdx->aiColumn[j] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 449);
}
// ROR Label 450
if((pIdx->aiColumn[j] > 0) != (pIdx->aiColumn[j] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 450);
}
// ROR Label 451
if((pIdx->aiColumn[j] <= 0) != (pIdx->aiColumn[j] >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
if( pIdx->aiColumn[j]>=0 ){
      /* If the column affinity is REAL but the number is an integer, then it
      ** might be stored in the table as an integer (using a compact
      ** representation) then converted to REAL by an OP_RealAffinity opcode.
      ** But we are getting ready to store this value back into an index, where
      ** it should be converted by to INTEGER again.  So omit the
      ** OP_RealAffinity opcode if it is present */
      
// ABS Label 452
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}
sqlite3VdbeDeletePriorOpcode(v, OP_RealAffinity);
    }
  };
// ABS Label 422
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}
// ABS Label 423
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}

// ROR Label 424
if((j <= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 424);
}
// ROR Label 425
if((j > nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
// ROR Label 426
if((j >= nCol) != (j < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 426);
}

  
// ABS Label 453
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
if( regOut ){
    
// ABS Label 454
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}

// ABS Label 455
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}

// ABS Label 456
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}

// ABS Label 457
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regOut);
  }
  
// ABS Label 399
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}

// ABS Label 400
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}

// ABS Label 401
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}
sqlite3ReleaseTempRange(pParse, regBase, nCol);
  
// ABS Label 458
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
return regBase;
}

/*
** If a prior call to sqlite3GenerateIndexKey() generated a jump-over label
** because it was a partial index, then this routine should be called to
** resolve that label.
*/
void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){
  
// ABS Label 459
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}
if( iLabel ){
    
// ABS Label 460
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 460);
}

// ABS Label 461
if(iLabel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 461);
}
sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);
  }
}
