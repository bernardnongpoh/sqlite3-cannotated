/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2004 May 26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to implement APIs that are part of the
** VDBE.
*/
#include "sqliteInt.h"
#include "vdbeInt.h"

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Return TRUE (non-zero) of the statement supplied as an argument needs
** to be recompiled.  A statement needs to be recompiled whenever the
** execution environment changes in a way that would alter the program
** that sqlite3_prepare() generates.  For example, if new functions or
** collating sequences are registered or if an authorizer function is
** added or changed.
*/
int sqlite3_expired(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  
// ABS Label 7
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// COR Label 8
if((p == 0 && p->expired) != (p == 0 || p->expired))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 8);
}

// ROR Label 9
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 9);
}

// MCC Label 10
if(p == 0 && p->expired ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 10);
}
// MCC Label 11
if(p == 0 && !(p->expired) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 11);
}
// MCC Label 12
if(!(p == 0) && p->expired ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 12);
}
// MCC Label 13
if(!(p == 0) && !(p->expired) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 13);
}
return p==0 || p->expired;
}
#endif

/*
** Check on a Vdbe to make sure it has not been finalized.  Log
** an error and return true if it has been finalized (or is otherwise
** invalid).  Return false if it is ok.
*/
static int vdbeSafety(Vdbe *p){
  
// ABS Label 14
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ROR Label 15
if((p->db != 0) != (p->db == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
if( p->db==0 ){
    sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");
    return 1;
  }else{
    return 0;
  }
}
static int vdbeSafetyNotNull(Vdbe *p){
  
// ABS Label 16
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ROR Label 17
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
if( p==0 ){
    sqlite3_log(SQLITE_MISUSE, "API called with NULL prepared statement");
    return 1;
  }else{
    return vdbeSafety(p);
  }
}

#ifndef SQLITE_OMIT_TRACE
/*
** Invoke the profile callback.  This routine is only called if we already
** know that the profile callback is defined and needs to be invoked.
*/
static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){
  sqlite3_int64 iNow;
  sqlite3_int64 iElapse;
  assert( p->startTime>0 );
  assert( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0 );
  assert( db->init.busy==0 );
  assert( p->zSql!=0 );
  
// ABS Label 18
if(db->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);
  iElapse = (iNow - p->startTime)*1000000;
#ifndef SQLITE_OMIT_DEPRECATED
  
// ABS Label 19
if(db->xProfile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
if( db->xProfile ){
    
// ABS Label 20
if(db->pProfileArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
db->xProfile(db->pProfileArg, p->zSql, iElapse);
  }
#endif
  
// AOR Label 21
if(db->mTrace | 2 != db->mTrace & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 21);
}
// AOR Label 22
if(db->mTrace ^ 2 != db->mTrace & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 22);
}
if( db->mTrace & SQLITE_TRACE_PROFILE ){
    
// ABS Label 23
if(db->pTraceArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
db->trace.xV2(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);
  }
  p->startTime = 0;
}
/*
** The checkProfileCallback(DB,P) macro checks to see if a profile callback
** is needed, and it invokes the callback if it is needed.
*/
# define checkProfileCallback(DB,P) \
   if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }
#else
# define checkProfileCallback(DB,P)  /*no-op*/
#endif

/*
** The following routine destroys a virtual machine that is created by
** the sqlite3_compile() routine. The integer returned is an SQLITE_
** success/failure code that describes the result of executing the virtual
** machine.
**
** This routine sets the error code and string returned by
** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
*/
int sqlite3_finalize(sqlite3_stmt *pStmt){
  int rc;
  
// ABS Label 24
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// ROR Label 25
if((pStmt != 0) != (pStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
if( pStmt==0 ){
    /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
    ** pointer is a harmless no-op. */
    rc = SQLITE_OK;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    
// ABS Label 26
if(v->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3 *db = v->db;
    if( vdbeSafety(v) ) { return SQLITE_MISUSE_BKPT;
}
    
// ABS Label 27
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
sqlite3_mutex_enter(db->mutex);
    checkProfileCallback(db, v);
    rc = sqlite3VdbeFinalize(v);
    rc = sqlite3ApiExit(db, rc);
    
// ABS Label 28
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}
sqlite3LeaveMutexAndCloseZombie(db);
  }
  
// ABS Label 35
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
return rc;
}

/*
** Terminate the current execution of an SQL statement and reset it
** back to its starting state so that it can be reused. A success code from
** the prior execution is returned.
**
** This routine sets the error code and string returned by
** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
*/
int sqlite3_reset(sqlite3_stmt *pStmt){
  int rc;
  
// ABS Label 36
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ROR Label 37
if((pStmt != 0) != (pStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
if( pStmt==0 ){
    rc = SQLITE_OK;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    
// ABS Label 38
if(v->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
sqlite3 *db = v->db;
    
// ABS Label 39
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
sqlite3_mutex_enter(db->mutex);
    checkProfileCallback(db, v);
    rc = sqlite3VdbeReset(v);
    
// ABS Label 40
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
sqlite3VdbeRewind(v);
    assert( (rc & (db->errMask))==rc );
    rc = sqlite3ApiExit(db, rc);
    
// ABS Label 41
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
sqlite3_mutex_leave(db->mutex);
  }
  
// ABS Label 48
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}
return rc;
}

/*
** Set all the parameters in the compiled SQL statement to NULL.
*/
int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
  int i;
  int rc = SQLITE_OK;
  Vdbe *p = (Vdbe*)pStmt;
#if SQLITE_THREADSAFE
  
// ABS Label 49
if(((Vdbe *)pStmt)->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex;
#endif
  
// ABS Label 50
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
sqlite3_mutex_enter(mutex);
  i = 0;

// ABS Label 52
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}

// ROR Label 53
if((i <= p->nVar) != (i < p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}
// ROR Label 54
if((i > p->nVar) != (i < p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
// ROR Label 55
if((i >= p->nVar) != (i < p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
for(; i<p->nVar; i++){
    sqlite3VdbeMemRelease(&p->aVar[i]);
    p->aVar[i].flags = MEM_Null;
  };
// ABS Label 56
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}

// ROR Label 57
if((i <= p->nVar) != (i < p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if((i > p->nVar) != (i < p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((i >= p->nVar) != (i < p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}

  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );
  
// ABS Label 60
if(p->expmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
if( p->expmask ){
    p->expired = 1;
  }
  
// ABS Label 51
if(mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
sqlite3_mutex_leave(mutex);
  
// ABS Label 61
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
return rc;
}


/**************************** sqlite3_value_  *******************************
** The following routines extract information from a Mem or sqlite3_value
** structure.
*/
const void *sqlite3_value_blob(sqlite3_value *pVal){
  Mem *p = (Mem*)pVal;
  
// AOR Label 62
if(p->flags | (16 | 2) != p->flags & (16 | 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 62);
}
// AOR Label 63
if(p->flags ^ (16 | 2) != p->flags & (16 | 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 63);
}
if( p->flags & (MEM_Blob|MEM_Str) ){
    if( ExpandBlob(p)!=SQLITE_OK ){
      assert( p->flags==MEM_Null && p->z==0 );
      return 0;
    }
    p->flags |= MEM_Blob;
    return p->n ? p->z : 0;
  }else{
    return sqlite3_value_text(pVal);
  }
}
int sqlite3_value_bytes(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, SQLITE_UTF8);
}
int sqlite3_value_bytes16(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);
}
double sqlite3_value_double(sqlite3_value *pVal){
  return sqlite3VdbeRealValue((Mem*)pVal);
}
int sqlite3_value_int(sqlite3_value *pVal){
  return (int)sqlite3VdbeIntValue((Mem*)pVal);
}
sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){
  return sqlite3VdbeIntValue((Mem*)pVal);
}
unsigned int sqlite3_value_subtype(sqlite3_value *pVal){
  Mem *pMem = (Mem*)pVal;
  return ((pMem->flags & MEM_Subtype) ? pMem->eSubtype : 0);
}
void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){
  Mem *p = (Mem*)pVal;
  
// ABS Label 64
if(zPType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}

// MCC Label 65
if((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768) && zPType != 0 && p->eSubtype == 'p' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 65);
}
// MCC Label 66
if((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768) && zPType != 0 && !(p->eSubtype == 'p') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
// MCC Label 67
if((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768) && !(zPType != 0) && p->eSubtype == 'p' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 67);
}
// MCC Label 68
if((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768) && !(zPType != 0) && !(p->eSubtype == 'p') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 68);
}
// MCC Label 69
if(!((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768)) && zPType != 0 && p->eSubtype == 'p' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 69);
}
// MCC Label 70
if(!((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768)) && zPType != 0 && !(p->eSubtype == 'p') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 70);
}
// MCC Label 71
if(!((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768)) && !(zPType != 0) && p->eSubtype == 'p' && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if(!((p->flags & (49599 | 512 | 32768)) == (1 | 512 | 32768)) && !(zPType != 0) && !(p->eSubtype == 'p') && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
if( (p->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==
                 (MEM_Null|MEM_Term|MEM_Subtype)
   && zPType!=0
   && p->eSubtype=='p'
   && strcmp(p->u.zPType, zPType)==0
  ){
    return (void*)p->z;
  }else{
    return 0;
  }
}
const unsigned char *sqlite3_value_text(sqlite3_value *pVal){
  return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_value_text16(sqlite3_value* pVal){
  return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);
}
const void *sqlite3_value_text16be(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, SQLITE_UTF16BE);
}
const void *sqlite3_value_text16le(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, SQLITE_UTF16LE);
}
#endif /* SQLITE_OMIT_UTF16 */
/* EVIDENCE-OF: R-12793-43283 Every value in SQLite has one of five
** fundamental datatypes: 64-bit signed integer 64-bit IEEE floating
** point number string BLOB NULL
*/
int sqlite3_value_type(sqlite3_value* pVal){
  static const u8 aType[] = {
     SQLITE_BLOB,     /* 0x00 (not possible) */
     SQLITE_NULL,     /* 0x01 NULL */
     SQLITE_TEXT,     /* 0x02 TEXT */
     SQLITE_NULL,     /* 0x03 (not possible) */
     SQLITE_INTEGER,  /* 0x04 INTEGER */
     SQLITE_NULL,     /* 0x05 (not possible) */
     SQLITE_INTEGER,  /* 0x06 INTEGER + TEXT */
     SQLITE_NULL,     /* 0x07 (not possible) */
     SQLITE_FLOAT,    /* 0x08 FLOAT */
     SQLITE_NULL,     /* 0x09 (not possible) */
     SQLITE_FLOAT,    /* 0x0a FLOAT + TEXT */
     SQLITE_NULL,     /* 0x0b (not possible) */
     SQLITE_INTEGER,  /* 0x0c (not possible) */
     SQLITE_NULL,     /* 0x0d (not possible) */
     SQLITE_INTEGER,  /* 0x0e (not possible) */
     SQLITE_NULL,     /* 0x0f (not possible) */
     SQLITE_BLOB,     /* 0x10 BLOB */
     SQLITE_NULL,     /* 0x11 (not possible) */
     SQLITE_TEXT,     /* 0x12 (not possible) */
     SQLITE_NULL,     /* 0x13 (not possible) */
     SQLITE_INTEGER,  /* 0x14 INTEGER + BLOB */
     SQLITE_NULL,     /* 0x15 (not possible) */
     SQLITE_INTEGER,  /* 0x16 (not possible) */
     SQLITE_NULL,     /* 0x17 (not possible) */
     SQLITE_FLOAT,    /* 0x18 FLOAT + BLOB */
     SQLITE_NULL,     /* 0x19 (not possible) */
     SQLITE_FLOAT,    /* 0x1a (not possible) */
     SQLITE_NULL,     /* 0x1b (not possible) */
     SQLITE_INTEGER,  /* 0x1c (not possible) */
     SQLITE_NULL,     /* 0x1d (not possible) */
     SQLITE_INTEGER,  /* 0x1e (not possible) */
     SQLITE_NULL,     /* 0x1f (not possible) */
     SQLITE_FLOAT,    /* 0x20 INTREAL */
     SQLITE_NULL,     /* 0x21 (not possible) */
     SQLITE_TEXT,     /* 0x22 INTREAL + TEXT */
     SQLITE_NULL,     /* 0x23 (not possible) */
     SQLITE_FLOAT,    /* 0x24 (not possible) */
     SQLITE_NULL,     /* 0x25 (not possible) */
     SQLITE_FLOAT,    /* 0x26 (not possible) */
     SQLITE_NULL,     /* 0x27 (not possible) */
     SQLITE_FLOAT,    /* 0x28 (not possible) */
     SQLITE_NULL,     /* 0x29 (not possible) */
     SQLITE_FLOAT,    /* 0x2a (not possible) */
     SQLITE_NULL,     /* 0x2b (not possible) */
     SQLITE_FLOAT,    /* 0x2c (not possible) */
     SQLITE_NULL,     /* 0x2d (not possible) */
     SQLITE_FLOAT,    /* 0x2e (not possible) */
     SQLITE_NULL,     /* 0x2f (not possible) */
     SQLITE_BLOB,     /* 0x30 (not possible) */
     SQLITE_NULL,     /* 0x31 (not possible) */
     SQLITE_TEXT,     /* 0x32 (not possible) */
     SQLITE_NULL,     /* 0x33 (not possible) */
     SQLITE_FLOAT,    /* 0x34 (not possible) */
     SQLITE_NULL,     /* 0x35 (not possible) */
     SQLITE_FLOAT,    /* 0x36 (not possible) */
     SQLITE_NULL,     /* 0x37 (not possible) */
     SQLITE_FLOAT,    /* 0x38 (not possible) */
     SQLITE_NULL,     /* 0x39 (not possible) */
     SQLITE_FLOAT,    /* 0x3a (not possible) */
     SQLITE_NULL,     /* 0x3b (not possible) */
     SQLITE_FLOAT,    /* 0x3c (not possible) */
     SQLITE_NULL,     /* 0x3d (not possible) */
     SQLITE_FLOAT,    /* 0x3e (not possible) */
     SQLITE_NULL,     /* 0x3f (not possible) */
  };
#ifdef SQLITE_DEBUG
  {
    int eType = SQLITE_BLOB;
    if( pVal->flags & MEM_Null ){
      eType = SQLITE_NULL;
    }else if( pVal->flags & (MEM_Real|MEM_IntReal) ){
      eType = SQLITE_FLOAT;
    }else if( pVal->flags & MEM_Int ){
      eType = SQLITE_INTEGER;
    }else if( pVal->flags & MEM_Str ){
      eType = SQLITE_TEXT;
    }
    assert( eType == aType[pVal->flags&MEM_AffMask] );
  }
#endif
  return aType[pVal->flags&MEM_AffMask];
}

/* Return true if a parameter to xUpdate represents an unchanged column */
int sqlite3_value_nochange(sqlite3_value *pVal){
  
// ROR Label 73
if(((pVal->flags & (1 | 16384)) != (1 | 16384)) != ((pVal->flags & (1 | 16384)) == (1 | 16384)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
return (pVal->flags&(MEM_Null|MEM_Zero))==(MEM_Null|MEM_Zero);
}

/* Return true if a parameter value originated from an sqlite3_bind() */
int sqlite3_value_frombind(sqlite3_value *pVal){
  
// ROR Label 74
if(((pVal->flags & 64) == 0) != ((pVal->flags & 64) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
return (pVal->flags&MEM_FromBind)!=0;
}

/* Make a copy of an sqlite3_value object
*/
sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){
  sqlite3_value *pNew;
  
// ABS Label 75
if(pOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ROR Label 76
if((pOrig != 0) != (pOrig == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
if( pOrig==0 ) { return 0;
}
  pNew = sqlite3_malloc( sizeof(*pNew) );
  
// ABS Label 77
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
if( pNew==0 ) { return 0;
}
  memset(pNew, 0, sizeof(*pNew));
  memcpy(pNew, pOrig, MEMCELLSIZE);
  pNew->flags &= ~MEM_Dyn;
  pNew->db = 0;
  
// AOR Label 79
if(pNew->flags | (2 | 16) != pNew->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 79);
}
// AOR Label 80
if(pNew->flags ^ (2 | 16) != pNew->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 80);
}
if( pNew->flags&(MEM_Str|MEM_Blob) ){
    pNew->flags &= ~(MEM_Static|MEM_Dyn);
    pNew->flags |= MEM_Ephem;
    if( sqlite3VdbeMemMakeWriteable(pNew)!=SQLITE_OK ){
      
// ABS Label 81
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
sqlite3ValueFree(pNew);
      pNew = 0;
    }
  }
  
// ABS Label 82
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
return pNew;
}

/* Destroy an sqlite3_value object previously obtained from
** sqlite3_value_dup().
*/
void sqlite3_value_free(sqlite3_value *pOld){
  
// ABS Label 83
if(pOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
sqlite3ValueFree(pOld);
}
  

/**************************** sqlite3_result_  *******************************
** The following routines are used by user-defined functions to specify
** the function result.
**
** The setStrOrError() function calls sqlite3VdbeMemSetStr() to store the
** result as a string or blob but if the string or blob is too large, it
** then sets the error code to SQLITE_TOOBIG
**
** The invokeValueDestructor(P,X) routine invokes destructor function X()
** on value P is not going to be used and need to be destroyed.
*/
static void setResultStrOrError(
  sqlite3_context *pCtx,  /* Function context */
  const char *z,          /* String pointer */
  int n,                  /* Bytes in string, or negative */
  u8 enc,                 /* Encoding of z.  0 for BLOBs */
  void (*xDel)(void*)     /* Destructor function */
){
  if( sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel)==SQLITE_TOOBIG ){
    
// ABS Label 84
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
sqlite3_result_error_toobig(pCtx);
  }
}
static int invokeValueDestructor(
  const void *p,             /* Value to destroy */
  void (*xDel)(void*),       /* The destructor */
  sqlite3_context *pCtx      /* Set a SQLITE_TOOBIG error if no NULL */
){
  assert( xDel!=SQLITE_DYNAMIC );
  
// ABS Label 86
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// ROR Label 87
if((xDel != 0) != (xDel == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}
if( xDel==0 ){
    /* noop */
  }else { 
// ABS Label 88
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// ROR Label 89
if((xDel != ((sqlite3_destructor_type)-1)) != (xDel == ((sqlite3_destructor_type)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 89);
}
if( xDel==SQLITE_TRANSIENT ){
    /* noop */
  }else{
    xDel((void*)p);
  };}

  
// ABS Label 85
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
sqlite3_result_error_toobig(pCtx);
  return SQLITE_TOOBIG;
}
void sqlite3_result_blob(
  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
){
  assert( n>=0 );
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 90
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ABS Label 91
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}

// ABS Label 92
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}
setResultStrOrError(pCtx, z, n, 0, xDel);
}
void sqlite3_result_blob64(
  sqlite3_context *pCtx, 
  const void *z, 
  sqlite3_uint64 n,
  void (*xDel)(void *)
){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  assert( xDel!=SQLITE_DYNAMIC );
  
// ABS Label 93
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}

// ROR Label 94
if((n <= 2147483647) != (n > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 94);
}
// ROR Label 95
if((n < 2147483647) != (n > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
// ROR Label 96
if((n >= 2147483647) != (n > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 96);
}
if( n>0x7fffffff ){
    (void)invokeValueDestructor(z, xDel, pCtx);
  }else{
    
// ABS Label 97
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// ABS Label 98
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
setResultStrOrError(pCtx, z, (int)n, 0, xDel);
  }
}
void sqlite3_result_double(sqlite3_context *pCtx, double rVal){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 99
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}

// ABS Label 100
if(rVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);
}
void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  pCtx->isError = SQLITE_ERROR;
  
// ABS Label 101
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}

// ABS Label 102
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);
}
#ifndef SQLITE_OMIT_UTF16
void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  pCtx->isError = SQLITE_ERROR;
  
// ABS Label 103
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);
}
#endif
void sqlite3_result_int(sqlite3_context *pCtx, int iVal){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 104
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);
}
void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 105
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// ABS Label 106
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}
sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);
}
void sqlite3_result_null(sqlite3_context *pCtx){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 107
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
sqlite3VdbeMemSetNull(pCtx->pOut);
}
void sqlite3_result_pointer(
  sqlite3_context *pCtx,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
){
  
// ABS Label 108
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
Mem *pOut = pCtx->pOut;
  assert( sqlite3_mutex_held(pOut->db->mutex) );
  
// ABS Label 109
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
sqlite3VdbeMemRelease(pOut);
  pOut->flags = MEM_Null;
  
// ABS Label 110
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// ABS Label 111
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}

// ABS Label 112
if(zPType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ABS Label 113
if(xDestructor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
}
void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){
  
// ABS Label 114
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
Mem *pOut = pCtx->pOut;
  assert( sqlite3_mutex_held(pOut->db->mutex) );
  pOut->eSubtype = eSubtype & 0xff;
  pOut->flags |= MEM_Subtype;
}
void sqlite3_result_text(
  sqlite3_context *pCtx, 
  const char *z, 
  int n,
  void (*xDel)(void *)
){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 115
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// ABS Label 116
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ABS Label 117
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// ABS Label 118
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}
setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel);
}
void sqlite3_result_text64(
  sqlite3_context *pCtx, 
  const char *z, 
  sqlite3_uint64 n,
  void (*xDel)(void *),
  unsigned char enc
){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  assert( xDel!=SQLITE_DYNAMIC );
  
// ROR Label 119
if((enc != 4) != (enc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
if( enc==SQLITE_UTF16 ) { enc = SQLITE_UTF16NATIVE;
}
  
// ABS Label 120
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// ROR Label 121
if((n <= 2147483647) != (n > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
// ROR Label 122
if((n < 2147483647) != (n > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
// ROR Label 123
if((n >= 2147483647) != (n > 2147483647))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
if( n>0x7fffffff ){
    (void)invokeValueDestructor(z, xDel, pCtx);
  }else{
    
// ABS Label 124
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}

// ABS Label 125
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}

// ABS Label 126
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// ABS Label 127
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}
setResultStrOrError(pCtx, z, (int)n, enc, xDel);
  }
}
#ifndef SQLITE_OMIT_UTF16
void sqlite3_result_text16(
  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 128
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}

// ABS Label 129
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}

// ABS Label 130
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}
setResultStrOrError(pCtx, z, n, SQLITE_UTF16NATIVE, xDel);
}
void sqlite3_result_text16be(
  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 131
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}

// ABS Label 132
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}

// ABS Label 133
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
setResultStrOrError(pCtx, z, n, SQLITE_UTF16BE, xDel);
}
void sqlite3_result_text16le(
  sqlite3_context *pCtx, 
  const void *z, 
  int n, 
  void (*xDel)(void *)
){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 134
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}

// ABS Label 135
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}

// ABS Label 136
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
setResultStrOrError(pCtx, z, n, SQLITE_UTF16LE, xDel);
}
#endif /* SQLITE_OMIT_UTF16 */
void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 137
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
sqlite3VdbeMemCopy(pCtx->pOut, pValue);
}
void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 138
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// ABS Label 139
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n);
}
int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){
  
// ABS Label 140
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
Mem *pOut = pCtx->pOut;
  assert( sqlite3_mutex_held(pOut->db->mutex) );
  
// ABS Label 142
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}

// ROR Label 143
if((n <= (u64)pOut->db->aLimit[0]) != (n > (u64)pOut->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}
// ROR Label 144
if((n < (u64)pOut->db->aLimit[0]) != (n > (u64)pOut->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
// ROR Label 145
if((n >= (u64)pOut->db->aLimit[0]) != (n > (u64)pOut->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
if( n>(u64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH] ){
    return SQLITE_TOOBIG;
  }
  
// ABS Label 141
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);
  return SQLITE_OK;
}
void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
  pCtx->isError = errCode ? errCode : -1;
#ifdef SQLITE_DEBUG
  if( pCtx->pVdbe ) pCtx->pVdbe->rcApp = errCode;
#endif
  
// AOR Label 146
if(pCtx->pOut->flags | 1 != pCtx->pOut->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 146);
}
// AOR Label 147
if(pCtx->pOut->flags ^ 1 != pCtx->pOut->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 147);
}
if( pCtx->pOut->flags & MEM_Null ){
    
// ABS Label 148
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
sqlite3VdbeMemSetStr(pCtx->pOut, sqlite3ErrStr(errCode), -1, 
                         SQLITE_UTF8, SQLITE_STATIC);
  }
}

/* Force an SQLITE_TOOBIG error. */
void sqlite3_result_error_toobig(sqlite3_context *pCtx){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  pCtx->isError = SQLITE_TOOBIG;
  
// ABS Label 149
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1, 
                       SQLITE_UTF8, SQLITE_STATIC);
}

/* An SQLITE_NOMEM error. */
void sqlite3_result_error_nomem(sqlite3_context *pCtx){
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// ABS Label 150
if(pCtx->pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
sqlite3VdbeMemSetNull(pCtx->pOut);
  pCtx->isError = SQLITE_NOMEM_BKPT;
  
// ABS Label 151
if(pCtx->pOut->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}
sqlite3OomFault(pCtx->pOut->db);
}

#ifndef SQLITE_UNTESTABLE
/* Force the INT64 value currently stored as the result to be
** a MEM_IntReal value.  See the SQLITE_TESTCTRL_RESULT_INTREAL
** test-control.
*/
void sqlite3ResultIntReal(sqlite3_context *pCtx){ 
  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
  
// AOR Label 152
if(pCtx->pOut->flags | 4 != pCtx->pOut->flags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 152);
}
// AOR Label 153
if(pCtx->pOut->flags ^ 4 != pCtx->pOut->flags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 153);
}
if( pCtx->pOut->flags & MEM_Int ){
    pCtx->pOut->flags &= ~MEM_Int;
    pCtx->pOut->flags |= MEM_IntReal;
  }
}
#endif


/*
** This function is called after a transaction has been committed. It 
** invokes callbacks registered with sqlite3_wal_hook() as required.
*/
static int doWalCallbacks(sqlite3 *db){
  int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_WAL
  int i;
  i = 0;

// ABS Label 154
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}
// ABS Label 155
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}

// ROR Label 156
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
// ROR Label 157
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 157);
}
// ROR Label 158
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 158);
}
for(; i<db->nDb; i++){
    
// ABS Label 164
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}
Btree *pBt = db->aDb[i].pBt;
    
// ABS Label 165
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}
if( pBt ){
      int nEntry;
      
// ABS Label 166
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}
sqlite3BtreeEnter(pBt);
      nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
      
// ABS Label 167
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}
sqlite3BtreeLeave(pBt);
      
// ABS Label 168
if(db->xWalCallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}
// ABS Label 169
if(nEntry < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
// ABS Label 170
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// COR Label 171
if((nEntry > 0 && db->xWalCallback || rc == 0) != (nEntry > 0 && db->xWalCallback && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 171);
}
// COR Label 172
if((nEntry > 0 || db->xWalCallback) != (nEntry > 0 && db->xWalCallback))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 172);
}

// ROR Label 173
if((nEntry <= 0) != (nEntry > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
// ROR Label 174
if((nEntry < 0) != (nEntry > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((nEntry >= 0) != (nEntry > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
// ROR Label 176
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}

// MCC Label 177
if(nEntry > 0 && db->xWalCallback && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(nEntry > 0 && db->xWalCallback && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(nEntry > 0 && !(db->xWalCallback) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(nEntry > 0 && !(db->xWalCallback) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(!(nEntry > 0) && db->xWalCallback && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(!(nEntry > 0) && db->xWalCallback && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(!(nEntry > 0) && !(db->xWalCallback) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(!(nEntry > 0) && !(db->xWalCallback) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}
if( nEntry>0 && db->xWalCallback && rc==SQLITE_OK ){
        rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);
      }
    }
  };
// ABS Label 159
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
// ABS Label 160
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}

// ROR Label 161
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}

#endif
  
// ABS Label 185
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
return rc;
}


/*
** Execute the statement pStmt, either until a row of data is ready, the
** statement is completely executed or an error occurs.
**
** This routine implements the bulk of the logic behind the sqlite_step()
** API.  The only thing omitted is the automatic recompile if a 
** schema change has occurred.  That detail is handled by the
** outer sqlite3_step() wrapper procedure.
*/
static int sqlite3Step(Vdbe *p){
  sqlite3 *db;
  int rc;

  assert(p);
  
// ABS Label 186
if(p->iVdbeMagic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ROR Label 187
if((p->iVdbeMagic == 770837923) != (p->iVdbeMagic != 770837923))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){
    /* We used to require that sqlite3_reset() be called before retrying
    ** sqlite3_step() after any error or after SQLITE_DONE.  But beginning
    ** with version 3.7.0, we changed this so that sqlite3_reset() would
    ** be called automatically instead of throwing the SQLITE_MISUSE error.
    ** This "automatic-reset" change is not technically an incompatibility, 
    ** since any application that receives an SQLITE_MISUSE is broken by
    ** definition.
    **
    ** Nevertheless, some published applications that were originally written
    ** for version 3.6.23 or earlier do in fact depend on SQLITE_MISUSE 
    ** returns, and those were broken by the automatic-reset change.  As a
    ** a work-around, the SQLITE_OMIT_AUTORESET compile-time restores the
    ** legacy behavior of returning SQLITE_MISUSE for cases where the 
    ** previous sqlite3_step() returned something other than a SQLITE_LOCKED
    ** or SQLITE_BUSY error.
    */
#ifdef SQLITE_OMIT_AUTORESET
    if( (rc = p->rc&0xff)==SQLITE_BUSY || rc==SQLITE_LOCKED ){
      sqlite3_reset((sqlite3_stmt*)p);
    }else{
      return SQLITE_MISUSE_BKPT;
    }
#else
    sqlite3_reset((sqlite3_stmt*)p);
#endif
  }

  /* Check that malloc() has not failed. If it has, return early. */
  db = p->db;
  
// ABS Label 188
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}
if( db->mallocFailed ){
    p->rc = SQLITE_NOMEM;
    return SQLITE_NOMEM_BKPT;
  }

  
// ABS Label 189
if(p->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}

// COR Label 190
if((p->pc < 0 || p->expired) != (p->pc < 0 && p->expired))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 190);
}

// ROR Label 191
if((p->pc <= 0) != (p->pc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
// ROR Label 192
if((p->pc > 0) != (p->pc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((p->pc >= 0) != (p->pc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}

// MCC Label 194
if(p->pc < 0 && p->expired ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(p->pc < 0 && !(p->expired) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(!(p->pc < 0) && p->expired ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(!(p->pc < 0) && !(p->expired) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
if( p->pc<0 && p->expired ){
    p->rc = SQLITE_SCHEMA;
    rc = SQLITE_ERROR;
    
// ROR Label 198
if(((p->prepFlags & 128) == 0) != ((p->prepFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 198);
}
if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){
      /* If this statement was prepared using saved SQL and an 
      ** error has occurred, then return the error code in p->rc to the
      ** caller. Set the error code in the database handle to the same value.
      */ 
      rc = sqlite3VdbeTransferError(p);
    }
    goto end_of_step;
  }
  
// ABS Label 199
if(p->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}

// ROR Label 200
if((p->pc <= 0) != (p->pc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
// ROR Label 201
if((p->pc > 0) != (p->pc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
// ROR Label 202
if((p->pc >= 0) != (p->pc < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
if( p->pc<0 ){
    /* If there are no other statements currently running, then
    ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt
    ** from interrupting a statement that has not yet started.
    */
    
// ABS Label 203
if(db->nVdbeActive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}

// ROR Label 204
if((db->nVdbeActive != 0) != (db->nVdbeActive == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
if( db->nVdbeActive==0 ){
      AtomicStore(&db->u1.isInterrupted, 0);
    }

    assert( db->nVdbeWrite>0 || db->autoCommit==0 
        || (db->nDeferredCons==0 && db->nDeferredImmCons==0)
    );

#ifndef SQLITE_OMIT_TRACE
    
// ABS Label 205
if(p->zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}

// COR Label 206
if(((db->mTrace & (2 | 128)) != 0 && !db->init.busy || p->zSql) != ((db->mTrace & (2 | 128)) != 0 && !db->init.busy && p->zSql))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 206);
}
// COR Label 207
if(((db->mTrace & (2 | 128)) != 0 || !db->init.busy) != ((db->mTrace & (2 | 128)) != 0 && !db->init.busy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 207);
}

// ROR Label 208
if(((db->mTrace & (2 | 128)) == 0) != ((db->mTrace & (2 | 128)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}

// MCC Label 209
if((db->mTrace & (2 | 128)) != 0 && !db->init.busy && p->zSql ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if((db->mTrace & (2 | 128)) != 0 && !db->init.busy && !(p->zSql) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if((db->mTrace & (2 | 128)) != 0 && !(!db->init.busy) && p->zSql ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if((db->mTrace & (2 | 128)) != 0 && !(!db->init.busy) && !(p->zSql) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(!((db->mTrace & (2 | 128)) != 0) && !db->init.busy && p->zSql ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(!((db->mTrace & (2 | 128)) != 0) && !db->init.busy && !(p->zSql) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(!((db->mTrace & (2 | 128)) != 0) && !(!db->init.busy) && p->zSql ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(!((db->mTrace & (2 | 128)) != 0) && !(!db->init.busy) && !(p->zSql) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}
if( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0
        && !db->init.busy && p->zSql ){
      
// ABS Label 217
if(db->pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}
sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);
    }else{
      assert( p->startTime==0 );
    }
#endif

    db->nVdbeActive++;
    
// ROR Label 218
if((p->readOnly != 0) != (p->readOnly == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
if( p->readOnly==0 ) { db->nVdbeWrite++;
}
    
// ABS Label 219
if(p->bIsReader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
if( p->bIsReader ) { db->nVdbeRead++;
}
    p->pc = 0;
  }
#ifdef SQLITE_DEBUG
  p->rcApp = SQLITE_OK;
#endif
#ifndef SQLITE_OMIT_EXPLAIN
  
// ABS Label 220
if(p->explain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
if( p->explain ){
    rc = sqlite3VdbeList(p);
  }else
#endif /* SQLITE_OMIT_EXPLAIN */
  {
    db->nVdbeExec++;
    rc = sqlite3VdbeExec(p);
    db->nVdbeExec--;
  }

  
// ABS Label 221
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}

// ROR Label 222
if((rc == 100) != (rc != 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
if( rc!=SQLITE_ROW ){
#ifndef SQLITE_OMIT_TRACE
    /* If the statement completed successfully, invoke the profile callback */
    checkProfileCallback(db, p);
#endif

    
// ABS Label 229
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}

// COR Label 230
if((rc == 101 || db->autoCommit) != (rc == 101 && db->autoCommit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 230);
}

// ROR Label 231
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 231);
}

// MCC Label 232
if(rc == 101 && db->autoCommit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(rc == 101 && !(db->autoCommit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
// MCC Label 234
if(!(rc == 101) && db->autoCommit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
// MCC Label 235
if(!(rc == 101) && !(db->autoCommit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
if( rc==SQLITE_DONE && db->autoCommit ){
      assert( p->rc==SQLITE_OK );
      p->rc = doWalCallbacks(db);
      
// ABS Label 236
if(p->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}

// ROR Label 237
if((p->rc == 0) != (p->rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
if( p->rc!=SQLITE_OK ){
        rc = SQLITE_ERROR;
      }
    }else { 
// ABS Label 238
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// COR Label 239
if((rc != 101 || (p->prepFlags & 128) != 0) != (rc != 101 && (p->prepFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 239);
}

// ROR Label 240
if((rc == 101) != (rc != 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 240);
}
// ROR Label 241
if(((p->prepFlags & 128) == 0) != ((p->prepFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}

// MCC Label 242
if(rc != 101 && (p->prepFlags & 128) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 242);
}
// MCC Label 243
if(rc != 101 && !((p->prepFlags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 243);
}
// MCC Label 244
if(!(rc != 101) && (p->prepFlags & 128) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 244);
}
// MCC Label 245
if(!(rc != 101) && !((p->prepFlags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
if( rc!=SQLITE_DONE && (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){
      /* If this statement was prepared using saved SQL and an 
      ** error has occurred, then return the error code in p->rc to the
      ** caller. Set the error code in the database handle to the same value.
      */ 
      rc = sqlite3VdbeTransferError(p);
    };}

  }

  db->errCode = rc;
  if( SQLITE_NOMEM==sqlite3ApiExit(p->db, p->rc) ){
    p->rc = SQLITE_NOMEM_BKPT;
    
// ROR Label 246
if(((p->prepFlags & 128) == 0) != ((p->prepFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ) { rc = p->rc;
}
  }
end_of_step:
  /* There are only a limited number of result codes allowed from the
  ** statements prepared using the legacy sqlite3_prepare() interface */
  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0
       || rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR 
       || (rc&0xff)==SQLITE_BUSY || rc==SQLITE_MISUSE
  );
  
// MCC Label 247
if(( rc & db->errMask ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(( !(rc & db->errMask) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
return (rc&db->errMask);
}

/*
** This is the top-level implementation of sqlite3_step().  Call
** sqlite3Step() to do most of the work.  If a schema error occurs,
** call sqlite3Reprepare() and try again.
*/
int sqlite3_step(sqlite3_stmt *pStmt){
  int rc = SQLITE_OK;      /* Result from sqlite3Step() */
  Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */
  int cnt = 0;             /* Counter to prevent infinite loop of reprepares */
  sqlite3 *db;             /* The database connection */

  if( vdbeSafetyNotNull(v) ){
    return SQLITE_MISUSE_BKPT;
  }
  db = v->db;
  
// ABS Label 249
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
sqlite3_mutex_enter(db->mutex);
  v->doingRerun = 0;
  while( (rc = sqlite3Step(v))==SQLITE_SCHEMA
         && cnt++ < SQLITE_MAX_SCHEMA_RETRY ){
    
// ABS Label 251
if(v->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}
int savedPc = v->pc;
    rc = sqlite3Reprepare(v);
    
// ABS Label 253
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}

// ROR Label 254
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
if( rc!=SQLITE_OK ){
      /* This case occurs after failing to recompile an sql statement. 
      ** The error message from the SQL compiler has already been loaded 
      ** into the database handle. This block copies the error message 
      ** from the database handle into the statement and sets the statement
      ** program counter to 0 to ensure that when the statement is 
      ** finalized or reset the parser error message is available via
      ** sqlite3_errmsg() and sqlite3_errcode().
      */
      const char *zErr = (const char *)sqlite3_value_text(db->pErr); 
      
// ABS Label 255
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}
sqlite3DbFree(db, v->zErrMsg);
      if( !db->mallocFailed ){
        v->zErrMsg = sqlite3DbStrDup(db, zErr);
        v->rc = rc = sqlite3ApiExit(db, rc);
      } else {
        v->zErrMsg = 0;
        v->rc = rc = SQLITE_NOMEM_BKPT;
      }
      break;
    }
    
// ABS Label 252
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}
sqlite3_reset(pStmt);
    
// ABS Label 256
if(savedPc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ROR Label 257
if((savedPc < 0) != (savedPc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
// ROR Label 258
if((savedPc > 0) != (savedPc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}
// ROR Label 259
if((savedPc <= 0) != (savedPc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}
if( savedPc>=0 ) { v->doingRerun = 1;
}
    assert( v->expired==0 );
  };
  
// ABS Label 250
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 260
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
return rc;
}


/*
** Extract the user data from a sqlite3_context structure and return a
** pointer to it.
*/
void *sqlite3_user_data(sqlite3_context *p){
  assert( p && p->pFunc );
  
// ABS Label 261
if(p->pFunc->pUserData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}
return p->pFunc->pUserData;
}

/*
** Extract the user data from a sqlite3_context structure and return a
** pointer to it.
**
** IMPLEMENTATION-OF: R-46798-50301 The sqlite3_context_db_handle() interface
** returns a copy of the pointer to the database connection (the 1st
** parameter) of the sqlite3_create_function() and
** sqlite3_create_function16() routines that originally registered the
** application defined function.
*/
sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){
  assert( p && p->pOut );
  
// ABS Label 262
if(p->pOut->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}
return p->pOut->db;
}

/*
** If this routine is invoked from within an xColumn method of a virtual
** table, then it returns true if and only if the the call is during an
** UPDATE operation and the value of the column will not be modified
** by the UPDATE.
**
** If this routine is called from any context other than within the
** xColumn method of a virtual table, then the return value is meaningless
** and arbitrary.
**
** Virtual table implements might use this routine to optimize their
** performance by substituting a NULL result, or some other light-weight
** value, as a signal to the xUpdate routine that the column is unchanged.
*/
int sqlite3_vtab_nochange(sqlite3_context *p){
  assert( p );
  return sqlite3_value_nochange(p->pOut);
}

/*
** Return the current time for a statement.  If the current time
** is requested more than once within the same run of a single prepared
** statement, the exact same time is returned for each invocation regardless
** of the amount of time that elapses between invocations.  In other words,
** the time returned is always the time of the first call.
*/
sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){
  int rc;
#ifndef SQLITE_ENABLE_STAT4
  sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
  assert( p->pVdbe!=0 );
#else
  sqlite3_int64 iTime = 0;
  sqlite3_int64 *piTime = p->pVdbe!=0 ? &p->pVdbe->iCurrentTime : &iTime;
#endif
  
// ABS Label 263
if(*piTime < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}

// ROR Label 264
if((*piTime != 0) != (*piTime == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}
if( *piTime==0 ){
    rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);
    
// ABS Label 265
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}
if( rc ) { *piTime = 0;
}
  }
  
// ABS Label 266
if(*piTime < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}
return *piTime;
}

/*
** Create a new aggregate context for p and return a pointer to
** its pMem->z element.
*/
static SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte){
  
// ABS Label 267
if(p->pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 267);
}
Mem *pMem = p->pMem;
  assert( (pMem->flags & MEM_Agg)==0 );
  
// ABS Label 268
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}

// ROR Label 269
if((nByte < 0) != (nByte <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}
// ROR Label 270
if((nByte > 0) != (nByte <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 270);
}
// ROR Label 271
if((nByte >= 0) != (nByte <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 271);
}
if( nByte<=0 ){
    
// ABS Label 272
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
sqlite3VdbeMemSetNull(pMem);
    pMem->z = 0;
  }else{
    
// ABS Label 273
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

// ABS Label 274
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
sqlite3VdbeMemClearAndResize(pMem, nByte);
    pMem->flags = MEM_Agg;
    pMem->u.pDef = p->pFunc;
    
// ABS Label 275
if(pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
if( pMem->z ){
      memset(pMem->z, 0, nByte);
    }
  }
  return (void*)pMem->z;
}

/*
** Allocate or return the aggregate context for a user function.  A new
** context is allocated on the first call.  Subsequent calls return the
** same context that was returned on prior calls.
*/
void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
  assert( p && p->pFunc && p->pFunc->xFinalize );
  assert( sqlite3_mutex_held(p->pOut->db->mutex) );
  testcase( nByte<0 );
  
// ROR Label 276
if(((p->pMem->flags & 8192) != 0) != ((p->pMem->flags & 8192) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 276);
}
if( (p->pMem->flags & MEM_Agg)==0 ){
    return createAggContext(p, nByte);
  }else{
    return (void*)p->pMem->z;
  }
}

/*
** Return the auxiliary data pointer, if any, for the iArg'th argument to
** the user-function defined by pCtx.
**
** The left-most argument is 0.
**
** Undocumented behavior:  If iArg is negative then access a cache of
** auxiliary data pointers that is available to all functions within a
** single prepared statement.  The iArg values must match.
*/
void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
  AuxData *pAuxData;

  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
#if SQLITE_ENABLE_STAT4
  if( pCtx->pVdbe==0 ) return 0;
#else
  assert( pCtx->pVdbe!=0 );
#endif
  pAuxData = pCtx->pVdbe->pAuxData;

// ABS Label 277
if(pAuxData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
for(; pAuxData; pAuxData=pAuxData->pNextAux){
    
// ABS Label 279
if(iArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}
// ABS Label 280
if(pAuxData->iAuxArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}

// COR Label 281
if((pAuxData->iAuxArg == iArg || (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)) != (pAuxData->iAuxArg == iArg && (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 281);
}

// ROR Label 282
if((pAuxData->iAuxArg != iArg) != (pAuxData->iAuxArg == iArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}

// MCC Label 283
if(pAuxData->iAuxArg == iArg && ( pAuxData->iAuxOp == pCtx->iOp && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}
// MCC Label 284
if(pAuxData->iAuxArg == iArg && ( pAuxData->iAuxOp == pCtx->iOp && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 284);
}
// MCC Label 285
if(pAuxData->iAuxArg == iArg && ( !(pAuxData->iAuxOp == pCtx->iOp) && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 285);
}
// MCC Label 286
if(pAuxData->iAuxArg == iArg && ( !(pAuxData->iAuxOp == pCtx->iOp) && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 286);
}
// MCC Label 287
if(!(pAuxData->iAuxArg == iArg) && ( pAuxData->iAuxOp == pCtx->iOp && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 287);
}
// MCC Label 288
if(!(pAuxData->iAuxArg == iArg) && ( pAuxData->iAuxOp == pCtx->iOp && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 288);
}
// MCC Label 289
if(!(pAuxData->iAuxArg == iArg) && ( !(pAuxData->iAuxOp == pCtx->iOp) && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 289);
}
// MCC Label 290
if(!(pAuxData->iAuxArg == iArg) && ( !(pAuxData->iAuxOp == pCtx->iOp) && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 290);
}
if(  pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
      
// ABS Label 291
if(pAuxData->pAux < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}
return pAuxData->pAux;
    }
  };
// ABS Label 278
if(pAuxData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}

  return 0;
}

/*
** Set the auxiliary data pointer and delete function, for the iArg'th
** argument to the user-function defined by pCtx. Any previous value is
** deleted by calling the delete function specified when it was set.
**
** The left-most argument is 0.
**
** Undocumented behavior:  If iArg is negative then make the data available
** to all functions within the current prepared statement using iArg as an
** access code.
*/
void sqlite3_set_auxdata(
  sqlite3_context *pCtx, 
  int iArg, 
  void *pAux, 
  void (*xDelete)(void*)
){
  AuxData *pAuxData;
  
// ABS Label 292
if(pCtx->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
Vdbe *pVdbe = pCtx->pVdbe;

  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
#ifdef SQLITE_ENABLE_STAT4
  if( pVdbe==0 ) goto failed;
#else
  assert( pVdbe!=0 );
#endif

  pAuxData = pVdbe->pAuxData;

// ABS Label 293
if(pAuxData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
for(; pAuxData; pAuxData=pAuxData->pNextAux){
    
// ABS Label 295
if(iArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
// ABS Label 296
if(pAuxData->iAuxArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// COR Label 297
if((pAuxData->iAuxArg == iArg || (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)) != (pAuxData->iAuxArg == iArg && (pAuxData->iAuxOp == pCtx->iOp || iArg < 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 297);
}

// ROR Label 298
if((pAuxData->iAuxArg != iArg) != (pAuxData->iAuxArg == iArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}

// MCC Label 299
if(pAuxData->iAuxArg == iArg && ( pAuxData->iAuxOp == pCtx->iOp && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 299);
}
// MCC Label 300
if(pAuxData->iAuxArg == iArg && ( pAuxData->iAuxOp == pCtx->iOp && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 300);
}
// MCC Label 301
if(pAuxData->iAuxArg == iArg && ( !(pAuxData->iAuxOp == pCtx->iOp) && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 301);
}
// MCC Label 302
if(pAuxData->iAuxArg == iArg && ( !(pAuxData->iAuxOp == pCtx->iOp) && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 302);
}
// MCC Label 303
if(!(pAuxData->iAuxArg == iArg) && ( pAuxData->iAuxOp == pCtx->iOp && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 303);
}
// MCC Label 304
if(!(pAuxData->iAuxArg == iArg) && ( pAuxData->iAuxOp == pCtx->iOp && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 304);
}
// MCC Label 305
if(!(pAuxData->iAuxArg == iArg) && ( !(pAuxData->iAuxOp == pCtx->iOp) && iArg < 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 305);
}
// MCC Label 306
if(!(pAuxData->iAuxArg == iArg) && ( !(pAuxData->iAuxOp == pCtx->iOp) && !(iArg < 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 306);
}
if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
      break;
    }
  };
// ABS Label 294
if(pAuxData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}

  
// ABS Label 307
if(pAuxData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}

// ROR Label 308
if((pAuxData != 0) != (pAuxData == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 308);
}
if( pAuxData==0 ){
    pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));
    if( !pAuxData ) { goto failed;
}
    pAuxData->iAuxOp = pCtx->iOp;
    pAuxData->iAuxArg = iArg;
    pAuxData->pNextAux = pVdbe->pAuxData;
    pVdbe->pAuxData = pAuxData;
    
// ABS Label 309
if(pCtx->isError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}

// ROR Label 310
if((pCtx->isError != 0) != (pCtx->isError == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
if( pCtx->isError==0 ) { pCtx->isError = -1;
}
  }else { 
// ABS Label 311
if(pAuxData->xDeleteAux < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
if( pAuxData->xDeleteAux ){
    
// ABS Label 312
if(pAuxData->pAux < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
pAuxData->xDeleteAux(pAuxData->pAux);
  };}


  pAuxData->pAux = pAux;
  pAuxData->xDeleteAux = xDelete;
  return;

failed:
  
// ABS Label 313
if(xDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
if( xDelete ){
    
// ABS Label 314
if(pAux < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
xDelete(pAux);
  }
}

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Return the number of times the Step function of an aggregate has been 
** called.
**
** This function is deprecated.  Do not use it for new code.  It is
** provide only to avoid breaking legacy code.  New aggregate function
** implementations should keep their own counts within their aggregate
** context.
*/
int sqlite3_aggregate_count(sqlite3_context *p){
  assert( p && p->pMem && p->pFunc && p->pFunc->xFinalize );
  
// ABS Label 315
if(p->pMem->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
return p->pMem->n;
}
#endif

/*
** Return the number of columns in the result set for the statement pStmt.
*/
int sqlite3_column_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  return pVm ? pVm->nResColumn : 0;
}

/*
** Return the number of values available from the current row of the
** currently executing statement pStmt.
*/
int sqlite3_data_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  
// ABS Label 316
if(pVm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
// ABS Label 317
if(pVm->pResultSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}

// COR Label 318
if((pVm == 0 && pVm->pResultSet == 0) != (pVm == 0 || pVm->pResultSet == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 318);
}

// ROR Label 319
if((pVm != 0) != (pVm == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 319);
}
// ROR Label 320
if((pVm->pResultSet != 0) != (pVm->pResultSet == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 320);
}

// MCC Label 321
if(pVm == 0 && pVm->pResultSet == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 321);
}
// MCC Label 322
if(pVm == 0 && !(pVm->pResultSet == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
// MCC Label 323
if(!(pVm == 0) && pVm->pResultSet == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
// MCC Label 324
if(!(pVm == 0) && !(pVm->pResultSet == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 324);
}
if( pVm==0 || pVm->pResultSet==0 ) { return 0;
}
  return pVm->nResColumn;
}

/*
** Return a pointer to static memory containing an SQL NULL value.
*/
static const Mem *columnNullValue(void){
  /* Even though the Mem structure contains an element
  ** of type i64, on certain architectures (x86) with certain compiler
  ** switches (-Os), gcc may align this Mem object on a 4-byte boundary
  ** instead of an 8-byte one. This all works fine, except that when
  ** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s
  ** that a Mem structure is located on an 8-byte boundary. To prevent
  ** these assert()s from failing, when building with SQLITE_DEBUG defined
  ** using gcc, we force nullMem to be 8-byte aligned using the magical
  ** __attribute__((aligned(8))) macro.  */
  static const Mem nullMem 
#if defined(SQLITE_DEBUG) && defined(__GNUC__)
    __attribute__((aligned(8))) 
#endif
    = {
        /* .u          = */ {0},
        /* .flags      = */ (u16)MEM_Null,
        /* .enc        = */ (u8)0,
        /* .eSubtype   = */ (u8)0,
        /* .n          = */ (int)0,
        /* .z          = */ (char*)0,
        /* .zMalloc    = */ (char*)0,
        /* .szMalloc   = */ (int)0,
        /* .uTemp      = */ (u32)0,
        /* .db         = */ (sqlite3*)0,
        /* .xDel       = */ (void(*)(void*))0,
#ifdef SQLITE_DEBUG
        /* .pScopyFrom = */ (Mem*)0,
        /* .mScopyFlags= */ 0,
#endif
      };
  return &nullMem;
}

/*
** Check to see if column iCol of the given statement is valid.  If
** it is, return a pointer to the Mem for the value of that column.
** If iCol is not valid, return a pointer to a Mem which has a value
** of NULL.
*/
static Mem *columnMem(sqlite3_stmt *pStmt, int i){
  Vdbe *pVm;
  Mem *pOut;

  pVm = (Vdbe *)pStmt;
  
// ABS Label 326
if(pVm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ROR Label 327
if((pVm != 0) != (pVm == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
if( pVm==0 ) { return (Mem*)columnNullValue();
}
  assert( pVm->db );
  
// ABS Label 325
if(pVm->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
sqlite3_mutex_enter(pVm->db->mutex);
  
// ABS Label 328
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
// ABS Label 329
if(pVm->pResultSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}

// COR Label 330
if((pVm->pResultSet != 0 && i < pVm->nResColumn || i >= 0) != (pVm->pResultSet != 0 && i < pVm->nResColumn && i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 330);
}
// COR Label 331
if((pVm->pResultSet != 0 || i < pVm->nResColumn) != (pVm->pResultSet != 0 && i < pVm->nResColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 331);
}

// ROR Label 332
if((pVm->pResultSet == 0) != (pVm->pResultSet != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 332);
}
// ROR Label 333
if((i <= pVm->nResColumn) != (i < pVm->nResColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 333);
}
// ROR Label 334
if((i > pVm->nResColumn) != (i < pVm->nResColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
// ROR Label 335
if((i >= pVm->nResColumn) != (i < pVm->nResColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 335);
}
// ROR Label 336
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}
// ROR Label 337
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
// ROR Label 338
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}

// MCC Label 339
if(pVm->pResultSet != 0 && i < pVm->nResColumn && i >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 339);
}
// MCC Label 340
if(pVm->pResultSet != 0 && i < pVm->nResColumn && !(i >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 340);
}
// MCC Label 341
if(pVm->pResultSet != 0 && !(i < pVm->nResColumn) && i >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 341);
}
// MCC Label 342
if(pVm->pResultSet != 0 && !(i < pVm->nResColumn) && !(i >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 342);
}
// MCC Label 343
if(!(pVm->pResultSet != 0) && i < pVm->nResColumn && i >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 343);
}
// MCC Label 344
if(!(pVm->pResultSet != 0) && i < pVm->nResColumn && !(i >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 344);
}
// MCC Label 345
if(!(pVm->pResultSet != 0) && !(i < pVm->nResColumn) && i >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 345);
}
// MCC Label 346
if(!(pVm->pResultSet != 0) && !(i < pVm->nResColumn) && !(i >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 346);
}
if( pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){
    pOut = &pVm->pResultSet[i];
  }else{
    
// ABS Label 347
if(pVm->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}
sqlite3Error(pVm->db, SQLITE_RANGE);
    pOut = (Mem*)columnNullValue();
  }
  
// ABS Label 348
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}
return pOut;
}

/*
** This function is called after invoking an sqlite3_value_XXX function on a 
** column value (i.e. a value returned by evaluating an SQL expression in the
** select list of a SELECT statement) that may cause a malloc() failure. If 
** malloc() has failed, the threads mallocFailed flag is cleared and the result
** code of statement pStmt set to SQLITE_NOMEM.
**
** Specifically, this is called from within:
**
**     sqlite3_column_int()
**     sqlite3_column_int64()
**     sqlite3_column_text()
**     sqlite3_column_text16()
**     sqlite3_column_real()
**     sqlite3_column_bytes()
**     sqlite3_column_bytes16()
**     sqiite3_column_blob()
*/
static void columnMallocFailure(sqlite3_stmt *pStmt)
{
  /* If malloc() failed during an encoding conversion within an
  ** sqlite3_column_XXX API, then set the return code of the statement to
  ** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR
  ** and _finalize() will return NOMEM.
  */
  Vdbe *p = (Vdbe *)pStmt;
  
// ABS Label 349
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
if( p ){
    assert( p->db!=0 );
    assert( sqlite3_mutex_held(p->db->mutex) );
    p->rc = sqlite3ApiExit(p->db, p->rc);
    
// ABS Label 350
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
sqlite3_mutex_leave(p->db->mutex);
  }
}

/**************************** sqlite3_column_  *******************************
** The following routines are used to access elements of the current row
** in the result set.
*/
const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
  const void *val;
  val = sqlite3_value_blob( columnMem(pStmt,i) );
  /* Even though there is no encoding conversion, value_blob() might
  ** need to call malloc() to expand the result of a zeroblob() 
  ** expression. 
  */
  
// ABS Label 351
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
columnMallocFailure(pStmt);
  
// ABS Label 352
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}
return val;
}
int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes( columnMem(pStmt,i) );
  
// ABS Label 353
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}
columnMallocFailure(pStmt);
  
// ABS Label 354
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
return val;
}
int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );
  
// ABS Label 355
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
columnMallocFailure(pStmt);
  
// ABS Label 356
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}
return val;
}
double sqlite3_column_double(sqlite3_stmt *pStmt, int i){
  double val = sqlite3_value_double( columnMem(pStmt,i) );
  
// ABS Label 357
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}
columnMallocFailure(pStmt);
  
// ABS Label 358
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}
return val;
}
int sqlite3_column_int(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_int( columnMem(pStmt,i) );
  
// ABS Label 359
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 359);
}
columnMallocFailure(pStmt);
  
// ABS Label 360
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}
return val;
}
sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){
  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );
  
// ABS Label 361
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}
columnMallocFailure(pStmt);
  
// ABS Label 362
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}
return val;
}
const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){
  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );
  
// ABS Label 363
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 363);
}
columnMallocFailure(pStmt);
  
// ABS Label 364
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
return val;
}
sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){
  Mem *pOut = columnMem(pStmt, i);
  
// AOR Label 366
if(pOut->flags | 2048 != pOut->flags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 366);
}
// AOR Label 367
if(pOut->flags ^ 2048 != pOut->flags & 2048)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 367);
}
if( pOut->flags&MEM_Static ){
    pOut->flags &= ~MEM_Static;
    pOut->flags |= MEM_Ephem;
  }
  
// ABS Label 365
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
columnMallocFailure(pStmt);
  return (sqlite3_value *)pOut;
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){
  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );
  
// ABS Label 368
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}
columnMallocFailure(pStmt);
  
// ABS Label 369
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
return val;
}
#endif /* SQLITE_OMIT_UTF16 */
int sqlite3_column_type(sqlite3_stmt *pStmt, int i){
  int iType = sqlite3_value_type( columnMem(pStmt,i) );
  
// ABS Label 370
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}
columnMallocFailure(pStmt);
  
// ABS Label 371
if(iType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}
return iType;
}

/*
** Convert the N-th element of pStmt->pColName[] into a string using
** xFunc() then return that string.  If N is out of range, return 0.
**
** There are up to 5 names for each column.  useType determines which
** name is returned.  Here are the names:
**
**    0      The column name as it should be displayed for output
**    1      The datatype name for the column
**    2      The name of the database that the column derives from
**    3      The name of the table that the column derives from
**    4      The name of the table column that the result column derives from
**
** If the result is not a simple column reference (if it is an expression
** or a constant) then useTypes 2, 3, and 4 return NULL.
*/
static const void *columnName(
  sqlite3_stmt *pStmt,     /* The statement */
  int N,                   /* Which column to get the name for */
  int useUtf16,            /* True to return the name as UTF16 */
  int useType              /* What type of name */
){
  const void *ret;
  Vdbe *p;
  int n;
  sqlite3 *db;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( pStmt==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  ret = 0;
  p = (Vdbe *)pStmt;
  db = p->db;
  assert( db!=0 );
  n = sqlite3_column_count(pStmt);
  
// ABS Label 372
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
// ABS Label 373
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// COR Label 374
if((N < n || N >= 0) != (N < n && N >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 374);
}

// ROR Label 375
if((N <= n) != (N < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
// ROR Label 376
if((N > n) != (N < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((N >= n) != (N < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((N < 0) != (N >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
// ROR Label 379
if((N > 0) != (N >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 379);
}
// ROR Label 380
if((N <= 0) != (N >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 380);
}

// MCC Label 381
if(N < n && N >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(N < n && !(N >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}
// MCC Label 383
if(!(N < n) && N >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(!(N < n) && !(N >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
if( N<n && N>=0 ){
    N += useType*n;
    
// ABS Label 385
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
sqlite3_mutex_enter(db->mutex);
    assert( db->mallocFailed==0 );
#ifndef SQLITE_OMIT_UTF16
    
// ABS Label 387
if(useUtf16 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}
if( useUtf16 ){
      ret = sqlite3_value_text16((sqlite3_value*)&p->aColName[N]);
    }else
#endif
    {
      ret = sqlite3_value_text((sqlite3_value*)&p->aColName[N]);
    }
    /* A malloc may have failed inside of the _text() call. If this
    ** is the case, clear the mallocFailed flag and return NULL.
    */
    
// ABS Label 388
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
if( db->mallocFailed ){
      
// ABS Label 389
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}
sqlite3OomClear(db);
      ret = 0;
    }
    
// ABS Label 386
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
sqlite3_mutex_leave(db->mutex);
  }
  
// ABS Label 390
if(ret < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}
return ret;
}

/*
** Return the name of the Nth column of the result set returned by SQL
** statement pStmt.
*/
const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_NAME);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_NAME);
}
#endif

/*
** Constraint:  If you have ENABLE_COLUMN_METADATA then you must
** not define OMIT_DECLTYPE.
*/
#if defined(SQLITE_OMIT_DECLTYPE) && defined(SQLITE_ENABLE_COLUMN_METADATA)
# error "Must not define both SQLITE_OMIT_DECLTYPE \
         and SQLITE_ENABLE_COLUMN_METADATA"
#endif

#ifndef SQLITE_OMIT_DECLTYPE
/*
** Return the column declaration type (if applicable) of the 'i'th column
** of the result set of SQL statement pStmt.
*/
const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_DECLTYPE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_DECLTYPE);
}
#endif /* SQLITE_OMIT_UTF16 */
#endif /* SQLITE_OMIT_DECLTYPE */

#ifdef SQLITE_ENABLE_COLUMN_METADATA
/*
** Return the name of the database from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_DATABASE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_DATABASE);
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** Return the name of the table from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_TABLE);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_TABLE);
}
#endif /* SQLITE_OMIT_UTF16 */

/*
** Return the name of the table column from which a result column derives.
** NULL is returned if the result column is an expression or constant or
** anything else which is not an unambiguous reference to a database column.
*/
const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, COLNAME_COLUMN);
}
#ifndef SQLITE_OMIT_UTF16
const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, COLNAME_COLUMN);
}
#endif /* SQLITE_OMIT_UTF16 */
#endif /* SQLITE_ENABLE_COLUMN_METADATA */


/******************************* sqlite3_bind_  ***************************
** 
** Routines used to attach values to wildcards in a compiled SQL statement.
*/
/*
** Unbind the value bound to variable i in virtual machine p. This is the 
** the same as binding a NULL value to the column. If the "i" parameter is
** out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK.
**
** A successful evaluation of this routine acquires the mutex on p.
** the mutex is released if any kind of error occurs.
**
** The error code stored in database p->db is overwritten with the return
** value in any case.
*/
static int vdbeUnbind(Vdbe *p, int i){
  Mem *pVar;
  if( vdbeSafetyNotNull(p) ){
    return SQLITE_MISUSE_BKPT;
  }
  
// ABS Label 391
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}
sqlite3_mutex_enter(p->db->mutex);
  
// ABS Label 393
if(p->iVdbeMagic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}
// ABS Label 394
if(p->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}

// COR Label 395
if((p->iVdbeMagic != 770837923 && p->pc >= 0) != (p->iVdbeMagic != 770837923 || p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 395);
}

// ROR Label 396
if((p->iVdbeMagic == 770837923) != (p->iVdbeMagic != 770837923))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 396);
}
// ROR Label 397
if((p->pc < 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 397);
}
// ROR Label 398
if((p->pc > 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 398);
}
// ROR Label 399
if((p->pc <= 0) != (p->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 399);
}

// MCC Label 400
if(p->iVdbeMagic != 770837923 && p->pc >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 400);
}
// MCC Label 401
if(p->iVdbeMagic != 770837923 && !(p->pc >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 401);
}
// MCC Label 402
if(!(p->iVdbeMagic != 770837923) && p->pc >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 402);
}
// MCC Label 403
if(!(p->iVdbeMagic != 770837923) && !(p->pc >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 403);
}
if( p->iVdbeMagic!=VDBE_MAGIC_RUN || p->pc>=0 ){
    
// ABS Label 404
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}
sqlite3Error(p->db, SQLITE_MISUSE);
    
// ABS Label 405
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}
sqlite3_mutex_leave(p->db->mutex);
    
// ABS Label 406
if(p->zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
sqlite3_log(SQLITE_MISUSE, 
        "bind on a busy prepared statement: [%s]", p->zSql);
    return SQLITE_MISUSE_BKPT;
  }
  
// ABS Label 407
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// COR Label 408
if((i < 1 && i > p->nVar) != (i < 1 || i > p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 408);
}

// ROR Label 409
if((i <= 1) != (i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 409);
}
// ROR Label 410
if((i > 1) != (i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
// ROR Label 411
if((i >= 1) != (i < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 411);
}
// ROR Label 412
if((i <= p->nVar) != (i > p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 412);
}
// ROR Label 413
if((i < p->nVar) != (i > p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 413);
}
// ROR Label 414
if((i >= p->nVar) != (i > p->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 414);
}

// MCC Label 415
if(i < 1 && i > p->nVar ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 415);
}
// MCC Label 416
if(i < 1 && !(i > p->nVar) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 416);
}
// MCC Label 417
if(!(i < 1) && i > p->nVar ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 417);
}
// MCC Label 418
if(!(i < 1) && !(i > p->nVar) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 418);
}
if( i<1 || i>p->nVar ){
    
// ABS Label 419
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}
sqlite3Error(p->db, SQLITE_RANGE);
    
// ABS Label 420
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 420);
}
sqlite3_mutex_leave(p->db->mutex);
    return SQLITE_RANGE;
  }
  i--;
  pVar = &p->aVar[i];
  
// ABS Label 392
if(pVar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}
sqlite3VdbeMemRelease(pVar);
  pVar->flags = MEM_Null;
  p->db->errCode = SQLITE_OK;

  /* If the bit corresponding to this variable in Vdbe.expmask is set, then 
  ** binding a new value to this variable invalidates the current query plan.
  **
  ** IMPLEMENTATION-OF: R-57496-20354 If the specific value bound to a host
  ** parameter in the WHERE clause might influence the choice of query plan
  ** for a statement, then the statement will be automatically recompiled,
  ** as if there had been a schema change, on the first sqlite3_step() call
  ** following any change to the bindings of that parameter.
  */
  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );
  
// ABS Label 421
if(p->expmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}

// COR Label 422
if((p->expmask != 0 || (p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0) != (p->expmask != 0 && (p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 422);
}

// ROR Label 423
if((p->expmask == 0) != (p->expmask != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 423);
}
// ROR Label 424
if(((p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) == 0) != ((p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 424);
}

// MCC Label 425
if(p->expmask != 0 && (p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 425);
}
// MCC Label 426
if(p->expmask != 0 && !((p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 426);
}
// MCC Label 427
if(!(p->expmask != 0) && (p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 427);
}
// MCC Label 428
if(!(p->expmask != 0) && !((p->expmask & (i >= 31 ? 2147483648U : (u32)1 << i)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 428);
}
if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){
    p->expired = 1;
  }
  return SQLITE_OK;
}

/*
** Bind a text or BLOB value.
*/
static int bindText(
  sqlite3_stmt *pStmt,   /* The statement to bind against */
  int i,                 /* Index of the parameter to bind */
  const void *zData,     /* Pointer to the data to be bound */
  i64 nData,             /* Number of bytes of data to be bound */
  void (*xDel)(void*),   /* Destructor for the data */
  u8 encoding            /* Encoding for the data */
){
  Vdbe *p = (Vdbe *)pStmt;
  Mem *pVar;
  int rc;

  rc = vdbeUnbind(p, i);
  
// ABS Label 429
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}

// ROR Label 430
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}
if( rc==SQLITE_OK ){
    
// ABS Label 432
if(zData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}

// ROR Label 433
if((zData == 0) != (zData != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 433);
}
if( zData!=0 ){
      pVar = &p->aVar[i-1];
      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
      
// ABS Label 434
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}

// COR Label 435
if((rc == 0 || encoding != 0) != (rc == 0 && encoding != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 435);
}

// ROR Label 436
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((encoding == 0) != (encoding != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}

// MCC Label 438
if(rc == 0 && encoding != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 438);
}
// MCC Label 439
if(rc == 0 && !(encoding != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 439);
}
// MCC Label 440
if(!(rc == 0) && encoding != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(!(rc == 0) && !(encoding != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
if( rc==SQLITE_OK && encoding!=0 ){
        rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));
      }
      
// ABS Label 442
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}
if( rc ){
        
// ABS Label 443
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}

// ABS Label 444
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
sqlite3Error(p->db, rc);
        rc = sqlite3ApiExit(p->db, rc);
      }
    }
    
// ABS Label 431
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}
sqlite3_mutex_leave(p->db->mutex);
  }else { 
// ABS Label 445
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// COR Label 446
if((xDel != ((sqlite3_destructor_type)0) || xDel != ((sqlite3_destructor_type)-1)) != (xDel != ((sqlite3_destructor_type)0) && xDel != ((sqlite3_destructor_type)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 446);
}

// ROR Label 447
if((xDel == ((sqlite3_destructor_type)0)) != (xDel != ((sqlite3_destructor_type)0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((xDel == ((sqlite3_destructor_type)-1)) != (xDel != ((sqlite3_destructor_type)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}

// MCC Label 449
if(xDel != ((sqlite3_destructor_type)0) && xDel != ((sqlite3_destructor_type)-1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 449);
}
// MCC Label 450
if(xDel != ((sqlite3_destructor_type)0) && !(xDel != ((sqlite3_destructor_type)-1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 450);
}
// MCC Label 451
if(!(xDel != ((sqlite3_destructor_type)0)) && xDel != ((sqlite3_destructor_type)-1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 451);
}
// MCC Label 452
if(!(xDel != ((sqlite3_destructor_type)0)) && !(xDel != ((sqlite3_destructor_type)-1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 452);
}
if( xDel!=SQLITE_STATIC && xDel!=SQLITE_TRANSIENT ){
    xDel((void*)zData);
  };}

  
// ABS Label 453
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
return rc;
}


/*
** Bind a blob value to an SQL statement variable.
*/
int sqlite3_bind_blob(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  int nData, 
  void (*xDel)(void*)
){
#ifdef SQLITE_ENABLE_API_ARMOR
  if( nData<0 ) return SQLITE_MISUSE_BKPT;
#endif
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
int sqlite3_bind_blob64(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  sqlite3_uint64 nData, 
  void (*xDel)(void*)
){
  assert( xDel!=SQLITE_DYNAMIC );
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  
// ABS Label 454
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}

// ROR Label 455
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}
if( rc==SQLITE_OK ){
    
// ABS Label 456
if(rValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}
sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);
    
// ABS Label 457
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
sqlite3_mutex_leave(p->db->mutex);
  }
  
// ABS Label 458
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
return rc;
}
int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
  return sqlite3_bind_int64(p, i, (i64)iValue);
}
int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  
// ABS Label 459
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// ROR Label 460
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}
if( rc==SQLITE_OK ){
    
// ABS Label 461
if(iValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 461);
}
sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);
    
// ABS Label 462
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 462);
}
sqlite3_mutex_leave(p->db->mutex);
  }
  
// ABS Label 463
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}
return rc;
}
int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  
// ABS Label 464
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 464);
}

// ROR Label 465
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
if( rc==SQLITE_OK ){
    
// ABS Label 466
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}
sqlite3_mutex_leave(p->db->mutex);
  }
  
// ABS Label 467
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 467);
}
return rc;
}
int sqlite3_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  
// ABS Label 468
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 468);
}

// ROR Label 469
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 469);
}
if( rc==SQLITE_OK ){
    
// ABS Label 470
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}

// ABS Label 471
if(zPTtype < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}

// ABS Label 472
if(xDestructor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}
sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);
    
// ABS Label 473
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}
sqlite3_mutex_leave(p->db->mutex);
  }else { 
// ABS Label 474
if(xDestructor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}
if( xDestructor ){
    
// ABS Label 475
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}
xDestructor(pPtr);
  };}

  
// ABS Label 476
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}
return rc;
}
int sqlite3_bind_text( 
  sqlite3_stmt *pStmt, 
  int i, 
  const char *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);
}
int sqlite3_bind_text64( 
  sqlite3_stmt *pStmt, 
  int i, 
  const char *zData, 
  sqlite3_uint64 nData, 
  void (*xDel)(void*),
  unsigned char enc
){
  assert( xDel!=SQLITE_DYNAMIC );
  
// ROR Label 477
if((enc != 4) != (enc == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 477);
}
if( enc==SQLITE_UTF16 ) { enc = SQLITE_UTF16NATIVE;
}
  return bindText(pStmt, i, zData, nData, xDel, enc);
}
#ifndef SQLITE_OMIT_UTF16
int sqlite3_bind_text16(
  sqlite3_stmt *pStmt, 
  int i, 
  const void *zData, 
  int nData, 
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);
}
#endif /* SQLITE_OMIT_UTF16 */
int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
  int rc;
  switch( sqlite3_value_type((sqlite3_value*)pValue) ){
    case SQLITE_INTEGER: {
      rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);
      break;
    }
    case SQLITE_FLOAT: {
      rc = sqlite3_bind_double(pStmt, i, pValue->u.r);
      break;
    }
    case SQLITE_BLOB: {
      
// AOR Label 478
if(pValue->flags | 16384 != pValue->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 478);
}
// AOR Label 479
if(pValue->flags ^ 16384 != pValue->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 479);
}
if( pValue->flags & MEM_Zero ){
        rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);
      }else{
        rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,SQLITE_TRANSIENT);
      }
      break;
    }
    case SQLITE_TEXT: {
      rc = bindText(pStmt,i,  pValue->z, pValue->n, SQLITE_TRANSIENT,
                              pValue->enc);
      break;
    }
    default: {
      rc = sqlite3_bind_null(pStmt, i);
      break;
    }
  }
  
// ABS Label 480
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}
return rc;
}
int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  
// ABS Label 481
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}

// ROR Label 482
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 482);
}
if( rc==SQLITE_OK ){
    
// ABS Label 483
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}
sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);
    
// ABS Label 484
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}
sqlite3_mutex_leave(p->db->mutex);
  }
  
// ABS Label 485
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}
return rc;
}
int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  
// ABS Label 486
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
sqlite3_mutex_enter(p->db->mutex);
  
// ABS Label 488
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}

// ROR Label 489
if((n <= (u64)p->db->aLimit[0]) != (n > (u64)p->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 489);
}
// ROR Label 490
if((n < (u64)p->db->aLimit[0]) != (n > (u64)p->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 490);
}
// ROR Label 491
if((n >= (u64)p->db->aLimit[0]) != (n > (u64)p->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 491);
}
if( n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){
    rc = SQLITE_TOOBIG;
  }else{
    assert( (n & 0x7FFFFFFF)==n );
    rc = sqlite3_bind_zeroblob(pStmt, i, n);
  }
  rc = sqlite3ApiExit(p->db, rc);
  
// ABS Label 487
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
sqlite3_mutex_leave(p->db->mutex);
  
// ABS Label 492
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}
return rc;
}

/*
** Return the number of wildcards that can be potentially bound to.
** This routine is added to support DBD::SQLite.  
*/
int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p ? p->nVar : 0;
}

/*
** Return the name of a wildcard parameter.  Return NULL if the index
** is out of range or if the wildcard is unnamed.
**
** The result is always UTF-8.
*/
const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
  Vdbe *p = (Vdbe*)pStmt;
  
// ABS Label 493
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}

// ROR Label 494
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
if( p==0 ) { return 0;
}
  return sqlite3VListNumToName(p->pVList, i);
}

/*
** Given a wildcard parameter name, return the index of the variable
** with that name.  If there is no variable with the given name,
** return 0.
*/
int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){
  
// ABS Label 495
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 495);
}
// ABS Label 496
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 496);
}

// COR Label 497
if((p == 0 && zName == 0) != (p == 0 || zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 497);
}

// ROR Label 498
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}
// ROR Label 499
if((zName != 0) != (zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 499);
}

// MCC Label 500
if(p == 0 && zName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(p == 0 && !(zName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(!(p == 0) && zName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(!(p == 0) && !(zName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
if( p==0 || zName==0 ) { return 0;
}
  return sqlite3VListNameToNum(p->pVList, zName, nName);
}
int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}

/*
** Transfer all bindings from the first statement over to the second.
*/
int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  int i;
  assert( pTo->db==pFrom->db );
  assert( pTo->nVar==pFrom->nVar );
  
// ABS Label 504
if(pTo->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}
sqlite3_mutex_enter(pTo->db->mutex);
  i = 0;

// ABS Label 506
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 506);
}

// ROR Label 507
if((i <= pFrom->nVar) != (i < pFrom->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 507);
}
// ROR Label 508
if((i > pFrom->nVar) != (i < pFrom->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 508);
}
// ROR Label 509
if((i >= pFrom->nVar) != (i < pFrom->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 509);
}
for(; i<pFrom->nVar; i++){
    sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);
  };
// ABS Label 510
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}

// ROR Label 511
if((i <= pFrom->nVar) != (i < pFrom->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 511);
}
// ROR Label 512
if((i > pFrom->nVar) != (i < pFrom->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 512);
}
// ROR Label 513
if((i >= pFrom->nVar) != (i < pFrom->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}

  
// ABS Label 505
if(pTo->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 505);
}
sqlite3_mutex_leave(pTo->db->mutex);
  return SQLITE_OK;
}

#ifndef SQLITE_OMIT_DEPRECATED
/*
** Deprecated external interface.  Internal/core SQLite code
** should call sqlite3TransferBindings.
**
** It is misuse to call this routine with statements from different
** database connections.  But as this is a deprecated interface, we
** will not bother to check for that condition.
**
** If the two statements contain a different number of bindings, then
** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise
** SQLITE_OK is returned.
*/
int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  
// ROR Label 514
if((pFrom->nVar == pTo->nVar) != (pFrom->nVar != pTo->nVar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 514);
}
if( pFrom->nVar!=pTo->nVar ){
    return SQLITE_ERROR;
  }
  assert( (pTo->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pTo->expmask==0 );
  
// ABS Label 515
if(pTo->expmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}
if( pTo->expmask ){
    pTo->expired = 1;
  }
  assert( (pFrom->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pFrom->expmask==0 );
  
// ABS Label 516
if(pFrom->expmask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}
if( pFrom->expmask ){
    pFrom->expired = 1;
  }
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
#endif

/*
** Return the sqlite3* database handle to which the prepared statement given
** in the argument belongs.  This is the same database handle that was
** the first argument to the sqlite3_prepare() that was used to create
** the statement in the first place.
*/
sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->db : 0;
}

/*
** Return true if the prepared statement is guaranteed to not modify the
** database.
*/
int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;
}

/*
** Return 1 if the statement is an EXPLAIN and return 2 if the
** statement is an EXPLAIN QUERY PLAN
*/
int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->explain : 0;
}

/*
** Return true if the prepared statement is in need of being reset.
*/
int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
  Vdbe *v = (Vdbe*)pStmt;
  
// ABS Label 517
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}
// ABS Label 518
if(v->iVdbeMagic < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}
// ABS Label 519
if(v->pc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}

// COR Label 520
if((v != 0 && v->iVdbeMagic == 770837923 || v->pc >= 0) != (v != 0 && v->iVdbeMagic == 770837923 && v->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 520);
}
// COR Label 521
if((v != 0 || v->iVdbeMagic == 770837923) != (v != 0 && v->iVdbeMagic == 770837923))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 521);
}

// ROR Label 522
if((v == 0) != (v != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 522);
}
// ROR Label 523
if((v->iVdbeMagic != 770837923) != (v->iVdbeMagic == 770837923))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 523);
}
// ROR Label 524
if((v->pc < 0) != (v->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
// ROR Label 525
if((v->pc > 0) != (v->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 525);
}
// ROR Label 526
if((v->pc <= 0) != (v->pc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 526);
}

// MCC Label 527
if(v != 0 && v->iVdbeMagic == 770837923 && v->pc >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 527);
}
// MCC Label 528
if(v != 0 && v->iVdbeMagic == 770837923 && !(v->pc >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 528);
}
// MCC Label 529
if(v != 0 && !(v->iVdbeMagic == 770837923) && v->pc >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 529);
}
// MCC Label 530
if(v != 0 && !(v->iVdbeMagic == 770837923) && !(v->pc >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 530);
}
// MCC Label 531
if(!(v != 0) && v->iVdbeMagic == 770837923 && v->pc >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 531);
}
// MCC Label 532
if(!(v != 0) && v->iVdbeMagic == 770837923 && !(v->pc >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 532);
}
// MCC Label 533
if(!(v != 0) && !(v->iVdbeMagic == 770837923) && v->pc >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 533);
}
// MCC Label 534
if(!(v != 0) && !(v->iVdbeMagic == 770837923) && !(v->pc >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 534);
}
return v!=0 && v->iVdbeMagic==VDBE_MAGIC_RUN && v->pc>=0;
}

/*
** Return a pointer to the next prepared statement after pStmt associated
** with database connection pDb.  If pStmt is NULL, return the first
** prepared statement for the database connection.  Return NULL if there
** are no more.
*/
sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
  sqlite3_stmt *pNext;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(pDb) ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  
// ABS Label 535
if(pDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}
sqlite3_mutex_enter(pDb->mutex);
  
// ABS Label 537
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}

// ROR Label 538
if((pStmt != 0) != (pStmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 538);
}
if( pStmt==0 ){
    pNext = (sqlite3_stmt*)pDb->pVdbe;
  }else{
    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;
  }
  
// ABS Label 536
if(pDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}
sqlite3_mutex_leave(pDb->mutex);
  
// ABS Label 539
if(pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}
return pNext;
}

/*
** Return the value of a status counter for a prepared statement
*/
int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
  Vdbe *pVdbe = (Vdbe*)pStmt;
  u32 v;
#ifdef SQLITE_ENABLE_API_ARMOR
  if( !pStmt 
   || (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))
  ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  
// ABS Label 540
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}

// ROR Label 541
if((op != 99) != (op == 99))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 541);
}
if( op==SQLITE_STMTSTATUS_MEMUSED ){
    
// ABS Label 542
if(pVdbe->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
sqlite3 *db = pVdbe->db;
    
// ABS Label 543
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}
sqlite3_mutex_enter(db->mutex);
    v = 0;
    db->pnBytesFreed = (int*)&v;
    
// ABS Label 544
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 544);
}

// ABS Label 545
if(pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}
sqlite3VdbeClearObject(db, pVdbe);
    
// ABS Label 546
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}
sqlite3DbFree(db, pVdbe);
    db->pnBytesFreed = 0;
    
// ABS Label 547
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}
sqlite3_mutex_leave(db->mutex);
  }else{
    v = pVdbe->aCounter[op];
    
// ABS Label 548
if(resetFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}
if( resetFlag ) { pVdbe->aCounter[op] = 0;
}
  }
  return (int)v;
}

/*
** Return the SQL associated with a prepared statement
*/
const char *sqlite3_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  return p ? p->zSql : 0;
}

/*
** Return the SQL associated with a prepared statement with
** bound parameters expanded.  Space to hold the returned string is
** obtained from sqlite3_malloc().  The caller is responsible for
** freeing the returned string by passing it to sqlite3_free().
**
** The SQLITE_TRACE_SIZE_LIMIT puts an upper bound on the size of
** expanded bound parameters.
*/
char *sqlite3_expanded_sql(sqlite3_stmt *pStmt){
#ifdef SQLITE_OMIT_TRACE
  return 0;
#else
  char *z = 0;
  const char *zSql = sqlite3_sql(pStmt);
  
// ABS Label 549
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}
if( zSql ){
    Vdbe *p = (Vdbe *)pStmt;
    
// ABS Label 550
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}
sqlite3_mutex_enter(p->db->mutex);
    z = sqlite3VdbeExpandSql(p, zSql);
    
// ABS Label 551
if(p->db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 551);
}
sqlite3_mutex_leave(p->db->mutex);
  }
  
// ABS Label 552
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}
return z;
#endif
}

#ifdef SQLITE_ENABLE_NORMALIZE
/*
** Return the normalized SQL associated with a prepared statement.
*/
const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  if( p==0 ) return 0;
  if( p->zNormSql==0 && ALWAYS(p->zSql!=0) ){
    sqlite3_mutex_enter(p->db->mutex);
    p->zNormSql = sqlite3Normalize(p, p->zSql);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return p->zNormSql;
}
#endif /* SQLITE_ENABLE_NORMALIZE */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** Allocate and populate an UnpackedRecord structure based on the serialized
** record in nKey/pKey. Return a pointer to the new UnpackedRecord structure
** if successful, or a NULL pointer if an OOM error is encountered.
*/
static UnpackedRecord *vdbeUnpackRecord(
  KeyInfo *pKeyInfo, 
  int nKey, 
  const void *pKey
){
  UnpackedRecord *pRet;           /* Return value */

  pRet = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
  if( pRet ){
    memset(pRet->aMem, 0, sizeof(Mem)*(pKeyInfo->nKeyField+1));
    sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, pRet);
  }
  return pRet;
}

/*
** This function is called from within a pre-update callback to retrieve
** a field of the row currently being updated or deleted.
*/
int sqlite3_preupdate_old(sqlite3 *db, int iIdx, sqlite3_value **ppValue){
  PreUpdate *p = db->pPreUpdate;
  Mem *pMem;
  int rc = SQLITE_OK;

  /* Test that this call is being made from within an SQLITE_DELETE or
  ** SQLITE_UPDATE pre-update callback, and that iIdx is within range. */
  if( !p || p->op==SQLITE_INSERT ){
    rc = SQLITE_MISUSE_BKPT;
    goto preupdate_old_out;
  }
  if( p->pPk ){
    iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);
  }
  if( iIdx>=p->pCsr->nField || iIdx<0 ){
    rc = SQLITE_RANGE;
    goto preupdate_old_out;
  }

  /* If the old.* record has not yet been loaded into memory, do so now. */
  if( p->pUnpacked==0 ){
    u32 nRec;
    u8 *aRec;

    nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);
    aRec = sqlite3DbMallocRaw(db, nRec);
    if( !aRec ) goto preupdate_old_out;
    rc = sqlite3BtreePayload(p->pCsr->uc.pCursor, 0, nRec, aRec);
    if( rc==SQLITE_OK ){
      p->pUnpacked = vdbeUnpackRecord(&p->keyinfo, nRec, aRec);
      if( !p->pUnpacked ) rc = SQLITE_NOMEM;
    }
    if( rc!=SQLITE_OK ){
      sqlite3DbFree(db, aRec);
      goto preupdate_old_out;
    }
    p->aRecord = aRec;
  }

  pMem = *ppValue = &p->pUnpacked->aMem[iIdx];
  if( iIdx==p->pTab->iPKey ){
    sqlite3VdbeMemSetInt64(pMem, p->iKey1);
  }else if( iIdx>=p->pUnpacked->nField ){
    *ppValue = (sqlite3_value *)columnNullValue();
  }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){
    if( pMem->flags & (MEM_Int|MEM_IntReal) ){
      testcase( pMem->flags & MEM_Int );
      testcase( pMem->flags & MEM_IntReal );
      sqlite3VdbeMemRealify(pMem);
    }
  }

 preupdate_old_out:
  sqlite3Error(db, rc);
  return sqlite3ApiExit(db, rc);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is called from within a pre-update callback to retrieve
** the number of columns in the row being updated, deleted or inserted.
*/
int sqlite3_preupdate_count(sqlite3 *db){
  PreUpdate *p = db->pPreUpdate;
  return (p ? p->keyinfo.nKeyField : 0);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is designed to be called from within a pre-update callback
** only. It returns zero if the change that caused the callback was made
** immediately by a user SQL statement. Or, if the change was made by a
** trigger program, it returns the number of trigger programs currently
** on the stack (1 for a top-level trigger, 2 for a trigger fired by a 
** top-level trigger etc.).
**
** For the purposes of the previous paragraph, a foreign key CASCADE, SET NULL
** or SET DEFAULT action is considered a trigger.
*/
int sqlite3_preupdate_depth(sqlite3 *db){
  PreUpdate *p = db->pPreUpdate;
  return (p ? p->v->nFrame : 0);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is designed to be called from within a pre-update callback
** only. 
*/
int sqlite3_preupdate_blobwrite(sqlite3 *db){
  PreUpdate *p = db->pPreUpdate;
  return (p ? p->iBlobWrite : -1);
}
#endif

#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
/*
** This function is called from within a pre-update callback to retrieve
** a field of the row currently being updated or inserted.
*/
int sqlite3_preupdate_new(sqlite3 *db, int iIdx, sqlite3_value **ppValue){
  PreUpdate *p = db->pPreUpdate;
  int rc = SQLITE_OK;
  Mem *pMem;

  if( !p || p->op==SQLITE_DELETE ){
    rc = SQLITE_MISUSE_BKPT;
    goto preupdate_new_out;
  }
  if( p->pPk && p->op!=SQLITE_UPDATE ){
    iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);
  }
  if( iIdx>=p->pCsr->nField || iIdx<0 ){
    rc = SQLITE_RANGE;
    goto preupdate_new_out;
  }

  if( p->op==SQLITE_INSERT ){
    /* For an INSERT, memory cell p->iNewReg contains the serialized record
    ** that is being inserted. Deserialize it. */
    UnpackedRecord *pUnpack = p->pNewUnpacked;
    if( !pUnpack ){
      Mem *pData = &p->v->aMem[p->iNewReg];
      rc = ExpandBlob(pData);
      if( rc!=SQLITE_OK ) goto preupdate_new_out;
      pUnpack = vdbeUnpackRecord(&p->keyinfo, pData->n, pData->z);
      if( !pUnpack ){
        rc = SQLITE_NOMEM;
        goto preupdate_new_out;
      }
      p->pNewUnpacked = pUnpack;
    }
    pMem = &pUnpack->aMem[iIdx];
    if( iIdx==p->pTab->iPKey ){
      sqlite3VdbeMemSetInt64(pMem, p->iKey2);
    }else if( iIdx>=pUnpack->nField ){
      pMem = (sqlite3_value *)columnNullValue();
    }
  }else{
    /* For an UPDATE, memory cell (p->iNewReg+1+iIdx) contains the required
    ** value. Make a copy of the cell contents and return a pointer to it.
    ** It is not safe to return a pointer to the memory cell itself as the
    ** caller may modify the value text encoding.
    */
    assert( p->op==SQLITE_UPDATE );
    if( !p->aNew ){
      p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem) * p->pCsr->nField);
      if( !p->aNew ){
        rc = SQLITE_NOMEM;
        goto preupdate_new_out;
      }
    }
    assert( iIdx>=0 && iIdx<p->pCsr->nField );
    pMem = &p->aNew[iIdx];
    if( pMem->flags==0 ){
      if( iIdx==p->pTab->iPKey ){
        sqlite3VdbeMemSetInt64(pMem, p->iKey2);
      }else{
        rc = sqlite3VdbeMemCopy(pMem, &p->v->aMem[p->iNewReg+1+iIdx]);
        if( rc!=SQLITE_OK ) goto preupdate_new_out;
      }
    }
  }
  *ppValue = pMem;

 preupdate_new_out:
  sqlite3Error(db, rc);
  return sqlite3ApiExit(db, rc);
}
#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */

#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
/*
** Return status data for a single loop within query pStmt.
*/
int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,            /* Prepared statement being queried */
  int idx,                        /* Index of loop to report on */
  int iScanStatusOp,              /* Which metric to return */
  void *pOut                      /* OUT: Write the answer here */
){
  Vdbe *p = (Vdbe*)pStmt;
  ScanStatus *pScan;
  if( idx<0 || idx>=p->nScan ) return 1;
  pScan = &p->aScan[idx];
  switch( iScanStatusOp ){
    case SQLITE_SCANSTAT_NLOOP: {
      *(sqlite3_int64*)pOut = p->anExec[pScan->addrLoop];
      break;
    }
    case SQLITE_SCANSTAT_NVISIT: {
      *(sqlite3_int64*)pOut = p->anExec[pScan->addrVisit];
      break;
    }
    case SQLITE_SCANSTAT_EST: {
      double r = 1.0;
      LogEst x = pScan->nEst;
      while( x<100 ){
        x += 10;
        r *= 0.5;
      }
      *(double*)pOut = r*sqlite3LogEstToInt(x);
      break;
    }
    case SQLITE_SCANSTAT_NAME: {
      *(const char**)pOut = pScan->zName;
      break;
    }
    case SQLITE_SCANSTAT_EXPLAIN: {
      if( pScan->addrExplain ){
        *(const char**)pOut = p->aOp[ pScan->addrExplain ].p4.z;
      }else{
        *(const char**)pOut = 0;
      }
      break;
    }
    case SQLITE_SCANSTAT_SELECTID: {
      if( pScan->addrExplain ){
        *(int*)pOut = p->aOp[ pScan->addrExplain ].p1;
      }else{
        *(int*)pOut = -1;
      }
      break;
    }
    default: {
      return 1;
    }
  }
  return 0;
}

/*
** Zero all counters associated with the sqlite3_stmt_scanstatus() data.
*/
void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  memset(p->anExec, 0, p->nOp * sizeof(i64));
}
#endif /* SQLITE_ENABLE_STMT_SCANSTATUS */
