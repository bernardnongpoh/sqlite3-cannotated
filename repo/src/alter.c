/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2005 February 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that used to generate VDBE code
** that implements the ALTER TABLE command.
*/
#include "sqliteInt.h"

/*
** The code in this file only exists if we are not omitting the
** ALTER TABLE logic from the build.
*/
#ifndef SQLITE_OMIT_ALTERTABLE

/*
** Parameter zName is the name of a table that is about to be altered
** (either with ALTER TABLE ... RENAME TO or ALTER TABLE ... ADD COLUMN).
** If the table is a system table, this function leaves an error message
** in pParse->zErr (system tables may not be altered) and returns non-zero.
**
** Or, if zName is not a system table, zero is returned.
*/
static int isAlterableTable(Parse *pParse, Table *pTab){
  if( 0==sqlite3StrNICmp(pTab->zName, "sqlite_", 7)
#ifndef SQLITE_OMIT_VIRTUALTABLE
   || (pTab->tabFlags & TF_Eponymous)!=0
   || ( (pTab->tabFlags & TF_Shadow)!=0
        && sqlite3ReadOnlyShadowTables(pParse->db)
   )
#endif
  ){
    
// ABS Label 7
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ABS Label 8
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);
    return 1;
  }
  return 0;
}

/*
** Generate code to verify that the schemas of database zDb and, if
** bTemp is not true, database "temp", can still be parsed. This is
** called at the end of the generation of an ALTER TABLE ... RENAME ...
** statement to ensure that the operation has not rendered any schema
** objects unusable.
*/
static void renameTestSchema(
  Parse *pParse,                  /* Parse context */
  const char *zDb,                /* Name of db to verify schema of */
  int bTemp,                      /* True if this is the temp db */
  const char *zWhen,              /* "when" part of error message */
  int bNoDQS                      /* Do not allow DQS in the schema */
){
  pParse->colNamesSet = 1;
  
// ABS Label 9
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

// ABS Label 10
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}

// ABS Label 11
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ABS Label 12
if(bTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ABS Label 13
if(zWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// ABS Label 14
if(bNoDQS < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
sqlite3NestedParse(pParse, 
      "SELECT 1 "
      "FROM \"%w\"." DFLT_SCHEMA_TABLE " "
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'"
      " AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ",
      zDb,
      zDb, bTemp, zWhen, bNoDQS
  );

  
// ABS Label 15
if(bTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}

// ROR Label 16
if((bTemp != 0) != (bTemp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
if( bTemp==0 ){
    
// ABS Label 17
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// ABS Label 18
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ABS Label 19
if(zWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}

// ABS Label 20
if(bNoDQS < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
sqlite3NestedParse(pParse, 
        "SELECT 1 "
        "FROM temp." DFLT_SCHEMA_TABLE " "
        "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
        " AND sql NOT LIKE 'create virtual%%'"
        " AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ",
        zDb, zWhen, bNoDQS
    );
  }
}

/*
** Generate VM code to replace any double-quoted strings (but not double-quoted
** identifiers) within the "sql" column of the sqlite_schema table in 
** database zDb with their single-quoted equivalents. If argument bTemp is
** not true, similarly update all SQL statements in the sqlite_schema table
** of the temp db.
*/
static void renameFixQuotes(Parse *pParse, const char *zDb, int bTemp){
  
// ABS Label 21
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}

// ABS Label 22
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ABS Label 23
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3NestedParse(pParse, 
      "UPDATE \"%w\"." DFLT_SCHEMA_TABLE 
      " SET sql = sqlite_rename_quotefix(%Q, sql)"
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'" , zDb, zDb
  );
  
// ABS Label 24
if(bTemp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// ROR Label 25
if((bTemp != 0) != (bTemp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
if( bTemp==0 ){
    
// ABS Label 26
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3NestedParse(pParse, 
      "UPDATE temp." DFLT_SCHEMA_TABLE
      " SET sql = sqlite_rename_quotefix('temp', sql)"
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'"
    );
  }
}

/*
** Generate code to reload the schema for database iDb. And, if iDb!=1, for
** the temp database as well.
*/
static void renameReloadSchema(Parse *pParse, int iDb, u16 p5){
  
// ABS Label 27
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
Vdbe *v = pParse->pVdbe;
  
// ABS Label 28
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}
if( v ){
    
// ABS Label 29
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}

// ABS Label 30
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
sqlite3ChangeCookie(pParse, iDb);
    
// ABS Label 31
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// ABS Label 32
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}

// ABS Label 33
if(p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0, p5);
    
// ABS Label 34
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ROR Label 35
if((iDb == 1) != (iDb != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
if( iDb!=1 ) { 
// ABS Label 36
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ABS Label 37
if(p5 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0, p5);
}
  }
}

/*
** Generate code to implement the "ALTER TABLE xxx RENAME TO yyy" 
** command. 
*/
void sqlite3AlterRenameTable(
  Parse *pParse,            /* Parser context. */
  SrcList *pSrc,            /* The table to rename. */
  Token *pName              /* The new table name. */
){
  int iDb;                  /* Database that contains the table */
  char *zDb;                /* Name of database iDb */
  Table *pTab;              /* Table being renamed */
  char *zName = 0;          /* NULL-terminated version of pName */ 
  
// ABS Label 38
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
sqlite3 *db = pParse->db; /* Database connection */
  int nTabName;             /* Number of UTF-8 characters in zTabName */
  const char *zTabName;     /* Original name of the table */
  Vdbe *v;
  VTable *pVTab = 0;        /* Non-zero if this is a v-tab with an xRename() */
  u32 savedDbFlags;         /* Saved value of db->mDbFlags */

  savedDbFlags = db->mDbFlags;  
  
// ABS Label 59
if((db->mallocFailed) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
if( NEVER(db->mallocFailed) ) { goto exit_rename_table;
}
  assert( pSrc->nSrc==1 );
  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );

  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) { goto exit_rename_table;
}
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  zDb = db->aDb[iDb].zDbSName;
  db->mDbFlags |= DBFLAG_PreferBuiltin;

  /* Get a NULL terminated version of the new table name. */
  zName = sqlite3NameFromToken(db, pName);
  if( !zName ) { goto exit_rename_table;
}

  /* Check that a table or index named 'zName' does not already exist
  ** in database iDb. If so, this is an error.
  */
  if( sqlite3FindTable(db, zName, zDb)
   || sqlite3FindIndex(db, zName, zDb)
   || sqlite3IsShadowTableOf(db, pTab, zName)
  ){
    
// ABS Label 60
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}

// ABS Label 61
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
sqlite3ErrorMsg(pParse, 
        "there is already another table or index with this name: %s", zName);
    goto exit_rename_table;
  }

  /* Make sure it is not a system table being altered, or a reserved name
  ** that the table is being renamed to.
  */
  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( SQLITE_OK!=sqlite3CheckObjectName(pParse,zName,"table",zName) ){
    goto exit_rename_table;
  }

#ifndef SQLITE_OMIT_VIEW
  
// ABS Label 62
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}
if( pTab->pSelect ){
    
// ABS Label 63
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}

// ABS Label 64
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}
sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
    goto exit_rename_table;
  }
#endif

#ifndef SQLITE_OMIT_AUTHORIZATION
  /* Invoke the authorization callback. */
  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){
    goto exit_rename_table;
  }
#endif

#ifndef SQLITE_OMIT_VIRTUALTABLE
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_rename_table;
  }
  
// ABS Label 65
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
if( IsVirtual(pTab) ){
    pVTab = sqlite3GetVTable(db, pTab);
    
// ABS Label 66
if(pVTab->pVtab->pModule->xRename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}

// ROR Label 67
if((pVTab->pVtab->pModule->xRename != 0) != (pVTab->pVtab->pModule->xRename == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
if( pVTab->pVtab->pModule->xRename==0 ){
      pVTab = 0;
    }
  }
#endif

  /* Begin a transaction for database iDb. Then modify the schema cookie
  ** (since the ALTER TABLE modifies the schema). Call sqlite3MayAbort(),
  ** as the scalar functions (e.g. sqlite_rename_table()) invoked by the 
  ** nested SQL may raise an exception.  */
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 68
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}

// ROR Label 69
if((v != 0) != (v == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
if( v==0 ){
    goto exit_rename_table;
  }
  
// ABS Label 39
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
sqlite3MayAbort(pParse);

  /* figure out how many UTF-8 characters are in zName */
  zTabName = pTab->zName;
  nTabName = sqlite3Utf8CharLen(zTabName, -1);

  /* Rewrite all CREATE TABLE, INDEX, TRIGGER or VIEW statements in
  ** the schema to use the new table name.  */
  
// ABS Label 40
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}

// ABS Label 41
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// ABS Label 42
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}

// ABS Label 43
if(zTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// ABS Label 44
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// ABS Label 45
if(zTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
sqlite3NestedParse(pParse, 
      "UPDATE \"%w\"." DFLT_SCHEMA_TABLE " SET "
      "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) "
      "WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)"
      "AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      , zDb, zDb, zTabName, zName, (iDb==1), zTabName
  );

  /* Update the tbl_name and name columns of the sqlite_schema table
  ** as required.  */
  
// ABS Label 46
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}

// ABS Label 47
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ABS Label 48
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// ABS Label 49
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}

// ABS Label 50
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}

// ABS Label 51
if(nTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// ABS Label 52
if(zTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
sqlite3NestedParse(pParse,
      "UPDATE %Q." DFLT_SCHEMA_TABLE " SET "
          "tbl_name = %Q, "
          "name = CASE "
            "WHEN type='table' THEN %Q "
            "WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' "
            "     AND type='index' THEN "
             "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
            "ELSE name END "
      "WHERE tbl_name=%Q COLLATE nocase AND "
          "(type='table' OR type='index' OR type='trigger');", 
      zDb,
      zName, zName, zName, 
      nTabName, zTabName
  );

#ifndef SQLITE_OMIT_AUTOINCREMENT
  /* If the sqlite_sequence table exists in this database, then update 
  ** it with the new table name.
  */
  if( sqlite3FindTable(db, "sqlite_sequence", zDb) ){
    
// ABS Label 70
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ABS Label 71
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 71);
}

// ABS Label 72
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}

// ABS Label 73
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
sqlite3NestedParse(pParse,
        "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
        zDb, zName, pTab->zName);
  }
#endif

  /* If the table being renamed is not itself part of the temp database,
  ** edit view and trigger definitions within the temp database 
  ** as required.  */
  
// ABS Label 74
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}

// ROR Label 75
if((iDb == 1) != (iDb != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
if( iDb!=1 ){
    
// ABS Label 76
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// ABS Label 77
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ABS Label 78
if(zTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}

// ABS Label 79
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}

// ABS Label 80
if(zTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}

// ABS Label 81
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ABS Label 82
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
sqlite3NestedParse(pParse, 
        "UPDATE sqlite_temp_schema SET "
            "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), "
            "tbl_name = "
              "CASE WHEN tbl_name=%Q COLLATE nocase AND "
              "  sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) "
              "THEN %Q ELSE tbl_name END "
            "WHERE type IN ('view', 'trigger')"
        , zDb, zTabName, zName, zTabName, zDb, zName);
  }

  /* If this is a virtual table, invoke the xRename() function if
  ** one is defined. The xRename() callback will modify the names
  ** of any resources used by the v-table implementation (including other
  ** SQLite tables) that are identified by the name of the virtual table.
  */
#ifndef SQLITE_OMIT_VIRTUALTABLE
  
// ABS Label 83
if(pVTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
if( pVTab ){
    int i = ++pParse->nMem;
    
// ABS Label 84
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ABS Label 85
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
sqlite3VdbeLoadString(v, i, zName);
    
// ABS Label 86
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// ABS Label 87
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);
  }
#endif

  
// ABS Label 53
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// ABS Label 54
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}
renameReloadSchema(pParse, iDb, INITFLAG_AlterRename);
  
// ABS Label 55
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}

// ABS Label 56
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}

// ROR Label 57
if((iDb != 1) != (iDb == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
renameTestSchema(pParse, zDb, iDb==1, "after rename", 0);

exit_rename_table:
  sqlite3SrcListDelete(db, pSrc);
  
// ABS Label 58
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
sqlite3DbFree(db, zName);
  db->mDbFlags = savedDbFlags;
}

/*
** Write code that will raise an error if the table described by
** zDb and zTab is not empty.
*/
static void sqlite3ErrorIfNotEmpty(
  Parse *pParse,        /* Parsing context */
  const char *zDb,      /* Schema holding the table */
  const char *zTab,     /* Table to check for empty */
  const char *zErr      /* Error message text */
){
  
// ABS Label 88
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// ABS Label 89
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}

// ABS Label 90
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ABS Label 91
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
sqlite3NestedParse(pParse,
     "SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"",
     zErr, zDb, zTab
  );
}

/*
** This function is called after an "ALTER TABLE ... ADD" statement
** has been parsed. Argument pColDef contains the text of the new
** column definition.
**
** The Table structure pParse->pNewTable was extended to include
** the new column during parsing.
*/
void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
  Table *pNew;              /* Copy of pParse->pNewTable */
  Table *pTab;              /* Table being altered */
  int iDb;                  /* Database number */
  const char *zDb;          /* Database name */
  const char *zTab;         /* Table name */
  char *zCol;               /* Null-terminated column definition */
  Column *pCol;             /* The new column */
  Expr *pDflt;              /* Default value for the new column */
  sqlite3 *db;              /* The database connection; */
  Vdbe *v;                  /* The prepared statement under construction */
  int r1;                   /* Temporary registers */

  db = pParse->db;
  
// ABS Label 94
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// COR Label 95
if((pParse->nErr && db->mallocFailed) != (pParse->nErr || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 95);
}

// MCC Label 96
if(pParse->nErr && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(pParse->nErr && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
// MCC Label 98
if(!(pParse->nErr) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 98);
}
// MCC Label 99
if(!(pParse->nErr) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 99);
}
if( pParse->nErr || db->mallocFailed ) { return;
}
  pNew = pParse->pNewTable;
  assert( pNew );

  assert( sqlite3BtreeHoldsAllMutexes(db) );
  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);
  zDb = db->aDb[iDb].zDbSName;
  zTab = &pNew->zName[16];  /* Skip the "sqlite_altertab_" prefix on the name */
  pCol = &pNew->aCol[pNew->nCol-1];
  pDflt = pCol->pDflt;
  pTab = sqlite3FindTable(db, zTab, zDb);
  assert( pTab );

#ifndef SQLITE_OMIT_AUTHORIZATION
  /* Invoke the authorization callback. */
  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){
    return;
  }
#endif


  /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.
  ** If there is a NOT NULL constraint, then the default value for the
  ** column must not be NULL.
  */
  
// AOR Label 100
if(pCol->colFlags | 1 != pCol->colFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 100);
}
// AOR Label 101
if(pCol->colFlags ^ 1 != pCol->colFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 101);
}
if( pCol->colFlags & COLFLAG_PRIMKEY ){
    
// ABS Label 102
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
    return;
  }
  
// ABS Label 103
if(pNew->pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
if( pNew->pIndex ){
    
// ABS Label 104
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
sqlite3ErrorMsg(pParse,
         "Cannot add a UNIQUE column");
    return;
  }
  
// ROR Label 105
if(((pCol->colFlags & 96) != 0) != ((pCol->colFlags & 96) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
if( (pCol->colFlags & COLFLAG_GENERATED)==0 ){
    /* If the default value for the new column was specified with a 
    ** literal NULL, then set pDflt to 0. This simplifies checking
    ** for an SQL NULL default below.
    */
    assert( pDflt==0 || pDflt->op==TK_SPAN );
    
// ABS Label 106
if(pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// COR Label 107
if((pDflt || pDflt->pLeft->op == 120) != (pDflt && pDflt->pLeft->op == 120))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 107);
}

// ROR Label 108
if((pDflt->pLeft->op != 120) != (pDflt->pLeft->op == 120))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 108);
}

// MCC Label 109
if(pDflt && pDflt->pLeft->op == 120 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 109);
}
// MCC Label 110
if(pDflt && !(pDflt->pLeft->op == 120) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(!(pDflt) && pDflt->pLeft->op == 120 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
// MCC Label 112
if(!(pDflt) && !(pDflt->pLeft->op == 120) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
if( pDflt && pDflt->pLeft->op==TK_NULL ){
      pDflt = 0;
    }
    
// ABS Label 113
if(pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
// ABS Label 114
if(pNew->pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// COR Label 115
if(((db->flags & 16384) && pNew->pFKey || pDflt) != ((db->flags & 16384) && pNew->pFKey && pDflt))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 115);
}
// COR Label 116
if(((db->flags & 16384) || pNew->pFKey) != ((db->flags & 16384) && pNew->pFKey))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 116);
}

// MCC Label 117
if(( db->flags & 16384 ) && pNew->pFKey && pDflt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 117);
}
// MCC Label 118
if(( db->flags & 16384 ) && pNew->pFKey && !(pDflt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 118);
}
// MCC Label 119
if(( db->flags & 16384 ) && !(pNew->pFKey) && pDflt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 119);
}
// MCC Label 120
if(( db->flags & 16384 ) && !(pNew->pFKey) && !(pDflt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 120);
}
// MCC Label 121
if(( !(db->flags & 16384) ) && pNew->pFKey && pDflt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 121);
}
// MCC Label 122
if(( !(db->flags & 16384) ) && pNew->pFKey && !(pDflt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(( !(db->flags & 16384) ) && !(pNew->pFKey) && pDflt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
// MCC Label 124
if(( !(db->flags & 16384) ) && !(pNew->pFKey) && !(pDflt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 124);
}
if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){
      
// ABS Label 125
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}

// ABS Label 126
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// ABS Label 127
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}
sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,
          "Cannot add a REFERENCES column with non-NULL default value");
    }
    
// COR Label 128
if((pCol->notNull || !pDflt) != (pCol->notNull && !pDflt))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 128);
}

// MCC Label 129
if(pCol->notNull && !pDflt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
// MCC Label 130
if(pCol->notNull && !(!pDflt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
// MCC Label 131
if(!(pCol->notNull) && !pDflt ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 131);
}
// MCC Label 132
if(!(pCol->notNull) && !(!pDflt) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
if( pCol->notNull && !pDflt ){
      
// ABS Label 133
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}

// ABS Label 134
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}

// ABS Label 135
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}
sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,
          "Cannot add a NOT NULL column with default value NULL");
    }


    /* Ensure the default expression is something that sqlite3ValueFromExpr()
    ** can handle (i.e. not CURRENT_TIME etc.)
    */
    
// ABS Label 136
if(pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
if( pDflt ){
      sqlite3_value *pVal = 0;
      int rc;
      rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);
      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );
      
// ABS Label 138
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// ROR Label 139
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
if( rc!=SQLITE_OK ){
        assert( db->mallocFailed == 1 );
        return;
      }
      if( !pVal ){
        
// ABS Label 140
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ABS Label 141
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ABS Label 142
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,
           "Cannot add a column with non-constant default");
      }
      
// ABS Label 137
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
sqlite3ValueFree(pVal);
    }
  }else { 
// AOR Label 143
if(pCol->colFlags | 64 != pCol->colFlags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 143);
}
// AOR Label 144
if(pCol->colFlags ^ 64 != pCol->colFlags & 64)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 144);
}
if( pCol->colFlags & COLFLAG_STORED ){
    
// ABS Label 145
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}

// ABS Label 146
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ABS Label 147
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "cannot add a STORED column");
  };}



  /* Modify the CREATE TABLE statement. */
  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);
  
// ABS Label 148
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}
if( zCol ){
    char *zEnd = &zCol[pColDef->n-1];
    
// ABS Label 149
if(db->mDbFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
u32 savedDbFlags = db->mDbFlags;
    
// ABS Label 157
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
// ABS Label 158
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// COR Label 159
if((zEnd > zCol || (*zEnd == ';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1))) != (zEnd > zCol && (*zEnd == ';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 159);
}

// ROR Label 160
if((zEnd <= zCol) != (zEnd > zCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((zEnd < zCol) != (zEnd > zCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((zEnd >= zCol) != (zEnd > zCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}

// MCC Label 163
if(zEnd > zCol && ( *zEnd == ';' && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 163);
}
// MCC Label 164
if(zEnd > zCol && ( *zEnd == ';' && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(zEnd > zCol && ( !(*zEnd == ';') && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
// MCC Label 166
if(zEnd > zCol && ( !(*zEnd == ';') && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(!(zEnd > zCol) && ( *zEnd == ';' && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
// MCC Label 168
if(!(zEnd > zCol) && ( *zEnd == ';' && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
// MCC Label 169
if(!(zEnd > zCol) && ( !(*zEnd == ';') && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
// MCC Label 170
if(!(zEnd > zCol) && ( !(*zEnd == ';') && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){
      *zEnd-- = '\0';
    };
// ABS Label 171
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}
// ABS Label 172
if(zEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}

// COR Label 173
if((zEnd > zCol || (*zEnd == ';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1))) != (zEnd > zCol && (*zEnd == ';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 173);
}

// ROR Label 174
if((zEnd <= zCol) != (zEnd > zCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((zEnd < zCol) != (zEnd > zCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
// ROR Label 176
if((zEnd >= zCol) != (zEnd > zCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}

// MCC Label 177
if(zEnd > zCol && ( *zEnd == ';' && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(zEnd > zCol && ( *zEnd == ';' && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(zEnd > zCol && ( !(*zEnd == ';') && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(zEnd > zCol && ( !(*zEnd == ';') && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(!(zEnd > zCol) && ( *zEnd == ';' && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(!(zEnd > zCol) && ( *zEnd == ';' && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(!(zEnd > zCol) && ( !(*zEnd == ';') && ( sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(!(zEnd > zCol) && ( !(*zEnd == ';') && ( !(sqlite3CtypeMap[(unsigned char)(*zEnd)] & 1) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}

    db->mDbFlags |= DBFLAG_PreferBuiltin;
    /* substr() operations on characters, but addColOffset is in bytes. So we
    ** have to use printf() to translate between these units: */
    
// ABS Label 150
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ABS Label 151
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// ABS Label 152
if(pNew->addColOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// ABS Label 153
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ABS Label 154
if(pNew->addColOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}

// ABS Label 155
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}
sqlite3NestedParse(pParse, 
        "UPDATE \"%w\"." DFLT_SCHEMA_TABLE " SET "
          "sql = printf('%%.%ds, ',sql) || %Q"
          " || substr(sql,1+length(printf('%%.%ds',sql))) "
        "WHERE type = 'table' AND name = %Q", 
      zDb, pNew->addColOffset, zCol, pNew->addColOffset,
      zTab
    );
    
// ABS Label 156
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
sqlite3DbFree(db, zCol);
    db->mDbFlags = savedDbFlags;
  }

  /* Make sure the schema version is at least 3.  But do not upgrade
  ** from less than 3 to 4, as that will corrupt any preexisting DESC
  ** index.
  */
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 185
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
if( v ){
    r1 = sqlite3GetTempReg(pParse);
    
// ABS Label 186
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ABS Label 187
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}

// ABS Label 188
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}
sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);
    
// ABS Label 189
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 189);
}

// ABS Label 190
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
sqlite3VdbeUsesBtree(v, iDb);
    
// ABS Label 191
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// ABS Label 192
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
sqlite3VdbeAddOp2(v, OP_AddImm, r1, -2);
    
// ABS Label 193
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}

// ABS Label 194
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}
sqlite3VdbeAddOp2(v, OP_IfPos, r1, sqlite3VdbeCurrentAddr(v)+2);
    VdbeCoverage(v);
    
// ABS Label 195
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}

// ABS Label 196
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}
sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, 3);
    
// ABS Label 197
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}

// ABS Label 198
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
sqlite3ReleaseTempReg(pParse, r1);
  }

  /* Reload the table definition */
  
// ABS Label 92
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// ABS Label 93
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
renameReloadSchema(pParse, iDb, INITFLAG_AlterRename);
}

/*
** This function is called by the parser after the table-name in
** an "ALTER TABLE <table-name> ADD" statement is parsed. Argument 
** pSrc is the full-name of the table being altered.
**
** This routine makes a (partial) copy of the Table structure
** for the table being altered and sets Parse.pNewTable to point
** to it. Routines called by the parser as the column definition
** is parsed (i.e. sqlite3AddColumn()) add the new Column data to 
** the copy. The copy of the Table structure is deleted by tokenize.c 
** after parsing is finished.
**
** Routine sqlite3AlterFinishAddColumn() will be called to complete
** coding the "ALTER TABLE ... ADD" statement.
*/
void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){
  Table *pNew;
  Table *pTab;
  int iDb;
  int i;
  int nAlloc;
  
// ABS Label 199
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}
sqlite3 *db = pParse->db;

  /* Look up the table being altered. */
  assert( pParse->pNewTable==0 );
  assert( sqlite3BtreeHoldsAllMutexes(db) );
  
// ABS Label 204
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}
if( db->mallocFailed ) { goto exit_begin_add_column;
}
  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) { goto exit_begin_add_column;
}

#ifndef SQLITE_OMIT_VIRTUALTABLE
  
// ABS Label 205
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}
if( IsVirtual(pTab) ){
    
// ABS Label 206
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
    goto exit_begin_add_column;
  }
#endif

  /* Make sure this is not an attempt to ALTER a view. */
  
// ABS Label 207
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}
if( pTab->pSelect ){
    
// ABS Label 208
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 208);
}
sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
    goto exit_begin_add_column;
  }
  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){
    goto exit_begin_add_column;
  }

  
// ABS Label 200
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
sqlite3MayAbort(pParse);
  assert( pTab->addColOffset>0 );
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);

  /* Put a copy of the Table struct in Parse.pNewTable for the
  ** sqlite3AddColumn() function and friends to modify.  But modify
  ** the name by adding an "sqlite_altertab_" prefix.  By adding this
  ** prefix, we insure that the name will not collide with an existing
  ** table because user table are not allowed to have the "sqlite_"
  ** prefix on their name.
  */
  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));
  if( !pNew ) { goto exit_begin_add_column;
}
  pParse->pNewTable = pNew;
  pNew->nTabRef = 1;
  pNew->nCol = pTab->nCol;
  assert( pNew->nCol>0 );
  nAlloc = (((pNew->nCol-1)/8)*8)+8;
  assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 );
  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);
  pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);
  
// COR Label 209
if((!pNew->aCol && !pNew->zName) != (!pNew->aCol || !pNew->zName))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 209);
}

// MCC Label 210
if(!pNew->aCol && !pNew->zName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(!pNew->aCol && !(!pNew->zName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
// MCC Label 212
if(!(!pNew->aCol) && !pNew->zName ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 212);
}
// MCC Label 213
if(!(!pNew->aCol) && !(!pNew->zName) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
if( !pNew->aCol || !pNew->zName ){
    assert( db->mallocFailed );
    goto exit_begin_add_column;
  }
  
// AOR Label 201
if(sizeof(Column) - pNew->nCol != sizeof(Column) * pNew->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 201);
}
// AOR Label 202
if(sizeof(Column) + pNew->nCol != sizeof(Column) * pNew->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 202);
}
// AOR Label 203
if(sizeof(Column) / pNew->nCol != sizeof(Column) * pNew->nCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 203);
}
memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
  i = 0;

// ABS Label 214
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}

// ROR Label 215
if((i <= pNew->nCol) != (i < pNew->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 215);
}
// ROR Label 216
if((i > pNew->nCol) != (i < pNew->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 216);
}
// ROR Label 217
if((i >= pNew->nCol) != (i < pNew->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
for(; i<pNew->nCol; i++){
    Column *pCol = &pNew->aCol[i];
    pCol->zName = sqlite3DbStrDup(db, pCol->zName);
    pCol->hName = sqlite3StrIHash(pCol->zName);
    pCol->zColl = 0;
    pCol->pDflt = 0;
  };
// ABS Label 218
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}

// ROR Label 219
if((i <= pNew->nCol) != (i < pNew->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
// ROR Label 220
if((i > pNew->nCol) != (i < pNew->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 220);
}
// ROR Label 221
if((i >= pNew->nCol) != (i < pNew->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 221);
}

  pNew->pSchema = db->aDb[iDb].pSchema;
  pNew->addColOffset = pTab->addColOffset;
  pNew->nTabRef = 1;

exit_begin_add_column:
  sqlite3SrcListDelete(db, pSrc);
  return;
}

/*
** Parameter pTab is the subject of an ALTER TABLE ... RENAME COLUMN
** command. This function checks if the table is a view or virtual
** table (columns of views or virtual tables may not be renamed). If so,
** it loads an error message into pParse and returns non-zero.
**
** Or, if pTab is not a view or virtual table, zero is returned.
*/
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
static int isRealTable(Parse *pParse, Table *pTab, int bDrop){
  const char *zType = 0;
#ifndef SQLITE_OMIT_VIEW
  
// ABS Label 222
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}
if( pTab->pSelect ){
    zType = "view";
  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
  
// ABS Label 223
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}
if( IsVirtual(pTab) ){
    zType = "virtual table";
  }
#endif
  
// ABS Label 224
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
if( zType ){
    
// ABS Label 225
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}

// ABS Label 226
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}

// ABS Label 227
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"", 
        (bDrop ? "drop column from" : "rename columns of"),
        zType, pTab->zName
    );
    return 1;
  }
  return 0;
}
#else /* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */
# define isRealTable(x,y,z) (0)
#endif

/*
** Handles the following parser reduction:
**
**  cmd ::= ALTER TABLE pSrc RENAME COLUMN pOld TO pNew
*/
void sqlite3AlterRenameColumn(
  Parse *pParse,                  /* Parsing context */
  SrcList *pSrc,                  /* Table being altered.  pSrc->nSrc==1 */
  Token *pOld,                    /* Name of column being changed */
  Token *pNew                     /* New column name */
){
  
// ABS Label 228
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}
sqlite3 *db = pParse->db;       /* Database connection */
  Table *pTab;                    /* Table being updated */
  int iCol;                       /* Index of column being renamed */
  char *zOld = 0;                 /* Old column name */
  char *zNew = 0;                 /* New column name */
  const char *zDb;                /* Name of schema containing the table */
  int iSchema;                    /* Index of the schema */
  int bQuote;                     /* True to quote the new name */

  /* Locate the table to be altered */
  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) {goto exit_rename_column;}

  /* Cannot alter a system table */
  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) {goto exit_rename_column;}
  if( SQLITE_OK!=isRealTable(pParse, pTab, 0) ) {goto exit_rename_column;}

  /* Which schema holds the table to be altered */  
  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);
  assert( iSchema>=0 );
  zDb = db->aDb[iSchema].zDbSName;

#ifndef SQLITE_OMIT_AUTHORIZATION
  /* Invoke the authorization callback. */
  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){
    goto exit_rename_column;
  }
#endif

  /* Make sure the old name really is a column name in the table to be
  ** altered.  Set iCol to be the index of the column being renamed */
  zOld = sqlite3NameFromToken(db, pOld);
  if( !zOld ) { goto exit_rename_column;
}
  iCol = 0;

// ABS Label 262
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}

// ROR Label 263
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}
// ROR Label 264
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}
// ROR Label 265
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 265);
}
for(; iCol<pTab->nCol; iCol++){
    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zName, zOld) ) { break;
}
  };
// ABS Label 266
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}

// ROR Label 267
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}
// ROR Label 269
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 269);
}

  
// ABS Label 270
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}

// ROR Label 271
if((iCol != pTab->nCol) != (iCol == pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 271);
}
if( iCol==pTab->nCol ){
    
// ABS Label 272
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}

// ABS Label 273
if(zOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}
sqlite3ErrorMsg(pParse, "no such column: \"%s\"", zOld);
    goto exit_rename_column;
  }

  /* Ensure the schema contains no double-quoted strings */
  
// ABS Label 229
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}

// ABS Label 230
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}

// ABS Label 231
if(iSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ROR Label 232
if((iSchema != 1) != (iSchema == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
renameTestSchema(pParse, zDb, iSchema==1, "", 0);
  
// ABS Label 233
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}

// ABS Label 234
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}

// ABS Label 235
if(iSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}

// ROR Label 236
if((iSchema != 1) != (iSchema == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
renameFixQuotes(pParse, zDb, iSchema==1);

  /* Do the rename operation using a recursive UPDATE statement that
  ** uses the sqlite_rename_column() SQL function to compute the new
  ** CREATE statement text for the sqlite_schema table.
  */
  
// ABS Label 237
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}
sqlite3MayAbort(pParse);
  zNew = sqlite3NameFromToken(db, pNew);
  if( !zNew ) { goto exit_rename_column;
}
  assert( pNew->n>0 );
  bQuote = sqlite3Isquote(pNew->z[0]);
  
// ABS Label 238
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}

// ABS Label 239
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// ABS Label 240
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ABS Label 241
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}

// ABS Label 242
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 242);
}

// ABS Label 243
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}

// ABS Label 244
if(bQuote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ABS Label 245
if(iSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}

// ROR Label 246
if((iSchema != 1) != (iSchema == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}

// ABS Label 247
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
sqlite3NestedParse(pParse, 
      "UPDATE \"%w\"." DFLT_SCHEMA_TABLE " SET "
      "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) "
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' "
      " AND (type != 'index' OR tbl_name = %Q)"
      " AND sql NOT LIKE 'create virtual%%'",
      zDb,
      zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,
      pTab->zName
  );

  
// ABS Label 248
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}

// ABS Label 249
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}

// ABS Label 250
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

// ABS Label 251
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ABS Label 252
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 252);
}

// ABS Label 253
if(bQuote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}
sqlite3NestedParse(pParse, 
      "UPDATE temp." DFLT_SCHEMA_TABLE " SET "
      "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) "
      "WHERE type IN ('trigger', 'view')",
      zDb, pTab->zName, iCol, zNew, bQuote
  );

  /* Drop and reload the database schema. */
  
// ABS Label 254
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}

// ABS Label 255
if(iSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}
renameReloadSchema(pParse, iSchema, INITFLAG_AlterRename);
  
// ABS Label 256
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ABS Label 257
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}

// ABS Label 258
if(iSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// ROR Label 259
if((iSchema != 1) != (iSchema == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}
renameTestSchema(pParse, zDb, iSchema==1, "after rename", 1);

 exit_rename_column:
  sqlite3SrcListDelete(db, pSrc);
  
// ABS Label 260
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
sqlite3DbFree(db, zOld);
  
// ABS Label 261
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}
sqlite3DbFree(db, zNew);
  return;
}

/*
** Each RenameToken object maps an element of the parse tree into
** the token that generated that element.  The parse tree element
** might be one of:
**
**     *  A pointer to an Expr that represents an ID
**     *  The name of a table column in Column.zName
**
** A list of RenameToken objects can be constructed during parsing.
** Each new object is created by sqlite3RenameTokenMap().
** As the parse tree is transformed, the sqlite3RenameTokenRemap()
** routine is used to keep the mapping current.
**
** After the parse finishes, renameTokenFind() routine can be used
** to look up the actual token value that created some element in
** the parse tree.
*/
struct RenameToken {
  void *p;               /* Parse tree element created by token t */
  Token t;               /* The token that created parse tree element p */
  RenameToken *pNext;    /* Next is a list of all RenameToken objects */
};

/*
** The context of an ALTER TABLE RENAME COLUMN operation that gets passed
** down into the Walker.
*/
typedef struct RenameCtx RenameCtx;
struct RenameCtx {
  RenameToken *pList;             /* List of tokens to overwrite */
  int nList;                      /* Number of tokens in pList */
  int iCol;                       /* Index of column being renamed */
  Table *pTab;                    /* Table being ALTERed */ 
  const char *zOld;               /* Old column name */
};

#ifdef SQLITE_DEBUG
/*
** This function is only for debugging. It performs two tasks:
**
**   1. Checks that pointer pPtr does not already appear in the 
**      rename-token list.
**
**   2. Dereferences each pointer in the rename-token list.
**
** The second is most effective when debugging under valgrind or
** address-sanitizer or similar. If any of these pointers no longer 
** point to valid objects, an exception is raised by the memory-checking 
** tool.
**
** The point of this is to prevent comparisons of invalid pointer values.
** Even though this always seems to work, it is undefined according to the
** C standard. Example of undefined comparison:
**
**     sqlite3_free(x);
**     if( x==y ) ...
**
** Technically, as x no longer points into a valid object or to the byte
** following a valid object, it may not be used in comparison operations.
*/
static void renameTokenCheckAll(Parse *pParse, void *pPtr){
  if( pParse->nErr==0 && pParse->db->mallocFailed==0 ){
    RenameToken *p;
    u8 i = 0;
    for(p=pParse->pRename; p; p=p->pNext){
      if( p->p ){
        assert( p->p!=pPtr );
        i += *(u8*)(p->p);
      }
    }
  }
}
#else
# define renameTokenCheckAll(x,y)
#endif

/*
** Remember that the parser tree element pPtr was created using
** the token pToken.
**
** In other words, construct a new RenameToken object and add it
** to the list of RenameToken objects currently being built up
** in pParse->pRename.
**
** The pPtr argument is returned so that this routine can be used
** with tail recursion in tokenExpr() routine, for a small performance
** improvement.
*/
void *sqlite3RenameTokenMap(Parse *pParse, void *pPtr, Token *pToken){
  RenameToken *pNew;
  assert( pPtr || pParse->db->mallocFailed );
  renameTokenCheckAll(pParse, pPtr);
  
// MCC Label 274
if(( pParse->eParseMode != 3 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 274);
}
// MCC Label 275
if(( !(pParse->eParseMode != 3) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 275);
}
if( ALWAYS(pParse->eParseMode!=PARSE_MODE_UNMAP) ){
    pNew = sqlite3DbMallocZero(pParse->db, sizeof(RenameToken));
    
// ABS Label 276
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
if( pNew ){
      pNew->p = pPtr;
      pNew->t = *pToken;
      pNew->pNext = pParse->pRename;
      pParse->pRename = pNew;
    }
  }

  
// ABS Label 277
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
return pPtr;
}

/*
** It is assumed that there is already a RenameToken object associated
** with parse tree element pFrom. This function remaps the associated token
** to parse tree element pTo.
*/
void sqlite3RenameTokenRemap(Parse *pParse, void *pTo, void *pFrom){
  RenameToken *p;
  renameTokenCheckAll(pParse, pTo);
  p = pParse->pRename;

// ABS Label 278
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}
for(; p; p=p->pNext){
    
// ABS Label 280
if(p->p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
// ABS Label 281
if(pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// ROR Label 282
if((p->p != pFrom) != (p->p == pFrom))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
if( p->p==pFrom ){
      p->p = pTo;
      break;
    }
  };
// ABS Label 279
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}

}

/*
** Walker callback used by sqlite3RenameExprUnmap().
*/
static int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 283
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}
Parse *pParse = pWalker->pParse;
  
// ABS Label 284
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
  return WRC_Continue;
}

/*
** Iterate through the Select objects that are part of WITH clauses attached
** to select statement pSelect.
*/
static void renameWalkWith(Walker *pWalker, Select *pSelect){
  
// ABS Label 285
if(pSelect->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
With *pWith = pSelect->pWith;
  
// ABS Label 286
if(pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}
if( pWith ){
    
// ABS Label 287
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
Parse *pParse = pWalker->pParse;
    int i;
    With *pCopy = 0;
    assert( pWith->nCte>0 );
    
// ROR Label 288
if(((pWith->a[0].pSelect->selFlags & 64) != 0) != ((pWith->a[0].pSelect->selFlags & 64) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
if( (pWith->a[0].pSelect->selFlags & SF_Expanded)==0 ){
      /* Push a copy of the With object onto the with-stack. We use a copy
      ** here as the original will be expanded and resolved (flags SF_Expanded
      ** and SF_Resolved) below. And the parser code that uses the with-stack
      ** fails if the Select objects on it have already been expanded and
      ** resolved.  */
      pCopy = sqlite3WithDup(pParse->db, pWith);
      pCopy = sqlite3WithPush(pParse, pCopy, 1);
    }
    i = 0;

// ABS Label 289
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}
// ABS Label 290
if(pWith->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ROR Label 291
if((i <= pWith->nCte) != (i < pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 291);
}
// ROR Label 292
if((i > pWith->nCte) != (i < pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}
// ROR Label 293
if((i >= pWith->nCte) != (i < pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 293);
}
for(; i<pWith->nCte; i++){
      
// ABS Label 299
if(pWith->a[i].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
Select *p = pWith->a[i].pSelect;
      NameContext sNC;
      memset(&sNC, 0, sizeof(sNC));
      sNC.pParse = pParse;
      
// ABS Label 304
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
if( pCopy ) { 
// ABS Label 305
if(sNC.pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}

// ABS Label 306
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
sqlite3SelectPrep(sNC.pParse, p, &sNC);
}
      
// ABS Label 300
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}

// ABS Label 301
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}
sqlite3WalkSelect(pWalker, p);
      
// ABS Label 302
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}

// ABS Label 303
if(pWith->a[i].pCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
sqlite3RenameExprlistUnmap(pParse, pWith->a[i].pCols);
    };
// ABS Label 294
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
// ABS Label 295
if(pWith->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ROR Label 296
if((i <= pWith->nCte) != (i < pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
// ROR Label 297
if((i > pWith->nCte) != (i < pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}
// ROR Label 298
if((i >= pWith->nCte) != (i < pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}

    
// ABS Label 307
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
// ABS Label 308
if(pParse->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// COR Label 309
if((pCopy || pParse->pWith == pCopy) != (pCopy && pParse->pWith == pCopy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 309);
}

// ROR Label 310
if((pParse->pWith != pCopy) != (pParse->pWith == pCopy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}

// MCC Label 311
if(pCopy && pParse->pWith == pCopy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 311);
}
// MCC Label 312
if(pCopy && !(pParse->pWith == pCopy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 312);
}
// MCC Label 313
if(!(pCopy) && pParse->pWith == pCopy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 313);
}
// MCC Label 314
if(!(pCopy) && !(pParse->pWith == pCopy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 314);
}
if( pCopy && pParse->pWith==pCopy ){
      pParse->pWith = pCopy->pOuter;
    }
  }
}

/*
** Unmap all tokens in the IdList object passed as the second argument.
*/
static void unmapColumnIdlistNames(
  Parse *pParse,
  IdList *pIdList
){
  
// ABS Label 315
if(pIdList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
if( pIdList ){
    int ii;
    ii = 0;

// ABS Label 316
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
// ABS Label 317
if(pIdList->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}

// ROR Label 318
if((ii <= pIdList->nId) != (ii < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
// ROR Label 319
if((ii > pIdList->nId) != (ii < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 319);
}
// ROR Label 320
if((ii >= pIdList->nId) != (ii < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 320);
}
for(; ii<pIdList->nId; ii++){
      
// ABS Label 326
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)pIdList->a[ii].zName);
    };
// ABS Label 321
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
// ABS Label 322
if(pIdList->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}

// ROR Label 323
if((ii <= pIdList->nId) != (ii < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 323);
}
// ROR Label 324
if((ii > pIdList->nId) != (ii < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 324);
}
// ROR Label 325
if((ii >= pIdList->nId) != (ii < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}

  }
}

/*
** Walker callback used by sqlite3RenameExprUnmap().
*/
static int renameUnmapSelectCb(Walker *pWalker, Select *p){
  
// ABS Label 327
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
Parse *pParse = pWalker->pParse;
  int i;
  
// ABS Label 330
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
if( pParse->nErr ) { return WRC_Abort;
}
  
// ABS Label 331
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}

// AOR Label 332
if(p->selFlags | (2097152 | 67108864) != p->selFlags & (2097152 | 67108864))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 332);
}
// AOR Label 333
if(p->selFlags ^ (2097152 | 67108864) != p->selFlags & (2097152 | 67108864))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 333);
}
if( p->selFlags & (SF_View|SF_CopyCte) ){
    testcase( p->selFlags & SF_View );
    testcase( p->selFlags & SF_CopyCte );
    return WRC_Prune;
  }
  
// ABS Label 334
if((p->pEList) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
if( ALWAYS(p->pEList) ){
    
// ABS Label 335
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
ExprList *pList = p->pEList;
    i = 0;

// ABS Label 336
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}
// ABS Label 337
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}

// ROR Label 338
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}
// ROR Label 339
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}
// ROR Label 340
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 340);
}
for(; i<pList->nExpr; i++){
      
// ABS Label 346
if(pList->a[i].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}

// COR Label 347
if((pList->a[i].zEName || pList->a[i].eEName == 0) != (pList->a[i].zEName && pList->a[i].eEName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 347);
}

// ROR Label 348
if((pList->a[i].eEName != 0) != (pList->a[i].eEName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 348);
}

// MCC Label 349
if(pList->a[i].zEName && pList->a[i].eEName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
// MCC Label 350
if(pList->a[i].zEName && !(pList->a[i].eEName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
// MCC Label 351
if(!(pList->a[i].zEName) && pList->a[i].eEName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
// MCC Label 352
if(!(pList->a[i].zEName) && !(pList->a[i].eEName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 352);
}
if( pList->a[i].zEName && pList->a[i].eEName==ENAME_NAME ){
        
// ABS Label 353
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zEName);
      }
    };
// ABS Label 341
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
// ABS Label 342
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// ROR Label 343
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 343);
}
// ROR Label 344
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
// ROR Label 345
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 345);
}

  }
  
// ABS Label 354
if((p->pSrc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
if( ALWAYS(p->pSrc) ){  /* Every Select as a SrcList, even if it is empty */
    
// ABS Label 355
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
SrcList *pSrc = p->pSrc;
    i = 0;

// ABS Label 356
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}
// ABS Label 357
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}

// ROR Label 358
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}
// ROR Label 359
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}
// ROR Label 360
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 360);
}
for(; i<pSrc->nSrc; i++){
      
// ABS Label 366
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);
      if( sqlite3WalkExpr(pWalker, pSrc->a[i].pOn) ) { return WRC_Abort;
}
      
// ABS Label 367
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}

// ABS Label 368
if(pSrc->a[i].pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}
unmapColumnIdlistNames(pParse, pSrc->a[i].pUsing);
    };
// ABS Label 361
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}
// ABS Label 362
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}

// ROR Label 363
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}
// ROR Label 364
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}
// ROR Label 365
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 365);
}

  }

  
// ABS Label 328
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

// ABS Label 329
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
renameWalkWith(pWalker, p);
  return WRC_Continue;
}

/*
** Remove all nodes that are part of expression pExpr from the rename list.
*/
void sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){
  
// ABS Label 369
if(pParse->eParseMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
u8 eMode = pParse->eParseMode;
  Walker sWalker;
  memset(&sWalker, 0, sizeof(Walker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = renameUnmapExprCb;
  sWalker.xSelectCallback = renameUnmapSelectCb;
  pParse->eParseMode = PARSE_MODE_UNMAP;
  
// ABS Label 370
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 370);
}
sqlite3WalkExpr(&sWalker, pExpr);
  pParse->eParseMode = eMode;
}

/*
** Remove all nodes that are part of expression-list pEList from the 
** rename list.
*/
void sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){
  
// ABS Label 371
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}
if( pEList ){
    int i;
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.pParse = pParse;
    sWalker.xExprCallback = renameUnmapExprCb;
    
// ABS Label 372
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
sqlite3WalkExprList(&sWalker, pEList);
    i = 0;

// ABS Label 373
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}
// ABS Label 374
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}

// ROR Label 375
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
// ROR Label 376
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
for(; i<pEList->nExpr; i++){
      
// MCC Label 383
if(( pEList->a[i].eEName == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(( !(pEList->a[i].eEName == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
if( ALWAYS(pEList->a[i].eEName==ENAME_NAME) ){
        
// ABS Label 385
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zEName);
      }
    };
// ABS Label 378
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 378);
}
// ABS Label 379
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// ROR Label 380
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 380);
}
// ROR Label 381
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 381);
}
// ROR Label 382
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 382);
}

  }
}

/*
** Free the list of RenameToken objects given in the second argument
*/
static void renameTokenFree(sqlite3 *db, RenameToken *pToken){
  RenameToken *pNext;
  RenameToken *p;
  p = pToken;

// ABS Label 386
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
for(; p; p=pNext){
    pNext = p->pNext;
    
// ABS Label 388
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
sqlite3DbFree(db, p);
  };
// ABS Label 387
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

}

/*
** Search the Parse object passed as the first argument for a RenameToken
** object associated with parse tree element pPtr. If found, return a pointer
** to it. Otherwise, return NULL.
**
** If the second argument passed to this function is not NULL and a matching
** RenameToken object is found, remove it from the Parse object and add it to
** the list maintained by the RenameCtx object.
*/
static RenameToken *renameTokenFind(
  Parse *pParse, 
  struct RenameCtx *pCtx, 
  void *pPtr
){
  RenameToken **pp;
  
// MCC Label 389
if(( pPtr == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 389);
}
// MCC Label 390
if(( !(pPtr == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 390);
}
if( NEVER(pPtr==0) ){
    return 0;
  }
  pp = &pParse->pRename;

// ABS Label 391
if((*pp) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}
for(; (*pp); pp=&(*pp)->pNext){
    
// ABS Label 393
if((*pp)->p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}
// ABS Label 394
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}

// ROR Label 395
if(((*pp)->p != pPtr) != ((*pp)->p == pPtr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 395);
}
if( (*pp)->p==pPtr ){
      
// ABS Label 396
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}
RenameToken *pToken = *pp;
      
// ABS Label 397
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
if( pCtx ){
        *pp = pToken->pNext;
        pToken->pNext = pCtx->pList;
        pCtx->pList = pToken;
        pCtx->nList++;
      }
      
// ABS Label 398
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}
return pToken;
    }
  };
// ABS Label 392
if((*pp) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

  return 0;
}

/*
** This is a Walker select callback. It does nothing. It is only required
** because without a dummy callback, sqlite3WalkExpr() and similar do not
** descend into sub-select statements.
*/
static int renameColumnSelectCb(Walker *pWalker, Select *p){
  
// ABS Label 401
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}

// AOR Label 402
if(p->selFlags | (2097152 | 67108864) != p->selFlags & (2097152 | 67108864))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 402);
}
// AOR Label 403
if(p->selFlags ^ (2097152 | 67108864) != p->selFlags & (2097152 | 67108864))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 403);
}
if( p->selFlags & (SF_View|SF_CopyCte) ){
    testcase( p->selFlags & SF_View );
    testcase( p->selFlags & SF_CopyCte );
    return WRC_Prune;
  }
  
// ABS Label 399
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}

// ABS Label 400
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
renameWalkWith(pWalker, p);
  return WRC_Continue;
}

/*
** This is a Walker expression callback.
**
** For every TK_COLUMN node in the expression tree, search to see
** if the column being references is the column being renamed by an
** ALTER TABLE statement.  If it is, then attach its associated
** RenameToken object to the list of RenameToken objects being
** constructed in RenameCtx object at pWalker->u.pRename.
*/
static int renameColumnExprCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 404
if(pWalker->u.pRename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}
RenameCtx *p = pWalker->u.pRename;
  
// ABS Label 405
if(p->iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}
// ABS Label 406
if(p->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
// ABS Label 407
if(pWalker->pParse->pTriggerTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// COR Label 408
if((pExpr->op == 77 && pExpr->iColumn == p->iCol || pWalker->pParse->pTriggerTab == p->pTab) != (pExpr->op == 77 && pExpr->iColumn == p->iCol && pWalker->pParse->pTriggerTab == p->pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 408);
}
// COR Label 409
if((pExpr->op == 77 || pExpr->iColumn == p->iCol) != (pExpr->op == 77 && pExpr->iColumn == p->iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 409);
}

// ROR Label 410
if((pExpr->op != 77) != (pExpr->op == 77))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
// ROR Label 411
if((pExpr->iColumn != p->iCol) != (pExpr->iColumn == p->iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 411);
}
// ROR Label 412
if((pWalker->pParse->pTriggerTab != p->pTab) != (pWalker->pParse->pTriggerTab == p->pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 412);
}

// MCC Label 413
if(pExpr->op == 77 && pExpr->iColumn == p->iCol && pWalker->pParse->pTriggerTab == p->pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 413);
}
// MCC Label 414
if(pExpr->op == 77 && pExpr->iColumn == p->iCol && !(pWalker->pParse->pTriggerTab == p->pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 414);
}
// MCC Label 415
if(pExpr->op == 77 && !(pExpr->iColumn == p->iCol) && pWalker->pParse->pTriggerTab == p->pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 415);
}
// MCC Label 416
if(pExpr->op == 77 && !(pExpr->iColumn == p->iCol) && !(pWalker->pParse->pTriggerTab == p->pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 416);
}
// MCC Label 417
if(!(pExpr->op == 77) && pExpr->iColumn == p->iCol && pWalker->pParse->pTriggerTab == p->pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 417);
}
// MCC Label 418
if(!(pExpr->op == 77) && pExpr->iColumn == p->iCol && !(pWalker->pParse->pTriggerTab == p->pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 418);
}
// MCC Label 419
if(!(pExpr->op == 77) && !(pExpr->iColumn == p->iCol) && pWalker->pParse->pTriggerTab == p->pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 419);
}
// MCC Label 420
if(!(pExpr->op == 77) && !(pExpr->iColumn == p->iCol) && !(pWalker->pParse->pTriggerTab == p->pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 420);
}
if( pExpr->op==TK_TRIGGER 
   && pExpr->iColumn==p->iCol 
   && pWalker->pParse->pTriggerTab==p->pTab
  ){
    
// ABS Label 421
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}

// ABS Label 422
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}
renameTokenFind(pWalker->pParse, p, (void*)pExpr);
  }else { 
// ABS Label 423
if(p->iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}
// ABS Label 424
if(p->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}
// ABS Label 425
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}

// COR Label 426
if((pExpr->op == 166 && pExpr->iColumn == p->iCol || p->pTab == pExpr->y.pTab) != (pExpr->op == 166 && pExpr->iColumn == p->iCol && p->pTab == pExpr->y.pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 426);
}
// COR Label 427
if((pExpr->op == 166 || pExpr->iColumn == p->iCol) != (pExpr->op == 166 && pExpr->iColumn == p->iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 427);
}

// ROR Label 428
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 428);
}
// ROR Label 429
if((pExpr->iColumn != p->iCol) != (pExpr->iColumn == p->iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 429);
}
// ROR Label 430
if((p->pTab != pExpr->y.pTab) != (p->pTab == pExpr->y.pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}

// MCC Label 431
if(pExpr->op == 166 && pExpr->iColumn == p->iCol && p->pTab == pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 431);
}
// MCC Label 432
if(pExpr->op == 166 && pExpr->iColumn == p->iCol && !(p->pTab == pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 432);
}
// MCC Label 433
if(pExpr->op == 166 && !(pExpr->iColumn == p->iCol) && p->pTab == pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 433);
}
// MCC Label 434
if(pExpr->op == 166 && !(pExpr->iColumn == p->iCol) && !(p->pTab == pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 434);
}
// MCC Label 435
if(!(pExpr->op == 166) && pExpr->iColumn == p->iCol && p->pTab == pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 435);
}
// MCC Label 436
if(!(pExpr->op == 166) && pExpr->iColumn == p->iCol && !(p->pTab == pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 436);
}
// MCC Label 437
if(!(pExpr->op == 166) && !(pExpr->iColumn == p->iCol) && p->pTab == pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 437);
}
// MCC Label 438
if(!(pExpr->op == 166) && !(pExpr->iColumn == p->iCol) && !(p->pTab == pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 438);
}
if( pExpr->op==TK_COLUMN 
   && pExpr->iColumn==p->iCol 
   && p->pTab==pExpr->y.pTab
  ){
    
// ABS Label 439
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 439);
}

// ABS Label 440
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 440);
}
renameTokenFind(pWalker->pParse, p, (void*)pExpr);
  };}

  return WRC_Continue;
}

/*
** The RenameCtx contains a list of tokens that reference a column that
** is being renamed by an ALTER TABLE statement.  Return the "last"
** RenameToken in the RenameCtx and remove that RenameToken from the
** RenameContext.  "Last" means the last RenameToken encountered when
** the input SQL is parsed from left to right.  Repeated calls to this routine
** return all column name tokens in the order that they are encountered
** in the SQL statement.
*/
static RenameToken *renameColumnTokenNext(RenameCtx *pCtx){
  
// ABS Label 441
if(pCtx->pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 441);
}
RenameToken *pBest = pCtx->pList;
  RenameToken *pToken;
  RenameToken **pp;

  pToken = pBest->pNext;

// ABS Label 442
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}
for(; pToken; pToken=pToken->pNext){
    
// ABS Label 444
if(pBest->t.z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
// ABS Label 445
if(pToken->t.z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// ROR Label 446
if((pToken->t.z <= pBest->t.z) != (pToken->t.z > pBest->t.z))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 446);
}
// ROR Label 447
if((pToken->t.z < pBest->t.z) != (pToken->t.z > pBest->t.z))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((pToken->t.z >= pBest->t.z) != (pToken->t.z > pBest->t.z))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
if( pToken->t.z>pBest->t.z ) { pBest = pToken;
}
  };
// ABS Label 443
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}

  pp = &pCtx->pList;

// ABS Label 449
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}
// ABS Label 450
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}

// ROR Label 451
if((*pp == pBest) != (*pp != pBest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
for(; *pp!=pBest; pp=&(*pp)->pNext) {;
};
// ABS Label 452
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}
// ABS Label 453
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}

// ROR Label 454
if((*pp == pBest) != (*pp != pBest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 454);
}

  *pp = pBest->pNext;

  
// ABS Label 455
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}
return pBest;
}

/*
** An error occured while parsing or otherwise processing a database
** object (either pParse->pNewTable, pNewIndex or pNewTrigger) as part of an
** ALTER TABLE RENAME COLUMN program. The error message emitted by the
** sub-routine is currently stored in pParse->zErrMsg. This function
** adds context to the error message and then stores it in pCtx.
*/
static void renameColumnParseError(
  sqlite3_context *pCtx, 
  const char *zWhen,
  sqlite3_value *pType,
  sqlite3_value *pObject,
  Parse *pParse
){
  const char *zT = (const char*)sqlite3_value_text(pType);
  const char *zN = (const char*)sqlite3_value_text(pObject);
  char *zErr;

  zErr = sqlite3_mprintf("error in %s %s%s%s: %s", 
      zT, zN, (zWhen[0] ? " " : ""), zWhen,
      pParse->zErrMsg
  );
  
// ABS Label 456
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}
sqlite3_result_error(pCtx, zErr, -1);
  sqlite3_free(zErr);
}

/*
** For each name in the the expression-list pEList (i.e. each
** pEList->a[i].zName) that matches the string in zOld, extract the 
** corresponding rename-token from Parse object pParse and add it
** to the RenameCtx pCtx.
*/
static void renameColumnElistNames(
  Parse *pParse, 
  RenameCtx *pCtx, 
  ExprList *pEList, 
  const char *zOld
){
  
// ABS Label 457
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
if( pEList ){
    int i;
    i = 0;

// ABS Label 458
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
// ABS Label 459
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// ROR Label 460
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}
// ROR Label 461
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}
// ROR Label 462
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
for(; i<pEList->nExpr; i++){
      
// ABS Label 468
if(pEList->a[i].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 468);
}
char *zName = pEList->a[i].zEName;
      if( ALWAYS(pEList->a[i].eEName==ENAME_NAME)
       && ALWAYS(zName!=0)
       && 0==sqlite3_stricmp(zName, zOld)
      ){
        
// ABS Label 469
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 469);
}

// ABS Label 470
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}
renameTokenFind(pParse, pCtx, (void*)zName);
      }
    };
// ABS Label 463
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}
// ABS Label 464
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 464);
}

// ROR Label 465
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 465);
}
// ROR Label 466
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 466);
}
// ROR Label 467
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 467);
}

  }
}

/*
** For each name in the the id-list pIdList (i.e. each pIdList->a[i].zName) 
** that matches the string in zOld, extract the corresponding rename-token 
** from Parse object pParse and add it to the RenameCtx pCtx.
*/
static void renameColumnIdlistNames(
  Parse *pParse, 
  RenameCtx *pCtx, 
  IdList *pIdList, 
  const char *zOld
){
  
// ABS Label 471
if(pIdList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}
if( pIdList ){
    int i;
    i = 0;

// ABS Label 472
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}
// ABS Label 473
if(pIdList->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}

// ROR Label 474
if((i <= pIdList->nId) != (i < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 474);
}
// ROR Label 475
if((i > pIdList->nId) != (i < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 475);
}
// ROR Label 476
if((i >= pIdList->nId) != (i < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 476);
}
for(; i<pIdList->nId; i++){
      
// ABS Label 482
if(pIdList->a[i].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}
char *zName = pIdList->a[i].zName;
      if( 0==sqlite3_stricmp(zName, zOld) ){
        
// ABS Label 483
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}

// ABS Label 484
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}
renameTokenFind(pParse, pCtx, (void*)zName);
      }
    };
// ABS Label 477
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}
// ABS Label 478
if(pIdList->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}

// ROR Label 479
if((i <= pIdList->nId) != (i < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 479);
}
// ROR Label 480
if((i > pIdList->nId) != (i < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
// ROR Label 481
if((i >= pIdList->nId) != (i < pIdList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 481);
}

  }
}


/*
** Parse the SQL statement zSql using Parse object (*p). The Parse object
** is initialized by this function before it is used.
*/
static int renameParseSql(
  Parse *p,                       /* Memory to use for Parse object */
  const char *zDb,                /* Name of schema SQL belongs to */
  sqlite3 *db,                    /* Database handle */
  const char *zSql,               /* SQL to parse */
  int bTemp                       /* True if SQL is from temp schema */
){
  int rc;
  char *zErr = 0;

  db->init.iDb = bTemp ? 1 : sqlite3FindDbName(db, zDb);

  /* Parse the SQL statement passed as the first argument. If no error
  ** occurs and the parse does not result in a new table, index or
  ** trigger object, the database must be corrupt. */
  memset(p, 0, sizeof(Parse));
  p->eParseMode = PARSE_MODE_RENAME;
  p->db = db;
  p->nQueryLoop = 1;
  rc = zSql ? sqlite3RunParser(p, zSql, &zErr) : SQLITE_NOMEM;
  assert( p->zErrMsg==0 );
  assert( rc!=SQLITE_OK || zErr==0 );
  p->zErrMsg = zErr;
  
// ABS Label 485
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}
if( db->mallocFailed ) { rc = SQLITE_NOMEM;
}
  
// ABS Label 486
if(p->pNewIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
// ABS Label 487
if(p->pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
// ABS Label 488
if(p->pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
// ABS Label 489
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}

// COR Label 490
if((rc == 0 && p->pNewTable == 0 && p->pNewIndex == 0 || p->pNewTrigger == 0) != (rc == 0 && p->pNewTable == 0 && p->pNewIndex == 0 && p->pNewTrigger == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 490);
}
// COR Label 491
if((rc == 0 && p->pNewTable == 0 || p->pNewIndex == 0) != (rc == 0 && p->pNewTable == 0 && p->pNewIndex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 491);
}
// COR Label 492
if((rc == 0 || p->pNewTable == 0) != (rc == 0 && p->pNewTable == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 492);
}

// ROR Label 493
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}
// ROR Label 494
if((p->pNewTable != 0) != (p->pNewTable == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
// ROR Label 495
if((p->pNewIndex != 0) != (p->pNewIndex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}
// ROR Label 496
if((p->pNewTrigger != 0) != (p->pNewTrigger == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 496);
}

// MCC Label 497
if(rc == 0 && p->pNewTable == 0 && p->pNewIndex == 0 && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
// MCC Label 498
if(rc == 0 && p->pNewTable == 0 && p->pNewIndex == 0 && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 498);
}
// MCC Label 499
if(rc == 0 && p->pNewTable == 0 && !(p->pNewIndex == 0) && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
// MCC Label 500
if(rc == 0 && p->pNewTable == 0 && !(p->pNewIndex == 0) && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(rc == 0 && !(p->pNewTable == 0) && p->pNewIndex == 0 && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(rc == 0 && !(p->pNewTable == 0) && p->pNewIndex == 0 && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(rc == 0 && !(p->pNewTable == 0) && !(p->pNewIndex == 0) && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
// MCC Label 504
if(rc == 0 && !(p->pNewTable == 0) && !(p->pNewIndex == 0) && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
// MCC Label 505
if(!(rc == 0) && p->pNewTable == 0 && p->pNewIndex == 0 && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(!(rc == 0) && p->pNewTable == 0 && p->pNewIndex == 0 && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(!(rc == 0) && p->pNewTable == 0 && !(p->pNewIndex == 0) && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(!(rc == 0) && p->pNewTable == 0 && !(p->pNewIndex == 0) && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(!(rc == 0) && !(p->pNewTable == 0) && p->pNewIndex == 0 && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}
// MCC Label 510
if(!(rc == 0) && !(p->pNewTable == 0) && p->pNewIndex == 0 && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 510);
}
// MCC Label 511
if(!(rc == 0) && !(p->pNewTable == 0) && !(p->pNewIndex == 0) && p->pNewTrigger == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 511);
}
// MCC Label 512
if(!(rc == 0) && !(p->pNewTable == 0) && !(p->pNewIndex == 0) && !(p->pNewTrigger == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 512);
}
if( rc==SQLITE_OK 
   && p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0 
  ){
    rc = SQLITE_CORRUPT_BKPT;
  }

#ifdef SQLITE_DEBUG
  /* Ensure that all mappings in the Parse.pRename list really do map to
  ** a part of the input string.  */
  if( rc==SQLITE_OK ){
    int nSql = sqlite3Strlen30(zSql);
    RenameToken *pToken;
    for(pToken=p->pRename; pToken; pToken=pToken->pNext){
      assert( pToken->t.z>=zSql && &pToken->t.z[pToken->t.n]<=&zSql[nSql] );
    }
  }
#endif

  db->init.iDb = 0;
  
// ABS Label 513
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}
return rc;
}

/*
** This function edits SQL statement zSql, replacing each token identified
** by the linked list pRename with the text of zNew. If argument bQuote is
** true, then zNew is always quoted first. If no error occurs, the result
** is loaded into context object pCtx as the result.
**
** Or, if an error occurs (i.e. an OOM condition), an error is left in
** pCtx and an SQLite error code returned.
*/
static int renameEditSql(
  sqlite3_context *pCtx,          /* Return result here */
  RenameCtx *pRename,             /* Rename context */
  const char *zSql,               /* SQL statement to edit */
  const char *zNew,               /* New token text */
  int bQuote                      /* True to always quote token */
){
  i64 nNew = sqlite3Strlen30(zNew);
  i64 nSql = sqlite3Strlen30(zSql);
  sqlite3 *db = sqlite3_context_db_handle(pCtx);
  int rc = SQLITE_OK;
  char *zQuot = 0;
  char *zOut;
  i64 nQuot = 0;
  char *zBuf1 = 0;
  char *zBuf2 = 0;

  
// ABS Label 514
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}
if( zNew ){
    /* Set zQuot to point to a buffer containing a quoted copy of the 
    ** identifier zNew. If the corresponding identifier in the original 
    ** ALTER TABLE statement was quoted (bQuote==1), then set zNew to
    ** point to zQuot so that all substitutions are made using the
    ** quoted version of the new column name.  */
    zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);
    
// ABS Label 515
if(zQuot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}

// ROR Label 516
if((zQuot != 0) != (zQuot == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 516);
}
if( zQuot==0 ){
      return SQLITE_NOMEM;
    }else{
      nQuot = sqlite3Strlen30(zQuot)-1;
    }

    assert( nQuot>=nNew );
    zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);
  }else{
    zOut = (char*)sqlite3DbMallocZero(db, (nSql*2+1) * 3);
    
// ABS Label 517
if(zOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}
if( zOut ){
      zBuf1 = &zOut[nSql*2+1];
      zBuf2 = &zOut[nSql*4+2];
    }
  }

  /* At this point pRename->pList contains a list of RenameToken objects
  ** corresponding to all tokens in the input SQL that must be replaced
  ** with the new column name, or with single-quoted versions of themselves. 
  ** All that remains is to construct and return the edited SQL string. */
  
// ABS Label 518
if(zOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}
if( zOut ){
    int nOut = nSql;
    memcpy(zOut, zSql, nSql);
    
// ABS Label 521
if(pRename->pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}
while( pRename->pList ){
      int iOff;                   /* Offset of token to replace in zOut */
      u32 nReplace;
      const char *zReplace;
      RenameToken *pBest = renameColumnTokenNext(pRename);

      
// ABS Label 524
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}
if( zNew ){
        if( bQuote==0 && sqlite3IsIdChar(*pBest->t.z) ){
          nReplace = nNew;
          zReplace = zNew;
        }else{
          nReplace = nQuot;
          zReplace = zQuot;
          
// ROR Label 525
if((pBest->t.z[pBest->t.n] != '"') != (pBest->t.z[pBest->t.n] == '"'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 525);
}
if( pBest->t.z[pBest->t.n]=='"' ) { nReplace++;
}
        }
      }else{
        /* Dequote the double-quoted token. Then requote it again, this time
        ** using single quotes. If the character immediately following the
        ** original token within the input SQL was a single quote ('), then
        ** add another space after the new, single-quoted version of the
        ** token. This is so that (SELECT "string"'alias') maps to
        ** (SELECT 'string' 'alias'), and not (SELECT 'string''alias').  */
        memcpy(zBuf1, pBest->t.z, pBest->t.n);
        zBuf1[pBest->t.n] = 0;
        
// ABS Label 526
if(zBuf1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}
sqlite3Dequote(zBuf1);
        
// ABS Label 527
if(zBuf2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}

// ABS Label 528
if(zBuf1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 528);
}
sqlite3_snprintf(nSql*2, zBuf2, "%Q%s", zBuf1,
            pBest->t.z[pBest->t.n]=='\'' ? " " : ""
        );
        zReplace = zBuf2;
        nReplace = sqlite3Strlen30(zReplace);
      }

      iOff = pBest->t.z - zSql;
      
// ABS Label 529
if(nReplace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}
// ABS Label 530
if(pBest->t.n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}

// ROR Label 531
if((pBest->t.n == nReplace) != (pBest->t.n != nReplace))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 531);
}
if( pBest->t.n!=nReplace ){
        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n], 
            nOut - (iOff + pBest->t.n)
        );
        nOut += nReplace - pBest->t.n;
        zOut[nOut] = '\0';
      }
      memcpy(&zOut[iOff], zReplace, nReplace);
      
// ABS Label 523
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}
sqlite3DbFree(db, pBest);
    };
// ABS Label 522
if(pRename->pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 522);
}


    
// ABS Label 519
if(pCtx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}
sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);
    
// ABS Label 520
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 520);
}
sqlite3DbFree(db, zOut);
  }else{
    rc = SQLITE_NOMEM;
  }

  sqlite3_free(zQuot);
  
// ABS Label 532
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 532);
}
return rc;
}

/*
** Resolve all symbols in the trigger at pParse->pNewTrigger, assuming
** it was read from the schema of database zDb. Return SQLITE_OK if 
** successful. Otherwise, return an SQLite error code and leave an error
** message in the Parse object.
*/
static int renameResolveTrigger(Parse *pParse){
  
// ABS Label 533
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}
sqlite3 *db = pParse->db;
  
// ABS Label 534
if(pParse->pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}
Trigger *pNew = pParse->pNewTrigger;
  TriggerStep *pStep;
  NameContext sNC;
  int rc = SQLITE_OK;

  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  assert( pNew->pTabSchema );
  pParse->pTriggerTab = sqlite3FindTable(db, pNew->table, 
      db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName
  );
  pParse->eTriggerOp = pNew->op;
  /* ALWAYS() because if the table of the trigger does not exist, the
  ** error would have been hit before this point */
  
// ABS Label 535
if((pParse->pTriggerTab) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}
if( ALWAYS(pParse->pTriggerTab) ){
    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);
  }

  /* Resolve symbols in WHEN clause */
  
// ABS Label 536
if(pNew->pWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}
// ABS Label 537
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}

// COR Label 538
if((rc == 0 || pNew->pWhen) != (rc == 0 && pNew->pWhen))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 538);
}

// ROR Label 539
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 539);
}

// MCC Label 540
if(rc == 0 && pNew->pWhen ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 540);
}
// MCC Label 541
if(rc == 0 && !(pNew->pWhen) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
// MCC Label 542
if(!(rc == 0) && pNew->pWhen ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 542);
}
// MCC Label 543
if(!(rc == 0) && !(pNew->pWhen) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 543);
}
if( rc==SQLITE_OK && pNew->pWhen ){
    rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);
  }

  pStep = pNew->step_list;

// ABS Label 544
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 544);
}
// ABS Label 545
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}

// COR Label 546
if((rc == 0 || pStep) != (rc == 0 && pStep))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 546);
}

// ROR Label 547
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 547);
}

// MCC Label 548
if(rc == 0 && pStep ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 548);
}
// MCC Label 549
if(rc == 0 && !(pStep) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 549);
}
// MCC Label 550
if(!(rc == 0) && pStep ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 550);
}
// MCC Label 551
if(!(rc == 0) && !(pStep) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 551);
}
for(; rc==SQLITE_OK && pStep; pStep=pStep->pNext){
    
// ABS Label 560
if(pStep->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 560);
}
if( pStep->pSelect ){
      
// ABS Label 561
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}

// ABS Label 562
if(pStep->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}
sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);
      
// ABS Label 563
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 563);
}
if( pParse->nErr ) { rc = pParse->rc;
}
    }
    
// ABS Label 564
if(pStep->zTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 564);
}
// ABS Label 565
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 565);
}

// COR Label 566
if((rc == 0 || pStep->zTarget) != (rc == 0 && pStep->zTarget))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 566);
}

// ROR Label 567
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 567);
}

// MCC Label 568
if(rc == 0 && pStep->zTarget ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 568);
}
// MCC Label 569
if(rc == 0 && !(pStep->zTarget) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 569);
}
// MCC Label 570
if(!(rc == 0) && pStep->zTarget ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 570);
}
// MCC Label 571
if(!(rc == 0) && !(pStep->zTarget) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 571);
}
if( rc==SQLITE_OK && pStep->zTarget ){
      SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);
      
// ABS Label 572
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 572);
}
if( pSrc ){
        int i;
        i = 0;

// ABS Label 575
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 575);
}
// ABS Label 576
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 576);
}
// ABS Label 577
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 577);
}

// COR Label 578
if((i < pSrc->nSrc || rc == 0) != (i < pSrc->nSrc && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 578);
}

// ROR Label 579
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 579);
}
// ROR Label 580
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 580);
}
// ROR Label 581
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 581);
}
// ROR Label 582
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 582);
}

// MCC Label 583
if(i < pSrc->nSrc && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(i < pSrc->nSrc && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(!(i < pSrc->nSrc) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
// MCC Label 586
if(!(i < pSrc->nSrc) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 586);
}
for(; i<pSrc->nSrc && rc==SQLITE_OK; i++){
          SrcItem *p = &pSrc->a[i];
          p->iCursor = pParse->nTab++;
          
// ABS Label 599
if(p->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}
if( p->pSelect ){
            
// ABS Label 600
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 600);
}

// ABS Label 601
if(p->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 601);
}
sqlite3SelectPrep(pParse, p->pSelect, 0);
            
// ABS Label 602
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}

// ABS Label 603
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}
sqlite3ExpandSubquery(pParse, p);
            assert( i>0 );
            assert( pStep->pFrom->a[i-1].pSelect );
            
// ABS Label 604
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}

// ABS Label 605
if(pStep->pFrom->a[i - 1].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}
sqlite3SelectPrep(pParse, pStep->pFrom->a[i-1].pSelect, 0);
          }else{
            p->pTab = sqlite3LocateTableItem(pParse, 0, p);
            
// ABS Label 606
if(p->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 606);
}

// ROR Label 607
if((p->pTab != 0) != (p->pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 607);
}
if( p->pTab==0 ){
              rc = SQLITE_ERROR;
            }else{
              p->pTab->nTabRef++;
              rc = sqlite3ViewGetColumnNames(pParse, p->pTab);
            }
          }
        };
// ABS Label 587
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 587);
}
// ABS Label 588
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 588);
}
// ABS Label 589
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}

// COR Label 590
if((i < pSrc->nSrc || rc == 0) != (i < pSrc->nSrc && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 590);
}

// ROR Label 591
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 591);
}
// ROR Label 592
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}
// ROR Label 593
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}

// MCC Label 595
if(i < pSrc->nSrc && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(i < pSrc->nSrc && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
// MCC Label 597
if(!(i < pSrc->nSrc) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(!(i < pSrc->nSrc) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}

        sNC.pSrcList = pSrc;
        
// ABS Label 608
if(pStep->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}
// ABS Label 609
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}

// COR Label 610
if((rc == 0 || pStep->pWhere) != (rc == 0 && pStep->pWhere))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 610);
}

// ROR Label 611
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 611);
}

// MCC Label 612
if(rc == 0 && pStep->pWhere ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 612);
}
// MCC Label 613
if(rc == 0 && !(pStep->pWhere) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 613);
}
// MCC Label 614
if(!(rc == 0) && pStep->pWhere ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 614);
}
// MCC Label 615
if(!(rc == 0) && !(pStep->pWhere) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 615);
}
if( rc==SQLITE_OK && pStep->pWhere ){
          rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);
        }
        
// ABS Label 616
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 616);
}

// ROR Label 617
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 617);
}
if( rc==SQLITE_OK ){
          rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);
        }
        assert( !pStep->pUpsert || (!pStep->pWhere && !pStep->pExprList) );
        
// ABS Label 618
if(pStep->pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}
// ABS Label 619
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// COR Label 620
if((pStep->pUpsert || rc == 0) != (pStep->pUpsert && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 620);
}

// ROR Label 621
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}

// MCC Label 622
if(pStep->pUpsert && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 622);
}
// MCC Label 623
if(pStep->pUpsert && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 623);
}
// MCC Label 624
if(!(pStep->pUpsert) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(!(pStep->pUpsert) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
if( pStep->pUpsert && rc==SQLITE_OK ){
          
// ABS Label 626
if(pStep->pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 626);
}
Upsert *pUpsert = pStep->pUpsert;
          pUpsert->pUpsertSrc = pSrc;
          sNC.uNC.pUpsert = pUpsert;
          sNC.ncFlags = NC_UUpsert;
          rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);
          
// ABS Label 627
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 627);
}

// ROR Label 628
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 628);
}
if( rc==SQLITE_OK ){
            
// ABS Label 629
if(pUpsert->pUpsertSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}
ExprList *pUpsertSet = pUpsert->pUpsertSet;
            rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);
          }
          
// ABS Label 630
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}

// ROR Label 631
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}
if( rc==SQLITE_OK ){
            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);
          }
          
// ABS Label 632
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 632);
}

// ROR Label 633
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 633);
}
if( rc==SQLITE_OK ){
            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);
          }
          sNC.ncFlags = 0;
        }
        sNC.pSrcList = 0;
        
// ABS Label 573
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 573);
}

// ABS Label 574
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}
sqlite3SrcListDelete(db, pSrc);
      }else{
        rc = SQLITE_NOMEM;
      }
    }
  };
// ABS Label 552
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}
// ABS Label 553
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}

// COR Label 554
if((rc == 0 || pStep) != (rc == 0 && pStep))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 554);
}

// ROR Label 555
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}

// MCC Label 556
if(rc == 0 && pStep ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 556);
}
// MCC Label 557
if(rc == 0 && !(pStep) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 557);
}
// MCC Label 558
if(!(rc == 0) && pStep ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 558);
}
// MCC Label 559
if(!(rc == 0) && !(pStep) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 559);
}

  
// ABS Label 634
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}
return rc;
}

/*
** Invoke sqlite3WalkExpr() or sqlite3WalkSelect() on all Select or Expr
** objects that are part of the trigger passed as the second argument.
*/
static void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){
  TriggerStep *pStep;

  /* Find tokens to edit in WHEN clause */
  
// ABS Label 635
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 635);
}

// ABS Label 636
if(pTrigger->pWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 636);
}
sqlite3WalkExpr(pWalker, pTrigger->pWhen);

  /* Find tokens to edit in trigger steps */
  pStep = pTrigger->step_list;

// ABS Label 637
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 637);
}
for(; pStep; pStep=pStep->pNext){
    
// ABS Label 639
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// ABS Label 640
if(pStep->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 640);
}
sqlite3WalkSelect(pWalker, pStep->pSelect);
    
// ABS Label 641
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}

// ABS Label 642
if(pStep->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 642);
}
sqlite3WalkExpr(pWalker, pStep->pWhere);
    
// ABS Label 643
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}

// ABS Label 644
if(pStep->pExprList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}
sqlite3WalkExprList(pWalker, pStep->pExprList);
    
// ABS Label 645
if(pStep->pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}
if( pStep->pUpsert ){
      
// ABS Label 646
if(pStep->pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}
Upsert *pUpsert = pStep->pUpsert;
      
// ABS Label 647
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}

// ABS Label 648
if(pUpsert->pUpsertTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}
sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);
      
// ABS Label 649
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 649);
}

// ABS Label 650
if(pUpsert->pUpsertSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}
sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);
      
// ABS Label 651
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}

// ABS Label 652
if(pUpsert->pUpsertWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}
sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);
      
// ABS Label 653
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}

// ABS Label 654
if(pUpsert->pUpsertTargetWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}
sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);
    }
    
// ABS Label 655
if(pStep->pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 655);
}
if( pStep->pFrom ){
      int i;
      i = 0;

// ABS Label 656
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}
// ABS Label 657
if(pStep->pFrom->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}

// ROR Label 658
if((i <= pStep->pFrom->nSrc) != (i < pStep->pFrom->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 658);
}
// ROR Label 659
if((i > pStep->pFrom->nSrc) != (i < pStep->pFrom->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 659);
}
// ROR Label 660
if((i >= pStep->pFrom->nSrc) != (i < pStep->pFrom->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 660);
}
for(; i<pStep->pFrom->nSrc; i++){
        
// ABS Label 666
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ABS Label 667
if(pStep->pFrom->a[i].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}
sqlite3WalkSelect(pWalker, pStep->pFrom->a[i].pSelect);
      };
// ABS Label 661
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}
// ABS Label 662
if(pStep->pFrom->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 662);
}

// ROR Label 663
if((i <= pStep->pFrom->nSrc) != (i < pStep->pFrom->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 663);
}
// ROR Label 664
if((i > pStep->pFrom->nSrc) != (i < pStep->pFrom->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 664);
}
// ROR Label 665
if((i >= pStep->pFrom->nSrc) != (i < pStep->pFrom->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 665);
}

    }
  };
// ABS Label 638
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 638);
}

}

/*
** Free the contents of Parse object (*pParse). Do not free the memory
** occupied by the Parse object itself.
*/
static void renameParseCleanup(Parse *pParse){
  
// ABS Label 668
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}
sqlite3 *db = pParse->db;
  Index *pIdx;
  
// ABS Label 677
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}
if( pParse->pVdbe ){
    
// ABS Label 678
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
sqlite3VdbeFinalize(pParse->pVdbe);
  }
  
// ABS Label 669
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}

// ABS Label 670
if(pParse->pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}
sqlite3DeleteTable(db, pParse->pNewTable);
  while( (pIdx = pParse->pNewIndex)!=0 ){
    pParse->pNewIndex = pIdx->pNext;
    
// ABS Label 679
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}

// ABS Label 680
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}
sqlite3FreeIndex(db, pIdx);
  };
  
// ABS Label 671
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ABS Label 672
if(pParse->pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}
sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  
// ABS Label 673
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}
sqlite3DbFree(db, pParse->zErrMsg);
  
// ABS Label 674
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}

// ABS Label 675
if(pParse->pRename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}
renameTokenFree(db, pParse->pRename);
  
// ABS Label 676
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}
sqlite3ParserReset(pParse);
}

/*
** SQL function:
**
**     sqlite_rename_column(zSql, iCol, bQuote, zNew, zTable, zOld)
**
**   0. zSql:     SQL statement to rewrite
**   1. type:     Type of object ("table", "view" etc.)
**   2. object:   Name of object
**   3. Database: Database name (e.g. "main")
**   4. Table:    Table name
**   5. iCol:     Index of column to rename
**   6. zNew:     New column name
**   7. bQuote:   Non-zero if the new column name should be quoted.
**   8. bTemp:    True if zSql comes from temp schema
**
** Do a column rename operation on the CREATE statement given in zSql.
** The iCol-th column (left-most is 0) of table zTable is renamed from zCol
** into zNew.  The name should be quoted if bQuote is true.
**
** This function is used internally by the ALTER TABLE RENAME COLUMN command.
** It is only accessible to SQL created using sqlite3NestedParse().  It is
** not reachable from ordinary SQL passed into sqlite3_prepare().
*/
static void renameColumnFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  RenameCtx sCtx;
  const char *zSql = (const char*)sqlite3_value_text(argv[0]);
  const char *zDb = (const char*)sqlite3_value_text(argv[3]);
  const char *zTable = (const char*)sqlite3_value_text(argv[4]);
  int iCol = sqlite3_value_int(argv[5]);
  const char *zNew = (const char*)sqlite3_value_text(argv[6]);
  int bQuote = sqlite3_value_int(argv[7]);
  int bTemp = sqlite3_value_int(argv[8]);
  const char *zOld;
  int rc;
  Parse sParse;
  Walker sWalker;
  Index *pIdx;
  int i;
  Table *pTab;
#ifndef SQLITE_OMIT_AUTHORIZATION
  
// ABS Label 681
if(db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}
sqlite3_xauth xAuth = db->xAuth;
#endif

  UNUSED_PARAMETER(NotUsed);
  
// ABS Label 686
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}

// ROR Label 687
if((zSql != 0) != (zSql == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 687);
}
if( zSql==0 ) { return;
}
  
// ABS Label 688
if(zTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}

// ROR Label 689
if((zTable != 0) != (zTable == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 689);
}
if( zTable==0 ) { return;
}
  
// ABS Label 690
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}

// ROR Label 691
if((zNew != 0) != (zNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 691);
}
if( zNew==0 ) { return;
}
  
// ABS Label 692
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}

// ROR Label 693
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 693);
}
// ROR Label 694
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 694);
}
// ROR Label 695
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 695);
}
if( iCol<0 ) { return;
}
  
// ABS Label 682
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 682);
}
sqlite3BtreeEnterAll(db);
  pTab = sqlite3FindTable(db, zTable, zDb);
  
// ABS Label 696
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}
// ABS Label 697
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}

// COR Label 698
if((pTab == 0 && iCol >= pTab->nCol) != (pTab == 0 || iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 698);
}

// ROR Label 699
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}
// ROR Label 700
if((iCol < pTab->nCol) != (iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 700);
}
// ROR Label 701
if((iCol > pTab->nCol) != (iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 701);
}
// ROR Label 702
if((iCol <= pTab->nCol) != (iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 702);
}

// MCC Label 703
if(pTab == 0 && iCol >= pTab->nCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 703);
}
// MCC Label 704
if(pTab == 0 && !(iCol >= pTab->nCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 704);
}
// MCC Label 705
if(!(pTab == 0) && iCol >= pTab->nCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 705);
}
// MCC Label 706
if(!(pTab == 0) && !(iCol >= pTab->nCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 706);
}
if( pTab==0 || iCol>=pTab->nCol ){
    
// ABS Label 707
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}
sqlite3BtreeLeaveAll(db);
    return;
  }
  zOld = pTab->aCol[iCol].zName;
  memset(&sCtx, 0, sizeof(sCtx));
  sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);

#ifndef SQLITE_OMIT_AUTHORIZATION
  db->xAuth = 0;
#endif
  rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);

  /* Find tokens that need to be replaced. */
  memset(&sWalker, 0, sizeof(Walker));
  sWalker.pParse = &sParse;
  sWalker.xExprCallback = renameColumnExprCb;
  sWalker.xSelectCallback = renameColumnSelectCb;
  sWalker.u.pRename = &sCtx;

  sCtx.pTab = pTab;
  
// ABS Label 708
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 708);
}

// ROR Label 709
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 709);
}
if( rc!=SQLITE_OK ) { goto renameColumnFunc_done;
}
  
// ABS Label 710
if(sParse.pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}
if( sParse.pNewTable ){
    
// ABS Label 711
if(sParse.pNewTable->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 711);
}
Select *pSelect = sParse.pNewTable->pSelect;
    
// ABS Label 712
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}
if( pSelect ){
      pSelect->selFlags &= ~SF_View;
      sParse.rc = SQLITE_OK;
      
// ABS Label 713
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 713);
}
sqlite3SelectPrep(&sParse, pSelect, 0);
      rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);
      
// ABS Label 714
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}

// ROR Label 715
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 715);
}
if( rc==SQLITE_OK ){
        
// ABS Label 716
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}
sqlite3WalkSelect(&sWalker, pSelect);
      }
      
// ABS Label 717
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}

// ROR Label 718
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 718);
}
if( rc!=SQLITE_OK ) { goto renameColumnFunc_done;
}
    }else{
      /* A regular table */
      int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);
      FKey *pFKey;
      assert( sParse.pNewTable->pSelect==0 );
      sCtx.pTab = sParse.pNewTable;
      
// ABS Label 719
if(bFKOnly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}

// ROR Label 720
if((bFKOnly != 0) != (bFKOnly == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}
if( bFKOnly==0 ){
        
// ABS Label 722
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 722);
}

// ROR Label 723
if((iCol <= sParse.pNewTable->nCol) != (iCol < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}
// ROR Label 724
if((iCol > sParse.pNewTable->nCol) != (iCol < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 724);
}
// ROR Label 725
if((iCol >= sParse.pNewTable->nCol) != (iCol < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 725);
}
if( iCol<sParse.pNewTable->nCol ){
          renameTokenFind(
              &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zName
          );
        }
        
// ABS Label 726
if(sCtx.iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}

// ROR Label 727
if((sCtx.iCol <= 0) != (sCtx.iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 727);
}
// ROR Label 728
if((sCtx.iCol > 0) != (sCtx.iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 728);
}
// ROR Label 729
if((sCtx.iCol >= 0) != (sCtx.iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 729);
}
if( sCtx.iCol<0 ){
          renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);
        }
        
// ABS Label 721
if(sParse.pNewTable->pCheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}
sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);
        pIdx = sParse.pNewTable->pIndex;

// ABS Label 730
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
for(; pIdx; pIdx=pIdx->pNext){
          
// ABS Label 732
if(pIdx->aColExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}
sqlite3WalkExprList(&sWalker, pIdx->aColExpr);
        };
// ABS Label 731
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

        pIdx = sParse.pNewIndex;

// ABS Label 733
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 733);
}
for(; pIdx; pIdx=pIdx->pNext){
          
// ABS Label 735
if(pIdx->aColExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 735);
}
sqlite3WalkExprList(&sWalker, pIdx->aColExpr);
        };
// ABS Label 734
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 734);
}

#ifndef SQLITE_OMIT_GENERATED_COLUMNS
        i = 0;

// ABS Label 736
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// ROR Label 737
if((i <= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 737);
}
// ROR Label 738
if((i > sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 738);
}
// ROR Label 739
if((i >= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 739);
}
for(; i<sParse.pNewTable->nCol; i++){
          
// ABS Label 744
if(sParse.pNewTable->aCol[i].pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 744);
}
sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);
        };
// ABS Label 740
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}

// ROR Label 741
if((i <= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 741);
}
// ROR Label 742
if((i > sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 742);
}
// ROR Label 743
if((i >= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 743);
}

#endif
      }

      pFKey = sParse.pNewTable->pFKey;

// ABS Label 745
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}
for(; pFKey; pFKey=pFKey->pNextFrom){
        i = 0;

// ABS Label 747
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}
// ABS Label 748
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// ROR Label 749
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 749);
}
// ROR Label 750
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 750);
}
// ROR Label 751
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 751);
}
for(; i<pFKey->nCol; i++){
          
// ABS Label 757
if(bFKOnly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}
// ABS Label 758
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}
// ABS Label 759
if(pFKey->aCol[i].iFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}

// COR Label 760
if((bFKOnly == 0 || pFKey->aCol[i].iFrom == iCol) != (bFKOnly == 0 && pFKey->aCol[i].iFrom == iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 760);
}

// ROR Label 761
if((bFKOnly != 0) != (bFKOnly == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 761);
}
// ROR Label 762
if((pFKey->aCol[i].iFrom != iCol) != (pFKey->aCol[i].iFrom == iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 762);
}

// MCC Label 763
if(bFKOnly == 0 && pFKey->aCol[i].iFrom == iCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 763);
}
// MCC Label 764
if(bFKOnly == 0 && !(pFKey->aCol[i].iFrom == iCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 764);
}
// MCC Label 765
if(!(bFKOnly == 0) && pFKey->aCol[i].iFrom == iCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 765);
}
// MCC Label 766
if(!(bFKOnly == 0) && !(pFKey->aCol[i].iFrom == iCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 766);
}
if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){
            renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);
          }
          if( 0==sqlite3_stricmp(pFKey->zTo, zTable)
           && 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)
          ){
            renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);
          }
        };
// ABS Label 752
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 752);
}
// ABS Label 753
if(pFKey->nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 753);
}

// ROR Label 754
if((i <= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 754);
}
// ROR Label 755
if((i > pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 755);
}
// ROR Label 756
if((i >= pFKey->nCol) != (i < pFKey->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 756);
}

      };
// ABS Label 746
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}

    }
  }else { 
// ABS Label 767
if(sParse.pNewIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 767);
}
if( sParse.pNewIndex ){
    
// ABS Label 768
if(sParse.pNewIndex->aColExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}
sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);
    
// ABS Label 769
if(sParse.pNewIndex->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 769);
}
sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
  }else{
    /* A trigger */
    TriggerStep *pStep;
    rc = renameResolveTrigger(&sParse);
    
// ABS Label 771
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 771);
}

// ROR Label 772
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 772);
}
if( rc!=SQLITE_OK ) { goto renameColumnFunc_done;
}

    pStep = sParse.pNewTrigger->step_list;

// ABS Label 773
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}
for(; pStep; pStep=pStep->pNext){
      
// ABS Label 775
if(pStep->zTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}
if( pStep->zTarget ){ 
        Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);
        
// ABS Label 776
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}
// ABS Label 777
if(pTarget < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ROR Label 778
if((pTarget != pTab) != (pTarget == pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 778);
}
if( pTarget==pTab ){
          
// ABS Label 783
if(pStep->pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}
if( pStep->pUpsert ){
            
// ABS Label 784
if(pStep->pUpsert->pUpsertSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}
ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;
            
// ABS Label 785
if(pUpsertSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// ABS Label 786
if(zOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}
renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);
          }
          
// ABS Label 779
if(pStep->pIdList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 779);
}

// ABS Label 780
if(zOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}
renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);
          
// ABS Label 781
if(pStep->pExprList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}

// ABS Label 782
if(zOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}
renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);
        }
      }
    };
// ABS Label 774
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}



    /* Find tokens to edit in UPDATE OF clause */
    
// ABS Label 787
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}
// ABS Label 788
if(sParse.pTriggerTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}

// ROR Label 789
if((sParse.pTriggerTab != pTab) != (sParse.pTriggerTab == pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 789);
}
if( sParse.pTriggerTab==pTab ){
      
// ABS Label 790
if(sParse.pNewTrigger->pColumns < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}

// ABS Label 791
if(zOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}
renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);
    }

    /* Find tokens to edit in various expressions and selects */
    
// ABS Label 770
if(sParse.pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 770);
}
renameWalkTrigger(&sWalker, sParse.pNewTrigger);
  };}


  assert( rc==SQLITE_OK );
  rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);

renameColumnFunc_done:
  
// ABS Label 792
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}

// ROR Label 793
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 793);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 794
if(sParse.zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}
if( sParse.zErrMsg ){
      
// ABS Label 795
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}

// ABS Label 796
if(argv[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}

// ABS Label 797
if(argv[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}
renameColumnParseError(context, "", argv[1], argv[2], &sParse);
    }else{
      
// ABS Label 798
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}

// ABS Label 799
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}
sqlite3_result_error_code(context, rc);
    }
  }

  renameParseCleanup(&sParse);
  
// ABS Label 683
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}

// ABS Label 684
if(sCtx.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 684);
}
renameTokenFree(db, sCtx.pList);
#ifndef SQLITE_OMIT_AUTHORIZATION
  db->xAuth = xAuth;
#endif
  
// ABS Label 685
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}
sqlite3BtreeLeaveAll(db);
}

/*
** Walker expression callback used by "RENAME TABLE". 
*/
static int renameTableExprCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 800
if(pWalker->u.pRename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}
RenameCtx *p = pWalker->u.pRename;
  
// ABS Label 801
if(p->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}
// ABS Label 802
if(pExpr->y.pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 802);
}

// COR Label 803
if((pExpr->op == 166 || p->pTab == pExpr->y.pTab) != (pExpr->op == 166 && p->pTab == pExpr->y.pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 803);
}

// ROR Label 804
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 804);
}
// ROR Label 805
if((p->pTab != pExpr->y.pTab) != (p->pTab == pExpr->y.pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 805);
}

// MCC Label 806
if(pExpr->op == 166 && p->pTab == pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 806);
}
// MCC Label 807
if(pExpr->op == 166 && !(p->pTab == pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 807);
}
// MCC Label 808
if(!(pExpr->op == 166) && p->pTab == pExpr->y.pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 808);
}
// MCC Label 809
if(!(pExpr->op == 166) && !(p->pTab == pExpr->y.pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 809);
}
if( pExpr->op==TK_COLUMN && p->pTab==pExpr->y.pTab ){
    
// ABS Label 810
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}

// ABS Label 811
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);
  }
  return WRC_Continue;
}

/*
** Walker select callback used by "RENAME TABLE". 
*/
static int renameTableSelectCb(Walker *pWalker, Select *pSelect){
  int i;
  
// ABS Label 812
if(pWalker->u.pRename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}
RenameCtx *p = pWalker->u.pRename;
  
// ABS Label 813
if(pSelect->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}
SrcList *pSrc = pSelect->pSrc;
  
// ABS Label 816
if(pSelect->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// AOR Label 817
if(pSelect->selFlags | (2097152 | 67108864) != pSelect->selFlags & (2097152 | 67108864))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 817);
}
// AOR Label 818
if(pSelect->selFlags ^ (2097152 | 67108864) != pSelect->selFlags & (2097152 | 67108864))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 818);
}
if( pSelect->selFlags & (SF_View|SF_CopyCte) ){
    testcase( pSelect->selFlags & SF_View );
    testcase( pSelect->selFlags & SF_CopyCte );
    return WRC_Prune;
  }
  
// MCC Label 819
if(( pSrc == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 819);
}
// MCC Label 820
if(( !(pSrc == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 820);
}
if( NEVER(pSrc==0) ){
    assert( pWalker->pParse->db->mallocFailed );
    return WRC_Abort;
  }
  i = 0;

// ABS Label 821
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}
// ABS Label 822
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}

// ROR Label 823
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 823);
}
// ROR Label 824
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 824);
}
// ROR Label 825
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 825);
}
for(; i<pSrc->nSrc; i++){
    SrcItem *pItem = &pSrc->a[i];
    
// ABS Label 831
if(p->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 831);
}
// ABS Label 832
if(pItem->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 832);
}

// ROR Label 833
if((pItem->pTab != p->pTab) != (pItem->pTab == p->pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 833);
}
if( pItem->pTab==p->pTab ){
      
// ABS Label 834
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 834);
}

// ABS Label 835
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}
renameTokenFind(pWalker->pParse, p, pItem->zName);
    }
  };
// ABS Label 826
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}
// ABS Label 827
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}

// ROR Label 828
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 828);
}
// ROR Label 829
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 829);
}
// ROR Label 830
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 830);
}

  
// ABS Label 814
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ABS Label 815
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}
renameWalkWith(pWalker, pSelect);

  return WRC_Continue;
}


/*
** This C function implements an SQL user function that is used by SQL code
** generated by the ALTER TABLE ... RENAME command to modify the definition
** of any foreign key constraints that use the table being renamed as the 
** parent table. It is passed three arguments:
**
**   0: The database containing the table being renamed.
**   1. type:     Type of object ("table", "view" etc.)
**   2. object:   Name of object
**   3: The complete text of the schema statement being modified,
**   4: The old name of the table being renamed, and
**   5: The new name of the table being renamed.
**   6: True if the schema statement comes from the temp db.
**
** It returns the new schema statement. For example:
**
** sqlite_rename_table('main', 'CREATE TABLE t1(a REFERENCES t2)','t2','t3',0)
**       -> 'CREATE TABLE t1(a REFERENCES t3)'
*/
static void renameTableFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zDb = (const char*)sqlite3_value_text(argv[0]);
  const char *zInput = (const char*)sqlite3_value_text(argv[3]);
  const char *zOld = (const char*)sqlite3_value_text(argv[4]);
  const char *zNew = (const char*)sqlite3_value_text(argv[5]);
  int bTemp = sqlite3_value_int(argv[6]);
  UNUSED_PARAMETER(NotUsed);

  
// ABS Label 836
if(zInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 836);
}
// ABS Label 837
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 837);
}
// ABS Label 838
if(zOld < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}

// COR Label 839
if((zInput && zOld || zNew) != (zInput && zOld && zNew))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 839);
}
// COR Label 840
if((zInput || zOld) != (zInput && zOld))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 840);
}

// MCC Label 841
if(zInput && zOld && zNew ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 841);
}
// MCC Label 842
if(zInput && zOld && !(zNew) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 842);
}
// MCC Label 843
if(zInput && !(zOld) && zNew ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 843);
}
// MCC Label 844
if(zInput && !(zOld) && !(zNew) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 844);
}
// MCC Label 845
if(!(zInput) && zOld && zNew ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 845);
}
// MCC Label 846
if(!(zInput) && zOld && !(zNew) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 846);
}
// MCC Label 847
if(!(zInput) && !(zOld) && zNew ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 847);
}
// MCC Label 848
if(!(zInput) && !(zOld) && !(zNew) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 848);
}
if( zInput && zOld && zNew ){
    Parse sParse;
    int rc;
    int bQuote = 1;
    RenameCtx sCtx;
    Walker sWalker;

#ifndef SQLITE_OMIT_AUTHORIZATION
    
// ABS Label 849
if(db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}
sqlite3_xauth xAuth = db->xAuth;
    db->xAuth = 0;
#endif

    
// ABS Label 850
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}
sqlite3BtreeEnterAll(db);

    memset(&sCtx, 0, sizeof(RenameCtx));
    sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.pParse = &sParse;
    sWalker.xExprCallback = renameTableExprCb;
    sWalker.xSelectCallback = renameTableSelectCb;
    sWalker.u.pRename = &sCtx;

    rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);

    
// ABS Label 854
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}

// ROR Label 855
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 855);
}
if( rc==SQLITE_OK ){
      int isLegacy = (db->flags & SQLITE_LegacyAlter);
      
// ABS Label 856
if(sParse.pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}
if( sParse.pNewTable ){
        
// ABS Label 857
if(sParse.pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 857);
}
Table *pTab = sParse.pNewTable;

        
// ABS Label 858
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
if( pTab->pSelect ){
          
// ABS Label 859
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}

// ROR Label 860
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 860);
}
if( isLegacy==0 ){
            
// ABS Label 861
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 861);
}
Select *pSelect = pTab->pSelect;
            NameContext sNC;
            memset(&sNC, 0, sizeof(sNC));
            sNC.pParse = &sParse;

            assert( pSelect->selFlags & SF_View );
            pSelect->selFlags &= ~SF_View;
            
// ABS Label 862
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 862);
}
sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);
            
// ABS Label 863
if(sParse.nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}
if( sParse.nErr ){
              rc = sParse.rc;
            }else{
              
// ABS Label 864
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 864);
}
sqlite3WalkSelect(&sWalker, pTab->pSelect);
            }
          }
        }else{
          /* Modify any FK definitions to point to the new table. */
#ifndef SQLITE_OMIT_FOREIGN_KEY
          
// ABS Label 865
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 865);
}

// COR Label 866
if((isLegacy == 0 && (db->flags & 16384)) != (isLegacy == 0 || (db->flags & 16384)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 866);
}

// ROR Label 867
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 867);
}

// MCC Label 868
if(isLegacy == 0 && ( db->flags & 16384 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 868);
}
// MCC Label 869
if(isLegacy == 0 && ( !(db->flags & 16384) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 869);
}
// MCC Label 870
if(!(isLegacy == 0) && ( db->flags & 16384 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 870);
}
// MCC Label 871
if(!(isLegacy == 0) && ( !(db->flags & 16384) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 871);
}
if( isLegacy==0 || (db->flags & SQLITE_ForeignKeys) ){
            FKey *pFKey;
            pFKey = pTab->pFKey;

// ABS Label 872
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
for(; pFKey; pFKey=pFKey->pNextFrom){
              if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){
                renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);
              }
            };
// ABS Label 873
if(pFKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

          }
#endif

          /* If this is the table being altered, fix any table refs in CHECK
          ** expressions. Also update the name that appears right after the
          ** "CREATE [VIRTUAL] TABLE" bit. */
          if( sqlite3_stricmp(zOld, pTab->zName)==0 ){
            sCtx.pTab = pTab;
            
// ABS Label 874
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 874);
}

// ROR Label 875
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}
if( isLegacy==0 ){
              
// ABS Label 876
if(pTab->pCheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}
sqlite3WalkExprList(&sWalker, pTab->pCheck);
            }
            renameTokenFind(&sParse, &sCtx, pTab->zName);
          }
        }
      }

      else { 
// ABS Label 877
if(sParse.pNewIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}
if( sParse.pNewIndex ){
        renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);
        
// ABS Label 878
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 878);
}

// ROR Label 879
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 879);
}
if( isLegacy==0 ){
          
// ABS Label 880
if(sParse.pNewIndex->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 880);
}
sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
        }
      }

#ifndef SQLITE_OMIT_TRIGGER
      else{
        
// ABS Label 881
if(sParse.pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 881);
}
Trigger *pTrigger = sParse.pNewTrigger;
        TriggerStep *pStep;
        if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld) 
            && sCtx.pTab->pSchema==pTrigger->pTabSchema
          ){
          renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);
        }

        
// ABS Label 882
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}

// ROR Label 883
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 883);
}
if( isLegacy==0 ){
          rc = renameResolveTrigger(&sParse);
          
// ABS Label 884
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 884);
}

// ROR Label 885
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 885);
}
if( rc==SQLITE_OK ){
            
// ABS Label 886
if(pTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 886);
}
renameWalkTrigger(&sWalker, pTrigger);
            pStep = pTrigger->step_list;

// ABS Label 887
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 887);
}
for(; pStep; pStep=pStep->pNext){
              if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){
                renameTokenFind(&sParse, &sCtx, pStep->zTarget);
              }
            };
// ABS Label 888
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 888);
}

          }
        }
      };}

#endif
    }

    
// ABS Label 889
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 889);
}

// ROR Label 890
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 890);
}
if( rc==SQLITE_OK ){
      rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);
    }
    
// ABS Label 891
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}

// ROR Label 892
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 893
if(sParse.zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}
if( sParse.zErrMsg ){
        
// ABS Label 894
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}

// ABS Label 895
if(argv[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}

// ABS Label 896
if(argv[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}
renameColumnParseError(context, "", argv[1], argv[2], &sParse);
      }else{
        
// ABS Label 897
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}

// ABS Label 898
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 898);
}
sqlite3_result_error_code(context, rc);
      }
    }

    renameParseCleanup(&sParse);
    
// ABS Label 851
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}

// ABS Label 852
if(sCtx.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}
renameTokenFree(db, sCtx.pList);
    
// ABS Label 853
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 853);
}
sqlite3BtreeLeaveAll(db);
#ifndef SQLITE_OMIT_AUTHORIZATION
    db->xAuth = xAuth;
#endif
  }

  return;
}

static int renameQuotefixExprCb(Walker *pWalker, Expr *pExpr){
  
// COR Label 899
if((pExpr->op == 116 || (pExpr->flags & 64)) != (pExpr->op == 116 && (pExpr->flags & 64)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 899);
}

// ROR Label 900
if((pExpr->op != 116) != (pExpr->op == 116))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 900);
}

// MCC Label 901
if(pExpr->op == 116 && ( pExpr->flags & 64 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 901);
}
// MCC Label 902
if(pExpr->op == 116 && ( !(pExpr->flags & 64) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 902);
}
// MCC Label 903
if(!(pExpr->op == 116) && ( pExpr->flags & 64 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 903);
}
// MCC Label 904
if(!(pExpr->op == 116) && ( !(pExpr->flags & 64) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 904);
}
if( pExpr->op==TK_STRING && (pExpr->flags & EP_DblQuoted) ){
    
// ABS Label 905
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}

// ABS Label 906
if(pWalker->u.pRename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 906);
}
renameTokenFind(pWalker->pParse, pWalker->u.pRename, (void*)pExpr);
  }
  return WRC_Continue;
}

/*
** The implementation of an SQL scalar function that rewrites DDL statements
** so that any string literals that use double-quotes are modified so that
** they use single quotes.
**
** Two arguments must be passed:
**
**   0: Database name ("main", "temp" etc.).
**   1: SQL statement to edit.
**
** The returned value is the modified SQL statement. For example, given
** the database schema:
**
**   CREATE TABLE t1(a, b, c);
**
**   SELECT sqlite_rename_quotefix('main', 
**       'CREATE VIEW v1 AS SELECT "a", "string" FROM t1'
**   );
**
** returns the string:
** 
**   CREATE VIEW v1 AS SELECT "a", 'string' FROM t1
*/
static void renameQuotefixFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char const *zDb = (const char*)sqlite3_value_text(argv[0]);
  char const *zInput = (const char*)sqlite3_value_text(argv[1]);

#ifndef SQLITE_OMIT_AUTHORIZATION
  
// ABS Label 907
if(db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 907);
}
sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;
#endif

  
// ABS Label 908
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 908);
}
sqlite3BtreeEnterAll(db);

  UNUSED_PARAMETER(NotUsed);
  
// ABS Label 910
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}
// ABS Label 911
if(zInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}

// COR Label 912
if((zDb || zInput) != (zDb && zInput))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 912);
}

// MCC Label 913
if(zDb && zInput ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 913);
}
// MCC Label 914
if(zDb && !(zInput) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(!(zDb) && zInput ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(!(zDb) && !(zInput) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}
if( zDb && zInput ){
    int rc;
    Parse sParse;
    rc = renameParseSql(&sParse, zDb, db, zInput, 0);

    
// ABS Label 917
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ROR Label 918
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
if( rc==SQLITE_OK ){
      RenameCtx sCtx;
      Walker sWalker;

      /* Walker to find tokens that need to be replaced. */
      memset(&sCtx, 0, sizeof(RenameCtx));
      memset(&sWalker, 0, sizeof(Walker));
      sWalker.pParse = &sParse;
      sWalker.xExprCallback = renameQuotefixExprCb;
      sWalker.xSelectCallback = renameColumnSelectCb;
      sWalker.u.pRename = &sCtx;

      
// ABS Label 921
if(sParse.pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}
if( sParse.pNewTable ){
        
// ABS Label 922
if(sParse.pNewTable->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 922);
}
Select *pSelect = sParse.pNewTable->pSelect;
        
// ABS Label 923
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}
if( pSelect ){
          pSelect->selFlags &= ~SF_View;
          sParse.rc = SQLITE_OK;
          
// ABS Label 924
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 924);
}
sqlite3SelectPrep(&sParse, pSelect, 0);
          rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);
          
// ABS Label 925
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 925);
}

// ROR Label 926
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 926);
}
if( rc==SQLITE_OK ){
            
// ABS Label 927
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 927);
}
sqlite3WalkSelect(&sWalker, pSelect);
          }
        }else{
          int i;
          
// ABS Label 928
if(sParse.pNewTable->pCheck < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 928);
}
sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
          i = 0;

// ABS Label 929
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 929);
}

// ROR Label 930
if((i <= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 930);
}
// ROR Label 931
if((i > sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 931);
}
// ROR Label 932
if((i >= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 932);
}
for(; i<sParse.pNewTable->nCol; i++){
            
// ABS Label 937
if(sParse.pNewTable->aCol[i].pDflt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}
sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);
          };
// ABS Label 933
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}

// ROR Label 934
if((i <= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 934);
}
// ROR Label 935
if((i > sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 935);
}
// ROR Label 936
if((i >= sParse.pNewTable->nCol) != (i < sParse.pNewTable->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 936);
}

#endif /* SQLITE_OMIT_GENERATED_COLUMNS */
        }
      }else { 
// ABS Label 938
if(sParse.pNewIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}
if( sParse.pNewIndex ){
        
// ABS Label 939
if(sParse.pNewIndex->aColExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}
sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);
        
// ABS Label 940
if(sParse.pNewIndex->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}
sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
      }else{
#ifndef SQLITE_OMIT_TRIGGER
        rc = renameResolveTrigger(&sParse);
        
// ABS Label 941
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 941);
}

// ROR Label 942
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 942);
}
if( rc==SQLITE_OK ){
          
// ABS Label 943
if(sParse.pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}
renameWalkTrigger(&sWalker, sParse.pNewTrigger);
        }
#endif /* SQLITE_OMIT_TRIGGER */
      };}


      
// ABS Label 944
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}

// ROR Label 945
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 945);
}
if( rc==SQLITE_OK ){ 
        rc = renameEditSql(context, &sCtx, zInput, 0, 0);
      }
      
// ABS Label 919
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}

// ABS Label 920
if(sCtx.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}
renameTokenFree(db, sCtx.pList);
    }
    
// ABS Label 946
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}

// ROR Label 947
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 947);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 948
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 948);
}

// ABS Label 949
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 949);
}
sqlite3_result_error_code(context, rc);
    }
    renameParseCleanup(&sParse);
  }

#ifndef SQLITE_OMIT_AUTHORIZATION
  db->xAuth = xAuth;
#endif

  
// ABS Label 909
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 909);
}
sqlite3BtreeLeaveAll(db);
}

/*
** An SQL user function that checks that there are no parse or symbol
** resolution problems in a CREATE TRIGGER|TABLE|VIEW|INDEX statement.
** After an ALTER TABLE .. RENAME operation is performed and the schema
** reloaded, this function is called on each SQL statement in the schema
** to ensure that it is still usable.
**
**   0: Database name ("main", "temp" etc.).
**   1: SQL statement.
**   2: Object type ("view", "table", "trigger" or "index").
**   3: Object name.
**   4: True if object is from temp schema.
**   5: "when" part of error message.
**   6: True to disable the DQS quirk when parsing SQL.
**
** Unless it finds an error, this function normally returns NULL. However, it
** returns integer value 1 if:
**
**   * the SQL argument creates a trigger, and
**   * the table that the trigger is attached to is in database zDb.
*/
static void renameTableTest(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char const *zDb = (const char*)sqlite3_value_text(argv[0]);
  char const *zInput = (const char*)sqlite3_value_text(argv[1]);
  int bTemp = sqlite3_value_int(argv[4]);
  int isLegacy = (db->flags & SQLITE_LegacyAlter);
  char const *zWhen = (const char*)sqlite3_value_text(argv[5]);
  int bNoDQS = sqlite3_value_int(argv[6]);

#ifndef SQLITE_OMIT_AUTHORIZATION
  
// ABS Label 950
if(db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 950);
}
sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;
#endif

  UNUSED_PARAMETER(NotUsed);

  
// ABS Label 951
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 951);
}
// ABS Label 952
if(zInput < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 952);
}

// COR Label 953
if((zDb || zInput) != (zDb && zInput))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 953);
}

// MCC Label 954
if(zDb && zInput ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 954);
}
// MCC Label 955
if(zDb && !(zInput) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 955);
}
// MCC Label 956
if(!(zDb) && zInput ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 956);
}
// MCC Label 957
if(!(zDb) && !(zInput) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 957);
}
if( zDb && zInput ){
    int rc;
    Parse sParse;
    int flags = db->flags;
    
// ABS Label 958
if(bNoDQS < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 958);
}
if( bNoDQS ) { db->flags &= ~(SQLITE_DqsDML|SQLITE_DqsDDL);
}
    rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);
    db->flags |= (flags & (SQLITE_DqsDML|SQLITE_DqsDDL));
    
// ABS Label 959
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 959);
}

// ROR Label 960
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 960);
}
if( rc==SQLITE_OK ){
      
// ABS Label 961
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 961);
}
// ABS Label 962
if(sParse.pNewTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 962);
}
// ABS Label 963
if(sParse.pNewTable->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}

// COR Label 964
if((isLegacy == 0 && sParse.pNewTable || sParse.pNewTable->pSelect) != (isLegacy == 0 && sParse.pNewTable && sParse.pNewTable->pSelect))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 964);
}
// COR Label 965
if((isLegacy == 0 || sParse.pNewTable) != (isLegacy == 0 && sParse.pNewTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 965);
}

// ROR Label 966
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 966);
}

// MCC Label 967
if(isLegacy == 0 && sParse.pNewTable && sParse.pNewTable->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 967);
}
// MCC Label 968
if(isLegacy == 0 && sParse.pNewTable && !(sParse.pNewTable->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 968);
}
// MCC Label 969
if(isLegacy == 0 && !(sParse.pNewTable) && sParse.pNewTable->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 969);
}
// MCC Label 970
if(isLegacy == 0 && !(sParse.pNewTable) && !(sParse.pNewTable->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 970);
}
// MCC Label 971
if(!(isLegacy == 0) && sParse.pNewTable && sParse.pNewTable->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 971);
}
// MCC Label 972
if(!(isLegacy == 0) && sParse.pNewTable && !(sParse.pNewTable->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 972);
}
// MCC Label 973
if(!(isLegacy == 0) && !(sParse.pNewTable) && sParse.pNewTable->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 973);
}
// MCC Label 974
if(!(isLegacy == 0) && !(sParse.pNewTable) && !(sParse.pNewTable->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 974);
}
if( isLegacy==0 && sParse.pNewTable && sParse.pNewTable->pSelect ){
        NameContext sNC;
        memset(&sNC, 0, sizeof(sNC));
        sNC.pParse = &sParse;
        
// ABS Label 975
if(sParse.pNewTable->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 975);
}
sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, &sNC);
        
// ABS Label 976
if(sParse.nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}
if( sParse.nErr ) { rc = sParse.rc;
}
      }

      else { 
// ABS Label 977
if(sParse.pNewTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 977);
}
if( sParse.pNewTrigger ){
        
// ABS Label 978
if(isLegacy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}

// ROR Label 979
if((isLegacy != 0) != (isLegacy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 979);
}
if( isLegacy==0 ){
          rc = renameResolveTrigger(&sParse);
        }
        
// ABS Label 980
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}

// ROR Label 981
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 981);
}
if( rc==SQLITE_OK ){
          int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);
          int i2 = sqlite3FindDbName(db, zDb);
          
// ABS Label 982
if(i1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}
// ABS Label 983
if(i2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 983);
}

// ROR Label 984
if((i1 != i2) != (i1 == i2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 984);
}
if( i1==i2 ) { 
// ABS Label 985
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}
sqlite3_result_int(context, 1);
}
        }
      };}

    }

    
// ABS Label 986
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 986);
}
// ABS Label 987
if(zWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 987);
}

// COR Label 988
if((rc != 0 || zWhen) != (rc != 0 && zWhen))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 988);
}

// ROR Label 989
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 989);
}

// MCC Label 990
if(rc != 0 && zWhen ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 990);
}
// MCC Label 991
if(rc != 0 && !(zWhen) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 991);
}
// MCC Label 992
if(!(rc != 0) && zWhen ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 992);
}
// MCC Label 993
if(!(rc != 0) && !(zWhen) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 993);
}
if( rc!=SQLITE_OK && zWhen ){
      
// ABS Label 994
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 994);
}

// ABS Label 995
if(zWhen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 995);
}

// ABS Label 996
if(argv[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 996);
}

// ABS Label 997
if(argv[3] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}
renameColumnParseError(context, zWhen, argv[2], argv[3],&sParse);
    }
    renameParseCleanup(&sParse);
  }

#ifndef SQLITE_OMIT_AUTHORIZATION
  db->xAuth = xAuth;
#endif
}

/*
** The implementation of internal UDF sqlite_drop_column().
** 
** Arguments:
**
**  argv[0]: An integer - the index of the schema containing the table
**  argv[1]: CREATE TABLE statement to modify.
**  argv[2]: An integer - the index of the column to remove.
**
** The value returned is a string containing the CREATE TABLE statement
** with column argv[2] removed.
*/
static void dropColumnFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  int iSchema = sqlite3_value_int(argv[0]);
  const char *zSql = (const char*)sqlite3_value_text(argv[1]);
  int iCol = sqlite3_value_int(argv[2]);
  const char *zDb = db->aDb[iSchema].zDbSName;
  int rc;
  Parse sParse;
  RenameToken *pCol;
  Table *pTab;
  const char *zEnd;
  char *zNew = 0;

#ifndef SQLITE_OMIT_AUTHORIZATION
  
// ABS Label 998
if(db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}
sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;
#endif

  UNUSED_PARAMETER(NotUsed);
  rc = renameParseSql(&sParse, zDb, db, zSql, iSchema==1);
  
// ABS Label 1000
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}

// ROR Label 1001
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1001);
}
if( rc!=SQLITE_OK ) { goto drop_column_done;
}
  pTab = sParse.pNewTable;
  
// ABS Label 1002
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}
// ABS Label 1003
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// COR Label 1004
if((pTab == 0 || pTab->nCol == 1 && iCol >= pTab->nCol) != (pTab == 0 || pTab->nCol == 1 || iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1004);
}
// COR Label 1005
if((pTab == 0 && pTab->nCol == 1) != (pTab == 0 || pTab->nCol == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1005);
}

// ROR Label 1006
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1006);
}
// ROR Label 1007
if((pTab->nCol != 1) != (pTab->nCol == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1007);
}
// ROR Label 1008
if((iCol < pTab->nCol) != (iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1008);
}
// ROR Label 1009
if((iCol > pTab->nCol) != (iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1009);
}
// ROR Label 1010
if((iCol <= pTab->nCol) != (iCol >= pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1010);
}

// MCC Label 1011
if(pTab == 0 && pTab->nCol == 1 && iCol >= pTab->nCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1011);
}
// MCC Label 1012
if(pTab == 0 && pTab->nCol == 1 && !(iCol >= pTab->nCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1012);
}
// MCC Label 1013
if(pTab == 0 && !(pTab->nCol == 1) && iCol >= pTab->nCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1013);
}
// MCC Label 1014
if(pTab == 0 && !(pTab->nCol == 1) && !(iCol >= pTab->nCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1014);
}
// MCC Label 1015
if(!(pTab == 0) && pTab->nCol == 1 && iCol >= pTab->nCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1015);
}
// MCC Label 1016
if(!(pTab == 0) && pTab->nCol == 1 && !(iCol >= pTab->nCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1016);
}
// MCC Label 1017
if(!(pTab == 0) && !(pTab->nCol == 1) && iCol >= pTab->nCol ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1017);
}
// MCC Label 1018
if(!(pTab == 0) && !(pTab->nCol == 1) && !(iCol >= pTab->nCol) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1018);
}
if( pTab==0 || pTab->nCol==1 || iCol>=pTab->nCol ){ 
    /* This can happen if the sqlite_schema table is corrupt */
    rc = SQLITE_CORRUPT_BKPT;
    goto drop_column_done;
  }

  pCol = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol].zName);
  
// ABS Label 1019
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}

// AOR Label 1020
if(pTab->nCol / 1 != pTab->nCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1020);
}
// AOR Label 1021
if(pTab->nCol + 1 != pTab->nCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1021);
}
// AOR Label 1022
if(pTab->nCol * 1 != pTab->nCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1022);
}

// ROR Label 1023
if((iCol <= pTab->nCol - 1) != (iCol < pTab->nCol - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1023);
}
// ROR Label 1024
if((iCol > pTab->nCol - 1) != (iCol < pTab->nCol - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1024);
}
// ROR Label 1025
if((iCol >= pTab->nCol - 1) != (iCol < pTab->nCol - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1025);
}
if( iCol<pTab->nCol-1 ){
    RenameToken *pEnd;
    pEnd = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol+1].zName);
    zEnd = (const char*)pEnd->t.z;
  }else{
    zEnd = (const char*)&zSql[pTab->addColOffset];
    
// COR Label 1026
if(((pCol->t.z[0] != 0) || pCol->t.z[0] != ',') != ((pCol->t.z[0] != 0) && pCol->t.z[0] != ','))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1026);
}

// ROR Label 1027
if((pCol->t.z[0] == ',') != (pCol->t.z[0] != ','))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1027);
}

// MCC Label 1028
if(( pCol->t.z[0] != 0 ) && pCol->t.z[0] != ',' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1028);
}
// MCC Label 1029
if(( pCol->t.z[0] != 0 ) && !(pCol->t.z[0] != ',') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1029);
}
// MCC Label 1030
if(( !(pCol->t.z[0] != 0) ) && pCol->t.z[0] != ',' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1030);
}
// MCC Label 1031
if(( !(pCol->t.z[0] != 0) ) && !(pCol->t.z[0] != ',') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1031);
}
while( ALWAYS(pCol->t.z[0]!=0) && pCol->t.z[0]!=',' ) { pCol->t.z--;
};
// COR Label 1032
if(((pCol->t.z[0] != 0) || pCol->t.z[0] != ',') != ((pCol->t.z[0] != 0) && pCol->t.z[0] != ','))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1032);
}

// ROR Label 1033
if((pCol->t.z[0] == ',') != (pCol->t.z[0] != ','))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1033);
}

// MCC Label 1034
if(( pCol->t.z[0] != 0 ) && pCol->t.z[0] != ',' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1034);
}
// MCC Label 1035
if(( pCol->t.z[0] != 0 ) && !(pCol->t.z[0] != ',') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1035);
}
// MCC Label 1036
if(( !(pCol->t.z[0] != 0) ) && pCol->t.z[0] != ',' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1036);
}
// MCC Label 1037
if(( !(pCol->t.z[0] != 0) ) && !(pCol->t.z[0] != ',') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1037);
}

  }

  zNew = sqlite3MPrintf(db, "%.*s%s", pCol->t.z-zSql, zSql, zEnd);
  
// ABS Label 999
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}
sqlite3_result_text(context, zNew, -1, SQLITE_TRANSIENT);
  sqlite3_free(zNew);

drop_column_done:
  renameParseCleanup(&sParse);
#ifndef SQLITE_OMIT_AUTHORIZATION
  db->xAuth = xAuth;
#endif
  
// ABS Label 1038
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1038);
}

// ROR Label 1039
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1039);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 1040
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1040);
}

// ABS Label 1041
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}
sqlite3_result_error_code(context, rc);
  }
}

/*
** This function is called by the parser upon parsing an 
**
**     ALTER TABLE pSrc DROP COLUMN pName
**
** statement. Argument pSrc contains the possibly qualified name of the
** table being edited, and token pName the name of the column to drop.
*/
void sqlite3AlterDropColumn(Parse *pParse, SrcList *pSrc, Token *pName){
  
// ABS Label 1042
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}
sqlite3 *db = pParse->db;       /* Database handle */
  Table *pTab;                    /* Table to modify */
  int iDb;                        /* Index of db containing pTab in aDb[] */
  const char *zDb;                /* Database containing pTab ("main" etc.) */
  char *zCol = 0;                 /* Name of column to drop */
  int iCol;                       /* Index of column zCol in pTab->aCol[] */

  /* Look up the table being altered. */
  assert( pParse->pNewTable==0 );
  assert( sqlite3BtreeHoldsAllMutexes(db) );
  
// ABS Label 1064
if((db->mallocFailed) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1064);
}
if( NEVER(db->mallocFailed) ) { goto exit_drop_column;
}
  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) { goto exit_drop_column;
}

  /* Make sure this is not an attempt to ALTER a view, virtual table or 
  ** system table. */
  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) { goto exit_drop_column;
}
  if( SQLITE_OK!=isRealTable(pParse, pTab, 1) ) { goto exit_drop_column;
}

  /* Find the index of the column being dropped. */
  zCol = sqlite3NameFromToken(db, pName);
  
// ABS Label 1065
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1065);
}

// ROR Label 1066
if((zCol != 0) != (zCol == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1066);
}
if( zCol==0 ){
    assert( db->mallocFailed );
    goto exit_drop_column;
  }
  iCol = sqlite3ColumnIndex(pTab, zCol);
  
// ABS Label 1067
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}

// ROR Label 1068
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1068);
}
// ROR Label 1069
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1069);
}
// ROR Label 1070
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1070);
}
if( iCol<0 ){
    
// ABS Label 1071
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1071);
}

// ABS Label 1072
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1072);
}
sqlite3ErrorMsg(pParse, "no such column: \"%s\"", zCol);
    goto exit_drop_column;
  }

  /* Do not allow the user to drop a PRIMARY KEY column or a column 
  ** constrained by a UNIQUE constraint.  */
  
// AOR Label 1073
if(pTab->aCol[iCol].colFlags | (1 | 8) != pTab->aCol[iCol].colFlags & (1 | 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1073);
}
// AOR Label 1074
if(pTab->aCol[iCol].colFlags ^ (1 | 8) != pTab->aCol[iCol].colFlags & (1 | 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1074);
}
if( pTab->aCol[iCol].colFlags & (COLFLAG_PRIMKEY|COLFLAG_UNIQUE) ){
    
// ABS Label 1075
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1075);
}

// ABS Label 1076
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1076);
}
sqlite3ErrorMsg(pParse, "cannot drop %s column: \"%s\"", 
        (pTab->aCol[iCol].colFlags&COLFLAG_PRIMKEY) ? "PRIMARY KEY" : "UNIQUE",
        zCol
    );
    goto exit_drop_column;
  }

  /* Do not allow the number of columns to go to zero */
  
// ROR Label 1077
if((pTab->nCol < 1) != (pTab->nCol <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1077);
}
// ROR Label 1078
if((pTab->nCol > 1) != (pTab->nCol <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1078);
}
// ROR Label 1079
if((pTab->nCol >= 1) != (pTab->nCol <= 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1079);
}
if( pTab->nCol<=1 ){
    
// ABS Label 1080
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}

// ABS Label 1081
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1081);
}
sqlite3ErrorMsg(pParse, "cannot drop column \"%s\": no other columns exist",zCol);
    goto exit_drop_column;
  }

  /* Edit the sqlite_schema table */
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  assert( iDb>=0 );
  zDb = db->aDb[iDb].zDbSName;
  
// ABS Label 1043
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}

// ABS Label 1044
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// ABS Label 1045
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1045);
}

// ROR Label 1046
if((iDb != 1) != (iDb == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1046);
}
renameTestSchema(pParse, zDb, iDb==1, "", 0);
  
// ABS Label 1047
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1047);
}

// ABS Label 1048
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}

// ABS Label 1049
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}

// ROR Label 1050
if((iDb != 1) != (iDb == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1050);
}
renameFixQuotes(pParse, zDb, iDb==1);
  
// ABS Label 1051
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}

// ABS Label 1052
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}

// ABS Label 1053
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}

// ABS Label 1054
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}

// ABS Label 1055
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}
sqlite3NestedParse(pParse, 
      "UPDATE \"%w\"." DFLT_SCHEMA_TABLE " SET "
      "sql = sqlite_drop_column(%d, sql, %d) "
      "WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)"
      , zDb, iDb, iCol, pTab->zName
  );

  /* Drop and reload the database schema. */
  
// ABS Label 1056
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1056);
}

// ABS Label 1057
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}
renameReloadSchema(pParse, iDb, INITFLAG_AlterDrop);
  
// ABS Label 1058
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}

// ABS Label 1059
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1059);
}

// ABS Label 1060
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1060);
}

// ROR Label 1061
if((iDb != 1) != (iDb == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1061);
}
renameTestSchema(pParse, zDb, iDb==1, "after drop column", 1);

  /* Edit rows of table on disk */
  
// ABS Label 1082
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1082);
}

// COR Label 1083
if((pParse->nErr == 0 || (pTab->aCol[iCol].colFlags & 32) == 0) != (pParse->nErr == 0 && (pTab->aCol[iCol].colFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1083);
}

// ROR Label 1084
if((pParse->nErr != 0) != (pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1084);
}
// ROR Label 1085
if(((pTab->aCol[iCol].colFlags & 32) != 0) != ((pTab->aCol[iCol].colFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1085);
}

// MCC Label 1086
if(pParse->nErr == 0 && (pTab->aCol[iCol].colFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1086);
}
// MCC Label 1087
if(pParse->nErr == 0 && !((pTab->aCol[iCol].colFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1087);
}
// MCC Label 1088
if(!(pParse->nErr == 0) && (pTab->aCol[iCol].colFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1088);
}
// MCC Label 1089
if(!(pParse->nErr == 0) && !((pTab->aCol[iCol].colFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1089);
}
if( pParse->nErr==0 && (pTab->aCol[iCol].colFlags & COLFLAG_VIRTUAL)==0 ){
    int i;
    int addr;
    int reg;
    int regRec;
    Index *pPk = 0;
    int nField = 0;               /* Number of non-virtual columns after drop */
    int iCur;
    Vdbe *v = sqlite3GetVdbe(pParse);
    iCur = pParse->nTab++;
    
// ABS Label 1090
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}

// ABS Label 1091
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}

// ABS Label 1092
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// ABS Label 1093
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1093);
}
sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenWrite);
    addr = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);
    reg = ++pParse->nMem;
    
// MCC Label 1110
if(( ((pTab)->tabFlags & 128) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1110);
}
// MCC Label 1111
if(( !(((pTab)->tabFlags & 128) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1111);
}
if( HasRowid(pTab) ){
      
// ABS Label 1112
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1112);
}

// ABS Label 1113
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1113);
}

// ABS Label 1114
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1114);
}
sqlite3VdbeAddOp2(v, OP_Rowid, iCur, reg);
      pParse->nMem += pTab->nCol;
    }else{
      pPk = sqlite3PrimaryKeyIndex(pTab);
      pParse->nMem += pPk->nColumn;
      i = 0;

// ABS Label 1115
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1115);
}

// ROR Label 1116
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1116);
}
// ROR Label 1117
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1117);
}
// ROR Label 1118
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1118);
}
for(; i<pPk->nKeyCol; i++){
        
// ABS Label 1123
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1123);
}

// ABS Label 1124
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1124);
}

// ABS Label 1125
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1125);
}

// ABS Label 1126
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1126);
}
// ABS Label 1127
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}

// AOR Label 1128
if(reg + i - 1 != reg + i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1128);
}
// AOR Label 1129
if(reg + i / 1 != reg + i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1129);
}
// AOR Label 1130
if(reg + i * 1 != reg + i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1130);
}
// AOR Label 1131
if(reg - i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1131);
}
// AOR Label 1132
if(reg / i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1132);
}
// AOR Label 1133
if(reg * i != reg + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1133);
}
sqlite3VdbeAddOp3(v, OP_Column, iCur, i, reg+i+1);
      };
// ABS Label 1119
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1119);
}

// ROR Label 1120
if((i <= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1120);
}
// ROR Label 1121
if((i > pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1121);
}
// ROR Label 1122
if((i >= pPk->nKeyCol) != (i < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1122);
}

      nField = pPk->nKeyCol;
    }
    regRec = ++pParse->nMem;
    i = 0;

// ABS Label 1134
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}

// ROR Label 1135
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1135);
}
// ROR Label 1136
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1136);
}
// ROR Label 1137
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1137);
}
for(; i<pTab->nCol; i++){
      
// ABS Label 1142
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1142);
}
// ABS Label 1143
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1143);
}

// COR Label 1144
if((i != iCol || (pTab->aCol[i].colFlags & 32) == 0) != (i != iCol && (pTab->aCol[i].colFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1144);
}

// ROR Label 1145
if((i == iCol) != (i != iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1145);
}
// ROR Label 1146
if(((pTab->aCol[i].colFlags & 32) != 0) != ((pTab->aCol[i].colFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1146);
}

// MCC Label 1147
if(i != iCol && (pTab->aCol[i].colFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1147);
}
// MCC Label 1148
if(i != iCol && !((pTab->aCol[i].colFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1148);
}
// MCC Label 1149
if(!(i != iCol) && (pTab->aCol[i].colFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1149);
}
// MCC Label 1150
if(!(i != iCol) && !((pTab->aCol[i].colFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1150);
}
if( i!=iCol && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){
        int regOut;
        
// ABS Label 1151
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1151);
}
if( pPk ){
          int iPos = sqlite3TableColumnToIndex(pPk, i);
          int iColPos = sqlite3TableColumnToIndex(pPk, iCol);
          
// ABS Label 1152
if(iPos < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}

// ROR Label 1153
if((iPos <= pPk->nKeyCol) != (iPos < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1153);
}
// ROR Label 1154
if((iPos > pPk->nKeyCol) != (iPos < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1154);
}
// ROR Label 1155
if((iPos >= pPk->nKeyCol) != (iPos < pPk->nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1155);
}
if( iPos<pPk->nKeyCol ) { continue;
}
          regOut = reg+1+iPos-(iPos>iColPos);
        }else{
          regOut = reg+1+nField;
        }
        
// ABS Label 1156
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}

// ROR Label 1157
if((i != pTab->iPKey) != (i == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1157);
}
if( i==pTab->iPKey ){
          
// ABS Label 1158
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1158);
}

// ABS Label 1159
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1159);
}
sqlite3VdbeAddOp2(v, OP_Null, 0, regOut);
        }else{
          
// ABS Label 1160
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1160);
}

// ABS Label 1161
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1161);
}

// ABS Label 1162
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1162);
}

// ABS Label 1163
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}

// ABS Label 1164
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1164);
}
sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);
        }
        nField++;
      }
    };
// ABS Label 1138
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1138);
}

// ROR Label 1139
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1139);
}
// ROR Label 1140
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1140);
}
// ROR Label 1141
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1141);
}

    
// ABS Label 1094
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1094);
}

// ABS Label 1095
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}

// AOR Label 1096
if(reg - 1 != reg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1096);
}
// AOR Label 1097
if(reg / 1 != reg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1097);
}
// AOR Label 1098
if(reg * 1 != reg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1098);
}

// ABS Label 1099
if(nField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}

// ABS Label 1100
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, reg+1, nField, regRec);
    
// ABS Label 1165
if(pPk < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1165);
}
if( pPk ){
      
// ABS Label 1166
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1166);
}

// ABS Label 1167
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1167);
}

// ABS Label 1168
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1168);
}

// ABS Label 1169
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1169);
}

// AOR Label 1170
if(reg - 1 != reg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1170);
}
// AOR Label 1171
if(reg / 1 != reg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1171);
}
// AOR Label 1172
if(reg * 1 != reg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1172);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iCur, regRec, reg+1, pPk->nKeyCol);
    }else{
      
// ABS Label 1173
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1173);
}

// ABS Label 1174
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1174);
}

// ABS Label 1175
if(regRec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}

// ABS Label 1176
if(reg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1176);
}
sqlite3VdbeAddOp3(v, OP_Insert, iCur, regRec, reg);
    }
    
// ABS Label 1101
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}
sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);

    
// ABS Label 1102
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1102);
}

// ABS Label 1103
if(iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1103);
}

// ABS Label 1104
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}

// AOR Label 1105
if(addr - 1 != addr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1105);
}
// AOR Label 1106
if(addr / 1 != addr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1106);
}
// AOR Label 1107
if(addr * 1 != addr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1107);
}
sqlite3VdbeAddOp2(v, OP_Next, iCur, addr+1); VdbeCoverage(v);
    
// ABS Label 1108
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1108);
}

// ABS Label 1109
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1109);
}
sqlite3VdbeJumpHere(v, addr);
  }

exit_drop_column:
  sqlite3DbFree(db, zCol);
  
// ABS Label 1062
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1062);
}

// ABS Label 1063
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1063);
}
sqlite3SrcListDelete(db, pSrc);
}

/*
** Register built-in functions used to help implement ALTER TABLE
*/
void sqlite3AlterFunctions(void){
  static FuncDef aAlterTableFuncs[] = {
    INTERNAL_FUNCTION(sqlite_rename_column,  9, renameColumnFunc),
    INTERNAL_FUNCTION(sqlite_rename_table,   7, renameTableFunc),
    INTERNAL_FUNCTION(sqlite_rename_test,    7, renameTableTest),
    INTERNAL_FUNCTION(sqlite_drop_column,    3, dropColumnFunc),
    INTERNAL_FUNCTION(sqlite_rename_quotefix,2, renameQuotefixFunc),
  };
  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ArraySize(aAlterTableFuncs));
}
#endif  /* SQLITE_ALTER_TABLE */
