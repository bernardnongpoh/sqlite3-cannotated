/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2005 May 25
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the implementation of the sqlite3_prepare()
** interface, and routines that contribute to loading the database schema
** from disk.
*/
#include "sqliteInt.h"

/*
** Fill the InitData structure with an error message that indicates
** that the database is corrupt.
*/
static void corruptSchema(
  InitData *pData,     /* Initialization context */
  char **azObj,        /* Type and name of object being parsed */
  const char *zExtra   /* Error information */
){
  
// ABS Label 7
if(pData->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
sqlite3 *db = pData->db;
  
// ABS Label 8
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
if( db->mallocFailed ){
    pData->rc = SQLITE_NOMEM_BKPT;
  }else { 
// ABS Label 9
if(pData->pzErrMsg[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

// ROR Label 10
if((pData->pzErrMsg[0] == 0) != (pData->pzErrMsg[0] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( pData->pzErrMsg[0]!=0 ){
    /* A error message has already been generated.  Do not overwrite it */
  }else { 
// ABS Label 11
if(pData->mInitFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// AOR Label 12
if(pData->mInitFlags | (1 | 2) != pData->mInitFlags & (1 | 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 12);
}
// AOR Label 13
if(pData->mInitFlags ^ (1 | 2) != pData->mInitFlags & (1 | 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 13);
}
if( pData->mInitFlags & (INITFLAG_AlterRename|INITFLAG_AlterDrop) ){
    *pData->pzErrMsg = sqlite3MPrintf(db, 
        "error in %s %s after %s: %s", azObj[0], azObj[1], 
        (pData->mInitFlags & INITFLAG_AlterRename) ? "rename" : "drop column",
        zExtra
    );
    pData->rc = SQLITE_ERROR;
  }else { 
// ABS Label 14
if(db->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// AOR Label 15
if(db->flags | 1 != db->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 15);
}
// AOR Label 16
if(db->flags ^ 1 != db->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 16);
}
if( db->flags & SQLITE_WriteSchema ){
    pData->rc = SQLITE_CORRUPT_BKPT;
  }else{
    char *z;
    const char *zObj = azObj[1] ? azObj[1] : "?";
    z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
    
// ABS Label 17
if(zExtra < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// COR Label 18
if((zExtra || zExtra[0]) != (zExtra && zExtra[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 18);
}

// MCC Label 19
if(zExtra && zExtra[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 19);
}
// MCC Label 20
if(zExtra && !(zExtra[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 20);
}
// MCC Label 21
if(!(zExtra) && zExtra[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 21);
}
// MCC Label 22
if(!(zExtra) && !(zExtra[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 22);
}
if( zExtra && zExtra[0] ) { z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
}
    *pData->pzErrMsg = z;
    pData->rc = SQLITE_CORRUPT_BKPT;
  };}
;}
;}

}

/*
** Check to see if any sibling index (another index on the same table)
** of pIndex has the same root page number, and if it does, return true.
** This would indicate a corrupt schema.
*/
int sqlite3IndexHasDuplicateRootPage(Index *pIndex){
  Index *p;
  p = pIndex->pTable->pIndex;

// ABS Label 23
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
for(; p; p=p->pNext){
    
// ABS Label 25
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
// ABS Label 26
if(p->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
// ABS Label 27
if(pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
// ABS Label 28
if(pIndex->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// COR Label 29
if((p->tnum == pIndex->tnum || p != pIndex) != (p->tnum == pIndex->tnum && p != pIndex))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 29);
}

// ROR Label 30
if((p->tnum != pIndex->tnum) != (p->tnum == pIndex->tnum))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
// ROR Label 31
if((p == pIndex) != (p != pIndex))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}

// MCC Label 32
if(p->tnum == pIndex->tnum && p != pIndex ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 32);
}
// MCC Label 33
if(p->tnum == pIndex->tnum && !(p != pIndex) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 33);
}
// MCC Label 34
if(!(p->tnum == pIndex->tnum) && p != pIndex ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 34);
}
// MCC Label 35
if(!(p->tnum == pIndex->tnum) && !(p != pIndex) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
if( p->tnum==pIndex->tnum && p!=pIndex ) { return 1;
}
  };
// ABS Label 24
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

  return 0;
}

/* forward declaration */
static int sqlite3Prepare(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
  Vdbe *pReprepare,         /* VM being reprepared */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
);


/*
** This is the callback routine for the code that initializes the
** database.  See sqlite3Init() below for additional information.
** This routine is also called from the OP_ParseSchema opcode of the VDBE.
**
** Each callback contains the following information:
**
**     argv[0] = type of object: "table", "index", "trigger", or "view".
**     argv[1] = name of thing being created
**     argv[2] = associated table if an index or trigger
**     argv[3] = root page number for table or index. 0 for trigger or view.
**     argv[4] = SQL text for the CREATE statement.
**
*/
int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){
  InitData *pData = (InitData*)pInit;
  
// ABS Label 36
if(pData->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}
sqlite3 *db = pData->db;
  
// ABS Label 37
if(pData->iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}
int iDb = pData->iDb;

  assert( argc==5 );
  UNUSED_PARAMETER2(NotUsed, argc);
  assert( sqlite3_mutex_held(db->mutex) );
  db->mDbFlags |= DBFLAG_EncodingFixed;
  
// ABS Label 38
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}

// ROR Label 39
if((argv != 0) != (argv == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
if( argv==0 ) { return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */
}
  pData->nInitRow++;
  
// ABS Label 40
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}
if( db->mallocFailed ){
    
// ABS Label 41
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// ABS Label 42
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}
corruptSchema(pData, argv, 0);
    return 1;
  }

  assert( iDb>=0 && iDb<db->nDb );
  
// ABS Label 43
if(argv[3] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// ROR Label 44
if((argv[3] != 0) != (argv[3] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
if( argv[3]==0 ){
    
// ABS Label 45
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// ABS Label 46
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
corruptSchema(pData, argv, 0);
  }else { 
// ABS Label 47
if(argv[4] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// COR Label 48
if((argv[4] && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]] || 'r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]) != (argv[4] && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]] && 'r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 48);
}
// COR Label 49
if((argv[4] || 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]) != (argv[4] && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 49);
}

// ROR Label 50
if(('c' != sqlite3UpperToLower[(unsigned char)argv[4][0]]) != ('c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
// ROR Label 51
if(('r' != sqlite3UpperToLower[(unsigned char)argv[4][1]]) != ('r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}

// MCC Label 52
if(argv[4] && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]] && 'r' == sqlite3UpperToLower[(unsigned char)argv[4][1]] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 52);
}
// MCC Label 53
if(argv[4] && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]] && !('r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(argv[4] && !('c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]) && 'r' == sqlite3UpperToLower[(unsigned char)argv[4][1]] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(argv[4] && !('c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]) && !('r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(argv[4]) && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]] && 'r' == sqlite3UpperToLower[(unsigned char)argv[4][1]] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
// MCC Label 57
if(!(argv[4]) && 'c' == sqlite3UpperToLower[(unsigned char)argv[4][0]] && !('r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
// MCC Label 58
if(!(argv[4]) && !('c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]) && 'r' == sqlite3UpperToLower[(unsigned char)argv[4][1]] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 58);
}
// MCC Label 59
if(!(argv[4]) && !('c' == sqlite3UpperToLower[(unsigned char)argv[4][0]]) && !('r' == sqlite3UpperToLower[(unsigned char)argv[4][1]]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
if( argv[4]
         && 'c'==sqlite3UpperToLower[(unsigned char)argv[4][0]]
         && 'r'==sqlite3UpperToLower[(unsigned char)argv[4][1]] ){
    /* Call the parser to process a CREATE TABLE, INDEX or VIEW.
    ** But because db->init.busy is set to 1, no VDBE code is generated
    ** or executed.  All the parser does is build the internal data
    ** structures that describe the table, index, or view.
    **
    ** No other valid SQL statement, other than the variable CREATE statements,
    ** can begin with the letters "C" and "R".  Thus, it is not possible run
    ** any other kind of statement while parsing the schema, even a corrupt
    ** schema.
    */
    int rc;
    
// ABS Label 60
if(db->init.iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
u8 saved_iDb = db->init.iDb;
    sqlite3_stmt *pStmt;
    TESTONLY(int rcp);            /* Return code from sqlite3_prepare() */

    assert( db->init.busy );
    db->init.iDb = iDb;
    if( sqlite3GetUInt32(argv[3], &db->init.newTnum)==0
     || (db->init.newTnum>pData->mxPage && pData->mxPage>0)
    ){
      
// ABS Label 63
if(sqlite3Config.bExtraSchemaChecks < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}
if( sqlite3Config.bExtraSchemaChecks ){
        
// ABS Label 64
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}

// ABS Label 65
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
corruptSchema(pData, argv, "invalid rootpage");
      }
    }
    db->init.orphanTrigger = 0;
    db->init.azInit = argv;
    pStmt = 0;
    TESTONLY(rcp = ) 
// ABS Label 61
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
sqlite3Prepare(db, argv[4], -1, 0, 0, &pStmt, 0);
    rc = db->errCode;
    assert( (rc&0xFF)==(rcp&0xFF) );
    db->init.iDb = saved_iDb;
    /* assert( saved_iDb==0 || (db->mDbFlags & DBFLAG_Vacuum)!=0 ); */
    
// ABS Label 66
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}

// ROR Label 67
if((0 == rc) != (0 != rc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
if( SQLITE_OK!=rc ){
      
// ABS Label 68
if(db->init.orphanTrigger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}
if( db->init.orphanTrigger ){
        assert( iDb==1 );
      }else{
        
// ABS Label 69
if(pData->rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}
// ABS Label 70
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((rc <= pData->rc) != (rc > pData->rc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
// ROR Label 72
if((rc < pData->rc) != (rc > pData->rc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}
// ROR Label 73
if((rc >= pData->rc) != (rc > pData->rc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
if( rc > pData->rc ) { pData->rc = rc;
}
        
// ABS Label 74
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}

// ROR Label 75
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
if( rc==SQLITE_NOMEM ){
          
// ABS Label 76
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
sqlite3OomFault(db);
        }else { 
// ABS Label 77
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// COR Label 78
if((rc != 9 || (rc & 255) != 6) != (rc != 9 && (rc & 255) != 6))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 78);
}

// ROR Label 79
if((rc == 9) != (rc != 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
// ROR Label 80
if(((rc & 255) == 6) != ((rc & 255) != 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}

// MCC Label 81
if(rc != 9 && (rc & 255) != 6 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 81);
}
// MCC Label 82
if(rc != 9 && !((rc & 255) != 6) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
// MCC Label 83
if(!(rc != 9) && (rc & 255) != 6 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
// MCC Label 84
if(!(rc != 9) && !((rc & 255) != 6) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 84);
}
if( rc!=SQLITE_INTERRUPT && (rc&0xFF)!=SQLITE_LOCKED ){
          
// ABS Label 85
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}

// ABS Label 86
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
corruptSchema(pData, argv, sqlite3_errmsg(db));
        };}

      }
    }
    
// ABS Label 62
if(pStmt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}
sqlite3_finalize(pStmt);
  }else { 
// ABS Label 87
if(argv[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// COR Label 88
if((argv[1] == 0 && (argv[4] != 0 && argv[4][0] != 0)) != (argv[1] == 0 || (argv[4] != 0 && argv[4][0] != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 88);
}

// ROR Label 89
if((argv[1] != 0) != (argv[1] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 89);
}

// MCC Label 90
if(argv[1] == 0 && ( argv[4] != 0 && argv[4][0] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}
// MCC Label 91
if(argv[1] == 0 && ( argv[4] != 0 && !(argv[4][0] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 91);
}
// MCC Label 92
if(argv[1] == 0 && ( !(argv[4] != 0) && argv[4][0] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 92);
}
// MCC Label 93
if(argv[1] == 0 && ( !(argv[4] != 0) && !(argv[4][0] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 93);
}
// MCC Label 94
if(!(argv[1] == 0) && ( argv[4] != 0 && argv[4][0] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(!(argv[1] == 0) && ( argv[4] != 0 && !(argv[4][0] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(!(argv[1] == 0) && ( !(argv[4] != 0) && argv[4][0] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(!(argv[1] == 0) && ( !(argv[4] != 0) && !(argv[4][0] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){
    
// ABS Label 98
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}

// ABS Label 99
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
corruptSchema(pData, argv, 0);
  }else{
    /* If the SQL column is blank it means this is an index that
    ** was created to be the PRIMARY KEY or to fulfill a UNIQUE
    ** constraint for a CREATE TABLE.  The index should have already
    ** been created when we processed the CREATE TABLE.  All we have
    ** to do here is record the root page number for that index.
    */
    Index *pIndex;
    pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);
    
// ABS Label 100
if(pIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}

// ROR Label 101
if((pIndex != 0) != (pIndex == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 101);
}
if( pIndex==0 ){
      
// ABS Label 102
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}

// ABS Label 103
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
corruptSchema(pData, argv, "orphan index");
    }else {
    if( sqlite3GetUInt32(argv[3],&pIndex->tnum)==0
     || pIndex->tnum<2
     || pIndex->tnum>pData->mxPage
     || sqlite3IndexHasDuplicateRootPage(pIndex)
    ){
      
// ABS Label 104
if(sqlite3Config.bExtraSchemaChecks < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
if( sqlite3Config.bExtraSchemaChecks ){
        
// ABS Label 105
if(pData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// ABS Label 106
if(argv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}
corruptSchema(pData, argv, "invalid rootpage");
      }
    };}

  };}
;}

  return 0;
}

/*
** Attempt to read the database schema and initialize internal
** data structures for a single database file.  The index of the
** database file is given by iDb.  iDb==0 is used for the main
** database.  iDb==1 should never be used.  iDb>=2 is used for
** auxiliary databases.  Return one of the SQLITE_ error codes to
** indicate success or failure.
*/
int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg, u32 mFlags){
  int rc;
  int i;
#ifndef SQLITE_OMIT_DEPRECATED
  int size;
#endif
  Db *pDb;
  char const *azArg[6];
  int meta[5];
  InitData initData;
  const char *zSchemaTabName;
  int openedTransaction = 0;
  int mask = ((db->mDbFlags & DBFLAG_EncodingFixed) | ~DBFLAG_EncodingFixed);

  assert( (db->mDbFlags & DBFLAG_SchemaKnownOk)==0 );
  assert( iDb>=0 && iDb<db->nDb );
  assert( db->aDb[iDb].pSchema );
  assert( sqlite3_mutex_held(db->mutex) );
  assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );

  db->init.busy = 1;

  /* Construct the in-memory representation schema tables (sqlite_schema or
  ** sqlite_temp_schema) by invoking the parser directly.  The appropriate
  ** table name will be inserted automatically by the parser so we can just
  ** use the abbreviation "x" here.  The parser will also automatically tag
  ** the schema table as read-only. */
  azArg[0] = "table";
  azArg[1] = zSchemaTabName = SCHEMA_TABLE(iDb);
  azArg[2] = azArg[1];
  azArg[3] = "1";
  azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,"
                            "rootpage int,sql text)";
  azArg[5] = 0;
  initData.db = db;
  initData.iDb = iDb;
  initData.rc = SQLITE_OK;
  initData.pzErrMsg = pzErrMsg;
  initData.mInitFlags = mFlags;
  initData.nInitRow = 0;
  initData.mxPage = 0;
  sqlite3InitCallback(&initData, 5, (char **)azArg, 0);
  db->mDbFlags &= mask;
  
// ABS Label 109
if(initData.rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
if( initData.rc ){
    rc = initData.rc;
    goto error_out;
  }

  /* Create a cursor to hold the database open
  */
  pDb = &db->aDb[iDb];
  
// ABS Label 110
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// ROR Label 111
if((pDb->pBt != 0) != (pDb->pBt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 111);
}
if( pDb->pBt==0 ){
    assert( iDb==1 );
    DbSetProperty(db, 1, DB_SchemaLoaded);
    rc = SQLITE_OK;
    goto error_out;
  }

  /* If there is not already a read-only (or read-write) transaction opened
  ** on the b-tree database, open one now. If a transaction is opened, it 
  ** will be closed before this function returns.  */
  
// ABS Label 107
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
sqlite3BtreeEnter(pDb->pBt);
  if( sqlite3BtreeTxnState(pDb->pBt)==SQLITE_TXN_NONE ){
    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);
    
// ABS Label 112
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ROR Label 113
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 114
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// ABS Label 115
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));
      goto initone_error_out;
    }
    openedTransaction = 1;
  }

  /* Get the database meta information.
  **
  ** Meta values are as follows:
  **    meta[0]   Schema cookie.  Changes with each schema change.
  **    meta[1]   File format of schema layer.
  **    meta[2]   Size of the page cache.
  **    meta[3]   Largest rootpage (auto/incr_vacuum mode)
  **    meta[4]   Db text encoding. 1:UTF-8 2:UTF-16LE 3:UTF-16BE
  **    meta[5]   User version
  **    meta[6]   Incremental vacuum mode
  **    meta[7]   unused
  **    meta[8]   unused
  **    meta[9]   unused
  **
  ** Note: The #defined SQLITE_UTF* symbols in sqliteInt.h correspond to
  ** the possible values of meta[4].
  */
  i = 0;

// ABS Label 116
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ROR Label 117
if((i <= ((int)(sizeof (meta) / sizeof (meta[0])))) != (i < ((int)(sizeof (meta) / sizeof (meta[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
// ROR Label 118
if((i > ((int)(sizeof (meta) / sizeof (meta[0])))) != (i < ((int)(sizeof (meta) / sizeof (meta[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
// ROR Label 119
if((i >= ((int)(sizeof (meta) / sizeof (meta[0])))) != (i < ((int)(sizeof (meta) / sizeof (meta[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
for(; i<ArraySize(meta); i++){
    
// ABS Label 124
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}

// ABS Label 125
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}

// AOR Label 126
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 126);
}
// AOR Label 127
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 127);
}
// AOR Label 128
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 128);
}
sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);
  };
// ABS Label 120
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}

// ROR Label 121
if((i <= ((int)(sizeof (meta) / sizeof (meta[0])))) != (i < ((int)(sizeof (meta) / sizeof (meta[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
// ROR Label 122
if((i > ((int)(sizeof (meta) / sizeof (meta[0])))) != (i < ((int)(sizeof (meta) / sizeof (meta[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
// ROR Label 123
if((i >= ((int)(sizeof (meta) / sizeof (meta[0])))) != (i < ((int)(sizeof (meta) / sizeof (meta[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}

  
// ROR Label 129
if(((db->flags & 33554432) == 0) != ((db->flags & 33554432) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 129);
}
if( (db->flags & SQLITE_ResetDatabase)!=0 ){
    memset(meta, 0, sizeof(meta));
  }
  pDb->pSchema->schema_cookie = meta[BTREE_SCHEMA_VERSION-1];

  /* If opening a non-empty database, check the text encoding. For the
  ** main database, set sqlite3.enc to the encoding of the main database.
  ** For an attached db, it is an error if the encoding is not the same
  ** as sqlite3.enc.
  */
  
// ABS Label 130
if(meta[5 - 1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}

// AOR Label 131
if(5 / 1 != 5 - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 131);
}
// AOR Label 132
if(5 + 1 != 5 - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 132);
}
// AOR Label 133
if(5 * 1 != 5 - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 133);
}
if( meta[BTREE_TEXT_ENCODING-1] ){  /* text encoding */
    
// ABS Label 134
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}

// COR Label 135
if((iDb == 0 || (db->mDbFlags & 64) == 0) != (iDb == 0 && (db->mDbFlags & 64) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 135);
}

// ROR Label 136
if((iDb != 0) != (iDb == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 136);
}
// ROR Label 137
if(((db->mDbFlags & 64) != 0) != ((db->mDbFlags & 64) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}

// MCC Label 138
if(iDb == 0 && (db->mDbFlags & 64) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
// MCC Label 139
if(iDb == 0 && !((db->mDbFlags & 64) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 139);
}
// MCC Label 140
if(!(iDb == 0) && (db->mDbFlags & 64) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 140);
}
// MCC Label 141
if(!(iDb == 0) && !((db->mDbFlags & 64) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 141);
}
if( iDb==0 && (db->mDbFlags & DBFLAG_EncodingFixed)==0 ){
      u8 encoding;
#ifndef SQLITE_OMIT_UTF16
      /* If opening the main database, set ENC(db). */
      encoding = (u8)meta[BTREE_TEXT_ENCODING-1] & 3;
      
// ROR Label 144
if((encoding != 0) != (encoding == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( encoding==0 ) { encoding = SQLITE_UTF8;
}
#else
      encoding = SQLITE_UTF8;
#endif
      
// ABS Label 142
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}

// ABS Label 143
if(encoding < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
sqlite3SetTextEncoding(db, encoding);
    }else{
      /* If opening an attached database, the encoding much match ENC(db) */
      
// ROR Label 145
if(((meta[5 - 1] & 3) == ((db)->enc)) != ((meta[5 - 1] & 3) != ((db)->enc)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
if( (meta[BTREE_TEXT_ENCODING-1] & 3)!=ENC(db) ){
        
// ABS Label 146
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ABS Label 147
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}
sqlite3SetString(pzErrMsg, db, "attached databases must use the same"
            " text encoding as main database");
        rc = SQLITE_ERROR;
        goto initone_error_out;
      }
    }
  }
  pDb->pSchema->enc = ENC(db);

  
// ABS Label 148
if(pDb->pSchema->cache_size < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}

// ROR Label 149
if((pDb->pSchema->cache_size != 0) != (pDb->pSchema->cache_size == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 149);
}
if( pDb->pSchema->cache_size==0 ){
#ifndef SQLITE_OMIT_DEPRECATED
    size = sqlite3AbsInt32(meta[BTREE_DEFAULT_CACHE_SIZE-1]);
    
// ABS Label 152
if(size < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// ROR Label 153
if((size != 0) != (size == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 153);
}
if( size==0 ){ size = SQLITE_DEFAULT_CACHE_SIZE; }
    pDb->pSchema->cache_size = size;
#else
    pDb->pSchema->cache_size = SQLITE_DEFAULT_CACHE_SIZE;
#endif
    
// ABS Label 150
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ABS Label 151
if(pDb->pSchema->cache_size < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}
sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
  }

  /*
  ** file_format==1    Version 3.0.0.
  ** file_format==2    Version 3.1.3.  // ALTER TABLE ADD COLUMN
  ** file_format==3    Version 3.1.4.  // ditto but with non-NULL defaults
  ** file_format==4    Version 3.3.0.  // DESC indices.  Boolean constants
  */
  pDb->pSchema->file_format = (u8)meta[BTREE_FILE_FORMAT-1];
  
// ROR Label 154
if((pDb->pSchema->file_format != 0) != (pDb->pSchema->file_format == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
if( pDb->pSchema->file_format==0 ){
    pDb->pSchema->file_format = 1;
  }
  
// ROR Label 155
if((pDb->pSchema->file_format <= 4) != (pDb->pSchema->file_format > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 155);
}
// ROR Label 156
if((pDb->pSchema->file_format < 4) != (pDb->pSchema->file_format > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
// ROR Label 157
if((pDb->pSchema->file_format >= 4) != (pDb->pSchema->file_format > 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 157);
}
if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){
    
// ABS Label 158
if(pzErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// ABS Label 159
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
sqlite3SetString(pzErrMsg, db, "unsupported file format");
    rc = SQLITE_ERROR;
    goto initone_error_out;
  }

  /* Ticket #2804:  When we open a database in the newer file format,
  ** clear the legacy_file_format pragma flag so that a VACUUM will
  ** not downgrade the database and thus invalidate any descending
  ** indices that the user might have created.
  */
  
// ABS Label 160
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
// ABS Label 161
if(meta[2 - 1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}

// AOR Label 162
if(2 / 1 != 2 - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 162);
}
// AOR Label 163
if(2 + 1 != 2 - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 163);
}
// AOR Label 164
if(2 * 1 != 2 - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 164);
}

// COR Label 165
if((iDb == 0 || meta[2 - 1] >= 4) != (iDb == 0 && meta[2 - 1] >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 165);
}

// ROR Label 166
if((iDb != 0) != (iDb == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((meta[2 - 1] < 4) != (meta[2 - 1] >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((meta[2 - 1] > 4) != (meta[2 - 1] >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
// ROR Label 169
if((meta[2 - 1] <= 4) != (meta[2 - 1] >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}

// MCC Label 170
if(iDb == 0 && meta[2 - 1] >= 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
// MCC Label 171
if(iDb == 0 && !(meta[2 - 1] >= 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 171);
}
// MCC Label 172
if(!(iDb == 0) && meta[2 - 1] >= 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}
// MCC Label 173
if(!(iDb == 0) && !(meta[2 - 1] >= 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 173);
}
if( iDb==0 && meta[BTREE_FILE_FORMAT-1]>=4 ){
    db->flags &= ~(u64)SQLITE_LegacyFileFmt;
  }

  /* Read the schema information out of the schema tables
  */
  assert( db->init.busy );
  initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);
  {
    char *zSql;
    zSql = sqlite3MPrintf(db, 
        "SELECT*FROM\"%w\".%s ORDER BY rowid",
        db->aDb[iDb].zDbSName, zSchemaTabName);
#ifndef SQLITE_OMIT_AUTHORIZATION
    {
      sqlite3_xauth xAuth;
      xAuth = db->xAuth;
      db->xAuth = 0;
#endif
      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
#ifndef SQLITE_OMIT_AUTHORIZATION
      db->xAuth = xAuth;
    }
#endif
    
// ABS Label 175
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}

// ROR Label 176
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
if( rc==SQLITE_OK ) { rc = initData.rc;
}
    
// ABS Label 174
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}
sqlite3DbFree(db, zSql);
#ifndef SQLITE_OMIT_ANALYZE
    
// ABS Label 177
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}

// ROR Label 178
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}
if( rc==SQLITE_OK ){
      
// ABS Label 179
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}

// ABS Label 180
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}
sqlite3AnalysisLoad(db, iDb);
    }
#endif
  }
  assert( pDb == &(db->aDb[iDb]) );
  
// ABS Label 181
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
if( db->mallocFailed ){
    rc = SQLITE_NOMEM_BKPT;
    
// ABS Label 182
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
sqlite3ResetAllSchemasOfConnection(db);
    pDb = &db->aDb[iDb];
  }else {
  
// ABS Label 183
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}

// COR Label 184
if((rc == 0 && (db->flags & 134217728)) != (rc == 0 || (db->flags & 134217728)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 184);
}

// ROR Label 185
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}

// MCC Label 186
if(rc == 0 && ( db->flags & 134217728 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 186);
}
// MCC Label 187
if(rc == 0 && ( !(db->flags & 134217728) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}
// MCC Label 188
if(!(rc == 0) && ( db->flags & 134217728 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 188);
}
// MCC Label 189
if(!(rc == 0) && ( !(db->flags & 134217728) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 189);
}
if( rc==SQLITE_OK || (db->flags&SQLITE_NoSchemaError)){
    /* Hack: If the SQLITE_NoSchemaError flag is set, then consider
    ** the schema loaded, even if errors (other than OOM) occurred. In
    ** this situation the current sqlite3_prepare() operation will fail,
    ** but the following one will attempt to compile the supplied statement
    ** against whatever subset of the schema was loaded before the error
    ** occurred.
    **
    ** The primary purpose of this is to allow access to the sqlite_schema
    ** table even when its contents have been corrupted.
    */
    DbSetProperty(db, iDb, DB_SchemaLoaded);
    rc = SQLITE_OK;
  };}


  /* Jump here for an error that occurs after successfully allocating
  ** curMain and calling sqlite3BtreeEnter(). For an error that occurs
  ** before that point, jump to error_out.
  */
initone_error_out:
  
// ABS Label 190
if(openedTransaction < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
if( openedTransaction ){
    
// ABS Label 191
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
sqlite3BtreeCommit(pDb->pBt);
  }
  
// ABS Label 108
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
sqlite3BtreeLeave(pDb->pBt);

error_out:
  
// ABS Label 192
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
if( rc ){
    
// ABS Label 195
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}

// COR Label 196
if((rc == 7 && rc == (10 | (12 << 8))) != (rc == 7 || rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 196);
}

// ROR Label 197
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 197);
}
// ROR Label 198
if((rc != (10 | (12 << 8))) != (rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 198);
}

// MCC Label 199
if(rc == 7 && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 199);
}
// MCC Label 200
if(rc == 7 && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 200);
}
// MCC Label 201
if(!(rc == 7) && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 201);
}
// MCC Label 202
if(!(rc == 7) && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}
if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){
      
// ABS Label 203
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}
sqlite3OomFault(db);
    }
    
// ABS Label 193
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}

// ABS Label 194
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}
sqlite3ResetOneSchema(db, iDb);
  }
  db->init.busy = 0;
  
// ABS Label 204
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}
return rc;
}

/*
** Initialize all database files - the main database file, the file
** used to store temporary tables, and any additional database files
** created using ATTACH statements.  Return a success code.  If an
** error occurs, write an error message into *pzErrMsg.
**
** After a database is initialized, the DB_SchemaLoaded bit is set
** bit is set in the flags field of the Db structure. 
*/
int sqlite3Init(sqlite3 *db, char **pzErrMsg){
  int i, rc;
  int commit_internal = !(db->mDbFlags&DBFLAG_SchemaChange);
  
  assert( sqlite3_mutex_held(db->mutex) );
  assert( sqlite3BtreeHoldsMutex(db->aDb[0].pBt) );
  assert( db->init.busy==0 );
  ENC(db) = SCHEMA_ENC(db);
  assert( db->nDb>0 );
  /* Do the main schema first */
  if( !DbHasProperty(db, 0, DB_SchemaLoaded) ){
    rc = sqlite3InitOne(db, 0, pzErrMsg, 0);
    
// ABS Label 205
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}
if( rc ) { 
// ABS Label 206
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
return rc;
}
  }
  /* All other schemas after the main schema. The "temp" schema must be last */
  i = db->nDb - 1;

// ABS Label 207
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ROR Label 208
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
for(; i>0; i--){
    assert( i==1 || sqlite3BtreeHoldsMutex(db->aDb[i].pBt) );
    if( !DbHasProperty(db, i, DB_SchemaLoaded) ){
      rc = sqlite3InitOne(db, i, pzErrMsg, 0);
      
// ABS Label 215
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
if( rc ) { 
// ABS Label 216
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}
return rc;
}
    }
  };
// ABS Label 211
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}

// ROR Label 212
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 212);
}
// ROR Label 213
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 213);
}
// ROR Label 214
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 214);
}

  
// ABS Label 217
if(commit_internal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}
if( commit_internal ){
    
// ABS Label 218
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}
sqlite3CommitInternalChanges(db);
  }
  return SQLITE_OK;
}

/*
** This routine is a no-op if the database schema is already initialized.
** Otherwise, the schema is loaded. An error code is returned.
*/
int sqlite3ReadSchema(Parse *pParse){
  int rc = SQLITE_OK;
  
// ABS Label 219
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
sqlite3 *db = pParse->db;
  assert( sqlite3_mutex_held(db->mutex) );
  if( !db->init.busy ){
    rc = sqlite3Init(db, &pParse->zErrMsg);
    
// ABS Label 220
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}

// ROR Label 221
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 221);
}
if( rc!=SQLITE_OK ){
      pParse->rc = rc;
      pParse->nErr++;
    }else { 
// ABS Label 222
if(db->noSharedCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}
if( db->noSharedCache ){
      db->mDbFlags |= DBFLAG_SchemaKnownOk;
    };}

  }
  
// ABS Label 223
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 223);
}
return rc;
}


/*
** Check schema cookies in all databases.  If any cookie is out
** of date set pParse->rc to SQLITE_SCHEMA.  If all schema cookies
** make no changes to pParse->rc.
*/
static void schemaIsValid(Parse *pParse){
  
// ABS Label 224
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
sqlite3 *db = pParse->db;
  int iDb;
  int rc;
  int cookie;

  assert( pParse->checkSchema );
  assert( sqlite3_mutex_held(db->mutex) );
  iDb = 0;

// ABS Label 225
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}
// ABS Label 226
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}

// ROR Label 227
if((iDb <= db->nDb) != (iDb < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 227);
}
// ROR Label 228
if((iDb > db->nDb) != (iDb < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 228);
}
// ROR Label 229
if((iDb >= db->nDb) != (iDb < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 229);
}
for(; iDb<db->nDb; iDb++){
    int openedTransaction = 0;         /* True if a transaction is opened */
    
// ABS Label 235
if(db->aDb[iDb].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}
Btree *pBt = db->aDb[iDb].pBt;     /* Btree database to read cookie from */
    
// ABS Label 237
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}

// ROR Label 238
if((pBt != 0) != (pBt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
if( pBt==0 ) { continue;
}

    /* If there is not already a read-only (or read-write) transaction opened
    ** on the b-tree database, open one now. If a transaction is opened, it 
    ** will be closed immediately after reading the meta-value. */
    if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_NONE ){
      rc = sqlite3BtreeBeginTrans(pBt, 0, 0);
      
// ABS Label 239
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// COR Label 240
if((rc == 7 && rc == (10 | (12 << 8))) != (rc == 7 || rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 240);
}

// ROR Label 241
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((rc != (10 | (12 << 8))) != (rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}

// MCC Label 243
if(rc == 7 && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 243);
}
// MCC Label 244
if(rc == 7 && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 244);
}
// MCC Label 245
if(!(rc == 7) && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(!(rc == 7) && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){
        
// ABS Label 247
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
sqlite3OomFault(db);
        pParse->rc = SQLITE_NOMEM;
      }
      
// ABS Label 248
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}

// ROR Label 249
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 249);
}
if( rc!=SQLITE_OK ) { return;
}
      openedTransaction = 1;
    }

    /* Read the schema cookie from the database. If it does not match the 
    ** value stored as part of the in-memory schema representation,
    ** set Parse.rc to SQLITE_SCHEMA. */
    
// ABS Label 236
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}
sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);
    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
    
// ABS Label 250
if(cookie < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}
// ABS Label 251
if(db->aDb[iDb].pSchema->schema_cookie < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ROR Label 252
if((cookie == db->aDb[iDb].pSchema->schema_cookie) != (cookie != db->aDb[iDb].pSchema->schema_cookie))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){
      
// ABS Label 253
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}

// ABS Label 254
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}
sqlite3ResetOneSchema(db, iDb);
      pParse->rc = SQLITE_SCHEMA;
    }

    /* Close the transaction, if one was opened. */
    
// ABS Label 255
if(openedTransaction < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}
if( openedTransaction ){
      
// ABS Label 256
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}
sqlite3BtreeCommit(pBt);
    }
  };
// ABS Label 230
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}
// ABS Label 231
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ROR Label 232
if((iDb <= db->nDb) != (iDb < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
// ROR Label 233
if((iDb > db->nDb) != (iDb < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 233);
}
// ROR Label 234
if((iDb >= db->nDb) != (iDb < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}

}

/*
** Convert a schema pointer into the iDb index that indicates
** which database file in db->aDb[] the schema refers to.
**
** If the same database is attached more than once, the first
** attached database is returned.
*/
int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){
  int i = -32768;

  /* If pSchema is NULL, then return -32768. This happens when code in 
  ** expr.c is trying to resolve a reference to a transient table (i.e. one
  ** created by a sub-select). In this case the return value of this 
  ** function should never be used.
  **
  ** We return -32768 instead of the more usual -1 simply because using
  ** -32768 as the incorrect index into db->aDb[] is much 
  ** more likely to cause a segfault than -1 (of course there are assert()
  ** statements too, but it never hurts to play the odds) and
  ** -32768 will still fit into a 16-bit signed integer.
  */
  assert( sqlite3_mutex_held(db->mutex) );
  
// ABS Label 257
if(pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}
if( pSchema ){
    i = 0;
for(; 1; i++){
      assert( i<db->nDb );
      
// ABS Label 258
if(db->aDb[i].pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}
// ABS Label 259
if(pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 259);
}

// ROR Label 260
if((db->aDb[i].pSchema != pSchema) != (db->aDb[i].pSchema == pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 260);
}
if( db->aDb[i].pSchema==pSchema ){
        break;
      }
    };
    assert( i>=0 && i<db->nDb );
  }
  
// ABS Label 261
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}
return i;
}

/*
** Free all memory allocations in the pParse object
*/
void sqlite3ParserReset(Parse *pParse){
  
// ABS Label 262
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}
sqlite3 *db = pParse->db;
  
// ABS Label 264
if(pParse->pCleanup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
while( pParse->pCleanup ){
    
// ABS Label 266
if(pParse->pCleanup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}
ParseCleanup *pCleanup = pParse->pCleanup;
    pParse->pCleanup = pCleanup->pNext;
    
// ABS Label 267
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 267);
}

// ABS Label 268
if(pCleanup->pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}
pCleanup->xCleanup(db, pCleanup->pPtr);
    
// ABS Label 269
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
sqlite3DbFreeNN(db, pCleanup);
  };
// ABS Label 265
if(pParse->pCleanup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}

  
// ABS Label 263
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}
sqlite3DbFree(db, pParse->aLabel);
  
// ABS Label 270
if(pParse->pConstExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
if( pParse->pConstExpr ){
    
// ABS Label 271
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}

// ABS Label 272
if(pParse->pConstExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
sqlite3ExprListDelete(db, pParse->pConstExpr);
  }
  
// ABS Label 273
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}
if( db ){
    assert( db->lookaside.bDisable >= pParse->disableLookaside );
    db->lookaside.bDisable -= pParse->disableLookaside;
    db->lookaside.sz = db->lookaside.bDisable ? 0 : db->lookaside.szTrue;
  }
  pParse->disableLookaside = 0;
}

/*
** Add a new cleanup operation to a Parser.  The cleanup should happen when
** the parser object is destroyed.  But, beware: the cleanup might happen
** immediately.
**
** Use this mechanism for uncommon cleanups.  There is a higher setup
** cost for this mechansim (an extra malloc), so it should not be used
** for common cleanups that happen on most calls.  But for less
** common cleanups, we save a single NULL-pointer comparison in
** sqlite3ParserReset(), which reduces the total CPU cycle count.
**
** If a memory allocation error occurs, then the cleanup happens immediately.
** When either SQLITE_DEBUG or SQLITE_COVERAGE_TEST are defined, the
** pParse->earlyCleanup flag is set in that case.  Calling code show verify
** that test cases exist for which this happens, to guard against possible
** use-after-free errors following an OOM.  The preferred way to do this is
** to immediately follow the call to this routine with:
**
**       testcase( pParse->earlyCleanup );
**
** This routine returns a copy of its pPtr input (the third parameter)
** except if an early cleanup occurs, in which case it returns NULL.  So
** another way to check for early cleanup is to check the return value.
** Or, stop using the pPtr parameter with this call and use only its
** return value thereafter.  Something like this:
**
**       pObj = sqlite3ParserAddCleanup(pParse, destructor, pObj);
*/
void *sqlite3ParserAddCleanup(
  Parse *pParse,                      /* Destroy when this Parser finishes */
  void (*xCleanup)(sqlite3*,void*),   /* The cleanup routine */
  void *pPtr                          /* Pointer to object to be cleaned up */
){
  ParseCleanup *pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));
  
// ABS Label 274
if(pCleanup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
if( pCleanup ){
    pCleanup->pNext = pParse->pCleanup;
    pParse->pCleanup = pCleanup;
    pCleanup->pPtr = pPtr;
    pCleanup->xCleanup = xCleanup;
  }else{
    
// ABS Label 275
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}

// ABS Label 276
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
xCleanup(pParse->db, pPtr);
    pPtr = 0;
#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
    pParse->earlyCleanup = 1;
#endif
  }
  
// ABS Label 277
if(pPtr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
return pPtr;
}

/*
** Compile the UTF-8 encoded SQL statement zSql into a statement handle.
*/
static int sqlite3Prepare(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
  Vdbe *pReprepare,         /* VM being reprepared */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
){
  char *zErrMsg = 0;        /* Error message */
  int rc = SQLITE_OK;       /* Result code */
  int i;                    /* Loop counter */
  Parse sParse;             /* Parsing context */

  memset(&sParse, 0, PARSE_HDR_SZ);
  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);
  sParse.pReprepare = pReprepare;
  assert( ppStmt && *ppStmt==0 );
  /* assert( !db->mallocFailed ); // not true with SQLITE_USE_ALLOCA */
  assert( sqlite3_mutex_held(db->mutex) );

  /* For a long-term use prepared statement avoid the use of
  ** lookaside memory.
  */
  
// ABS Label 279
if(prepFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}

// AOR Label 280
if(prepFlags | 1 != prepFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 280);
}
// AOR Label 281
if(prepFlags ^ 1 != prepFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 281);
}
if( prepFlags & SQLITE_PREPARE_PERSISTENT ){
    sParse.disableLookaside++;
    DisableLookaside;
  }
  sParse.disableVtab = (prepFlags & SQLITE_PREPARE_NO_VTAB)!=0;

  /* Check to verify that it is possible to get a read lock on all
  ** database schemas.  The inability to get a read lock indicates that
  ** some other database connection is holding a write-lock, which in
  ** turn means that the other connection has made uncommitted changes
  ** to the schema.
  **
  ** Were we to proceed and prepare the statement against the uncommitted
  ** schema changes and if those schema changes are subsequently rolled
  ** back and different changes are made in their place, then when this
  ** prepared statement goes to run the schema cookie would fail to detect
  ** the schema change.  Disaster would follow.
  **
  ** This thread is currently holding mutexes on all Btrees (because
  ** of the sqlite3BtreeEnterAll() in sqlite3LockAndPrepare()) so it
  ** is not possible for another thread to start a new schema change
  ** while this routine is running.  Hence, we do not need to hold 
  ** locks on the schema, we just need to make sure nobody else is 
  ** holding them.
  **
  ** Note that setting READ_UNCOMMITTED overrides most lock detection,
  ** but it does *not* override schema lock detection, so this all still
  ** works even if READ_UNCOMMITTED is set.
  */
  if( !db->noSharedCache ){
    i = 0;

// ABS Label 282
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
// ABS Label 283
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
// ROR Label 285
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 285);
}
// ROR Label 286
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
for(; i<db->nDb; i++) {
      
// ABS Label 292
if(db->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
Btree *pBt = db->aDb[i].pBt;
      
// ABS Label 293
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
if( pBt ){
        assert( sqlite3BtreeHoldsMutex(pBt) );
        rc = sqlite3BtreeSchemaLocked(pBt);
        
// ABS Label 294
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
if( rc ){
          const char *zDb = db->aDb[i].zDbSName;
          
// ABS Label 295
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// ABS Label 297
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);
          testcase( db->flags & SQLITE_ReadUncommit );
          goto end_prepare;
        }
      }
    };
// ABS Label 287
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
// ABS Label 288
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}

// ROR Label 289
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}
// ROR Label 290
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 290);
}
// ROR Label 291
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 291);
}

  }

  
// ABS Label 278
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}
sqlite3VtabUnlockList(db);

  sParse.db = db;
  
// ABS Label 298
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}

// COR Label 299
if((nBytes >= 0 || (nBytes == 0 || zSql[nBytes - 1] != 0)) != (nBytes >= 0 && (nBytes == 0 || zSql[nBytes - 1] != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 299);
}

// ROR Label 300
if((nBytes < 0) != (nBytes >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
// ROR Label 301
if((nBytes > 0) != (nBytes >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}
// ROR Label 302
if((nBytes <= 0) != (nBytes >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}

// MCC Label 303
if(nBytes >= 0 && ( nBytes == 0 && zSql[nBytes - 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 303);
}
// MCC Label 304
if(nBytes >= 0 && ( nBytes == 0 && !(zSql[nBytes - 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 304);
}
// MCC Label 305
if(nBytes >= 0 && ( !(nBytes == 0) && zSql[nBytes - 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 305);
}
// MCC Label 306
if(nBytes >= 0 && ( !(nBytes == 0) && !(zSql[nBytes - 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 306);
}
// MCC Label 307
if(!(nBytes >= 0) && ( nBytes == 0 && zSql[nBytes - 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 307);
}
// MCC Label 308
if(!(nBytes >= 0) && ( nBytes == 0 && !(zSql[nBytes - 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 308);
}
// MCC Label 309
if(!(nBytes >= 0) && ( !(nBytes == 0) && zSql[nBytes - 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 309);
}
// MCC Label 310
if(!(nBytes >= 0) && ( !(nBytes == 0) && !(zSql[nBytes - 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 310);
}
if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){
    char *zSqlCopy;
    
// ABS Label 311
if(db->aLimit[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];
    testcase( nBytes==mxLen );
    testcase( nBytes==mxLen+1 );
    
// ABS Label 312
if(mxLen < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
// ABS Label 313
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}

// ROR Label 314
if((nBytes <= mxLen) != (nBytes > mxLen))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
// ROR Label 315
if((nBytes < mxLen) != (nBytes > mxLen))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}
// ROR Label 316
if((nBytes >= mxLen) != (nBytes > mxLen))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
if( nBytes>mxLen ){
      
// ABS Label 317
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
sqlite3ErrorWithMsg(db, SQLITE_TOOBIG, "statement too long");
      rc = sqlite3ApiExit(db, SQLITE_TOOBIG);
      goto end_prepare;
    }
    zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);
    
// ABS Label 318
if(zSqlCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
if( zSqlCopy ){
      sqlite3RunParser(&sParse, zSqlCopy, &zErrMsg);
      sParse.zTail = &zSql[sParse.zTail-zSqlCopy];
      
// ABS Label 319
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
sqlite3DbFree(db, zSqlCopy);
    }else{
      sParse.zTail = &zSql[nBytes];
    }
  }else{
    
// ABS Label 320
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
sqlite3RunParser(&sParse, zSql, &zErrMsg);
  }
  assert( 0==sParse.nQueryLoop );

  
// ABS Label 321
if(pzTail < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
if( pzTail ){
    *pzTail = sParse.zTail;
  }

  
// ROR Label 322
if((db->init.busy != 0) != (db->init.busy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}
if( db->init.busy==0 ){
    
// ABS Label 323
if(sParse.pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}

// ABS Label 324
if(zSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}
sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);
  }
  
// ABS Label 325
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
if( db->mallocFailed ){
    sParse.rc = SQLITE_NOMEM_BKPT;
    sParse.checkSchema = 0;
  }
  
// ABS Label 326
if(sParse.rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// COR Label 327
if((sParse.rc != 0 || sParse.rc != 101) != (sParse.rc != 0 && sParse.rc != 101))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 327);
}

// ROR Label 328
if((sParse.rc == 0) != (sParse.rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 328);
}
// ROR Label 329
if((sParse.rc == 101) != (sParse.rc != 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 329);
}

// MCC Label 330
if(sParse.rc != 0 && sParse.rc != 101 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 330);
}
// MCC Label 331
if(sParse.rc != 0 && !(sParse.rc != 101) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 331);
}
// MCC Label 332
if(!(sParse.rc != 0) && sParse.rc != 101 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 332);
}
// MCC Label 333
if(!(sParse.rc != 0) && !(sParse.rc != 101) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 333);
}
if( sParse.rc!=SQLITE_OK && sParse.rc!=SQLITE_DONE ){
    
// ABS Label 334
if(sParse.checkSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
if( sParse.checkSchema ){
      schemaIsValid(&sParse);
    }
    
// ABS Label 335
if(sParse.pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
if( sParse.pVdbe ){
      
// ABS Label 336
if(sParse.pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}
sqlite3VdbeFinalize(sParse.pVdbe);
    }
    assert( 0==(*ppStmt) );
    rc = sParse.rc;
    
// ABS Label 337
if(zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
if( zErrMsg ){
      
// ABS Label 338
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}

// ABS Label 339
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}

// ABS Label 340
if(zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}
sqlite3ErrorWithMsg(db, rc, "%s", zErrMsg);
      
// ABS Label 341
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
sqlite3DbFree(db, zErrMsg);
    }else{
      
// ABS Label 342
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// ABS Label 343
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}
sqlite3Error(db, rc);
    }
  }else{
    assert( zErrMsg==0 );
    *ppStmt = (sqlite3_stmt*)sParse.pVdbe;
    rc = SQLITE_OK;
    
// ABS Label 344
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
sqlite3ErrorClear(db);
  }


  /* Delete any TriggerPrg structures allocated while parsing this statement. */
  
// ABS Label 345
if(sParse.pTriggerPrg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}
while( sParse.pTriggerPrg ){
    
// ABS Label 347
if(sParse.pTriggerPrg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}
TriggerPrg *pT = sParse.pTriggerPrg;
    sParse.pTriggerPrg = pT->pNext;
    
// ABS Label 348
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}
sqlite3DbFree(db, pT);
  };
// ABS Label 346
if(sParse.pTriggerPrg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}


end_prepare:

  sqlite3ParserReset(&sParse);
  
// ABS Label 349
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
return rc;
}
static int sqlite3LockAndPrepare(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
  Vdbe *pOld,               /* VM being reprepared */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
){
  int rc;
  int cnt = 0;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;
#endif
  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){
    return SQLITE_MISUSE_BKPT;
  }
  
// ABS Label 350
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}
sqlite3_mutex_enter(db->mutex);
  
// ABS Label 351
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}
sqlite3BtreeEnterAll(db);
  do{
    /* Make multiple attempts to compile the SQL, until it either succeeds
    ** or encounters a permanent error.  A schema problem after one schema
    ** reset is considered a permanent error. */
    rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);
    assert( rc==SQLITE_OK || *ppStmt==0 );
  }while( rc==SQLITE_ERROR_RETRY
       || (rc==SQLITE_SCHEMA && (sqlite3ResetOneSchema(db,-1), cnt++)==0) );;
  
// ABS Label 352
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}
sqlite3BtreeLeaveAll(db);
  rc = sqlite3ApiExit(db, rc);
  assert( (rc&db->errMask)==rc );
  db->busyHandler.nBusy = 0;
  
// ABS Label 353
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 354
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
return rc;
}


/*
** Rerun the compilation of a statement after a schema change.
**
** If the statement is successfully recompiled, return SQLITE_OK. Otherwise,
** if the statement cannot be recompiled because another connection has
** locked the sqlite3_schema table, return SQLITE_LOCKED. If any other error
** occurs, return SQLITE_SCHEMA.
*/
int sqlite3Reprepare(Vdbe *p){
  int rc;
  sqlite3_stmt *pNew;
  const char *zSql;
  sqlite3 *db;
  u8 prepFlags;

  assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );
  zSql = sqlite3_sql((sqlite3_stmt *)p);
  assert( zSql!=0 );  /* Reprepare only called for prepare_v2() statements */
  db = sqlite3VdbeDb(p);
  assert( sqlite3_mutex_held(db->mutex) );
  prepFlags = sqlite3VdbePrepareFlags(p);
  rc = sqlite3LockAndPrepare(db, zSql, -1, prepFlags, p, &pNew, 0);
  
// ABS Label 357
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}
if( rc ){
    
// ABS Label 358
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}

// ROR Label 359
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}
if( rc==SQLITE_NOMEM ){
      
// ABS Label 360
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 360);
}
sqlite3OomFault(db);
    }
    assert( pNew==0 );
    
// ABS Label 361
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}
return rc;
  }else{
    assert( pNew!=0 );
  }
  
// ABS Label 355
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
sqlite3VdbeSwap((Vdbe*)pNew, p);
  
// ABS Label 356
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}
sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);
  sqlite3VdbeResetStepResult((Vdbe*)pNew);
  sqlite3VdbeFinalize((Vdbe*)pNew);
  return SQLITE_OK;
}


/*
** Two versions of the official API.  Legacy and new use.  In the legacy
** version, the original SQL text is not saved in the prepared statement
** and so if a schema change occurs, SQLITE_SCHEMA is returned by
** sqlite3_step().  In the new version, the original SQL text is retained
** and the statement is automatically recompiled if an schema change
** occurs.
*/
int sqlite3_prepare(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
){
  int rc;
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);
  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
  
// ABS Label 362
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}
return rc;
}
int sqlite3_prepare_v2(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
){
  int rc;
  /* EVIDENCE-OF: R-37923-12173 The sqlite3_prepare_v2() interface works
  ** exactly the same as sqlite3_prepare_v3() with a zero prepFlags
  ** parameter.
  **
  ** Proof in that the 5th parameter to sqlite3LockAndPrepare is 0 */
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,0,
                             ppStmt,pzTail);
  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );
  
// ABS Label 363
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 363);
}
return rc;
}
int sqlite3_prepare_v3(
  sqlite3 *db,              /* Database handle. */
  const char *zSql,         /* UTF-8 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const char **pzTail       /* OUT: End of parsed string */
){
  int rc;
  /* EVIDENCE-OF: R-56861-42673 sqlite3_prepare_v3() differs from
  ** sqlite3_prepare_v2() only in having the extra prepFlags parameter,
  ** which is a bit array consisting of zero or more of the
  ** SQLITE_PREPARE_* flags.
  **
  ** Proof by comparison to the implementation of sqlite3_prepare_v2()
  ** directly above. */
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,
                 SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),
                 0,ppStmt,pzTail);
  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );
  
// ABS Label 364
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
return rc;
}


#ifndef SQLITE_OMIT_UTF16
/*
** Compile the UTF-16 encoded SQL statement zSql into a statement handle.
*/
static int sqlite3Prepare16(
  sqlite3 *db,              /* Database handle. */ 
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
){
  /* This function currently works by first transforming the UTF-16
  ** encoded string to UTF-8, then invoking sqlite3_prepare(). The
  ** tricky bit is figuring out the pointer to return in *pzTail.
  */
  char *zSql8;
  const char *zTail8 = 0;
  int rc = SQLITE_OK;

#ifdef SQLITE_ENABLE_API_ARMOR
  if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;
#endif
  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){
    return SQLITE_MISUSE_BKPT;
  }
  
// ABS Label 368
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}

// ROR Label 369
if((nBytes < 0) != (nBytes >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}
// ROR Label 370
if((nBytes > 0) != (nBytes >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 370);
}
// ROR Label 371
if((nBytes <= 0) != (nBytes >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 371);
}
if( nBytes>=0 ){
    int sz;
    const char *z = (const char*)zSql;
    sz = 0;

// ABS Label 372
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
// ABS Label 373
if(sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// COR Label 374
if((sz < nBytes || (z[sz] != 0 || z[sz + 1] != 0)) != (sz < nBytes && (z[sz] != 0 || z[sz + 1] != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 374);
}

// ROR Label 375
if((sz <= nBytes) != (sz < nBytes))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
// ROR Label 376
if((sz > nBytes) != (sz < nBytes))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((sz >= nBytes) != (sz < nBytes))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}

// MCC Label 378
if(sz < nBytes && ( z[sz] != 0 && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 378);
}
// MCC Label 379
if(sz < nBytes && ( z[sz] != 0 && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(sz < nBytes && ( !(z[sz] != 0) && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(sz < nBytes && ( !(z[sz] != 0) && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(!(sz < nBytes) && ( z[sz] != 0 && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}
// MCC Label 383
if(!(sz < nBytes) && ( z[sz] != 0 && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(!(sz < nBytes) && ( !(z[sz] != 0) && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
// MCC Label 385
if(!(sz < nBytes) && ( !(z[sz] != 0) && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
for(; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){};
// ABS Label 386
if(nBytes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
// ABS Label 387
if(sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// COR Label 388
if((sz < nBytes || (z[sz] != 0 || z[sz + 1] != 0)) != (sz < nBytes && (z[sz] != 0 || z[sz + 1] != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 388);
}

// ROR Label 389
if((sz <= nBytes) != (sz < nBytes))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 389);
}
// ROR Label 390
if((sz > nBytes) != (sz < nBytes))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 390);
}
// ROR Label 391
if((sz >= nBytes) != (sz < nBytes))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}

// MCC Label 392
if(sz < nBytes && ( z[sz] != 0 && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
// MCC Label 393
if(sz < nBytes && ( z[sz] != 0 && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(sz < nBytes && ( !(z[sz] != 0) && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(sz < nBytes && ( !(z[sz] != 0) && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(!(sz < nBytes) && ( z[sz] != 0 && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
// MCC Label 397
if(!(sz < nBytes) && ( z[sz] != 0 && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 397);
}
// MCC Label 398
if(!(sz < nBytes) && ( !(z[sz] != 0) && z[sz + 1] != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 398);
}
// MCC Label 399
if(!(sz < nBytes) && ( !(z[sz] != 0) && !(z[sz + 1] != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 399);
}

    nBytes = sz;
  }
  
// ABS Label 365
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
sqlite3_mutex_enter(db->mutex);
  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);
  
// ABS Label 400
if(zSql8 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
if( zSql8 ){
    rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);
  }

  
// ABS Label 401
if(pzTail < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}
// ABS Label 402
if(zTail8 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}

// COR Label 403
if((zTail8 || pzTail) != (zTail8 && pzTail))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 403);
}

// MCC Label 404
if(zTail8 && pzTail ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 404);
}
// MCC Label 405
if(zTail8 && !(pzTail) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 405);
}
// MCC Label 406
if(!(zTail8) && pzTail ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 406);
}
// MCC Label 407
if(!(zTail8) && !(pzTail) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 407);
}
if( zTail8 && pzTail ){
    /* If sqlite3_prepare returns a tail pointer, we calculate the
    ** equivalent pointer into the UTF-16 string by counting the unicode
    ** characters between zSql8 and zTail8, and then returning a pointer
    ** the same number of characters into the UTF-16 string.
    */
    int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));
    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);
  }
  
// ABS Label 366
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}
sqlite3DbFree(db, zSql8); 
  rc = sqlite3ApiExit(db, rc);
  
// ABS Label 367
if(db->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}
sqlite3_mutex_leave(db->mutex);
  
// ABS Label 408
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}
return rc;
}

/*
** Two versions of the official API.  Legacy and new use.  In the legacy
** version, the original SQL text is not saved in the prepared statement
** and so if a schema change occurs, SQLITE_SCHEMA is returned by
** sqlite3_step().  In the new version, the original SQL text is retained
** and the statement is automatically recompiled if an schema change
** occurs.
*/
int sqlite3_prepare16(
  sqlite3 *db,              /* Database handle. */ 
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);
  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
  
// ABS Label 409
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}
return rc;
}
int sqlite3_prepare16_v2(
  sqlite3 *db,              /* Database handle. */ 
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,ppStmt,pzTail);
  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
  
// ABS Label 410
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}
return rc;
}
int sqlite3_prepare16_v3(
  sqlite3 *db,              /* Database handle. */ 
  const void *zSql,         /* UTF-16 encoded SQL statement. */
  int nBytes,               /* Length of zSql in bytes. */
  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */
  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */
  const void **pzTail       /* OUT: End of parsed string */
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,
         SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),
         ppStmt,pzTail);
  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */
  
// ABS Label 411
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}
return rc;
}

#endif /* SQLITE_OMIT_UTF16 */
