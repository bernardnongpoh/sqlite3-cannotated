/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2008 August 18
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains routines used for walking the parser tree and
** resolve all identifiers by associating them with a particular
** table and column.
*/
#include "sqliteInt.h"

/*
** Magic table number to mean the EXCLUDED table in an UPSERT statement.
*/
#define EXCLUDED_TABLE_NUMBER  2

/*
** Walk the expression tree pExpr and increase the aggregate function
** depth (the Expr.op2 field) by N on every TK_AGG_FUNCTION node.
** This needs to occur when copying a TK_AGG_FUNCTION node from an
** outer query into an inner subquery.
**
** incrAggFunctionDepth(pExpr,n) is the main routine.  incrAggDepth(..)
** is a helper function - a callback for the tree walker.
**
** See also the sqlite3WindowExtraAggFuncDepth() routine in window.c
*/
static int incrAggDepth(Walker *pWalker, Expr *pExpr){
  
// ROR Label 7
if((pExpr->op != 167) != (pExpr->op == 167))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 7);
}
if( pExpr->op==TK_AGG_FUNCTION ) { pExpr->op2 += pWalker->u.n;
}
  return WRC_Continue;
}
static void incrAggFunctionDepth(Expr *pExpr, int N){
  
// ABS Label 8
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

// ROR Label 9
if((N <= 0) != (N > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 9);
}
// ROR Label 10
if((N < 0) != (N > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
// ROR Label 11
if((N >= 0) != (N > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 11);
}
if( N>0 ){
    Walker w;
    memset(&w, 0, sizeof(w));
    w.xExprCallback = incrAggDepth;
    w.u.n = N;
    
// ABS Label 12
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3WalkExpr(&w, pExpr);
  }
}

/*
** Turn the pExpr expression into an alias for the iCol-th column of the
** result set in pEList.
**
** If the reference is followed by a COLLATE operator, then make sure
** the COLLATE operator is preserved.  For example:
**
**     SELECT a+b, c+d FROM t1 ORDER BY 1 COLLATE nocase;
**
** Should be transformed into:
**
**     SELECT a+b, c+d FROM t1 ORDER BY (a+b) COLLATE nocase;
**
** The nSubquery parameter specifies how many levels of subquery the
** alias is removed from the original expression.  The usual value is
** zero but it might be more if the alias is contained within a subquery
** of the original expression.  The Expr.op2 field of TK_AGG_FUNCTION
** structures must be increased by the nSubquery amount.
*/
static void resolveAlias(
  Parse *pParse,         /* Parsing context */
  ExprList *pEList,      /* A result set */
  int iCol,              /* A column in the result set.  0..pEList->nExpr-1 */
  Expr *pExpr,           /* Transform this into an alias to the result set */
  int nSubquery          /* Number of subqueries that the label is moving */
){
  Expr *pOrig;           /* The iCol-th column of the result set */
  Expr *pDup;            /* Copy of pOrig */
  sqlite3 *db;           /* The database connection */

  assert( iCol>=0 && iCol<pEList->nExpr );
  pOrig = pEList->a[iCol].pExpr;
  assert( pOrig!=0 );
  db = pParse->db;
  pDup = sqlite3ExprDup(db, pOrig, 0);
  
// ABS Label 13
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
if( db->mallocFailed ){
    
// ABS Label 14
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ABS Label 15
if(pDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
sqlite3ExprDelete(db, pDup);
    pDup = 0;
  }else{
    
// ABS Label 16
if(pDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ABS Label 17
if(nSubquery < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
incrAggFunctionDepth(pDup, nSubquery);
    
// ROR Label 21
if((pExpr->op != 112) != (pExpr->op == 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
if( pExpr->op==TK_COLLATE ){
      pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);
    }

    /* Before calling sqlite3ExprDelete(), set the EP_Static flag. This 
    ** prevents ExprDelete() from deleting the Expr structure itself,
    ** allowing it to be repopulated by the memcpy() on the following line.
    ** The pExpr->u.zToken might point into memory that will be freed by the
    ** sqlite3DbFree(db, pDup) on the last line of this block, so be sure to
    ** make a copy of the token before doing the sqlite3DbFree().
    */
    ExprSetProperty(pExpr, EP_Static);
    
// ABS Label 18
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ABS Label 19
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3ExprDelete(db, pExpr);
    memcpy(pExpr, pDup, sizeof(*pExpr));
    
// ABS Label 22
if(pExpr->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// COR Label 23
if((!(((pExpr)->flags & (1024)) != 0) || pExpr->u.zToken != 0) != (!(((pExpr)->flags & (1024)) != 0) && pExpr->u.zToken != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 23);
}

// ROR Label 24
if((pExpr->u.zToken == 0) != (pExpr->u.zToken != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}

// MCC Label 25
if(!(((pExpr)->flags & (1024)) != 0) && pExpr->u.zToken != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 25);
}
// MCC Label 26
if(!(((pExpr)->flags & (1024)) != 0) && !(pExpr->u.zToken != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 26);
}
// MCC Label 27
if(!(!(((pExpr)->flags & (1024)) != 0)) && pExpr->u.zToken != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 27);
}
// MCC Label 28
if(!(!(((pExpr)->flags & (1024)) != 0)) && !(pExpr->u.zToken != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 28);
}
if( !ExprHasProperty(pExpr, EP_IntValue) && pExpr->u.zToken!=0 ){
      assert( (pExpr->flags & (EP_Reduced|EP_TokenOnly))==0 );
      pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken);
      pExpr->flags |= EP_MemToken;
    }
    
// MCC Label 29
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 29);
}
// MCC Label 30
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 30);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
      
// MCC Label 31
if(( pExpr->y.pWin != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 31);
}
// MCC Label 32
if(( !(pExpr->y.pWin != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 32);
}
if( ALWAYS(pExpr->y.pWin!=0) ){
        pExpr->y.pWin->pOwner = pExpr;
      }
    }
    
// ABS Label 20
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
sqlite3DbFree(db, pDup);
  }
}


/*
** Return TRUE if the name zCol occurs anywhere in the USING clause.
**
** Return FALSE if the USING clause is NULL or if it does not contain
** zCol.
*/
static int nameInUsingClause(IdList *pUsing, const char *zCol){
  
// ABS Label 33
if(pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
if( pUsing ){
    int k;
    k = 0;

// ABS Label 34
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
// ABS Label 35
if(pUsing->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// ROR Label 36
if((k <= pUsing->nId) != (k < pUsing->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
// ROR Label 37
if((k > pUsing->nId) != (k < pUsing->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
// ROR Label 38
if((k >= pUsing->nId) != (k < pUsing->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
for(; k<pUsing->nId; k++){
      if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ) { return 1;
}
    };
// ABS Label 39
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
// ABS Label 40
if(pUsing->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}

// ROR Label 41
if((k <= pUsing->nId) != (k < pUsing->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
// ROR Label 42
if((k > pUsing->nId) != (k < pUsing->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((k >= pUsing->nId) != (k < pUsing->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}

  }
  return 0;
}

/*
** Subqueries stores the original database, table and column names for their
** result sets in ExprList.a[].zSpan, in the form "DATABASE.TABLE.COLUMN".
** Check to see if the zSpan given to this routine matches the zDb, zTab,
** and zCol.  If any of zDb, zTab, and zCol are NULL then those fields will
** match anything.
*/
int sqlite3MatchEName(
  const struct ExprList_item *pItem,
  const char *zCol,
  const char *zTab,
  const char *zDb
){
  int n;
  const char *zSpan;
  
// ROR Label 44
if((pItem->eEName == 2) != (pItem->eEName != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
if( pItem->eEName!=ENAME_TAB ) { return 0;
}
  zSpan = pItem->zEName;
  n = 0;

// COR Label 45
if(((zSpan[n]) || zSpan[n] != '.') != ((zSpan[n]) && zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 45);
}

// ROR Label 46
if((zSpan[n] == '.') != (zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}

// MCC Label 47
if((zSpan[n]) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 47);
}
// MCC Label 48
if((zSpan[n]) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 48);
}
// MCC Label 49
if(!((zSpan[n])) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 49);
}
// MCC Label 50
if(!((zSpan[n])) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 50);
}
for(; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){};
// COR Label 51
if(((zSpan[n]) || zSpan[n] != '.') != ((zSpan[n]) && zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 51);
}

// ROR Label 52
if((zSpan[n] == '.') != (zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}

// MCC Label 53
if((zSpan[n]) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if((zSpan[n]) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(!((zSpan[n])) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!((zSpan[n])) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}

  if( zDb && (sqlite3StrNICmp(zSpan, zDb, n)!=0 || zDb[n]!=0) ){
    return 0;
  }
  zSpan += n+1;
  n = 0;

// COR Label 57
if(((zSpan[n]) || zSpan[n] != '.') != ((zSpan[n]) && zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 57);
}

// ROR Label 58
if((zSpan[n] == '.') != (zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}

// MCC Label 59
if((zSpan[n]) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if((zSpan[n]) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!((zSpan[n])) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!((zSpan[n])) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
for(; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){};
// COR Label 63
if(((zSpan[n]) || zSpan[n] != '.') != ((zSpan[n]) && zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 63);
}

// ROR Label 64
if((zSpan[n] == '.') != (zSpan[n] != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}

// MCC Label 65
if((zSpan[n]) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 65);
}
// MCC Label 66
if((zSpan[n]) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
// MCC Label 67
if(!((zSpan[n])) && zSpan[n] != '.' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 67);
}
// MCC Label 68
if(!((zSpan[n])) && !(zSpan[n] != '.') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 68);
}

  if( zTab && (sqlite3StrNICmp(zSpan, zTab, n)!=0 || zTab[n]!=0) ){
    return 0;
  }
  zSpan += n+1;
  if( zCol && sqlite3StrICmp(zSpan, zCol)!=0 ){
    return 0;
  }
  return 1;
}

/*
** Return TRUE if the double-quoted string  mis-feature should be supported.
*/
static int areDoubleQuotedStringsEnabled(sqlite3 *db, NameContext *pTopNC){
  
// ABS Label 69
if(db->init.busy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}
if( db->init.busy ) { return 1;  /* Always support for legacy schemas */
}
  
// ABS Label 70
if(pTopNC->ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// AOR Label 71
if(pTopNC->ncFlags | 65536 != pTopNC->ncFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 71);
}
// AOR Label 72
if(pTopNC->ncFlags ^ 65536 != pTopNC->ncFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 72);
}
if( pTopNC->ncFlags & NC_IsDDL ){
    /* Currently parsing a DDL statement */
    if( sqlite3WritableSchema(db) && (db->flags & SQLITE_DqsDML)!=0 ){
      return 1;
    }
    
// ROR Label 73
if(((db->flags & 536870912) == 0) != ((db->flags & 536870912) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
return (db->flags & SQLITE_DqsDDL)!=0;
  }else{
    /* Currently parsing a DML statement */
    
// ROR Label 74
if(((db->flags & 1073741824) == 0) != ((db->flags & 1073741824) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
return (db->flags & SQLITE_DqsDML)!=0;
  }
}

/*
** The argument is guaranteed to be a non-NULL Expr node of type TK_COLUMN.
** return the appropriate colUsed mask.
*/
Bitmask sqlite3ExprColUsed(Expr *pExpr){
  int n;
  Table *pExTab;
  Bitmask result;

  n = pExpr->iColumn;
  pExTab = pExpr->y.pTab;
  assert( pExTab!=0 );
#ifdef MAGMA_ENABLE_FIXES
  if( (pExTab->tabFlags & TF_HasGenerated)!=0
   && (pExTab->aCol[n].colFlags & COLFLAG_GENERATED)!=0 
  ){
    testcase( pExTab->nCol==BMS-1 );
    testcase( pExTab->nCol==BMS );
    result = pExTab->nCol>=BMS ? ALLBITS : MASKBIT(pExTab->nCol)-1;
  }else{
#endif
    testcase( n==BMS-1 );
    testcase( n==BMS );
    
// ABS Label 75
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}

// ROR Label 76
if((n < ((int)(sizeof(Bitmask) * 8))) != (n >= ((int)(sizeof(Bitmask) * 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
// ROR Label 77
if((n > ((int)(sizeof(Bitmask) * 8))) != (n >= ((int)(sizeof(Bitmask) * 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
// ROR Label 78
if((n <= ((int)(sizeof(Bitmask) * 8))) != (n >= ((int)(sizeof(Bitmask) * 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
if( n>=BMS ) { n = BMS-1;
}
    result = ((Bitmask)1)<<n;
#ifdef MAGMA_ENABLE_FIXES
  }
#else
#ifdef MAGMA_ENABLE_CANARIES
  MAGMA_LOG("SQL015",
    MAGMA_AND((pExTab->tabFlags & TF_HasGenerated)!=0,
    MAGMA_AND((pExTab->aCol[n].colFlags & COLFLAG_GENERATED)!=0,
    MAGMA_AND(pExTab->nCol >= BMS,
              result < ALLBITS)))
  );
#endif
#endif
  
// ABS Label 79
if(result < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}
return result;
}

/*
** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up
** that name in the set of source tables in pSrcList and make the pExpr 
** expression node refer back to that source column.  The following changes
** are made to pExpr:
**
**    pExpr->iDb           Set the index in db->aDb[] of the database X
**                         (even if X is implied).
**    pExpr->iTable        Set to the cursor number for the table obtained
**                         from pSrcList.
**    pExpr->y.pTab        Points to the Table structure of X.Y (even if
**                         X and/or Y are implied.)
**    pExpr->iColumn       Set to the column number within the table.
**    pExpr->op            Set to TK_COLUMN.
**    pExpr->pLeft         Any expression this points to is deleted
**    pExpr->pRight        Any expression this points to is deleted.
**
** The zDb variable is the name of the database (the "X").  This value may be
** NULL meaning that name is of the form Y.Z or Z.  Any available database
** can be used.  The zTable variable is the name of the table (the "Y").  This
** value can be NULL if zDb is also NULL.  If zTable is NULL it
** means that the form of the name is Z and that columns from any table
** can be used.
**
** If the name cannot be resolved unambiguously, leave an error message
** in pParse and return WRC_Abort.  Return WRC_Prune on success.
*/
static int lookupName(
  Parse *pParse,       /* The parsing context */
  const char *zDb,     /* Name of the database containing table, or NULL */
  const char *zTab,    /* Name of table containing column, or NULL */
  const char *zCol,    /* Name of the column. */
  NameContext *pNC,    /* The name context used to resolve the name */
  Expr *pExpr          /* Make this EXPR node point to the selected column */
){
  int i, j;                         /* Loop counters */
  int cnt = 0;                      /* Number of matching column names */
  int cntTab = 0;                   /* Number of matching table names */
  int nSubquery = 0;                /* How many levels of subquery */
  
// ABS Label 80
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}
sqlite3 *db = pParse->db;         /* The database connection */
  SrcItem *pItem;                   /* Use for looping over pSrcList items */
  SrcItem *pMatch = 0;              /* The matching pSrcList item */
  
// ABS Label 81
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
NameContext *pTopNC = pNC;        /* First namecontext in the list */
  Schema *pSchema = 0;              /* Schema of the expression */
  int eNewExprOp = TK_COLUMN;       /* New value for pExpr->op on success */
  Table *pTab = 0;                  /* Table hold the row */
  Column *pCol;                     /* A column of pTab */

  assert( pNC );     /* the name context cannot be NULL. */
  assert( zCol );    /* The Z in X.Y.Z cannot be NULL */
  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );

  /* Initialize the node to no-match */
  pExpr->iTable = -1;
  ExprSetVVAProperty(pExpr, EP_NoReduce);

  /* Translate the schema name in zDb into a pointer to the corresponding
  ** schema.  If not found, pSchema will remain NULL and nothing will match
  ** resulting in an appropriate error message toward the end of this routine
  */
  
// ABS Label 82
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
if( zDb ){
    testcase( pNC->ncFlags & NC_PartIdx );
    testcase( pNC->ncFlags & NC_IsCheck );
    
// ROR Label 83
if(((pNC->ncFlags & (2 | 4)) == 0) != ((pNC->ncFlags & (2 | 4)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){
      /* Silently ignore database qualifiers inside CHECK constraints and
      ** partial indices.  Do not raise errors because that might break
      ** legacy and because it does not hurt anything to just ignore the
      ** database name. */
      zDb = 0;
    }else{
      i = 0;

// ABS Label 84
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
// ABS Label 85
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}

// ROR Label 86
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
// ROR Label 87
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}
// ROR Label 88
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 88);
}
for(; i<db->nDb; i++){
        assert( db->aDb[i].zDbSName );
        if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){
          pSchema = db->aDb[i].pSchema;
          break;
        }
      };
// ABS Label 89
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}
// ABS Label 90
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 90);
}

// ROR Label 91
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}

      if( i==db->nDb && sqlite3StrICmp("main", zDb)==0 ){
        /* This branch is taken when the main database has been renamed
        ** using SQLITE_DBCONFIG_MAINDBNAME. */
        pSchema = db->aDb[0].pSchema;
        zDb = db->aDb[0].zDbSName;
      }
    }
  }

  /* Start at the inner-most context and move outward until a match is found */
  assert( pNC && cnt==0 );
  
// ABS Label 94
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}
do{
    ExprList *pEList;
    
// ABS Label 96
if(pNC->pSrcList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}
SrcList *pSrcList = pNC->pSrcList;

    
// ABS Label 97
if(pSrcList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}
if( pSrcList ){
      i = 0 , pItem = pSrcList->a;

// ABS Label 98
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
// ABS Label 99
if(pSrcList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}

// ROR Label 100
if((i <= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}
// ROR Label 101
if((i > pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 101);
}
// ROR Label 102
if((i >= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 102);
}
for(; i<pSrcList->nSrc; i++, pItem++){
        u8 hCol;
        pTab = pItem->pTab;
        assert( pTab!=0 && pTab->zName!=0 );
        assert( pTab->nCol>0 || pParse->nErr );
        
// ABS Label 108
if(pItem->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}

// COR Label 109
if((pItem->pSelect || (pItem->pSelect->selFlags & 2048) != 0) != (pItem->pSelect && (pItem->pSelect->selFlags & 2048) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 109);
}

// ROR Label 110
if(((pItem->pSelect->selFlags & 2048) == 0) != ((pItem->pSelect->selFlags & 2048) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}

// MCC Label 111
if(pItem->pSelect && (pItem->pSelect->selFlags & 2048) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
// MCC Label 112
if(pItem->pSelect && !((pItem->pSelect->selFlags & 2048) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(!(pItem->pSelect) && (pItem->pSelect->selFlags & 2048) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
// MCC Label 114
if(!(pItem->pSelect) && !((pItem->pSelect->selFlags & 2048) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 114);
}
if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){
          int hit = 0;
          pEList = pItem->pSelect->pEList;
          j = 0;

// ABS Label 115
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
// ABS Label 116
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}

// ROR Label 117
if((j <= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
// ROR Label 118
if((j > pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
// ROR Label 119
if((j >= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
for(; j<pEList->nExpr; j++){
            if( sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb) ){
              cnt++;
              cntTab = 2;
              pMatch = pItem;
              pExpr->iColumn = j;
              hit = 1;
            }
          };
// ABS Label 120
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}
// ABS Label 121
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}

// ROR Label 122
if((j <= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
// ROR Label 123
if((j > pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
// ROR Label 124
if((j >= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}

          
// ABS Label 125
if(hit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
// ABS Label 126
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// COR Label 127
if((hit && zTab == 0) != (hit || zTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 127);
}

// ROR Label 128
if((zTab != 0) != (zTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}

// MCC Label 129
if(hit && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
// MCC Label 130
if(hit && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
// MCC Label 131
if(!(hit) && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 131);
}
// MCC Label 132
if(!(hit) && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
if( hit || zTab==0 ) { continue;
}
        }
        
// ABS Label 133
if(pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
// ABS Label 134
if(pTab->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}
// ABS Label 135
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}

// COR Label 136
if((zDb || pTab->pSchema != pSchema) != (zDb && pTab->pSchema != pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 136);
}

// ROR Label 137
if((pTab->pSchema == pSchema) != (pTab->pSchema != pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}

// MCC Label 138
if(zDb && pTab->pSchema != pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
// MCC Label 139
if(zDb && !(pTab->pSchema != pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 139);
}
// MCC Label 140
if(!(zDb) && pTab->pSchema != pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 140);
}
// MCC Label 141
if(!(zDb) && !(pTab->pSchema != pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 141);
}
if( zDb && pTab->pSchema!=pSchema ){
          continue;
        }
        
// ABS Label 142
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
if( zTab ){
          const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;
          assert( zTabName!=0 );
          if( sqlite3StrICmp(zTabName, zTab)!=0 ){
            continue;
          }
          
// ABS Label 143
if(pItem->zAlias < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}

// COR Label 144
if(((pParse->eParseMode >= 2) || pItem->zAlias) != ((pParse->eParseMode >= 2) && pItem->zAlias))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 144);
}

// MCC Label 145
if(( pParse->eParseMode >= 2 ) && pItem->zAlias ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 145);
}
// MCC Label 146
if(( pParse->eParseMode >= 2 ) && !(pItem->zAlias) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 146);
}
// MCC Label 147
if(( !(pParse->eParseMode >= 2) ) && pItem->zAlias ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(( !(pParse->eParseMode >= 2) ) && !(pItem->zAlias) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
if( IN_RENAME_OBJECT && pItem->zAlias ){
            
// ABS Label 149
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);
          }
        }
        hCol = sqlite3StrIHash(zCol);
        j = 0 , pCol = pTab->aCol;

// ABS Label 150
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ROR Label 151
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
// ROR Label 153
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 153);
}
for(; j<pTab->nCol; j++, pCol++){
          if( pCol->hName==hCol && sqlite3StrICmp(pCol->zName, zCol)==0 ){
            /* If there has been exactly one prior match and this match
            ** is for the right-hand table of a NATURAL JOIN or is in a 
            ** USING clause, then skip this match.
            */
            
// ABS Label 158
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// ROR Label 159
if((cnt != 1) != (cnt == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 159);
}
if( cnt==1 ){
              
// AOR Label 160
if(pItem->fg.jointype | 4 != pItem->fg.jointype & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 160);
}
// AOR Label 161
if(pItem->fg.jointype ^ 4 != pItem->fg.jointype & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 161);
}
if( pItem->fg.jointype & JT_NATURAL ) { continue;
}
              if( nameInUsingClause(pItem->pUsing, zCol) ) { continue;
}
            }
            cnt++;
            pMatch = pItem;
            /* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */
            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
            break;
          }
        };
// ABS Label 154
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}

// ROR Label 155
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 155);
}
// ROR Label 156
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}
// ROR Label 157
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 157);
}

        
// ABS Label 162
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}

// COR Label 163
if((0 == cnt || (((pTab)->tabFlags & 512) == 0)) != (0 == cnt && (((pTab)->tabFlags & 512) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 163);
}

// ROR Label 164
if((0 != cnt) != (0 == cnt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}

// MCC Label 165
if(0 == cnt && ( ((pTab)->tabFlags & 512) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
// MCC Label 166
if(0 == cnt && ( !(((pTab)->tabFlags & 512) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(!(0 == cnt) && ( ((pTab)->tabFlags & 512) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
// MCC Label 168
if(!(0 == cnt) && ( !(((pTab)->tabFlags & 512) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
if( 0==cnt && VisibleRowid(pTab) ){
          cntTab++;
          pMatch = pItem;
        }
      };
// ABS Label 103
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
// ABS Label 104
if(pSrcList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}

// ROR Label 105
if((i <= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
// ROR Label 106
if((i > pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
// ROR Label 107
if((i >= pSrcList->nSrc) != (i < pSrcList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}

      
// ABS Label 169
if(pMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 169);
}
if( pMatch ){
        pExpr->iTable = pMatch->iCursor;
        pExpr->y.pTab = pMatch->pTab;
        /* RIGHT JOIN not (yet) supported */
        assert( (pMatch->fg.jointype & JT_RIGHT)==0 );
        
// ROR Label 170
if(((pMatch->fg.jointype & 8) == 0) != ((pMatch->fg.jointype & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 170);
}
if( (pMatch->fg.jointype & JT_LEFT)!=0 ){
          ExprSetProperty(pExpr, EP_CanBeNull);
        }
        pSchema = pExpr->y.pTab->pSchema;
      }
    } /* if( pSrcList ) */

#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)
    /* If we have not already resolved the name, then maybe 
    ** it is a new.* or old.* trigger argument reference.  Or
    ** maybe it is an excluded.* from an upsert.  Or maybe it is
    ** a reference in the RETURNING clause to a table being modified.
    */
    
// ABS Label 171
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}
// ABS Label 172
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}

// COR Label 173
if((cnt == 0 || zDb == 0) != (cnt == 0 && zDb == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 173);
}

// ROR Label 174
if((cnt != 0) != (cnt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((zDb != 0) != (zDb == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}

// MCC Label 176
if(cnt == 0 && zDb == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
// MCC Label 177
if(cnt == 0 && !(zDb == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(!(cnt == 0) && zDb == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(!(cnt == 0) && !(zDb == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
if( cnt==0 && zDb==0 ){
      pTab = 0;
#ifndef SQLITE_OMIT_TRIGGER
      
// ABS Label 180
if(pParse->pTriggerTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}

// ROR Label 181
if((pParse->pTriggerTab == 0) != (pParse->pTriggerTab != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 181);
}
if( pParse->pTriggerTab!=0 ){
        int op = pParse->eTriggerOp;
        assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );
        
// ABS Label 182
if(pParse->bReturning < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
if( pParse->bReturning ){
          if( (pNC->ncFlags & NC_UBaseReg)!=0
           && (zTab==0 || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0)
          ){
            pExpr->iTable = op!=TK_DELETE;
            pTab = pParse->pTriggerTab;
          }
        }else { if( op!=TK_DELETE && zTab && sqlite3StrICmp("new",zTab) == 0 ){
          pExpr->iTable = 1;
          pTab = pParse->pTriggerTab;
        }else { if( op!=TK_INSERT && zTab && sqlite3StrICmp("old",zTab)==0 ){
          pExpr->iTable = 0;
          pTab = pParse->pTriggerTab;
        };}
;}

      }
#endif /* SQLITE_OMIT_TRIGGER */
#ifndef SQLITE_OMIT_UPSERT
      
// ABS Label 183
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}

// COR Label 184
if(((pNC->ncFlags & 512) != 0 || zTab != 0) != ((pNC->ncFlags & 512) != 0 && zTab != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 184);
}

// ROR Label 185
if(((pNC->ncFlags & 512) == 0) != ((pNC->ncFlags & 512) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
// ROR Label 186
if((zTab == 0) != (zTab != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 186);
}

// MCC Label 187
if((pNC->ncFlags & 512) != 0 && zTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}
// MCC Label 188
if((pNC->ncFlags & 512) != 0 && !(zTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 188);
}
// MCC Label 189
if(!((pNC->ncFlags & 512) != 0) && zTab != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 189);
}
// MCC Label 190
if(!((pNC->ncFlags & 512) != 0) && !(zTab != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 190);
}
if( (pNC->ncFlags & NC_UUpsert)!=0 && zTab!=0 ){
        
// ABS Label 191
if(pNC->uNC.pUpsert < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}
Upsert *pUpsert = pNC->uNC.pUpsert;
        if( pUpsert && sqlite3StrICmp("excluded",zTab)==0 ){
          pTab = pUpsert->pUpsertSrc->a[0].pTab;
          pExpr->iTable = EXCLUDED_TABLE_NUMBER;
        }
      }
#endif /* SQLITE_OMIT_UPSERT */

      
// ABS Label 192
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
if( pTab ){ 
        int iCol;
        u8 hCol = sqlite3StrIHash(zCol);
        pSchema = pTab->pSchema;
        cntTab++;
        iCol = 0 , pCol = pTab->aCol;

// ABS Label 193
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}

// ROR Label 194
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
// ROR Label 195
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 195);
}
// ROR Label 196
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}
for(; iCol<pTab->nCol; iCol++, pCol++){
          if( pCol->hName==hCol && sqlite3StrICmp(pCol->zName, zCol)==0 ){
            
// ABS Label 201
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}

// ROR Label 202
if((iCol != pTab->iPKey) != (iCol == pTab->iPKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
if( iCol==pTab->iPKey ){
              iCol = -1;
            }
            break;
          }
        };
// ABS Label 197
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}

// ROR Label 198
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 198);
}
// ROR Label 199
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
// ROR Label 200
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}

        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){
          /* IMP: R-51414-32910 */
          iCol = -1;
        }
        
// ABS Label 203
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}

// ROR Label 204
if((iCol <= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((iCol > pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((iCol >= pTab->nCol) != (iCol < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
if( iCol<pTab->nCol ){
          cnt++;
          pMatch = 0;
#ifndef SQLITE_OMIT_UPSERT
          
// ABS Label 207
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ROR Label 208
if((pExpr->iTable != 2) != (pExpr->iTable == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
if( pExpr->iTable==EXCLUDED_TABLE_NUMBER ){
            testcase( iCol==(-1) );
            
// MCC Label 209
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
if( IN_RENAME_OBJECT ){
              pExpr->iColumn = iCol;
              pExpr->y.pTab = pTab;
              eNewExprOp = TK_COLUMN;
            }else{
              pExpr->iTable = pNC->uNC.pUpsert->regData +
                 sqlite3TableColumnToStorage(pTab, iCol);
              eNewExprOp = TK_REGISTER;
            }
          }else
#endif /* SQLITE_OMIT_UPSERT */
          {
            pExpr->y.pTab = pTab;
            
// ABS Label 211
if(pParse->bReturning < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}
if( pParse->bReturning ){
              eNewExprOp = TK_REGISTER;
              pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol+1)*pExpr->iTable +
                 sqlite3TableColumnToStorage(pTab, iCol) + 1;
            }else{
              pExpr->iColumn = (i16)iCol;
              eNewExprOp = TK_TRIGGER;
#ifndef SQLITE_OMIT_TRIGGER
              
// ABS Label 212
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// ROR Label 213
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 213);
}
// ROR Label 214
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 214);
}
// ROR Label 215
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 215);
}
if( iCol<0 ){
                pExpr->affExpr = SQLITE_AFF_INTEGER;
              }else { 
// ABS Label 216
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// ROR Label 217
if((pExpr->iTable != 0) != (pExpr->iTable == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
if( pExpr->iTable==0 ){
                testcase( iCol==31 );
                testcase( iCol==32 );
                pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
              }else{
                testcase( iCol==31 );
                testcase( iCol==32 );
                pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
              };}

#endif /* SQLITE_OMIT_TRIGGER */
            }
          }
        }
      }
    }
#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */

    /*
    ** Perhaps the name is a reference to the ROWID
    */
    if( cnt==0
     && cntTab==1
     && pMatch
     && (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0
     && sqlite3IsRowid(zCol)
     && ALWAYS(VisibleRowid(pMatch->pTab))
    ){
      cnt = 1;
      pExpr->iColumn = -1;
      pExpr->affExpr = SQLITE_AFF_INTEGER;
    }

    /*
    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z
    ** might refer to an result-set alias.  This happens, for example, when
    ** we are resolving names in the WHERE clause of the following command:
    **
    **     SELECT a+b AS x FROM table WHERE x<10;
    **
    ** In cases like this, replace pExpr with a copy of the expression that
    ** forms the result set entry ("a+b" in the example) and return immediately.
    ** Note that the expression in the result set should have already been
    ** resolved by the time the WHERE clause is resolved.
    **
    ** The ability to use an output result-set column in the WHERE, GROUP BY,
    ** or HAVING clauses, or as part of a larger expression in the ORDER BY
    ** clause is not standard SQL.  This is a (goofy) SQLite extension, that
    ** is supported for backwards compatibility only. Hence, we issue a warning
    ** on sqlite3_log() whenever the capability is used.
    */
    
// ABS Label 218
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}
// ABS Label 219
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}

// COR Label 220
if((cnt == 0 && (pNC->ncFlags & 128) != 0 || zTab == 0) != (cnt == 0 && (pNC->ncFlags & 128) != 0 && zTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 220);
}
// COR Label 221
if((cnt == 0 || (pNC->ncFlags & 128) != 0) != (cnt == 0 && (pNC->ncFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 221);
}

// ROR Label 222
if((cnt != 0) != (cnt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
// ROR Label 223
if(((pNC->ncFlags & 128) == 0) != ((pNC->ncFlags & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
// ROR Label 224
if((zTab != 0) != (zTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 224);
}

// MCC Label 225
if(cnt == 0 && (pNC->ncFlags & 128) != 0 && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
// MCC Label 226
if(cnt == 0 && (pNC->ncFlags & 128) != 0 && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 226);
}
// MCC Label 227
if(cnt == 0 && !((pNC->ncFlags & 128) != 0) && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 227);
}
// MCC Label 228
if(cnt == 0 && !((pNC->ncFlags & 128) != 0) && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 228);
}
// MCC Label 229
if(!(cnt == 0) && (pNC->ncFlags & 128) != 0 && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 229);
}
// MCC Label 230
if(!(cnt == 0) && (pNC->ncFlags & 128) != 0 && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(!(cnt == 0) && !((pNC->ncFlags & 128) != 0) && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(!(cnt == 0) && !((pNC->ncFlags & 128) != 0) && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
if( cnt==0
     && (pNC->ncFlags & NC_UEList)!=0
     && zTab==0
    ){
      pEList = pNC->uNC.pEList;
      assert( pEList!=0 );
      j = 0;

// ABS Label 233
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}
// ABS Label 234
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}

// ROR Label 235
if((j <= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
// ROR Label 236
if((j > pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
// ROR Label 237
if((j >= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
for(; j<pEList->nExpr; j++){
        
// ABS Label 243
if(pEList->a[j].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}
char *zAs = pEList->a[j].zEName;
        if( pEList->a[j].eEName==ENAME_NAME
         && sqlite3_stricmp(zAs, zCol)==0
        ){
          Expr *pOrig;
          assert( pExpr->pLeft==0 && pExpr->pRight==0 );
          assert( pExpr->x.pList==0 );
          assert( pExpr->x.pSelect==0 );
          pOrig = pEList->a[j].pExpr;
          
// COR Label 249
if(((pNC->ncFlags & 1) == 0 || (((pOrig)->flags & (16)) != 0)) != ((pNC->ncFlags & 1) == 0 && (((pOrig)->flags & (16)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 249);
}

// ROR Label 250
if(((pNC->ncFlags & 1) != 0) != ((pNC->ncFlags & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}

// MCC Label 251
if((pNC->ncFlags & 1) == 0 && ( ((pOrig)->flags & (16)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 251);
}
// MCC Label 252
if((pNC->ncFlags & 1) == 0 && ( !(((pOrig)->flags & (16)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 252);
}
// MCC Label 253
if(!((pNC->ncFlags & 1) == 0) && ( ((pOrig)->flags & (16)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 253);
}
// MCC Label 254
if(!((pNC->ncFlags & 1) == 0) && ( !(((pOrig)->flags & (16)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 254);
}
if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){
            
// ABS Label 255
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}

// ABS Label 256
if(zAs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}
sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
            return WRC_Abort;
          }
          
// COR Label 257
if(((((pOrig)->flags & (32768)) != 0) || ((pNC->ncFlags & 16384) == 0 || pNC != pTopNC)) != ((((pOrig)->flags & (32768)) != 0) && ((pNC->ncFlags & 16384) == 0 || pNC != pTopNC)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 257);
}

// MCC Label 258
if(( ((pOrig)->flags & (32768)) != 0 ) && ( (pNC->ncFlags & 16384) == 0 && pNC != pTopNC ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 258);
}
// MCC Label 259
if(( ((pOrig)->flags & (32768)) != 0 ) && ( (pNC->ncFlags & 16384) == 0 && !(pNC != pTopNC) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 259);
}
// MCC Label 260
if(( ((pOrig)->flags & (32768)) != 0 ) && ( !((pNC->ncFlags & 16384) == 0) && pNC != pTopNC ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if(( ((pOrig)->flags & (32768)) != 0 ) && ( !((pNC->ncFlags & 16384) == 0) && !(pNC != pTopNC) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(( !(((pOrig)->flags & (32768)) != 0) ) && ( (pNC->ncFlags & 16384) == 0 && pNC != pTopNC ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(( !(((pOrig)->flags & (32768)) != 0) ) && ( (pNC->ncFlags & 16384) == 0 && !(pNC != pTopNC) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
// MCC Label 264
if(( !(((pOrig)->flags & (32768)) != 0) ) && ( !((pNC->ncFlags & 16384) == 0) && pNC != pTopNC ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(( !(((pOrig)->flags & (32768)) != 0) ) && ( !((pNC->ncFlags & 16384) == 0) && !(pNC != pTopNC) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
if( ExprHasProperty(pOrig, EP_Win)
           && ((pNC->ncFlags&NC_AllowWin)==0 || pNC!=pTopNC )
          ){
            
// ABS Label 266
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}

// ABS Label 267
if(zAs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 267);
}
sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",zAs);
            return WRC_Abort;
          }
          if( sqlite3ExprVectorSize(pOrig)!=1 ){
            
// ABS Label 268
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}
sqlite3ErrorMsg(pParse, "row value misused");
            return WRC_Abort;
          }
          
// ABS Label 244
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ABS Label 245
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}

// ABS Label 246
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}

// ABS Label 247
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}

// ABS Label 248
if(nSubquery < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
resolveAlias(pParse, pEList, j, pExpr, nSubquery);
          cnt = 1;
          pMatch = 0;
          assert( zTab==0 && zDb==0 );
          
// MCC Label 269
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
if( IN_RENAME_OBJECT ){
            
// ABS Label 271
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
          }
          goto lookupname_end;
        }
      };
// ABS Label 238
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}
// ABS Label 239
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// ROR Label 240
if((j <= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 240);
}
// ROR Label 241
if((j > pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((j >= pEList->nExpr) != (j < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
 
    }

    /* Advance to the next name context.  The loop will exit when either
    ** we have a match (cnt>0) or when we run out of name contexts.
    */
    
// ABS Label 272
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
if( cnt ) { break;
}
    pNC = pNC->pNext;
    nSubquery++;
  }while( pNC );
// ABS Label 95
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}
;


  /*
  ** If X and Y are NULL (in other words if only the column name Z is
  ** supplied) and the value of Z is enclosed in double-quotes, then
  ** Z is a string literal if it doesn't match any column names.  In that
  ** case, we need to return right away and not make any changes to
  ** pExpr.
  **
  ** Because no reference was made to outer contexts, the pNC->nRef
  ** fields are not changed in any context.
  */
  
// ABS Label 273
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}
// ABS Label 274
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}

// COR Label 275
if((cnt == 0 || zTab == 0) != (cnt == 0 && zTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 275);
}

// ROR Label 276
if((cnt != 0) != (cnt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 276);
}
// ROR Label 277
if((zTab != 0) != (zTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 277);
}

// MCC Label 278
if(cnt == 0 && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}
// MCC Label 279
if(cnt == 0 && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 279);
}
// MCC Label 280
if(!(cnt == 0) && zTab == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 280);
}
// MCC Label 281
if(!(cnt == 0) && !(zTab == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 281);
}
if( cnt==0 && zTab==0 ){
    assert( pExpr->op==TK_ID );
    if( ExprHasProperty(pExpr,EP_DblQuoted)
     && areDoubleQuotedStringsEnabled(db, pTopNC)
    ){
      /* If a double-quoted identifier does not match any known column name,
      ** then treat it as a string.
      **
      ** This hack was added in the early days of SQLite in a misguided attempt
      ** to be compatible with MySQL 3.x, which used double-quotes for strings.
      ** I now sorely regret putting in this hack. The effect of this hack is
      ** that misspelled identifier names are silently converted into strings
      ** rather than causing an error, to the frustration of countless
      ** programmers. To all those frustrated programmers, my apologies.
      **
      ** Someday, I hope to get rid of this hack. Unfortunately there is
      ** a huge amount of legacy SQL that uses it. So for now, we just
      ** issue a warning.
      */
      
// ABS Label 282
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
sqlite3_log(SQLITE_WARNING,
        "double-quoted string literal: \"%w\"", zCol);
#ifdef SQLITE_ENABLE_NORMALIZE
      sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);
#endif
      pExpr->op = TK_STRING;
      pExpr->y.pTab = 0;
      return WRC_Prune;
    }
    if( sqlite3ExprIdToTrueFalse(pExpr) ){
      return WRC_Prune;
    }
  }

  /*
  ** cnt==0 means there was not match.  cnt>1 means there were two or
  ** more matches.  Either way, we have an error.
  */
  
// ABS Label 283
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((cnt == 1) != (cnt != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
if( cnt!=1 ){
    const char *zErr;
    zErr = cnt==0 ? "no such column" : "ambiguous column name";
    
// ABS Label 285
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
if( zDb ){
      
// ABS Label 286
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ABS Label 287
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}

// ABS Label 288
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}

// ABS Label 289
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// ABS Label 290
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}
sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
    }else { 
// ABS Label 291
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}
if( zTab ){
      
// ABS Label 292
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}

// ABS Label 293
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ABS Label 294
if(zTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}

// ABS Label 295
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
    }else{
      
// ABS Label 296
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// ABS Label 297
if(zErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ABS Label 298
if(zCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
    };}

    pParse->checkSchema = 1;
    pTopNC->nNcErr++;
  }

  /* If a column from a table in pSrcList is referenced, then record
  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes
  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  Bit 63 is
  ** set if the 63rd or any subsequent column is used.
  **
  ** The colUsed mask is an optimization used to help determine if an
  ** index is a covering index.  The correct answer is still obtained
  ** if the mask contains extra set bits.  However, it is important to
  ** avoid setting bits beyond the maximum column number of the table.
  ** (See ticket [b92e5e8ec2cdbaa1]).
  **
  ** If a generated column is referenced, set bits for every column
  ** of the table.
  */
  
// ABS Label 299
if(pMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}

// COR Label 300
if((pExpr->iColumn >= 0 || pMatch != 0) != (pExpr->iColumn >= 0 && pMatch != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 300);
}

// ROR Label 301
if((pExpr->iColumn < 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 301);
}
// ROR Label 302
if((pExpr->iColumn > 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}
// ROR Label 303
if((pExpr->iColumn <= 0) != (pExpr->iColumn >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 303);
}
// ROR Label 304
if((pMatch == 0) != (pMatch != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}

// MCC Label 305
if(pExpr->iColumn >= 0 && pMatch != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 305);
}
// MCC Label 306
if(pExpr->iColumn >= 0 && !(pMatch != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 306);
}
// MCC Label 307
if(!(pExpr->iColumn >= 0) && pMatch != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 307);
}
// MCC Label 308
if(!(pExpr->iColumn >= 0) && !(pMatch != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 308);
}
if( pExpr->iColumn>=0 && pMatch!=0 ){
    pMatch->colUsed |= sqlite3ExprColUsed(pExpr);
  }

  /* Clean up and return
  */
  if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){
    
// ABS Label 309
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}

// ABS Label 310
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}
sqlite3ExprDelete(db, pExpr->pLeft);
    pExpr->pLeft = 0;
    
// ABS Label 311
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}

// ABS Label 312
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
sqlite3ExprDelete(db, pExpr->pRight);
    pExpr->pRight = 0;
  }
  pExpr->op = eNewExprOp;
  ExprSetProperty(pExpr, EP_Leaf);
lookupname_end:
  
// ABS Label 313
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}

// ROR Label 314
if((cnt != 1) != (cnt == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
if( cnt==1 ){
    assert( pNC!=0 );
#ifndef SQLITE_OMIT_AUTHORIZATION
    
// ABS Label 315
if(pParse->db->xAuth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}

// COR Label 316
if((pParse->db->xAuth || (pExpr->op == 166 || pExpr->op == 77)) != (pParse->db->xAuth && (pExpr->op == 166 || pExpr->op == 77)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 316);
}

// MCC Label 317
if(pParse->db->xAuth && ( pExpr->op == 166 && pExpr->op == 77 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 317);
}
// MCC Label 318
if(pParse->db->xAuth && ( pExpr->op == 166 && !(pExpr->op == 77) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 318);
}
// MCC Label 319
if(pParse->db->xAuth && ( !(pExpr->op == 166) && pExpr->op == 77 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 319);
}
// MCC Label 320
if(pParse->db->xAuth && ( !(pExpr->op == 166) && !(pExpr->op == 77) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 320);
}
// MCC Label 321
if(!(pParse->db->xAuth) && ( pExpr->op == 166 && pExpr->op == 77 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 321);
}
// MCC Label 322
if(!(pParse->db->xAuth) && ( pExpr->op == 166 && !(pExpr->op == 77) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
// MCC Label 323
if(!(pParse->db->xAuth) && ( !(pExpr->op == 166) && pExpr->op == 77 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
// MCC Label 324
if(!(pParse->db->xAuth) && ( !(pExpr->op == 166) && !(pExpr->op == 77) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 324);
}
if( pParse->db->xAuth
     && (pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER)
    ){
      
// ABS Label 325
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}

// ABS Label 326
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}

// ABS Label 327
if(pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}

// ABS Label 328
if(pNC->pSrcList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
    }
#endif
    /* Increment the nRef value on all name contexts from TopNC up to
    ** the point where the name matched. */
    for(;;){
      assert( pTopNC!=0 );
      pTopNC->nRef++;
      
// ABS Label 329
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
// ABS Label 330
if(pTopNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}

// ROR Label 331
if((pTopNC != pNC) != (pTopNC == pNC))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 331);
}
if( pTopNC==pNC ) { break;
}
      pTopNC = pTopNC->pNext;
    };
    return WRC_Prune;
  } else {
    return WRC_Abort;
  }
}

/*
** Allocate and return a pointer to an expression to load the column iCol
** from datasource iSrc in SrcList pSrc.
*/
Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){
  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);
  
// ABS Label 332
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}
if( p ){
    SrcItem *pItem = &pSrc->a[iSrc];
    Table *pTab = p->y.pTab = pItem->pTab;
    p->iTable = pItem->iCursor;
    
// ABS Label 333
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}

// ROR Label 334
if((p->y.pTab->iPKey != iCol) != (p->y.pTab->iPKey == iCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
if( p->y.pTab->iPKey==iCol ){
      p->iColumn = -1;
    }else{
      p->iColumn = (ynVar)iCol;
      
// COR Label 335
if(((pTab->tabFlags & 96) != 0 || (pTab->aCol[iCol].colFlags & 96) != 0) != ((pTab->tabFlags & 96) != 0 && (pTab->aCol[iCol].colFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 335);
}

// ROR Label 336
if(((pTab->tabFlags & 96) == 0) != ((pTab->tabFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}
// ROR Label 337
if(((pTab->aCol[iCol].colFlags & 96) == 0) != ((pTab->aCol[iCol].colFlags & 96) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}

// MCC Label 338
if((pTab->tabFlags & 96) != 0 && (pTab->aCol[iCol].colFlags & 96) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 338);
}
// MCC Label 339
if((pTab->tabFlags & 96) != 0 && !((pTab->aCol[iCol].colFlags & 96) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 339);
}
// MCC Label 340
if(!((pTab->tabFlags & 96) != 0) && (pTab->aCol[iCol].colFlags & 96) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 340);
}
// MCC Label 341
if(!((pTab->tabFlags & 96) != 0) && !((pTab->aCol[iCol].colFlags & 96) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 341);
}
if( (pTab->tabFlags & TF_HasGenerated)!=0
       && (pTab->aCol[iCol].colFlags & COLFLAG_GENERATED)!=0
      ){
        testcase( pTab->nCol==63 );
        testcase( pTab->nCol==64 );
        pItem->colUsed = pTab->nCol>=64 ? ALLBITS : MASKBIT(pTab->nCol)-1;
      }else{
        testcase( iCol==BMS );
        testcase( iCol==BMS-1 );
        pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);
      }
    }
  }
  
// ABS Label 342
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}
return p;
}

/*
** Report an error that an expression is not valid for some set of
** pNC->ncFlags values determined by validMask.
**
** static void notValid(
**   Parse *pParse,       // Leave error message here
**   NameContext *pNC,    // The name context 
**   const char *zMsg,    // Type of error
**   int validMask,       // Set of contexts for which prohibited
**   Expr *pExpr          // Invalidate this expression on error
** ){...}
**
** As an optimization, since the conditional is almost always false
** (because errors are rare), the conditional is moved outside of the
** function call using a macro.
*/
static void notValidImpl(
   Parse *pParse,       /* Leave error message here */
   NameContext *pNC,    /* The name context */
   const char *zMsg,    /* Type of error */
   Expr *pExpr          /* Invalidate this expression on error */
){
  const char *zIn = "partial index WHERE clauses";
  
// ABS Label 346
if(pNC->ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}

// AOR Label 347
if(pNC->ncFlags | 32 != pNC->ncFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 347);
}
// AOR Label 348
if(pNC->ncFlags ^ 32 != pNC->ncFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 348);
}
if( pNC->ncFlags & NC_IdxExpr ) {      zIn = "index expressions";
#ifndef SQLITE_OMIT_CHECK
  } else { 
// ABS Label 349
if(pNC->ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}

// AOR Label 350
if(pNC->ncFlags | 4 != pNC->ncFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 350);
}
// AOR Label 351
if(pNC->ncFlags ^ 4 != pNC->ncFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 351);
}
if( pNC->ncFlags & NC_IsCheck ) { zIn = "CHECK constraints";
#endif
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
  } else { 
// ABS Label 352
if(pNC->ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}

// AOR Label 353
if(pNC->ncFlags | 8 != pNC->ncFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 353);
}
// AOR Label 354
if(pNC->ncFlags ^ 8 != pNC->ncFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 354);
}
if( pNC->ncFlags & NC_GenCol ) { zIn = "generated columns";
};}
;}

#endif
  
// ABS Label 343
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}

// ABS Label 344
if(zMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}

// ABS Label 345
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}
sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
  
// ABS Label 355
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
if( pExpr ) { pExpr->op = TK_NULL;
}
}
#define sqlite3ResolveNotValid(P,N,M,X,E) \
  assert( ((X)&~(NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol))==0 ); \
  if( ((N)->ncFlags & (X))!=0 ) notValidImpl(P,N,M,E);

/*
** Expression p should encode a floating point value between 1.0 and 0.0.
** Return 1024 times this value.  Or return -1 if p is not a floating point
** value between 1.0 and 0.0.
*/
static int exprProbability(Expr *p){
  double r = -1.0;
  
// ROR Label 356
if((p->op == 152) != (p->op != 152))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 356);
}
if( p->op!=TK_FLOAT ) { return -1;
}
  sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), SQLITE_UTF8);
  assert( r>=0.0 );
  
// ABS Label 357
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}

// ROR Label 358
if((r <= 1.) != (r > 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 358);
}
// ROR Label 359
if((r < 1.) != (r > 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 359);
}
// ROR Label 360
if((r >= 1.) != (r > 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 360);
}
if( r>1.0 ) { return -1;
}
  return (int)(r*134217728.0);
}

/*
** This routine is callback for sqlite3WalkExpr().
**
** Resolve symbolic names into TK_COLUMN operators for the current
** node in the expression tree.  Return 0 to continue the search down
** the tree or 2 to abort the tree walk.
**
** This routine also does error checking and name resolution for
** function names.  The operator for aggregate functions is changed
** to TK_AGG_FUNCTION.
*/
static int resolveExprStep(Walker *pWalker, Expr *pExpr){
  NameContext *pNC;
  Parse *pParse;

  pNC = pWalker->u.pNC;
  assert( pNC!=0 );
  pParse = pNC->pParse;
  assert( pParse==pWalker->pParse );

#ifndef NDEBUG
  if( pNC->pSrcList && pNC->pSrcList->nAlloc>0 ){
    SrcList *pSrcList = pNC->pSrcList;
    int i;
    for(i=0; i<pNC->pSrcList->nSrc; i++){
      assert( pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab);
    }
  }
#endif
  switch( pExpr->op ){

    /* The special operator TK_ROW means use the rowid for the first
    ** column in the FROM clause.  This is used by the LIMIT and ORDER BY
    ** clause processing on UPDATE and DELETE statements, and by 
    ** UPDATE ... FROM statement processing.
    */
    case TK_ROW: {
      
// ABS Label 361
if(pNC->pSrcList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 361);
}
SrcList *pSrcList = pNC->pSrcList;
      SrcItem *pItem;
      assert( pSrcList && pSrcList->nSrc>=1 );
      pItem = pSrcList->a;
      pExpr->op = TK_COLUMN;
      pExpr->y.pTab = pItem->pTab;
      pExpr->iTable = pItem->iCursor;
      pExpr->iColumn--;
      pExpr->affExpr = SQLITE_AFF_INTEGER;
      break;
    }

    /* An optimization:  Attempt to convert
    **
    **      "expr IS NOT NULL"  -->  "TRUE"
    **      "expr IS NULL"      -->  "FALSE"
    **
    ** if we can prove that "expr" is never NULL.  Call this the
    ** "NOT NULL strength reduction optimization".
    **
    ** If this optimization occurs, also restore the NameContext ref-counts
    ** to the state they where in before the "column" LHS expression was
    ** resolved.  This prevents "column" from being counted as having been
    ** referenced, which might prevent a SELECT from being erroneously
    ** marked as correlated.
    */
    case TK_NOTNULL:
    case TK_ISNULL: {
      int anRef[8];
      NameContext *p;
      int i;
      i = 0 , p = pNC;

// ABS Label 364
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 364);
}
// ABS Label 365
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}

// COR Label 366
if((p || i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (p && i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 366);
}

// ROR Label 367
if((i <= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}
// ROR Label 368
if((i > ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}
// ROR Label 369
if((i >= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 369);
}

// MCC Label 370
if(p && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(p && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}
// MCC Label 372
if(!(p) && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 372);
}
// MCC Label 373
if(!(p) && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 373);
}
for(; p && i<ArraySize(anRef); p=p->pNext, i++){ 
        anRef[i] = p->nRef;
      };
// ABS Label 374
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
// ABS Label 375
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}

// COR Label 376
if((p || i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (p && i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 376);
}

// ROR Label 377
if((i <= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((i > ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
// ROR Label 379
if((i >= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 379);
}

// MCC Label 380
if(p && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(p && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(!(p) && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}
// MCC Label 383
if(!(p) && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}

      
// ABS Label 362
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}

// ABS Label 363
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 363);
}
sqlite3WalkExpr(pWalker, pExpr->pLeft);
      if( 0==sqlite3ExprCanBeNull(pExpr->pLeft) && !IN_RENAME_OBJECT ){
        
// ROR Label 386
if((pExpr->op != 51) != (pExpr->op == 51))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
if( pExpr->op==TK_NOTNULL ){
          pExpr->u.zToken = "true";
          ExprSetProperty(pExpr, EP_IsTrue);
        }else{
          pExpr->u.zToken = "false";
          ExprSetProperty(pExpr, EP_IsFalse);
        }
        pExpr->op = TK_TRUEFALSE;
        i = 0 , p = pNC;

// ABS Label 387
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}
// ABS Label 388
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}

// COR Label 389
if((p || i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (p && i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 389);
}

// ROR Label 390
if((i <= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 390);
}
// ROR Label 391
if((i > ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}
// ROR Label 392
if((i >= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 392);
}

// MCC Label 393
if(p && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(p && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(!(p) && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(!(p) && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
for(; p && i<ArraySize(anRef); p=p->pNext, i++){
          p->nRef = anRef[i];
        };
// ABS Label 397
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
// ABS Label 398
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}

// COR Label 399
if((p || i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (p && i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 399);
}

// ROR Label 400
if((i <= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 400);
}
// ROR Label 401
if((i > ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 401);
}
// ROR Label 402
if((i >= ((int)(sizeof (anRef) / sizeof (anRef[0])))) != (i < ((int)(sizeof (anRef) / sizeof (anRef[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 402);
}

// MCC Label 403
if(p && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 403);
}
// MCC Label 404
if(p && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 404);
}
// MCC Label 405
if(!(p) && i < ((int)(sizeof (anRef) / sizeof (anRef[0]))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 405);
}
// MCC Label 406
if(!(p) && !(i < ((int)(sizeof (anRef) / sizeof (anRef[0])))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 406);
}

        
// ABS Label 384
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}

// ABS Label 385
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}
sqlite3ExprDelete(pParse->db, pExpr->pLeft);
        pExpr->pLeft = 0;
      }
      return WRC_Prune;
    }

    /* A column name:                    ID
    ** Or table name and column name:    ID.ID
    ** Or a database, table and column:  ID.ID.ID
    **
    ** The TK_ID and TK_OUT cases are combined so that there will only
    ** be one call to lookupName().  Then the compiler will in-line 
    ** lookupName() for a size reduction and performance increase.
    */
    case TK_ID:
    case TK_DOT: {
      const char *zColumn;
      const char *zTable;
      const char *zDb;
      Expr *pRight;

      
// ROR Label 407
if((pExpr->op != 59) != (pExpr->op == 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 407);
}
if( pExpr->op==TK_ID ){
        zDb = 0;
        zTable = 0;
        zColumn = pExpr->u.zToken;
      }else{
        
// ABS Label 408
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}
Expr *pLeft = pExpr->pLeft;
        testcase( pNC->ncFlags & NC_IdxExpr );
        testcase( pNC->ncFlags & NC_GenCol );
        sqlite3ResolveNotValid(pParse, pNC, "the \".\" operator",
                               NC_IdxExpr|NC_GenCol, 0);
        pRight = pExpr->pRight;
        
// ROR Label 410
if((pRight->op != 59) != (pRight->op == 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
if( pRight->op==TK_ID ){
          zDb = 0;
        }else{
          assert( pRight->op==TK_DOT );
          zDb = pLeft->u.zToken;
          pLeft = pRight->pLeft;
          pRight = pRight->pRight;
        }
        zTable = pLeft->u.zToken;
        zColumn = pRight->u.zToken;
        
// MCC Label 411
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
// MCC Label 412
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
if( IN_RENAME_OBJECT ){
          
// ABS Label 413
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
sqlite3RenameTokenRemap(pParse, (void*)pExpr, (void*)pRight);
          
// ABS Label 414
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}
sqlite3RenameTokenRemap(pParse, (void*)&pExpr->y.pTab, (void*)pLeft);
        }
      }
      return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);
    }

    /* Resolve function names
    */
    case TK_FUNCTION: {
      
// ABS Label 415
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}
ExprList *pList = pExpr->x.pList;    /* The argument list */
      int n = pList ? pList->nExpr : 0;    /* Number of arguments */
      int no_such_func = 0;       /* True if no such function exists */
      int wrong_num_args = 0;     /* True if wrong number of arguments */
      int is_agg = 0;             /* True if is an aggregate function */
      int nId;                    /* Number of characters in function name */
      const char *zId;            /* The function name. */
      FuncDef *pDef;              /* Information about the function */
      
// ABS Label 416
if(((pParse->db)->enc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
u8 enc = ENC(pParse->db);   /* The database encoding */
      int savedAllowFlags = (pNC->ncFlags & (NC_AllowAgg | NC_AllowWin));
#ifndef SQLITE_OMIT_WINDOWFUNC
      Window *pWin = (IsWindowFunc(pExpr) ? pExpr->y.pWin : 0);
#endif
      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
      zId = pExpr->u.zToken;
      nId = sqlite3Strlen30(zId);
      pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);
      
// ABS Label 419
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}

// ROR Label 420
if((pDef != 0) != (pDef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
if( pDef==0 ){
        pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, 0);
        
// ABS Label 421
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}

// ROR Label 422
if((pDef != 0) != (pDef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 422);
}
if( pDef==0 ){
          no_such_func = 1;
        }else{
          wrong_num_args = 1;
        }
      }else{
        is_agg = pDef->xFinalize!=0;
        
// ABS Label 423
if(pDef->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}

// AOR Label 424
if(pDef->funcFlags | 1024 != pDef->funcFlags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 424);
}
// AOR Label 425
if(pDef->funcFlags ^ 1024 != pDef->funcFlags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 425);
}
if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){
          ExprSetProperty(pExpr, EP_Unlikely);
          
// ABS Label 426
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}

// ROR Label 427
if((n != 2) != (n == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
if( n==2 ){
            pExpr->iTable = exprProbability(pList->a[1].pExpr);
            
// ABS Label 428
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// ROR Label 429
if((pExpr->iTable <= 0) != (pExpr->iTable < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 429);
}
// ROR Label 430
if((pExpr->iTable > 0) != (pExpr->iTable < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 430);
}
// ROR Label 431
if((pExpr->iTable >= 0) != (pExpr->iTable < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 431);
}
if( pExpr->iTable<0 ){
              
// ABS Label 432
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 432);
}
sqlite3ErrorMsg(pParse,
                "second argument to likelihood() must be a "
                "constant between 0.0 and 1.0");
              pNC->nNcErr++;
            }
          }else{
            /* EVIDENCE-OF: R-61304-29449 The unlikely(X) function is
            ** equivalent to likelihood(X, 0.0625).
            ** EVIDENCE-OF: R-01283-11636 The unlikely(X) function is
            ** short-hand for likelihood(X,0.0625).
            ** EVIDENCE-OF: R-36850-34127 The likely(X) function is short-hand
            ** for likelihood(X,0.9375).
            ** EVIDENCE-OF: R-53436-40973 The likely(X) function is equivalent
            ** to likelihood(X,0.9375). */
            /* TUNING: unlikely() probability is 0.0625.  likely() is 0.9375 */
            pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;
          }             
        }
#ifndef SQLITE_OMIT_AUTHORIZATION
        {
          int auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0,pDef->zName,0);
          
// ABS Label 433
if(auth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 433);
}

// ROR Label 434
if((auth == 0) != (auth != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 434);
}
if( auth!=SQLITE_OK ){
            
// ABS Label 435
if(auth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}

// ROR Label 436
if((auth != 1) != (auth == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
if( auth==SQLITE_DENY ){
              
// ABS Label 437
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 437);
}

// ABS Label 438
if(pDef->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 438);
}
sqlite3ErrorMsg(pParse, "not authorized to use function: %s",
                                      pDef->zName);
              pNC->nNcErr++;
            }
            pExpr->op = TK_NULL;
            return WRC_Prune;
          }
        }
#endif
        
// ABS Label 439
if(pDef->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 439);
}

// AOR Label 440
if(pDef->funcFlags | (2048 | 8192) != pDef->funcFlags & (2048 | 8192))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 440);
}
// AOR Label 441
if(pDef->funcFlags ^ (2048 | 8192) != pDef->funcFlags & (2048 | 8192))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 441);
}
if( pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG) ){
          /* For the purposes of the EP_ConstFunc flag, date and time
          ** functions and other functions that change slowly are considered
          ** constant because they are constant for the duration of one query.
          ** This allows them to be factored out of inner loops. */
          ExprSetProperty(pExpr,EP_ConstFunc);
        }
        
// ROR Label 442
if(((pDef->funcFlags & 2048) != 0) != ((pDef->funcFlags & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 442);
}
if( (pDef->funcFlags & SQLITE_FUNC_CONSTANT)==0 ){
          /* Clearly non-deterministic functions like random(), but also
          ** date/time functions that use 'now', and other functions like
          ** sqlite_version() that might change over time cannot be used
          ** in an index or generated column.  Curiously, they can be used
          ** in a CHECK constraint.  SQLServer, MySQL, and PostgreSQL all
          ** all this. */
          sqlite3ResolveNotValid(pParse, pNC, "non-deterministic functions",
                                 NC_IdxExpr|NC_PartIdx|NC_GenCol, 0);
        }else{
          assert( (NC_SelfRef & 0xff)==NC_SelfRef ); /* Must fit in 8 bits */
          pExpr->op2 = pNC->ncFlags & NC_SelfRef;
          
// ABS Label 444
if(pNC->ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}

// AOR Label 445
if(pNC->ncFlags | 262144 != pNC->ncFlags & 262144)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 445);
}
// AOR Label 446
if(pNC->ncFlags ^ 262144 != pNC->ncFlags & 262144)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 446);
}
if( pNC->ncFlags & NC_FromDDL ) { ExprSetProperty(pExpr, EP_FromDDL);
}
        }
        
// COR Label 447
if(((pDef->funcFlags & 262144) != 0 && pParse->nested == 0 || (pParse->db->mDbFlags & 32) == 0) != ((pDef->funcFlags & 262144) != 0 && pParse->nested == 0 && (pParse->db->mDbFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 447);
}
// COR Label 448
if(((pDef->funcFlags & 262144) != 0 || pParse->nested == 0) != ((pDef->funcFlags & 262144) != 0 && pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 448);
}

// ROR Label 449
if(((pDef->funcFlags & 262144) == 0) != ((pDef->funcFlags & 262144) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 449);
}
// ROR Label 450
if((pParse->nested != 0) != (pParse->nested == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 450);
}
// ROR Label 451
if(((pParse->db->mDbFlags & 32) != 0) != ((pParse->db->mDbFlags & 32) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}

// MCC Label 452
if((pDef->funcFlags & 262144) != 0 && pParse->nested == 0 && (pParse->db->mDbFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 452);
}
// MCC Label 453
if((pDef->funcFlags & 262144) != 0 && pParse->nested == 0 && !((pParse->db->mDbFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 453);
}
// MCC Label 454
if((pDef->funcFlags & 262144) != 0 && !(pParse->nested == 0) && (pParse->db->mDbFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 454);
}
// MCC Label 455
if((pDef->funcFlags & 262144) != 0 && !(pParse->nested == 0) && !((pParse->db->mDbFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 455);
}
// MCC Label 456
if(!((pDef->funcFlags & 262144) != 0) && pParse->nested == 0 && (pParse->db->mDbFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 456);
}
// MCC Label 457
if(!((pDef->funcFlags & 262144) != 0) && pParse->nested == 0 && !((pParse->db->mDbFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 457);
}
// MCC Label 458
if(!((pDef->funcFlags & 262144) != 0) && !(pParse->nested == 0) && (pParse->db->mDbFlags & 32) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 458);
}
// MCC Label 459
if(!((pDef->funcFlags & 262144) != 0) && !(pParse->nested == 0) && !((pParse->db->mDbFlags & 32) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 459);
}
if( (pDef->funcFlags & SQLITE_FUNC_INTERNAL)!=0
         && pParse->nested==0
         && (pParse->db->mDbFlags & DBFLAG_InternalFunc)==0
        ){
          /* Internal-use-only functions are disallowed unless the
          ** SQL is being compiled using sqlite3NestedParse() or
          ** the SQLITE_TESTCTRL_INTERNAL_FUNCTIONS test-control has be
          ** used to activate internal functionsn for testing purposes */
          no_such_func = 1;
          pDef = 0;
        }else {
        
// COR Label 460
if(((pDef->funcFlags & (524288 | 2097152)) != 0 || !(pParse->eParseMode >= 2)) != ((pDef->funcFlags & (524288 | 2097152)) != 0 && !(pParse->eParseMode >= 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 460);
}

// ROR Label 461
if(((pDef->funcFlags & (524288 | 2097152)) == 0) != ((pDef->funcFlags & (524288 | 2097152)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}

// MCC Label 462
if((pDef->funcFlags & (524288 | 2097152)) != 0 && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 462);
}
// MCC Label 463
if((pDef->funcFlags & (524288 | 2097152)) != 0 && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 463);
}
// MCC Label 464
if(!((pDef->funcFlags & (524288 | 2097152)) != 0) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
// MCC Label 465
if(!((pDef->funcFlags & (524288 | 2097152)) != 0) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 465);
}
if( (pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE))!=0
         && !IN_RENAME_OBJECT
        ){
          
// ABS Label 466
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}

// ABS Label 467
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 467);
}

// ABS Label 468
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 468);
}
sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
        };}

      }

      
// ROR Label 469
if((0 != (pParse->eParseMode >= 2)) != (0 == (pParse->eParseMode >= 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 469);
}
if( 0==IN_RENAME_OBJECT ){
#ifndef SQLITE_OMIT_WINDOWFUNC
        assert( is_agg==0 || (pDef->funcFlags & SQLITE_FUNC_MINMAX)
          || (pDef->xValue==0 && pDef->xInverse==0)
          || (pDef->xValue && pDef->xInverse && pDef->xSFunc && pDef->xFinalize)
        );
        
// ABS Label 470
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}
// ABS Label 471
if(pDef->xValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}
// ABS Label 472
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}

// COR Label 473
if((pDef && pDef->xValue == 0 || pWin) != (pDef && pDef->xValue == 0 && pWin))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 473);
}
// COR Label 474
if((pDef || pDef->xValue == 0) != (pDef && pDef->xValue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 474);
}

// ROR Label 475
if((pDef->xValue != 0) != (pDef->xValue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 475);
}

// MCC Label 476
if(pDef && pDef->xValue == 0 && pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 476);
}
// MCC Label 477
if(pDef && pDef->xValue == 0 && !(pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 477);
}
// MCC Label 478
if(pDef && !(pDef->xValue == 0) && pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 478);
}
// MCC Label 479
if(pDef && !(pDef->xValue == 0) && !(pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 479);
}
// MCC Label 480
if(!(pDef) && pDef->xValue == 0 && pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 480);
}
// MCC Label 481
if(!(pDef) && pDef->xValue == 0 && !(pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 481);
}
// MCC Label 482
if(!(pDef) && !(pDef->xValue == 0) && pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 482);
}
// MCC Label 483
if(!(pDef) && !(pDef->xValue == 0) && !(pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 483);
}
if( pDef && pDef->xValue==0 && pWin ){
          
// ABS Label 484
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}

// ABS Label 485
if(nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}

// ABS Label 486
if(zId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
sqlite3ErrorMsg(pParse, 
              "%.*s() may not be used as a window function", nId, zId
          );
          pNC->nNcErr++;
        }else { 
// COR Label 487
if(((is_agg && (pNC->ncFlags & 1) == 0) || (is_agg && (pDef->funcFlags & 65536) && !pWin) && (is_agg && pWin && (pNC->ncFlags & 16384) == 0)) != ((is_agg && (pNC->ncFlags & 1) == 0) || (is_agg && (pDef->funcFlags & 65536) && !pWin) || (is_agg && pWin && (pNC->ncFlags & 16384) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 487);
}
// COR Label 488
if(((is_agg && (pNC->ncFlags & 1) == 0) && (is_agg && (pDef->funcFlags & 65536) && !pWin)) != ((is_agg && (pNC->ncFlags & 1) == 0) || (is_agg && (pDef->funcFlags & 65536) && !pWin)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 488);
}

// MCC Label 489
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 489);
}
// MCC Label 490
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 490);
}
// MCC Label 491
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 491);
}
// MCC Label 492
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 492);
}
// MCC Label 493
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 493);
}
// MCC Label 494
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 494);
}
// MCC Label 495
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 495);
}
// MCC Label 496
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 496);
}
// MCC Label 497
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
// MCC Label 498
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 498);
}
// MCC Label 499
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
// MCC Label 500
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
// MCC Label 503
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 503);
}
// MCC Label 504
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 504);
}
// MCC Label 505
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 505);
}
// MCC Label 506
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}
// MCC Label 510
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 510);
}
// MCC Label 511
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 511);
}
// MCC Label 512
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 512);
}
// MCC Label 513
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 513);
}
// MCC Label 514
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 514);
}
// MCC Label 515
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 515);
}
// MCC Label 516
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 516);
}
// MCC Label 517
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 517);
}
// MCC Label 518
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 518);
}
// MCC Label 519
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 519);
}
// MCC Label 520
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 520);
}
// MCC Label 521
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 521);
}
// MCC Label 522
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 522);
}
// MCC Label 523
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 523);
}
// MCC Label 524
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 524);
}
// MCC Label 525
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 525);
}
// MCC Label 526
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 526);
}
// MCC Label 527
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 527);
}
// MCC Label 528
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 528);
}
// MCC Label 529
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 529);
}
// MCC Label 530
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 530);
}
// MCC Label 531
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 531);
}
// MCC Label 532
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 532);
}
// MCC Label 533
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 533);
}
// MCC Label 534
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 534);
}
// MCC Label 535
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 535);
}
// MCC Label 536
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 536);
}
// MCC Label 537
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 537);
}
// MCC Label 538
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 538);
}
// MCC Label 539
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 539);
}
// MCC Label 540
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 540);
}
// MCC Label 541
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
// MCC Label 542
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 542);
}
// MCC Label 543
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 543);
}
// MCC Label 544
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 544);
}
// MCC Label 545
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 545);
}
// MCC Label 546
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 546);
}
// MCC Label 547
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 547);
}
// MCC Label 548
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 548);
}
// MCC Label 549
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 549);
}
// MCC Label 550
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 550);
}
// MCC Label 551
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 551);
}
// MCC Label 552
if(( is_agg && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 552);
}
// MCC Label 553
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 553);
}
// MCC Label 554
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 554);
}
// MCC Label 555
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 555);
}
// MCC Label 556
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 556);
}
// MCC Label 557
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 557);
}
// MCC Label 558
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 558);
}
// MCC Label 559
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 559);
}
// MCC Label 560
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 560);
}
// MCC Label 561
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 561);
}
// MCC Label 562
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 562);
}
// MCC Label 563
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 563);
}
// MCC Label 564
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 564);
}
// MCC Label 565
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 565);
}
// MCC Label 566
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 566);
}
// MCC Label 567
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 567);
}
// MCC Label 568
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 568);
}
// MCC Label 569
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 569);
}
// MCC Label 570
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 570);
}
// MCC Label 571
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 571);
}
// MCC Label 572
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 572);
}
// MCC Label 573
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 573);
}
// MCC Label 574
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 574);
}
// MCC Label 575
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
// MCC Label 577
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 577);
}
// MCC Label 578
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
// MCC Label 579
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 579);
}
// MCC Label 580
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 580);
}
// MCC Label 581
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 581);
}
// MCC Label 582
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
// MCC Label 586
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 586);
}
// MCC Label 587
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 587);
}
// MCC Label 588
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 588);
}
// MCC Label 589
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 589);
}
// MCC Label 590
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 590);
}
// MCC Label 591
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 591);
}
// MCC Label 592
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 592);
}
// MCC Label 593
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 593);
}
// MCC Label 594
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 594);
}
// MCC Label 595
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
// MCC Label 597
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}
// MCC Label 599
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 599);
}
// MCC Label 600
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 600);
}
// MCC Label 601
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 601);
}
// MCC Label 602
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 602);
}
// MCC Label 603
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 603);
}
// MCC Label 604
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 604);
}
// MCC Label 605
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 605);
}
// MCC Label 606
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 606);
}
// MCC Label 607
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 607);
}
// MCC Label 608
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 608);
}
// MCC Label 609
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 609);
}
// MCC Label 610
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 610);
}
// MCC Label 611
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 611);
}
// MCC Label 612
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 612);
}
// MCC Label 613
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 613);
}
// MCC Label 614
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 614);
}
// MCC Label 615
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 615);
}
// MCC Label 616
if(( is_agg && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 616);
}
// MCC Label 617
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 617);
}
// MCC Label 618
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 618);
}
// MCC Label 619
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 619);
}
// MCC Label 620
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 620);
}
// MCC Label 621
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 621);
}
// MCC Label 622
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 622);
}
// MCC Label 623
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 623);
}
// MCC Label 624
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
// MCC Label 626
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 626);
}
// MCC Label 627
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 627);
}
// MCC Label 628
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 628);
}
// MCC Label 629
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 629);
}
// MCC Label 630
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 630);
}
// MCC Label 631
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 631);
}
// MCC Label 632
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 632);
}
// MCC Label 633
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 633);
}
// MCC Label 634
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 634);
}
// MCC Label 635
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 635);
}
// MCC Label 636
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 636);
}
// MCC Label 637
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 637);
}
// MCC Label 638
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 638);
}
// MCC Label 639
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 639);
}
// MCC Label 640
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 640);
}
// MCC Label 641
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 641);
}
// MCC Label 642
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 642);
}
// MCC Label 643
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 643);
}
// MCC Label 644
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 644);
}
// MCC Label 645
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 645);
}
// MCC Label 646
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 646);
}
// MCC Label 647
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 647);
}
// MCC Label 648
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 648);
}
// MCC Label 649
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 649);
}
// MCC Label 650
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 650);
}
// MCC Label 651
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 651);
}
// MCC Label 652
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 652);
}
// MCC Label 653
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 653);
}
// MCC Label 654
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 654);
}
// MCC Label 655
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 655);
}
// MCC Label 656
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 656);
}
// MCC Label 657
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 657);
}
// MCC Label 658
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 658);
}
// MCC Label 659
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 659);
}
// MCC Label 660
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 660);
}
// MCC Label 661
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 661);
}
// MCC Label 662
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 662);
}
// MCC Label 663
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 663);
}
// MCC Label 664
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 664);
}
// MCC Label 665
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 665);
}
// MCC Label 666
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 666);
}
// MCC Label 667
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 667);
}
// MCC Label 668
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 668);
}
// MCC Label 669
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 669);
}
// MCC Label 670
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 670);
}
// MCC Label 671
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 671);
}
// MCC Label 672
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 672);
}
// MCC Label 673
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 673);
}
// MCC Label 674
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 674);
}
// MCC Label 675
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 675);
}
// MCC Label 676
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 676);
}
// MCC Label 677
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 677);
}
// MCC Label 678
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 678);
}
// MCC Label 679
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 679);
}
// MCC Label 680
if(( !(is_agg) && (pNC->ncFlags & 1) == 0 ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 680);
}
// MCC Label 681
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 681);
}
// MCC Label 682
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 682);
}
// MCC Label 683
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 683);
}
// MCC Label 684
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 684);
}
// MCC Label 685
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 685);
}
// MCC Label 686
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 686);
}
// MCC Label 687
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 687);
}
// MCC Label 688
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 688);
}
// MCC Label 689
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 689);
}
// MCC Label 690
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 690);
}
// MCC Label 691
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 691);
}
// MCC Label 692
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 692);
}
// MCC Label 693
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 693);
}
// MCC Label 694
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 694);
}
// MCC Label 695
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 695);
}
// MCC Label 696
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 696);
}
// MCC Label 697
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 697);
}
// MCC Label 698
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 698);
}
// MCC Label 699
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 699);
}
// MCC Label 700
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 700);
}
// MCC Label 701
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 701);
}
// MCC Label 702
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 702);
}
// MCC Label 703
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 703);
}
// MCC Label 704
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 704);
}
// MCC Label 705
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 705);
}
// MCC Label 706
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 706);
}
// MCC Label 707
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 707);
}
// MCC Label 708
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 708);
}
// MCC Label 709
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 709);
}
// MCC Label 710
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 710);
}
// MCC Label 711
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 711);
}
// MCC Label 712
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( is_agg && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 712);
}
// MCC Label 713
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 713);
}
// MCC Label 714
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 714);
}
// MCC Label 715
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 715);
}
// MCC Label 716
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 716);
}
// MCC Label 717
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 717);
}
// MCC Label 718
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 718);
}
// MCC Label 719
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 719);
}
// MCC Label 720
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 720);
}
// MCC Label 721
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 721);
}
// MCC Label 722
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 722);
}
// MCC Label 723
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 723);
}
// MCC Label 724
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 724);
}
// MCC Label 725
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 725);
}
// MCC Label 726
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 726);
}
// MCC Label 727
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 727);
}
// MCC Label 728
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( pDef->funcFlags & 65536 ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 728);
}
// MCC Label 729
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 729);
}
// MCC Label 730
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 730);
}
// MCC Label 731
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 731);
}
// MCC Label 732
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 732);
}
// MCC Label 733
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 733);
}
// MCC Label 734
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 734);
}
// MCC Label 735
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 735);
}
// MCC Label 736
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !pWin ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 736);
}
// MCC Label 737
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 737);
}
// MCC Label 738
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 738);
}
// MCC Label 739
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 739);
}
// MCC Label 740
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( is_agg && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 740);
}
// MCC Label 741
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 741);
}
// MCC Label 742
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && pWin && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 742);
}
// MCC Label 743
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && (pNC->ncFlags & 16384) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 743);
}
// MCC Label 744
if(( !(is_agg) && !((pNC->ncFlags & 1) == 0) ) && ( !(is_agg) && ( !(pDef->funcFlags & 65536) ) && !(!pWin) ) && ( !(is_agg) && !(pWin) && !((pNC->ncFlags & 16384) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 744);
}
if( 
              (is_agg && (pNC->ncFlags & NC_AllowAgg)==0)
           || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pWin)
           || (is_agg && pWin && (pNC->ncFlags & NC_AllowWin)==0)
        ){
          const char *zType;
          
// ABS Label 749
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}

// COR Label 750
if(((pDef->funcFlags & 65536) && pWin) != ((pDef->funcFlags & 65536) || pWin))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 750);
}

// MCC Label 751
if(( pDef->funcFlags & 65536 ) && pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 751);
}
// MCC Label 752
if(( pDef->funcFlags & 65536 ) && !(pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 752);
}
// MCC Label 753
if(( !(pDef->funcFlags & 65536) ) && pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 753);
}
// MCC Label 754
if(( !(pDef->funcFlags & 65536) ) && !(pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 754);
}
if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pWin ){
            zType = "window";
          }else{
            zType = "aggregate";
          }
          
// ABS Label 745
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}

// ABS Label 746
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}

// ABS Label 747
if(nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// ABS Label 748
if(zId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}
sqlite3ErrorMsg(pParse, "misuse of %s function %.*s()",zType,nId,zId);
          pNC->nNcErr++;
          is_agg = 0;
        }
#else
        if( (is_agg && (pNC->ncFlags & NC_AllowAgg)==0) ){
          sqlite3ErrorMsg(pParse,"misuse of aggregate function %.*s()",nId,zId);
          pNC->nNcErr++;
          is_agg = 0;
        }
#endif
        else { 
// ABS Label 755
if(no_such_func < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}

// COR Label 756
if((no_such_func || pParse->db->init.busy == 0) != (no_such_func && pParse->db->init.busy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 756);
}

// ROR Label 757
if((pParse->db->init.busy != 0) != (pParse->db->init.busy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 757);
}

// MCC Label 758
if(no_such_func && pParse->db->init.busy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 758);
}
// MCC Label 759
if(no_such_func && !(pParse->db->init.busy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 759);
}
// MCC Label 760
if(!(no_such_func) && pParse->db->init.busy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 760);
}
// MCC Label 761
if(!(no_such_func) && !(pParse->db->init.busy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 761);
}
if( no_such_func && pParse->db->init.busy==0
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
                  && pParse->explain==0
#endif
        ){
          
// ABS Label 762
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}

// ABS Label 763
if(nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 763);
}

// ABS Label 764
if(zId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}
sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);
          pNC->nNcErr++;
        }else { 
// ABS Label 765
if(wrong_num_args < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}
if( wrong_num_args ){
          
// ABS Label 766
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 766);
}

// ABS Label 767
if(nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 767);
}

// ABS Label 768
if(zId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}
sqlite3ErrorMsg(pParse,"wrong number of arguments to function %.*s()",
               nId, zId);
          pNC->nNcErr++;
        }
#ifndef SQLITE_OMIT_WINDOWFUNC
        else { 
// ABS Label 769
if(is_agg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 769);
}

// COR Label 770
if((is_agg == 0 || (((pExpr)->flags & (16777216)) != 0)) != (is_agg == 0 && (((pExpr)->flags & (16777216)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 770);
}

// ROR Label 771
if((is_agg != 0) != (is_agg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 771);
}

// MCC Label 772
if(is_agg == 0 && ( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 772);
}
// MCC Label 773
if(is_agg == 0 && ( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 773);
}
// MCC Label 774
if(!(is_agg == 0) && ( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 774);
}
// MCC Label 775
if(!(is_agg == 0) && ( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 775);
}
if( is_agg==0 && ExprHasProperty(pExpr, EP_WinFunc) ){
          
// ABS Label 776
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}

// ABS Label 777
if(nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ABS Label 778
if(zId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}
sqlite3ErrorMsg(pParse, 
              "FILTER may not be used with non-aggregate %.*s()", 
              nId, zId
          );
          pNC->nNcErr++;
        };}
;}
;}
;}

#endif
        
// ABS Label 779
if(is_agg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 779);
}
if( is_agg ){
          /* Window functions may not be arguments of aggregate functions.
          ** Or arguments of other window functions. But aggregate functions
          ** may be arguments for window functions.  */
#ifndef SQLITE_OMIT_WINDOWFUNC
          pNC->ncFlags &= ~(NC_AllowWin | (!pWin ? NC_AllowAgg : 0));
#else
          pNC->ncFlags &= ~NC_AllowAgg;
#endif
        }
      }
#ifndef SQLITE_OMIT_WINDOWFUNC
      else { 
// MCC Label 780
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 780);
}
// MCC Label 781
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 781);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
        is_agg = 1;
      };}

#endif
      
// ABS Label 417
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}

// ABS Label 418
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
sqlite3WalkExprList(pWalker, pList);
      
// ABS Label 782
if(is_agg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}
if( is_agg ){
#ifndef SQLITE_OMIT_WINDOWFUNC
        
// ABS Label 783
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}
if( pWin ){
          
// ABS Label 784
if(pNC->pWinSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}
Select *pSel = pNC->pWinSelect;
          assert( pWin==pExpr->y.pWin );
          
// ROR Label 793
if(((pParse->eParseMode >= 2) != 0) != ((pParse->eParseMode >= 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 793);
}
if( IN_RENAME_OBJECT==0 ){
            
// ABS Label 794
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}

// ABS Label 795
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}

// ABS Label 796
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}
sqlite3WindowUpdate(pParse, pSel ? pSel->pWinDefn : 0, pWin, pDef);
            
// ABS Label 797
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}
if( pParse->db->mallocFailed ) { break;
}
          }
          
// ABS Label 785
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// ABS Label 786
if(pWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}
sqlite3WalkExprList(pWalker, pWin->pPartition);
          
// ABS Label 787
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}

// ABS Label 788
if(pWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}
sqlite3WalkExprList(pWalker, pWin->pOrderBy);
          
// ABS Label 789
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}

// ABS Label 790
if(pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}
sqlite3WalkExpr(pWalker, pWin->pFilter);
          
// ABS Label 791
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}

// ABS Label 792
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}
sqlite3WindowLink(pSel, pWin);
          pNC->ncFlags |= NC_HasWin;
        }else
#endif /* SQLITE_OMIT_WINDOWFUNC */
        {
          
// ABS Label 798
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}
NameContext *pNC2 = pNC;
          pExpr->op = TK_AGG_FUNCTION;
          pExpr->op2 = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
          
// MCC Label 799
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 799);
}
// MCC Label 800
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 800);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
            
// ABS Label 801
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}

// ABS Label 802
if(pExpr->y.pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 802);
}
sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);
          }
#endif
          while( pNC2 && !sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList) ){
            pExpr->op2++;
            pNC2 = pNC2->pNext;
          };
          assert( pDef!=0 || IN_RENAME_OBJECT );
          
// ABS Label 803
if(pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 803);
}
// ABS Label 804
if(pNC2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}

// COR Label 805
if((pNC2 || pDef) != (pNC2 && pDef))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 805);
}

// MCC Label 806
if(pNC2 && pDef ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 806);
}
// MCC Label 807
if(pNC2 && !(pDef) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 807);
}
// MCC Label 808
if(!(pNC2) && pDef ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 808);
}
// MCC Label 809
if(!(pNC2) && !(pDef) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 809);
}
if( pNC2 && pDef ){
            assert( SQLITE_FUNC_MINMAX==NC_MinMaxAgg );
            testcase( (pDef->funcFlags & SQLITE_FUNC_MINMAX)!=0 );
            pNC2->ncFlags |= NC_HasAgg | (pDef->funcFlags & SQLITE_FUNC_MINMAX);

          }
        }
        pNC->ncFlags |= savedAllowFlags;
      }
      /* FIX ME:  Compute pExpr->affinity based on the expected return
      ** type of the function 
      */
      return WRC_Prune;
    }
#ifndef SQLITE_OMIT_SUBQUERY
    case TK_SELECT:
    case TK_EXISTS:  testcase( pExpr->op==TK_EXISTS );
#endif
    case TK_IN: {
      testcase( pExpr->op==TK_IN );
      
// MCC Label 810
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 810);
}
// MCC Label 811
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 811);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
        
// ABS Label 812
if(pNC->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}
int nRef = pNC->nRef;
        testcase( pNC->ncFlags & NC_IsCheck );
        testcase( pNC->ncFlags & NC_PartIdx );
        testcase( pNC->ncFlags & NC_IdxExpr );
        testcase( pNC->ncFlags & NC_GenCol );
        sqlite3ResolveNotValid(pParse, pNC, "subqueries",
                 NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol, pExpr);
        
// ABS Label 813
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}

// ABS Label 814
if(pExpr->x.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}
sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
        assert( pNC->nRef>=nRef );
        
// ABS Label 816
if(nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}
// ABS Label 817
if(pNC->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}

// ROR Label 818
if((nRef == pNC->nRef) != (nRef != pNC->nRef))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 818);
}
if( nRef!=pNC->nRef ){
          ExprSetProperty(pExpr, EP_VarSelect);
          pNC->ncFlags |= NC_VarSelect;
        }
      }
      break;
    }
    case TK_VARIABLE: {
      testcase( pNC->ncFlags & NC_IsCheck );
      testcase( pNC->ncFlags & NC_PartIdx );
      testcase( pNC->ncFlags & NC_IdxExpr );
      testcase( pNC->ncFlags & NC_GenCol );
      sqlite3ResolveNotValid(pParse, pNC, "parameters",
               NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol, pExpr);
      break;
    }
    case TK_IS:
    case TK_ISNOT: {
      Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);
      assert( !ExprHasProperty(pExpr, EP_Reduced) );
      /* Handle special cases of "x IS TRUE", "x IS FALSE", "x IS NOT TRUE",
      ** and "x IS NOT FALSE". */
      
// ABS Label 820
if((pRight) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}

// COR Label 821
if(((pRight) || (pRight->op == 59 || pRight->op == 169)) != ((pRight) && (pRight->op == 59 || pRight->op == 169)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 821);
}

// MCC Label 822
if((pRight) && ( pRight->op == 59 && pRight->op == 169 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 822);
}
// MCC Label 823
if((pRight) && ( pRight->op == 59 && !(pRight->op == 169) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 823);
}
// MCC Label 824
if((pRight) && ( !(pRight->op == 59) && pRight->op == 169 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 824);
}
// MCC Label 825
if((pRight) && ( !(pRight->op == 59) && !(pRight->op == 169) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 825);
}
// MCC Label 826
if(!((pRight)) && ( pRight->op == 59 && pRight->op == 169 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 826);
}
// MCC Label 827
if(!((pRight)) && ( pRight->op == 59 && !(pRight->op == 169) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 827);
}
// MCC Label 828
if(!((pRight)) && ( !(pRight->op == 59) && pRight->op == 169 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 828);
}
// MCC Label 829
if(!((pRight)) && ( !(pRight->op == 59) && !(pRight->op == 169) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 829);
}
if( ALWAYS(pRight) && (pRight->op==TK_ID || pRight->op==TK_TRUEFALSE) ){
        int rc = resolveExprStep(pWalker, pRight);
        
// ABS Label 830
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}

// ROR Label 831
if((rc != 2) != (rc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 831);
}
if( rc==WRC_Abort ) { return WRC_Abort;
}
        
// ROR Label 832
if((pRight->op != 169) != (pRight->op == 169))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}
if( pRight->op==TK_TRUEFALSE ){
          pExpr->op2 = pExpr->op;
          pExpr->op = TK_TRUTH;
          return WRC_Continue;
        }
      }
      /* no break */ deliberate_fall_through
    }
    case TK_BETWEEN:
    case TK_EQ:
    case TK_NE:
    case TK_LT:
    case TK_LE:
    case TK_GT:
    case TK_GE: {
      int nLeft, nRight;
      
// ABS Label 833
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}
if( pParse->db->mallocFailed ) { break;
}
      assert( pExpr->pLeft!=0 );
      nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
      
// ROR Label 834
if((pExpr->op != 48) != (pExpr->op == 48))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 834);
}
if( pExpr->op==TK_BETWEEN ){
        nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);
        
// ABS Label 835
if(nLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}
// ABS Label 836
if(nRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 836);
}

// ROR Label 837
if((nRight != nLeft) != (nRight == nLeft))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 837);
}
if( nRight==nLeft ){
          nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);
        }
      }else{
        assert( pExpr->pRight!=0 );
        nRight = sqlite3ExprVectorSize(pExpr->pRight);
      }
      
// ABS Label 838
if(nLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}
// ABS Label 839
if(nRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}

// ROR Label 840
if((nLeft == nRight) != (nLeft != nRight))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 840);
}
if( nLeft!=nRight ){
        testcase( pExpr->op==TK_EQ );
        testcase( pExpr->op==TK_NE );
        testcase( pExpr->op==TK_LT );
        testcase( pExpr->op==TK_LE );
        testcase( pExpr->op==TK_GT );
        testcase( pExpr->op==TK_GE );
        testcase( pExpr->op==TK_IS );
        testcase( pExpr->op==TK_ISNOT );
        testcase( pExpr->op==TK_BETWEEN );
        
// ABS Label 841
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 841);
}
sqlite3ErrorMsg(pParse, "row value misused");
      }
      break; 
    }
  }
  return (pParse->nErr || pParse->db->mallocFailed) ? WRC_Abort : WRC_Continue;
}

/*
** pEList is a list of expressions which are really the result set of the
** a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.
** This routine checks to see if pE is a simple identifier which corresponds
** to the AS-name of one of the terms of the expression list.  If it is,
** this routine return an integer between 1 and N where N is the number of
** elements in pEList, corresponding to the matching entry.  If there is
** no match, or if pE is not a simple identifier, then this routine
** return 0.
**
** pEList has been resolved.  pE has not.
*/
static int resolveAsName(
  Parse *pParse,     /* Parsing context for error messages */
  ExprList *pEList,  /* List of expressions to scan */
  Expr *pE           /* Expression we are trying to match */
){
  int i;             /* Loop counter */

  UNUSED_PARAMETER(pParse);

  
// ROR Label 842
if((pE->op != 59) != (pE->op == 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 842);
}
if( pE->op==TK_ID ){
    
// ABS Label 843
if(pE->u.zToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 843);
}
char *zCol = pE->u.zToken;
    i = 0;

// ABS Label 844
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 844);
}
// ABS Label 845
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}

// ROR Label 846
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 846);
}
// ROR Label 847
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 847);
}
// ROR Label 848
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 848);
}
for(; i<pEList->nExpr; i++){
      if( pEList->a[i].eEName==ENAME_NAME
       && sqlite3_stricmp(pEList->a[i].zEName, zCol)==0
      ){
        
// ABS Label 854
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}

// AOR Label 855
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 855);
}
// AOR Label 856
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 856);
}
// AOR Label 857
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 857);
}
return i+1;
      }
    };
// ABS Label 849
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}
// ABS Label 850
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}

// ROR Label 851
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 851);
}
// ROR Label 852
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 852);
}
// ROR Label 853
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}

  }
  return 0;
}

/*
** pE is a pointer to an expression which is a single term in the
** ORDER BY of a compound SELECT.  The expression has not been
** name resolved.
**
** At the point this routine is called, we already know that the
** ORDER BY term is not an integer index into the result set.  That
** case is handled by the calling routine.
**
** Attempt to match pE against result set columns in the left-most
** SELECT statement.  Return the index i of the matching column,
** as an indication to the caller that it should sort by the i-th column.
** The left-most column is 1.  In other words, the value returned is the
** same integer value that would be used in the SQL statement to indicate
** the column.
**
** If there is no match, return 0.  Return -1 if an error occurs.
*/
static int resolveOrderByTermToExprList(
  Parse *pParse,     /* Parsing context for error messages */
  Select *pSelect,   /* The SELECT statement with the ORDER BY clause */
  Expr *pE           /* The specific ORDER BY term */
){
  int i;             /* Loop counter */
  ExprList *pEList;  /* The columns of the result set */
  NameContext nc;    /* Name context for resolving pE */
  sqlite3 *db;       /* Database connection */
  int rc;            /* Return code from subprocedures */
  u8 savedSuppErr;   /* Saved value of db->suppressErr */

  assert( sqlite3ExprIsInteger(pE, &i)==0 );
  pEList = pSelect->pEList;

  /* Resolve all names in the ORDER BY term expression
  */
  memset(&nc, 0, sizeof(nc));
  nc.pParse = pParse;
  nc.pSrcList = pSelect->pSrc;
  nc.uNC.pEList = pEList;
  nc.ncFlags = NC_AllowAgg|NC_UEList|NC_NoSelect;
  nc.nNcErr = 0;
  db = pParse->db;
  savedSuppErr = db->suppressErr;
  db->suppressErr = 1;
  rc = sqlite3ResolveExprNames(&nc, pE);
  db->suppressErr = savedSuppErr;
  
// ABS Label 858
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
if( rc ) { return 0;
}

  /* Try to match the ORDER BY expression against an expression
  ** in the result set.  Return an 1-based index of the matching
  ** result-set entry.
  */
  i = 0;

// ABS Label 859
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}
// ABS Label 860
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}

// ROR Label 861
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 861);
}
// ROR Label 862
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
// ROR Label 863
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 863);
}
for(; i<pEList->nExpr; i++){
    if( sqlite3ExprCompare(0, pEList->a[i].pExpr, pE, -1)<2 ){
      
// ABS Label 869
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 869);
}

// AOR Label 870
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 870);
}
// AOR Label 871
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 871);
}
// AOR Label 872
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 872);
}
return i+1;
    }
  };
// ABS Label 864
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 864);
}
// ABS Label 865
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 865);
}

// ROR Label 866
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 866);
}
// ROR Label 867
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 867);
}
// ROR Label 868
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 868);
}


  /* If no match, return 0. */
  return 0;
}

/*
** Generate an ORDER BY or GROUP BY term out-of-range error.
*/
static void resolveOutOfRangeError(
  Parse *pParse,         /* The error context into which to write the error */
  const char *zType,     /* "ORDER" or "GROUP" */
  int i,                 /* The index (1-based) of the term out of range */
  int mx                 /* Largest permissible value of i */
){
  
// ABS Label 873
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// ABS Label 874
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 874);
}

// ABS Label 875
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 875);
}

// ABS Label 876
if(mx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}
sqlite3ErrorMsg(pParse, 
    "%r %s BY term out of range - should be "
    "between 1 and %d", i, zType, mx);
}

/*
** Analyze the ORDER BY clause in a compound SELECT statement.   Modify
** each term of the ORDER BY clause is a constant integer between 1
** and N where N is the number of columns in the compound SELECT.
**
** ORDER BY terms that are already an integer between 1 and N are
** unmodified.  ORDER BY terms that are integers outside the range of
** 1 through N generate an error.  ORDER BY terms that are expressions
** are matched against result set expressions of compound SELECT
** beginning with the left-most SELECT and working toward the right.
** At the first match, the ORDER BY expression is transformed into
** the integer column number.
**
** Return the number of errors seen.
*/
static int resolveCompoundOrderBy(
  Parse *pParse,        /* Parsing context.  Leave error messages here */
  Select *pSelect       /* The SELECT statement containing the ORDER BY */
){
  int i;
  ExprList *pOrderBy;
  ExprList *pEList;
  sqlite3 *db;
  int moreToDo = 1;

  pOrderBy = pSelect->pOrderBy;
  
// ABS Label 877
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}

// ROR Label 878
if((pOrderBy != 0) != (pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 878);
}
if( pOrderBy==0 ) { return 0;
}
  db = pParse->db;
  
// ABS Label 879
if(db->aLimit[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 879);
}
// ABS Label 880
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 880);
}

// ROR Label 881
if((pOrderBy->nExpr <= db->aLimit[2]) != (pOrderBy->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 881);
}
// ROR Label 882
if((pOrderBy->nExpr < db->aLimit[2]) != (pOrderBy->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 882);
}
// ROR Label 883
if((pOrderBy->nExpr >= db->aLimit[2]) != (pOrderBy->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 883);
}
if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){
    
// ABS Label 884
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 884);
}
sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    return 1;
  }
  i = 0;

// ABS Label 885
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 885);
}
// ABS Label 886
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 886);
}

// ROR Label 887
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}
// ROR Label 888
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
// ROR Label 889
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 889);
}
for(; i<pOrderBy->nExpr; i++){
    pOrderBy->a[i].done = 0;
  };
// ABS Label 890
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 890);
}
// ABS Label 891
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}

// ROR Label 892
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
// ROR Label 893
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 893);
}
// ROR Label 894
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 894);
}

  pSelect->pNext = 0;
  
// ABS Label 895
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}
while( pSelect->pPrior ){
    pSelect->pPrior->pNext = pSelect;
    pSelect = pSelect->pPrior;
  };
// ABS Label 896
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}

  
// ABS Label 897
if(moreToDo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}
// ABS Label 898
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 898);
}

// COR Label 899
if((pSelect || moreToDo) != (pSelect && moreToDo))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 899);
}

// MCC Label 900
if(pSelect && moreToDo ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 900);
}
// MCC Label 901
if(pSelect && !(moreToDo) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 901);
}
// MCC Label 902
if(!(pSelect) && moreToDo ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 902);
}
// MCC Label 903
if(!(pSelect) && !(moreToDo) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 903);
}
while( pSelect && moreToDo ){
    struct ExprList_item *pItem;
    moreToDo = 0;
    pEList = pSelect->pEList;
    assert( pEList!=0 );
    i = 0 , pItem = pOrderBy->a;

// ABS Label 911
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}
// ABS Label 912
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 912);
}

// ROR Label 913
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 913);
}
// ROR Label 914
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 914);
}
// ROR Label 915
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 915);
}
for(; i<pOrderBy->nExpr; i++, pItem++){
      int iCol = -1;
      Expr *pE, *pDup;
      
// ABS Label 921
if(pItem->done < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}
if( pItem->done ) { continue;
}
      pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
      
// MCC Label 922
if(( pE == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 922);
}
// MCC Label 923
if(( !(pE == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 923);
}
if( NEVER(pE==0) ) { continue;
}
      if( sqlite3ExprIsInteger(pE, &iCol) ){
        
// ABS Label 924
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 924);
}
// ABS Label 925
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 925);
}

// COR Label 926
if((iCol <= 0 && iCol > pEList->nExpr) != (iCol <= 0 || iCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 926);
}

// ROR Label 927
if((iCol < 0) != (iCol <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 927);
}
// ROR Label 928
if((iCol > 0) != (iCol <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 928);
}
// ROR Label 929
if((iCol >= 0) != (iCol <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 929);
}
// ROR Label 930
if((iCol <= pEList->nExpr) != (iCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 930);
}
// ROR Label 931
if((iCol < pEList->nExpr) != (iCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 931);
}
// ROR Label 932
if((iCol >= pEList->nExpr) != (iCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 932);
}

// MCC Label 933
if(iCol <= 0 && iCol > pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 933);
}
// MCC Label 934
if(iCol <= 0 && !(iCol > pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 934);
}
// MCC Label 935
if(!(iCol <= 0) && iCol > pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 935);
}
// MCC Label 936
if(!(iCol <= 0) && !(iCol > pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 936);
}
if( iCol<=0 || iCol>pEList->nExpr ){
          
// ABS Label 937
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}

// ABS Label 938
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}

// AOR Label 939
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 939);
}
// AOR Label 940
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 940);
}
// AOR Label 941
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 941);
}

// ABS Label 942
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 942);
}
resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr);
          return 1;
        }
      }else{
        iCol = resolveAsName(pParse, pEList, pE);
        
// ABS Label 943
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}

// ROR Label 944
if((iCol != 0) != (iCol == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 944);
}
if( iCol==0 ){
          /* Now test if expression pE matches one of the values returned
          ** by pSelect. In the usual case this is done by duplicating the 
          ** expression, resolving any symbols in it, and then comparing
          ** it against each expression returned by the SELECT statement.
          ** Once the comparisons are finished, the duplicate expression
          ** is deleted.
          **
          ** If this is running as part of an ALTER TABLE operation and
          ** the symbols resolve successfully, also resolve the symbols in the
          ** actual expression. This allows the code in alter.c to modify
          ** column references within the ORDER BY expression as required.  */
          pDup = sqlite3ExprDup(db, pE, 0);
          if( !db->mallocFailed ){
            assert(pDup);
            iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);
            
// ABS Label 947
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}

// COR Label 948
if(((pParse->eParseMode >= 2) || iCol > 0) != ((pParse->eParseMode >= 2) && iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 948);
}

// ROR Label 949
if((iCol <= 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 949);
}
// ROR Label 950
if((iCol < 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 950);
}
// ROR Label 951
if((iCol >= 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 951);
}

// MCC Label 952
if(( pParse->eParseMode >= 2 ) && iCol > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 952);
}
// MCC Label 953
if(( pParse->eParseMode >= 2 ) && !(iCol > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 953);
}
// MCC Label 954
if(( !(pParse->eParseMode >= 2) ) && iCol > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 954);
}
// MCC Label 955
if(( !(pParse->eParseMode >= 2) ) && !(iCol > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 955);
}
if( IN_RENAME_OBJECT && iCol>0 ){
              
// ABS Label 956
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 956);
}

// ABS Label 957
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 957);
}

// ABS Label 958
if(pE < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 958);
}
resolveOrderByTermToExprList(pParse, pSelect, pE);
            }
          }
          
// ABS Label 945
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}

// ABS Label 946
if(pDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}
sqlite3ExprDelete(db, pDup);
        }
      }
      
// ABS Label 959
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 959);
}

// ROR Label 960
if((iCol <= 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 960);
}
// ROR Label 961
if((iCol < 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 961);
}
// ROR Label 962
if((iCol >= 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 962);
}
if( iCol>0 ){
        /* Convert the ORDER BY term into an integer column number iCol,
        ** taking care to preserve the COLLATE clause if it exists. */
        if( !IN_RENAME_OBJECT ){
          Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);
          
// ABS Label 965
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 965);
}

// ROR Label 966
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 966);
}
if( pNew==0 ) { return 1;
}
          pNew->flags |= EP_IntValue;
          pNew->u.iValue = iCol;
          
// ABS Label 967
if(pE < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 967);
}
// ABS Label 968
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 968);
}

// ROR Label 969
if((pItem->pExpr != pE) != (pItem->pExpr == pE))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 969);
}
if( pItem->pExpr==pE ){
            pItem->pExpr = pNew;
          }else{
            
// ABS Label 970
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}
Expr *pParent = pItem->pExpr;
            assert( pParent->op==TK_COLLATE );
            
// ROR Label 971
if((pParent->pLeft->op != 112) != (pParent->pLeft->op == 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 971);
}
while( pParent->pLeft->op==TK_COLLATE ) { pParent = pParent->pLeft;
};
// ROR Label 972
if((pParent->pLeft->op != 112) != (pParent->pLeft->op == 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 972);
}

            assert( pParent->pLeft==pE );
            pParent->pLeft = pNew;
          }
          
// ABS Label 963
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}

// ABS Label 964
if(pE < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 964);
}
sqlite3ExprDelete(db, pE);
          pItem->u.x.iOrderByCol = (u16)iCol;
        }
        pItem->done = 1;
      }else{
        moreToDo = 1;
      }
    };
// ABS Label 916
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 916);
}
// ABS Label 917
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ROR Label 918
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
// ROR Label 919
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 919);
}
// ROR Label 920
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 920);
}

    pSelect = pSelect->pNext;
  };
// ABS Label 904
if(moreToDo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 904);
}
// ABS Label 905
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}

// COR Label 906
if((pSelect || moreToDo) != (pSelect && moreToDo))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 906);
}

// MCC Label 907
if(pSelect && moreToDo ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(pSelect && !(moreToDo) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
// MCC Label 909
if(!(pSelect) && moreToDo ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 909);
}
// MCC Label 910
if(!(pSelect) && !(moreToDo) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 910);
}

  i = 0;

// ABS Label 973
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 973);
}
// ABS Label 974
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 974);
}

// ROR Label 975
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 975);
}
// ROR Label 976
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 976);
}
// ROR Label 977
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 977);
}
for(; i<pOrderBy->nExpr; i++){
    
// ROR Label 983
if((pOrderBy->a[i].done != 0) != (pOrderBy->a[i].done == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 983);
}
if( pOrderBy->a[i].done==0 ){
      
// ABS Label 984
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 984);
}

// ABS Label 985
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}

// AOR Label 986
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 986);
}
// AOR Label 987
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 987);
}
// AOR Label 988
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 988);
}
sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "
            "column in the result set", i+1);
      return 1;
    }
  };
// ABS Label 978
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}
// ABS Label 979
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 979);
}

// ROR Label 980
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 980);
}
// ROR Label 981
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 981);
}
// ROR Label 982
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 982);
}

  return 0;
}

/*
** Check every term in the ORDER BY or GROUP BY clause pOrderBy of
** the SELECT statement pSelect.  If any term is reference to a
** result set expression (as determined by the ExprList.a.u.x.iOrderByCol
** field) then convert that term into a copy of the corresponding result set
** column.
**
** If any errors are detected, add an error message to pParse and
** return non-zero.  Return zero if no errors are seen.
*/
int sqlite3ResolveOrderGroupBy(
  Parse *pParse,        /* Parsing context.  Leave error messages here */
  Select *pSelect,      /* The SELECT statement containing the clause */
  ExprList *pOrderBy,   /* The ORDER BY or GROUP BY clause to be processed */
  const char *zType     /* "ORDER" or "GROUP" */
){
  int i;
  
// ABS Label 989
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 989);
}
sqlite3 *db = pParse->db;
  ExprList *pEList;
  struct ExprList_item *pItem;

  
// ABS Label 990
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 990);
}

// COR Label 991
if((pOrderBy == 0 || pParse->db->mallocFailed && (pParse->eParseMode >= 2)) != (pOrderBy == 0 || pParse->db->mallocFailed || (pParse->eParseMode >= 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 991);
}
// COR Label 992
if((pOrderBy == 0 && pParse->db->mallocFailed) != (pOrderBy == 0 || pParse->db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 992);
}

// ROR Label 993
if((pOrderBy != 0) != (pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 993);
}

// MCC Label 994
if(pOrderBy == 0 && pParse->db->mallocFailed && ( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 994);
}
// MCC Label 995
if(pOrderBy == 0 && pParse->db->mallocFailed && ( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 995);
}
// MCC Label 996
if(pOrderBy == 0 && !(pParse->db->mallocFailed) && ( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 996);
}
// MCC Label 997
if(pOrderBy == 0 && !(pParse->db->mallocFailed) && ( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 997);
}
// MCC Label 998
if(!(pOrderBy == 0) && pParse->db->mallocFailed && ( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 998);
}
// MCC Label 999
if(!(pOrderBy == 0) && pParse->db->mallocFailed && ( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 999);
}
// MCC Label 1000
if(!(pOrderBy == 0) && !(pParse->db->mallocFailed) && ( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1000);
}
// MCC Label 1001
if(!(pOrderBy == 0) && !(pParse->db->mallocFailed) && ( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1001);
}
if( pOrderBy==0 || pParse->db->mallocFailed || IN_RENAME_OBJECT ) { return 0;
}
  
// ABS Label 1002
if(db->aLimit[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}
// ABS Label 1003
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// ROR Label 1004
if((pOrderBy->nExpr <= db->aLimit[2]) != (pOrderBy->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1004);
}
// ROR Label 1005
if((pOrderBy->nExpr < db->aLimit[2]) != (pOrderBy->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1005);
}
// ROR Label 1006
if((pOrderBy->nExpr >= db->aLimit[2]) != (pOrderBy->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1006);
}
if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){
    
// ABS Label 1007
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1007);
}

// ABS Label 1008
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1008);
}
sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
    return 1;
  }
  pEList = pSelect->pEList;
  assert( pEList!=0 );  /* sqlite3SelectNew() guarantees this */
  i = 0 , pItem = pOrderBy->a;

// ABS Label 1009
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1009);
}
// ABS Label 1010
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1010);
}

// ROR Label 1011
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1011);
}
// ROR Label 1012
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1012);
}
// ROR Label 1013
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1013);
}
for(; i<pOrderBy->nExpr; i++, pItem++){
    
// ABS Label 1019
if(pItem->u.x.iOrderByCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}
if( pItem->u.x.iOrderByCol ){
      
// ABS Label 1026
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1026);
}

// ROR Label 1027
if((pItem->u.x.iOrderByCol <= pEList->nExpr) != (pItem->u.x.iOrderByCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1027);
}
// ROR Label 1028
if((pItem->u.x.iOrderByCol < pEList->nExpr) != (pItem->u.x.iOrderByCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1028);
}
// ROR Label 1029
if((pItem->u.x.iOrderByCol >= pEList->nExpr) != (pItem->u.x.iOrderByCol > pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1029);
}
if( pItem->u.x.iOrderByCol>pEList->nExpr ){
        
// ABS Label 1030
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1030);
}

// ABS Label 1031
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}

// ABS Label 1032
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}

// AOR Label 1033
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1033);
}
// AOR Label 1034
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1034);
}
// AOR Label 1035
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1035);
}

// ABS Label 1036
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1036);
}
resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr);
        return 1;
      }
      
// ABS Label 1020
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1020);
}

// ABS Label 1021
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1021);
}

// AOR Label 1022
if(pItem->u.x.iOrderByCol / 1 != pItem->u.x.iOrderByCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1022);
}
// AOR Label 1023
if(pItem->u.x.iOrderByCol + 1 != pItem->u.x.iOrderByCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1023);
}
// AOR Label 1024
if(pItem->u.x.iOrderByCol * 1 != pItem->u.x.iOrderByCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1024);
}

// ABS Label 1025
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1025);
}
resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,0);
    }
  };
// ABS Label 1014
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1014);
}
// ABS Label 1015
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}

// ROR Label 1016
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1016);
}
// ROR Label 1017
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1017);
}
// ROR Label 1018
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1018);
}

  return 0;
}

#ifndef SQLITE_OMIT_WINDOWFUNC
/*
** Walker callback for windowRemoveExprFromSelect().
*/
static int resolveRemoveWindowsCb(Walker *pWalker, Expr *pExpr){
  UNUSED_PARAMETER(pWalker);
  
// MCC Label 1037
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1037);
}
// MCC Label 1038
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1038);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
    
// ABS Label 1039
if(pExpr->y.pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1039);
}
Window *pWin = pExpr->y.pWin;
    
// ABS Label 1040
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1040);
}
sqlite3WindowUnlinkFromSelect(pWin);
  }
  return WRC_Continue;
}

/*
** Remove any Window objects owned by the expression pExpr from the
** Select.pWin list of Select object pSelect.
*/
static void windowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){
  
// ABS Label 1041
if(pSelect->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}
if( pSelect->pWin ){
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.xExprCallback = resolveRemoveWindowsCb;
    sWalker.u.pSelect = pSelect;
    
// ABS Label 1042
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}
sqlite3WalkExpr(&sWalker, pExpr);
  }
}
#else
# define windowRemoveExprFromSelect(a, b)
#endif /* SQLITE_OMIT_WINDOWFUNC */

/*
** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.
** The Name context of the SELECT statement is pNC.  zType is either
** "ORDER" or "GROUP" depending on which type of clause pOrderBy is.
**
** This routine resolves each term of the clause into an expression.
** If the order-by term is an integer I between 1 and N (where N is the
** number of columns in the result set of the SELECT) then the expression
** in the resolution is a copy of the I-th result-set expression.  If
** the order-by term is an identifier that corresponds to the AS-name of
** a result-set expression, then the term resolves to a copy of the
** result-set expression.  Otherwise, the expression is resolved in
** the usual way - using sqlite3ResolveExprNames().
**
** This routine returns the number of errors.  If errors occur, then
** an appropriate error message might be left in pParse.  (OOM errors
** excepted.)
*/
static int resolveOrderGroupBy(
  NameContext *pNC,     /* The name context of the SELECT statement */
  Select *pSelect,      /* The SELECT statement holding pOrderBy */
  ExprList *pOrderBy,   /* An ORDER BY or GROUP BY clause to resolve */
  const char *zType     /* Either "ORDER" or "GROUP", as appropriate */
){
  int i, j;                      /* Loop counters */
  int iCol;                      /* Column number */
  struct ExprList_item *pItem;   /* A term of the ORDER BY clause */
  Parse *pParse;                 /* Parsing context */
  int nResult;                   /* Number of terms in the result set */

  assert( pOrderBy!=0 );
  nResult = pSelect->pEList->nExpr;
  pParse = pNC->pParse;
  i = 0 , pItem = pOrderBy->a;

// ABS Label 1043
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}
// ABS Label 1044
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}

// ROR Label 1045
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1045);
}
// ROR Label 1046
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1046);
}
// ROR Label 1047
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1047);
}
for(; i<pOrderBy->nExpr; i++, pItem++){
    
// ABS Label 1053
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}
Expr *pE = pItem->pExpr;
    Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pE);
    
// MCC Label 1054
if(( pE2 == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1054);
}
// MCC Label 1055
if(( !(pE2 == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1055);
}
if( NEVER(pE2==0) ) { continue;
}
    
// ROR Label 1056
if((zType[0] == 'G') != (zType[0] != 'G'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1056);
}
if( zType[0]!='G' ){
      iCol = resolveAsName(pParse, pSelect->pEList, pE2);
      
// ABS Label 1057
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}

// ROR Label 1058
if((iCol <= 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1058);
}
// ROR Label 1059
if((iCol < 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1059);
}
// ROR Label 1060
if((iCol >= 0) != (iCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1060);
}
if( iCol>0 ){
        /* If an AS-name match is found, mark this ORDER BY column as being
        ** a copy of the iCol-th result-set column.  The subsequent call to
        ** sqlite3ResolveOrderGroupBy() will convert the expression to a
        ** copy of the iCol-th result-set expression. */
        pItem->u.x.iOrderByCol = (u16)iCol;
        continue;
      }
    }
    if( sqlite3ExprIsInteger(pE2, &iCol) ){
      /* The ORDER BY term is an integer constant.  Again, set the column
      ** number so that sqlite3ResolveOrderGroupBy() will convert the
      ** order-by term to a copy of the result-set expression */
      
// ABS Label 1061
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1061);
}

// COR Label 1062
if((iCol < 1 && iCol > 65535) != (iCol < 1 || iCol > 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1062);
}

// ROR Label 1063
if((iCol <= 1) != (iCol < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1063);
}
// ROR Label 1064
if((iCol > 1) != (iCol < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1064);
}
// ROR Label 1065
if((iCol >= 1) != (iCol < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1065);
}
// ROR Label 1066
if((iCol <= 65535) != (iCol > 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1066);
}
// ROR Label 1067
if((iCol < 65535) != (iCol > 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1067);
}
// ROR Label 1068
if((iCol >= 65535) != (iCol > 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1068);
}

// MCC Label 1069
if(iCol < 1 && iCol > 65535 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1069);
}
// MCC Label 1070
if(iCol < 1 && !(iCol > 65535) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1070);
}
// MCC Label 1071
if(!(iCol < 1) && iCol > 65535 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1071);
}
// MCC Label 1072
if(!(iCol < 1) && !(iCol > 65535) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1072);
}
if( iCol<1 || iCol>0xffff ){
        
// ABS Label 1073
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1073);
}

// ABS Label 1074
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1074);
}

// ABS Label 1075
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1075);
}

// AOR Label 1076
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1076);
}
// AOR Label 1077
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1077);
}
// AOR Label 1078
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1078);
}

// ABS Label 1079
if(nResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1079);
}
resolveOutOfRangeError(pParse, zType, i+1, nResult);
        return 1;
      }
      pItem->u.x.iOrderByCol = (u16)iCol;
      continue;
    }

    /* Otherwise, treat the ORDER BY term as an ordinary expression */
    pItem->u.x.iOrderByCol = 0;
    if( sqlite3ResolveExprNames(pNC, pE) ){
      return 1;
    }
    j = 0;

// ABS Label 1080
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}
// ABS Label 1081
if(pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1081);
}

// ROR Label 1082
if((j <= pSelect->pEList->nExpr) != (j < pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1082);
}
// ROR Label 1083
if((j > pSelect->pEList->nExpr) != (j < pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1083);
}
// ROR Label 1084
if((j >= pSelect->pEList->nExpr) != (j < pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1084);
}
for(; j<pSelect->pEList->nExpr; j++){
      if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){
        /* Since this expresion is being changed into a reference
        ** to an identical expression in the result set, remove all Window
        ** objects belonging to the expression from the Select.pWin list. */
        
// ABS Label 1090
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}

// ABS Label 1091
if(pE < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1091);
}
windowRemoveExprFromSelect(pSelect, pE);
        pItem->u.x.iOrderByCol = j+1;
      }
    };
// ABS Label 1085
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1085);
}
// ABS Label 1086
if(pSelect->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1086);
}

// ROR Label 1087
if((j <= pSelect->pEList->nExpr) != (j < pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1087);
}
// ROR Label 1088
if((j > pSelect->pEList->nExpr) != (j < pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1088);
}
// ROR Label 1089
if((j >= pSelect->pEList->nExpr) != (j < pSelect->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1089);
}

  };
// ABS Label 1048
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}
// ABS Label 1049
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}

// ROR Label 1050
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1050);
}
// ROR Label 1051
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1051);
}
// ROR Label 1052
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1052);
}

  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
}

/*
** Resolve names in the SELECT statement p and all of its descendants.
*/
static int resolveSelectStep(Walker *pWalker, Select *p){
  NameContext *pOuterNC;  /* Context that contains this SELECT */
  NameContext sNC;        /* Name context of this SELECT */
  int isCompound;         /* True if p is a compound select */
  int nCompound;          /* Number of compound terms processed so far */
  Parse *pParse;          /* Parsing context */
  int i;                  /* Loop counter */
  ExprList *pGroupBy;     /* The GROUP BY clause */
  Select *pLeftmost;      /* Left-most of SELECT of a compound */
  sqlite3 *db;            /* Database connection */
  

  assert( p!=0 );
  
// ABS Label 1092
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// AOR Label 1093
if(p->selFlags | 4 != p->selFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1093);
}
// AOR Label 1094
if(p->selFlags ^ 4 != p->selFlags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1094);
}
if( p->selFlags & SF_Resolved ){
    return WRC_Prune;
  }
  pOuterNC = pWalker->u.pNC;
  pParse = pWalker->pParse;
  db = pParse->db;

  /* Normally sqlite3SelectExpand() will be called first and will have
  ** already expanded this SELECT.  However, if this is a subquery within
  ** an expression, sqlite3ResolveExprNames() will be called without a
  ** prior call to sqlite3SelectExpand().  When that happens, let
  ** sqlite3SelectPrep() do all of the processing for this SELECT.
  ** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and
  ** this routine in the correct order.
  */
  
// ROR Label 1095
if(((p->selFlags & 64) != 0) != ((p->selFlags & 64) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1095);
}
if( (p->selFlags & SF_Expanded)==0 ){
    
// ABS Label 1096
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1096);
}

// ABS Label 1097
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1097);
}

// ABS Label 1098
if(pOuterNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1098);
}
sqlite3SelectPrep(pParse, p, pOuterNC);
    return (pParse->nErr || db->mallocFailed) ? WRC_Abort : WRC_Prune;
  }

  isCompound = p->pPrior!=0;
  nCompound = 0;
  pLeftmost = p;
  
// ABS Label 1099
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}
while( p ){
    assert( (p->selFlags & SF_Expanded)!=0 );
    assert( (p->selFlags & SF_Resolved)==0 );
    assert( db->suppressErr==0 ); /* SF_Resolved not set if errors suppressed */
    p->selFlags |= SF_Resolved;


    /* Resolve the expressions in the LIMIT and OFFSET clauses. These
    ** are not allowed to refer to any names, so pass an empty NameContext.
    */
    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pWinSelect = p;
    if( sqlite3ResolveExprNames(&sNC, p->pLimit) ){
      return WRC_Abort;
    }

    /* If the SF_Converted flags is set, then this Select object was
    ** was created by the convertCompoundSelectToSubquery() function.
    ** In this case the ORDER BY clause (p->pOrderBy) should be resolved
    ** as if it were part of the sub-query, not the parent. This block
    ** moves the pOrderBy down to the sub-query. It will be moved back
    ** after the names have been resolved.  */
    
// ABS Label 1101
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}

// AOR Label 1102
if(p->selFlags | 65536 != p->selFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1102);
}
// AOR Label 1103
if(p->selFlags ^ 65536 != p->selFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1103);
}
if( p->selFlags & SF_Converted ){
      
// ABS Label 1104
if(p->pSrc->a[0].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}
Select *pSub = p->pSrc->a[0].pSelect;
      assert( p->pSrc->nSrc==1 && p->pOrderBy );
      assert( pSub->pPrior && pSub->pOrderBy==0 );
      pSub->pOrderBy = p->pOrderBy;
      p->pOrderBy = 0;
    }
  
    /* Recursively resolve names in all subqueries
    */
    i = 0;

// ABS Label 1105
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1105);
}
// ABS Label 1106
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1106);
}

// ROR Label 1107
if((i <= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1107);
}
// ROR Label 1108
if((i > p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1108);
}
// ROR Label 1109
if((i >= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1109);
}
for(; i<p->pSrc->nSrc; i++){
      SrcItem *pItem = &p->pSrc->a[i];
      
// ABS Label 1115
if(pItem->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1115);
}

// COR Label 1116
if((pItem->pSelect || (pItem->pSelect->selFlags & 4) == 0) != (pItem->pSelect && (pItem->pSelect->selFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1116);
}

// ROR Label 1117
if(((pItem->pSelect->selFlags & 4) != 0) != ((pItem->pSelect->selFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1117);
}

// MCC Label 1118
if(pItem->pSelect && (pItem->pSelect->selFlags & 4) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1118);
}
// MCC Label 1119
if(pItem->pSelect && !((pItem->pSelect->selFlags & 4) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1119);
}
// MCC Label 1120
if(!(pItem->pSelect) && (pItem->pSelect->selFlags & 4) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1120);
}
// MCC Label 1121
if(!(pItem->pSelect) && !((pItem->pSelect->selFlags & 4) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1121);
}
if( pItem->pSelect && (pItem->pSelect->selFlags & SF_Resolved)==0 ){
        int nRef = pOuterNC ? pOuterNC->nRef : 0;
        
// ABS Label 1122
if(pParse->zAuthContext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1122);
}
const char *zSavedContext = pParse->zAuthContext;

        
// ABS Label 1126
if(pItem->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1126);
}
if( pItem->zName ) { pParse->zAuthContext = pItem->zName;
}
        
// ABS Label 1123
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1123);
}

// ABS Label 1124
if(pItem->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1124);
}

// ABS Label 1125
if(pOuterNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1125);
}
sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);
        pParse->zAuthContext = zSavedContext;
        
// ABS Label 1127
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1127);
}

// COR Label 1128
if((pParse->nErr && db->mallocFailed) != (pParse->nErr || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1128);
}

// MCC Label 1129
if(pParse->nErr && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1129);
}
// MCC Label 1130
if(pParse->nErr && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1130);
}
// MCC Label 1131
if(!(pParse->nErr) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1131);
}
// MCC Label 1132
if(!(pParse->nErr) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1132);
}
if( pParse->nErr || db->mallocFailed ) { return WRC_Abort;
}

        /* If the number of references to the outer context changed when
        ** expressions in the sub-select were resolved, the sub-select
        ** is correlated. It is not required to check the refcount on any
        ** but the innermost outer context object, as lookupName() increments
        ** the refcount on all contexts between the current one and the
        ** context containing the column when it resolves a name. */
        
// ABS Label 1133
if(pOuterNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1133);
}
if( pOuterNC ){
          assert( pItem->fg.isCorrelated==0 && pOuterNC->nRef>=nRef );
          pItem->fg.isCorrelated = (pOuterNC->nRef>nRef);
        }
      }
    };
// ABS Label 1110
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1110);
}
// ABS Label 1111
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1111);
}

// ROR Label 1112
if((i <= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1112);
}
// ROR Label 1113
if((i > p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1113);
}
// ROR Label 1114
if((i >= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1114);
}

  
    /* Set up the local name-context to pass to sqlite3ResolveExprNames() to
    ** resolve the result-set expression list.
    */
    sNC.ncFlags = NC_AllowAgg|NC_AllowWin;
    sNC.pSrcList = p->pSrc;
    sNC.pNext = pOuterNC;
  
    /* Resolve names in the result set. */
    if( sqlite3ResolveExprListNames(&sNC, p->pEList) ) { return WRC_Abort;
}
    sNC.ncFlags &= ~NC_AllowWin;
  
    /* If there are no aggregate functions in the result-set, and no GROUP BY 
    ** expression, do not allow aggregates in any of the other expressions.
    */
    assert( (p->selFlags & SF_Aggregate)==0 );
    pGroupBy = p->pGroupBy;
    
// ABS Label 1134
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}

// COR Label 1135
if((pGroupBy && (sNC.ncFlags & 16) != 0) != (pGroupBy || (sNC.ncFlags & 16) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1135);
}

// ROR Label 1136
if(((sNC.ncFlags & 16) == 0) != ((sNC.ncFlags & 16) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1136);
}

// MCC Label 1137
if(pGroupBy && (sNC.ncFlags & 16) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1137);
}
// MCC Label 1138
if(pGroupBy && !((sNC.ncFlags & 16) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1138);
}
// MCC Label 1139
if(!(pGroupBy) && (sNC.ncFlags & 16) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1139);
}
// MCC Label 1140
if(!(pGroupBy) && !((sNC.ncFlags & 16) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1140);
}
if( pGroupBy || (sNC.ncFlags & NC_HasAgg)!=0 ){
      assert( NC_MinMaxAgg==SF_MinMaxAgg );
      p->selFlags |= SF_Aggregate | (sNC.ncFlags&NC_MinMaxAgg);
    }else{
      sNC.ncFlags &= ~NC_AllowAgg;
    }
  
    /* Add the output column list to the name-context before parsing the
    ** other expressions in the SELECT statement. This is so that
    ** expressions in the WHERE clause (etc.) can refer to expressions by
    ** aliases in the result set.
    **
    ** Minor point: If this is the case, then the expression will be
    ** re-evaluated for each reference to it.
    */
    assert( (sNC.ncFlags & (NC_UAggInfo|NC_UUpsert|NC_UBaseReg))==0 );
    sNC.uNC.pEList = p->pEList;
    sNC.ncFlags |= NC_UEList;
    
// ABS Label 1141
if(p->pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1141);
}
if( p->pHaving ){
      if( !pGroupBy ){
        
// ABS Label 1142
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1142);
}
sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
        return WRC_Abort;
      }
      if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) { return WRC_Abort;
}
    }
    if( sqlite3ResolveExprNames(&sNC, p->pWhere) ) { return WRC_Abort;
}

    /* Resolve names in table-valued-function arguments */
    i = 0;

// ABS Label 1143
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1143);
}
// ABS Label 1144
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1144);
}

// ROR Label 1145
if((i <= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1145);
}
// ROR Label 1146
if((i > p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1146);
}
// ROR Label 1147
if((i >= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1147);
}
for(; i<p->pSrc->nSrc; i++){
      SrcItem *pItem = &p->pSrc->a[i];
      if( pItem->fg.isTabFunc
       && sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg) 
      ){
        return WRC_Abort;
      }
    };
// ABS Label 1148
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1148);
}
// ABS Label 1149
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1149);
}

// ROR Label 1150
if((i <= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1150);
}
// ROR Label 1151
if((i > p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1151);
}
// ROR Label 1152
if((i >= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1152);
}


#ifndef SQLITE_OMIT_WINDOWFUNC
    
// MCC Label 1153
if(( pParse->eParseMode >= 2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1153);
}
// MCC Label 1154
if(( !(pParse->eParseMode >= 2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1154);
}
if( IN_RENAME_OBJECT ){
      Window *pWin;
      pWin = p->pWinDefn;

// ABS Label 1155
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1155);
}
for(; pWin; pWin=pWin->pNextWin){
        if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)
         || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)
        ){
          return WRC_Abort;
        }
      };
// ABS Label 1156
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}

    }
#endif

    /* The ORDER BY and GROUP BY clauses may not refer to terms in
    ** outer queries 
    */
    sNC.pNext = 0;
    sNC.ncFlags |= NC_AllowAgg|NC_AllowWin;

    /* If this is a converted compound query, move the ORDER BY clause from 
    ** the sub-query back to the parent query. At this point each term
    ** within the ORDER BY clause has been transformed to an integer value.
    ** These integers will be replaced by copies of the corresponding result
    ** set expressions by the call to resolveOrderGroupBy() below.  */
    
// ABS Label 1157
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1157);
}

// AOR Label 1158
if(p->selFlags | 65536 != p->selFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1158);
}
// AOR Label 1159
if(p->selFlags ^ 65536 != p->selFlags & 65536)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1159);
}
if( p->selFlags & SF_Converted ){
      
// ABS Label 1160
if(p->pSrc->a[0].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1160);
}
Select *pSub = p->pSrc->a[0].pSelect;
      p->pOrderBy = pSub->pOrderBy;
      pSub->pOrderBy = 0;
    }

    /* Process the ORDER BY clause for singleton SELECT statements.
    ** The ORDER BY clause for compounds SELECT statements is handled
    ** below, after all of the result-sets for all of the elements of
    ** the compound have been resolved.
    **
    ** If there is an ORDER BY clause on a term of a compound-select other
    ** than the right-most term, then that is a syntax error.  But the error
    ** is not detected until much later, and so we need to go ahead and
    ** resolve those symbols on the incorrect ORDER BY for consistency.
    */
    if( p->pOrderBy!=0
     && isCompound<=nCompound  /* Defer right-most ORDER BY of a compound */
     && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")
    ){
      return WRC_Abort;
    }
    
// ABS Label 1161
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1161);
}
if( db->mallocFailed ){
      return WRC_Abort;
    }
    sNC.ncFlags &= ~NC_AllowWin;
  
    /* Resolve the GROUP BY clause.  At the same time, make sure 
    ** the GROUP BY clause does not contain aggregate functions.
    */
    
// ABS Label 1162
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1162);
}
if( pGroupBy ){
      struct ExprList_item *pItem;
    
      if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){
        return WRC_Abort;
      }
      i = 0 , pItem = pGroupBy->a;

// ABS Label 1163
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1163);
}
// ABS Label 1164
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1164);
}

// ROR Label 1165
if((i <= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1165);
}
// ROR Label 1166
if((i > pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1166);
}
// ROR Label 1167
if((i >= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1167);
}
for(; i<pGroupBy->nExpr; i++, pItem++){
        
// MCC Label 1173
if(( ((pItem->pExpr)->flags & (16)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1173);
}
// MCC Label 1174
if(( !(((pItem->pExpr)->flags & (16)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1174);
}
if( ExprHasProperty(pItem->pExpr, EP_Agg) ){
          
// ABS Label 1175
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}
sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "
              "the GROUP BY clause");
          return WRC_Abort;
        }
      };
// ABS Label 1168
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1168);
}
// ABS Label 1169
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1169);
}

// ROR Label 1170
if((i <= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1170);
}
// ROR Label 1171
if((i > pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1171);
}
// ROR Label 1172
if((i >= pGroupBy->nExpr) != (i < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1172);
}

    }

    /* If this is part of a compound SELECT, check that it has the right
    ** number of expressions in the select list. */
    
// ABS Label 1176
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1176);
}
// ABS Label 1177
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1177);
}
// ABS Label 1178
if(p->pNext->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1178);
}

// COR Label 1179
if((p->pNext || p->pEList->nExpr != p->pNext->pEList->nExpr) != (p->pNext && p->pEList->nExpr != p->pNext->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1179);
}

// ROR Label 1180
if((p->pEList->nExpr == p->pNext->pEList->nExpr) != (p->pEList->nExpr != p->pNext->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1180);
}

// MCC Label 1181
if(p->pNext && p->pEList->nExpr != p->pNext->pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1181);
}
// MCC Label 1182
if(p->pNext && !(p->pEList->nExpr != p->pNext->pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1182);
}
// MCC Label 1183
if(!(p->pNext) && p->pEList->nExpr != p->pNext->pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1183);
}
// MCC Label 1184
if(!(p->pNext) && !(p->pEList->nExpr != p->pNext->pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1184);
}
if( p->pNext && p->pEList->nExpr!=p->pNext->pEList->nExpr ){
      
// ABS Label 1185
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}

// ABS Label 1186
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1186);
}
sqlite3SelectWrongNumTermsError(pParse, p->pNext);
      return WRC_Abort;
    }

    /* Advance to the next term of the compound
    */
    p = p->pPrior;
    nCompound++;
  };
// ABS Label 1100
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}


  /* Resolve the ORDER BY on a compound SELECT after all terms of
  ** the compound have been resolved.
  */
  if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){
    return WRC_Abort;
  }

  return WRC_Prune;
}

/*
** This routine walks an expression tree and resolves references to
** table columns and result-set columns.  At the same time, do error
** checking on function usage and set a flag if any aggregate functions
** are seen.
**
** To resolve table columns references we look for nodes (or subtrees) of the 
** form X.Y.Z or Y.Z or just Z where
**
**      X:   The name of a database.  Ex:  "main" or "temp" or
**           the symbolic name assigned to an ATTACH-ed database.
**
**      Y:   The name of a table in a FROM clause.  Or in a trigger
**           one of the special names "old" or "new".
**
**      Z:   The name of a column in table Y.
**
** The node at the root of the subtree is modified as follows:
**
**    Expr.op        Changed to TK_COLUMN
**    Expr.pTab      Points to the Table object for X.Y
**    Expr.iColumn   The column index in X.Y.  -1 for the rowid.
**    Expr.iTable    The VDBE cursor number for X.Y
**
**
** To resolve result-set references, look for expression nodes of the
** form Z (with no X and Y prefix) where the Z matches the right-hand
** size of an AS clause in the result-set of a SELECT.  The Z expression
** is replaced by a copy of the left-hand side of the result-set expression.
** Table-name and function resolution occurs on the substituted expression
** tree.  For example, in:
**
**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY x;
**
** The "x" term of the order by is replaced by "a+b" to render:
**
**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY a+b;
**
** Function calls are checked to make sure that the function is 
** defined and that the correct number of arguments are specified.
** If the function is an aggregate function, then the NC_HasAgg flag is
** set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.
** If an expression contains aggregate functions then the EP_Agg
** property on the expression is set.
**
** An error message is left in pParse if anything is amiss.  The number
** if errors is returned.
*/
int sqlite3ResolveExprNames( 
  NameContext *pNC,       /* Namespace to resolve expressions in. */
  Expr *pExpr             /* The expression to be analyzed. */
){
  int savedHasAgg;
  Walker w;

  
// ABS Label 1188
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1188);
}

// ROR Label 1189
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1189);
}
if( pExpr==0 ) { return SQLITE_OK;
}
  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
  w.pParse = pNC->pParse;
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = (pNC->ncFlags & NC_NoSelect) ? 0 : resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.u.pNC = pNC;
#if SQLITE_MAX_EXPR_DEPTH>0
  w.pParse->nHeight += pExpr->nHeight;
  if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){
    return SQLITE_ERROR;
  }
#endif
  
// ABS Label 1187
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}
sqlite3WalkExpr(&w, pExpr);
#if SQLITE_MAX_EXPR_DEPTH>0
  w.pParse->nHeight -= pExpr->nHeight;
#endif
  assert( EP_Agg==NC_HasAgg );
  assert( EP_Win==NC_HasWin );
  testcase( pNC->ncFlags & NC_HasAgg );
  testcase( pNC->ncFlags & NC_HasWin );
  ExprSetProperty(pExpr, pNC->ncFlags & (NC_HasAgg|NC_HasWin) );
  pNC->ncFlags |= savedHasAgg;
  
// ABS Label 1190
if(pNC->nNcErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}
// ABS Label 1191
if(w.pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}

// COR Label 1192
if((pNC->nNcErr > 0 && w.pParse->nErr > 0) != (pNC->nNcErr > 0 || w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1192);
}

// ROR Label 1193
if((pNC->nNcErr <= 0) != (pNC->nNcErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1193);
}
// ROR Label 1194
if((pNC->nNcErr < 0) != (pNC->nNcErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1194);
}
// ROR Label 1195
if((pNC->nNcErr >= 0) != (pNC->nNcErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1195);
}
// ROR Label 1196
if((w.pParse->nErr <= 0) != (w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1196);
}
// ROR Label 1197
if((w.pParse->nErr < 0) != (w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1197);
}
// ROR Label 1198
if((w.pParse->nErr >= 0) != (w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1198);
}

// MCC Label 1199
if(pNC->nNcErr > 0 && w.pParse->nErr > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1199);
}
// MCC Label 1200
if(pNC->nNcErr > 0 && !(w.pParse->nErr > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1200);
}
// MCC Label 1201
if(!(pNC->nNcErr > 0) && w.pParse->nErr > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1201);
}
// MCC Label 1202
if(!(pNC->nNcErr > 0) && !(w.pParse->nErr > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1202);
}
return pNC->nNcErr>0 || w.pParse->nErr>0;
}

/*
** Resolve all names for all expression in an expression list.  This is
** just like sqlite3ResolveExprNames() except that it works for an expression
** list rather than a single expression.
*/
int sqlite3ResolveExprListNames( 
  NameContext *pNC,       /* Namespace to resolve expressions in. */
  ExprList *pList         /* The expression list to be analyzed. */
){
  int i;
  int savedHasAgg = 0;
  Walker w;
  
// ABS Label 1203
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1203);
}

// ROR Label 1204
if((pList != 0) != (pList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1204);
}
if( pList==0 ) { return WRC_Continue;
}
  w.pParse = pNC->pParse;
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.u.pNC = pNC;
  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
  i = 0;

// ABS Label 1205
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1205);
}
// ABS Label 1206
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1206);
}

// ROR Label 1207
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1207);
}
// ROR Label 1208
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1208);
}
// ROR Label 1209
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1209);
}
for(; i<pList->nExpr; i++){
    
// ABS Label 1215
if(pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1215);
}
Expr *pExpr = pList->a[i].pExpr;
    
// ABS Label 1217
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1217);
}

// ROR Label 1218
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1218);
}
if( pExpr==0 ) { continue;
}
#if SQLITE_MAX_EXPR_DEPTH>0
    w.pParse->nHeight += pExpr->nHeight;
    if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){
      return WRC_Abort;
    }
#endif
    
// ABS Label 1216
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1216);
}
sqlite3WalkExpr(&w, pExpr);
#if SQLITE_MAX_EXPR_DEPTH>0
    w.pParse->nHeight -= pExpr->nHeight;
#endif
    assert( EP_Agg==NC_HasAgg );
    assert( EP_Win==NC_HasWin );
    testcase( pNC->ncFlags & NC_HasAgg );
    testcase( pNC->ncFlags & NC_HasWin );
    
// ABS Label 1219
if(pNC->ncFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1219);
}

// AOR Label 1220
if(pNC->ncFlags | (16 | 4096 | 32768) != pNC->ncFlags & (16 | 4096 | 32768))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1220);
}
// AOR Label 1221
if(pNC->ncFlags ^ (16 | 4096 | 32768) != pNC->ncFlags & (16 | 4096 | 32768))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1221);
}
if( pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin) ){
      ExprSetProperty(pExpr, pNC->ncFlags & (NC_HasAgg|NC_HasWin) );
      savedHasAgg |= pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
      pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin);
    }
    
// ABS Label 1222
if(w.pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1222);
}

// ROR Label 1223
if((w.pParse->nErr <= 0) != (w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1223);
}
// ROR Label 1224
if((w.pParse->nErr < 0) != (w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1224);
}
// ROR Label 1225
if((w.pParse->nErr >= 0) != (w.pParse->nErr > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1225);
}
if( w.pParse->nErr>0 ) { return WRC_Abort;
}
  };
// ABS Label 1210
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1210);
}
// ABS Label 1211
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1211);
}

// ROR Label 1212
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1212);
}
// ROR Label 1213
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1213);
}
// ROR Label 1214
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1214);
}

  pNC->ncFlags |= savedHasAgg;
  return WRC_Continue;
}

/*
** Resolve all names in all expressions of a SELECT and in all
** decendents of the SELECT, including compounds off of p->pPrior,
** subqueries in expressions, and subqueries used as FROM clause
** terms.
**
** See sqlite3ResolveExprNames() for a description of the kinds of
** transformations that occur.
**
** All SELECT statements should have been expanded using
** sqlite3SelectExpand() prior to invoking this routine.
*/
void sqlite3ResolveSelectNames(
  Parse *pParse,         /* The parser context */
  Select *p,             /* The SELECT statement being coded. */
  NameContext *pOuterNC  /* Name context for parent SELECT statement */
){
  Walker w;

  assert( p!=0 );
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.pParse = pParse;
  w.u.pNC = pOuterNC;
  
// ABS Label 1226
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1226);
}
sqlite3WalkSelect(&w, p);
}

/*
** Resolve names in expressions that can only reference a single table
** or which cannot reference any tables at all.  Examples:
**
**                                                    "type" flag
**                                                    ------------
**    (1)   CHECK constraints                         NC_IsCheck
**    (2)   WHERE clauses on partial indices          NC_PartIdx
**    (3)   Expressions in indexes on expressions     NC_IdxExpr
**    (4)   Expression arguments to VACUUM INTO.      0
**    (5)   GENERATED ALWAYS as expressions           NC_GenCol
**
** In all cases except (4), the Expr.iTable value for Expr.op==TK_COLUMN
** nodes of the expression is set to -1 and the Expr.iColumn value is
** set to the column number.  In case (4), TK_COLUMN nodes cause an error.
**
** Any errors cause an error message to be set in pParse.
*/
int sqlite3ResolveSelfReference(
  Parse *pParse,   /* Parsing context */
  Table *pTab,     /* The table being referenced, or NULL */
  int type,        /* NC_IsCheck, NC_PartIdx, NC_IdxExpr, NC_GenCol, or 0 */
  Expr *pExpr,     /* Expression to resolve.  May be NULL. */
  ExprList *pList  /* Expression list to resolve.  May be NULL. */
){
  SrcList sSrc;                   /* Fake SrcList for pParse->pNewTable */
  NameContext sNC;                /* Name context for pParse->pNewTable */
  int rc;

  assert( type==0 || pTab!=0 );
  assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr
          || type==NC_GenCol || pTab==0 );
  memset(&sNC, 0, sizeof(sNC));
  memset(&sSrc, 0, sizeof(sSrc));
  
// ABS Label 1227
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1227);
}
if( pTab ){
    sSrc.nSrc = 1;
    sSrc.a[0].zName = pTab->zName;
    sSrc.a[0].pTab = pTab;
    sSrc.a[0].iCursor = -1;
    
// ABS Label 1228
if(pParse->db->aDb[1].pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1228);
}
// ABS Label 1229
if(pTab->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1229);
}

// ROR Label 1230
if((pTab->pSchema == pParse->db->aDb[1].pSchema) != (pTab->pSchema != pParse->db->aDb[1].pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1230);
}
if( pTab->pSchema!=pParse->db->aDb[1].pSchema ){
      /* Cause EP_FromDDL to be set on TK_FUNCTION nodes of non-TEMP
      ** schema elements */
      type |= NC_FromDDL;
    }
  }
  sNC.pParse = pParse;
  sNC.pSrcList = &sSrc;
  sNC.ncFlags = type | NC_IsDDL;
  if( (rc = sqlite3ResolveExprNames(&sNC, pExpr))!=SQLITE_OK ) { 
// ABS Label 1231
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1231);
}
return rc;
}
  
// ABS Label 1232
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1232);
}
if( pList ) { rc = sqlite3ResolveExprListNames(&sNC, pList);
}
  
// ABS Label 1233
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1233);
}
return rc;
}
