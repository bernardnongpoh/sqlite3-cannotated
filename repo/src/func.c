/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2002 February 23
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the C-language implementations for many of the SQL
** functions of SQLite.  (Some function, and in particular the date and
** time functions, are implemented separately.)
*/
#include "sqliteInt.h"
#include <stdlib.h>
#include <assert.h>
#ifndef SQLITE_OMIT_FLOATING_POINT
#include <math.h>
#endif
#include "vdbeInt.h"

/*
** Return the collating function associated with a function.
*/
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){
  VdbeOp *pOp;
  assert( context->pVdbe!=0 );
  pOp = &context->pVdbe->aOp[context->iOp-1];
  assert( pOp->opcode==OP_CollSeq );
  assert( pOp->p4type==P4_COLLSEQ );
  
// ABS Label 7
if(pOp->p4.pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
return pOp->p4.pColl;
}

/*
** Indicate that the accumulator load should be skipped on this
** iteration of the aggregate loop.
*/
static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){
  assert( context->isError<=0 );
  context->isError = -1;
  context->skipFlag = 1;
}

/*
** Implementation of the non-aggregate min() and max() functions
*/
static void minmaxFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i;
  int mask;    /* 0 for min() or 0xffffffff for max() */
  int iBest;
  CollSeq *pColl;

  assert( argc>1 );
  mask = sqlite3_user_data(context)==0 ? 0 : -1;
  pColl = sqlite3GetFuncCollSeq(context);
  assert( pColl );
  assert( mask==-1 || mask==0 );
  iBest = 0;
  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) { return;
}
  i = 1;

// ABS Label 11
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
// ABS Label 12
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ROR Label 13
if((i <= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if((i > argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
// ROR Label 15
if((i >= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
for(; i<argc; i++){
    if( sqlite3_value_type(argv[i])==SQLITE_NULL ) { return;
}
    if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){
      testcase( mask==0 );
      iBest = i;
    }
  };
// ABS Label 16
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
// ABS Label 17
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// ROR Label 18
if((i <= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
// ROR Label 19
if((i > argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
// ROR Label 20
if((i >= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 20);
}

  
// ABS Label 8
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

// ABS Label 9
if(argv[iBest] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
// ABS Label 10
if(iBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
sqlite3_result_value(context, argv[iBest]);
}

/*
** Return the type of the argument.
*/
static void typeofFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  static const char *azType[] = { "integer", "real", "text", "blob", "null" };
  int i = sqlite3_value_type(argv[0]) - 1;
  UNUSED_PARAMETER(NotUsed);
  assert( i>=0 && i<ArraySize(azType) );
  assert( SQLITE_INTEGER==1 );
  assert( SQLITE_FLOAT==2 );
  assert( SQLITE_TEXT==3 );
  assert( SQLITE_BLOB==4 );
  assert( SQLITE_NULL==5 );
  /* EVIDENCE-OF: R-01470-60482 The sqlite3_value_type(V) interface returns
  ** the datatype code for the initial datatype of the sqlite3_value object
  ** V. The returned value is one of SQLITE_INTEGER, SQLITE_FLOAT,
  ** SQLITE_TEXT, SQLITE_BLOB, or SQLITE_NULL. */
  
// ABS Label 21
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}

// ABS Label 22
if(azType[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
// ABS Label 23
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3_result_text(context, azType[i], -1, SQLITE_STATIC);
}


/*
** Implementation of the length() function
*/
static void lengthFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case SQLITE_BLOB:
    case SQLITE_INTEGER:
    case SQLITE_FLOAT: {
      
// ABS Label 24
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      break;
    }
    case SQLITE_TEXT: {
      const unsigned char *z = sqlite3_value_text(argv[0]);
      const unsigned char *z0;
      unsigned char c;
      
// ABS Label 26
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// ROR Label 27
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
if( z==0 ) { return;
}
      z0 = z;
      while( (c = *z)!=0 ){
        z++;
        
// ROR Label 28
if((c < 192) != (c >= 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((c > 192) != (c >= 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((c <= 192) != (c >= 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
if( c>=0xc0 ){
          
// ROR Label 31
if(((*z & 192) != 128) != ((*z & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
while( (*z & 0xc0)==0x80 ){ z++; z0++; };
// ROR Label 32
if(((*z & 192) != 128) != ((*z & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}

        }
      };
      
// ABS Label 25
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
sqlite3_result_int(context, (int)(z-z0));
      break;
    }
    default: {
      
// ABS Label 33
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
sqlite3_result_null(context);
      break;
    }
  }
}

/*
** Implementation of the abs() function.
**
** IMP: R-23979-26855 The abs(X) function returns the absolute value of
** the numeric argument X. 
*/
static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case SQLITE_INTEGER: {
      i64 iVal = sqlite3_value_int64(argv[0]);
      
// ABS Label 36
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}

// ROR Label 37
if((iVal <= 0) != (iVal < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
// ROR Label 38
if((iVal > 0) != (iVal < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((iVal >= 0) != (iVal < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
if( iVal<0 ){
        
// ABS Label 40
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}

// ROR Label 41
if((iVal != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (iVal == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
if( iVal==SMALLEST_INT64 ){
          /* IMP: R-31676-45509 If X is the integer -9223372036854775808
          ** then abs(X) throws an integer overflow error since there is no
          ** equivalent positive 64-bit two complement value. */
          
// ABS Label 42
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}
sqlite3_result_error(context, "integer overflow", -1);
          return;
        }
        iVal = -iVal;
      } 
      
// ABS Label 34
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ABS Label 35
if(iVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
sqlite3_result_int64(context, iVal);
      break;
    }
    case SQLITE_NULL: {
      /* IMP: R-37434-19929 Abs(X) returns NULL if X is NULL. */
      
// ABS Label 43
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}
sqlite3_result_null(context);
      break;
    }
    default: {
      /* Because sqlite3_value_double() returns 0.0 if the argument is not
      ** something that can be converted into a number, we have:
      ** IMP: R-01992-00519 Abs(X) returns 0.0 if X is a string or blob
      ** that cannot be converted to a numeric value.
      */
      double rVal = sqlite3_value_double(argv[0]);
      
// ABS Label 46
if(rVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}

// ROR Label 47
if((rVal <= 0) != (rVal < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
// ROR Label 48
if((rVal > 0) != (rVal < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
// ROR Label 49
if((rVal >= 0) != (rVal < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
if( rVal<0 ) { rVal = -rVal;
}
      
// ABS Label 44
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// ABS Label 45
if(rVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
sqlite3_result_double(context, rVal);
      break;
    }
  }
}

/*
** Implementation of the instr() function.
**
** instr(haystack,needle) finds the first occurrence of needle
** in haystack and returns the number of previous characters plus 1,
** or 0 if needle does not occur within haystack.
**
** If both haystack and needle are BLOBs, then the result is one more than
** the number of bytes in haystack prior to the first occurrence of needle,
** or 0 if needle never occurs in haystack.
*/
static void instrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zHaystack;
  const unsigned char *zNeedle;
  int nHaystack;
  int nNeedle;
  int typeHaystack, typeNeedle;
  int N = 1;
  int isText;
  unsigned char firstChar;
  sqlite3_value *pC1 = 0;
  sqlite3_value *pC2 = 0;

  UNUSED_PARAMETER(argc);
  typeHaystack = sqlite3_value_type(argv[0]);
  typeNeedle = sqlite3_value_type(argv[1]);
  
// ABS Label 53
if(typeHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
// ABS Label 54
if(typeNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// COR Label 55
if((typeHaystack == 5 && typeNeedle == 5) != (typeHaystack == 5 || typeNeedle == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 55);
}

// ROR Label 56
if((typeHaystack != 5) != (typeHaystack == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
// ROR Label 57
if((typeNeedle != 5) != (typeNeedle == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}

// MCC Label 58
if(typeHaystack == 5 && typeNeedle == 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 58);
}
// MCC Label 59
if(typeHaystack == 5 && !(typeNeedle == 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if(!(typeHaystack == 5) && typeNeedle == 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!(typeHaystack == 5) && !(typeNeedle == 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
if( typeHaystack==SQLITE_NULL || typeNeedle==SQLITE_NULL ) { return;
}
  nHaystack = sqlite3_value_bytes(argv[0]);
  nNeedle = sqlite3_value_bytes(argv[1]);
  
// ABS Label 62
if(nNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 62);
}

// ROR Label 63
if((nNeedle <= 0) != (nNeedle > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((nNeedle < 0) != (nNeedle > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((nNeedle >= 0) != (nNeedle > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
if( nNeedle>0 ){
    
// ABS Label 66
if(typeHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
// ABS Label 67
if(typeNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}

// COR Label 68
if((typeHaystack == 4 || typeNeedle == 4) != (typeHaystack == 4 && typeNeedle == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 68);
}

// ROR Label 69
if((typeHaystack != 4) != (typeHaystack == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((typeNeedle != 4) != (typeNeedle == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}

// MCC Label 71
if(typeHaystack == 4 && typeNeedle == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if(typeHaystack == 4 && !(typeNeedle == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
// MCC Label 73
if(!(typeHaystack == 4) && typeNeedle == 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
// MCC Label 74
if(!(typeHaystack == 4) && !(typeNeedle == 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 74);
}
if( typeHaystack==SQLITE_BLOB && typeNeedle==SQLITE_BLOB ){
      zHaystack = sqlite3_value_blob(argv[0]);
      zNeedle = sqlite3_value_blob(argv[1]);
      isText = 0;
    }else { 
// ABS Label 75
if(typeHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}
// ABS Label 76
if(typeNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// COR Label 77
if((typeHaystack != 4 || typeNeedle != 4) != (typeHaystack != 4 && typeNeedle != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 77);
}

// ROR Label 78
if((typeHaystack == 4) != (typeHaystack != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
// ROR Label 79
if((typeNeedle == 4) != (typeNeedle != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}

// MCC Label 80
if(typeHaystack != 4 && typeNeedle != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 80);
}
// MCC Label 81
if(typeHaystack != 4 && !(typeNeedle != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 81);
}
// MCC Label 82
if(!(typeHaystack != 4) && typeNeedle != 4 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
// MCC Label 83
if(!(typeHaystack != 4) && !(typeNeedle != 4) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
if( typeHaystack!=SQLITE_BLOB && typeNeedle!=SQLITE_BLOB ){
      zHaystack = sqlite3_value_text(argv[0]);
      zNeedle = sqlite3_value_text(argv[1]);
      isText = 1;
    }else{
      pC1 = sqlite3_value_dup(argv[0]);
      zHaystack = sqlite3_value_text(pC1);
      
// ABS Label 84
if(zHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ROR Label 85
if((zHaystack != 0) != (zHaystack == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}
if( zHaystack==0 ) { goto endInstrOOM;
}
      nHaystack = sqlite3_value_bytes(pC1);
      pC2 = sqlite3_value_dup(argv[1]);
      zNeedle = sqlite3_value_text(pC2);
      
// ABS Label 86
if(zNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}

// ROR Label 87
if((zNeedle != 0) != (zNeedle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}
if( zNeedle==0 ) { goto endInstrOOM;
}
      nNeedle = sqlite3_value_bytes(pC2);
      isText = 1;
    };}

    
// ABS Label 88
if(zNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// COR Label 89
if((zNeedle == 0 && (nHaystack && zHaystack == 0)) != (zNeedle == 0 || (nHaystack && zHaystack == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 89);
}

// ROR Label 90
if((zNeedle != 0) != (zNeedle == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}

// MCC Label 91
if(zNeedle == 0 && ( nHaystack && zHaystack == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 91);
}
// MCC Label 92
if(zNeedle == 0 && ( nHaystack && !(zHaystack == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 92);
}
// MCC Label 93
if(zNeedle == 0 && ( !(nHaystack) && zHaystack == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 93);
}
// MCC Label 94
if(zNeedle == 0 && ( !(nHaystack) && !(zHaystack == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(!(zNeedle == 0) && ( nHaystack && zHaystack == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(!(zNeedle == 0) && ( nHaystack && !(zHaystack == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(!(zNeedle == 0) && ( !(nHaystack) && zHaystack == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
// MCC Label 98
if(!(zNeedle == 0) && ( !(nHaystack) && !(zHaystack == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 98);
}
if( zNeedle==0 || (nHaystack && zHaystack==0) ) { goto endInstrOOM;
}
    firstChar = zNeedle[0];
    
// ABS Label 99
if(nHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
// ABS Label 100
if(nNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}

// COR Label 101
if((nNeedle <= nHaystack || (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0)) != (nNeedle <= nHaystack && (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 101);
}

// ROR Label 102
if((nNeedle < nHaystack) != (nNeedle <= nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 102);
}
// ROR Label 103
if((nNeedle > nHaystack) != (nNeedle <= nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 103);
}
// ROR Label 104
if((nNeedle >= nHaystack) != (nNeedle <= nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}

// MCC Label 105
if(nNeedle <= nHaystack && ( zHaystack[0] != firstChar && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 105);
}
// MCC Label 106
if(nNeedle <= nHaystack && ( !(zHaystack[0] != firstChar) && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 106);
}
// MCC Label 107
if(!(nNeedle <= nHaystack) && ( zHaystack[0] != firstChar && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 107);
}
// MCC Label 108
if(!(nNeedle <= nHaystack) && ( !(zHaystack[0] != firstChar) && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
while( nNeedle<=nHaystack
       && (zHaystack[0]!=firstChar || memcmp(zHaystack, zNeedle, nNeedle)!=0)
    ){
      N++;
      
// ABS Label 119
if(isText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}

// COR Label 120
if((isText || (zHaystack[0] & 192) == 128) != (isText && (zHaystack[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 120);
}

// ROR Label 121
if(((zHaystack[0] & 192) != 128) != ((zHaystack[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}

// MCC Label 122
if(isText && (zHaystack[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(isText && !((zHaystack[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
// MCC Label 124
if(!(isText) && (zHaystack[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 124);
}
// MCC Label 125
if(!(isText) && !((zHaystack[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 125);
}
do{
        nHaystack--;
        zHaystack++;
      }while( isText && (zHaystack[0]&0xc0)==0x80 );
// ABS Label 126
if(isText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// COR Label 127
if((isText || (zHaystack[0] & 192) == 128) != (isText && (zHaystack[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 127);
}

// ROR Label 128
if(((zHaystack[0] & 192) != 128) != ((zHaystack[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}

// MCC Label 129
if(isText && (zHaystack[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
// MCC Label 130
if(isText && !((zHaystack[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 130);
}
// MCC Label 131
if(!(isText) && (zHaystack[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 131);
}
// MCC Label 132
if(!(isText) && !((zHaystack[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
;
    };
// ABS Label 109
if(nHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}
// ABS Label 110
if(nNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 110);
}

// COR Label 111
if((nNeedle <= nHaystack || (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0)) != (nNeedle <= nHaystack && (zHaystack[0] != firstChar || memcmp(zHaystack, zNeedle, nNeedle) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 111);
}

// ROR Label 112
if((nNeedle < nHaystack) != (nNeedle <= nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 112);
}
// ROR Label 113
if((nNeedle > nHaystack) != (nNeedle <= nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
// ROR Label 114
if((nNeedle >= nHaystack) != (nNeedle <= nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}

// MCC Label 115
if(nNeedle <= nHaystack && ( zHaystack[0] != firstChar && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 115);
}
// MCC Label 116
if(nNeedle <= nHaystack && ( !(zHaystack[0] != firstChar) && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 116);
}
// MCC Label 117
if(!(nNeedle <= nHaystack) && ( zHaystack[0] != firstChar && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 117);
}
// MCC Label 118
if(!(nNeedle <= nHaystack) && ( !(zHaystack[0] != firstChar) && 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 118);
}

    
// ABS Label 133
if(nHaystack < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
// ABS Label 134
if(nNeedle < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}

// ROR Label 135
if((nNeedle <= nHaystack) != (nNeedle > nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 135);
}
// ROR Label 136
if((nNeedle < nHaystack) != (nNeedle > nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 136);
}
// ROR Label 137
if((nNeedle >= nHaystack) != (nNeedle > nHaystack))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
if( nNeedle>nHaystack ) { N = 0;
}
  }
  
// ABS Label 50
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}

// ABS Label 51
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
sqlite3_result_int(context, N);
endInstr:
  sqlite3_value_free(pC1);
  
// ABS Label 52
if(pC2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
sqlite3_value_free(pC2);
  return;
endInstrOOM:
  sqlite3_result_error_nomem(context);
  goto endInstr;
}

/*
** Implementation of the printf() function.
*/
static void printfFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  PrintfArguments x;
  StrAccum str;
  const char *zFormat;
  int n;
  sqlite3 *db = sqlite3_context_db_handle(context);

  if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    x.nArg = argc-1;
    x.nUsed = 0;
    x.apArg = argv+1;
    
// ABS Label 138
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// ABS Label 139
if(db->aLimit[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}
sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);
    str.printfFlags = SQLITE_PRINTF_SQLFUNC;
    
// ABS Label 140
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
sqlite3_str_appendf(&str, zFormat, &x);
    n = str.nChar;
    
// ABS Label 141
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ABS Label 142
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,
                        SQLITE_DYNAMIC);
  }
}

/*
** Implementation of the substr() function.
**
** substr(x,p1,p2)  returns p2 characters of x[] beginning with p1.
** p1 is 1-indexed.  So substr(x,1,1) returns the first character
** of x.  If x is text, then we actually count UTF-8 characters.
** If x is a blob, then we count bytes.
**
** If p1 is negative, then we begin abs(p1) from the end of x[].
**
** If p2 is negative, return the p2 characters preceding p1.
*/
static void substrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z;
  const unsigned char *z2;
  int len;
  int p0type;
  i64 p1, p2;
  int negP2 = 0;

  assert( argc==3 || argc==2 );
  if( sqlite3_value_type(argv[1])==SQLITE_NULL
   || (argc==3 && sqlite3_value_type(argv[2])==SQLITE_NULL)
  ){
    return;
  }
  p0type = sqlite3_value_type(argv[0]);
  p1 = sqlite3_value_int(argv[1]);
  
// ABS Label 143
if(p0type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}

// ROR Label 144
if((p0type != 4) != (p0type == 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
if( p0type==SQLITE_BLOB ){
    len = sqlite3_value_bytes(argv[0]);
    z = sqlite3_value_blob(argv[0]);
    
// ABS Label 145
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}

// ROR Label 146
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 146);
}
if( z==0 ) { return;
}
    assert( len==sqlite3_value_bytes(argv[0]) );
  }else{
    z = sqlite3_value_text(argv[0]);
    
// ABS Label 147
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}

// ROR Label 148
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 148);
}
if( z==0 ) { return;
}
    len = 0;
    
// ABS Label 149
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}

// ROR Label 150
if((p1 <= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 150);
}
// ROR Label 151
if((p1 > 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 151);
}
// ROR Label 152
if((p1 >= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
if( p1<0 ){
      z2 = z;

// ABS Label 153
if(*z2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}
for(; *z2; len++){
        SQLITE_SKIP_UTF8(z2);
      };
// ABS Label 154
if(*z2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}

    }
  }
#ifdef SQLITE_SUBSTR_COMPATIBILITY
  /* If SUBSTR_COMPATIBILITY is defined then substr(X,0,N) work the same as
  ** as substr(X,1,N) - it returns the first N characters of X.  This
  ** is essentially a back-out of the bug-fix in check-in [5fc125d362df4b8]
  ** from 2009-02-02 for compatibility of applications that exploited the
  ** old buggy behavior. */
  if( p1==0 ) p1 = 1; /* <rdar://problem/6778339> */
#endif
  
// ABS Label 157
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}

// ROR Label 158
if((argc != 3) != (argc == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 158);
}
if( argc==3 ){
    p2 = sqlite3_value_int(argv[2]);
    
// ABS Label 159
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}

// ROR Label 160
if((p2 <= 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((p2 > 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((p2 >= 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
if( p2<0 ){
      p2 = -p2;
      negP2 = 1;
    }
  }else{
    p2 = sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH];
  }
  
// ABS Label 163
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ROR Label 164
if((p1 <= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
// ROR Label 165
if((p1 > 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((p1 >= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
if( p1<0 ){
    p1 += len;
    
// ABS Label 167
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}

// ROR Label 168
if((p1 <= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
// ROR Label 169
if((p1 > 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}
// ROR Label 170
if((p1 >= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 170);
}
if( p1<0 ){
      p2 += p1;
      
// ABS Label 171
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}

// ROR Label 172
if((p2 <= 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 172);
}
// ROR Label 173
if((p2 > 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
// ROR Label 174
if((p2 >= 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
if( p2<0 ) { p2 = 0;
}
      p1 = 0;
    }
  }else { 
// ABS Label 175
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}

// ROR Label 176
if((p1 <= 0) != (p1 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}
// ROR Label 177
if((p1 < 0) != (p1 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 177);
}
// ROR Label 178
if((p1 >= 0) != (p1 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}
if( p1>0 ){
    p1--;
  }else { 
// ABS Label 179
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}

// ROR Label 180
if((p2 <= 0) != (p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 180);
}
// ROR Label 181
if((p2 < 0) != (p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 181);
}
// ROR Label 182
if((p2 >= 0) != (p2 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 182);
}
if( p2>0 ){
    p2--;
  };}
;}

  
// ABS Label 183
if(negP2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}
if( negP2 ){
    p1 -= p2;
    
// ABS Label 184
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}

// ROR Label 185
if((p1 <= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
// ROR Label 186
if((p1 > 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 186);
}
// ROR Label 187
if((p1 >= 0) != (p1 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
if( p1<0 ){
      p2 += p1;
      p1 = 0;
    }
  }
  assert( p1>=0 && p2>=0 );
  
// ABS Label 188
if(p0type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// ROR Label 189
if((p0type == 4) != (p0type != 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
if( p0type!=SQLITE_BLOB ){
    
// ABS Label 191
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// COR Label 192
if((*z || p1) != (*z && p1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 192);
}

// MCC Label 193
if(*z && p1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 193);
}
// MCC Label 194
if(*z && !(p1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(!(*z) && p1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(!(*z) && !(p1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
while( *z && p1 ){
      SQLITE_SKIP_UTF8(z);
      p1--;
    };
// ABS Label 197
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}

// COR Label 198
if((*z || p1) != (*z && p1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 198);
}

// MCC Label 199
if(*z && p1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 199);
}
// MCC Label 200
if(*z && !(p1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 200);
}
// MCC Label 201
if(!(*z) && p1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 201);
}
// MCC Label 202
if(!(*z) && !(p1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}

    z2 = z;

// ABS Label 205
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}

// COR Label 206
if((*z2 || p2) != (*z2 && p2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 206);
}

// MCC Label 207
if(*z2 && p2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 207);
}
// MCC Label 208
if(*z2 && !(p2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 208);
}
// MCC Label 209
if(!(*z2) && p2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 209);
}
// MCC Label 210
if(!(*z2) && !(p2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
for(; *z2 && p2; p2--){
      SQLITE_SKIP_UTF8(z2);
    };
// ABS Label 211
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}

// COR Label 212
if((*z2 || p2) != (*z2 && p2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 212);
}

// MCC Label 213
if(*z2 && p2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 213);
}
// MCC Label 214
if(*z2 && !(p2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 214);
}
// MCC Label 215
if(!(*z2) && p2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 215);
}
// MCC Label 216
if(!(*z2) && !(p2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 216);
}

    
// ABS Label 190
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
sqlite3_result_text64(context, (char*)z, z2-z, SQLITE_TRANSIENT,
                          SQLITE_UTF8);
  }else{
    
// ABS Label 220
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
// ABS Label 221
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}

// AOR Label 222
if(p1 - p2 != p1 + p2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 222);
}
// AOR Label 223
if(p1 / p2 != p1 + p2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 223);
}
// AOR Label 224
if(p1 * p2 != p1 + p2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 224);
}

// ROR Label 225
if((p1 + p2 <= len) != (p1 + p2 > len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 225);
}
// ROR Label 226
if((p1 + p2 < len) != (p1 + p2 > len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 226);
}
// ROR Label 227
if((p1 + p2 >= len) != (p1 + p2 > len))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 227);
}
if( p1+p2>len ){
      p2 = len-p1;
      
// ABS Label 228
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}

// ROR Label 229
if((p2 <= 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 229);
}
// ROR Label 230
if((p2 > 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 230);
}
// ROR Label 231
if((p2 >= 0) != (p2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 231);
}
if( p2<0 ) { p2 = 0;
}
    }
    
// ABS Label 219
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}
sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, SQLITE_TRANSIENT);
  }
}

/*
** Implementation of the round() function
*/
#ifndef SQLITE_OMIT_FLOATING_POINT
static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  int n = 0;
  double r;
  char *zBuf;
  assert( argc==1 || argc==2 );
  
// ABS Label 234
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 234);
}

// ROR Label 235
if((argc != 2) != (argc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 235);
}
if( argc==2 ){
    if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) { return;
}
    n = sqlite3_value_int(argv[1]);
    
// ABS Label 236
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}

// ROR Label 237
if((n <= 30) != (n > 30))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
// ROR Label 238
if((n < 30) != (n > 30))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
// ROR Label 239
if((n >= 30) != (n > 30))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 239);
}
if( n>30 ) { n = 30;
}
    
// ABS Label 240
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 240);
}

// ROR Label 241
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
// ROR Label 243
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
if( n<0 ) { n = 0;
}
  }
  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) { return;
}
  r = sqlite3_value_double(argv[0]);
  /* If Y==0 and X will fit in a 64-bit int,
  ** handle the rounding directly,
  ** otherwise use printf.
  */
  
// ABS Label 244
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// COR Label 245
if((r < -4503599627370496. && r > +4503599627370496.) != (r < -4503599627370496. || r > +4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 245);
}

// ROR Label 246
if((r <= -4503599627370496.) != (r < -4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
// ROR Label 247
if((r > -4503599627370496.) != (r < -4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 247);
}
// ROR Label 248
if((r >= -4503599627370496.) != (r < -4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 248);
}
// ROR Label 249
if((r <= +4503599627370496.) != (r > +4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 249);
}
// ROR Label 250
if((r < +4503599627370496.) != (r > +4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((r >= +4503599627370496.) != (r > +4503599627370496.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}

// MCC Label 252
if(r < -4503599627370496. && r > +4503599627370496. ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 252);
}
// MCC Label 253
if(r < -4503599627370496. && !(r > +4503599627370496.) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 253);
}
// MCC Label 254
if(!(r < -4503599627370496.) && r > +4503599627370496. ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 254);
}
// MCC Label 255
if(!(r < -4503599627370496.) && !(r > +4503599627370496.) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
if( r<-4503599627370496.0 || r>+4503599627370496.0 ){
    /* The value has no fractional part so there is nothing to round */
  }else { 
// ABS Label 256
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ROR Label 257
if((n != 0) != (n == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
if( n==0 ){  
    r = (double)((sqlite_int64)(r+(r<0?-0.5:+0.5)));
  }else{
    zBuf = sqlite3_mprintf("%.*f",n,r);
    
// ABS Label 258
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// ROR Label 259
if((zBuf != 0) != (zBuf == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}
if( zBuf==0 ){
      
// ABS Label 260
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 260);
}
sqlite3_result_error_nomem(context);
      return;
    }
    sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), SQLITE_UTF8);
    sqlite3_free(zBuf);
  };}

  
// ABS Label 232
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}

// ABS Label 233
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 233);
}
sqlite3_result_double(context, r);
}
#endif

/*
** Allocate nByte bytes of space using sqlite3Malloc(). If the
** allocation fails, call sqlite3_result_error_nomem() to notify
** the database handle that malloc() has failed and return NULL.
** If nByte is larger than the maximum string or blob length, then
** raise an SQLITE_TOOBIG exception and return NULL.
*/
static void *contextMalloc(sqlite3_context *context, i64 nByte){
  char *z;
  sqlite3 *db = sqlite3_context_db_handle(context);
  assert( nByte>0 );
  testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH] );
  testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH]+1 );
  
// ABS Label 261
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 261);
}

// ROR Label 262
if((nByte <= db->aLimit[0]) != (nByte > db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((nByte < db->aLimit[0]) != (nByte > db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}
// ROR Label 264
if((nByte >= db->aLimit[0]) != (nByte > db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}
if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){
    
// ABS Label 265
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}
sqlite3_result_error_toobig(context);
    z = 0;
  }else{
    z = sqlite3Malloc(nByte);
    if( !z ){
      
// ABS Label 266
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 266);
}
sqlite3_result_error_nomem(context);
    }
  }
  return z;
}

/*
** Implementation of the upper() and lower() SQL functions.
*/
static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  UNUSED_PARAMETER(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);
  /* Verify that the call to _bytes() does not invalidate the _text() pointer */
  assert( z2==(char*)sqlite3_value_text(argv[0]) );
  
// ABS Label 267
if(z2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 267);
}
if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    
// ABS Label 268
if(z1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}
if( z1 ){
      i = 0;

// ABS Label 271
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
// ABS Label 272
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}

// ROR Label 273
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
// ROR Label 274
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 274);
}
// ROR Label 275
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 275);
}
for(; i<n; i++){
        z1[i] = (char)sqlite3Toupper(z2[i]);
      };
// ABS Label 276
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
// ABS Label 277
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}

// ROR Label 278
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 278);
}
// ROR Label 279
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}

      
// ABS Label 269
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}

// ABS Label 270
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
sqlite3_result_text(context, z1, n, sqlite3_free);
    }
  }
}
static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  UNUSED_PARAMETER(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);
  /* Verify that the call to _bytes() does not invalidate the _text() pointer */
  assert( z2==(char*)sqlite3_value_text(argv[0]) );
  
// ABS Label 281
if(z2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}
if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    
// ABS Label 282
if(z1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
if( z1 ){
      i = 0;

// ABS Label 285
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
// ABS Label 286
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ROR Label 287
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
// ROR Label 288
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
// ROR Label 289
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}
for(; i<n; i++){
        z1[i] = sqlite3Tolower(z2[i]);
      };
// ABS Label 290
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}
// ABS Label 291
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ROR Label 292
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}
// ROR Label 293
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 293);
}
// ROR Label 294
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}

      
// ABS Label 283
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ABS Label 284
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}
sqlite3_result_text(context, z1, n, sqlite3_free);
    }
  }
}

/*
** Some functions like COALESCE() and IFNULL() and UNLIKELY() are implemented
** as VDBE code so that unused argument values do not have to be computed.
** However, we still need some kind of function implementation for this
** routines in the function table.  The noopFunc macro provides this.
** noopFunc will never be called so it doesn't matter what the implementation
** is.  We might as well use the "version()" function as a substitute.
*/
#define noopFunc versionFunc   /* Substitute function - never called */

/*
** Implementation of random().  Return a random integer.  
*/
static void randomFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite_int64 r;
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  sqlite3_randomness(sizeof(r), &r);
  
// ABS Label 297
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ROR Label 298
if((r <= 0) != (r < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
// ROR Label 299
if((r > 0) != (r < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 299);
}
// ROR Label 300
if((r >= 0) != (r < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
if( r<0 ){
    /* We need to prevent a random number of 0x8000000000000000 
    ** (or -9223372036854775808) since when you do abs() of that
    ** number of you get the same value back again.  To do this
    ** in a way that is testable, mask the sign bit off of negative
    ** values, resulting in a positive value.  Then take the 
    ** 2s complement of that positive value.  The end result can
    ** therefore be no less than -9223372036854775807.
    */
    r = -(r & LARGEST_INT64);
  }
  
// ABS Label 295
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ABS Label 296
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
sqlite3_result_int64(context, r);
}

/*
** Implementation of randomblob(N).  Return a random blob
** that is N bytes long.
*/
static void randomBlob(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite3_int64 n;
  unsigned char *p;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  n = sqlite3_value_int64(argv[0]);
  
// ABS Label 301
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ROR Label 302
if((n <= 1) != (n < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}
// ROR Label 303
if((n > 1) != (n < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 303);
}
// ROR Label 304
if((n >= 1) != (n < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
if( n<1 ){
    n = 1;
  }
  p = contextMalloc(context, n);
  
// ABS Label 305
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
if( p ){
    sqlite3_randomness(n, p);
    
// ABS Label 306
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
sqlite3_result_blob(context, (char*)p, n, sqlite3_free);
  }
}

/*
** Implementation of the last_insert_rowid() SQL function.  The return
** value is the same as the sqlite3_last_insert_rowid() API function.
*/
static void last_insert_rowid(
  sqlite3_context *context, 
  int NotUsed, 
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  /* IMP: R-51513-12026 The last_insert_rowid() SQL function is a
  ** wrapper around the sqlite3_last_insert_rowid() C/C++ interface
  ** function. */
  
// ABS Label 307
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));
}

/*
** Implementation of the changes() SQL function.
**
** IMP: R-62073-11209 The changes() SQL function is a wrapper
** around the sqlite3_changes64() C/C++ function and hence follows the same
** rules for counting changes.
*/
static void changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  
// ABS Label 308
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}
sqlite3_result_int64(context, sqlite3_changes64(db));
}

/*
** Implementation of the total_changes() SQL function.  The return value is
** the same as the sqlite3_total_changes64() API function.
*/
static void total_changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  /* IMP: R-52756-41993 This function was a wrapper around the
  ** sqlite3_total_changes() C/C++ interface. */
  
// ABS Label 309
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}
sqlite3_result_int64(context, sqlite3_total_changes64(db));
}

/*
** A structure defining how to do GLOB-style comparisons.
*/
struct compareInfo {
  u8 matchAll;          /* "*" or "%" */
  u8 matchOne;          /* "?" or "_" */
  u8 matchSet;          /* "[" or 0 */
  u8 noCase;            /* true to ignore case differences */
};

/*
** For LIKE and GLOB matching on EBCDIC machines, assume that every
** character is exactly one byte in size.  Also, provde the Utf8Read()
** macro for fast reading of the next character in the common case where
** the next character is ASCII.
*/
#if defined(SQLITE_EBCDIC)
# define sqlite3Utf8Read(A)        (*((*A)++))
# define Utf8Read(A)               (*(A++))
#else
# define Utf8Read(A)               (A[0]<0x80?*(A++):sqlite3Utf8Read(&A))
#endif

static const struct compareInfo globInfo = { '*', '?', '[', 0 };
/* The correct SQL-92 behavior is for the LIKE operator to ignore
** case.  Thus  'a' LIKE 'A' would be true. */
static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };
/* If SQLITE_CASE_SENSITIVE_LIKE is defined, then the LIKE operator
** is case sensitive causing 'a' LIKE 'A' to be false */
static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };

/*
** Possible error returns from patternMatch()
*/
#define SQLITE_MATCH             0
#define SQLITE_NOMATCH           1
#define SQLITE_NOWILDCARDMATCH   2

/*
** Compare two UTF-8 strings for equality where the first string is
** a GLOB or LIKE expression.  Return values:
**
**    SQLITE_MATCH:            Match
**    SQLITE_NOMATCH:          No match
**    SQLITE_NOWILDCARDMATCH:  No match in spite of having * or % wildcards.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
** With the [...] and [^...] matching, a ']' character can be included
** in the list by making it the first character after '[' or '^'.  A
** range of characters can be specified using '-'.  Example:
** "[a-z]" matches any single lower-case letter.  To match a '-', make
** it the last character in the list.
**
** Like matching rules:
** 
**      '%'       Matches any sequence of zero or more characters
**
***     '_'       Matches any one character
**
**      Ec        Where E is the "esc" character and c is any other
**                character, including '%', '_', and esc, match exactly c.
**
** The comments within this routine usually assume glob matching.
**
** This routine is usually quick, but can be N**2 in the worst case.
*/
static int patternCompare(
  const u8 *zPattern,              /* The glob pattern */
  const u8 *zString,               /* The string to compare against the glob */
  const struct compareInfo *pInfo, /* Information about how to do the compare */
  u32 matchOther                   /* The escape char (LIKE) or '[' (GLOB) */
){
  u32 c, c2;                       /* Next pattern and input string chars */
  u32 matchOne = pInfo->matchOne;  /* "?" or "_" */
  u32 matchAll = pInfo->matchAll;  /* "*" or "%" */
  
// ABS Label 310
if(pInfo->noCase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}
u8 noCase = pInfo->noCase;       /* True if uppercase==lowercase */
  const u8 *zEscaped = 0;          /* One past the last escaped input char */
  
  while( (c = Utf8Read(zPattern))!=0 ){
    
// ABS Label 311
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}
// ABS Label 312
if(matchAll < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}

// ROR Label 313
if((c != matchAll) != (c == matchAll))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 313);
}
if( c==matchAll ){  /* Match "*" */
      /* Skip over multiple "*" characters in the pattern.  If there
      ** are also "?" characters, skip those as well, but consume a
      ** single character of the input string for each "?" skipped */
      while( (c=Utf8Read(zPattern)) == matchAll 
             || (c == matchOne && matchOne!=0) ){
        if( c==matchOne && sqlite3Utf8Read(&zString)==0 ){
          return SQLITE_NOWILDCARDMATCH;
        }
      };
      
// ABS Label 314
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}

// ROR Label 315
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}
if( c==0 ){
        return SQLITE_MATCH;   /* "*" at the end of the pattern matches */
      }else { 
// ABS Label 316
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
// ABS Label 317
if(matchOther < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}

// ROR Label 318
if((c != matchOther) != (c == matchOther))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
if( c==matchOther ){
        
// ROR Label 319
if((pInfo->matchSet != 0) != (pInfo->matchSet == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 319);
}
if( pInfo->matchSet==0 ){
          c = sqlite3Utf8Read(&zPattern);
          
// ABS Label 320
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}

// ROR Label 321
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 321);
}
if( c==0 ) { return SQLITE_NOWILDCARDMATCH;
}
        }else{
          /* "[...]" immediately follows the "*".  We have to do a slow
          ** recursive search in this case, but it is an unusual case. */
          assert( matchOther<0x80 );  /* '[' is a single-byte character */
          
// ABS Label 322
if(*zString < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
while( *zString ){
            int bMatch = patternCompare(&zPattern[-1],zString,pInfo,matchOther);
            
// ABS Label 324
if(bMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ROR Label 325
if((bMatch == 1) != (bMatch != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 325);
}
if( bMatch!=SQLITE_NOMATCH ) { 
// ABS Label 326
if(bMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
return bMatch;
}
            SQLITE_SKIP_UTF8(zString);
          };
// ABS Label 323
if(*zString < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}

          return SQLITE_NOWILDCARDMATCH;
        }
      };}


      /* At this point variable c contains the first character of the
      ** pattern string past the "*".  Search in the input string for the
      ** first matching character and recursively continue the match from
      ** that point.
      **
      ** For a case-insensitive search, set variable cx to be the same as
      ** c but in the other case and search the input string for either
      ** c or cx.
      */
      
// ABS Label 329
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}

// ROR Label 330
if((c < 128) != (c <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 330);
}
// ROR Label 331
if((c > 128) != (c <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 331);
}
// ROR Label 332
if((c >= 128) != (c <= 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 332);
}
if( c<=0x80 ){
        char zStop[3];
        int bMatch;
        
// ABS Label 333
if(noCase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}
if( noCase ){
          zStop[0] = sqlite3Toupper(c);
          zStop[1] = sqlite3Tolower(c);
          zStop[2] = 0;
        }else{
          zStop[0] = c;
          zStop[1] = 0;
        }
        while(1){
          zString += strcspn((const char*)zString, zStop);
          
// ROR Label 334
if((zString[0] != 0) != (zString[0] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
if( zString[0]==0 ) { break;
}
          zString++;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          
// ABS Label 335
if(bMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}

// ROR Label 336
if((bMatch == 1) != (bMatch != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 336);
}
if( bMatch!=SQLITE_NOMATCH ) { 
// ABS Label 337
if(bMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
return bMatch;
}
        };
      }else{
        int bMatch;
        while( (c2 = Utf8Read(zString))!=0 ){
          
// ABS Label 338
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
// ABS Label 339
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}

// ROR Label 340
if((c2 == c) != (c2 != c))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 340);
}
if( c2!=c ) { continue;
}
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          
// ABS Label 341
if(bMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}

// ROR Label 342
if((bMatch == 1) != (bMatch != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}
if( bMatch!=SQLITE_NOMATCH ) { 
// ABS Label 343
if(bMatch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}
return bMatch;
}
        };
      }
      return SQLITE_NOWILDCARDMATCH;
    }
    
// ABS Label 344
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
// ABS Label 345
if(matchOther < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}

// ROR Label 346
if((c != matchOther) != (c == matchOther))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 346);
}
if( c==matchOther ){
      
// ROR Label 347
if((pInfo->matchSet != 0) != (pInfo->matchSet == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 347);
}
if( pInfo->matchSet==0 ){
        c = sqlite3Utf8Read(&zPattern);
        
// ABS Label 348
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}

// ROR Label 349
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 349);
}
if( c==0 ) { return SQLITE_NOMATCH;
}
        zEscaped = zPattern;
      }else{
        u32 prior_c = 0;
        int seen = 0;
        int invert = 0;
        c = sqlite3Utf8Read(&zString);
        
// ABS Label 350
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}

// ROR Label 351
if((c != 0) != (c == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 351);
}
if( c==0 ) { return SQLITE_NOMATCH;
}
        c2 = sqlite3Utf8Read(&zPattern);
        
// ABS Label 352
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 352);
}

// ROR Label 353
if((c2 != '^') != (c2 == '^'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 353);
}
if( c2=='^' ){
          invert = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        
// ABS Label 354
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}

// ROR Label 355
if((c2 != ']') != (c2 == ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}
if( c2==']' ){
          
// ABS Label 356
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ROR Label 357
if((c != ']') != (c == ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}
if( c==']' ) { seen = 1;
}
          c2 = sqlite3Utf8Read(&zPattern);
        }
        
// ABS Label 358
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}

// COR Label 359
if((c2 || c2 != ']') != (c2 && c2 != ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 359);
}

// ROR Label 360
if((c2 == ']') != (c2 != ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 360);
}

// MCC Label 361
if(c2 && c2 != ']' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
// MCC Label 362
if(c2 && !(c2 != ']') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 362);
}
// MCC Label 363
if(!(c2) && c2 != ']' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
// MCC Label 364
if(!(c2) && !(c2 != ']') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 364);
}
while( c2 && c2!=']' ){
          
// ABS Label 372
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}
// ABS Label 373
if(prior_c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// COR Label 374
if((c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 || prior_c > 0) != (c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 && prior_c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 374);
}
// COR Label 375
if((c2 == '-' && zPattern[0] != ']' || zPattern[0] != 0) != (c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 375);
}
// COR Label 376
if((c2 == '-' || zPattern[0] != ']') != (c2 == '-' && zPattern[0] != ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 376);
}

// ROR Label 377
if((c2 != '-') != (c2 == '-'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((zPattern[0] == ']') != (zPattern[0] != ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
// ROR Label 379
if((zPattern[0] == 0) != (zPattern[0] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 379);
}
// ROR Label 380
if((prior_c <= 0) != (prior_c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 380);
}
// ROR Label 381
if((prior_c < 0) != (prior_c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 381);
}
// ROR Label 382
if((prior_c >= 0) != (prior_c > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 382);
}

// MCC Label 383
if(c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
// MCC Label 385
if(c2 == '-' && zPattern[0] != ']' && !(zPattern[0] != 0) && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
// MCC Label 386
if(c2 == '-' && zPattern[0] != ']' && !(zPattern[0] != 0) && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 386);
}
// MCC Label 387
if(c2 == '-' && !(zPattern[0] != ']') && zPattern[0] != 0 && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 387);
}
// MCC Label 388
if(c2 == '-' && !(zPattern[0] != ']') && zPattern[0] != 0 && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 388);
}
// MCC Label 389
if(c2 == '-' && !(zPattern[0] != ']') && !(zPattern[0] != 0) && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 389);
}
// MCC Label 390
if(c2 == '-' && !(zPattern[0] != ']') && !(zPattern[0] != 0) && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 390);
}
// MCC Label 391
if(!(c2 == '-') && zPattern[0] != ']' && zPattern[0] != 0 && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 391);
}
// MCC Label 392
if(!(c2 == '-') && zPattern[0] != ']' && zPattern[0] != 0 && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 392);
}
// MCC Label 393
if(!(c2 == '-') && zPattern[0] != ']' && !(zPattern[0] != 0) && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 393);
}
// MCC Label 394
if(!(c2 == '-') && zPattern[0] != ']' && !(zPattern[0] != 0) && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 394);
}
// MCC Label 395
if(!(c2 == '-') && !(zPattern[0] != ']') && zPattern[0] != 0 && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 395);
}
// MCC Label 396
if(!(c2 == '-') && !(zPattern[0] != ']') && zPattern[0] != 0 && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 396);
}
// MCC Label 397
if(!(c2 == '-') && !(zPattern[0] != ']') && !(zPattern[0] != 0) && prior_c > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 397);
}
// MCC Label 398
if(!(c2 == '-') && !(zPattern[0] != ']') && !(zPattern[0] != 0) && !(prior_c > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 398);
}
if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){
            c2 = sqlite3Utf8Read(&zPattern);
            
// ABS Label 399
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}
// ABS Label 400
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
// ABS Label 401
if(prior_c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}

// COR Label 402
if((c >= prior_c || c <= c2) != (c >= prior_c && c <= c2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 402);
}

// ROR Label 403
if((c < prior_c) != (c >= prior_c))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
// ROR Label 404
if((c > prior_c) != (c >= prior_c))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 404);
}
// ROR Label 405
if((c <= prior_c) != (c >= prior_c))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 405);
}
// ROR Label 406
if((c < c2) != (c <= c2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 406);
}
// ROR Label 407
if((c > c2) != (c <= c2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 407);
}
// ROR Label 408
if((c >= c2) != (c <= c2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}

// MCC Label 409
if(c >= prior_c && c <= c2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 409);
}
// MCC Label 410
if(c >= prior_c && !(c <= c2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 410);
}
// MCC Label 411
if(!(c >= prior_c) && c <= c2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 411);
}
// MCC Label 412
if(!(c >= prior_c) && !(c <= c2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 412);
}
if( c>=prior_c && c<=c2 ) { seen = 1;
}
            prior_c = 0;
          }else{
            
// ABS Label 413
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
// ABS Label 414
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// ROR Label 415
if((c != c2) != (c == c2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 415);
}
if( c==c2 ){
              seen = 1;
            }
            prior_c = c2;
          }
          c2 = sqlite3Utf8Read(&zPattern);
        };
// ABS Label 365
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}

// COR Label 366
if((c2 || c2 != ']') != (c2 && c2 != ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 366);
}

// ROR Label 367
if((c2 == ']') != (c2 != ']'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}

// MCC Label 368
if(c2 && c2 != ']' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
// MCC Label 369
if(c2 && !(c2 != ']') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 369);
}
// MCC Label 370
if(!(c2) && c2 != ']' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(!(c2) && !(c2 != ']') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}

        
// ABS Label 416
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}

// COR Label 417
if((c2 == 0 && (seen ^ invert) == 0) != (c2 == 0 || (seen ^ invert) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 417);
}

// ROR Label 418
if((c2 != 0) != (c2 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 418);
}
// ROR Label 419
if(((seen ^ invert) != 0) != ((seen ^ invert) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}

// MCC Label 420
if(c2 == 0 && (seen ^ invert) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 420);
}
// MCC Label 421
if(c2 == 0 && !((seen ^ invert) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 421);
}
// MCC Label 422
if(!(c2 == 0) && (seen ^ invert) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 422);
}
// MCC Label 423
if(!(c2 == 0) && !((seen ^ invert) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 423);
}
if( c2==0 || (seen ^ invert)==0 ){
          return SQLITE_NOMATCH;
        }
        continue;
      }
    }
    c2 = Utf8Read(zString);
    
// ABS Label 424
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}
// ABS Label 425
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}

// ROR Label 426
if((c != c2) != (c == c2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 426);
}
if( c==c2 ) { continue;
}
    
// ABS Label 427
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}
// ABS Label 428
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// COR Label 429
if((noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128 || c2 < 128) != (noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128 && c2 < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 429);
}
// COR Label 430
if((noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) || c < 128) != (noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 430);
}
// COR Label 431
if((noCase || (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) != (noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 431);
}

// ROR Label 432
if(((sqlite3UpperToLower[(unsigned char)(c)]) != (sqlite3UpperToLower[(unsigned char)(c2)])) != ((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 432);
}
// ROR Label 433
if((c <= 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 433);
}
// ROR Label 434
if((c > 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 434);
}
// ROR Label 435
if((c >= 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 435);
}
// ROR Label 436
if((c2 <= 128) != (c2 < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((c2 > 128) != (c2 < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
// ROR Label 438
if((c2 >= 128) != (c2 < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}

// MCC Label 439
if(noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128 && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 439);
}
// MCC Label 440
if(noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128 && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && !(c < 128) && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(noCase && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && !(c < 128) && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(noCase && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && c < 128 && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}
// MCC Label 444
if(noCase && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && c < 128 && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 444);
}
// MCC Label 445
if(noCase && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && !(c < 128) && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 445);
}
// MCC Label 446
if(noCase && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && !(c < 128) && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 446);
}
// MCC Label 447
if(!(noCase) && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128 && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 447);
}
// MCC Label 448
if(!(noCase) && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && c < 128 && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 448);
}
// MCC Label 449
if(!(noCase) && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && !(c < 128) && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 449);
}
// MCC Label 450
if(!(noCase) && (sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)]) && !(c < 128) && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 450);
}
// MCC Label 451
if(!(noCase) && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && c < 128 && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 451);
}
// MCC Label 452
if(!(noCase) && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && c < 128 && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 452);
}
// MCC Label 453
if(!(noCase) && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && !(c < 128) && c2 < 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 453);
}
// MCC Label 454
if(!(noCase) && !((sqlite3UpperToLower[(unsigned char)(c)]) == (sqlite3UpperToLower[(unsigned char)(c2)])) && !(c < 128) && !(c2 < 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 454);
}
if( noCase  && sqlite3Tolower(c)==sqlite3Tolower(c2) && c<0x80 && c2<0x80 ){
      continue;
    }
    
// ABS Label 455
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}
// ABS Label 456
if(c2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 456);
}
// ABS Label 457
if(matchOne < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
// ABS Label 458
if(zEscaped < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
// ABS Label 459
if(zPattern < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// COR Label 460
if((c == matchOne && zPattern != zEscaped || c2 != 0) != (c == matchOne && zPattern != zEscaped && c2 != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 460);
}
// COR Label 461
if((c == matchOne || zPattern != zEscaped) != (c == matchOne && zPattern != zEscaped))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 461);
}

// ROR Label 462
if((c != matchOne) != (c == matchOne))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
// ROR Label 463
if((zPattern == zEscaped) != (zPattern != zEscaped))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 463);
}
// ROR Label 464
if((c2 == 0) != (c2 != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 464);
}

// MCC Label 465
if(c == matchOne && zPattern != zEscaped && c2 != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 465);
}
// MCC Label 466
if(c == matchOne && zPattern != zEscaped && !(c2 != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 466);
}
// MCC Label 467
if(c == matchOne && !(zPattern != zEscaped) && c2 != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 467);
}
// MCC Label 468
if(c == matchOne && !(zPattern != zEscaped) && !(c2 != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 468);
}
// MCC Label 469
if(!(c == matchOne) && zPattern != zEscaped && c2 != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 469);
}
// MCC Label 470
if(!(c == matchOne) && zPattern != zEscaped && !(c2 != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 470);
}
// MCC Label 471
if(!(c == matchOne) && !(zPattern != zEscaped) && c2 != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 471);
}
// MCC Label 472
if(!(c == matchOne) && !(zPattern != zEscaped) && !(c2 != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 472);
}
if( c==matchOne && zPattern!=zEscaped && c2!=0 ) { continue;
}
    return SQLITE_NOMATCH;
  };
  return *zString==0 ? SQLITE_MATCH : SQLITE_NOMATCH;
}

/*
** The sqlite3_strglob() interface.  Return 0 on a match (like strcmp()) and
** non-zero if there is no match.
*/
int sqlite3_strglob(const char *zGlobPattern, const char *zString){
  return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');
}

/*
** The sqlite3_strlike() interface.  Return 0 on a match and non-zero for
** a miss - like strcmp().
*/
int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc){
  return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);
}

/*
** Count the number of times that the LIKE operator (or GLOB which is
** just a variation of LIKE) gets called.  This is used for testing
** only.
*/
#ifdef SQLITE_TEST
int sqlite3_like_count = 0;
#endif


/*
** Implementation of the like() SQL function.  This function implements
** the build-in LIKE operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A LIKE B
**
** is implemented as like(B,A).
**
** This same function (with a different compareInfo structure) computes
** the GLOB operator.
*/
static void likeFunc(
  sqlite3_context *context, 
  int argc, 
  sqlite3_value **argv
){
  const unsigned char *zA, *zB;
  u32 escape;
  int nPat;
  sqlite3 *db = sqlite3_context_db_handle(context);
  struct compareInfo *pInfo = sqlite3_user_data(context);
  struct compareInfo backupInfo;

#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
  if( sqlite3_value_type(argv[0])==SQLITE_BLOB
   || sqlite3_value_type(argv[1])==SQLITE_BLOB
  ){
#ifdef SQLITE_TEST
    sqlite3_like_count++;
#endif
    sqlite3_result_int(context, 0);
    return;
  }
#endif

  /* Limit the length of the LIKE or GLOB pattern to avoid problems
  ** of deep recursion and N*N behavior in patternCompare().
  */
  nPat = sqlite3_value_bytes(argv[0]);
  testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] );
  testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]+1 );
  
// ABS Label 473
if(db->aLimit[8] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}
// ABS Label 474
if(nPat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}

// ROR Label 475
if((nPat <= db->aLimit[8]) != (nPat > db->aLimit[8]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 475);
}
// ROR Label 476
if((nPat < db->aLimit[8]) != (nPat > db->aLimit[8]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 476);
}
// ROR Label 477
if((nPat >= db->aLimit[8]) != (nPat > db->aLimit[8]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 477);
}
if( nPat > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){
    
// ABS Label 478
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}
sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
    return;
  }
  
// ABS Label 479
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// ROR Label 480
if((argc != 3) != (argc == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
if( argc==3 ){
    /* The escape character string must consist of a single UTF-8 character.
    ** Otherwise, return an error.
    */
    const unsigned char *zEsc = sqlite3_value_text(argv[2]);
    
// ABS Label 481
if(zEsc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}

// ROR Label 482
if((zEsc != 0) != (zEsc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 482);
}
if( zEsc==0 ) { return;
}
    if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){
      
// ABS Label 483
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}
sqlite3_result_error(context, 
          "ESCAPE expression must be a single character", -1);
      return;
    }
    escape = sqlite3Utf8Read(&zEsc);
    
// ABS Label 484
if(escape < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 484);
}

// COR Label 485
if((escape == pInfo->matchAll && escape == pInfo->matchOne) != (escape == pInfo->matchAll || escape == pInfo->matchOne))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 485);
}

// ROR Label 486
if((escape != pInfo->matchAll) != (escape == pInfo->matchAll))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 486);
}
// ROR Label 487
if((escape != pInfo->matchOne) != (escape == pInfo->matchOne))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 487);
}

// MCC Label 488
if(escape == pInfo->matchAll && escape == pInfo->matchOne ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 488);
}
// MCC Label 489
if(escape == pInfo->matchAll && !(escape == pInfo->matchOne) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 489);
}
// MCC Label 490
if(!(escape == pInfo->matchAll) && escape == pInfo->matchOne ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 490);
}
// MCC Label 491
if(!(escape == pInfo->matchAll) && !(escape == pInfo->matchOne) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 491);
}
if( escape==pInfo->matchAll || escape==pInfo->matchOne ){
      memcpy(&backupInfo, pInfo, sizeof(backupInfo));
      pInfo = &backupInfo;
      
// ABS Label 492
if(escape < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}

// ROR Label 493
if((escape != pInfo->matchAll) != (escape == pInfo->matchAll))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}
if( escape==pInfo->matchAll ) { pInfo->matchAll = 0;
}
      
// ABS Label 494
if(escape < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 494);
}

// ROR Label 495
if((escape != pInfo->matchOne) != (escape == pInfo->matchOne))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}
if( escape==pInfo->matchOne ) { pInfo->matchOne = 0;
}
    }
  }else{
    escape = pInfo->matchSet;
  }
  zB = sqlite3_value_text(argv[0]);
  zA = sqlite3_value_text(argv[1]);
  
// ABS Label 496
if(zA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 496);
}
// ABS Label 497
if(zB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// COR Label 498
if((zA || zB) != (zA && zB))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 498);
}

// MCC Label 499
if(zA && zB ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
// MCC Label 500
if(zA && !(zB) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 500);
}
// MCC Label 501
if(!(zA) && zB ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 501);
}
// MCC Label 502
if(!(zA) && !(zB) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 502);
}
if( zA && zB ){
#ifdef SQLITE_TEST
    sqlite3_like_count++;
#endif
    
// ABS Label 503
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 503);
}
sqlite3_result_int(context,
                      patternCompare(zB, zA, pInfo, escape)==SQLITE_MATCH);
  }
}

/*
** Implementation of the NULLIF(x,y) function.  The result is the first
** argument if the arguments are different.  The result is NULL if the
** arguments are equal to each other.
*/
static void nullifFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  CollSeq *pColl = sqlite3GetFuncCollSeq(context);
  UNUSED_PARAMETER(NotUsed);
  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){
    
// ABS Label 504
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}

// ABS Label 505
if(argv[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 505);
}
sqlite3_result_value(context, argv[0]);
  }
}

/*
** Implementation of the sqlite_version() function.  The result is the version
** of the SQLite library that is running.
*/
static void versionFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  /* IMP: R-48699-48617 This function is an SQL wrapper around the
  ** sqlite3_libversion() C-interface. */
  
// ABS Label 506
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 506);
}
sqlite3_result_text(context, sqlite3_libversion(), -1, SQLITE_STATIC);
}

/*
** Implementation of the sqlite_source_id() function. The result is a string
** that identifies the particular version of the source code used to build
** SQLite.
*/
static void sourceidFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  /* IMP: R-24470-31136 This function is an SQL wrapper around the
  ** sqlite3_sourceid() C interface. */
  
// ABS Label 507
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 507);
}
sqlite3_result_text(context, sqlite3_sourceid(), -1, SQLITE_STATIC);
}

/*
** Implementation of the sqlite_log() function.  This is a wrapper around
** sqlite3_log().  The return value is NULL.  The function exists purely for
** its side-effects.
*/
static void errlogFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  UNUSED_PARAMETER(argc);
  UNUSED_PARAMETER(context);
  sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1]));
}

/*
** Implementation of the sqlite_compileoption_used() function.
** The result is an integer that identifies if the compiler option
** was used to build SQLite.
*/
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
static void compileoptionusedFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zOptName;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  /* IMP: R-39564-36305 The sqlite_compileoption_used() SQL
  ** function is a wrapper around the sqlite3_compileoption_used() C/C++
  ** function.
  */
  if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    
// ABS Label 508
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}
sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));
  }
}
#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */

/*
** Implementation of the sqlite_compileoption_get() function. 
** The result is a string that identifies the compiler options 
** used to build SQLite.
*/
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
static void compileoptiongetFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  /* IMP: R-04922-24076 The sqlite_compileoption_get() SQL function
  ** is a wrapper around the sqlite3_compileoption_get() C/C++ function.
  */
  n = sqlite3_value_int(argv[0]);
  
// ABS Label 509
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}
sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, SQLITE_STATIC);
}
#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */

/* Array for converting from half-bytes (nybbles) into ASCII hex
** digits. */
static const char hexdigits[] = {
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' 
};

/*
** Implementation of the QUOTE() function.  This function takes a single
** argument.  If the argument is numeric, the return value is the same as
** the argument.  If the argument is NULL, the return value is the string
** "NULL".  Otherwise, the argument is enclosed in single quotes with
** single-quote escapes.
*/
static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case SQLITE_FLOAT: {
      double r1, r2;
      char zBuf[50];
      r1 = sqlite3_value_double(argv[0]);
      
// ABS Label 510
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}
sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.15g", r1);
      sqlite3AtoF(zBuf, &r2, 20, SQLITE_UTF8);
      
// ABS Label 512
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}
// ABS Label 513
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}

// ROR Label 514
if((r1 == r2) != (r1 != r2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 514);
}
if( r1!=r2 ){
        
// ABS Label 515
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}
sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.20e", r1);
      }
      
// ABS Label 511
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}
sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);
      break;
    }
    case SQLITE_INTEGER: {
      
// ABS Label 516
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}

// ABS Label 517
if(argv[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 517);
}
sqlite3_result_value(context, argv[0]);
      break;
    }
    case SQLITE_BLOB: {
      char *zText = 0;
      char const *zBlob = sqlite3_value_blob(argv[0]);
      int nBlob = sqlite3_value_bytes(argv[0]);
      assert( zBlob==sqlite3_value_blob(argv[0]) ); /* No encoding change */
      zText = (char *)contextMalloc(context, (2*(i64)nBlob)+4); 
      
// ABS Label 518
if(zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}
if( zText ){
        int i;
        i = 0;

// ABS Label 520
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 520);
}
// ABS Label 521
if(nBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 521);
}

// ROR Label 522
if((i <= nBlob) != (i < nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 522);
}
// ROR Label 523
if((i > nBlob) != (i < nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 523);
}
// ROR Label 524
if((i >= nBlob) != (i < nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
for(; i<nBlob; i++){
          zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];
          zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];
        };
// ABS Label 525
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}
// ABS Label 526
if(nBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// ROR Label 527
if((i <= nBlob) != (i < nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 527);
}
// ROR Label 528
if((i > nBlob) != (i < nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 528);
}
// ROR Label 529
if((i >= nBlob) != (i < nBlob))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 529);
}

        zText[(nBlob*2)+2] = '\'';
        zText[(nBlob*2)+3] = '\0';
        zText[0] = 'X';
        zText[1] = '\'';
        
// ABS Label 519
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 519);
}
sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);
        sqlite3_free(zText);
      }
      break;
    }
    case SQLITE_TEXT: {
      int i,j;
      u64 n;
      const unsigned char *zArg = sqlite3_value_text(argv[0]);
      char *z;

      
// ABS Label 530
if(zArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 530);
}

// ROR Label 531
if((zArg != 0) != (zArg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 531);
}
if( zArg==0 ) { return;
}
      i = 0 , n = 0;

// ABS Label 532
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 532);
}
// ABS Label 533
if(zArg[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}
for(; zArg[i]; i++){ 
// ROR Label 536
if((zArg[i] != '\'') != (zArg[i] == '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 536);
}
if( zArg[i]=='\'' ) { n++; 
}};
// ABS Label 534
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}
// ABS Label 535
if(zArg[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}

      z = contextMalloc(context, ((i64)i)+((i64)n)+3);
      
// ABS Label 537
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}
if( z ){
        z[0] = '\'';
        i = 0 , j = 1;

// ABS Label 540
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}
// ABS Label 541
if(zArg[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}
for(; zArg[i]; i++){
          z[j++] = zArg[i];
          
// ROR Label 544
if((zArg[i] != '\'') != (zArg[i] == '\''))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 544);
}
if( zArg[i]=='\'' ){
            z[j++] = '\'';
          }
        };
// ABS Label 542
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
// ABS Label 543
if(zArg[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}

        z[j++] = '\'';
        z[j] = 0;
        
// ABS Label 538
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 538);
}

// ABS Label 539
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 539);
}
sqlite3_result_text(context, z, j, sqlite3_free);
      }
      break;
    }
    default: {
      assert( sqlite3_value_type(argv[0])==SQLITE_NULL );
      
// ABS Label 545
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 545);
}
sqlite3_result_text(context, "NULL", 4, SQLITE_STATIC);
      break;
    }
  }
}

/*
** The unicode() function.  Return the integer unicode code-point value
** for the first character of the input string. 
*/
static void unicodeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z = sqlite3_value_text(argv[0]);
  (void)argc;
  
// ABS Label 546
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}

// COR Label 547
if((z || z[0]) != (z && z[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 547);
}

// MCC Label 548
if(z && z[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 548);
}
// MCC Label 549
if(z && !(z[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 549);
}
// MCC Label 550
if(!(z) && z[0] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 550);
}
// MCC Label 551
if(!(z) && !(z[0]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 551);
}
if( z && z[0] ) { 
// ABS Label 552
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}
sqlite3_result_int(context, sqlite3Utf8Read(&z));
}
}

/*
** The char() function takes zero or more arguments, each of which is
** an integer.  It constructs a string where each character of the string
** is the unicode character for the corresponding integer argument.
*/
static void charFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  unsigned char *z, *zOut;
  int i;
  zOut = z = sqlite3_malloc64( argc*4+1 );
  
// ABS Label 554
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 554);
}

// ROR Label 555
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}
if( z==0 ){
    
// ABS Label 556
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}
sqlite3_result_error_nomem(context);
    return;
  }
  i = 0;

// ABS Label 557
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}
// ABS Label 558
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// ROR Label 559
if((i <= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 559);
}
// ROR Label 560
if((i > argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 560);
}
// ROR Label 561
if((i >= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 561);
}
for(; i<argc; i++){
    sqlite3_int64 x;
    unsigned c;
    x = sqlite3_value_int64(argv[i]);
    
// ABS Label 567
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 567);
}

// COR Label 568
if((x < 0 && x > 1114111) != (x < 0 || x > 1114111))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 568);
}

// ROR Label 569
if((x <= 0) != (x < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 569);
}
// ROR Label 570
if((x > 0) != (x < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 570);
}
// ROR Label 571
if((x >= 0) != (x < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}
// ROR Label 572
if((x <= 1114111) != (x > 1114111))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
// ROR Label 573
if((x < 1114111) != (x > 1114111))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 573);
}
// ROR Label 574
if((x >= 1114111) != (x > 1114111))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 574);
}

// MCC Label 575
if(x < 0 && x > 1114111 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(x < 0 && !(x > 1114111) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
// MCC Label 577
if(!(x < 0) && x > 1114111 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 577);
}
// MCC Label 578
if(!(x < 0) && !(x > 1114111) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
if( x<0 || x>0x10ffff ) { x = 0xfffd;
}
    c = (unsigned)(x & 0x1fffff);
    
// ABS Label 579
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}

// ROR Label 580
if((c <= 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 580);
}
// ROR Label 581
if((c > 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 581);
}
// ROR Label 582
if((c >= 128) != (c < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 582);
}
if( c<0x00080 ){
      *zOut++ = (u8)(c&0xFF);
    }else { 
// ABS Label 583
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 583);
}

// ROR Label 584
if((c <= 2048) != (c < 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 584);
}
// ROR Label 585
if((c > 2048) != (c < 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 585);
}
// ROR Label 586
if((c >= 2048) != (c < 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 586);
}
if( c<0x00800 ){
      *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }else { 
// ABS Label 587
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 587);
}

// ROR Label 588
if((c <= 65536) != (c < 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 588);
}
// ROR Label 589
if((c > 65536) != (c < 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 589);
}
// ROR Label 590
if((c >= 65536) != (c < 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 590);
}
if( c<0x10000 ){
      *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);
      *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }else{
      *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);
      *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);
      *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    };}
;}
                                                    \
  };
// ABS Label 562
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}
// ABS Label 563
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 563);
}

// ROR Label 564
if((i <= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}
// ROR Label 565
if((i > argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 565);
}
// ROR Label 566
if((i >= argc) != (i < argc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 566);
}

  
// ABS Label 553
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}
sqlite3_result_text64(context, (char*)z, zOut-z, sqlite3_free, SQLITE_UTF8);
}

/*
** The hex() function.  Interpret the argument as a blob.  Return
** a hexadecimal rendering as text.
*/
static void hexFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i, n;
  const unsigned char *pBlob;
  char *zHex, *z;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  pBlob = sqlite3_value_blob(argv[0]);
  n = sqlite3_value_bytes(argv[0]);
  assert( pBlob==sqlite3_value_blob(argv[0]) );  /* No encoding change */
  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);
  
// ABS Label 591
if(zHex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 591);
}
if( zHex ){
    i = 0;

// ABS Label 597
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 597);
}
// ABS Label 598
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}

// ROR Label 599
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 599);
}
// ROR Label 600
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 600);
}
// ROR Label 601
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 601);
}
for(; i<n; i++, pBlob++){
      
// ABS Label 607
if(*pBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 607);
}
unsigned char c = *pBlob;
      *(z++) = hexdigits[(c>>4)&0xf];
      *(z++) = hexdigits[c&0xf];
    };
// ABS Label 602
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 602);
}
// ABS Label 603
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}

// ROR Label 604
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 604);
}
// ROR Label 605
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 605);
}
// ROR Label 606
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 606);
}

    *z = 0;
    
// ABS Label 592
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 592);
}

// ABS Label 593
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 593);
}

// AOR Label 594
if(n - 2 != n * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 594);
}
// AOR Label 595
if(n + 2 != n * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 595);
}
// AOR Label 596
if(n / 2 != n * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 596);
}
sqlite3_result_text(context, zHex, n*2, sqlite3_free);
  }
}

/*
** The zeroblob(N) function returns a zero-filled blob of size N bytes.
*/
static void zeroblobFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  i64 n;
  int rc;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  n = sqlite3_value_int64(argv[0]);
  
// ABS Label 608
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 608);
}

// ROR Label 609
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 609);
}
// ROR Label 610
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}
// ROR Label 611
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 611);
}
if( n<0 ) { n = 0;
}
  rc = sqlite3_result_zeroblob64(context, n); /* IMP: R-00293-64994 */
  
// ABS Label 612
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 612);
}
if( rc ){
    
// ABS Label 613
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 613);
}

// ABS Label 614
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 614);
}
sqlite3_result_error_code(context, rc);
  }
}

/*
** The replace() function.  Three arguments are all strings: call
** them A, B, and C. The result is also a string which is derived
** from A by replacing every occurrence of B with C.  The match
** must be exact.  Collating sequences are not used.
*/
static void replaceFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zStr;        /* The input string A */
  const unsigned char *zPattern;    /* The pattern string B */
  const unsigned char *zRep;        /* The replacement string C */
  unsigned char *zOut;              /* The output */
  int nStr;                /* Size of zStr */
  int nPattern;            /* Size of zPattern */
  int nRep;                /* Size of zRep */
  i64 nOut;                /* Maximum size of zOut */
  int loopLimit;           /* Last zStr[] that might match zPattern[] */
  int i, j;                /* Loop counters */
  unsigned cntExpand;      /* Number zOut expansions */
  sqlite3 *db = sqlite3_context_db_handle(context);

  assert( argc==3 );
  UNUSED_PARAMETER(argc);
  zStr = sqlite3_value_text(argv[0]);
  
// ABS Label 617
if(zStr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}

// ROR Label 618
if((zStr != 0) != (zStr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 618);
}
if( zStr==0 ) { return;
}
  nStr = sqlite3_value_bytes(argv[0]);
  assert( zStr==sqlite3_value_text(argv[0]) );  /* No encoding change */
  zPattern = sqlite3_value_text(argv[1]);
  
// ABS Label 619
if(zPattern < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// ROR Label 620
if((zPattern != 0) != (zPattern == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
if( zPattern==0 ){
    assert( sqlite3_value_type(argv[1])==SQLITE_NULL
            || sqlite3_context_db_handle(context)->mallocFailed );
    return;
  }
  
// ROR Label 621
if((zPattern[0] != 0) != (zPattern[0] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}
if( zPattern[0]==0 ){
    assert( sqlite3_value_type(argv[1])!=SQLITE_NULL );
    
// ABS Label 622
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 622);
}

// ABS Label 623
if(argv[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 623);
}
sqlite3_result_value(context, argv[0]);
    return;
  }
  nPattern = sqlite3_value_bytes(argv[1]);
  assert( zPattern==sqlite3_value_text(argv[1]) );  /* No encoding change */
  zRep = sqlite3_value_text(argv[2]);
  
// ABS Label 624
if(zRep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 624);
}

// ROR Label 625
if((zRep != 0) != (zRep == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}
if( zRep==0 ) { return;
}
  nRep = sqlite3_value_bytes(argv[2]);
  assert( zRep==sqlite3_value_text(argv[2]) );
  nOut = nStr + 1;
  assert( nOut<SQLITE_MAX_LENGTH );
  zOut = contextMalloc(context, (i64)nOut);
  
// ABS Label 626
if(zOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 626);
}

// ROR Label 627
if((zOut != 0) != (zOut == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 627);
}
if( zOut==0 ){
    return;
  }
  loopLimit = nStr - nPattern;  
  cntExpand = 0;
  i = j = 0;

// ABS Label 628
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}
// ABS Label 629
if(loopLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}

// ROR Label 630
if((i < loopLimit) != (i <= loopLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 630);
}
// ROR Label 631
if((i > loopLimit) != (i <= loopLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}
// ROR Label 632
if((i >= loopLimit) != (i <= loopLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 632);
}
for(; i<=loopLimit; i++){
    
// MCC Label 638
if(zStr[i] != zPattern[0] && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 638);
}
// MCC Label 639
if(!(zStr[i] != zPattern[0]) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 639);
}
if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){
      zOut[j++] = zStr[i];
    }else{
      
// ABS Label 640
if(nPattern < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 640);
}
// ABS Label 641
if(nRep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}

// ROR Label 642
if((nRep <= nPattern) != (nRep > nPattern))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}
// ROR Label 643
if((nRep < nPattern) != (nRep > nPattern))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 643);
}
// ROR Label 644
if((nRep >= nPattern) != (nRep > nPattern))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 644);
}
if( nRep>nPattern ){
        nOut += nRep - nPattern;
        testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );
        testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );
        
// ABS Label 645
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}

// AOR Label 646
if(nOut / 1 != nOut - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 646);
}
// AOR Label 647
if(nOut + 1 != nOut - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 647);
}
// AOR Label 648
if(nOut * 1 != nOut - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 648);
}

// ROR Label 649
if((nOut - 1 <= db->aLimit[0]) != (nOut - 1 > db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 649);
}
// ROR Label 650
if((nOut - 1 < db->aLimit[0]) != (nOut - 1 > db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 650);
}
// ROR Label 651
if((nOut - 1 >= db->aLimit[0]) != (nOut - 1 > db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}
if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){
          
// ABS Label 652
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}
sqlite3_result_error_toobig(context);
          sqlite3_free(zOut);
          return;
        }
        cntExpand++;
        
// ROR Label 653
if(((cntExpand & (cntExpand - 1)) != 0) != ((cntExpand & (cntExpand - 1)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 653);
}
if( (cntExpand&(cntExpand-1))==0 ){
          /* Grow the size of the output buffer only on substitutions
          ** whose index is a power of two: 1, 2, 4, 8, 16, 32, ... */
          u8 *zOld;
          zOld = zOut;
          zOut = sqlite3Realloc(zOut, (int)nOut + (nOut - nStr - 1));
          
// ABS Label 654
if(zOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 654);
}

// ROR Label 655
if((zOut != 0) != (zOut == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 655);
}
if( zOut==0 ){
            
// ABS Label 656
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 656);
}
sqlite3_result_error_nomem(context);
            sqlite3_free(zOld);
            return;
          }
        }
      }
      memcpy(&zOut[j], zRep, nRep);
      j += nRep;
      i += nPattern-1;
    }
  };
// ABS Label 633
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 633);
}
// ABS Label 634
if(loopLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}

// ROR Label 635
if((i < loopLimit) != (i <= loopLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 635);
}
// ROR Label 636
if((i > loopLimit) != (i <= loopLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
// ROR Label 637
if((i >= loopLimit) != (i <= loopLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}

  assert( j+nStr-i+1<=nOut );
  memcpy(&zOut[j], &zStr[i], nStr-i);
  j += nStr - i;
  assert( j<=nOut );
  zOut[j] = 0;
  
// ABS Label 615
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 615);
}

// ABS Label 616
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 616);
}
sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);
}

/*
** Implementation of the TRIM(), LTRIM(), and RTRIM() functions.
** The userdata is 0x1 for left trim, 0x2 for right trim, 0x3 for both.
*/
static void trimFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zIn;         /* Input string */
  const unsigned char *zCharSet;    /* Set of characters to trim */
  unsigned int nIn;                 /* Number of bytes in input */
  int flags;                        /* 1: trimleft  2: trimright  3: trim */
  int i;                            /* Loop counter */
  unsigned int *aLen = 0;           /* Length of each character in zCharSet */
  unsigned char **azChar = 0;       /* Individual characters in zCharSet */
  int nChar;                        /* Number of characters in zCharSet */

  if( sqlite3_value_type(argv[0])==SQLITE_NULL ){
    return;
  }
  zIn = sqlite3_value_text(argv[0]);
  
// ABS Label 658
if(zIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}

// ROR Label 659
if((zIn != 0) != (zIn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 659);
}
if( zIn==0 ) { return;
}
  nIn = (unsigned)sqlite3_value_bytes(argv[0]);
  assert( zIn==sqlite3_value_text(argv[0]) );
  
// ABS Label 660
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 660);
}

// ROR Label 661
if((argc != 1) != (argc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 661);
}
if( argc==1 ){
    static const unsigned lenOne[] = { 1 };
    static unsigned char * const azOne[] = { (u8*)" " };
    nChar = 1;
    aLen = (unsigned*)lenOne;
    azChar = (unsigned char **)azOne;
    zCharSet = 0;
  }else { if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){
    return;
  }else{
    const unsigned char *z;
    z = zCharSet , nChar = 0;

// ABS Label 662
if(*z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 662);
}
for(; *z; nChar++){
      SQLITE_SKIP_UTF8(z);
    };
// ABS Label 663
if(*z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}

    
// ABS Label 666
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ROR Label 667
if((nChar <= 0) != (nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
// ROR Label 668
if((nChar < 0) != (nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 668);
}
// ROR Label 669
if((nChar >= 0) != (nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 669);
}
if( nChar>0 ){
      azChar = contextMalloc(context, 
                     ((i64)nChar)*(sizeof(char*)+sizeof(unsigned)));
      
// ABS Label 670
if(azChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}

// ROR Label 671
if((azChar != 0) != (azChar == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 671);
}
if( azChar==0 ){
        return;
      }
      aLen = (unsigned*)&azChar[nChar];
      z = zCharSet , nChar = 0;

// ABS Label 672
if(*z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}
for(; *z; nChar++){
        azChar[nChar] = (unsigned char *)z;
        SQLITE_SKIP_UTF8(z);
        aLen[nChar] = (unsigned)(z - azChar[nChar]);
      };
// ABS Label 673
if(*z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}

    }
  };}

  
// ABS Label 676
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 676);
}

// ROR Label 677
if((nChar <= 0) != (nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 677);
}
// ROR Label 678
if((nChar < 0) != (nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 678);
}
// ROR Label 679
if((nChar >= 0) != (nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 679);
}
if( nChar>0 ){
    flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context));
    
// ABS Label 680
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}

// AOR Label 681
if(flags | 1 != flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 681);
}
// AOR Label 682
if(flags ^ 1 != flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 682);
}
if( flags & 1 ){
      
// ABS Label 683
if(nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}

// ROR Label 684
if((nIn <= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 684);
}
// ROR Label 685
if((nIn < 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 685);
}
// ROR Label 686
if((nIn >= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 686);
}
while( nIn>0 ){
        unsigned int len = 0;
        i = 0;

// ABS Label 691
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}
// ABS Label 692
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}

// ROR Label 693
if((i <= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 693);
}
// ROR Label 694
if((i > nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 694);
}
// ROR Label 695
if((i >= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 695);
}
for(; i<nChar; i++){
          len = aLen[i];
          
// ABS Label 701
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}
// ABS Label 702
if(nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}

// MCC Label 703
if(len <= nIn && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 703);
}
// MCC Label 704
if(!(len <= nIn) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 704);
}
if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) { break;
}
        };
// ABS Label 696
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}
// ABS Label 697
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}

// ROR Label 698
if((i <= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 698);
}
// ROR Label 699
if((i > nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}
// ROR Label 700
if((i >= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 700);
}

        
// ABS Label 705
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}
// ABS Label 706
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}

// ROR Label 707
if((i < nChar) != (i >= nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 707);
}
// ROR Label 708
if((i > nChar) != (i >= nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 708);
}
// ROR Label 709
if((i <= nChar) != (i >= nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 709);
}
if( i>=nChar ) { break;
}
        zIn += len;
        nIn -= len;
      };
// ABS Label 687
if(nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}

// ROR Label 688
if((nIn <= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 688);
}
// ROR Label 689
if((nIn < 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 689);
}
// ROR Label 690
if((nIn >= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 690);
}

    }
    
// ABS Label 710
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}

// AOR Label 711
if(flags | 2 != flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 711);
}
// AOR Label 712
if(flags ^ 2 != flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 712);
}
if( flags & 2 ){
      
// ABS Label 713
if(nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 713);
}

// ROR Label 714
if((nIn <= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 714);
}
// ROR Label 715
if((nIn < 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 715);
}
// ROR Label 716
if((nIn >= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 716);
}
while( nIn>0 ){
        unsigned int len = 0;
        i = 0;

// ABS Label 721
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}
// ABS Label 722
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 722);
}

// ROR Label 723
if((i <= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}
// ROR Label 724
if((i > nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 724);
}
// ROR Label 725
if((i >= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 725);
}
for(; i<nChar; i++){
          len = aLen[i];
          
// ABS Label 731
if(len < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}
// ABS Label 732
if(nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}

// MCC Label 733
if(len <= nIn && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 733);
}
// MCC Label 734
if(!(len <= nIn) && 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 734);
}
if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) { break;
}
        };
// ABS Label 726
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}
// ABS Label 727
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}

// ROR Label 728
if((i <= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 728);
}
// ROR Label 729
if((i > nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 729);
}
// ROR Label 730
if((i >= nChar) != (i < nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 730);
}

        
// ABS Label 735
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 735);
}
// ABS Label 736
if(nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// ROR Label 737
if((i < nChar) != (i >= nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 737);
}
// ROR Label 738
if((i > nChar) != (i >= nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 738);
}
// ROR Label 739
if((i <= nChar) != (i >= nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 739);
}
if( i>=nChar ) { break;
}
        nIn -= len;
      };
// ABS Label 717
if(nIn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}

// ROR Label 718
if((nIn <= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 718);
}
// ROR Label 719
if((nIn < 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 719);
}
// ROR Label 720
if((nIn >= 0) != (nIn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}

    }
    
// ABS Label 740
if(zCharSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}
if( zCharSet ){
      sqlite3_free(azChar);
    }
  }
  
// ABS Label 657
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}
sqlite3_result_text(context, (char*)zIn, nIn, SQLITE_TRANSIENT);
}


#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
/*
** The "unknown" function is automatically substituted in place of
** any unrecognized function name when doing an EXPLAIN or EXPLAIN QUERY PLAN
** when the SQLITE_ENABLE_UNKNOWN_FUNCTION compile-time option is used.
** When the "sqlite3" command-line shell is built using this functionality,
** that allows an EXPLAIN or EXPLAIN QUERY PLAN for complex queries
** involving application-defined functions to be examined in a generic
** sqlite3 shell.
*/
static void unknownFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  /* no-op */
}
#endif /*SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION*/


/* IMP: R-25361-16150 This function is omitted from SQLite by default. It
** is only available if the SQLITE_SOUNDEX compile-time option is used
** when SQLite is built.
*/
#ifdef SQLITE_SOUNDEX
/*
** Compute the soundex encoding of a word.
**
** IMP: R-59782-00072 The soundex(X) function returns a string that is the
** soundex encoding of the string X. 
*/
static void soundexFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  char zResult[8];
  const u8 *zIn;
  int i, j;
  static const unsigned char iCode[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,
    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,
    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,
    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,
  };
  assert( argc==1 );
  zIn = (u8*)sqlite3_value_text(argv[0]);
  if( zIn==0 ) zIn = (u8*)"";
  for(i=0; zIn[i] && !sqlite3Isalpha(zIn[i]); i++){}
  if( zIn[i] ){
    u8 prevcode = iCode[zIn[i]&0x7f];
    zResult[0] = sqlite3Toupper(zIn[i]);
    for(j=1; j<4 && zIn[i]; i++){
      int code = iCode[zIn[i]&0x7f];
      if( code>0 ){
        if( code!=prevcode ){
          prevcode = code;
          zResult[j++] = code + '0';
        }
      }else{
        prevcode = 0;
      }
    }
    while( j<4 ){
      zResult[j++] = '0';
    }
    zResult[j] = 0;
    sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT);
  }else{
    /* IMP: R-64894-50321 The string "?000" is returned if the argument
    ** is NULL or contains no ASCII alphabetic characters. */
    sqlite3_result_text(context, "?000", 4, SQLITE_STATIC);
  }
}
#endif /* SQLITE_SOUNDEX */

#ifndef SQLITE_OMIT_LOAD_EXTENSION
/*
** A function that loads a shared-library extension then returns NULL.
*/
static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){
  const char *zFile = (const char *)sqlite3_value_text(argv[0]);
  const char *zProc;
  sqlite3 *db = sqlite3_context_db_handle(context);
  char *zErrMsg = 0;

  /* Disallow the load_extension() SQL function unless the SQLITE_LoadExtFunc
  ** flag is set.  See the sqlite3_enable_load_extension() API.
  */
  
// ROR Label 741
if(((db->flags & 131072) != 0) != ((db->flags & 131072) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 741);
}
if( (db->flags & SQLITE_LoadExtFunc)==0 ){
    
// ABS Label 742
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}
sqlite3_result_error(context, "not authorized", -1);
    return;
  }

  
// ABS Label 743
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}

// ROR Label 744
if((argc != 2) != (argc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 744);
}
if( argc==2 ){
    zProc = (const char *)sqlite3_value_text(argv[1]);
  }else{
    zProc = 0;
  }
  if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){
    
// ABS Label 745
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}
sqlite3_result_error(context, zErrMsg, -1);
    sqlite3_free(zErrMsg);
  }
}
#endif


/*
** An instance of the following structure holds the context of a
** sum() or avg() aggregate computation.
*/
typedef struct SumCtx SumCtx;
struct SumCtx {
  double rSum;      /* Floating point sum */
  i64 iSum;         /* Integer sum */   
  i64 cnt;          /* Number of elements summed */
  u8 overflow;      /* True if integer overflow seen */
  u8 approx;        /* True if non-integer value was input to the sum */
};

/*
** Routines used to compute the sum, average, and total.
**
** The SUM() function follows the (broken) SQL standard which means
** that it returns NULL if it sums over no inputs.  TOTAL returns
** 0.0 in that case.  In addition, TOTAL always returns a float where
** SUM might return an integer if it never encounters a floating point
** value.  TOTAL never fails, but SUM might through an exception if
** it overflows an integer.
*/
static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  SumCtx *p;
  int type;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);
  
// ABS Label 746
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}
// ABS Label 747
if(type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}

// COR Label 748
if((p || type != 5) != (p && type != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 748);
}

// ROR Label 749
if((type == 5) != (type != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 749);
}

// MCC Label 750
if(p && type != 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 750);
}
// MCC Label 751
if(p && !(type != 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 751);
}
// MCC Label 752
if(!(p) && type != 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 752);
}
// MCC Label 753
if(!(p) && !(type != 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 753);
}
if( p && type!=SQLITE_NULL ){
    p->cnt++;
    
// ABS Label 754
if(type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 754);
}

// ROR Label 755
if((type != 1) != (type == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 755);
}
if( type==SQLITE_INTEGER ){
      i64 v = sqlite3_value_int64(argv[0]);
      p->rSum += v;
      if( (p->approx|p->overflow)==0 && sqlite3AddInt64(&p->iSum, v) ){
        p->approx = p->overflow = 1;
      }
    }else{
      p->rSum += sqlite3_value_double(argv[0]);
      p->approx = 1;
    }
  }
}
#ifndef SQLITE_OMIT_WINDOWFUNC
static void sumInverse(sqlite3_context *context, int argc, sqlite3_value**argv){
  SumCtx *p;
  int type;
  assert( argc==1 );
  UNUSED_PARAMETER(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);
  /* p is always non-NULL because sumStep() will have been called first
  ** to initialize it */
  
// ABS Label 756
if((p) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}
// ABS Label 757
if(type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}

// COR Label 758
if(((p) || type != 5) != ((p) && type != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 758);
}

// ROR Label 759
if((type == 5) != (type != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 759);
}

// MCC Label 760
if((p) && type != 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 760);
}
// MCC Label 761
if((p) && !(type != 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 761);
}
// MCC Label 762
if(!((p)) && type != 5 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 762);
}
// MCC Label 763
if(!((p)) && !(type != 5) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 763);
}
if( ALWAYS(p) && type!=SQLITE_NULL ){
    assert( p->cnt>0 );
    p->cnt--;
    assert( type==SQLITE_INTEGER || p->approx );
    
// ABS Label 764
if(type < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// COR Label 765
if((type == 1 || p->approx == 0) != (type == 1 && p->approx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 765);
}

// ROR Label 766
if((type != 1) != (type == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 766);
}
// ROR Label 767
if((p->approx != 0) != (p->approx == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 767);
}

// MCC Label 768
if(type == 1 && p->approx == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 768);
}
// MCC Label 769
if(type == 1 && !(p->approx == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 769);
}
// MCC Label 770
if(!(type == 1) && p->approx == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
// MCC Label 771
if(!(type == 1) && !(p->approx == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 771);
}
if( type==SQLITE_INTEGER && p->approx==0 ){
      i64 v = sqlite3_value_int64(argv[0]);
      p->rSum -= v;
      p->iSum -= v;
    }else{
      p->rSum -= sqlite3_value_double(argv[0]);
    }
  }
}
#else
# define sumInverse 0
#endif /* SQLITE_OMIT_WINDOWFUNC */
static void sumFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  
// ABS Label 772
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 772);
}
// ABS Label 773
if(p->cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}

// COR Label 774
if((p || p->cnt > 0) != (p && p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 774);
}

// ROR Label 775
if((p->cnt <= 0) != (p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 775);
}
// ROR Label 776
if((p->cnt < 0) != (p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 776);
}
// ROR Label 777
if((p->cnt >= 0) != (p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 777);
}

// MCC Label 778
if(p && p->cnt > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 778);
}
// MCC Label 779
if(p && !(p->cnt > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 779);
}
// MCC Label 780
if(!(p) && p->cnt > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 780);
}
// MCC Label 781
if(!(p) && !(p->cnt > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 781);
}
if( p && p->cnt>0 ){
    
// ABS Label 782
if(p->overflow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}
if( p->overflow ){
      
// ABS Label 783
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}
sqlite3_result_error(context,"integer overflow",-1);
    }else { 
// ABS Label 784
if(p->approx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}
if( p->approx ){
      
// ABS Label 785
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// ABS Label 786
if(p->rSum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}
sqlite3_result_double(context, p->rSum);
    }else{
      
// ABS Label 787
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}

// ABS Label 788
if(p->iSum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}
sqlite3_result_int64(context, p->iSum);
    };}

  }
}
static void avgFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  
// ABS Label 789
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}
// ABS Label 790
if(p->cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}

// COR Label 791
if((p || p->cnt > 0) != (p && p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 791);
}

// ROR Label 792
if((p->cnt <= 0) != (p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 792);
}
// ROR Label 793
if((p->cnt < 0) != (p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 793);
}
// ROR Label 794
if((p->cnt >= 0) != (p->cnt > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 794);
}

// MCC Label 795
if(p && p->cnt > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 795);
}
// MCC Label 796
if(p && !(p->cnt > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 796);
}
// MCC Label 797
if(!(p) && p->cnt > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 797);
}
// MCC Label 798
if(!(p) && !(p->cnt > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 798);
}
if( p && p->cnt>0 ){
    
// ABS Label 799
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}

// ABS Label 800
if(p->rSum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}

// AOR Label 801
if(p->rSum - (double)p->cnt != p->rSum / (double)p->cnt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 801);
}
// AOR Label 802
if(p->rSum + (double)p->cnt != p->rSum / (double)p->cnt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 802);
}
// AOR Label 803
if(p->rSum * (double)p->cnt != p->rSum / (double)p->cnt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 803);
}
sqlite3_result_double(context, p->rSum/(double)p->cnt);
  }
}
static void totalFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
  
// ABS Label 804
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}
sqlite3_result_double(context, p ? p->rSum : (double)0);
}

/*
** The following structure keeps track of state information for the
** count() aggregate function.
*/
typedef struct CountCtx CountCtx;
struct CountCtx {
  i64 n;
#ifdef SQLITE_DEBUG
  int bInverse;                   /* True if xInverse() ever called */
#endif
};

/*
** Routines to implement the count() aggregate function.
*/
static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, sizeof(*p));
  if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){
    p->n++;
  }

#ifndef SQLITE_OMIT_DEPRECATED
  /* The sqlite3_aggregate_count() function is deprecated.  But just to make
  ** sure it still operates correctly, verify that its count agrees with our 
  ** internal count when using count(*) and when the total count can be
  ** expressed as a 32-bit integer. */
  assert( argc==1 || p==0 || p->n>0x7fffffff || p->bInverse
          || p->n==sqlite3_aggregate_count(context) );
#endif
}   
static void countFinalize(sqlite3_context *context){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  
// ABS Label 805
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}
sqlite3_result_int64(context, p ? p->n : 0);
}
#ifndef SQLITE_OMIT_WINDOWFUNC
static void countInverse(sqlite3_context *ctx, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(ctx, sizeof(*p));
  /* p is always non-NULL since countStep() will have been called first */
  if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && ALWAYS(p) ){
    p->n--;
#ifdef SQLITE_DEBUG
    p->bInverse = 1;
#endif
  }
}   
#else
# define countInverse 0
#endif /* SQLITE_OMIT_WINDOWFUNC */

/*
** Routines to implement min() and max() aggregate functions.
*/
static void minmaxStep(
  sqlite3_context *context, 
  int NotUsed, 
  sqlite3_value **argv
){
  Mem *pArg  = (Mem *)argv[0];
  Mem *pBest;
  UNUSED_PARAMETER(NotUsed);

  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));
  if( !pBest ) { return;
}

  if( sqlite3_value_type(pArg)==SQLITE_NULL ){
    
// ABS Label 806
if(pBest->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}
if( pBest->flags ) { 
// ABS Label 807
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}
sqlite3SkipAccumulatorLoad(context);
}
  }else { 
// ABS Label 808
if(pBest->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}
if( pBest->flags ){
    int max;
    int cmp;
    CollSeq *pColl = sqlite3GetFuncCollSeq(context);
    /* This step function is used for both the min() and max() aggregates,
    ** the only difference between the two being that the sense of the
    ** comparison is inverted. For the max() aggregate, the
    ** sqlite3_user_data() function returns (void *)-1. For min() it
    ** returns (void *)db, where db is the sqlite3* database pointer.
    ** Therefore the next statement sets variable 'max' to 1 for the max()
    ** aggregate, or 0 for min().
    */
    max = sqlite3_user_data(context)!=0;
    cmp = sqlite3MemCompare(pBest, pArg, pColl);
    
// COR Label 809
if(((max && cmp < 0) && (!max && cmp > 0)) != ((max && cmp < 0) || (!max && cmp > 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 809);
}

// MCC Label 810
if(( max && cmp < 0 ) && ( !max && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 810);
}
// MCC Label 811
if(( max && cmp < 0 ) && ( !max && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 811);
}
// MCC Label 812
if(( max && cmp < 0 ) && ( !(!max) && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 812);
}
// MCC Label 813
if(( max && cmp < 0 ) && ( !(!max) && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 813);
}
// MCC Label 814
if(( max && !(cmp < 0) ) && ( !max && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 814);
}
// MCC Label 815
if(( max && !(cmp < 0) ) && ( !max && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 815);
}
// MCC Label 816
if(( max && !(cmp < 0) ) && ( !(!max) && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 816);
}
// MCC Label 817
if(( max && !(cmp < 0) ) && ( !(!max) && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 817);
}
// MCC Label 818
if(( !(max) && cmp < 0 ) && ( !max && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 818);
}
// MCC Label 819
if(( !(max) && cmp < 0 ) && ( !max && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 819);
}
// MCC Label 820
if(( !(max) && cmp < 0 ) && ( !(!max) && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 820);
}
// MCC Label 821
if(( !(max) && cmp < 0 ) && ( !(!max) && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 821);
}
// MCC Label 822
if(( !(max) && !(cmp < 0) ) && ( !max && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 822);
}
// MCC Label 823
if(( !(max) && !(cmp < 0) ) && ( !max && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 823);
}
// MCC Label 824
if(( !(max) && !(cmp < 0) ) && ( !(!max) && cmp > 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 824);
}
// MCC Label 825
if(( !(max) && !(cmp < 0) ) && ( !(!max) && !(cmp > 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 825);
}
if( (max && cmp<0) || (!max && cmp>0) ){
      
// ABS Label 826
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}
sqlite3VdbeMemCopy(pBest, pArg);
    }else{
      
// ABS Label 827
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
sqlite3SkipAccumulatorLoad(context);
    }
  }else{
    pBest->db = sqlite3_context_db_handle(context);
    
// ABS Label 828
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}
sqlite3VdbeMemCopy(pBest, pArg);
  };}

}
static void minMaxValueFinalize(sqlite3_context *context, int bValue){
  sqlite3_value *pRes;
  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);
  
// ABS Label 829
if(pRes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}
if( pRes ){
    
// ABS Label 830
if(pRes->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}
if( pRes->flags ){
      
// ABS Label 831
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 831);
}

// ABS Label 832
if(pRes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 832);
}
sqlite3_result_value(context, pRes);
    }
    
// ABS Label 833
if(bValue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}

// ROR Label 834
if((bValue != 0) != (bValue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 834);
}
if( bValue==0 ) { 
// ABS Label 835
if(pRes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 835);
}
sqlite3VdbeMemRelease(pRes);
}
  }
}
#ifndef SQLITE_OMIT_WINDOWFUNC
static void minMaxValue(sqlite3_context *context){
  
// ABS Label 836
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 836);
}
minMaxValueFinalize(context, 1);
}
#else
# define minMaxValue 0
#endif /* SQLITE_OMIT_WINDOWFUNC */
static void minMaxFinalize(sqlite3_context *context){
  
// ABS Label 837
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 837);
}
minMaxValueFinalize(context, 0);
}

/*
** group_concat(EXPR, ?SEPARATOR?)
*/
static void groupConcatStep(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zVal;
  StrAccum *pAccum;
  const char *zSep;
  int nVal, nSep;
  assert( argc==1 || argc==2 );
  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) { return;
}
  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));

  
// ABS Label 838
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}
if( pAccum ){
    sqlite3 *db = sqlite3_context_db_handle(context);
    
// ABS Label 839
if(pAccum->mxAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}

// ROR Label 840
if((pAccum->mxAlloc != 0) != (pAccum->mxAlloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 840);
}
int firstTerm = pAccum->mxAlloc==0;
    pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];
    if( !firstTerm ){
      
// ABS Label 841
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 841);
}

// ROR Label 842
if((argc != 2) != (argc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 842);
}
if( argc==2 ){
        zSep = (char*)sqlite3_value_text(argv[1]);
        nSep = sqlite3_value_bytes(argv[1]);
      }else{
        zSep = ",";
        nSep = 1;
      }
      
// ABS Label 843
if(zSep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 843);
}
if( zSep ) { 
// ABS Label 844
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 844);
}

// ABS Label 845
if(zSep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}

// ABS Label 846
if(nSep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}
sqlite3_str_append(pAccum, zSep, nSep);
}
    }
    zVal = (char*)sqlite3_value_text(argv[0]);
    nVal = sqlite3_value_bytes(argv[0]);
    
// ABS Label 847
if(zVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}
if( zVal ) { 
// ABS Label 848
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}

// ABS Label 849
if(zVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}

// ABS Label 850
if(nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 850);
}
sqlite3_str_append(pAccum, zVal, nVal);
}
  }
}
#ifndef SQLITE_OMIT_WINDOWFUNC
static void groupConcatInverse(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  StrAccum *pAccum;
  assert( argc==1 || argc==2 );
  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) { return;
}
  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));
  /* pAccum is always non-NULL since groupConcatStep() will have always
  ** run frist to initialize it */
  
// ABS Label 851
if((pAccum) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}
if( ALWAYS(pAccum) ){
    n = sqlite3_value_bytes(argv[0]);
    
// ABS Label 852
if(argc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}

// ROR Label 853
if((argc != 2) != (argc == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
if( argc==2 ){
      n += sqlite3_value_bytes(argv[1]);
    }else{
      n++;
    }
    
// ABS Label 854
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}

// ROR Label 855
if((n < (int)pAccum->nChar) != (n >= (int)pAccum->nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 855);
}
// ROR Label 856
if((n > (int)pAccum->nChar) != (n >= (int)pAccum->nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 856);
}
// ROR Label 857
if((n <= (int)pAccum->nChar) != (n >= (int)pAccum->nChar))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 857);
}
if( n>=(int)pAccum->nChar ){
      pAccum->nChar = 0;
    }else{
      pAccum->nChar -= n;
      memmove(pAccum->zText, &pAccum->zText[n], pAccum->nChar);
    }
    
// ABS Label 858
if(pAccum->nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}

// ROR Label 859
if((pAccum->nChar != 0) != (pAccum->nChar == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 859);
}
if( pAccum->nChar==0 ) { pAccum->mxAlloc = 0;
}
  }
}
#else
# define groupConcatInverse 0
#endif /* SQLITE_OMIT_WINDOWFUNC */
static void groupConcatFinalize(sqlite3_context *context){
  StrAccum *pAccum;
  pAccum = sqlite3_aggregate_context(context, 0);
  
// ABS Label 860
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 860);
}
if( pAccum ){
    
// ROR Label 861
if((pAccum->accError != 18) != (pAccum->accError == 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 861);
}
if( pAccum->accError==SQLITE_TOOBIG ){
      
// ABS Label 862
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 862);
}
sqlite3_result_error_toobig(context);
    }else { 
// ROR Label 863
if((pAccum->accError != 7) != (pAccum->accError == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 863);
}
if( pAccum->accError==SQLITE_NOMEM ){
      
// ABS Label 864
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 864);
}
sqlite3_result_error_nomem(context);
    }else{    
      
// ABS Label 865
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 865);
}
sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1, 
                          sqlite3_free);
    };}

  }
}
#ifndef SQLITE_OMIT_WINDOWFUNC
static void groupConcatValue(sqlite3_context *context){
  sqlite3_str *pAccum;
  pAccum = (sqlite3_str*)sqlite3_aggregate_context(context, 0);
  
// ABS Label 866
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 866);
}
if( pAccum ){
    
// ROR Label 867
if((pAccum->accError != 18) != (pAccum->accError == 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 867);
}
if( pAccum->accError==SQLITE_TOOBIG ){
      
// ABS Label 868
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 868);
}
sqlite3_result_error_toobig(context);
    }else { 
// ROR Label 869
if((pAccum->accError != 7) != (pAccum->accError == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 869);
}
if( pAccum->accError==SQLITE_NOMEM ){
      
// ABS Label 870
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}
sqlite3_result_error_nomem(context);
    }else{    
      const char *zText = sqlite3_str_value(pAccum);
      
// ABS Label 871
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}

// ABS Label 872
if(zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);
    };}

  }
}
#else
# define groupConcatValue 0
#endif /* SQLITE_OMIT_WINDOWFUNC */

/*
** This routine does per-connection function registration.  Most
** of the built-in functions above are part of the global function set.
** This routine only deals with those that are not global.
*/
void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db){
  int rc = sqlite3_overload_function(db, "MATCH", 2);
  assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );
  
// ABS Label 873
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// ROR Label 874
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 874);
}
if( rc==SQLITE_NOMEM ){
    
// ABS Label 875
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 875);
}
sqlite3OomFault(db);
  }
}

/*
** Re-register the built-in LIKE functions.  The caseSensitive
** parameter determines whether or not the LIKE operator is case
** sensitive.
*/
void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){
  struct compareInfo *pInfo;
  int flags;
  
// ABS Label 878
if(caseSensitive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 878);
}
if( caseSensitive ){
    pInfo = (struct compareInfo*)&likeInfoAlt;
    flags = SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE;
  }else{
    pInfo = (struct compareInfo*)&likeInfoNorm;
    flags = SQLITE_FUNC_LIKE;
  }
  
// ABS Label 876
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 876);
}
sqlite3CreateFunc(db, "like", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);
  
// ABS Label 877
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}
sqlite3CreateFunc(db, "like", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);
  sqlite3FindFunction(db, "like", 2, SQLITE_UTF8, 0)->funcFlags |= flags;
  sqlite3FindFunction(db, "like", 3, SQLITE_UTF8, 0)->funcFlags |= flags;
}

/*
** pExpr points to an expression which implements a function.  If
** it is appropriate to apply the LIKE optimization to that function
** then set aWc[0] through aWc[2] to the wildcard characters and the
** escape character and then return TRUE.  If the function is not a 
** LIKE-style function then return FALSE.
**
** The expression "a LIKE b ESCAPE c" is only considered a valid LIKE
** operator if c is a string literal that is exactly one byte in length.
** That one byte is stored in aWc[3].  aWc[3] is set to zero if there is
** no ESCAPE clause.
**
** *pIsNocase is set to true if uppercase and lowercase are equivalent for
** the function (default for LIKE).  If the function makes the distinction
** between uppercase and lowercase (as does GLOB) then *pIsNocase is set to
** false.
*/
int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){
  FuncDef *pDef;
  int nExpr;
  assert( pExpr!=0 );
  assert( pExpr->op==TK_FUNCTION );
  if( !pExpr->x.pList ){
    return 0;
  }
  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
  nExpr = pExpr->x.pList->nExpr;
  pDef = sqlite3FindFunction(db, pExpr->u.zToken, nExpr, SQLITE_UTF8, 0);
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
  if( pDef==0 ) return 0;
#endif
  
// COR Label 879
if(((pDef == 0) && (pDef->funcFlags & 4) == 0) != ((pDef == 0) || (pDef->funcFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 879);
}

// ROR Label 880
if(((pDef->funcFlags & 4) != 0) != ((pDef->funcFlags & 4) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 880);
}

// MCC Label 881
if(( pDef == 0 ) && (pDef->funcFlags & 4) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 881);
}
// MCC Label 882
if(( pDef == 0 ) && !((pDef->funcFlags & 4) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 882);
}
// MCC Label 883
if(( !(pDef == 0) ) && (pDef->funcFlags & 4) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 883);
}
// MCC Label 884
if(( !(pDef == 0) ) && !((pDef->funcFlags & 4) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 884);
}
if( NEVER(pDef==0) || (pDef->funcFlags & SQLITE_FUNC_LIKE)==0 ){
    return 0;
  }

  /* The memcpy() statement assumes that the wildcard characters are
  ** the first three statements in the compareInfo structure.  The
  ** asserts() that follow verify that assumption
  */
  memcpy(aWc, pDef->pUserData, 3);
  assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll );
  assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne );
  assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet );

  
// ABS Label 885
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 885);
}

// ROR Label 886
if((nExpr <= 3) != (nExpr < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 886);
}
// ROR Label 887
if((nExpr > 3) != (nExpr < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 887);
}
// ROR Label 888
if((nExpr >= 3) != (nExpr < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
if( nExpr<3 ){
    aWc[3] = 0;
  }else{
    
// ABS Label 889
if(pExpr->x.pList->a[2].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 889);
}
Expr *pEscape = pExpr->x.pList->a[2].pExpr;
    char *zEscape;
    
// ROR Label 890
if((pEscape->op == 116) != (pEscape->op != 116))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 890);
}
if( pEscape->op!=TK_STRING ) { return 0;
}
    zEscape = pEscape->u.zToken;
    
// COR Label 891
if((zEscape[0] == 0 && zEscape[1] != 0) != (zEscape[0] == 0 || zEscape[1] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 891);
}

// ROR Label 892
if((zEscape[0] != 0) != (zEscape[0] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
// ROR Label 893
if((zEscape[1] == 0) != (zEscape[1] != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 893);
}

// MCC Label 894
if(zEscape[0] == 0 && zEscape[1] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 894);
}
// MCC Label 895
if(zEscape[0] == 0 && !(zEscape[1] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 895);
}
// MCC Label 896
if(!(zEscape[0] == 0) && zEscape[1] != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 896);
}
// MCC Label 897
if(!(zEscape[0] == 0) && !(zEscape[1] != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 897);
}
if( zEscape[0]==0 || zEscape[1]!=0 ) { return 0;
}
    
// ROR Label 898
if((zEscape[0] != aWc[0]) != (zEscape[0] == aWc[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 898);
}
if( zEscape[0]==aWc[0] ) { return 0;
}
    
// ROR Label 899
if((zEscape[0] != aWc[1]) != (zEscape[0] == aWc[1]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 899);
}
if( zEscape[0]==aWc[1] ) { return 0;
}
    aWc[3] = zEscape[0];
  }

  *pIsNocase = (pDef->funcFlags & SQLITE_FUNC_CASE)==0;
  return 1;
}

/* Mathematical Constants */
#ifndef M_PI
# define M_PI   3.141592653589793238462643383279502884
#endif
#ifndef M_LN10
# define M_LN10 2.302585092994045684017991454684364208
#endif
#ifndef M_LN2
# define M_LN2  0.693147180559945309417232121458176568
#endif


/* Extra math functions that require linking with -lm
*/
#ifdef SQLITE_ENABLE_MATH_FUNCTIONS
/*
** Implementation SQL functions:
**
**   ceil(X)
**   ceiling(X)
**   floor(X)
**
** The sqlite3_user_data() pointer is a pointer to the libm implementation
** of the underlying C function.
*/
static void ceilingFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  assert( argc==1 );
  switch( sqlite3_value_numeric_type(argv[0]) ){
    case SQLITE_INTEGER: {
       sqlite3_result_int64(context, sqlite3_value_int64(argv[0]));
       break;
    }
    case SQLITE_FLOAT: {
       double (*x)(double) = (double(*)(double))sqlite3_user_data(context);
       sqlite3_result_double(context, x(sqlite3_value_double(argv[0])));
       break;
    }
    default: {
       break;
    }
  }
}

/*
** On some systems, ceil() and floor() are intrinsic function.  You are
** unable to take a pointer to these functions.  Hence, we here wrap them
** in our own actual functions.
*/
static double xCeil(double x){ return ceil(x); }
static double xFloor(double x){ return floor(x); }

/*
** Implementation of SQL functions:
**
**   ln(X)       - natural logarithm
**   log(X)      - log X base 10
**   log10(X)    - log X base 10
**   log(B,X)    - log X base B
*/
static void logFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  double x, b, ans;
  assert( argc==1 || argc==2 );
  switch( sqlite3_value_numeric_type(argv[0]) ){
    case SQLITE_INTEGER:
    case SQLITE_FLOAT:
      x = sqlite3_value_double(argv[0]);
      if( x<=0.0 ) return;
      break;
    default:
      return;
  }
  if( argc==2 ){
    switch( sqlite3_value_numeric_type(argv[0]) ){
      case SQLITE_INTEGER:
      case SQLITE_FLOAT:
        b = log(x);
        if( b<=0.0 ) return;
        x = sqlite3_value_double(argv[1]);
        if( x<=0.0 ) return;
        break;
     default:
        return;
    }
    ans = log(x)/b;
  }else{
    ans = log(x);
    switch( SQLITE_PTR_TO_INT(sqlite3_user_data(context)) ){
      case 1:
        /* Convert from natural logarithm to log base 10 */
        ans *= 1.0/M_LN10;
        break;
      case 2:
        /* Convert from natural logarithm to log base 2 */
        ans *= 1.0/M_LN2;
        break;
      default:
        break;
    }
  }
  sqlite3_result_double(context, ans);
}

/*
** Functions to converts degrees to radians and radians to degrees.
*/
static double degToRad(double x){ return x*(M_PI/180.0); }
static double radToDeg(double x){ return x*(180.0/M_PI); }

/*
** Implementation of 1-argument SQL math functions:
**
**   exp(X)  - Compute e to the X-th power
*/
static void math1Func(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int type0;
  double v0, ans;
  double (*x)(double);
  assert( argc==1 );
  type0 = sqlite3_value_numeric_type(argv[0]);
  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;
  v0 = sqlite3_value_double(argv[0]);
  x = (double(*)(double))sqlite3_user_data(context);
  ans = x(v0);
  sqlite3_result_double(context, ans);
}

/*
** Implementation of 2-argument SQL math functions:
**
**   power(X,Y)  - Compute X to the Y-th power
*/
static void math2Func(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int type0, type1;
  double v0, v1, ans;
  double (*x)(double,double);
  assert( argc==2 );
  type0 = sqlite3_value_numeric_type(argv[0]);
  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;
  type1 = sqlite3_value_numeric_type(argv[1]);
  if( type1!=SQLITE_INTEGER && type1!=SQLITE_FLOAT ) return;
  v0 = sqlite3_value_double(argv[0]);
  v1 = sqlite3_value_double(argv[1]);
  x = (double(*)(double,double))sqlite3_user_data(context);
  ans = x(v0, v1);
  sqlite3_result_double(context, ans);
}

/*
** Implementation of 0-argument pi() function.
*/
static void piFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  assert( argc==0 );
  sqlite3_result_double(context, M_PI);
}

#endif /* SQLITE_ENABLE_MATH_FUNCTIONS */

/*
** Implementation of sign(X) function.
*/
static void signFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int type0;
  double x;
  UNUSED_PARAMETER(argc);
  assert( argc==1 );
  type0 = sqlite3_value_numeric_type(argv[0]);
  
// ABS Label 901
if(type0 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 901);
}

// COR Label 902
if((type0 != 1 || type0 != 2) != (type0 != 1 && type0 != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 902);
}

// ROR Label 903
if((type0 == 1) != (type0 != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 903);
}
// ROR Label 904
if((type0 == 2) != (type0 != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 904);
}

// MCC Label 905
if(type0 != 1 && type0 != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 905);
}
// MCC Label 906
if(type0 != 1 && !(type0 != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 906);
}
// MCC Label 907
if(!(type0 != 1) && type0 != 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 907);
}
// MCC Label 908
if(!(type0 != 1) && !(type0 != 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 908);
}
if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) { return;
}
  x = sqlite3_value_double(argv[0]);
  
// ABS Label 900
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 900);
}
sqlite3_result_int(context, x<0.0 ? -1 : x>0.0 ? +1 : 0);
}

/*
** All of the FuncDef structures in the aBuiltinFunc[] array above
** to the global function hash table.  This occurs at start-time (as
** a consequence of calling sqlite3_initialize()).
**
** After this routine runs
*/
void sqlite3RegisterBuiltinFunctions(void){
  /*
  ** The following array holds FuncDef structures for all of the functions
  ** defined in this file.
  **
  ** The array cannot be constant since changes are made to the
  ** FuncDef.pHash elements at start-time.  The elements of this array
  ** are read-only after initialization is complete.
  **
  ** For peak efficiency, put the most frequently used function last.
  */
  static FuncDef aBuiltinFunc[] = {
/***** Functions only available with SQLITE_TESTCTRL_INTERNAL_FUNCTIONS *****/
    TEST_FUNC(implies_nonnull_row, 2, INLINEFUNC_implies_nonnull_row, 0),
    TEST_FUNC(expr_compare,        2, INLINEFUNC_expr_compare,        0),
    TEST_FUNC(expr_implies_expr,   2, INLINEFUNC_expr_implies_expr,   0),
#ifdef SQLITE_DEBUG
    TEST_FUNC(affinity,          1, INLINEFUNC_affinity, 0),
#endif
/***** Regular functions *****/
#ifdef SQLITE_SOUNDEX
    FUNCTION(soundex,            1, 0, 0, soundexFunc      ),
#endif
#ifndef SQLITE_OMIT_LOAD_EXTENSION
    SFUNCTION(load_extension,    1, 0, 0, loadExt          ),
    SFUNCTION(load_extension,    2, 0, 0, loadExt          ),
#endif
#if SQLITE_USER_AUTHENTICATION
    FUNCTION(sqlite_crypt,       2, 0, 0, sqlite3CryptFunc ),
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
    DFUNCTION(sqlite_compileoption_used,1, 0, 0, compileoptionusedFunc  ),
    DFUNCTION(sqlite_compileoption_get, 1, 0, 0, compileoptiongetFunc  ),
#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */
    INLINE_FUNC(unlikely,        1, INLINEFUNC_unlikely, SQLITE_FUNC_UNLIKELY),
    INLINE_FUNC(likelihood,      2, INLINEFUNC_unlikely, SQLITE_FUNC_UNLIKELY),
    INLINE_FUNC(likely,          1, INLINEFUNC_unlikely, SQLITE_FUNC_UNLIKELY),
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
    FUNCTION2(sqlite_offset,     1, 0, 0, noopFunc,  SQLITE_FUNC_OFFSET|
                                                     SQLITE_FUNC_TYPEOF),
#endif
    FUNCTION(ltrim,              1, 1, 0, trimFunc         ),
    FUNCTION(ltrim,              2, 1, 0, trimFunc         ),
    FUNCTION(rtrim,              1, 2, 0, trimFunc         ),
    FUNCTION(rtrim,              2, 2, 0, trimFunc         ),
    FUNCTION(trim,               1, 3, 0, trimFunc         ),
    FUNCTION(trim,               2, 3, 0, trimFunc         ),
    FUNCTION(min,               -1, 0, 1, minmaxFunc       ),
    FUNCTION(min,                0, 0, 1, 0                ),
    WAGGREGATE(min, 1, 0, 1, minmaxStep, minMaxFinalize, minMaxValue, 0,
                                          SQLITE_FUNC_MINMAX ),
    FUNCTION(max,               -1, 1, 1, minmaxFunc       ),
    FUNCTION(max,                0, 1, 1, 0                ),
    WAGGREGATE(max, 1, 1, 1, minmaxStep, minMaxFinalize, minMaxValue, 0,
                                          SQLITE_FUNC_MINMAX ),
    FUNCTION2(typeof,            1, 0, 0, typeofFunc,  SQLITE_FUNC_TYPEOF),
    FUNCTION2(length,            1, 0, 0, lengthFunc,  SQLITE_FUNC_LENGTH),
    FUNCTION(instr,              2, 0, 0, instrFunc        ),
    FUNCTION(printf,            -1, 0, 0, printfFunc       ),
    FUNCTION(unicode,            1, 0, 0, unicodeFunc      ),
    FUNCTION(char,              -1, 0, 0, charFunc         ),
    FUNCTION(abs,                1, 0, 0, absFunc          ),
#ifndef SQLITE_OMIT_FLOATING_POINT
    FUNCTION(round,              1, 0, 0, roundFunc        ),
    FUNCTION(round,              2, 0, 0, roundFunc        ),
#endif
    FUNCTION(upper,              1, 0, 0, upperFunc        ),
    FUNCTION(lower,              1, 0, 0, lowerFunc        ),
    FUNCTION(hex,                1, 0, 0, hexFunc          ),
    INLINE_FUNC(ifnull,          2, INLINEFUNC_coalesce, 0 ),
    VFUNCTION(random,            0, 0, 0, randomFunc       ),
    VFUNCTION(randomblob,        1, 0, 0, randomBlob       ),
    FUNCTION(nullif,             2, 0, 1, nullifFunc       ),
    DFUNCTION(sqlite_version,    0, 0, 0, versionFunc      ),
    DFUNCTION(sqlite_source_id,  0, 0, 0, sourceidFunc     ),
    FUNCTION(sqlite_log,         2, 0, 0, errlogFunc       ),
    FUNCTION(quote,              1, 0, 0, quoteFunc        ),
    VFUNCTION(last_insert_rowid, 0, 0, 0, last_insert_rowid),
    VFUNCTION(changes,           0, 0, 0, changes          ),
    VFUNCTION(total_changes,     0, 0, 0, total_changes    ),
    FUNCTION(replace,            3, 0, 0, replaceFunc      ),
    FUNCTION(zeroblob,           1, 0, 0, zeroblobFunc     ),
    FUNCTION(substr,             2, 0, 0, substrFunc       ),
    FUNCTION(substr,             3, 0, 0, substrFunc       ),
    FUNCTION(substring,          2, 0, 0, substrFunc       ),
    FUNCTION(substring,          3, 0, 0, substrFunc       ),
    WAGGREGATE(sum,   1,0,0, sumStep, sumFinalize, sumFinalize, sumInverse, 0),
    WAGGREGATE(total, 1,0,0, sumStep,totalFinalize,totalFinalize,sumInverse, 0),
    WAGGREGATE(avg,   1,0,0, sumStep, avgFinalize, avgFinalize, sumInverse, 0),
    WAGGREGATE(count, 0,0,0, countStep, 
        countFinalize, countFinalize, countInverse, SQLITE_FUNC_COUNT  ),
    WAGGREGATE(count, 1,0,0, countStep, 
        countFinalize, countFinalize, countInverse, 0  ),
    WAGGREGATE(group_concat, 1, 0, 0, groupConcatStep, 
        groupConcatFinalize, groupConcatValue, groupConcatInverse, 0),
    WAGGREGATE(group_concat, 2, 0, 0, groupConcatStep, 
        groupConcatFinalize, groupConcatValue, groupConcatInverse, 0),
  
    LIKEFUNC(glob, 2, &globInfo, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),
#ifdef SQLITE_CASE_SENSITIVE_LIKE
    LIKEFUNC(like, 2, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),
    LIKEFUNC(like, 3, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),
#else
    LIKEFUNC(like, 2, &likeInfoNorm, SQLITE_FUNC_LIKE),
    LIKEFUNC(like, 3, &likeInfoNorm, SQLITE_FUNC_LIKE),
#endif
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
    FUNCTION(unknown,           -1, 0, 0, unknownFunc      ),
#endif
    FUNCTION(coalesce,           1, 0, 0, 0                ),
    FUNCTION(coalesce,           0, 0, 0, 0                ),
#ifdef SQLITE_ENABLE_MATH_FUNCTIONS
    MFUNCTION(ceil,              1, xCeil,     ceilingFunc ),
    MFUNCTION(ceiling,           1, xCeil,     ceilingFunc ),
    MFUNCTION(floor,             1, xFloor,    ceilingFunc ),
#if SQLITE_HAVE_C99_MATH_FUNCS
    MFUNCTION(trunc,             1, trunc,     ceilingFunc ),
#endif
    FUNCTION(ln,                 1, 0, 0,      logFunc     ),
    FUNCTION(log,                1, 1, 0,      logFunc     ),
    FUNCTION(log10,              1, 1, 0,      logFunc     ),
    FUNCTION(log2,               1, 2, 0,      logFunc     ),
    FUNCTION(log,                2, 0, 0,      logFunc     ),
    MFUNCTION(exp,               1, exp,       math1Func   ),
    MFUNCTION(pow,               2, pow,       math2Func   ),
    MFUNCTION(power,             2, pow,       math2Func   ),
    MFUNCTION(mod,               2, fmod,      math2Func   ),
    MFUNCTION(acos,              1, acos,      math1Func   ),
    MFUNCTION(asin,              1, asin,      math1Func   ),
    MFUNCTION(atan,              1, atan,      math1Func   ),
    MFUNCTION(atan2,             2, atan2,     math2Func   ),
    MFUNCTION(cos,               1, cos,       math1Func   ),
    MFUNCTION(sin,               1, sin,       math1Func   ),
    MFUNCTION(tan,               1, tan,       math1Func   ),
    MFUNCTION(cosh,              1, cosh,      math1Func   ),
    MFUNCTION(sinh,              1, sinh,      math1Func   ),
    MFUNCTION(tanh,              1, tanh,      math1Func   ),
#if SQLITE_HAVE_C99_MATH_FUNCS
    MFUNCTION(acosh,             1, acosh,     math1Func   ),
    MFUNCTION(asinh,             1, asinh,     math1Func   ),
    MFUNCTION(atanh,             1, atanh,     math1Func   ),
#endif
    MFUNCTION(sqrt,              1, sqrt,      math1Func   ),
    MFUNCTION(radians,           1, degToRad,  math1Func   ),
    MFUNCTION(degrees,           1, radToDeg,  math1Func   ),
    FUNCTION(pi,                 0, 0, 0,      piFunc      ),
#endif /* SQLITE_ENABLE_MATH_FUNCTIONS */
    FUNCTION(sign,               1, 0, 0,      signFunc    ),
    INLINE_FUNC(coalesce,       -1, INLINEFUNC_coalesce, 0 ),
    INLINE_FUNC(iif,             3, INLINEFUNC_iif,      0 ),
  };
#ifndef SQLITE_OMIT_ALTERTABLE
  sqlite3AlterFunctions();
#endif
  sqlite3WindowFunctions();
  sqlite3RegisterDateTimeFunctions();
  sqlite3InsertBuiltinFuncs(aBuiltinFunc, ArraySize(aBuiltinFunc));

#if 0  /* Enable to print out how the built-in functions are hashed */
  {
    int i;
    FuncDef *p;
    for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){
      printf("FUNC-HASH %02d:", i);
      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash){
        int n = sqlite3Strlen30(p->zName);
        int h = p->zName[0] + n;
        printf(" %s(%d)", p->zName, h);
      }
      printf("\n");
    }
  }
#endif
}
