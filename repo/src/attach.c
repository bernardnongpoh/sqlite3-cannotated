/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2003 April 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used to implement the ATTACH and DETACH commands.
*/
#include "sqliteInt.h"

#ifndef SQLITE_OMIT_ATTACH
/*
** Resolve an expression that was part of an ATTACH or DETACH statement. This
** is slightly different from resolving a normal SQL expression, because simple
** identifiers are treated as strings, not possible column names or aliases.
**
** i.e. if the parser sees:
**
**     ATTACH DATABASE abc AS def
**
** it treats the two expressions as literal strings 'abc' and 'def' instead of
** looking for columns of the same name.
**
** This only applies to the root node of pExpr, so the statement:
**
**     ATTACH DATABASE abc||def AS 'db2'
**
** will fail because neither abc or def can be resolved.
*/
static int resolveAttachExpr(NameContext *pName, Expr *pExpr)
{
  int rc = SQLITE_OK;
  
// ABS Label 7
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
if( pExpr ){
    
// ROR Label 8
if((pExpr->op == 59) != (pExpr->op != 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
if( pExpr->op!=TK_ID ){
      rc = sqlite3ResolveExprNames(pName, pExpr);
    }else{
      pExpr->op = TK_STRING;
    }
  }
  
// ABS Label 9
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
return rc;
}

/*
** Return true if zName points to a name that may be used to refer to
** database iDb attached to handle db.
*/
int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName){
  return (
      sqlite3StrICmp(db->aDb[iDb].zDbSName, zName)==0
   || (iDb==0 && sqlite3StrICmp("main", zName)==0)
  );
}

/*
** An SQL user-function registered to do the work of an ATTACH statement. The
** three arguments to the function come directly from an attach statement:
**
**     ATTACH DATABASE x AS y KEY z
**
**     SELECT sqlite_attach(x, y, z)
**
** If the optional "KEY z" syntax is omitted, an SQL NULL is passed as the
** third argument.
**
** If the db->init.reopenMemdb flags is set, then instead of attaching a
** new database, close the database on db->init.iDb and reopen it as an
** empty MemDB.
*/
static void attachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  int i;
  int rc = 0;
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zName;
  const char *zFile;
  char *zPath = 0;
  char *zErr = 0;
  unsigned int flags;
  Db *aNew;                 /* New array of Db pointers */
  Db *pNew;                 /* Db object for the newly attached database */
  char *zErrDyn = 0;
  sqlite3_vfs *pVfs;

  UNUSED_PARAMETER(NotUsed);
  zFile = (const char *)sqlite3_value_text(argv[0]);
  zName = (const char *)sqlite3_value_text(argv[1]);
  
// ABS Label 11
if(zFile < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ROR Label 12
if((zFile != 0) != (zFile == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
if( zFile==0 ) { zFile = "";
}
  
// ABS Label 13
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// ROR Label 14
if((zName != 0) != (zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
if( zName==0 ) { zName = "";
}

#ifndef SQLITE_OMIT_DESERIALIZE
# define REOPEN_AS_MEMDB(db)  (db->init.reopenMemdb)
#else
# define REOPEN_AS_MEMDB(db)  (0)
#endif

  
// ABS Label 15
if((db->init.reopenMemdb) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
if( REOPEN_AS_MEMDB(db) ){
    /* This is not a real ATTACH.  Instead, this routine is being called
    ** from sqlite3_deserialize() to close database db->init.iDb and
    ** reopen it as a MemDB */
    pVfs = sqlite3_vfs_find("memdb");
    
// ABS Label 16
if(pVfs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ROR Label 17
if((pVfs != 0) != (pVfs == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
if( pVfs==0 ) { return;
}
    pNew = &db->aDb[db->init.iDb];
    
// ABS Label 18
if(pNew->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
if( pNew->pBt ) { 
// ABS Label 19
if(pNew->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3BtreeClose(pNew->pBt);
}
    pNew->pBt = 0;
    pNew->pSchema = 0;
    rc = sqlite3BtreeOpen(pVfs, "x\0", db, &pNew->pBt, 0, SQLITE_OPEN_MAIN_DB);
  }else{
    /* This is a real ATTACH
    **
    ** Check for the following errors:
    **
    **     * Too many attached databases,
    **     * Transaction currently open
    **     * Specified database name already being used.
    */
    
// ABS Label 20
if(db->aLimit[7] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
// ABS Label 21
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}

// AOR Label 22
if(db->aLimit[7] - 2 != db->aLimit[7] + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 22);
}
// AOR Label 23
if(db->aLimit[7] / 2 != db->aLimit[7] + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 23);
}
// AOR Label 24
if(db->aLimit[7] * 2 != db->aLimit[7] + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 24);
}

// ROR Label 25
if((db->nDb < db->aLimit[7] + 2) != (db->nDb >= db->aLimit[7] + 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 25);
}
// ROR Label 26
if((db->nDb > db->aLimit[7] + 2) != (db->nDb >= db->aLimit[7] + 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
// ROR Label 27
if((db->nDb <= db->aLimit[7] + 2) != (db->nDb >= db->aLimit[7] + 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){
      zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", 
        db->aLimit[SQLITE_LIMIT_ATTACHED]
      );
      goto attach_error;
    }
    i = 0;

// ABS Label 28
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}
// ABS Label 29
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}

// ROR Label 30
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
// ROR Label 31
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
for(; i<db->nDb; i++){
      assert( zName );
      if( sqlite3DbIsNamed(db, i, zName) ){
        zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
        goto attach_error;
      }
    };
// ABS Label 33
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
// ABS Label 34
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}

// ROR Label 35
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
// ROR Label 36
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
// ROR Label 37
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}

  
    /* Allocate the new entry in the db->aDb[] array and initialize the schema
    ** hash tables.
    */
    
// ABS Label 38
if(db->aDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}

// ROR Label 39
if((db->aDb != db->aDbStatic) != (db->aDb == db->aDbStatic))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
if( db->aDb==db->aDbStatic ){
      aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );
      
// ABS Label 43
if(aNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// ROR Label 44
if((aNew != 0) != (aNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
if( aNew==0 ) { return;
}
      
// AOR Label 40
if(sizeof (db->aDb[0]) - 2 != sizeof (db->aDb[0]) * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 40);
}
// AOR Label 41
if(sizeof (db->aDb[0]) + 2 != sizeof (db->aDb[0]) * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 41);
}
// AOR Label 42
if(sizeof (db->aDb[0]) / 2 != sizeof (db->aDb[0]) * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 42);
}
memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
    }else{
      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );
      
// ABS Label 45
if(aNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// ROR Label 46
if((aNew != 0) != (aNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
if( aNew==0 ) { return;
}
    }
    db->aDb = aNew;
    pNew = &db->aDb[db->nDb];
    memset(pNew, 0, sizeof(*pNew));
  
    /* Open the database file. If the btree is successfully opened, use
    ** it to obtain the database schema. At this point the schema may
    ** or may not be initialized.
    */
    flags = db->openFlags;
    rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);
    
// ABS Label 47
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ROR Label 48
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
if( rc!=SQLITE_OK ){
      
// ABS Label 50
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}

// ROR Label 51
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
if( rc==SQLITE_NOMEM ) { 
// ABS Label 52
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
sqlite3OomFault(db);
}
      
// ABS Label 49
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
sqlite3_result_error(context, zErr, -1);
      sqlite3_free(zErr);
      return;
    }
    assert( pVfs );
    flags |= SQLITE_OPEN_MAIN_DB;
    rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);
    db->nDb++;
    pNew->zDbSName = sqlite3DbStrDup(db, zName);
  }
  db->noSharedCache = 0;
  
// ABS Label 53
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// ROR Label 54
if((rc != 19) != (rc == 19))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
if( rc==SQLITE_CONSTRAINT ){
    rc = SQLITE_ERROR;
    zErrDyn = sqlite3MPrintf(db, "database is already attached");
  }else { 
// ABS Label 55
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}

// ROR Label 56
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
if( rc==SQLITE_OK ){
    Pager *pPager;
    pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);
    if( !pNew->pSchema ){
      rc = SQLITE_NOMEM_BKPT;
    }else { 
// COR Label 62
if((pNew->pSchema->file_format || pNew->pSchema->enc != ((db)->enc)) != (pNew->pSchema->file_format && pNew->pSchema->enc != ((db)->enc)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 62);
}

// ROR Label 63
if((pNew->pSchema->enc == ((db)->enc)) != (pNew->pSchema->enc != ((db)->enc)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}

// MCC Label 64
if(pNew->pSchema->file_format && pNew->pSchema->enc != ((db)->enc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 64);
}
// MCC Label 65
if(pNew->pSchema->file_format && !(pNew->pSchema->enc != ((db)->enc)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 65);
}
// MCC Label 66
if(!(pNew->pSchema->file_format) && pNew->pSchema->enc != ((db)->enc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
// MCC Label 67
if(!(pNew->pSchema->file_format) && !(pNew->pSchema->enc != ((db)->enc)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 67);
}
if( pNew->pSchema->file_format && pNew->pSchema->enc!=ENC(db) ){
      zErrDyn = sqlite3MPrintf(db, 
        "attached databases must use the same text encoding as main database");
      rc = SQLITE_ERROR;
    };}

    
// ABS Label 57
if(pNew->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
sqlite3BtreeEnter(pNew->pBt);
    pPager = sqlite3BtreePager(pNew->pBt);
    
// ABS Label 58
if(pPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
sqlite3PagerLockingMode(pPager, db->dfltLockMode);
    
// ABS Label 59
if(pNew->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
sqlite3BtreeSecureDelete(pNew->pBt,
                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
    
// ABS Label 60
if(pNew->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}
sqlite3BtreeSetPagerFlags(pNew->pBt,
                      PAGER_SYNCHRONOUS_FULL | (db->flags & PAGER_FLAGS_MASK));
#endif
    
// ABS Label 61
if(pNew->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 61);
}
sqlite3BtreeLeave(pNew->pBt);
  };}

  pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
  
// ABS Label 68
if(pNew->zDbSName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}
// ABS Label 69
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}

// COR Label 70
if((rc == 0 || pNew->zDbSName == 0) != (rc == 0 && pNew->zDbSName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 70);
}

// ROR Label 71
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
// ROR Label 72
if((pNew->zDbSName != 0) != (pNew->zDbSName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}

// MCC Label 73
if(rc == 0 && pNew->zDbSName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
// MCC Label 74
if(rc == 0 && !(pNew->zDbSName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 74);
}
// MCC Label 75
if(!(rc == 0) && pNew->zDbSName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 75);
}
// MCC Label 76
if(!(rc == 0) && !(pNew->zDbSName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 76);
}
if( rc==SQLITE_OK && pNew->zDbSName==0 ){
    rc = SQLITE_NOMEM_BKPT;
  }
  
// ABS Label 10
if(zPath < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
sqlite3_free_filename( zPath );

  /* If the file was opened successfully, read the schema for the new database.
  ** If this fails, or if opening the file failed, then close the file and 
  ** remove the entry from the db->aDb[] array. i.e. put everything back the
  ** way we found it.
  */
  
// ABS Label 77
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
if( rc==SQLITE_OK ){
    
// ABS Label 79
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 79);
}
sqlite3BtreeEnterAll(db);
    db->init.iDb = 0;
    db->mDbFlags &= ~(DBFLAG_SchemaKnownOk);
    if( !REOPEN_AS_MEMDB(db) ){
      rc = sqlite3Init(db, &zErrDyn);
    }
    
// ABS Label 80
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}
sqlite3BtreeLeaveAll(db);
    assert( zErrDyn==0 || rc!=SQLITE_OK );
  }
#ifdef SQLITE_USER_AUTHENTICATION
  if( rc==SQLITE_OK && !REOPEN_AS_MEMDB(db) ){
    u8 newAuth = 0;
    rc = sqlite3UserAuthCheckLogin(db, zName, &newAuth);
    if( newAuth<db->auth.authLevel ){
      rc = SQLITE_AUTH_USER;
    }
  }
#endif
  
// ABS Label 81
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
if( rc ){
    if( !REOPEN_AS_MEMDB(db) ){
      
// ABS Label 82
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}

// AOR Label 83
if(db->nDb / 1 != db->nDb - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 83);
}
// AOR Label 84
if(db->nDb + 1 != db->nDb - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 84);
}
// AOR Label 85
if(db->nDb * 1 != db->nDb - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 85);
}
int iDb = db->nDb - 1;
      assert( iDb>=2 );
      
// ABS Label 87
if(db->aDb[iDb].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
if( db->aDb[iDb].pBt ){
        
// ABS Label 88
if(db->aDb[iDb].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
sqlite3BtreeClose(db->aDb[iDb].pBt);
        db->aDb[iDb].pBt = 0;
        db->aDb[iDb].pSchema = 0;
      }
      
// ABS Label 86
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
sqlite3ResetAllSchemasOfConnection(db);
      db->nDb = iDb;
      
// ABS Label 89
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}

// COR Label 90
if((rc == 7 && rc == (10 | (12 << 8))) != (rc == 7 || rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 90);
}

// ROR Label 91
if((rc != 7) != (rc == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((rc != (10 | (12 << 8))) != (rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}

// MCC Label 93
if(rc == 7 && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 93);
}
// MCC Label 94
if(rc == 7 && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(!(rc == 7) && rc == (10 | (12 << 8)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(!(rc == 7) && !(rc == (10 | (12 << 8))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){
        
// ABS Label 97
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}
sqlite3OomFault(db);
        
// ABS Label 98
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
sqlite3DbFree(db, zErrDyn);
        zErrDyn = sqlite3MPrintf(db, "out of memory");
      }else { 
// ABS Label 99
if(zErrDyn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}

// ROR Label 100
if((zErrDyn != 0) != (zErrDyn == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}
if( zErrDyn==0 ){
        zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
      };}

    }
    goto attach_error;
  }
  
  return;

attach_error:
  /* Return an error if we get here */
  
// ABS Label 101
if(zErrDyn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
if( zErrDyn ){
    
// ABS Label 102
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
sqlite3_result_error(context, zErrDyn, -1);
    
// ABS Label 103
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
sqlite3DbFree(db, zErrDyn);
  }
  
// ABS Label 104
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
if( rc ) { 
// ABS Label 105
if(context < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// ABS Label 106
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}
sqlite3_result_error_code(context, rc);
}
}

/*
** An SQL user-function registered to do the work of an DETACH statement. The
** three arguments to the function come directly from a detach statement:
**
**     DETACH DATABASE x
**
**     SELECT sqlite_detach(x)
*/
static void detachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  const char *zName = (const char *)sqlite3_value_text(argv[0]);
  sqlite3 *db = sqlite3_context_db_handle(context);
  int i;
  Db *pDb = 0;
  HashElem *pEntry;
  char zErr[128];

  UNUSED_PARAMETER(NotUsed);

  
// ABS Label 109
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}

// ROR Label 110
if((zName != 0) != (zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
if( zName==0 ) { zName = "";
}
  i = 0;

// ABS Label 111
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 111);
}
// ABS Label 112
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ROR Label 113
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
// ROR Label 114
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}
// ROR Label 115
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
for(; i<db->nDb; i++){
    pDb = &db->aDb[i];
    
// ABS Label 121
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}

// ROR Label 122
if((pDb->pBt != 0) != (pDb->pBt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 122);
}
if( pDb->pBt==0 ) { continue;
}
    if( sqlite3DbIsNamed(db, i, zName) ) { break;
}
  };
// ABS Label 116
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
// ABS Label 117
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}

// ROR Label 118
if((i <= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
// ROR Label 119
if((i > db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((i >= db->nDb) != (i < db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}


  
// ABS Label 123
if(db->nDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}
// ABS Label 124
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}

// ROR Label 125
if((i < db->nDb) != (i >= db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}
// ROR Label 126
if((i > db->nDb) != (i >= db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
// ROR Label 127
if((i <= db->nDb) != (i >= db->nDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 127);
}
if( i>=db->nDb ){
    
// ABS Label 128
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 128);
}
sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName);
    goto detach_error;
  }
  
// ABS Label 129
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}

// ROR Label 130
if((i <= 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if((i > 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}
// ROR Label 132
if((i >= 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
if( i<2 ){
    
// ABS Label 133
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName);
    goto detach_error;
  }
  if( sqlite3BtreeTxnState(pDb->pBt)!=SQLITE_TXN_NONE
   || sqlite3BtreeIsInBackup(pDb->pBt)
  ){
    
// ABS Label 134
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}
sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);
    goto detach_error;
  }

  /* If any TEMP triggers reference the schema being detached, move those
  ** triggers to reference the TEMP schema itself. */
  assert( db->aDb[1].pSchema );
  pEntry = sqliteHashFirst(&db->aDb[1].pSchema->trigHash);
  
// ABS Label 135
if(pEntry < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}
while( pEntry ){
    Trigger *pTrig = (Trigger*)sqliteHashData(pEntry);
    
// ABS Label 137
if(pDb->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
// ABS Label 138
if(pTrig->pTabSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// ROR Label 139
if((pTrig->pTabSchema != pDb->pSchema) != (pTrig->pTabSchema == pDb->pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
if( pTrig->pTabSchema==pDb->pSchema ){
      pTrig->pTabSchema = pTrig->pSchema;
    }
    pEntry = sqliteHashNext(pEntry);
  };
// ABS Label 136
if(pEntry < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}


  
// ABS Label 107
if(pDb->pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
sqlite3BtreeClose(pDb->pBt);
  pDb->pBt = 0;
  pDb->pSchema = 0;
  
// ABS Label 108
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}
sqlite3CollapseDatabaseArray(db);
  return;

detach_error:
  sqlite3_result_error(context, zErr, -1);
}

/*
** This procedure generates VDBE code for a single invocation of either the
** sqlite_detach() or sqlite_attach() SQL user functions.
*/
static void codeAttach(
  Parse *pParse,       /* The parser context */
  int type,            /* Either SQLITE_ATTACH or SQLITE_DETACH */
  FuncDef const *pFunc,/* FuncDef wrapper for detachFunc() or attachFunc() */
  Expr *pAuthArg,      /* Expression to pass to authorization callback */
  Expr *pFilename,     /* Name of database file */
  Expr *pDbname,       /* Name of the database to use internally */
  Expr *pKey           /* Database key for encryption extension */
){
  int rc;
  NameContext sName;
  Vdbe *v;
  
// ABS Label 140
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
sqlite3* db = pParse->db;
  int regArgs;

  
// ABS Label 160
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
if( pParse->nErr ) { goto attach_end;
}
  memset(&sName, 0, sizeof(NameContext));
  sName.pParse = pParse;

  if( 
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||
      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))
  ){
    goto attach_end;
  }

#ifndef SQLITE_OMIT_AUTHORIZATION
  
// ABS Label 161
if(pAuthArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}
if( pAuthArg ){
    char *zAuthArg;
    
// ROR Label 162
if((pAuthArg->op != 116) != (pAuthArg->op == 116))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
if( pAuthArg->op==TK_STRING ){
      zAuthArg = pAuthArg->u.zToken;
    }else{
      zAuthArg = 0;
    }
    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);
    
// ABS Label 163
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ROR Label 164
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
if(rc!=SQLITE_OK ){
      goto attach_end;
    }
  }
#endif /* SQLITE_OMIT_AUTHORIZATION */


  v = sqlite3GetVdbe(pParse);
  regArgs = sqlite3GetTempRange(pParse, 4);
  
// ABS Label 141
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ABS Label 142
if(pFilename < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}

// ABS Label 143
if(regArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
sqlite3ExprCode(pParse, pFilename, regArgs);
  
// ABS Label 144
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}

// ABS Label 145
if(pDbname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 145);
}

// ABS Label 146
if(regArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// AOR Label 147
if(regArgs - 1 != regArgs + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 147);
}
// AOR Label 148
if(regArgs / 1 != regArgs + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 148);
}
// AOR Label 149
if(regArgs * 1 != regArgs + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 149);
}
sqlite3ExprCode(pParse, pDbname, regArgs+1);
  
// ABS Label 150
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}

// ABS Label 151
if(pKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// ABS Label 152
if(regArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// AOR Label 153
if(regArgs - 2 != regArgs + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 153);
}
// AOR Label 154
if(regArgs / 2 != regArgs + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 154);
}
// AOR Label 155
if(regArgs * 2 != regArgs + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 155);
}
sqlite3ExprCode(pParse, pKey, regArgs+2);

  assert( v || db->mallocFailed );
  
// ABS Label 165
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}
if( v ){
    
// ABS Label 166
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}

// ABS Label 167
if(regArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}

// AOR Label 168
if(regArgs + 3 / pFunc->nArg != regArgs + 3 - pFunc->nArg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 168);
}
// AOR Label 169
if(regArgs + 3 + pFunc->nArg != regArgs + 3 - pFunc->nArg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 169);
}
// AOR Label 170
if(regArgs + 3 * pFunc->nArg != regArgs + 3 - pFunc->nArg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 170);
}
// AOR Label 171
if(regArgs - 3 != regArgs + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 171);
}
// AOR Label 172
if(regArgs / 3 != regArgs + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 172);
}
// AOR Label 173
if(regArgs * 3 != regArgs + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 173);
}

// ABS Label 174
if(regArgs < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// AOR Label 175
if(regArgs - 3 != regArgs + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 175);
}
// AOR Label 176
if(regArgs / 3 != regArgs + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 176);
}
// AOR Label 177
if(regArgs * 3 != regArgs + 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 177);
}

// ABS Label 178
if(pFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}
sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,
                               pFunc->nArg, pFunc, 0);
    /* Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this
    ** statement only). For DETACH, set it to false (expire all existing
    ** statements).
    */
    
// ABS Label 179
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}
sqlite3VdbeAddOp1(v, OP_Expire, (type==SQLITE_ATTACH));
  }
  
attach_end:
  sqlite3ExprDelete(db, pFilename);
  
// ABS Label 156
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}

// ABS Label 157
if(pDbname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
sqlite3ExprDelete(db, pDbname);
  
// ABS Label 158
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// ABS Label 159
if(pKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}
sqlite3ExprDelete(db, pKey);
}

/*
** Called by the parser to compile a DETACH statement.
**
**     DETACH pDbname
*/
void sqlite3Detach(Parse *pParse, Expr *pDbname){
  static const FuncDef detach_func = {
    1,                /* nArg */
    SQLITE_UTF8,      /* funcFlags */
    0,                /* pUserData */
    0,                /* pNext */
    detachFunc,       /* xSFunc */
    0,                /* xFinalize */
    0, 0,             /* xValue, xInverse */
    "sqlite_detach",  /* zName */
    {0}
  };
  
// ABS Label 180
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 180);
}

// ABS Label 181
if(pDbname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}

// ABS Label 182
if(pDbname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}
codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname);
}

/*
** Called by the parser to compile an ATTACH statement.
**
**     ATTACH p AS pDbname KEY pKey
*/
void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){
  static const FuncDef attach_func = {
    3,                /* nArg */
    SQLITE_UTF8,      /* funcFlags */
    0,                /* pUserData */
    0,                /* pNext */
    attachFunc,       /* xSFunc */
    0,                /* xFinalize */
    0, 0,             /* xValue, xInverse */
    "sqlite_attach",  /* zName */
    {0}
  };
  
// ABS Label 183
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 183);
}

// ABS Label 184
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 184);
}

// ABS Label 185
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}

// ABS Label 186
if(pDbname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ABS Label 187
if(pKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}
codeAttach(pParse, SQLITE_ATTACH, &attach_func, p, p, pDbname, pKey);
}
#endif /* SQLITE_OMIT_ATTACH */

/*
** Expression callback used by sqlite3FixAAAA() routines.
*/
static int fixExprCb(Walker *p, Expr *pExpr){
  
// ABS Label 188
if(p->u.pFix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}
DbFixer *pFix = p->u.pFix;
  if( !pFix->bTemp ) { ExprSetProperty(pExpr, EP_FromDDL);
}
  
// ROR Label 189
if((pExpr->op != 155) != (pExpr->op == 155))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
if( pExpr->op==TK_VARIABLE ){
    
// ABS Label 190
if(pFix->pParse->db->init.busy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
if( pFix->pParse->db->init.busy ){
      pExpr->op = TK_NULL;
    }else{
      
// ABS Label 191
if(pFix->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// ABS Label 192
if(pFix->zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}
sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
      return WRC_Abort;
    }
  }
  return WRC_Continue;
}

/*
** Select callback used by sqlite3FixAAAA() routines.
*/
static int fixSelectCb(Walker *p, Select *pSelect){
  
// ABS Label 193
if(p->u.pFix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}
DbFixer *pFix = p->u.pFix;
  int i;
  SrcItem *pItem;
  
// ABS Label 194
if(pFix->pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}
sqlite3 *db = pFix->pParse->db;
  int iDb = sqlite3FindDbName(db, pFix->zDb);
  
// ABS Label 195
if(pSelect->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}
SrcList *pList = pSelect->pSrc;

  
// MCC Label 196
if(( pList == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(( !(pList == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
if( NEVER(pList==0) ) { return WRC_Continue;
}
  i = 0 , pItem = pList->a;

// ABS Label 198
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
// ABS Label 199
if(pList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}

// ROR Label 200
if((i <= pList->nSrc) != (i < pList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
// ROR Label 201
if((i > pList->nSrc) != (i < pList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
// ROR Label 202
if((i >= pList->nSrc) != (i < pList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
for(; i<pList->nSrc; i++, pItem++){
    
// ROR Label 208
if((pFix->bTemp != 0) != (pFix->bTemp == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
if( pFix->bTemp==0 ){
      
// ABS Label 209
if(pItem->zDatabase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 209);
}
if( pItem->zDatabase ){
        if( iDb!=sqlite3FindDbName(db, pItem->zDatabase) ){
          
// ABS Label 211
if(pFix->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}

// ABS Label 212
if(pFix->zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// ABS Label 213
if(pFix->pName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}

// ABS Label 214
if(pItem->zDatabase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}
sqlite3ErrorMsg(pFix->pParse,
              "%s %T cannot reference objects in database %s",
              pFix->zType, pFix->pName, pItem->zDatabase);
          return WRC_Abort;
        }
        
// ABS Label 210
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 210);
}
sqlite3DbFree(db, pItem->zDatabase);
        pItem->zDatabase = 0;
        pItem->fg.notCte = 1;
      }
      pItem->pSchema = pFix->pSchema;
      pItem->fg.fromDDL = 1;
    }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
    if( sqlite3WalkExpr(&pFix->w, pList->a[i].pOn) ) { return WRC_Abort;
}
#endif
  };
// ABS Label 203
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}
// ABS Label 204
if(pList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}

// ROR Label 205
if((i <= pList->nSrc) != (i < pList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((i > pList->nSrc) != (i < pList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((i >= pList->nSrc) != (i < pList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}

  
// ABS Label 215
if(pSelect->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
if( pSelect->pWith ){
    i = 0;

// ABS Label 216
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}
// ABS Label 217
if(pSelect->pWith->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}

// ROR Label 218
if((i <= pSelect->pWith->nCte) != (i < pSelect->pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
// ROR Label 219
if((i > pSelect->pWith->nCte) != (i < pSelect->pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
// ROR Label 220
if((i >= pSelect->pWith->nCte) != (i < pSelect->pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 220);
}
for(; i<pSelect->pWith->nCte; i++){
      if( sqlite3WalkSelect(p, pSelect->pWith->a[i].pSelect) ){
        return WRC_Abort;
      }
    };
// ABS Label 221
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
// ABS Label 222
if(pSelect->pWith->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}

// ROR Label 223
if((i <= pSelect->pWith->nCte) != (i < pSelect->pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
// ROR Label 224
if((i > pSelect->pWith->nCte) != (i < pSelect->pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 224);
}
// ROR Label 225
if((i >= pSelect->pWith->nCte) != (i < pSelect->pWith->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 225);
}

  }
  return WRC_Continue;
}

/*
** Initialize a DbFixer structure.  This routine must be called prior
** to passing the structure to one of the sqliteFixAAAA() routines below.
*/
void sqlite3FixInit(
  DbFixer *pFix,      /* The fixer to be initialized */
  Parse *pParse,      /* Error messages will be written here */
  int iDb,            /* This is the database that must be used */
  const char *zType,  /* "view", "trigger", or "index" */
  const Token *pName  /* Name of the view, trigger, or index */
){
  
// ABS Label 226
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
sqlite3 *db = pParse->db;
  assert( db->nDb>iDb );
  pFix->pParse = pParse;
  pFix->zDb = db->aDb[iDb].zDbSName;
  pFix->pSchema = db->aDb[iDb].pSchema;
  pFix->zType = zType;
  pFix->pName = pName;
  pFix->bTemp = (iDb==1);
  pFix->w.pParse = pParse;
  pFix->w.xExprCallback = fixExprCb;
  pFix->w.xSelectCallback = fixSelectCb;
  pFix->w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;
  pFix->w.walkerDepth = 0;
  pFix->w.eCode = 0;
  pFix->w.u.pFix = pFix;
}

/*
** The following set of routines walk through the parse tree and assign
** a specific database to all table references where the database name
** was left unspecified in the original SQL statement.  The pFix structure
** must have been initialized by a prior call to sqlite3FixInit().
**
** These routines are used to make sure that an index, trigger, or
** view in one database does not refer to objects in a different database.
** (Exception: indices, triggers, and views in the TEMP database are
** allowed to refer to anything.)  If a reference is explicitly made
** to an object in a different database, an error message is added to
** pParse->zErrMsg and these routines return non-zero.  If everything
** checks out, these routines return 0.
*/
int sqlite3FixSrcList(
  DbFixer *pFix,       /* Context of the fixation */
  SrcList *pList       /* The Source list to check and modify */
){
  int res = 0;
  
// ABS Label 227
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
if( pList ){
    Select s; 
    memset(&s, 0, sizeof(s));
    s.pSrc = pList;
    res = sqlite3WalkSelect(&pFix->w, &s);
  }
  
// ABS Label 228
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}
return res;
}
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
int sqlite3FixSelect(
  DbFixer *pFix,       /* Context of the fixation */
  Select *pSelect      /* The SELECT statement to be fixed to one database */
){
  return sqlite3WalkSelect(&pFix->w, pSelect);
}
int sqlite3FixExpr(
  DbFixer *pFix,     /* Context of the fixation */
  Expr *pExpr        /* The expression to be fixed to one database */
){
  return sqlite3WalkExpr(&pFix->w, pExpr);
}
#endif

#ifndef SQLITE_OMIT_TRIGGER
int sqlite3FixTriggerStep(
  DbFixer *pFix,     /* Context of the fixation */
  TriggerStep *pStep /* The trigger step be fixed to one database */
){
  
// ABS Label 229
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}
while( pStep ){
    if( sqlite3WalkSelect(&pFix->w, pStep->pSelect)
     || sqlite3WalkExpr(&pFix->w, pStep->pWhere) 
     || sqlite3WalkExprList(&pFix->w, pStep->pExprList)
     || sqlite3FixSrcList(pFix, pStep->pFrom)
    ){
      return 1;
    }
#ifndef SQLITE_OMIT_UPSERT
    {
      Upsert *pUp;
      pUp = pStep->pUpsert;

// ABS Label 231
if(pUp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}
for(; pUp; pUp=pUp->pNextUpsert){
        if( sqlite3WalkExprList(&pFix->w, pUp->pUpsertTarget)
         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertTargetWhere)
         || sqlite3WalkExprList(&pFix->w, pUp->pUpsertSet)
         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertWhere)
        ){
          return 1;
        }
      };
// ABS Label 232
if(pUp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}

    }
#endif
    pStep = pStep->pNext;
  };
// ABS Label 230
if(pStep < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}


  return 0;
}
#endif
