/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2011-07-09
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code for the VdbeSorter object, used in concert with
** a VdbeCursor to sort large numbers of keys for CREATE INDEX statements
** or by SELECT statements with ORDER BY clauses that cannot be satisfied
** using indexes and without LIMIT clauses.
**
** The VdbeSorter object implements a multi-threaded external merge sort
** algorithm that is efficient even if the number of elements being sorted
** exceeds the available memory.
**
** Here is the (internal, non-API) interface between this module and the
** rest of the SQLite system:
**
**    sqlite3VdbeSorterInit()       Create a new VdbeSorter object.
**
**    sqlite3VdbeSorterWrite()      Add a single new row to the VdbeSorter
**                                  object.  The row is a binary blob in the
**                                  OP_MakeRecord format that contains both
**                                  the ORDER BY key columns and result columns
**                                  in the case of a SELECT w/ ORDER BY, or
**                                  the complete record for an index entry
**                                  in the case of a CREATE INDEX.
**
**    sqlite3VdbeSorterRewind()     Sort all content previously added.
**                                  Position the read cursor on the
**                                  first sorted element.
**
**    sqlite3VdbeSorterNext()       Advance the read cursor to the next sorted
**                                  element.
**
**    sqlite3VdbeSorterRowkey()     Return the complete binary blob for the
**                                  row currently under the read cursor.
**
**    sqlite3VdbeSorterCompare()    Compare the binary blob for the row
**                                  currently under the read cursor against
**                                  another binary blob X and report if
**                                  X is strictly less than the read cursor.
**                                  Used to enforce uniqueness in a
**                                  CREATE UNIQUE INDEX statement.
**
**    sqlite3VdbeSorterClose()      Close the VdbeSorter object and reclaim
**                                  all resources.
**
**    sqlite3VdbeSorterReset()      Refurbish the VdbeSorter for reuse.  This
**                                  is like Close() followed by Init() only
**                                  much faster.
**
** The interfaces above must be called in a particular order.  Write() can 
** only occur in between Init()/Reset() and Rewind().  Next(), Rowkey(), and
** Compare() can only occur in between Rewind() and Close()/Reset(). i.e.
**
**   Init()
**   for each record: Write()
**   Rewind()
**     Rowkey()/Compare()
**   Next() 
**   Close()
**
** Algorithm:
**
** Records passed to the sorter via calls to Write() are initially held 
** unsorted in main memory. Assuming the amount of memory used never exceeds
** a threshold, when Rewind() is called the set of records is sorted using
** an in-memory merge sort. In this case, no temporary files are required
** and subsequent calls to Rowkey(), Next() and Compare() read records 
** directly from main memory.
**
** If the amount of space used to store records in main memory exceeds the
** threshold, then the set of records currently in memory are sorted and
** written to a temporary file in "Packed Memory Array" (PMA) format.
** A PMA created at this point is known as a "level-0 PMA". Higher levels
** of PMAs may be created by merging existing PMAs together - for example
** merging two or more level-0 PMAs together creates a level-1 PMA.
**
** The threshold for the amount of main memory to use before flushing 
** records to a PMA is roughly the same as the limit configured for the
** page-cache of the main database. Specifically, the threshold is set to 
** the value returned by "PRAGMA main.page_size" multipled by 
** that returned by "PRAGMA main.cache_size", in bytes.
**
** If the sorter is running in single-threaded mode, then all PMAs generated
** are appended to a single temporary file. Or, if the sorter is running in
** multi-threaded mode then up to (N+1) temporary files may be opened, where
** N is the configured number of worker threads. In this case, instead of
** sorting the records and writing the PMA to a temporary file itself, the
** calling thread usually launches a worker thread to do so. Except, if
** there are already N worker threads running, the main thread does the work
** itself.
**
** The sorter is running in multi-threaded mode if (a) the library was built
** with pre-processor symbol SQLITE_MAX_WORKER_THREADS set to a value greater
** than zero, and (b) worker threads have been enabled at runtime by calling
** "PRAGMA threads=N" with some value of N greater than 0.
**
** When Rewind() is called, any data remaining in memory is flushed to a 
** final PMA. So at this point the data is stored in some number of sorted
** PMAs within temporary files on disk.
**
** If there are fewer than SORTER_MAX_MERGE_COUNT PMAs in total and the
** sorter is running in single-threaded mode, then these PMAs are merged
** incrementally as keys are retreived from the sorter by the VDBE.  The
** MergeEngine object, described in further detail below, performs this
** merge.
**
** Or, if running in multi-threaded mode, then a background thread is
** launched to merge the existing PMAs. Once the background thread has
** merged T bytes of data into a single sorted PMA, the main thread 
** begins reading keys from that PMA while the background thread proceeds
** with merging the next T bytes of data. And so on.
**
** Parameter T is set to half the value of the memory threshold used 
** by Write() above to determine when to create a new PMA.
**
** If there are more than SORTER_MAX_MERGE_COUNT PMAs in total when 
** Rewind() is called, then a hierarchy of incremental-merges is used. 
** First, T bytes of data from the first SORTER_MAX_MERGE_COUNT PMAs on 
** disk are merged together. Then T bytes of data from the second set, and
** so on, such that no operation ever merges more than SORTER_MAX_MERGE_COUNT
** PMAs at a time. This done is to improve locality.
**
** If running in multi-threaded mode and there are more than
** SORTER_MAX_MERGE_COUNT PMAs on disk when Rewind() is called, then more
** than one background thread may be created. Specifically, there may be
** one background thread for each temporary file on disk, and one background
** thread to merge the output of each of the others to a single PMA for
** the main thread to read from.
*/
#include "sqliteInt.h"
#include "vdbeInt.h"

/* 
** If SQLITE_DEBUG_SORTER_THREADS is defined, this module outputs various
** messages to stderr that may be helpful in understanding the performance
** characteristics of the sorter in multi-threaded mode.
*/
#if 0
# define SQLITE_DEBUG_SORTER_THREADS 1
#endif

/*
** Hard-coded maximum amount of data to accumulate in memory before flushing
** to a level 0 PMA. The purpose of this limit is to prevent various integer
** overflows. 512MiB.
*/
#define SQLITE_MAX_PMASZ    (1<<29)

/*
** Private objects used by the sorter
*/
typedef struct MergeEngine MergeEngine;     /* Merge PMAs together */
typedef struct PmaReader PmaReader;         /* Incrementally read one PMA */
typedef struct PmaWriter PmaWriter;         /* Incrementally write one PMA */
typedef struct SorterRecord SorterRecord;   /* A record being sorted */
typedef struct SortSubtask SortSubtask;     /* A sub-task in the sort process */
typedef struct SorterFile SorterFile;       /* Temporary file object wrapper */
typedef struct SorterList SorterList;       /* In-memory list of records */
typedef struct IncrMerger IncrMerger;       /* Read & merge multiple PMAs */

/*
** A container for a temp file handle and the current amount of data 
** stored in the file.
*/
struct SorterFile {
  sqlite3_file *pFd;              /* File handle */
  i64 iEof;                       /* Bytes of data stored in pFd */
};

/*
** An in-memory list of objects to be sorted.
**
** If aMemory==0 then each object is allocated separately and the objects
** are connected using SorterRecord.u.pNext.  If aMemory!=0 then all objects
** are stored in the aMemory[] bulk memory, one right after the other, and
** are connected using SorterRecord.u.iNext.
*/
struct SorterList {
  SorterRecord *pList;            /* Linked list of records */
  u8 *aMemory;                    /* If non-NULL, bulk memory to hold pList */
  int szPMA;                      /* Size of pList as PMA in bytes */
};

/*
** The MergeEngine object is used to combine two or more smaller PMAs into
** one big PMA using a merge operation.  Separate PMAs all need to be
** combined into one big PMA in order to be able to step through the sorted
** records in order.
**
** The aReadr[] array contains a PmaReader object for each of the PMAs being
** merged.  An aReadr[] object either points to a valid key or else is at EOF.
** ("EOF" means "End Of File".  When aReadr[] is at EOF there is no more data.)
** For the purposes of the paragraphs below, we assume that the array is
** actually N elements in size, where N is the smallest power of 2 greater
** to or equal to the number of PMAs being merged. The extra aReadr[] elements
** are treated as if they are empty (always at EOF).
**
** The aTree[] array is also N elements in size. The value of N is stored in
** the MergeEngine.nTree variable.
**
** The final (N/2) elements of aTree[] contain the results of comparing
** pairs of PMA keys together. Element i contains the result of 
** comparing aReadr[2*i-N] and aReadr[2*i-N+1]. Whichever key is smaller, the
** aTree element is set to the index of it. 
**
** For the purposes of this comparison, EOF is considered greater than any
** other key value. If the keys are equal (only possible with two EOF
** values), it doesn't matter which index is stored.
**
** The (N/4) elements of aTree[] that precede the final (N/2) described 
** above contains the index of the smallest of each block of 4 PmaReaders
** And so on. So that aTree[1] contains the index of the PmaReader that 
** currently points to the smallest key value. aTree[0] is unused.
**
** Example:
**
**     aReadr[0] -> Banana
**     aReadr[1] -> Feijoa
**     aReadr[2] -> Elderberry
**     aReadr[3] -> Currant
**     aReadr[4] -> Grapefruit
**     aReadr[5] -> Apple
**     aReadr[6] -> Durian
**     aReadr[7] -> EOF
**
**     aTree[] = { X, 5   0, 5    0, 3, 5, 6 }
**
** The current element is "Apple" (the value of the key indicated by 
** PmaReader 5). When the Next() operation is invoked, PmaReader 5 will
** be advanced to the next key in its segment. Say the next key is
** "Eggplant":
**
**     aReadr[5] -> Eggplant
**
** The contents of aTree[] are updated first by comparing the new PmaReader
** 5 key to the current key of PmaReader 4 (still "Grapefruit"). The PmaReader
** 5 value is still smaller, so aTree[6] is set to 5. And so on up the tree.
** The value of PmaReader 6 - "Durian" - is now smaller than that of PmaReader
** 5, so aTree[3] is set to 6. Key 0 is smaller than key 6 (Banana<Durian),
** so the value written into element 1 of the array is 0. As follows:
**
**     aTree[] = { X, 0   0, 6    0, 3, 5, 6 }
**
** In other words, each time we advance to the next sorter element, log2(N)
** key comparison operations are required, where N is the number of segments
** being merged (rounded up to the next power of 2).
*/
struct MergeEngine {
  int nTree;                 /* Used size of aTree/aReadr (power of 2) */
  SortSubtask *pTask;        /* Used by this thread only */
  int *aTree;                /* Current state of incremental merge */
  PmaReader *aReadr;         /* Array of PmaReaders to merge data from */
};

/*
** This object represents a single thread of control in a sort operation.
** Exactly VdbeSorter.nTask instances of this object are allocated
** as part of each VdbeSorter object. Instances are never allocated any
** other way. VdbeSorter.nTask is set to the number of worker threads allowed
** (see SQLITE_CONFIG_WORKER_THREADS) plus one (the main thread).  Thus for
** single-threaded operation, there is exactly one instance of this object
** and for multi-threaded operation there are two or more instances.
**
** Essentially, this structure contains all those fields of the VdbeSorter
** structure for which each thread requires a separate instance. For example,
** each thread requries its own UnpackedRecord object to unpack records in
** as part of comparison operations.
**
** Before a background thread is launched, variable bDone is set to 0. Then, 
** right before it exits, the thread itself sets bDone to 1. This is used for 
** two purposes:
**
**   1. When flushing the contents of memory to a level-0 PMA on disk, to
**      attempt to select a SortSubtask for which there is not already an
**      active background thread (since doing so causes the main thread
**      to block until it finishes).
**
**   2. If SQLITE_DEBUG_SORTER_THREADS is defined, to determine if a call
**      to sqlite3ThreadJoin() is likely to block. Cases that are likely to
**      block provoke debugging output.
**
** In both cases, the effects of the main thread seeing (bDone==0) even
** after the thread has finished are not dire. So we don't worry about
** memory barriers and such here.
*/
typedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int);
struct SortSubtask {
  SQLiteThread *pThread;          /* Background thread, if any */
  int bDone;                      /* Set if thread is finished but not joined */
  VdbeSorter *pSorter;            /* Sorter that owns this sub-task */
  UnpackedRecord *pUnpacked;      /* Space to unpack a record */
  SorterList list;                /* List for thread to write to a PMA */
  int nPMA;                       /* Number of PMAs currently in file */
  SorterCompare xCompare;         /* Compare function to use */
  SorterFile file;                /* Temp file for level-0 PMAs */
  SorterFile file2;               /* Space for other PMAs */
};


/*
** Main sorter structure. A single instance of this is allocated for each 
** sorter cursor created by the VDBE.
**
** mxKeysize:
**   As records are added to the sorter by calls to sqlite3VdbeSorterWrite(),
**   this variable is updated so as to be set to the size on disk of the
**   largest record in the sorter.
*/
struct VdbeSorter {
  int mnPmaSize;                  /* Minimum PMA size, in bytes */
  int mxPmaSize;                  /* Maximum PMA size, in bytes.  0==no limit */
  int mxKeysize;                  /* Largest serialized key seen so far */
  int pgsz;                       /* Main database page size */
  PmaReader *pReader;             /* Readr data from here after Rewind() */
  MergeEngine *pMerger;           /* Or here, if bUseThreads==0 */
  sqlite3 *db;                    /* Database connection */
  KeyInfo *pKeyInfo;              /* How to compare records */
  UnpackedRecord *pUnpacked;      /* Used by VdbeSorterCompare() */
  SorterList list;                /* List of in-memory records */
  int iMemory;                    /* Offset of free space in list.aMemory */
  int nMemory;                    /* Size of list.aMemory allocation in bytes */
  u8 bUsePMA;                     /* True if one or more PMAs created */
  u8 bUseThreads;                 /* True to use background threads */
  u8 iPrev;                       /* Previous thread used to flush PMA */
  u8 nTask;                       /* Size of aTask[] array */
  u8 typeMask;
  SortSubtask aTask[1];           /* One or more subtasks */
};

#define SORTER_TYPE_INTEGER 0x01
#define SORTER_TYPE_TEXT    0x02

/*
** An instance of the following object is used to read records out of a
** PMA, in sorted order.  The next key to be read is cached in nKey/aKey.
** aKey might point into aMap or into aBuffer.  If neither of those locations
** contain a contiguous representation of the key, then aAlloc is allocated
** and the key is copied into aAlloc and aKey is made to poitn to aAlloc.
**
** pFd==0 at EOF.
*/
struct PmaReader {
  i64 iReadOff;               /* Current read offset */
  i64 iEof;                   /* 1 byte past EOF for this PmaReader */
  int nAlloc;                 /* Bytes of space at aAlloc */
  int nKey;                   /* Number of bytes in key */
  sqlite3_file *pFd;          /* File handle we are reading from */
  u8 *aAlloc;                 /* Space for aKey if aBuffer and pMap wont work */
  u8 *aKey;                   /* Pointer to current key */
  u8 *aBuffer;                /* Current read buffer */
  int nBuffer;                /* Size of read buffer in bytes */
  u8 *aMap;                   /* Pointer to mapping of entire file */
  IncrMerger *pIncr;          /* Incremental merger */
};

/*
** Normally, a PmaReader object iterates through an existing PMA stored 
** within a temp file. However, if the PmaReader.pIncr variable points to
** an object of the following type, it may be used to iterate/merge through
** multiple PMAs simultaneously.
**
** There are two types of IncrMerger object - single (bUseThread==0) and 
** multi-threaded (bUseThread==1). 
**
** A multi-threaded IncrMerger object uses two temporary files - aFile[0] 
** and aFile[1]. Neither file is allowed to grow to more than mxSz bytes in 
** size. When the IncrMerger is initialized, it reads enough data from 
** pMerger to populate aFile[0]. It then sets variables within the 
** corresponding PmaReader object to read from that file and kicks off 
** a background thread to populate aFile[1] with the next mxSz bytes of 
** sorted record data from pMerger. 
**
** When the PmaReader reaches the end of aFile[0], it blocks until the
** background thread has finished populating aFile[1]. It then exchanges
** the contents of the aFile[0] and aFile[1] variables within this structure,
** sets the PmaReader fields to read from the new aFile[0] and kicks off
** another background thread to populate the new aFile[1]. And so on, until
** the contents of pMerger are exhausted.
**
** A single-threaded IncrMerger does not open any temporary files of its
** own. Instead, it has exclusive access to mxSz bytes of space beginning
** at offset iStartOff of file pTask->file2. And instead of using a 
** background thread to prepare data for the PmaReader, with a single
** threaded IncrMerger the allocate part of pTask->file2 is "refilled" with
** keys from pMerger by the calling thread whenever the PmaReader runs out
** of data.
*/
struct IncrMerger {
  SortSubtask *pTask;             /* Task that owns this merger */
  MergeEngine *pMerger;           /* Merge engine thread reads data from */
  i64 iStartOff;                  /* Offset to start writing file at */
  int mxSz;                       /* Maximum bytes of data to store */
  int bEof;                       /* Set to true when merge is finished */
  int bUseThread;                 /* True to use a bg thread for this object */
  SorterFile aFile[2];            /* aFile[0] for reading, [1] for writing */
};

/*
** An instance of this object is used for writing a PMA.
**
** The PMA is written one record at a time.  Each record is of an arbitrary
** size.  But I/O is more efficient if it occurs in page-sized blocks where
** each block is aligned on a page boundary.  This object caches writes to
** the PMA so that aligned, page-size blocks are written.
*/
struct PmaWriter {
  int eFWErr;                     /* Non-zero if in an error state */
  u8 *aBuffer;                    /* Pointer to write buffer */
  int nBuffer;                    /* Size of write buffer in bytes */
  int iBufStart;                  /* First byte of buffer to write */
  int iBufEnd;                    /* Last byte of buffer to write */
  i64 iWriteOff;                  /* Offset of start of buffer in file */
  sqlite3_file *pFd;              /* File handle to write to */
};

/*
** This object is the header on a single record while that record is being
** held in memory and prior to being written out as part of a PMA.
**
** How the linked list is connected depends on how memory is being managed
** by this module. If using a separate allocation for each in-memory record
** (VdbeSorter.list.aMemory==0), then the list is always connected using the
** SorterRecord.u.pNext pointers.
**
** Or, if using the single large allocation method (VdbeSorter.list.aMemory!=0),
** then while records are being accumulated the list is linked using the
** SorterRecord.u.iNext offset. This is because the aMemory[] array may
** be sqlite3Realloc()ed while records are being accumulated. Once the VM
** has finished passing records to the sorter, or when the in-memory buffer
** is full, the list is sorted. As part of the sorting process, it is
** converted to use the SorterRecord.u.pNext pointers. See function
** vdbeSorterSort() for details.
*/
struct SorterRecord {
  int nVal;                       /* Size of the record in bytes */
  union {
    SorterRecord *pNext;          /* Pointer to next record in list */
    int iNext;                    /* Offset within aMemory of next record */
  } u;
  /* The data for the record immediately follows this header */
};

/* Return a pointer to the buffer containing the record data for SorterRecord
** object p. Should be used as if:
**
**   void *SRVAL(SorterRecord *p) { return (void*)&p[1]; }
*/
#define SRVAL(p) ((void*)((SorterRecord*)(p) + 1))


/* Maximum number of PMAs that a single MergeEngine can merge */
#define SORTER_MAX_MERGE_COUNT 16

static int vdbeIncrSwap(IncrMerger*);
static void vdbeIncrFree(IncrMerger *);

/*
** Free all memory belonging to the PmaReader object passed as the
** argument. All structure fields are set to zero before returning.
*/
static void vdbePmaReaderClear(PmaReader *pReadr){
  sqlite3_free(pReadr->aAlloc);
  sqlite3_free(pReadr->aBuffer);
  
// ABS Label 8
if(pReadr->aMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
if( pReadr->aMap ) { 
// ABS Label 9
if(pReadr->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
}
  
// ABS Label 7
if(pReadr->pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
vdbeIncrFree(pReadr->pIncr);
  memset(pReadr, 0, sizeof(PmaReader));
}

/*
** Read the next nByte bytes of data from the PMA p.
** If successful, set *ppOut to point to a buffer containing the data
** and return SQLITE_OK. Otherwise, if an error occurs, return an SQLite
** error code.
**
** The buffer returned in *ppOut is only valid until the
** next call to this function.
*/
static int vdbePmaReadBlob(
  PmaReader *p,                   /* PmaReader from which to take the blob */
  int nByte,                      /* Bytes of data to read */
  u8 **ppOut                      /* OUT: Pointer to buffer containing data */
){
  int iBuf;                       /* Offset within buffer to read from */
  int nAvail;                     /* Bytes of data available in buffer */

  
// ABS Label 10
if(p->aMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
if( p->aMap ){
    *ppOut = &p->aMap[p->iReadOff];
    p->iReadOff += nByte;
    return SQLITE_OK;
  }

  assert( p->aBuffer );

  /* If there is no more data to be read from the buffer, read the next 
  ** p->nBuffer bytes of data from the file into it. Or, if there are less
  ** than p->nBuffer bytes remaining in the PMA, read all remaining data.  */
  iBuf = p->iReadOff % p->nBuffer;
  
// ABS Label 11
if(iBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ROR Label 12
if((iBuf != 0) != (iBuf == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
if( iBuf==0 ){
    int nRead;                    /* Bytes to read from disk */
    int rc;                       /* sqlite3OsRead() return code */

    /* Determine how many bytes of data to read. */
    
// ROR Label 13
if(((p->iEof - p->iReadOff) <= (i64)p->nBuffer) != ((p->iEof - p->iReadOff) > (i64)p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
// ROR Label 14
if(((p->iEof - p->iReadOff) < (i64)p->nBuffer) != ((p->iEof - p->iReadOff) > (i64)p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
// ROR Label 15
if(((p->iEof - p->iReadOff) >= (i64)p->nBuffer) != ((p->iEof - p->iReadOff) > (i64)p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){
      nRead = p->nBuffer;
    }else{
      nRead = (int)(p->iEof - p->iReadOff);
    }
    assert( nRead>0 );

    /* Readr data from the file. Return early if an error occurs. */
    rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);
    assert( rc!=SQLITE_IOERR_SHORT_READ );
    
// ABS Label 16
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ROR Label 17
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 18
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}
return rc;
}
  }
  nAvail = p->nBuffer - iBuf; 

  
// ABS Label 19
if(nAvail < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
// ABS Label 20
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}

// ROR Label 21
if((nByte < nAvail) != (nByte <= nAvail))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
// ROR Label 22
if((nByte > nAvail) != (nByte <= nAvail))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}
// ROR Label 23
if((nByte >= nAvail) != (nByte <= nAvail))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
if( nByte<=nAvail ){
    /* The requested data is available in the in-memory buffer. In this
    ** case there is no need to make a copy of the data, just return a 
    ** pointer into the buffer to the caller.  */
    *ppOut = &p->aBuffer[iBuf];
    p->iReadOff += nByte;
  }else{
    /* The requested data is not all available in the in-memory buffer.
    ** In this case, allocate space at p->aAlloc[] to copy the requested
    ** range into. Then return a copy of pointer p->aAlloc to the caller.  */
    int nRem;                     /* Bytes remaining to copy */

    /* Extend the p->aAlloc[] allocation if required. */
    
// ABS Label 24
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
// ABS Label 25
if(p->nAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}

// ROR Label 26
if((p->nAlloc <= nByte) != (p->nAlloc < nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 26);
}
// ROR Label 27
if((p->nAlloc > nByte) != (p->nAlloc < nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
// ROR Label 28
if((p->nAlloc >= nByte) != (p->nAlloc < nByte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
if( p->nAlloc<nByte ){
      u8 *aNew;
      sqlite3_int64 nNew = MAX(128, 2*(sqlite3_int64)p->nAlloc);
      
// ABS Label 29
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}

// ROR Label 30
if((nByte <= nNew) != (nByte > nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}
// ROR Label 31
if((nByte < nNew) != (nByte > nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((nByte >= nNew) != (nByte > nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
while( nByte>nNew ) { nNew = nNew*2;
};
// ABS Label 33
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}

// ROR Label 34
if((nByte <= nNew) != (nByte > nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
// ROR Label 35
if((nByte < nNew) != (nByte > nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
// ROR Label 36
if((nByte >= nNew) != (nByte > nNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}

      aNew = sqlite3Realloc(p->aAlloc, nNew);
      if( !aNew ) { return SQLITE_NOMEM_BKPT;
}
      p->nAlloc = nNew;
      p->aAlloc = aNew;
    }

    /* Copy as much data as is available in the buffer into the start of
    ** p->aAlloc[].  */
    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
    p->iReadOff += nAvail;
    nRem = nByte - nAvail;

    /* The following loop copies up to p->nBuffer bytes per iteration into
    ** the p->aAlloc[] buffer.  */
    
// ABS Label 37
if(nRem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}

// ROR Label 38
if((nRem <= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((nRem < 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
// ROR Label 40
if((nRem >= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
while( nRem>0 ){
      int rc;                     /* vdbePmaReadBlob() return code */
      int nCopy;                  /* Number of bytes to copy */
      u8 *aNext;                  /* Pointer to buffer to copy data from */

      nCopy = nRem;
      
// ABS Label 45
if(nRem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}
// ABS Label 46
if(p->nBuffer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}

// ROR Label 47
if((nRem <= p->nBuffer) != (nRem > p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
// ROR Label 48
if((nRem < p->nBuffer) != (nRem > p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
// ROR Label 49
if((nRem >= p->nBuffer) != (nRem > p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
if( nRem>p->nBuffer ) { nCopy = p->nBuffer;
}
      rc = vdbePmaReadBlob(p, nCopy, &aNext);
      
// ABS Label 50
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}

// ROR Label 51
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 52
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
return rc;
}
      assert( aNext!=p->aAlloc );
      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
      nRem -= nCopy;
    };
// ABS Label 41
if(nRem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// ROR Label 42
if((nRem <= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((nRem < 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((nRem >= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}


    *ppOut = p->aAlloc;
  }

  return SQLITE_OK;
}

/*
** Read a varint from the stream of data accessed by p. Set *pnOut to
** the value read.
*/
static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){
  int iBuf;

  
// ABS Label 53
if(p->aMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
if( p->aMap ){
    p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);
  }else{
    iBuf = p->iReadOff % p->nBuffer;
    
// ABS Label 54
if(iBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// COR Label 55
if((iBuf || (p->nBuffer - iBuf) >= 9) != (iBuf && (p->nBuffer - iBuf) >= 9))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 55);
}

// ROR Label 56
if(((p->nBuffer - iBuf) < 9) != ((p->nBuffer - iBuf) >= 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
// ROR Label 57
if(((p->nBuffer - iBuf) > 9) != ((p->nBuffer - iBuf) >= 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if(((p->nBuffer - iBuf) <= 9) != ((p->nBuffer - iBuf) >= 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}

// MCC Label 59
if(iBuf && (p->nBuffer - iBuf) >= 9 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if(iBuf && !((p->nBuffer - iBuf) >= 9) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!(iBuf) && (p->nBuffer - iBuf) >= 9 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(iBuf) && !((p->nBuffer - iBuf) >= 9) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
if( iBuf && (p->nBuffer-iBuf)>=9 ){
      p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);
    }else{
      u8 aVarint[16], *a;
      int i = 0, rc;
      
// ROR Label 64
if(((a[0] & 128) == 0) != ((a[0] & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
do{
        rc = vdbePmaReadBlob(p, 1, &a);
        
// ABS Label 66
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
if( rc ) { 
// ABS Label 67
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
return rc;
}
        aVarint[(i++)&0xf] = a[0];
      }while( (a[0]&0x80)!=0 );
// ROR Label 65
if(((a[0] & 128) == 0) != ((a[0] & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}
;
      
// ABS Label 63
if(pnOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}
sqlite3GetVarint(aVarint, pnOut);
    }
  }

  return SQLITE_OK;
}

/*
** Attempt to memory map file pFile. If successful, set *pp to point to the
** new mapping and return SQLITE_OK. If the mapping is not attempted 
** (because the file is too large or the VFS layer is configured not to use
** mmap), return SQLITE_OK and set *pp to NULL.
**
** Or, if an error occurs, return an SQLite error code. The final value of
** *pp is undefined in this case.
*/
static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){
  int rc = SQLITE_OK;
  
// ABS Label 68
if(pFile->iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}

// ROR Label 69
if((pFile->iEof < (i64)(pTask->pSorter->db->nMaxSorterMmap)) != (pFile->iEof <= (i64)(pTask->pSorter->db->nMaxSorterMmap)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}
// ROR Label 70
if((pFile->iEof > (i64)(pTask->pSorter->db->nMaxSorterMmap)) != (pFile->iEof <= (i64)(pTask->pSorter->db->nMaxSorterMmap)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
// ROR Label 71
if((pFile->iEof >= (i64)(pTask->pSorter->db->nMaxSorterMmap)) != (pFile->iEof <= (i64)(pTask->pSorter->db->nMaxSorterMmap)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){
    
// ABS Label 72
if(pFile->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 72);
}
sqlite3_file *pFd = pFile->pFd;
    
// ABS Label 73
if(pFd->pMethods->iVersion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// ROR Label 74
if((pFd->pMethods->iVersion < 3) != (pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
// ROR Label 75
if((pFd->pMethods->iVersion > 3) != (pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
// ROR Label 76
if((pFd->pMethods->iVersion <= 3) != (pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
if( pFd->pMethods->iVersion>=3 ){
      rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);
      testcase( rc!=SQLITE_OK );
    }
  }
  
// ABS Label 77
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}
return rc;
}

/*
** Attach PmaReader pReadr to file pFile (if it is not already attached to
** that file) and seek it to offset iOff within the file.  Return SQLITE_OK 
** if successful, or an SQLite error code if an error occurs.
*/
static int vdbePmaReaderSeek(
  SortSubtask *pTask,             /* Task context */
  PmaReader *pReadr,              /* Reader whose cursor is to be moved */
  SorterFile *pFile,              /* Sorter file to read from */
  i64 iOff                        /* Offset in pFile */
){
  int rc = SQLITE_OK;

  assert( pReadr->pIncr==0 || pReadr->pIncr->bEof==0 );

  if( sqlite3FaultSim(201) ) { 
// MCC Label 78
if(( 10 | (1 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 78);
}
// MCC Label 79
if(( !(10 | (1 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 79);
}
return SQLITE_IOERR_READ;
}
  
// ABS Label 80
if(pReadr->aMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 80);
}
if( pReadr->aMap ){
    
// ABS Label 81
if(pReadr->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}
sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
    pReadr->aMap = 0;
  }
  pReadr->iReadOff = iOff;
  pReadr->iEof = pFile->iEof;
  pReadr->pFd = pFile->pFd;

  rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);
  
// ABS Label 82
if(pReadr->aMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}
// ABS Label 83
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}

// COR Label 84
if((rc == 0 || pReadr->aMap == 0) != (rc == 0 && pReadr->aMap == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 84);
}

// ROR Label 85
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}
// ROR Label 86
if((pReadr->aMap != 0) != (pReadr->aMap == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}

// MCC Label 87
if(rc == 0 && pReadr->aMap == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 87);
}
// MCC Label 88
if(rc == 0 && !(pReadr->aMap == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 88);
}
// MCC Label 89
if(!(rc == 0) && pReadr->aMap == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 89);
}
// MCC Label 90
if(!(rc == 0) && !(pReadr->aMap == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}
if( rc==SQLITE_OK && pReadr->aMap==0 ){
    
// ABS Label 91
if(pTask->pSorter->pgsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
int pgsz = pTask->pSorter->pgsz;
    int iBuf = pReadr->iReadOff % pgsz;
    
// ABS Label 92
if(pReadr->aBuffer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// ROR Label 93
if((pReadr->aBuffer != 0) != (pReadr->aBuffer == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
if( pReadr->aBuffer==0 ){
      pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);
      
// ABS Label 94
if(pReadr->aBuffer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// ROR Label 95
if((pReadr->aBuffer != 0) != (pReadr->aBuffer == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}
if( pReadr->aBuffer==0 ) { rc = SQLITE_NOMEM_BKPT;
}
      pReadr->nBuffer = pgsz;
    }
    
// ABS Label 96
if(iBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}
// ABS Label 97
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// COR Label 98
if((rc == 0 || iBuf) != (rc == 0 && iBuf))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 98);
}

// ROR Label 99
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}

// MCC Label 100
if(rc == 0 && iBuf ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 100);
}
// MCC Label 101
if(rc == 0 && !(iBuf) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(!(rc == 0) && iBuf ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
// MCC Label 103
if(!(rc == 0) && !(iBuf) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 103);
}
if( rc==SQLITE_OK && iBuf ){
      
// ABS Label 104
if(iBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
// ABS Label 105
if(pgsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// AOR Label 106
if(pgsz / iBuf != pgsz - iBuf)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 106);
}
// AOR Label 107
if(pgsz + iBuf != pgsz - iBuf)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 107);
}
// AOR Label 108
if(pgsz * iBuf != pgsz - iBuf)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 108);
}
int nRead = pgsz - iBuf;
      
// ABS Label 109
if(pReadr->iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 109);
}

// ROR Label 110
if(((pReadr->iReadOff + nRead) <= pReadr->iEof) != ((pReadr->iReadOff + nRead) > pReadr->iEof))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
// ROR Label 111
if(((pReadr->iReadOff + nRead) < pReadr->iEof) != ((pReadr->iReadOff + nRead) > pReadr->iEof))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 111);
}
// ROR Label 112
if(((pReadr->iReadOff + nRead) >= pReadr->iEof) != ((pReadr->iReadOff + nRead) > pReadr->iEof))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 112);
}
if( (pReadr->iReadOff + nRead) > pReadr->iEof ){
        nRead = (int)(pReadr->iEof - pReadr->iReadOff);
      }
      rc = sqlite3OsRead(
          pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff
      );
      testcase( rc!=SQLITE_OK );
    }
  }

  
// ABS Label 113
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
return rc;
}

/*
** Advance PmaReader pReadr to the next key in its PMA. Return SQLITE_OK if
** no error occurs, or an SQLite error code if one does.
*/
static int vdbePmaReaderNext(PmaReader *pReadr){
  int rc = SQLITE_OK;             /* Return Code */
  u64 nRec = 0;                   /* Size of record in bytes */


  
// ABS Label 114
if(pReadr->iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
// ABS Label 115
if(pReadr->iReadOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// ROR Label 116
if((pReadr->iReadOff < pReadr->iEof) != (pReadr->iReadOff >= pReadr->iEof))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
// ROR Label 117
if((pReadr->iReadOff > pReadr->iEof) != (pReadr->iReadOff >= pReadr->iEof))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
// ROR Label 118
if((pReadr->iReadOff <= pReadr->iEof) != (pReadr->iReadOff >= pReadr->iEof))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
if( pReadr->iReadOff>=pReadr->iEof ){
    
// ABS Label 119
if(pReadr->pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 119);
}
IncrMerger *pIncr = pReadr->pIncr;
    int bEof = 1;
    
// ABS Label 120
if(pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 120);
}
if( pIncr ){
      rc = vdbeIncrSwap(pIncr);
      
// ABS Label 121
if(pIncr->bEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 121);
}
// ABS Label 122
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// COR Label 123
if((rc == 0 || pIncr->bEof == 0) != (rc == 0 && pIncr->bEof == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 123);
}

// ROR Label 124
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}
// ROR Label 125
if((pIncr->bEof != 0) != (pIncr->bEof == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}

// MCC Label 126
if(rc == 0 && pIncr->bEof == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 126);
}
// MCC Label 127
if(rc == 0 && !(pIncr->bEof == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 127);
}
// MCC Label 128
if(!(rc == 0) && pIncr->bEof == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 128);
}
// MCC Label 129
if(!(rc == 0) && !(pIncr->bEof == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 129);
}
if( rc==SQLITE_OK && pIncr->bEof==0 ){
        rc = vdbePmaReaderSeek(
            pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff
        );
        bEof = 0;
      }
    }

    
// ABS Label 130
if(bEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}
if( bEof ){
      /* This is an EOF condition */
      
// ABS Label 131
if(pReadr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}
vdbePmaReaderClear(pReadr);
      testcase( rc!=SQLITE_OK );
      
// ABS Label 132
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}
return rc;
    }
  }

  
// ABS Label 133
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}

// ROR Label 134
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}
if( rc==SQLITE_OK ){
    rc = vdbePmaReadVarint(pReadr, &nRec);
  }
  
// ABS Label 135
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}

// ROR Label 136
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 136);
}
if( rc==SQLITE_OK ){
    pReadr->nKey = (int)nRec;
    rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);
    testcase( rc!=SQLITE_OK );
  }

  
// ABS Label 137
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
return rc;
}

/*
** Initialize PmaReader pReadr to scan through the PMA stored in file pFile
** starting at offset iStart and ending at offset iEof-1. This function 
** leaves the PmaReader pointing to the first key in the PMA (or EOF if the 
** PMA is empty).
**
** If the pnByte parameter is NULL, then it is assumed that the file 
** contains a single PMA, and that that PMA omits the initial length varint.
*/
static int vdbePmaReaderInit(
  SortSubtask *pTask,             /* Task context */
  SorterFile *pFile,              /* Sorter file to read from */
  i64 iStart,                     /* Start offset in pFile */
  PmaReader *pReadr,              /* PmaReader to populate */
  i64 *pnByte                     /* IN/OUT: Increment this value by PMA size */
){
  int rc;

  assert( pFile->iEof>iStart );
  assert( pReadr->aAlloc==0 && pReadr->nAlloc==0 );
  assert( pReadr->aBuffer==0 );
  assert( pReadr->aMap==0 );

  rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);
  
// ABS Label 138
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// ROR Label 139
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 139);
}
if( rc==SQLITE_OK ){
    u64 nByte = 0;                 /* Size of PMA in bytes */
    rc = vdbePmaReadVarint(pReadr, &nByte);
    pReadr->iEof = pReadr->iReadOff + nByte;
    *pnByte += nByte;
  }

  
// ABS Label 140
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}

// ROR Label 141
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 141);
}
if( rc==SQLITE_OK ){
    rc = vdbePmaReaderNext(pReadr);
  }
  
// ABS Label 142
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
return rc;
}

/*
** A version of vdbeSorterCompare() that assumes that it has already been
** determined that the first field of key1 is equal to the first field of 
** key2.
*/
static int vdbeSorterCompareTail(
  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
  const void *pKey1, int nKey1,   /* Left side of comparison */
  const void *pKey2, int nKey2    /* Right side of comparison */
){
  
// ABS Label 143
if(pTask->pUnpacked < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
UnpackedRecord *r2 = pTask->pUnpacked;
  
// ABS Label 144
if(*pbKey2Cached < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 144);
}

// ROR Label 145
if((*pbKey2Cached != 0) != (*pbKey2Cached == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
if( *pbKey2Cached==0 ){
    
// ABS Label 146
if(pTask->pSorter->pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}

// ABS Label 147
if(nKey2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 147);
}

// ABS Label 148
if(pKey2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 148);
}

// ABS Label 149
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);
}

/*
** Compare key1 (buffer pKey1, size nKey1 bytes) with key2 (buffer pKey2, 
** size nKey2 bytes). Use (pTask->pKeyInfo) for the collation sequences
** used by the comparison. Return the result of the comparison.
**
** If IN/OUT parameter *pbKey2Cached is true when this function is called,
** it is assumed that (pTask->pUnpacked) contains the unpacked version
** of key2. If it is false, (pTask->pUnpacked) is populated with the unpacked
** version of key2 and *pbKey2Cached set to true before returning.
**
** If an OOM error is encountered, (pTask->pUnpacked->error_rc) is set
** to SQLITE_NOMEM.
*/
static int vdbeSorterCompare(
  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
  const void *pKey1, int nKey1,   /* Left side of comparison */
  const void *pKey2, int nKey2    /* Right side of comparison */
){
  
// ABS Label 150
if(pTask->pUnpacked < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
UnpackedRecord *r2 = pTask->pUnpacked;
  if( !*pbKey2Cached ){
    
// ABS Label 151
if(pTask->pSorter->pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// ABS Label 152
if(nKey2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}

// ABS Label 153
if(pKey2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ABS Label 154
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 154);
}
sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);
}

/*
** A specially optimized version of vdbeSorterCompare() that assumes that
** the first field of each key is a TEXT value and that the collation
** sequence to compare them with is BINARY.
*/
static int vdbeSorterCompareText(
  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
  const void *pKey1, int nKey1,   /* Left side of comparison */
  const void *pKey2, int nKey2    /* Right side of comparison */
){
  const u8 * const p1 = (const u8 * const)pKey1;
  const u8 * const p2 = (const u8 * const)pKey2;
  const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */
  const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */

  int n1;
  int n2;
  int res;

  getVarint32NR(&p1[1], n1);
  getVarint32NR(&p2[1], n2);
  res = memcmp(v1, v2, (MIN(n1, n2) - 13)/2);
  
// ABS Label 163
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ROR Label 164
if((res != 0) != (res == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
if( res==0 ){
    res = n1 - n2;
  }

  
// ABS Label 165
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}

// ROR Label 166
if((res != 0) != (res == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
if( res==0 ){
    
// ROR Label 167
if((pTask->pSorter->pKeyInfo->nKeyField <= 1) != (pTask->pSorter->pKeyInfo->nKeyField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((pTask->pSorter->pKeyInfo->nKeyField < 1) != (pTask->pSorter->pKeyInfo->nKeyField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
// ROR Label 169
if((pTask->pSorter->pKeyInfo->nKeyField >= 1) != (pTask->pSorter->pKeyInfo->nKeyField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}
if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
      res = vdbeSorterCompareTail(
          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
      );
    }
  }else{
    assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );
    
// ABS Label 170
if(pTask->pSorter->pKeyInfo->aSortFlags[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}
if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
      res = res * -1;
    }
  }

  
// ABS Label 171
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}
return res;
}

/*
** A specially optimized version of vdbeSorterCompare() that assumes that
** the first field of each key is an INTEGER value.
*/
static int vdbeSorterCompareInt(
  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */
  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */
  const void *pKey1, int nKey1,   /* Left side of comparison */
  const void *pKey2, int nKey2    /* Right side of comparison */
){
  const u8 * const p1 = (const u8 * const)pKey1;
  const u8 * const p2 = (const u8 * const)pKey2;
  const int s1 = p1[1];                 /* Left hand serial type */
  const int s2 = p2[1];                 /* Right hand serial type */
  const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */
  const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */
  int res;                              /* Return value */

  assert( (s1>0 && s1<7) || s1==8 || s1==9 );
  assert( (s2>0 && s2<7) || s2==8 || s2==9 );

  
// ABS Label 172
if(s1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}
// ABS Label 173
if(s2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}

// ROR Label 174
if((s1 != s2) != (s1 == s2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
if( s1==s2 ){
    /* The two values have the same sign. Compare using memcmp(). */
    static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };
    
// ABS Label 175
if(aLen[s1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}
// ABS Label 176
if(s1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}
const u8 n = aLen[s1];
    int i;
    res = 0;
    i = 0;

// ABS Label 177
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}

// ROR Label 178
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 178);
}
// ROR Label 179
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}
// ROR Label 180
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 180);
}
for(; i<n; i++){
      if( (res = v1[i] - v2[i])!=0 ){
        
// ROR Label 185
if((((v1[0] ^ v2[0]) & 128) == 0) != (((v1[0] ^ v2[0]) & 128) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){
          res = v1[0] & 0x80 ? -1 : +1;
        }
        break;
      }
    };
// ABS Label 181
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}

// ROR Label 182
if((i <= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 182);
}
// ROR Label 183
if((i > n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((i >= n) != (i < n))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}

  }else { 
// ABS Label 186
if(s1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}
// ABS Label 187
if(s2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 187);
}

// COR Label 188
if((s1 > 7 || s2 > 7) != (s1 > 7 && s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 188);
}

// ROR Label 189
if((s1 <= 7) != (s1 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
// ROR Label 190
if((s1 < 7) != (s1 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 190);
}
// ROR Label 191
if((s1 >= 7) != (s1 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
// ROR Label 192
if((s2 <= 7) != (s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((s2 < 7) != (s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
// ROR Label 194
if((s2 >= 7) != (s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}

// MCC Label 195
if(s1 > 7 && s2 > 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(s1 > 7 && !(s2 > 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(!(s1 > 7) && s2 > 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
// MCC Label 198
if(!(s1 > 7) && !(s2 > 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 198);
}
if( s1>7 && s2>7 ){
    res = s1 - s2;
  }else{
    
// ABS Label 199
if(s2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}

// ROR Label 200
if((s2 <= 7) != (s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 200);
}
// ROR Label 201
if((s2 < 7) != (s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 201);
}
// ROR Label 202
if((s2 >= 7) != (s2 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 202);
}
if( s2>7 ){
      res = +1;
    }else { 
// ABS Label 203
if(s1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}

// ROR Label 204
if((s1 <= 7) != (s1 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((s1 < 7) != (s1 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
// ROR Label 206
if((s1 >= 7) != (s1 > 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
if( s1>7 ){
      res = -1;
    }else{
      res = s1 - s2;
    };}

    assert( res!=0 );

    
// ABS Label 207
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ROR Label 208
if((res <= 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((res < 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((res >= 0) != (res > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
if( res>0 ){
      
// AOR Label 211
if(*v1 | 128 != *v1 & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 211);
}
// AOR Label 212
if(*v1 ^ 128 != *v1 & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 212);
}
if( *v1 & 0x80 ) { res = -1;
}
    }else{
      
// AOR Label 213
if(*v2 | 128 != *v2 & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 213);
}
// AOR Label 214
if(*v2 ^ 128 != *v2 & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 214);
}
if( *v2 & 0x80 ) { res = +1;
}
    }
  };}


  
// ABS Label 215
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}

// ROR Label 216
if((res != 0) != (res == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 216);
}
if( res==0 ){
    
// ROR Label 217
if((pTask->pSorter->pKeyInfo->nKeyField <= 1) != (pTask->pSorter->pKeyInfo->nKeyField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
// ROR Label 218
if((pTask->pSorter->pKeyInfo->nKeyField < 1) != (pTask->pSorter->pKeyInfo->nKeyField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
// ROR Label 219
if((pTask->pSorter->pKeyInfo->nKeyField >= 1) != (pTask->pSorter->pKeyInfo->nKeyField > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
      res = vdbeSorterCompareTail(
          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
      );
    }
  }else { 
// ABS Label 220
if(pTask->pSorter->pKeyInfo->aSortFlags[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
    assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );
    res = res * -1;
  };}


  
// ABS Label 221
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
return res;
}

/*
** Initialize the temporary index cursor just opened as a sorter cursor.
**
** Usually, the sorter module uses the value of (pCsr->pKeyInfo->nKeyField)
** to determine the number of fields that should be compared from the
** records being sorted. However, if the value passed as argument nField
** is non-zero and the sorter is able to guarantee a stable sort, nField
** is used instead. This is used when sorting records for a CREATE INDEX
** statement. In this case, keys are always delivered to the sorter in
** order of the primary key, which happens to be make up the final part 
** of the records being sorted. So if the sort is stable, there is never
** any reason to compare PK fields and they can be ignored for a small
** performance boost.
**
** The sorter can guarantee a stable sort when running in single-threaded
** mode, but not in multi-threaded mode.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/
int sqlite3VdbeSorterInit(
  sqlite3 *db,                    /* Database connection (for malloc()) */
  int nField,                     /* Number of key fields in each record */
  VdbeCursor *pCsr                /* Cursor that holds the new sorter */
){
  int pgsz;                       /* Page size of main database */
  int i;                          /* Used to iterate through aTask[] */
  VdbeSorter *pSorter;            /* The new sorter */
  KeyInfo *pKeyInfo;              /* Copy of pCsr->pKeyInfo with db==0 */
  int szKeyInfo;                  /* Size of pCsr->pKeyInfo in bytes */
  int sz;                         /* Size of pSorter in bytes */
  int rc = SQLITE_OK;
#if SQLITE_MAX_WORKER_THREADS==0
# define nWorker 0
#else
  int nWorker;
#endif

  /* Initialize the upper limit on the number of worker threads */
#if SQLITE_MAX_WORKER_THREADS>0
  if( sqlite3TempInMemory(db) || sqlite3GlobalConfig.bCoreMutex==0 ){
    nWorker = 0;
  }else{
    nWorker = db->aLimit[SQLITE_LIMIT_WORKER_THREADS];
  }
#endif

  /* Do not allow the total number of threads (main thread + all workers)
  ** to exceed the maximum merge count */
#if SQLITE_MAX_WORKER_THREADS>=SORTER_MAX_MERGE_COUNT
  if( nWorker>=SORTER_MAX_MERGE_COUNT ){
    nWorker = SORTER_MAX_MERGE_COUNT-1;
  }
#endif

  assert( pCsr->pKeyInfo && pCsr->pBtx==0 );
  assert( pCsr->eCurType==CURTYPE_SORTER );
  szKeyInfo = sizeof(KeyInfo) + (pCsr->pKeyInfo->nKeyField-1)*sizeof(CollSeq*);
  sz = sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask);

  pSorter = (VdbeSorter*)sqlite3DbMallocZero(db, sz + szKeyInfo);
  pCsr->uc.pSorter = pSorter;
  
// ABS Label 222
if(pSorter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}

// ROR Label 223
if((pSorter != 0) != (pSorter == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 223);
}
if( pSorter==0 ){
    rc = SQLITE_NOMEM_BKPT;
  }else{
    
// ABS Label 224
if(db->aDb[0].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
Btree *pBt = db->aDb[0].pBt;
    pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);
    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
    pKeyInfo->db = 0;
    
// ABS Label 227
if(nField < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
// ABS Label 228
if(nWorker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}

// COR Label 229
if((nField || nWorker == 0) != (nField && nWorker == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 229);
}

// ROR Label 230
if((nWorker != 0) != (nWorker == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 230);
}

// MCC Label 231
if(nField && nWorker == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(nField && !(nWorker == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(!(nField) && nWorker == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
// MCC Label 234
if(!(nField) && !(nWorker == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
if( nField && nWorker==0 ){
      pKeyInfo->nKeyField = nField;
    }
    
// ABS Label 225
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}
sqlite3BtreeEnter(pBt);
    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(pBt);
    
// ABS Label 226
if(pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
sqlite3BtreeLeave(pBt);
    pSorter->nTask = nWorker + 1;
    pSorter->iPrev = (u8)(nWorker - 1);
    pSorter->bUseThreads = (pSorter->nTask>1);
    pSorter->db = db;
    i = 0;

// ABS Label 235
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}

// ROR Label 236
if((i <= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
// ROR Label 237
if((i > pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
// ROR Label 238
if((i >= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
for(; i<pSorter->nTask; i++){
      SortSubtask *pTask = &pSorter->aTask[i];
      pTask->pSorter = pSorter;
    };
// ABS Label 239
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// ROR Label 240
if((i <= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 240);
}
// ROR Label 241
if((i > pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((i >= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}


    if( !sqlite3TempInMemory(db) ){
      i64 mxCache;                /* Cache size in bytes*/
      
// ABS Label 243
if(sqlite3Config.szPma < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}
u32 szPma = sqlite3GlobalConfig.szPma;
      pSorter->mnPmaSize = szPma * pgsz;

      mxCache = db->aDb[0].pSchema->cache_size;
      
// ABS Label 244
if(mxCache < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ROR Label 245
if((mxCache <= 0) != (mxCache < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 245);
}
// ROR Label 246
if((mxCache > 0) != (mxCache < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
// ROR Label 247
if((mxCache >= 0) != (mxCache < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 247);
}
if( mxCache<0 ){
        /* A negative cache-size value C indicates that the cache is abs(C)
        ** KiB in size.  */
        mxCache = mxCache * -1024;
      }else{
        mxCache = mxCache * pgsz;
      }
      mxCache = MIN(mxCache, SQLITE_MAX_PMASZ);
      pSorter->mxPmaSize = MAX(pSorter->mnPmaSize, (int)mxCache);

      /* Avoid large memory allocations if the application has requested
      ** SQLITE_CONFIG_SMALL_MALLOC. */
      
// ROR Label 248
if((sqlite3Config.bSmallMalloc != 0) != (sqlite3Config.bSmallMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 248);
}
if( sqlite3GlobalConfig.bSmallMalloc==0 ){
        assert( pSorter->iMemory==0 );
        pSorter->nMemory = pgsz;
        pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);
        if( !pSorter->list.aMemory ) { rc = SQLITE_NOMEM_BKPT;
}
      }
    }

    
// COR Label 249
if((pKeyInfo->nAllField < 13 && (pKeyInfo->aColl[0] == 0 || pKeyInfo->aColl[0] == db->pDfltColl) || (pKeyInfo->aSortFlags[0] & 2) == 0) != (pKeyInfo->nAllField < 13 && (pKeyInfo->aColl[0] == 0 || pKeyInfo->aColl[0] == db->pDfltColl) && (pKeyInfo->aSortFlags[0] & 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 249);
}
// COR Label 250
if((pKeyInfo->nAllField < 13 || (pKeyInfo->aColl[0] == 0 || pKeyInfo->aColl[0] == db->pDfltColl)) != (pKeyInfo->nAllField < 13 && (pKeyInfo->aColl[0] == 0 || pKeyInfo->aColl[0] == db->pDfltColl)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 250);
}

// ROR Label 251
if((pKeyInfo->nAllField <= 13) != (pKeyInfo->nAllField < 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}
// ROR Label 252
if((pKeyInfo->nAllField > 13) != (pKeyInfo->nAllField < 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((pKeyInfo->nAllField >= 13) != (pKeyInfo->nAllField < 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
// ROR Label 254
if(((pKeyInfo->aSortFlags[0] & 2) != 0) != ((pKeyInfo->aSortFlags[0] & 2) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}

// MCC Label 255
if(pKeyInfo->nAllField < 13 && ( pKeyInfo->aColl[0] == 0 && pKeyInfo->aColl[0] == db->pDfltColl ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 255);
}
// MCC Label 256
if(pKeyInfo->nAllField < 13 && ( pKeyInfo->aColl[0] == 0 && pKeyInfo->aColl[0] == db->pDfltColl ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 256);
}
// MCC Label 257
if(pKeyInfo->nAllField < 13 && ( pKeyInfo->aColl[0] == 0 && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 257);
}
// MCC Label 258
if(pKeyInfo->nAllField < 13 && ( pKeyInfo->aColl[0] == 0 && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 258);
}
// MCC Label 259
if(pKeyInfo->nAllField < 13 && ( !(pKeyInfo->aColl[0] == 0) && pKeyInfo->aColl[0] == db->pDfltColl ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 259);
}
// MCC Label 260
if(pKeyInfo->nAllField < 13 && ( !(pKeyInfo->aColl[0] == 0) && pKeyInfo->aColl[0] == db->pDfltColl ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if(pKeyInfo->nAllField < 13 && ( !(pKeyInfo->aColl[0] == 0) && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(pKeyInfo->nAllField < 13 && ( !(pKeyInfo->aColl[0] == 0) && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(!(pKeyInfo->nAllField < 13) && ( pKeyInfo->aColl[0] == 0 && pKeyInfo->aColl[0] == db->pDfltColl ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
// MCC Label 264
if(!(pKeyInfo->nAllField < 13) && ( pKeyInfo->aColl[0] == 0 && pKeyInfo->aColl[0] == db->pDfltColl ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(!(pKeyInfo->nAllField < 13) && ( pKeyInfo->aColl[0] == 0 && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(!(pKeyInfo->nAllField < 13) && ( pKeyInfo->aColl[0] == 0 && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(!(pKeyInfo->nAllField < 13) && ( !(pKeyInfo->aColl[0] == 0) && pKeyInfo->aColl[0] == db->pDfltColl ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(!(pKeyInfo->nAllField < 13) && ( !(pKeyInfo->aColl[0] == 0) && pKeyInfo->aColl[0] == db->pDfltColl ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if(!(pKeyInfo->nAllField < 13) && ( !(pKeyInfo->aColl[0] == 0) && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && (pKeyInfo->aSortFlags[0] & 2) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(!(pKeyInfo->nAllField < 13) && ( !(pKeyInfo->aColl[0] == 0) && !(pKeyInfo->aColl[0] == db->pDfltColl) ) && !((pKeyInfo->aSortFlags[0] & 2) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
if( pKeyInfo->nAllField<13 
     && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)
     && (pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL)==0
    ){
      pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;
    }
  }

  
// ABS Label 271
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
return rc;
}
#undef nWorker   /* Defined at the top of this function */

/*
** Free the list of sorted records starting at pRecord.
*/
static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){
  SorterRecord *p;
  SorterRecord *pNext;
  p = pRecord;

// ABS Label 272
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
for(; p; p=pNext){
    pNext = p->u.pNext;
    
// ABS Label 274
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}
sqlite3DbFree(db, p);
  };
// ABS Label 273
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

}

/*
** Free all resources owned by the object indicated by argument pTask. All 
** fields of *pTask are zeroed before returning.
*/
static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){
  
// ABS Label 275
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
sqlite3DbFree(db, pTask->pUnpacked);
#if SQLITE_MAX_WORKER_THREADS>0
  /* pTask->list.aMemory can only be non-zero if it was handed memory
  ** from the main thread.  That only occurs SQLITE_MAX_WORKER_THREADS>0 */
  
// ABS Label 276
if(pTask->list.aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
if( pTask->list.aMemory ){
    sqlite3_free(pTask->list.aMemory);
  }else
#endif
  {
    assert( pTask->list.aMemory==0 );
    
// ABS Label 277
if(pTask->list.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
vdbeSorterRecordFree(0, pTask->list.pList);
  }
  
// ABS Label 278
if(pTask->file.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}
if( pTask->file.pFd ){
    
// ABS Label 279
if(pTask->file.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}
sqlite3OsCloseFree(pTask->file.pFd);
  }
  
// ABS Label 280
if(pTask->file2.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
if( pTask->file2.pFd ){
    
// ABS Label 281
if(pTask->file2.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}
sqlite3OsCloseFree(pTask->file2.pFd);
  }
  memset(pTask, 0, sizeof(SortSubtask));
}

#ifdef SQLITE_DEBUG_SORTER_THREADS
static void vdbeSorterWorkDebug(SortSubtask *pTask, const char *zEvent){
  i64 t;
  int iTask = (pTask - pTask->pSorter->aTask);
  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
  fprintf(stderr, "%lld:%d %s\n", t, iTask, zEvent);
}
static void vdbeSorterRewindDebug(const char *zEvent){
  i64 t = 0;
  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
  if( ALWAYS(pVfs) ) sqlite3OsCurrentTimeInt64(pVfs, &t);
  fprintf(stderr, "%lld:X %s\n", t, zEvent);
}
static void vdbeSorterPopulateDebug(
  SortSubtask *pTask,
  const char *zEvent
){
  i64 t;
  int iTask = (pTask - pTask->pSorter->aTask);
  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
  fprintf(stderr, "%lld:bg%d %s\n", t, iTask, zEvent);
}
static void vdbeSorterBlockDebug(
  SortSubtask *pTask,
  int bBlocked,
  const char *zEvent
){
  if( bBlocked ){
    i64 t;
    sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);
    fprintf(stderr, "%lld:main %s\n", t, zEvent);
  }
}
#else
# define vdbeSorterWorkDebug(x,y)
# define vdbeSorterRewindDebug(y)
# define vdbeSorterPopulateDebug(x,y)
# define vdbeSorterBlockDebug(x,y,z)
#endif

#if SQLITE_MAX_WORKER_THREADS>0
/*
** Join thread pTask->thread.
*/
static int vdbeSorterJoinThread(SortSubtask *pTask){
  int rc = SQLITE_OK;
  
// ABS Label 282
if(pTask->pThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
if( pTask->pThread ){
#ifdef SQLITE_DEBUG_SORTER_THREADS
    int bDone = pTask->bDone;
#endif
    void *pRet = SQLITE_INT_TO_PTR(SQLITE_ERROR);
    vdbeSorterBlockDebug(pTask, !bDone, "enter");
    (void)sqlite3ThreadJoin(pTask->pThread, &pRet);
    vdbeSorterBlockDebug(pTask, !bDone, "exit");
    rc = SQLITE_PTR_TO_INT(pRet);
    assert( pTask->bDone==1 );
    pTask->bDone = 0;
    pTask->pThread = 0;
  }
  
// ABS Label 283
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}
return rc;
}

/*
** Launch a background thread to run xTask(pIn).
*/
static int vdbeSorterCreateThread(
  SortSubtask *pTask,             /* Thread will use this task object */
  void *(*xTask)(void*),          /* Routine to run in a separate thread */
  void *pIn                       /* Argument passed into xTask() */
){
  assert( pTask->pThread==0 && pTask->bDone==0 );
  return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn);
}

/*
** Join all outstanding threads launched by SorterWrite() to create 
** level-0 PMAs.
*/
static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){
  
// ABS Label 284
if(rcin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}
int rc = rcin;
  int i;

  /* This function is always called by the main user thread.
  **
  ** If this function is being called after SorterRewind() has been called, 
  ** it is possible that thread pSorter->aTask[pSorter->nTask-1].pThread
  ** is currently attempt to join one of the other threads. To avoid a race
  ** condition where this thread also attempts to join the same object, join 
  ** thread pSorter->aTask[pSorter->nTask-1].pThread first. */
  i = pSorter->nTask - 1;

// ABS Label 285
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}

// ROR Label 286
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
// ROR Label 287
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
// ROR Label 288
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
for(; i>=0; i--){
    SortSubtask *pTask = &pSorter->aTask[i];
    int rc2 = vdbeSorterJoinThread(pTask);
    
// ABS Label 293
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}

// ROR Label 294
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}
if( rc==SQLITE_OK ) { rc = rc2;
}
  };
// ABS Label 289
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// ROR Label 290
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 290);
}
// ROR Label 291
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 291);
}
// ROR Label 292
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}

  
// ABS Label 295
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
return rc;
}
#else
# define vdbeSorterJoinAll(x,rcin) (rcin)
# define vdbeSorterJoinThread(pTask) SQLITE_OK
#endif

/*
** Allocate a new MergeEngine object capable of handling up to
** nReader PmaReader inputs.
**
** nReader is automatically rounded up to the next power of two.
** nReader may not exceed SORTER_MAX_MERGE_COUNT even after rounding up.
*/
static MergeEngine *vdbeMergeEngineNew(int nReader){
  int N = 2;                      /* Smallest power of two >= nReader */
  int nByte;                      /* Total bytes of space to allocate */
  MergeEngine *pNew;              /* Pointer to allocated object to return */

  assert( nReader<=SORTER_MAX_MERGE_COUNT );

  
// ABS Label 296
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
// ABS Label 297
if(nReader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}

// ROR Label 298
if((N <= nReader) != (N < nReader))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
// ROR Label 299
if((N > nReader) != (N < nReader))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 299);
}
// ROR Label 300
if((N >= nReader) != (N < nReader))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 300);
}
while( N<nReader ) { N += N;
};
// ABS Label 301
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}
// ABS Label 302
if(nReader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}

// ROR Label 303
if((N <= nReader) != (N < nReader))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 303);
}
// ROR Label 304
if((N > nReader) != (N < nReader))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 304);
}
// ROR Label 305
if((N >= nReader) != (N < nReader))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 305);
}

  nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));

  pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);
  
// ABS Label 306
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
if( pNew ){
    pNew->nTree = N;
    pNew->pTask = 0;
    pNew->aReadr = (PmaReader*)&pNew[1];
    pNew->aTree = (int*)&pNew->aReadr[N];
  }
  
// ABS Label 307
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
return pNew;
}

/*
** Free the MergeEngine object passed as the only argument.
*/
static void vdbeMergeEngineFree(MergeEngine *pMerger){
  int i;
  
// ABS Label 308
if(pMerger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}
if( pMerger ){
    i = 0;

// ABS Label 309
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 309);
}
// ABS Label 310
if(pMerger->nTree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}

// ROR Label 311
if((i <= pMerger->nTree) != (i < pMerger->nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
// ROR Label 312
if((i > pMerger->nTree) != (i < pMerger->nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 312);
}
// ROR Label 313
if((i >= pMerger->nTree) != (i < pMerger->nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 313);
}
for(; i<pMerger->nTree; i++){
      vdbePmaReaderClear(&pMerger->aReadr[i]);
    };
// ABS Label 314
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}
// ABS Label 315
if(pMerger->nTree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}

// ROR Label 316
if((i <= pMerger->nTree) != (i < pMerger->nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
// ROR Label 317
if((i > pMerger->nTree) != (i < pMerger->nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 317);
}
// ROR Label 318
if((i >= pMerger->nTree) != (i < pMerger->nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}

  }
  sqlite3_free(pMerger);
}

/*
** Free all resources associated with the IncrMerger object indicated by
** the first argument.
*/
static void vdbeIncrFree(IncrMerger *pIncr){
  
// ABS Label 319
if(pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
if( pIncr ){
#if SQLITE_MAX_WORKER_THREADS>0
    
// ABS Label 321
if(pIncr->bUseThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
if( pIncr->bUseThread ){
      
// ABS Label 322
if(pIncr->pTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
vdbeSorterJoinThread(pIncr->pTask);
      
// ABS Label 323
if(pIncr->aFile[0].pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
if( pIncr->aFile[0].pFd ) { 
// ABS Label 324
if(pIncr->aFile[0].pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}
sqlite3OsCloseFree(pIncr->aFile[0].pFd);
}
      
// ABS Label 325
if(pIncr->aFile[1].pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
if( pIncr->aFile[1].pFd ) { 
// ABS Label 326
if(pIncr->aFile[1].pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
sqlite3OsCloseFree(pIncr->aFile[1].pFd);
}
    }
#endif
    
// ABS Label 320
if(pIncr->pMerger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
vdbeMergeEngineFree(pIncr->pMerger);
    sqlite3_free(pIncr);
  }
}

/*
** Reset a sorting cursor back to its original empty state.
*/
void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){
  int i;
  (void)vdbeSorterJoinAll(pSorter, SQLITE_OK);
  assert( pSorter->bUseThreads || pSorter->pReader==0 );
#if SQLITE_MAX_WORKER_THREADS>0
  
// ABS Label 329
if(pSorter->pReader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
if( pSorter->pReader ){
    
// ABS Label 330
if(pSorter->pReader < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
vdbePmaReaderClear(pSorter->pReader);
    
// ABS Label 331
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
sqlite3DbFree(db, pSorter->pReader);
    pSorter->pReader = 0;
  }
#endif
  
// ABS Label 327
if(pSorter->pMerger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
vdbeMergeEngineFree(pSorter->pMerger);
  pSorter->pMerger = 0;
  i = 0;

// ABS Label 332
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// ROR Label 333
if((i <= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 333);
}
// ROR Label 334
if((i > pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
// ROR Label 335
if((i >= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 335);
}
for(; i<pSorter->nTask; i++){
    SortSubtask *pTask = &pSorter->aTask[i];
    
// ABS Label 340
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// ABS Label 341
if(pTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}
vdbeSortSubtaskCleanup(db, pTask);
    pTask->pSorter = pSorter;
  };
// ABS Label 336
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ROR Label 337
if((i <= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
// ROR Label 338
if((i > pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 338);
}
// ROR Label 339
if((i >= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 339);
}

  
// ABS Label 342
if(pSorter->list.aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// ROR Label 343
if((pSorter->list.aMemory != 0) != (pSorter->list.aMemory == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 343);
}
if( pSorter->list.aMemory==0 ){
    
// ABS Label 344
if(pSorter->list.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}
vdbeSorterRecordFree(0, pSorter->list.pList);
  }
  pSorter->list.pList = 0;
  pSorter->list.szPMA = 0;
  pSorter->bUsePMA = 0;
  pSorter->iMemory = 0;
  pSorter->mxKeysize = 0;
  
// ABS Label 328
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
sqlite3DbFree(db, pSorter->pUnpacked);
  pSorter->pUnpacked = 0;
}

/*
** Free any cursor components allocated by sqlite3VdbeSorterXXX routines.
*/
void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){
  VdbeSorter *pSorter;
  assert( pCsr->eCurType==CURTYPE_SORTER );
  pSorter = pCsr->uc.pSorter;
  
// ABS Label 345
if(pSorter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 345);
}
if( pSorter ){
    
// ABS Label 346
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 346);
}

// ABS Label 347
if(pSorter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 347);
}
sqlite3VdbeSorterReset(db, pSorter);
    sqlite3_free(pSorter->list.aMemory);
    
// ABS Label 348
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}
sqlite3DbFree(db, pSorter);
    pCsr->uc.pSorter = 0;
  }
}

#if SQLITE_MAX_MMAP_SIZE>0
/*
** The first argument is a file-handle open on a temporary file. The file
** is guaranteed to be nByte bytes or smaller in size. This function
** attempts to extend the file to nByte bytes in size and to ensure that
** the VFS has memory mapped it.
**
** Whether or not the file does end up memory mapped of course depends on
** the specific VFS implementation.
*/
static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){
  
// ABS Label 349
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}
// ABS Label 350
if(pFd->pMethods->iVersion < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 350);
}

// COR Label 351
if((nByte <= (i64)(db->nMaxSorterMmap) || pFd->pMethods->iVersion >= 3) != (nByte <= (i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 351);
}

// ROR Label 352
if((nByte < (i64)(db->nMaxSorterMmap)) != (nByte <= (i64)(db->nMaxSorterMmap)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 352);
}
// ROR Label 353
if((nByte > (i64)(db->nMaxSorterMmap)) != (nByte <= (i64)(db->nMaxSorterMmap)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 353);
}
// ROR Label 354
if((nByte >= (i64)(db->nMaxSorterMmap)) != (nByte <= (i64)(db->nMaxSorterMmap)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}
// ROR Label 355
if((pFd->pMethods->iVersion < 3) != (pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}
// ROR Label 356
if((pFd->pMethods->iVersion > 3) != (pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 356);
}
// ROR Label 357
if((pFd->pMethods->iVersion <= 3) != (pFd->pMethods->iVersion >= 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 357);
}

// MCC Label 358
if(nByte <= (i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion >= 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 358);
}
// MCC Label 359
if(nByte <= (i64)(db->nMaxSorterMmap) && !(pFd->pMethods->iVersion >= 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 359);
}
// MCC Label 360
if(!(nByte <= (i64)(db->nMaxSorterMmap)) && pFd->pMethods->iVersion >= 3 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 360);
}
// MCC Label 361
if(!(nByte <= (i64)(db->nMaxSorterMmap)) && !(pFd->pMethods->iVersion >= 3) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){
    void *p = 0;
    
// AOR Label 362
if(4 - 1024 != 4 * 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 362);
}
// AOR Label 363
if(4 + 1024 != 4 * 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 363);
}
// AOR Label 364
if(4 / 1024 != 4 * 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 364);
}
int chunksize = 4*1024;
    
// ABS Label 365
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}
sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_CHUNK_SIZE, &chunksize);
    
// ABS Label 366
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 366);
}
sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_SIZE_HINT, &nByte);
    
// ABS Label 367
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 367);
}
sqlite3OsFetch(pFd, 0, (int)nByte, &p);
    
// ABS Label 368
if(pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 368);
}

// ABS Label 369
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}
sqlite3OsUnfetch(pFd, 0, p);
  }
}
#else
# define vdbeSorterExtendFile(x,y,z)
#endif

/*
** Allocate space for a file-handle and open a temporary file. If successful,
** set *ppFd to point to the malloc'd file-handle and return SQLITE_OK.
** Otherwise, set *ppFd to 0 and return an SQLite error code.
*/
static int vdbeSorterOpenTempFile(
  sqlite3 *db,                    /* Database handle doing sort */
  i64 nExtend,                    /* Attempt to extend file to this size */
  sqlite3_file **ppFd
){
  int rc;
  if( sqlite3FaultSim(202) ) { 
// MCC Label 370
if(( 10 | (13 << 8) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(( !(10 | (13 << 8)) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}
return SQLITE_IOERR_ACCESS;
}
  rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,
      SQLITE_OPEN_TEMP_JOURNAL |
      SQLITE_OPEN_READWRITE    | SQLITE_OPEN_CREATE |
      SQLITE_OPEN_EXCLUSIVE    | SQLITE_OPEN_DELETEONCLOSE, &rc
  );
  
// ABS Label 372
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 372);
}

// ROR Label 373
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 373);
}
if( rc==SQLITE_OK ){
    i64 max = SQLITE_MAX_MMAP_SIZE;
    
// ABS Label 374
if(*ppFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}
sqlite3OsFileControlHint(*ppFd, SQLITE_FCNTL_MMAP_SIZE, (void*)&max);
    
// ABS Label 375
if(nExtend < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}

// ROR Label 376
if((nExtend <= 0) != (nExtend > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((nExtend < 0) != (nExtend > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((nExtend >= 0) != (nExtend > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}
if( nExtend>0 ){
      
// ABS Label 379
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// ABS Label 380
if(*ppFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 380);
}

// ABS Label 381
if(nExtend < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 381);
}
vdbeSorterExtendFile(db, *ppFd, nExtend);
    }
  }
  
// ABS Label 382
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 382);
}
return rc;
}

/*
** If it has not already been allocated, allocate the UnpackedRecord 
** structure at pTask->pUnpacked. Return SQLITE_OK if successful (or 
** if no allocation was required), or SQLITE_NOMEM otherwise.
*/
static int vdbeSortAllocUnpacked(SortSubtask *pTask){
  
// ABS Label 383
if(pTask->pUnpacked < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}

// ROR Label 384
if((pTask->pUnpacked != 0) != (pTask->pUnpacked == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 384);
}
if( pTask->pUnpacked==0 ){
    pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);
    
// ABS Label 385
if(pTask->pUnpacked < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}

// ROR Label 386
if((pTask->pUnpacked != 0) != (pTask->pUnpacked == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
if( pTask->pUnpacked==0 ) { return SQLITE_NOMEM_BKPT;
}
    pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;
    pTask->pUnpacked->errCode = 0;
  }
  return SQLITE_OK;
}


/*
** Merge the two sorted lists p1 and p2 into a single list.
*/
static SorterRecord *vdbeSorterMerge(
  SortSubtask *pTask,             /* Calling thread context */
  SorterRecord *p1,               /* First list to merge */
  SorterRecord *p2                /* Second list to merge */
){
  SorterRecord *pFinal = 0;
  SorterRecord **pp = &pFinal;
  int bCached = 0;

  assert( p1!=0 && p2!=0 );
  for(;;){
    int res;
    res = pTask->xCompare(
        pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal
    );

    
// ABS Label 387
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// ROR Label 388
if((res < 0) != (res <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 388);
}
// ROR Label 389
if((res > 0) != (res <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 389);
}
// ROR Label 390
if((res >= 0) != (res <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 390);
}
if( res<=0 ){
      *pp = p1;
      pp = &p1->u.pNext;
      p1 = p1->u.pNext;
      
// ABS Label 391
if(p1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}

// ROR Label 392
if((p1 != 0) != (p1 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 392);
}
if( p1==0 ){
        *pp = p2;
        break;
      }
    }else{
      *pp = p2;
      pp = &p2->u.pNext;
      p2 = p2->u.pNext;
      bCached = 0;
      
// ABS Label 393
if(p2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}

// ROR Label 394
if((p2 != 0) != (p2 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 394);
}
if( p2==0 ){
        *pp = p1;
        break;
      }
    }
  };
  
// ABS Label 395
if(pFinal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 395);
}
return pFinal;
}

/*
** Return the SorterCompare function to compare values collected by the
** sorter object passed as the only argument.
*/
static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){
  
// ROR Label 396
if((p->typeMask != 1) != (p->typeMask == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 396);
}
if( p->typeMask==SORTER_TYPE_INTEGER ){
    return vdbeSorterCompareInt;
  }else { 
// ROR Label 397
if((p->typeMask != 2) != (p->typeMask == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 397);
}
if( p->typeMask==SORTER_TYPE_TEXT ){
    return vdbeSorterCompareText; 
  };}

  return vdbeSorterCompare;
}

/*
** Sort the linked list of records headed at pTask->pList. Return 
** SQLITE_OK if successful, or an SQLite error code (i.e. SQLITE_NOMEM) if 
** an error occurs.
*/
static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){
  int i;
  SorterRecord *p;
  int rc;
  SorterRecord *aSlot[64];

  rc = vdbeSortAllocUnpacked(pTask);
  
// ABS Label 398
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}

// ROR Label 399
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 399);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 400
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}
return rc;
}

  p = pList->pList;
  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);
  memset(aSlot, 0, sizeof(aSlot));

  
// ABS Label 401
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 401);
}
while( p ){
    SorterRecord *pNext;
    
// ABS Label 403
if(pList->aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}
if( pList->aMemory ){
      
// ABS Label 404
if(pList->aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}

// ROR Label 405
if(((u8 *)p != pList->aMemory) != ((u8 *)p == pList->aMemory))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 405);
}
if( (u8*)p==pList->aMemory ){
        pNext = 0;
      }else{
        assert( p->u.iNext<sqlite3MallocSize(pList->aMemory) );
        pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];
      }
    }else{
      pNext = p->u.pNext;
    }

    p->u.pNext = 0;
    i = 0;

// ABS Label 406
if(aSlot[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}
// ABS Label 407
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}
for(; aSlot[i]; i++){
      p = vdbeSorterMerge(pTask, p, aSlot[i]);
      aSlot[i] = 0;
    };
// ABS Label 408
if(aSlot[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}
// ABS Label 409
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}

    aSlot[i] = p;
    p = pNext;
  };
// ABS Label 402
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}


  p = 0;
  i = 0;

// ABS Label 410
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ROR Label 411
if((i <= ((int)(sizeof (aSlot) / sizeof (aSlot[0])))) != (i < ((int)(sizeof (aSlot) / sizeof (aSlot[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 411);
}
// ROR Label 412
if((i > ((int)(sizeof (aSlot) / sizeof (aSlot[0])))) != (i < ((int)(sizeof (aSlot) / sizeof (aSlot[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 412);
}
// ROR Label 413
if((i >= ((int)(sizeof (aSlot) / sizeof (aSlot[0])))) != (i < ((int)(sizeof (aSlot) / sizeof (aSlot[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 413);
}
for(; i<ArraySize(aSlot); i++){
    
// ABS Label 418
if(aSlot[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
// ABS Label 419
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}

// ROR Label 420
if((aSlot[i] != 0) != (aSlot[i] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
if( aSlot[i]==0 ) { continue;
}
    p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
  };
// ABS Label 414
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// ROR Label 415
if((i <= ((int)(sizeof (aSlot) / sizeof (aSlot[0])))) != (i < ((int)(sizeof (aSlot) / sizeof (aSlot[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 415);
}
// ROR Label 416
if((i > ((int)(sizeof (aSlot) / sizeof (aSlot[0])))) != (i < ((int)(sizeof (aSlot) / sizeof (aSlot[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 416);
}
// ROR Label 417
if((i >= ((int)(sizeof (aSlot) / sizeof (aSlot[0])))) != (i < ((int)(sizeof (aSlot) / sizeof (aSlot[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 417);
}

  pList->pList = p;

  assert( pTask->pUnpacked->errCode==SQLITE_OK 
       || pTask->pUnpacked->errCode==SQLITE_NOMEM 
  );
  return pTask->pUnpacked->errCode;
}

/*
** Initialize a PMA-writer object.
*/
static void vdbePmaWriterInit(
  sqlite3_file *pFd,              /* File handle to write to */
  PmaWriter *p,                   /* Object to populate */
  int nBuf,                       /* Buffer size */
  i64 iStart                      /* Offset of pFd to begin writing at */
){
  memset(p, 0, sizeof(PmaWriter));
  p->aBuffer = (u8*)sqlite3Malloc(nBuf);
  if( !p->aBuffer ){
    p->eFWErr = SQLITE_NOMEM_BKPT;
  }else{
    p->iBufEnd = p->iBufStart = (iStart % nBuf);
    p->iWriteOff = iStart - p->iBufStart;
    p->nBuffer = nBuf;
    p->pFd = pFd;
  }
}

/*
** Write nData bytes of data to the PMA. Return SQLITE_OK
** if successful, or an SQLite error code if an error occurs.
*/
static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){
  
// ABS Label 421
if(nData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}
int nRem = nData;
  
// ABS Label 422
if(nRem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}
// ABS Label 423
if(p->eFWErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}

// COR Label 424
if((nRem > 0 || p->eFWErr == 0) != (nRem > 0 && p->eFWErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 424);
}

// ROR Label 425
if((nRem <= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
// ROR Label 426
if((nRem < 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 426);
}
// ROR Label 427
if((nRem >= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
// ROR Label 428
if((p->eFWErr != 0) != (p->eFWErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 428);
}

// MCC Label 429
if(nRem > 0 && p->eFWErr == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 429);
}
// MCC Label 430
if(nRem > 0 && !(p->eFWErr == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 430);
}
// MCC Label 431
if(!(nRem > 0) && p->eFWErr == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 431);
}
// MCC Label 432
if(!(nRem > 0) && !(p->eFWErr == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 432);
}
while( nRem>0 && p->eFWErr==0 ){
    
// ABS Label 444
if(nRem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
int nCopy = nRem;
    
// ABS Label 445
if(nCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}

// ROR Label 446
if((nCopy <= (p->nBuffer - p->iBufEnd)) != (nCopy > (p->nBuffer - p->iBufEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 446);
}
// ROR Label 447
if((nCopy < (p->nBuffer - p->iBufEnd)) != (nCopy > (p->nBuffer - p->iBufEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 447);
}
// ROR Label 448
if((nCopy >= (p->nBuffer - p->iBufEnd)) != (nCopy > (p->nBuffer - p->iBufEnd)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
if( nCopy>(p->nBuffer - p->iBufEnd) ){
      nCopy = p->nBuffer - p->iBufEnd;
    }

    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);
    p->iBufEnd += nCopy;
    
// ABS Label 449
if(p->iBufEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}
// ABS Label 450
if(p->nBuffer < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 450);
}

// ROR Label 451
if((p->iBufEnd != p->nBuffer) != (p->iBufEnd == p->nBuffer))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
if( p->iBufEnd==p->nBuffer ){
      p->eFWErr = sqlite3OsWrite(p->pFd, 
          &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart, 
          p->iWriteOff + p->iBufStart
      );
      p->iBufStart = p->iBufEnd = 0;
      p->iWriteOff += p->nBuffer;
    }
    assert( p->iBufEnd<p->nBuffer );

    nRem -= nCopy;
  };
// ABS Label 433
if(nRem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 433);
}
// ABS Label 434
if(p->eFWErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}

// COR Label 435
if((nRem > 0 || p->eFWErr == 0) != (nRem > 0 && p->eFWErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 435);
}

// ROR Label 436
if((nRem <= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((nRem < 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
// ROR Label 438
if((nRem >= 0) != (nRem > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}
// ROR Label 439
if((p->eFWErr != 0) != (p->eFWErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 439);
}

// MCC Label 440
if(nRem > 0 && p->eFWErr == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(nRem > 0 && !(p->eFWErr == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(!(nRem > 0) && p->eFWErr == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(!(nRem > 0) && !(p->eFWErr == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}

}

/*
** Flush any buffered data to disk and clean up the PMA-writer object.
** The results of using the PMA-writer after this call are undefined.
** Return SQLITE_OK if flushing the buffered data succeeds or is not 
** required. Otherwise, return an SQLite error code.
**
** Before returning, set *piEof to the offset immediately following the
** last byte written to the file.
*/
static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof){
  int rc;
  
// ABS Label 452
if((p->aBuffer) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 452);
}
// ABS Label 453
if(p->eFWErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
// ABS Label 454
if(p->iBufEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}
// ABS Label 455
if(p->iBufStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 455);
}

// COR Label 456
if((p->eFWErr == 0 && (p->aBuffer) || p->iBufEnd > p->iBufStart) != (p->eFWErr == 0 && (p->aBuffer) && p->iBufEnd > p->iBufStart))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 456);
}
// COR Label 457
if((p->eFWErr == 0 || (p->aBuffer)) != (p->eFWErr == 0 && (p->aBuffer)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 457);
}

// ROR Label 458
if((p->eFWErr != 0) != (p->eFWErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 458);
}
// ROR Label 459
if((p->iBufEnd <= p->iBufStart) != (p->iBufEnd > p->iBufStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 459);
}
// ROR Label 460
if((p->iBufEnd < p->iBufStart) != (p->iBufEnd > p->iBufStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}
// ROR Label 461
if((p->iBufEnd >= p->iBufStart) != (p->iBufEnd > p->iBufStart))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}

// MCC Label 462
if(p->eFWErr == 0 && (p->aBuffer) && p->iBufEnd > p->iBufStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 462);
}
// MCC Label 463
if(p->eFWErr == 0 && (p->aBuffer) && !(p->iBufEnd > p->iBufStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 463);
}
// MCC Label 464
if(p->eFWErr == 0 && !((p->aBuffer)) && p->iBufEnd > p->iBufStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
// MCC Label 465
if(p->eFWErr == 0 && !((p->aBuffer)) && !(p->iBufEnd > p->iBufStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 465);
}
// MCC Label 466
if(!(p->eFWErr == 0) && (p->aBuffer) && p->iBufEnd > p->iBufStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 466);
}
// MCC Label 467
if(!(p->eFWErr == 0) && (p->aBuffer) && !(p->iBufEnd > p->iBufStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 467);
}
// MCC Label 468
if(!(p->eFWErr == 0) && !((p->aBuffer)) && p->iBufEnd > p->iBufStart ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 468);
}
// MCC Label 469
if(!(p->eFWErr == 0) && !((p->aBuffer)) && !(p->iBufEnd > p->iBufStart) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 469);
}
if( p->eFWErr==0 && ALWAYS(p->aBuffer) && p->iBufEnd>p->iBufStart ){
    p->eFWErr = sqlite3OsWrite(p->pFd, 
        &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart, 
        p->iWriteOff + p->iBufStart
    );
  }
  *piEof = (p->iWriteOff + p->iBufEnd);
  sqlite3_free(p->aBuffer);
  rc = p->eFWErr;
  memset(p, 0, sizeof(PmaWriter));
  
// ABS Label 470
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 470);
}
return rc;
}

/*
** Write value iVal encoded as a varint to the PMA. Return 
** SQLITE_OK if successful, or an SQLite error code if an error occurs.
*/
static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){
  int nByte; 
  u8 aByte[10];
  nByte = sqlite3PutVarint(aByte, iVal);
  
// ABS Label 471
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 471);
}

// ABS Label 472
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}
vdbePmaWriteBlob(p, aByte, nByte);
}

/*
** Write the current contents of in-memory linked-list pList to a level-0
** PMA in the temp file belonging to sub-task pTask. Return SQLITE_OK if 
** successful, or an SQLite error code otherwise.
**
** The format of a PMA is:
**
**     * A varint. This varint contains the total number of bytes of content
**       in the PMA (not including the varint itself).
**
**     * One or more records packed end-to-end in order of ascending keys. 
**       Each record consists of a varint followed by a blob of data (the 
**       key). The varint is the number of bytes in the blob of data.
*/
static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){
  
// ABS Label 473
if(pTask->pSorter->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}
sqlite3 *db = pTask->pSorter->db;
  int rc = SQLITE_OK;             /* Return code */
  PmaWriter writer;               /* Object used to write to the file */

#ifdef SQLITE_DEBUG
  /* Set iSz to the expected size of file pTask->file after writing the PMA. 
  ** This is used by an assert() statement at the end of this function.  */
  i64 iSz = pList->szPMA + sqlite3VarintLen(pList->szPMA) + pTask->file.iEof;
#endif

  vdbeSorterWorkDebug(pTask, "enter");
  memset(&writer, 0, sizeof(PmaWriter));
  assert( pList->szPMA>0 );

  /* If the first temporary PMA file has not been opened, open it now. */
  
// ABS Label 474
if(pTask->file.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}

// ROR Label 475
if((pTask->file.pFd != 0) != (pTask->file.pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 475);
}
if( pTask->file.pFd==0 ){
    rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);
    assert( rc!=SQLITE_OK || pTask->file.pFd );
    assert( pTask->file.iEof==0 );
    assert( pTask->nPMA==0 );
  }

  /* Try to get the file to memory map */
  
// ABS Label 476
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 476);
}

// ROR Label 477
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 477);
}
if( rc==SQLITE_OK ){
    
// ABS Label 478
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}

// ABS Label 479
if(pTask->file.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// ABS Label 480
if(pTask->file.iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}

// AOR Label 481
if(pTask->file.iEof + pList->szPMA - 9 != pTask->file.iEof + pList->szPMA + 9)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 481);
}
// AOR Label 482
if(pTask->file.iEof + pList->szPMA / 9 != pTask->file.iEof + pList->szPMA + 9)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 482);
}
// AOR Label 483
if(pTask->file.iEof + pList->szPMA * 9 != pTask->file.iEof + pList->szPMA + 9)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 483);
}
// AOR Label 484
if(pTask->file.iEof - pList->szPMA != pTask->file.iEof + pList->szPMA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 484);
}
// AOR Label 485
if(pTask->file.iEof / pList->szPMA != pTask->file.iEof + pList->szPMA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 485);
}
// AOR Label 486
if(pTask->file.iEof * pList->szPMA != pTask->file.iEof + pList->szPMA)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 486);
}
vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof+pList->szPMA+9);
  }

  /* Sort the list */
  
// ABS Label 487
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}

// ROR Label 488
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 488);
}
if( rc==SQLITE_OK ){
    rc = vdbeSorterSort(pTask, pList);
  }

  
// ABS Label 489
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 489);
}

// ROR Label 490
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 490);
}
if( rc==SQLITE_OK ){
    SorterRecord *p;
    SorterRecord *pNext = 0;

    
// ABS Label 491
if(pTask->file.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 491);
}

// ABS Label 492
if(pTask->pSorter->pgsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}

// ABS Label 493
if(pTask->file.iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}
vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,
                      pTask->file.iEof);
    pTask->nPMA++;
    vdbePmaWriteVarint(&writer, pList->szPMA);
    p = pList->pList;

// ABS Label 494
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 494);
}
for(; p; p=pNext){
      pNext = p->u.pNext;
      vdbePmaWriteVarint(&writer, p->nVal);
      
// ABS Label 496
if(p->nVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 496);
}
vdbePmaWriteBlob(&writer, SRVAL(p), p->nVal);
      
// ABS Label 497
if(pList->aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// ROR Label 498
if((pList->aMemory != 0) != (pList->aMemory == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 498);
}
if( pList->aMemory==0 ) { sqlite3_free(p);
}
    };
// ABS Label 495
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 495);
}

    pList->pList = p;
    rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof);
  }

  vdbeSorterWorkDebug(pTask, "exit");
  assert( rc!=SQLITE_OK || pList->pList==0 );
  assert( rc!=SQLITE_OK || pTask->file.iEof==iSz );
  
// ABS Label 499
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 499);
}
return rc;
}

/*
** Advance the MergeEngine to its next entry.
** Set *pbEof to true there is no next entry because
** the MergeEngine has reached the end of all its inputs.
**
** Return SQLITE_OK if successful or an error code if an error occurs.
*/
static int vdbeMergeEngineStep(
  MergeEngine *pMerger,      /* The merge engine to advance to the next row */
  int *pbEof                 /* Set TRUE at EOF.  Set false for more content */
){
  int rc;
  
// ABS Label 500
if(pMerger->aTree[1] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}
int iPrev = pMerger->aTree[1];/* Index of PmaReader to advance */
  
// ABS Label 501
if(pMerger->pTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}
SortSubtask *pTask = pMerger->pTask;

  /* Advance the current PmaReader */
  rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);

  /* Update contents of aTree[] */
  
// ABS Label 502
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 502);
}

// ROR Label 503
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 503);
}
if( rc==SQLITE_OK ){
    int i;                      /* Index of aTree[] to recalculate */
    PmaReader *pReadr1;         /* First PmaReader to compare */
    PmaReader *pReadr2;         /* Second PmaReader to compare */
    int bCached = 0;

    /* Find the first two PmaReaders to compare. The one that was just
    ** advanced (iPrev) and the one next to it in the array.  */
    pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];
    pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];

    i = (pMerger->nTree + iPrev) / 2;

// ABS Label 504
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}

// ROR Label 505
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 505);
}
// ROR Label 506
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 506);
}
// ROR Label 507
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 507);
}
for(; i>0; i=i/2){
      /* Compare pReadr1 and pReadr2. Store the result in variable iRes. */
      int iRes;
      
// ABS Label 512
if(pReadr1->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}

// ROR Label 513
if((pReadr1->pFd != 0) != (pReadr1->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}
if( pReadr1->pFd==0 ){
        iRes = +1;
      }else { 
// ABS Label 514
if(pReadr2->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}

// ROR Label 515
if((pReadr2->pFd != 0) != (pReadr2->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 515);
}
if( pReadr2->pFd==0 ){
        iRes = -1;
      }else{
        iRes = pTask->xCompare(pTask, &bCached,
            pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey
        );
      };}


      /* If pReadr1 contained the smaller value, set aTree[i] to its index.
      ** Then set pReadr2 to the next PmaReader to compare to pReadr1. In this
      ** case there is no cache of pReadr2 in pTask->pUnpacked, so set
      ** pKey2 to point to the record belonging to pReadr2.
      **
      ** Alternatively, if pReadr2 contains the smaller of the two values,
      ** set aTree[i] to its index and update pReadr1. If vdbeSorterCompare()
      ** was actually called above, then pTask->pUnpacked now contains
      ** a value equivalent to pReadr2. So set pKey2 to NULL to prevent
      ** vdbeSorterCompare() from decoding pReadr2 again.
      **
      ** If the two values were equal, then the value from the oldest
      ** PMA should be considered smaller. The VdbeSorter.aReadr[] array
      ** is sorted from oldest to newest, so pReadr1 contains older values
      ** than pReadr2 iff (pReadr1<pReadr2).  */
      
// ABS Label 516
if(iRes < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 516);
}

// COR Label 517
if((iRes < 0 && (iRes == 0 && pReadr1 < pReadr2)) != (iRes < 0 || (iRes == 0 && pReadr1 < pReadr2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 517);
}

// ROR Label 518
if((iRes <= 0) != (iRes < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 518);
}
// ROR Label 519
if((iRes > 0) != (iRes < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 519);
}
// ROR Label 520
if((iRes >= 0) != (iRes < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 520);
}

// MCC Label 521
if(iRes < 0 && ( iRes == 0 && pReadr1 < pReadr2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 521);
}
// MCC Label 522
if(iRes < 0 && ( iRes == 0 && !(pReadr1 < pReadr2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 522);
}
// MCC Label 523
if(iRes < 0 && ( !(iRes == 0) && pReadr1 < pReadr2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 523);
}
// MCC Label 524
if(iRes < 0 && ( !(iRes == 0) && !(pReadr1 < pReadr2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 524);
}
// MCC Label 525
if(!(iRes < 0) && ( iRes == 0 && pReadr1 < pReadr2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 525);
}
// MCC Label 526
if(!(iRes < 0) && ( iRes == 0 && !(pReadr1 < pReadr2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 526);
}
// MCC Label 527
if(!(iRes < 0) && ( !(iRes == 0) && pReadr1 < pReadr2 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 527);
}
// MCC Label 528
if(!(iRes < 0) && ( !(iRes == 0) && !(pReadr1 < pReadr2) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 528);
}
if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){
        pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);
        pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
        bCached = 0;
      }else{
        
// ABS Label 529
if(pReadr1->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 529);
}
if( pReadr1->pFd ) { bCached = 0;
}
        pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);
        pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
      }
    };
// ABS Label 508
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}

// ROR Label 509
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 509);
}
// ROR Label 510
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 510);
}
// ROR Label 511
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 511);
}

    *pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);
  }

  
// MCC Label 530
if(( ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 530);
}
return (rc==SQLITE_OK ? pTask->pUnpacked->errCode : rc);
}

#if SQLITE_MAX_WORKER_THREADS>0
/*
** The main routine for background threads that write level-0 PMAs.
*/
static void *vdbeSorterFlushThread(void *pCtx){
  SortSubtask *pTask = (SortSubtask*)pCtx;
  int rc;                         /* Return code */
  assert( pTask->bDone==0 );
  rc = vdbeSorterListToPMA(pTask, &pTask->list);
  pTask->bDone = 1;
  
// MCC Label 531
if(( ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 531);
}
return SQLITE_INT_TO_PTR(rc);
}
#endif /* SQLITE_MAX_WORKER_THREADS>0 */

/*
** Flush the current contents of VdbeSorter.list to a new PMA, possibly
** using a background thread.
*/
static int vdbeSorterFlushPMA(VdbeSorter *pSorter){
#if SQLITE_MAX_WORKER_THREADS==0
  pSorter->bUsePMA = 1;
  return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);
#else
  int rc = SQLITE_OK;
  int i;
  SortSubtask *pTask = 0;    /* Thread context used to create new PMA */
  int nWorker = (pSorter->nTask-1);

  /* Set the flag to indicate that at least one PMA has been written. 
  ** Or will be, anyhow.  */
  pSorter->bUsePMA = 1;

  /* Select a sub-task to sort and flush the current list of in-memory
  ** records to disk. If the sorter is running in multi-threaded mode,
  ** round-robin between the first (pSorter->nTask-1) tasks. Except, if
  ** the background thread from a sub-tasks previous turn is still running,
  ** skip it. If the first (pSorter->nTask-1) sub-tasks are all still busy,
  ** fall back to using the final sub-task. The first (pSorter->nTask-1)
  ** sub-tasks are prefered as they use background threads - the final 
  ** sub-task uses the main thread. */
  i = 0;

// ABS Label 532
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 532);
}
// ABS Label 533
if(nWorker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}

// ROR Label 534
if((i <= nWorker) != (i < nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 534);
}
// ROR Label 535
if((i > nWorker) != (i < nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 535);
}
// ROR Label 536
if((i >= nWorker) != (i < nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 536);
}
for(; i<nWorker; i++){
    
// ABS Label 542
if(nWorker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}

// AOR Label 543
if((pSorter->iPrev + i + 1) - nWorker != (pSorter->iPrev + i + 1) % nWorker)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 543);
}
// AOR Label 544
if((pSorter->iPrev + i + 1) + nWorker != (pSorter->iPrev + i + 1) % nWorker)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 544);
}
// AOR Label 545
if((pSorter->iPrev + i + 1) * nWorker != (pSorter->iPrev + i + 1) % nWorker)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 545);
}
int iTest = (pSorter->iPrev + i + 1) % nWorker;
    pTask = &pSorter->aTask[iTest];
    
// ABS Label 546
if(pTask->bDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}
if( pTask->bDone ){
      rc = vdbeSorterJoinThread(pTask);
    }
    
// ABS Label 547
if(pTask->pThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}
// ABS Label 548
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}

// COR Label 549
if((rc != 0 && pTask->pThread == 0) != (rc != 0 || pTask->pThread == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 549);
}

// ROR Label 550
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 550);
}
// ROR Label 551
if((pTask->pThread != 0) != (pTask->pThread == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 551);
}

// MCC Label 552
if(rc != 0 && pTask->pThread == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 552);
}
// MCC Label 553
if(rc != 0 && !(pTask->pThread == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 553);
}
// MCC Label 554
if(!(rc != 0) && pTask->pThread == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 554);
}
// MCC Label 555
if(!(rc != 0) && !(pTask->pThread == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 555);
}
if( rc!=SQLITE_OK || pTask->pThread==0 ) { break;
}
  };
// ABS Label 537
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 537);
}
// ABS Label 538
if(nWorker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 538);
}

// ROR Label 539
if((i <= nWorker) != (i < nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 539);
}
// ROR Label 540
if((i > nWorker) != (i < nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 540);
}
// ROR Label 541
if((i >= nWorker) != (i < nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 541);
}


  
// ABS Label 556
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}

// ROR Label 557
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 557);
}
if( rc==SQLITE_OK ){
    
// ABS Label 558
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}
// ABS Label 559
if(nWorker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 559);
}

// ROR Label 560
if((i != nWorker) != (i == nWorker))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 560);
}
if( i==nWorker ){
      /* Use the foreground thread for this operation */
      rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
    }else{
      /* Launch a background thread for this operation */
      u8 *aMem;
      void *pCtx;

      assert( pTask!=0 );
      assert( pTask->pThread==0 && pTask->bDone==0 );
      assert( pTask->list.pList==0 );
      assert( pTask->list.aMemory==0 || pSorter->list.aMemory!=0 );

      aMem = pTask->list.aMemory;
      pCtx = (void*)pTask;
      pSorter->iPrev = (u8)(pTask - pSorter->aTask);
      pTask->list = pSorter->list;
      pSorter->list.pList = 0;
      pSorter->list.szPMA = 0;
      
// ABS Label 561
if(aMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 561);
}
if( aMem ){
        pSorter->list.aMemory = aMem;
        pSorter->nMemory = sqlite3MallocSize(aMem);
      }else { 
// ABS Label 562
if(pSorter->list.aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 562);
}
if( pSorter->list.aMemory ){
        pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);
        if( !pSorter->list.aMemory ) { return SQLITE_NOMEM_BKPT;
}
      };}


      rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);
    }
  }

  
// ABS Label 563
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 563);
}
return rc;
#endif /* SQLITE_MAX_WORKER_THREADS!=0 */
}

/*
** Add a record to the sorter.
*/
int sqlite3VdbeSorterWrite(
  const VdbeCursor *pCsr,         /* Sorter cursor */
  Mem *pVal                       /* Memory cell containing record */
){
  VdbeSorter *pSorter;
  int rc = SQLITE_OK;             /* Return Code */
  SorterRecord *pNew;             /* New list element */
  int bFlush;                     /* True to flush contents of memory to PMA */
  int nReq;                       /* Bytes of memory required */
  int nPMA;                       /* Bytes of PMA space required */
  int t;                          /* serial type of first record field */

  assert( pCsr->eCurType==CURTYPE_SORTER );
  pSorter = pCsr->uc.pSorter;
  getVarint32NR((const u8*)&pVal->z[1], t);
  
// ABS Label 568
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 568);
}

// COR Label 569
if((t > 0 && t < 10 || t != 7) != (t > 0 && t < 10 && t != 7))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 569);
}
// COR Label 570
if((t > 0 || t < 10) != (t > 0 && t < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 570);
}

// ROR Label 571
if((t <= 0) != (t > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}
// ROR Label 572
if((t < 0) != (t > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
// ROR Label 573
if((t >= 0) != (t > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 573);
}
// ROR Label 574
if((t <= 10) != (t < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 574);
}
// ROR Label 575
if((t > 10) != (t < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 575);
}
// ROR Label 576
if((t >= 10) != (t < 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 576);
}
// ROR Label 577
if((t == 7) != (t != 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 577);
}

// MCC Label 578
if(t > 0 && t < 10 && t != 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
// MCC Label 579
if(t > 0 && t < 10 && !(t != 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 579);
}
// MCC Label 580
if(t > 0 && !(t < 10) && t != 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 580);
}
// MCC Label 581
if(t > 0 && !(t < 10) && !(t != 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 581);
}
// MCC Label 582
if(!(t > 0) && t < 10 && t != 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(!(t > 0) && t < 10 && !(t != 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(!(t > 0) && !(t < 10) && t != 7 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(!(t > 0) && !(t < 10) && !(t != 7) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
if( t>0 && t<10 && t!=7 ){
    pSorter->typeMask &= SORTER_TYPE_INTEGER;
  }else { 
// ABS Label 586
if(t < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 586);
}

// COR Label 587
if((t > 10 || (t & 1)) != (t > 10 && (t & 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 587);
}

// ROR Label 588
if((t <= 10) != (t > 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 588);
}
// ROR Label 589
if((t < 10) != (t > 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 589);
}
// ROR Label 590
if((t >= 10) != (t > 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 590);
}

// MCC Label 591
if(t > 10 && ( t & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 591);
}
// MCC Label 592
if(t > 10 && ( !(t & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 592);
}
// MCC Label 593
if(!(t > 10) && ( t & 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 593);
}
// MCC Label 594
if(!(t > 10) && ( !(t & 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 594);
}
if( t>10 && (t & 0x01) ){
    pSorter->typeMask &= SORTER_TYPE_TEXT;
  }else{
    pSorter->typeMask = 0;
  };}


  assert( pSorter );

  /* Figure out whether or not the current contents of memory should be
  ** flushed to a PMA before continuing. If so, do so.
  **
  ** If using the single large allocation mode (pSorter->aMemory!=0), then
  ** flush the contents of memory to a new PMA if (a) at least one value is
  ** already in memory and (b) the new value will not fit in memory.
  ** 
  ** Or, if using separate allocations for each record, flush the contents
  ** of memory to a PMA if either of the following are true:
  **
  **   * The total memory allocated for the in-memory list is greater 
  **     than (page-size * cache-size), or
  **
  **   * The total memory allocated for the in-memory list is greater 
  **     than (page-size * 10) and sqlite3HeapNearlyFull() returns true.
  */
  nReq = pVal->n + sizeof(SorterRecord);
  nPMA = pVal->n + sqlite3VarintLen(pVal->n);
  
// ABS Label 595
if(pSorter->mxPmaSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 595);
}
if( pSorter->mxPmaSize ){
    
// ABS Label 596
if(pSorter->list.aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}
if( pSorter->list.aMemory ){
      bFlush = pSorter->iMemory && (pSorter->iMemory+nReq) > pSorter->mxPmaSize;
    }else{
      bFlush = (
          (pSorter->list.szPMA > pSorter->mxPmaSize)
       || (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())
      );
    }
    
// ABS Label 597
if(bFlush < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 597);
}
if( bFlush ){
      rc = vdbeSorterFlushPMA(pSorter);
      pSorter->list.szPMA = 0;
      pSorter->iMemory = 0;
      assert( rc!=SQLITE_OK || pSorter->list.pList==0 );
    }
  }

  pSorter->list.szPMA += nPMA;
  
// ABS Label 598
if(nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 598);
}
// ABS Label 599
if(pSorter->mxKeysize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}

// ROR Label 600
if((nPMA <= pSorter->mxKeysize) != (nPMA > pSorter->mxKeysize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 600);
}
// ROR Label 601
if((nPMA < pSorter->mxKeysize) != (nPMA > pSorter->mxKeysize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 601);
}
// ROR Label 602
if((nPMA >= pSorter->mxKeysize) != (nPMA > pSorter->mxKeysize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 602);
}
if( nPMA>pSorter->mxKeysize ){
    pSorter->mxKeysize = nPMA;
  }

  
// ABS Label 603
if(pSorter->list.aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}
if( pSorter->list.aMemory ){
    
// ABS Label 604
if(nReq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}
// ABS Label 605
if(pSorter->iMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}

// AOR Label 606
if(pSorter->iMemory - nReq != pSorter->iMemory + nReq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 606);
}
// AOR Label 607
if(pSorter->iMemory / nReq != pSorter->iMemory + nReq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 607);
}
// AOR Label 608
if(pSorter->iMemory * nReq != pSorter->iMemory + nReq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 608);
}
int nMin = pSorter->iMemory + nReq;

    
// ABS Label 609
if(nMin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}
// ABS Label 610
if(pSorter->nMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}

// ROR Label 611
if((nMin <= pSorter->nMemory) != (nMin > pSorter->nMemory))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 611);
}
// ROR Label 612
if((nMin < pSorter->nMemory) != (nMin > pSorter->nMemory))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 612);
}
// ROR Label 613
if((nMin >= pSorter->nMemory) != (nMin > pSorter->nMemory))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 613);
}
if( nMin>pSorter->nMemory ){
      u8 *aNew;
      
// AOR Label 614
if(2 - (sqlite3_int64)pSorter->nMemory != 2 * (sqlite3_int64)pSorter->nMemory)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 614);
}
// AOR Label 615
if(2 + (sqlite3_int64)pSorter->nMemory != 2 * (sqlite3_int64)pSorter->nMemory)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 615);
}
// AOR Label 616
if(2 / (sqlite3_int64)pSorter->nMemory != 2 * (sqlite3_int64)pSorter->nMemory)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 616);
}
sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;
      int iListOff = -1;
      
// ABS Label 617
if(pSorter->list.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 617);
}
if( pSorter->list.pList ){
        iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;
      }
      
// ABS Label 618
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 618);
}

// ROR Label 619
if((nNew <= nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 619);
}
// ROR Label 620
if((nNew > nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 620);
}
// ROR Label 621
if((nNew >= nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}
while( nNew < nMin ) { nNew = nNew*2;
};
// ABS Label 622
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 622);
}

// ROR Label 623
if((nNew <= nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 623);
}
// ROR Label 624
if((nNew > nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 624);
}
// ROR Label 625
if((nNew >= nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 625);
}

      
// ABS Label 626
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 626);
}

// ROR Label 627
if((nNew <= pSorter->mxPmaSize) != (nNew > pSorter->mxPmaSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 627);
}
// ROR Label 628
if((nNew < pSorter->mxPmaSize) != (nNew > pSorter->mxPmaSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 628);
}
// ROR Label 629
if((nNew >= pSorter->mxPmaSize) != (nNew > pSorter->mxPmaSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 629);
}
if( nNew > pSorter->mxPmaSize ) { nNew = pSorter->mxPmaSize;
}
      
// ABS Label 630
if(nNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 630);
}

// ROR Label 631
if((nNew <= nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}
// ROR Label 632
if((nNew > nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 632);
}
// ROR Label 633
if((nNew >= nMin) != (nNew < nMin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 633);
}
if( nNew < nMin ) { nNew = nMin;
}
      aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);
      if( !aNew ) { return SQLITE_NOMEM_BKPT;
}
      
// ABS Label 634
if(iListOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}

// ROR Label 635
if((iListOff < 0) != (iListOff >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 635);
}
// ROR Label 636
if((iListOff > 0) != (iListOff >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
// ROR Label 637
if((iListOff <= 0) != (iListOff >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}
if( iListOff>=0 ){
        pSorter->list.pList = (SorterRecord*)&aNew[iListOff];
      }
      pSorter->list.aMemory = aNew;
      pSorter->nMemory = nNew;
    }

    pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];
    pSorter->iMemory += ROUND8(nReq);
    
// ABS Label 638
if(pSorter->list.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 638);
}
if( pSorter->list.pList ){
      pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);
    }
  }else{
    pNew = (SorterRecord *)sqlite3Malloc(nReq);
    
// ABS Label 639
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// ROR Label 640
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 640);
}
if( pNew==0 ){
      return SQLITE_NOMEM_BKPT;
    }
    pNew->u.pNext = pSorter->list.pList;
  }

  memcpy(SRVAL(pNew), pVal->z, pVal->n);
  pNew->nVal = pVal->n;
  pSorter->list.pList = pNew;

  
// ABS Label 641
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}
return rc;
}

/*
** Read keys from pIncr->pMerger and populate pIncr->aFile[1]. The format
** of the data stored in aFile[1] is the same as that used by regular PMAs,
** except that the number-of-bytes varint is omitted from the start.
*/
static int vdbeIncrPopulate(IncrMerger *pIncr){
  int rc = SQLITE_OK;
  int rc2;
  
// ABS Label 642
if(pIncr->iStartOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 642);
}
i64 iStart = pIncr->iStartOff;
  SorterFile *pOut = &pIncr->aFile[1];
  
// ABS Label 643
if(pIncr->pTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}
SortSubtask *pTask = pIncr->pTask;
  
// ABS Label 644
if(pIncr->pMerger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}
MergeEngine *pMerger = pIncr->pMerger;
  PmaWriter writer;
  assert( pIncr->bEof==0 );

  vdbeSorterPopulateDebug(pTask, "enter");

  
// ABS Label 645
if(pOut->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 645);
}

// ABS Label 646
if(pTask->pSorter->pgsz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 646);
}

// ABS Label 647
if(iStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 647);
}
vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);
  
// ABS Label 648
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 648);
}

// ROR Label 649
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 649);
}
while( rc==SQLITE_OK ){
    int dummy;
    PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];
    
// ABS Label 652
if(pReader->nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}
int nKey = pReader->nKey;
    
// ABS Label 653
if(writer.iWriteOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 653);
}

// AOR Label 654
if(writer.iWriteOff - writer.iBufEnd != writer.iWriteOff + writer.iBufEnd)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 654);
}
// AOR Label 655
if(writer.iWriteOff / writer.iBufEnd != writer.iWriteOff + writer.iBufEnd)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 655);
}
// AOR Label 656
if(writer.iWriteOff * writer.iBufEnd != writer.iWriteOff + writer.iBufEnd)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 656);
}
i64 iEof = writer.iWriteOff + writer.iBufEnd;

    /* Check if the output file is full or if the input has been exhausted.
    ** In either case exit the loop. */
    
// ABS Label 659
if(pReader->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}

// ROR Label 660
if((pReader->pFd != 0) != (pReader->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 660);
}
if( pReader->pFd==0 ) { break;
}
    if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) { break;
}

    /* Write the next key to the output. */
    vdbePmaWriteVarint(&writer, nKey);
    
// ABS Label 657
if(pReader->aKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}

// ABS Label 658
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
vdbePmaWriteBlob(&writer, pReader->aKey, nKey);
    assert( pIncr->pMerger->pTask==pTask );
    rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);
  };
// ABS Label 650
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 650);
}

// ROR Label 651
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 651);
}


  rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof);
  
// ABS Label 661
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 661);
}

// ROR Label 662
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
if( rc==SQLITE_OK ) { rc = rc2;
}
  vdbeSorterPopulateDebug(pTask, "exit");
  
// ABS Label 663
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}
return rc;
}

#if SQLITE_MAX_WORKER_THREADS>0
/*
** The main routine for background threads that populate aFile[1] of
** multi-threaded IncrMerger objects.
*/
static void *vdbeIncrPopulateThread(void *pCtx){
  IncrMerger *pIncr = (IncrMerger*)pCtx;
  void *pRet = SQLITE_INT_TO_PTR( vdbeIncrPopulate(pIncr) );
  pIncr->pTask->bDone = 1;
  
// ABS Label 664
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 664);
}
return pRet;
}

/*
** Launch a background thread to populate aFile[1] of pIncr.
*/
static int vdbeIncrBgPopulate(IncrMerger *pIncr){
  void *p = (void*)pIncr;
  assert( pIncr->bUseThread );
  return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);
}
#endif

/*
** This function is called when the PmaReader corresponding to pIncr has
** finished reading the contents of aFile[0]. Its purpose is to "refill"
** aFile[0] such that the PmaReader should start rereading it from the
** beginning.
**
** For single-threaded objects, this is accomplished by literally reading 
** keys from pIncr->pMerger and repopulating aFile[0]. 
**
** For multi-threaded objects, all that is required is to wait until the 
** background thread is finished (if it is not already) and then swap 
** aFile[0] and aFile[1] in place. If the contents of pMerger have not
** been exhausted, this function also launches a new background thread
** to populate the new aFile[1].
**
** SQLITE_OK is returned on success, or an SQLite error code otherwise.
*/
static int vdbeIncrSwap(IncrMerger *pIncr){
  int rc = SQLITE_OK;

#if SQLITE_MAX_WORKER_THREADS>0
  
// ABS Label 665
if(pIncr->bUseThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 665);
}
if( pIncr->bUseThread ){
    rc = vdbeSorterJoinThread(pIncr->pTask);

    
// ABS Label 666
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 666);
}

// ROR Label 667
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}
if( rc==SQLITE_OK ){
      
// ABS Label 668
if(pIncr->aFile[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}
SorterFile f0 = pIncr->aFile[0];
      pIncr->aFile[0] = pIncr->aFile[1];
      pIncr->aFile[1] = f0;
    }

    
// ABS Label 669
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}

// ROR Label 670
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 670);
}
if( rc==SQLITE_OK ){
      
// ABS Label 671
if(pIncr->aFile[0].iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}
// ABS Label 672
if(pIncr->iStartOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}

// ROR Label 673
if((pIncr->aFile[0].iEof != pIncr->iStartOff) != (pIncr->aFile[0].iEof == pIncr->iStartOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 673);
}
if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
        pIncr->bEof = 1;
      }else{
        rc = vdbeIncrBgPopulate(pIncr);
      }
    }
  }else
#endif
  {
    rc = vdbeIncrPopulate(pIncr);
    pIncr->aFile[0] = pIncr->aFile[1];
    
// ABS Label 674
if(pIncr->aFile[0].iEof < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}
// ABS Label 675
if(pIncr->iStartOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}

// ROR Label 676
if((pIncr->aFile[0].iEof != pIncr->iStartOff) != (pIncr->aFile[0].iEof == pIncr->iStartOff))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 676);
}
if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
      pIncr->bEof = 1;
    }
  }

  
// ABS Label 677
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}
return rc;
}

/*
** Allocate and return a new IncrMerger object to read data from pMerger.
**
** If an OOM condition is encountered, return NULL. In this case free the
** pMerger argument before returning.
*/
static int vdbeIncrMergerNew(
  SortSubtask *pTask,     /* The thread that will be using the new IncrMerger */
  MergeEngine *pMerger,   /* The MergeEngine that the IncrMerger will control */
  IncrMerger **ppOut      /* Write the new IncrMerger here */
){
  int rc = SQLITE_OK;
  IncrMerger *pIncr = *ppOut = (IncrMerger*)
       (sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));
  
// ABS Label 678
if(pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
if( pIncr ){
    pIncr->pMerger = pMerger;
    pIncr->pTask = pTask;
    pIncr->mxSz = MAX(pTask->pSorter->mxKeysize+9,pTask->pSorter->mxPmaSize/2);
    pTask->file2.iEof += pIncr->mxSz;
  }else{
    
// ABS Label 679
if(pMerger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}
vdbeMergeEngineFree(pMerger);
    rc = SQLITE_NOMEM_BKPT;
  }
  
// ABS Label 680
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}
return rc;
}

#if SQLITE_MAX_WORKER_THREADS>0
/*
** Set the "use-threads" flag on object pIncr.
*/
static void vdbeIncrMergerSetThreads(IncrMerger *pIncr){
  pIncr->bUseThread = 1;
  pIncr->pTask->file2.iEof -= pIncr->mxSz;
}
#endif /* SQLITE_MAX_WORKER_THREADS>0 */



/*
** Recompute pMerger->aTree[iOut] by comparing the next keys on the
** two PmaReaders that feed that entry.  Neither of the PmaReaders
** are advanced.  This routine merely does the comparison.
*/
static void vdbeMergeEngineCompare(
  MergeEngine *pMerger,  /* Merge engine containing PmaReaders to compare */
  int iOut               /* Store the result in pMerger->aTree[iOut] */
){
  int i1;
  int i2;
  int iRes;
  PmaReader *p1;
  PmaReader *p2;

  assert( iOut<pMerger->nTree && iOut>0 );

  
// ABS Label 681
if(iOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}

// ROR Label 682
if((iOut < (pMerger->nTree / 2)) != (iOut >= (pMerger->nTree / 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 682);
}
// ROR Label 683
if((iOut > (pMerger->nTree / 2)) != (iOut >= (pMerger->nTree / 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 683);
}
// ROR Label 684
if((iOut <= (pMerger->nTree / 2)) != (iOut >= (pMerger->nTree / 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 684);
}
if( iOut>=(pMerger->nTree/2) ){
    i1 = (iOut - pMerger->nTree/2) * 2;
    i2 = i1 + 1;
  }else{
    i1 = pMerger->aTree[iOut*2];
    i2 = pMerger->aTree[iOut*2+1];
  }

  p1 = &pMerger->aReadr[i1];
  p2 = &pMerger->aReadr[i2];

  
// ABS Label 685
if(p1->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}

// ROR Label 686
if((p1->pFd != 0) != (p1->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 686);
}
if( p1->pFd==0 ){
    iRes = i2;
  }else { 
// ABS Label 687
if(p2->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}

// ROR Label 688
if((p2->pFd != 0) != (p2->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 688);
}
if( p2->pFd==0 ){
    iRes = i1;
  }else{
    
// ABS Label 689
if(pMerger->pTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}
SortSubtask *pTask = pMerger->pTask;
    int bCached = 0;
    int res;
    assert( pTask->pUnpacked!=0 );  /* from vdbeSortSubtaskMain() */
    res = pTask->xCompare(
        pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey
    );
    
// ABS Label 690
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}

// ROR Label 691
if((res < 0) != (res <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 691);
}
// ROR Label 692
if((res > 0) != (res <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 692);
}
// ROR Label 693
if((res >= 0) != (res <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 693);
}
if( res<=0 ){
      iRes = i1;
    }else{
      iRes = i2;
    }
  };}


  pMerger->aTree[iOut] = iRes;
}

/*
** Allowed values for the eMode parameter to vdbeMergeEngineInit()
** and vdbePmaReaderIncrMergeInit().
**
** Only INCRINIT_NORMAL is valid in single-threaded builds (when
** SQLITE_MAX_WORKER_THREADS==0).  The other values are only used
** when there exists one or more separate worker threads.
*/
#define INCRINIT_NORMAL 0
#define INCRINIT_TASK   1
#define INCRINIT_ROOT   2

/* 
** Forward reference required as the vdbeIncrMergeInit() and
** vdbePmaReaderIncrInit() routines are called mutually recursively when
** building a merge tree.
*/
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode);

/*
** Initialize the MergeEngine object passed as the second argument. Once this
** function returns, the first key of merged data may be read from the 
** MergeEngine object in the usual fashion.
**
** If argument eMode is INCRINIT_ROOT, then it is assumed that any IncrMerge
** objects attached to the PmaReader objects that the merger reads from have
** already been populated, but that they have not yet populated aFile[0] and
** set the PmaReader objects up to read from it. In this case all that is
** required is to call vdbePmaReaderNext() on each PmaReader to point it at
** its first key.
**
** Otherwise, if eMode is any value other than INCRINIT_ROOT, then use 
** vdbePmaReaderIncrMergeInit() to initialize each PmaReader that feeds data 
** to pMerger.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/
static int vdbeMergeEngineInit(
  SortSubtask *pTask,             /* Thread that will run pMerger */
  MergeEngine *pMerger,           /* MergeEngine to initialize */
  int eMode                       /* One of the INCRINIT_XXX constants */
){
  int rc = SQLITE_OK;             /* Return code */
  int i;                          /* For looping over PmaReader objects */
  int nTree;                      /* Number of subtrees to merge */

  /* Failure to allocate the merge would have been detected prior to
  ** invoking this routine */
  assert( pMerger!=0 );

  /* eMode is always INCRINIT_NORMAL in single-threaded mode */
  assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );

  /* Verify that the MergeEngine is assigned to a single thread */
  assert( pMerger->pTask==0 );
  pMerger->pTask = pTask;

  nTree = pMerger->nTree;
  i = 0;

// ABS Label 694
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}
// ABS Label 695
if(nTree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}

// ROR Label 696
if((i <= nTree) != (i < nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 696);
}
// ROR Label 697
if((i > nTree) != (i < nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 697);
}
// ROR Label 698
if((i >= nTree) != (i < nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 698);
}
for(; i<nTree; i++){
    
// ABS Label 704
if(eMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 704);
}

// COR Label 705
if((8 > 0 || eMode == 2) != (8 > 0 && eMode == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 705);
}

// ROR Label 706
if((8 <= 0) != (8 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 706);
}
// ROR Label 707
if((8 < 0) != (8 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 707);
}
// ROR Label 708
if((8 >= 0) != (8 > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 708);
}
// ROR Label 709
if((eMode != 2) != (eMode == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 709);
}

// MCC Label 710
if(8 > 0 && eMode == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 710);
}
// MCC Label 711
if(8 > 0 && !(eMode == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 711);
}
// MCC Label 712
if(!(8 > 0) && eMode == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 712);
}
// MCC Label 713
if(!(8 > 0) && !(eMode == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 713);
}
if( SQLITE_MAX_WORKER_THREADS>0 && eMode==INCRINIT_ROOT ){
      /* PmaReaders should be normally initialized in order, as if they are
      ** reading from the same temp file this makes for more linear file IO.
      ** However, in the INCRINIT_ROOT case, if PmaReader aReadr[nTask-1] is
      ** in use it will block the vdbePmaReaderNext() call while it uses
      ** the main thread to fill its buffer. So calling PmaReaderNext()
      ** on this PmaReader before any of the multi-threaded PmaReaders takes
      ** better advantage of multi-processor hardware. */
      rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);
    }else{
      rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);
    }
    
// ABS Label 714
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 714);
}

// ROR Label 715
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 715);
}
if( rc!=SQLITE_OK ) { 
// ABS Label 716
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}
return rc;
}
  };
// ABS Label 699
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 699);
}
// ABS Label 700
if(nTree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 700);
}

// ROR Label 701
if((i <= nTree) != (i < nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 701);
}
// ROR Label 702
if((i > nTree) != (i < nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 702);
}
// ROR Label 703
if((i >= nTree) != (i < nTree))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 703);
}


  i = pMerger->nTree - 1;

// ABS Label 717
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}

// ROR Label 718
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 718);
}
// ROR Label 719
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 719);
}
// ROR Label 720
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}
for(; i>0; i--){
    
// ABS Label 725
if(pMerger < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 725);
}

// ABS Label 726
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}
vdbeMergeEngineCompare(pMerger, i);
  };
// ABS Label 721
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 721);
}

// ROR Label 722
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 722);
}
// ROR Label 723
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 723);
}
// ROR Label 724
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 724);
}

  return pTask->pUnpacked->errCode;
}

/*
** The PmaReader passed as the first argument is guaranteed to be an
** incremental-reader (pReadr->pIncr!=0). This function serves to open
** and/or initialize the temp file related fields of the IncrMerge
** object at (pReadr->pIncr).
**
** If argument eMode is set to INCRINIT_NORMAL, then all PmaReaders
** in the sub-tree headed by pReadr are also initialized. Data is then 
** loaded into the buffers belonging to pReadr and it is set to point to 
** the first key in its range.
**
** If argument eMode is set to INCRINIT_TASK, then pReadr is guaranteed
** to be a multi-threaded PmaReader and this function is being called in a
** background thread. In this case all PmaReaders in the sub-tree are 
** initialized as for INCRINIT_NORMAL and the aFile[1] buffer belonging to
** pReadr is populated. However, pReadr itself is not set up to point
** to its first key. A call to vdbePmaReaderNext() is still required to do
** that. 
**
** The reason this function does not call vdbePmaReaderNext() immediately 
** in the INCRINIT_TASK case is that vdbePmaReaderNext() assumes that it has
** to block on thread (pTask->thread) before accessing aFile[1]. But, since
** this entire function is being run by thread (pTask->thread), that will
** lead to the current background thread attempting to join itself.
**
** Finally, if argument eMode is set to INCRINIT_ROOT, it may be assumed
** that pReadr->pIncr is a multi-threaded IncrMerge objects, and that all
** child-trees have already been initialized using IncrInit(INCRINIT_TASK).
** In this case vdbePmaReaderNext() is called on all child PmaReaders and
** the current PmaReader set to point to the first key in its range.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/
static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){
  int rc = SQLITE_OK;
  
// ABS Label 727
if(pReadr->pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}
IncrMerger *pIncr = pReadr->pIncr;
  
// ABS Label 728
if(pIncr->pTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}
SortSubtask *pTask = pIncr->pTask;
  
// ABS Label 729
if(pTask->pSorter->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}
sqlite3 *db = pTask->pSorter->db;

  /* eMode is always INCRINIT_NORMAL in single-threaded mode */
  assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );

  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);

  /* Set up the required files for pIncr. A multi-theaded IncrMerge object
  ** requires two temp files to itself, whereas a single-threaded object
  ** only requires a region of pTask->file2. */
  
// ABS Label 730
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}

// ROR Label 731
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 731);
}
if( rc==SQLITE_OK ){
    
// ABS Label 732
if(pIncr->mxSz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 732);
}
int mxSz = pIncr->mxSz;
#if SQLITE_MAX_WORKER_THREADS>0
    
// ABS Label 733
if(pIncr->bUseThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 733);
}
if( pIncr->bUseThread ){
      rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
      
// ABS Label 734
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 734);
}

// ROR Label 735
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 735);
}
if( rc==SQLITE_OK ){
        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
      }
    }else
#endif
    /*if( !pIncr->bUseThread )*/{
      
// ABS Label 736
if(pTask->file2.pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}

// ROR Label 737
if((pTask->file2.pFd != 0) != (pTask->file2.pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 737);
}
if( pTask->file2.pFd==0 ){
        assert( pTask->file2.iEof>0 );
        rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);
        pTask->file2.iEof = 0;
      }
      
// ABS Label 738
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 738);
}

// ROR Label 739
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 739);
}
if( rc==SQLITE_OK ){
        pIncr->aFile[1].pFd = pTask->file2.pFd;
        pIncr->iStartOff = pTask->file2.iEof;
        pTask->file2.iEof += mxSz;
      }
    }
  }

#if SQLITE_MAX_WORKER_THREADS>0
  
// ABS Label 740
if(pIncr->bUseThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}
// ABS Label 741
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}

// COR Label 742
if((rc == 0 || pIncr->bUseThread) != (rc == 0 && pIncr->bUseThread))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 742);
}

// ROR Label 743
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 743);
}

// MCC Label 744
if(rc == 0 && pIncr->bUseThread ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 744);
}
// MCC Label 745
if(rc == 0 && !(pIncr->bUseThread) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 745);
}
// MCC Label 746
if(!(rc == 0) && pIncr->bUseThread ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 746);
}
// MCC Label 747
if(!(rc == 0) && !(pIncr->bUseThread) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 747);
}
if( rc==SQLITE_OK && pIncr->bUseThread ){
    /* Use the current thread to populate aFile[1], even though this
    ** PmaReader is multi-threaded. If this is an INCRINIT_TASK object,
    ** then this function is already running in background thread 
    ** pIncr->pTask->thread. 
    **
    ** If this is the INCRINIT_ROOT object, then it is running in the 
    ** main VDBE thread. But that is Ok, as that thread cannot return
    ** control to the VDBE or proceed with anything useful until the 
    ** first results are ready from this merger object anyway.
    */
    assert( eMode==INCRINIT_ROOT || eMode==INCRINIT_TASK );
    rc = vdbeIncrPopulate(pIncr);
  }
#endif

  
// ABS Label 748
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// COR Label 749
if((rc == 0 || (8 == 0 || eMode != 1)) != (rc == 0 && (8 == 0 || eMode != 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 749);
}

// ROR Label 750
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 750);
}

// MCC Label 751
if(rc == 0 && ( 8 == 0 && eMode != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 751);
}
// MCC Label 752
if(rc == 0 && ( 8 == 0 && !(eMode != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 752);
}
// MCC Label 753
if(rc == 0 && ( !(8 == 0) && eMode != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 753);
}
// MCC Label 754
if(rc == 0 && ( !(8 == 0) && !(eMode != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 754);
}
// MCC Label 755
if(!(rc == 0) && ( 8 == 0 && eMode != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 755);
}
// MCC Label 756
if(!(rc == 0) && ( 8 == 0 && !(eMode != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 756);
}
// MCC Label 757
if(!(rc == 0) && ( !(8 == 0) && eMode != 1 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 757);
}
// MCC Label 758
if(!(rc == 0) && ( !(8 == 0) && !(eMode != 1) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 758);
}
if( rc==SQLITE_OK && (SQLITE_MAX_WORKER_THREADS==0 || eMode!=INCRINIT_TASK) ){
    rc = vdbePmaReaderNext(pReadr);
  }

  
// ABS Label 759
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}
return rc;
}

#if SQLITE_MAX_WORKER_THREADS>0
/*
** The main routine for vdbePmaReaderIncrMergeInit() operations run in 
** background threads.
*/
static void *vdbePmaReaderBgIncrInit(void *pCtx){
  PmaReader *pReader = (PmaReader*)pCtx;
  void *pRet = SQLITE_INT_TO_PTR(
                  vdbePmaReaderIncrMergeInit(pReader,INCRINIT_TASK)
               );
  pReader->pIncr->pTask->bDone = 1;
  
// ABS Label 760
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}
return pRet;
}
#endif

/*
** If the PmaReader passed as the first argument is not an incremental-reader
** (if pReadr->pIncr==0), then this function is a no-op. Otherwise, it invokes
** the vdbePmaReaderIncrMergeInit() function with the parameters passed to
** this routine to initialize the incremental merge.
** 
** If the IncrMerger object is multi-threaded (IncrMerger.bUseThread==1), 
** then a background thread is launched to call vdbePmaReaderIncrMergeInit().
** Or, if the IncrMerger is single threaded, the same function is called
** using the current thread.
*/
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){
  
// ABS Label 761
if(pReadr->pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 761);
}
IncrMerger *pIncr = pReadr->pIncr;   /* Incremental merger */
  int rc = SQLITE_OK;                  /* Return code */
  
// ABS Label 762
if(pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}
if( pIncr ){
#if SQLITE_MAX_WORKER_THREADS>0
    assert( pIncr->bUseThread==0 || eMode==INCRINIT_TASK );
    
// ABS Label 763
if(pIncr->bUseThread < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 763);
}
if( pIncr->bUseThread ){
      void *pCtx = (void*)pReadr;
      rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);
    }else
#endif
    {
      rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);
    }
  }
  
// ABS Label 764
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}
return rc;
}

/*
** Allocate a new MergeEngine object to merge the contents of nPMA level-0
** PMAs from pTask->file. If no error occurs, set *ppOut to point to
** the new object and return SQLITE_OK. Or, if an error does occur, set *ppOut
** to NULL and return an SQLite error code.
**
** When this function is called, *piOffset is set to the offset of the
** first PMA to read from pTask->file. Assuming no error occurs, it is 
** set to the offset immediately following the last byte of the last
** PMA before returning. If an error does occur, then the final value of
** *piOffset is undefined.
*/
static int vdbeMergeEngineLevel0(
  SortSubtask *pTask,             /* Sorter task to read from */
  int nPMA,                       /* Number of PMAs to read */
  i64 *piOffset,                  /* IN/OUT: Readr offset in pTask->file */
  MergeEngine **ppOut             /* OUT: New merge-engine */
){
  MergeEngine *pNew;              /* Merge engine to return */
  
// ABS Label 765
if(*piOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}
i64 iOff = *piOffset;
  int i;
  int rc = SQLITE_OK;

  *ppOut = pNew = vdbeMergeEngineNew(nPMA);
  
// ABS Label 766
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 766);
}

// ROR Label 767
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 767);
}
if( pNew==0 ) { rc = SQLITE_NOMEM_BKPT;
}

  i = 0;

// ABS Label 768
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}
// ABS Label 769
if(nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 769);
}
// ABS Label 770
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 770);
}

// COR Label 771
if((i < nPMA || rc == 0) != (i < nPMA && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 771);
}

// ROR Label 772
if((i <= nPMA) != (i < nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 772);
}
// ROR Label 773
if((i > nPMA) != (i < nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 773);
}
// ROR Label 774
if((i >= nPMA) != (i < nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 774);
}
// ROR Label 775
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 775);
}

// MCC Label 776
if(i < nPMA && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 776);
}
// MCC Label 777
if(i < nPMA && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 777);
}
// MCC Label 778
if(!(i < nPMA) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 778);
}
// MCC Label 779
if(!(i < nPMA) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 779);
}
for(; i<nPMA && rc==SQLITE_OK; i++){
    i64 nDummy = 0;
    PmaReader *pReadr = &pNew->aReadr[i];
    rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);
    iOff = pReadr->iEof;
  };
// ABS Label 780
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}
// ABS Label 781
if(nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}
// ABS Label 782
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}

// COR Label 783
if((i < nPMA || rc == 0) != (i < nPMA && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 783);
}

// ROR Label 784
if((i <= nPMA) != (i < nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 784);
}
// ROR Label 785
if((i > nPMA) != (i < nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 785);
}
// ROR Label 786
if((i >= nPMA) != (i < nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 786);
}
// ROR Label 787
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 787);
}

// MCC Label 788
if(i < nPMA && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 788);
}
// MCC Label 789
if(i < nPMA && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 789);
}
// MCC Label 790
if(!(i < nPMA) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 790);
}
// MCC Label 791
if(!(i < nPMA) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 791);
}


  
// ABS Label 792
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}

// ROR Label 793
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 793);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 794
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}
vdbeMergeEngineFree(pNew);
    *ppOut = 0;
  }
  *piOffset = iOff;
  
// ABS Label 795
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}
return rc;
}

/*
** Return the depth of a tree comprising nPMA PMAs, assuming a fanout of
** SORTER_MAX_MERGE_COUNT. The returned value does not include leaf nodes.
**
** i.e.
**
**   nPMA<=16    -> TreeDepth() == 0
**   nPMA<=256   -> TreeDepth() == 1
**   nPMA<=65536 -> TreeDepth() == 2
*/
static int vdbeSorterTreeDepth(int nPMA){
  int nDepth = 0;
  i64 nDiv = SORTER_MAX_MERGE_COUNT;
  
// ABS Label 796
if(nDiv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}

// ROR Label 797
if((nDiv <= (i64)nPMA) != (nDiv < (i64)nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 797);
}
// ROR Label 798
if((nDiv > (i64)nPMA) != (nDiv < (i64)nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 798);
}
// ROR Label 799
if((nDiv >= (i64)nPMA) != (nDiv < (i64)nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 799);
}
while( nDiv < (i64)nPMA ){
    nDiv = nDiv * SORTER_MAX_MERGE_COUNT;
    nDepth++;
  };
// ABS Label 800
if(nDiv < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}

// ROR Label 801
if((nDiv <= (i64)nPMA) != (nDiv < (i64)nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 801);
}
// ROR Label 802
if((nDiv > (i64)nPMA) != (nDiv < (i64)nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 802);
}
// ROR Label 803
if((nDiv >= (i64)nPMA) != (nDiv < (i64)nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 803);
}

  
// ABS Label 804
if(nDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}
return nDepth;
}

/*
** pRoot is the root of an incremental merge-tree with depth nDepth (according
** to vdbeSorterTreeDepth()). pLeaf is the iSeq'th leaf to be added to the
** tree, counting from zero. This function adds pLeaf to the tree.
**
** If successful, SQLITE_OK is returned. If an error occurs, an SQLite error
** code is returned and pLeaf is freed.
*/
static int vdbeSorterAddToTree(
  SortSubtask *pTask,             /* Task context */
  int nDepth,                     /* Depth of tree according to TreeDepth() */
  int iSeq,                       /* Sequence number of leaf within tree */
  MergeEngine *pRoot,             /* Root of tree */
  MergeEngine *pLeaf              /* Leaf to add to tree */
){
  int rc = SQLITE_OK;
  int nDiv = 1;
  int i;
  
// ABS Label 805
if(pRoot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}
MergeEngine *p = pRoot;
  IncrMerger *pIncr;

  rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);

  i = 1;

// ABS Label 806
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}
// ABS Label 807
if(nDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}

// ROR Label 808
if((i <= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 808);
}
// ROR Label 809
if((i > nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 809);
}
// ROR Label 810
if((i >= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 810);
}
for(; i<nDepth; i++){
    nDiv = nDiv * SORTER_MAX_MERGE_COUNT;
  };
// ABS Label 811
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
// ABS Label 812
if(nDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}

// ROR Label 813
if((i <= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 813);
}
// ROR Label 814
if((i > nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 814);
}
// ROR Label 815
if((i >= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 815);
}


  i = 1;

// ABS Label 816
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}
// ABS Label 817
if(nDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}
// ABS Label 818
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}

// COR Label 819
if((i < nDepth || rc == 0) != (i < nDepth && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 819);
}

// ROR Label 820
if((i <= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 820);
}
// ROR Label 821
if((i > nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 821);
}
// ROR Label 822
if((i >= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 822);
}
// ROR Label 823
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 823);
}

// MCC Label 824
if(i < nDepth && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 824);
}
// MCC Label 825
if(i < nDepth && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 825);
}
// MCC Label 826
if(!(i < nDepth) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 826);
}
// MCC Label 827
if(!(i < nDepth) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 827);
}
for(; i<nDepth && rc==SQLITE_OK; i++){
    
// AOR Label 840
if((iSeq / nDiv) - 16 != (iSeq / nDiv) % 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 840);
}
// AOR Label 841
if((iSeq / nDiv) + 16 != (iSeq / nDiv) % 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 841);
}
// AOR Label 842
if((iSeq / nDiv) * 16 != (iSeq / nDiv) % 16)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 842);
}
int iIter = (iSeq / nDiv) % SORTER_MAX_MERGE_COUNT;
    PmaReader *pReadr = &p->aReadr[iIter];

    
// ABS Label 843
if(pReadr->pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 843);
}

// ROR Label 844
if((pReadr->pIncr != 0) != (pReadr->pIncr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 844);
}
if( pReadr->pIncr==0 ){
      MergeEngine *pNew = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);
      
// ABS Label 845
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}

// ROR Label 846
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 846);
}
if( pNew==0 ){
        rc = SQLITE_NOMEM_BKPT;
      }else{
        rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);
      }
    }
    
// ABS Label 847
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}

// ROR Label 848
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 848);
}
if( rc==SQLITE_OK ){
      p = pReadr->pIncr->pMerger;
      nDiv = nDiv / SORTER_MAX_MERGE_COUNT;
    }
  };
// ABS Label 828
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}
// ABS Label 829
if(nDepth < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}
// ABS Label 830
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}

// COR Label 831
if((i < nDepth || rc == 0) != (i < nDepth && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 831);
}

// ROR Label 832
if((i <= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 832);
}
// ROR Label 833
if((i > nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 833);
}
// ROR Label 834
if((i >= nDepth) != (i < nDepth))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 834);
}
// ROR Label 835
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 835);
}

// MCC Label 836
if(i < nDepth && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 836);
}
// MCC Label 837
if(i < nDepth && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 837);
}
// MCC Label 838
if(!(i < nDepth) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 838);
}
// MCC Label 839
if(!(i < nDepth) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 839);
}


  
// ABS Label 849
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}

// ROR Label 850
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 850);
}
if( rc==SQLITE_OK ){
    p->aReadr[iSeq % SORTER_MAX_MERGE_COUNT].pIncr = pIncr;
  }else{
    
// ABS Label 851
if(pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 851);
}
vdbeIncrFree(pIncr);
  }
  
// ABS Label 852
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 852);
}
return rc;
}

/*
** This function is called as part of a SorterRewind() operation on a sorter
** that has already written two or more level-0 PMAs to one or more temp
** files. It builds a tree of MergeEngine/IncrMerger/PmaReader objects that 
** can be used to incrementally merge all PMAs on disk.
**
** If successful, SQLITE_OK is returned and *ppOut set to point to the
** MergeEngine object at the root of the tree before returning. Or, if an
** error occurs, an SQLite error code is returned and the final value 
** of *ppOut is undefined.
*/
static int vdbeSorterMergeTreeBuild(
  VdbeSorter *pSorter,       /* The VDBE cursor that implements the sort */
  MergeEngine **ppOut        /* Write the MergeEngine here */
){
  MergeEngine *pMain = 0;
  int rc = SQLITE_OK;
  int iTask;

#if SQLITE_MAX_WORKER_THREADS>0
  /* If the sorter uses more than one task, then create the top-level 
  ** MergeEngine here. This MergeEngine will read data from exactly 
  ** one PmaReader per sub-task.  */
  assert( pSorter->bUseThreads || pSorter->nTask==1 );
  
// ROR Label 853
if((pSorter->nTask <= 1) != (pSorter->nTask > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 853);
}
// ROR Label 854
if((pSorter->nTask < 1) != (pSorter->nTask > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 854);
}
// ROR Label 855
if((pSorter->nTask >= 1) != (pSorter->nTask > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 855);
}
if( pSorter->nTask>1 ){
    pMain = vdbeMergeEngineNew(pSorter->nTask);
    
// ABS Label 856
if(pMain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}

// ROR Label 857
if((pMain != 0) != (pMain == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 857);
}
if( pMain==0 ) { rc = SQLITE_NOMEM_BKPT;
}
  }
#endif

  iTask = 0;

// ABS Label 858
if(iTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 858);
}
// ABS Label 859
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 859);
}

// COR Label 860
if((rc == 0 || iTask < pSorter->nTask) != (rc == 0 && iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 860);
}

// ROR Label 861
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 861);
}
// ROR Label 862
if((iTask <= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
// ROR Label 863
if((iTask > pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 863);
}
// ROR Label 864
if((iTask >= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}

// MCC Label 865
if(rc == 0 && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 865);
}
// MCC Label 866
if(rc == 0 && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 866);
}
// MCC Label 867
if(!(rc == 0) && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 867);
}
// MCC Label 868
if(!(rc == 0) && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 868);
}
for(; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){
    SortSubtask *pTask = &pSorter->aTask[iTask];
    assert( pTask->nPMA>0 || SQLITE_MAX_WORKER_THREADS>0 );
    
// ABS Label 880
if(pTask->nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 880);
}

// COR Label 881
if((8 == 0 && pTask->nPMA) != (8 == 0 || pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 881);
}

// ROR Label 882
if((8 != 0) != (8 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 882);
}

// MCC Label 883
if(8 == 0 && pTask->nPMA ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 883);
}
// MCC Label 884
if(8 == 0 && !(pTask->nPMA) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 884);
}
// MCC Label 885
if(!(8 == 0) && pTask->nPMA ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 885);
}
// MCC Label 886
if(!(8 == 0) && !(pTask->nPMA) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 886);
}
if( SQLITE_MAX_WORKER_THREADS==0 || pTask->nPMA ){
      MergeEngine *pRoot = 0;     /* Root node of tree for this task */
      int nDepth = vdbeSorterTreeDepth(pTask->nPMA);
      i64 iReadOff = 0;

      
// ABS Label 887
if(pTask->nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 887);
}

// ROR Label 888
if((pTask->nPMA < 16) != (pTask->nPMA <= 16))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 888);
}
// ROR Label 889
if((pTask->nPMA > 16) != (pTask->nPMA <= 16))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 889);
}
// ROR Label 890
if((pTask->nPMA >= 16) != (pTask->nPMA <= 16))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 890);
}
if( pTask->nPMA<=SORTER_MAX_MERGE_COUNT ){
        rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);
      }else{
        int i;
        int iSeq = 0;
        pRoot = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);
        
// ABS Label 891
if(pRoot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}

// ROR Label 892
if((pRoot != 0) != (pRoot == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 892);
}
if( pRoot==0 ) { rc = SQLITE_NOMEM_BKPT;
}
        i = 0;

// ABS Label 893
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 893);
}
// ABS Label 894
if(pTask->nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 894);
}
// ABS Label 895
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}

// COR Label 896
if((i < pTask->nPMA || rc == 0) != (i < pTask->nPMA && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 896);
}

// ROR Label 897
if((i <= pTask->nPMA) != (i < pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 897);
}
// ROR Label 898
if((i > pTask->nPMA) != (i < pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 898);
}
// ROR Label 899
if((i >= pTask->nPMA) != (i < pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 899);
}
// ROR Label 900
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 900);
}

// MCC Label 901
if(i < pTask->nPMA && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 901);
}
// MCC Label 902
if(i < pTask->nPMA && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 902);
}
// MCC Label 903
if(!(i < pTask->nPMA) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 903);
}
// MCC Label 904
if(!(i < pTask->nPMA) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 904);
}
for(; i<pTask->nPMA && rc==SQLITE_OK; i += SORTER_MAX_MERGE_COUNT){
          MergeEngine *pMerger = 0; /* New level-0 PMA merger */
          int nReader;              /* Number of level-0 PMAs to merge */

          nReader = MIN(pTask->nPMA - i, SORTER_MAX_MERGE_COUNT);
          rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);
          
// ABS Label 917
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}

// ROR Label 918
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 918);
}
if( rc==SQLITE_OK ){
            rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);
          }
        };
// ABS Label 905
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 905);
}
// ABS Label 906
if(pTask->nPMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 906);
}
// ABS Label 907
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 907);
}

// COR Label 908
if((i < pTask->nPMA || rc == 0) != (i < pTask->nPMA && rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 908);
}

// ROR Label 909
if((i <= pTask->nPMA) != (i < pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 909);
}
// ROR Label 910
if((i > pTask->nPMA) != (i < pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 910);
}
// ROR Label 911
if((i >= pTask->nPMA) != (i < pTask->nPMA))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 911);
}
// ROR Label 912
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 912);
}

// MCC Label 913
if(i < pTask->nPMA && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 913);
}
// MCC Label 914
if(i < pTask->nPMA && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 914);
}
// MCC Label 915
if(!(i < pTask->nPMA) && rc == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 915);
}
// MCC Label 916
if(!(i < pTask->nPMA) && !(rc == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 916);
}

      }

      
// ABS Label 919
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}

// ROR Label 920
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 920);
}
if( rc==SQLITE_OK ){
#if SQLITE_MAX_WORKER_THREADS>0
        
// ABS Label 921
if(pMain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}

// ROR Label 922
if((pMain == 0) != (pMain != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 922);
}
if( pMain!=0 ){
          rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);
        }else
#endif
        {
          assert( pMain==0 );
          pMain = pRoot;
        }
      }else{
        
// ABS Label 923
if(pRoot < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 923);
}
vdbeMergeEngineFree(pRoot);
      }
    }
  };
// ABS Label 869
if(iTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 869);
}
// ABS Label 870
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}

// COR Label 871
if((rc == 0 || iTask < pSorter->nTask) != (rc == 0 && iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 871);
}

// ROR Label 872
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 872);
}
// ROR Label 873
if((iTask <= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 873);
}
// ROR Label 874
if((iTask > pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 874);
}
// ROR Label 875
if((iTask >= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}

// MCC Label 876
if(rc == 0 && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 876);
}
// MCC Label 877
if(rc == 0 && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 877);
}
// MCC Label 878
if(!(rc == 0) && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 878);
}
// MCC Label 879
if(!(rc == 0) && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 879);
}


  
// ABS Label 924
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 924);
}

// ROR Label 925
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 925);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 926
if(pMain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 926);
}
vdbeMergeEngineFree(pMain);
    pMain = 0;
  }
  *ppOut = pMain;
  
// ABS Label 927
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 927);
}
return rc;
}

/*
** This function is called as part of an sqlite3VdbeSorterRewind() operation
** on a sorter that has written two or more PMAs to temporary files. It sets
** up either VdbeSorter.pMerger (for single threaded sorters) or pReader
** (for multi-threaded sorters) so that it can be used to iterate through
** all records stored in the sorter.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/
static int vdbeSorterSetupMerge(VdbeSorter *pSorter){
  int rc;                         /* Return code */
  SortSubtask *pTask0 = &pSorter->aTask[0];
  MergeEngine *pMain = 0;
#if SQLITE_MAX_WORKER_THREADS
  
// ABS Label 928
if(pTask0->pSorter->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 928);
}
sqlite3 *db = pTask0->pSorter->db;
  int i;
  SorterCompare xCompare = vdbeSorterGetCompare(pSorter);
  i = 0;

// ABS Label 929
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 929);
}

// ROR Label 930
if((i <= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 930);
}
// ROR Label 931
if((i > pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 931);
}
// ROR Label 932
if((i >= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 932);
}
for(; i<pSorter->nTask; i++){
    pSorter->aTask[i].xCompare = xCompare;
  };
// ABS Label 933
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}

// ROR Label 934
if((i <= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 934);
}
// ROR Label 935
if((i > pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 935);
}
// ROR Label 936
if((i >= pSorter->nTask) != (i < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 936);
}

#endif

  rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);
  
// ABS Label 937
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}

// ROR Label 938
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 938);
}
if( rc==SQLITE_OK ){
#if SQLITE_MAX_WORKER_THREADS
    assert( pSorter->bUseThreads==0 || pSorter->nTask>1 );
    
// ABS Label 939
if(pSorter->bUseThreads < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}
if( pSorter->bUseThreads ){
      int iTask;
      PmaReader *pReadr = 0;
      SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];
      rc = vdbeSortAllocUnpacked(pLast);
      
// ABS Label 940
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}

// ROR Label 941
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 941);
}
if( rc==SQLITE_OK ){
        pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));
        pSorter->pReader = pReadr;
        
// ABS Label 942
if(pReadr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 942);
}

// ROR Label 943
if((pReadr != 0) != (pReadr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 943);
}
if( pReadr==0 ) { rc = SQLITE_NOMEM_BKPT;
}
      }
      
// ABS Label 944
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}

// ROR Label 945
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 945);
}
if( rc==SQLITE_OK ){
        rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);
        
// ABS Label 946
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}

// ROR Label 947
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 947);
}
if( rc==SQLITE_OK ){
          
// ABS Label 948
if(pReadr->pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 948);
}
vdbeIncrMergerSetThreads(pReadr->pIncr);
          iTask = 0;

// ABS Label 949
if(iTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 949);
}

// ROR Label 950
if((iTask <= (pSorter->nTask - 1)) != (iTask < (pSorter->nTask - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 950);
}
// ROR Label 951
if((iTask > (pSorter->nTask - 1)) != (iTask < (pSorter->nTask - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 951);
}
// ROR Label 952
if((iTask >= (pSorter->nTask - 1)) != (iTask < (pSorter->nTask - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 952);
}
for(; iTask<(pSorter->nTask-1); iTask++){
            IncrMerger *pIncr;
            if( (pIncr = pMain->aReadr[iTask].pIncr) ){
              
// ABS Label 957
if(pIncr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 957);
}
vdbeIncrMergerSetThreads(pIncr);
              assert( pIncr->pTask!=pLast );
            }
          };
// ABS Label 953
if(iTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 953);
}

// ROR Label 954
if((iTask <= (pSorter->nTask - 1)) != (iTask < (pSorter->nTask - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 954);
}
// ROR Label 955
if((iTask > (pSorter->nTask - 1)) != (iTask < (pSorter->nTask - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 955);
}
// ROR Label 956
if((iTask >= (pSorter->nTask - 1)) != (iTask < (pSorter->nTask - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 956);
}

          iTask = 0;

// ABS Label 958
if(iTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 958);
}
// ABS Label 959
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 959);
}

// COR Label 960
if((rc == 0 || iTask < pSorter->nTask) != (rc == 0 && iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 960);
}

// ROR Label 961
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 961);
}
// ROR Label 962
if((iTask <= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 962);
}
// ROR Label 963
if((iTask > pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 963);
}
// ROR Label 964
if((iTask >= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 964);
}

// MCC Label 965
if(rc == 0 && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 965);
}
// MCC Label 966
if(rc == 0 && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 966);
}
// MCC Label 967
if(!(rc == 0) && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 967);
}
// MCC Label 968
if(!(rc == 0) && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 968);
}
for(; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){
            /* Check that:
            **   
            **   a) The incremental merge object is configured to use the
            **      right task, and
            **   b) If it is using task (nTask-1), it is configured to run
            **      in single-threaded mode. This is important, as the
            **      root merge (INCRINIT_ROOT) will be using the same task
            **      object.
            */
            PmaReader *p = &pMain->aReadr[iTask];
            assert( p->pIncr==0 || (
                (p->pIncr->pTask==&pSorter->aTask[iTask])             /* a */
             && (iTask!=pSorter->nTask-1 || p->pIncr->bUseThread==0)  /* b */
            ));
            rc = vdbePmaReaderIncrInit(p, INCRINIT_TASK);
          };
// ABS Label 969
if(iTask < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 969);
}
// ABS Label 970
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 970);
}

// COR Label 971
if((rc == 0 || iTask < pSorter->nTask) != (rc == 0 && iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 971);
}

// ROR Label 972
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 972);
}
// ROR Label 973
if((iTask <= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 973);
}
// ROR Label 974
if((iTask > pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 974);
}
// ROR Label 975
if((iTask >= pSorter->nTask) != (iTask < pSorter->nTask))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 975);
}

// MCC Label 976
if(rc == 0 && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 976);
}
// MCC Label 977
if(rc == 0 && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 977);
}
// MCC Label 978
if(!(rc == 0) && iTask < pSorter->nTask ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 978);
}
// MCC Label 979
if(!(rc == 0) && !(iTask < pSorter->nTask) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 979);
}

        }
        pMain = 0;
      }
      
// ABS Label 980
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 980);
}

// ROR Label 981
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 981);
}
if( rc==SQLITE_OK ){
        rc = vdbePmaReaderIncrMergeInit(pReadr, INCRINIT_ROOT);
      }
    }else
#endif
    {
      rc = vdbeMergeEngineInit(pTask0, pMain, INCRINIT_NORMAL);
      pSorter->pMerger = pMain;
      pMain = 0;
    }
  }

  
// ABS Label 982
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 982);
}

// ROR Label 983
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 983);
}
if( rc!=SQLITE_OK ){
    
// ABS Label 984
if(pMain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 984);
}
vdbeMergeEngineFree(pMain);
  }
  
// ABS Label 985
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 985);
}
return rc;
}


/*
** Once the sorter has been populated by calls to sqlite3VdbeSorterWrite,
** this function is called to prepare for iterating through the records
** in sorted order.
*/
int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){
  VdbeSorter *pSorter;
  int rc = SQLITE_OK;             /* Return code */

  assert( pCsr->eCurType==CURTYPE_SORTER );
  pSorter = pCsr->uc.pSorter;
  assert( pSorter );

  /* If no data has been written to disk, then do not do so now. Instead,
  ** sort the VdbeSorter.pRecord list. The vdbe layer will read data directly
  ** from the in-memory list.  */
  
// ROR Label 986
if((pSorter->bUsePMA != 0) != (pSorter->bUsePMA == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 986);
}
if( pSorter->bUsePMA==0 ){
    
// ABS Label 987
if(pSorter->list.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 987);
}
if( pSorter->list.pList ){
      *pbEof = 0;
      rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);
    }else{
      *pbEof = 1;
    }
    
// ABS Label 988
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 988);
}
return rc;
  }

  /* Write the current in-memory list to a PMA. When the VdbeSorterWrite() 
  ** function flushes the contents of memory to disk, it immediately always
  ** creates a new list consisting of a single key immediately afterwards.
  ** So the list is never empty at this point.  */
  assert( pSorter->list.pList );
  rc = vdbeSorterFlushPMA(pSorter);

  /* Join all threads */
  rc = vdbeSorterJoinAll(pSorter, rc);

  vdbeSorterRewindDebug("rewind");

  /* Assuming no errors have occurred, set up a merger structure to 
  ** incrementally read and merge all remaining PMAs.  */
  assert( pSorter->pReader==0 );
  
// ABS Label 989
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 989);
}

// ROR Label 990
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 990);
}
if( rc==SQLITE_OK ){
    rc = vdbeSorterSetupMerge(pSorter);
    *pbEof = 0;
  }

  vdbeSorterRewindDebug("rewinddone");
  
// ABS Label 991
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 991);
}
return rc;
}

/*
** Advance to the next element in the sorter.  Return value:
**
**    SQLITE_OK     success
**    SQLITE_DONE   end of data
**    otherwise     some kind of error.
*/
int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){
  VdbeSorter *pSorter;
  int rc;                         /* Return code */

  assert( pCsr->eCurType==CURTYPE_SORTER );
  pSorter = pCsr->uc.pSorter;
  assert( pSorter->bUsePMA || (pSorter->pReader==0 && pSorter->pMerger==0) );
  
// ABS Label 992
if(pSorter->bUsePMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 992);
}
if( pSorter->bUsePMA ){
    assert( pSorter->pReader==0 || pSorter->pMerger==0 );
    assert( pSorter->bUseThreads==0 || pSorter->pReader );
    assert( pSorter->bUseThreads==1 || pSorter->pMerger );
#if SQLITE_MAX_WORKER_THREADS>0
    
// ABS Label 993
if(pSorter->bUseThreads < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 993);
}
if( pSorter->bUseThreads ){
      rc = vdbePmaReaderNext(pSorter->pReader);
      
// ABS Label 994
if(pSorter->pReader->pFd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 994);
}
// ABS Label 995
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 995);
}

// COR Label 996
if((rc == 0 || pSorter->pReader->pFd == 0) != (rc == 0 && pSorter->pReader->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 996);
}

// ROR Label 997
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 997);
}
// ROR Label 998
if((pSorter->pReader->pFd != 0) != (pSorter->pReader->pFd == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 998);
}

// MCC Label 999
if(rc == 0 && pSorter->pReader->pFd == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 999);
}
// MCC Label 1000
if(rc == 0 && !(pSorter->pReader->pFd == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1000);
}
// MCC Label 1001
if(!(rc == 0) && pSorter->pReader->pFd == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1001);
}
// MCC Label 1002
if(!(rc == 0) && !(pSorter->pReader->pFd == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1002);
}
if( rc==SQLITE_OK && pSorter->pReader->pFd==0 ) { rc = SQLITE_DONE;
}
    }else
#endif
    /*if( !pSorter->bUseThreads )*/ {
      int res = 0;
      assert( pSorter->pMerger!=0 );
      assert( pSorter->pMerger->pTask==(&pSorter->aTask[0]) );
      rc = vdbeMergeEngineStep(pSorter->pMerger, &res);
      
// ABS Label 1003
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}
// ABS Label 1004
if(res < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1004);
}

// COR Label 1005
if((rc == 0 || res) != (rc == 0 && res))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1005);
}

// ROR Label 1006
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1006);
}

// MCC Label 1007
if(rc == 0 && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1007);
}
// MCC Label 1008
if(rc == 0 && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1008);
}
// MCC Label 1009
if(!(rc == 0) && res ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1009);
}
// MCC Label 1010
if(!(rc == 0) && !(res) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1010);
}
if( rc==SQLITE_OK && res ) { rc = SQLITE_DONE;
}
    }
  }else{
    
// ABS Label 1011
if(pSorter->list.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1011);
}
SorterRecord *pFree = pSorter->list.pList;
    pSorter->list.pList = pFree->u.pNext;
    pFree->u.pNext = 0;
    
// ABS Label 1012
if(pSorter->list.aMemory < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1012);
}

// ROR Label 1013
if((pSorter->list.aMemory != 0) != (pSorter->list.aMemory == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1013);
}
if( pSorter->list.aMemory==0 ) { 
// ABS Label 1014
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1014);
}

// ABS Label 1015
if(pFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1015);
}
vdbeSorterRecordFree(db, pFree);
}
    rc = pSorter->list.pList ? SQLITE_OK : SQLITE_DONE;
  }
  
// ABS Label 1016
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1016);
}
return rc;
}

/*
** Return a pointer to a buffer owned by the sorter that contains the 
** current key.
*/
static void *vdbeSorterRowkey(
  const VdbeSorter *pSorter,      /* Sorter object */
  int *pnKey                      /* OUT: Size of current key in bytes */
){
  void *pKey;
  
// ABS Label 1017
if(pSorter->bUsePMA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}
if( pSorter->bUsePMA ){
    PmaReader *pReader;
#if SQLITE_MAX_WORKER_THREADS>0
    
// ABS Label 1018
if(pSorter->bUseThreads < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1018);
}
if( pSorter->bUseThreads ){
      pReader = pSorter->pReader;
    }else
#endif
    /*if( !pSorter->bUseThreads )*/{
      pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];
    }
    *pnKey = pReader->nKey;
    pKey = pReader->aKey;
  }else{
    *pnKey = pSorter->list.pList->nVal;
    pKey = SRVAL(pSorter->list.pList);
  }
  
// ABS Label 1019
if(pKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1019);
}
return pKey;
}

/*
** Copy the current sorter key into the memory cell pOut.
*/
int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){
  VdbeSorter *pSorter;
  void *pKey; int nKey;           /* Sorter key to copy into pOut */

  assert( pCsr->eCurType==CURTYPE_SORTER );
  pSorter = pCsr->uc.pSorter;
  pKey = vdbeSorterRowkey(pSorter, &nKey);
  if( sqlite3VdbeMemClearAndResize(pOut, nKey) ){
    return SQLITE_NOMEM_BKPT;
  }
  pOut->n = nKey;
  MemSetTypeFlag(pOut, MEM_Blob);
  memcpy(pOut->z, pKey, nKey);

  return SQLITE_OK;
}

/*
** Compare the key in memory cell pVal with the key that the sorter cursor
** passed as the first argument currently points to. For the purposes of
** the comparison, ignore the rowid field at the end of each record.
**
** If the sorter cursor key contains any NULL values, consider it to be
** less than pVal. Even if pVal also contains NULL values.
**
** If an error occurs, return an SQLite error code (i.e. SQLITE_NOMEM).
** Otherwise, set *pRes to a negative, zero or positive value if the
** key in pVal is smaller than, equal to or larger than the current sorter
** key.
**
** This routine forms the core of the OP_SorterCompare opcode, which in
** turn is used to verify uniqueness when constructing a UNIQUE INDEX.
*/
int sqlite3VdbeSorterCompare(
  const VdbeCursor *pCsr,         /* Sorter cursor */
  Mem *pVal,                      /* Value to compare to current sorter key */
  int nKeyCol,                    /* Compare this many columns */
  int *pRes                       /* OUT: Result of comparison */
){
  VdbeSorter *pSorter;
  UnpackedRecord *r2;
  KeyInfo *pKeyInfo;
  int i;
  void *pKey; int nKey;           /* Sorter key to compare pVal with */

  assert( pCsr->eCurType==CURTYPE_SORTER );
  pSorter = pCsr->uc.pSorter;
  r2 = pSorter->pUnpacked;
  pKeyInfo = pCsr->pKeyInfo;
  
// ABS Label 1023
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}

// ROR Label 1024
if((r2 != 0) != (r2 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1024);
}
if( r2==0 ){
    r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    
// ABS Label 1025
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1025);
}

// ROR Label 1026
if((r2 != 0) != (r2 == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1026);
}
if( r2==0 ) { return SQLITE_NOMEM_BKPT;
}
    r2->nField = nKeyCol;
  }
  assert( r2->nField==nKeyCol );

  pKey = vdbeSorterRowkey(pSorter, &nKey);
  
// ABS Label 1020
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1020);
}

// ABS Label 1021
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1021);
}

// ABS Label 1022
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1022);
}
sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, r2);
  i = 0;

// ABS Label 1027
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1027);
}
// ABS Label 1028
if(nKeyCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1028);
}

// ROR Label 1029
if((i <= nKeyCol) != (i < nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1029);
}
// ROR Label 1030
if((i > nKeyCol) != (i < nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1030);
}
// ROR Label 1031
if((i >= nKeyCol) != (i < nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1031);
}
for(; i<nKeyCol; i++){
    
// AOR Label 1037
if(r2->aMem[i].flags | 1 != r2->aMem[i].flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1037);
}
// AOR Label 1038
if(r2->aMem[i].flags ^ 1 != r2->aMem[i].flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1038);
}
if( r2->aMem[i].flags & MEM_Null ){
      *pRes = -1;
      return SQLITE_OK;
    }
  };
// ABS Label 1032
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}
// ABS Label 1033
if(nKeyCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}

// ROR Label 1034
if((i <= nKeyCol) != (i < nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1034);
}
// ROR Label 1035
if((i > nKeyCol) != (i < nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1035);
}
// ROR Label 1036
if((i >= nKeyCol) != (i < nKeyCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1036);
}


  *pRes = sqlite3VdbeRecordCompare(pVal->n, pVal->z, r2);
  return SQLITE_OK;
}
