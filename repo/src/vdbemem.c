/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2004 May 26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code use to manipulate "Mem" structure.  A "Mem"
** stores a single value in the VDBE.  Mem is an opaque structure visible
** only within the VDBE.  Interface routines refer to a Mem using the
** name sqlite_value
*/
#include "sqliteInt.h"
#include "vdbeInt.h"

/* True if X is a power of two.  0 is considered a power of two here.
** In other words, return true if X has at most one bit set.
*/
#define ISPOWEROF2(X)  (((X)&((X)-1))==0)

#ifdef SQLITE_DEBUG
/*
** Check invariants on a Mem object.
**
** This routine is intended for use inside of assert() statements, like
** this:    assert( sqlite3VdbeCheckMemInvariants(pMem) );
*/
int sqlite3VdbeCheckMemInvariants(Mem *p){
  /* If MEM_Dyn is set then Mem.xDel!=0.  
  ** Mem.xDel might not be initialized if MEM_Dyn is clear.
  */
  assert( (p->flags & MEM_Dyn)==0 || p->xDel!=0 );

  /* MEM_Dyn may only be set if Mem.szMalloc==0.  In this way we
  ** ensure that if Mem.szMalloc>0 then it is safe to do
  ** Mem.z = Mem.zMalloc without having to check Mem.flags&MEM_Dyn.
  ** That saves a few cycles in inner loops. */
  assert( (p->flags & MEM_Dyn)==0 || p->szMalloc==0 );

  /* Cannot have more than one of MEM_Int, MEM_Real, or MEM_IntReal */
  assert( ISPOWEROF2(p->flags & (MEM_Int|MEM_Real|MEM_IntReal)) );

  if( p->flags & MEM_Null ){
    /* Cannot be both MEM_Null and some other type */
    assert( (p->flags & (MEM_Int|MEM_Real|MEM_Str|MEM_Blob|MEM_Agg))==0 );

    /* If MEM_Null is set, then either the value is a pure NULL (the usual
    ** case) or it is a pointer set using sqlite3_bind_pointer() or
    ** sqlite3_result_pointer().  If a pointer, then MEM_Term must also be
    ** set.
    */
    if( (p->flags & (MEM_Term|MEM_Subtype))==(MEM_Term|MEM_Subtype) ){
      /* This is a pointer type.  There may be a flag to indicate what to
      ** do with the pointer. */
      assert( ((p->flags&MEM_Dyn)!=0 ? 1 : 0) +
              ((p->flags&MEM_Ephem)!=0 ? 1 : 0) +
              ((p->flags&MEM_Static)!=0 ? 1 : 0) <= 1 );

      /* No other bits set */
      assert( (p->flags & ~(MEM_Null|MEM_Term|MEM_Subtype|MEM_FromBind
                           |MEM_Dyn|MEM_Ephem|MEM_Static))==0 );
    }else{
      /* A pure NULL might have other flags, such as MEM_Static, MEM_Dyn,
      ** MEM_Ephem, MEM_Cleared, or MEM_Subtype */
    }
  }else{
    /* The MEM_Cleared bit is only allowed on NULLs */
    assert( (p->flags & MEM_Cleared)==0 );
  }

  /* The szMalloc field holds the correct memory allocation size */
  assert( p->szMalloc==0
       || (p->flags==MEM_Undefined 
           && p->szMalloc<=sqlite3DbMallocSize(p->db,p->zMalloc))
       || p->szMalloc==sqlite3DbMallocSize(p->db,p->zMalloc));

  /* If p holds a string or blob, the Mem.z must point to exactly
  ** one of the following:
  **
  **   (1) Memory in Mem.zMalloc and managed by the Mem object
  **   (2) Memory to be freed using Mem.xDel
  **   (3) An ephemeral string or blob
  **   (4) A static string or blob
  */
  if( (p->flags & (MEM_Str|MEM_Blob)) && p->n>0 ){
    assert( 
      ((p->szMalloc>0 && p->z==p->zMalloc)? 1 : 0) +
      ((p->flags&MEM_Dyn)!=0 ? 1 : 0) +
      ((p->flags&MEM_Ephem)!=0 ? 1 : 0) +
      ((p->flags&MEM_Static)!=0 ? 1 : 0) == 1
    );
  }
  return 1;
}
#endif

/*
** Render a Mem object which is one of MEM_Int, MEM_Real, or MEM_IntReal
** into a buffer.
*/
static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){
  StrAccum acc;
  assert( p->flags & (MEM_Int|MEM_Real|MEM_IntReal) );
  assert( sz>22 );
  
// AOR Label 7
if(p->flags | 4 != p->flags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 7);
}
// AOR Label 8
if(p->flags ^ 4 != p->flags & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 8);
}
if( p->flags & MEM_Int ){
#if GCC_VERSION>=7000000
    /* Work-around for GCC bug
    ** https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96270 */
    i64 x;
    assert( (p->flags&MEM_Int)*2==sizeof(x) );
    memcpy(&x, (char*)&p->u, (p->flags&MEM_Int)*2);
    sqlite3Int64ToText(x, zBuf);
#else
    
// ABS Label 9
if(p->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

// ABS Label 10
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
sqlite3Int64ToText(p->u.i, zBuf);
#endif
  }else{
    
// ABS Label 11
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ABS Label 12
if(sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);
    sqlite3_str_appendf(&acc, "%!.15g", 
         (p->flags & MEM_IntReal)!=0 ? (double)p->u.i : p->u.r);
    assert( acc.zText==zBuf && acc.mxAlloc<=0 );
    zBuf[acc.nChar] = 0; /* Fast version of sqlite3StrAccumFinish(&acc) */
  }
}

#ifdef SQLITE_DEBUG
/*
** Validity checks on pMem.  pMem holds a string.
**
** (1) Check that string value of pMem agrees with its integer or real value.
** (2) Check that the string is correctly zero terminated
**
** A single int or real value always converts to the same strings.  But
** many different strings can be converted into the same int or real.
** If a table contains a numeric value and an index is based on the
** corresponding string value, then it is important that the string be
** derived from the numeric value, not the other way around, to ensure
** that the index and table are consistent.  See ticket
** https://www.sqlite.org/src/info/343634942dd54ab (2018-01-31) for
** an example.
**
** This routine looks at pMem to verify that if it has both a numeric
** representation and a string representation then the string rep has
** been derived from the numeric and not the other way around.  It returns
** true if everything is ok and false if there is a problem.
**
** This routine is for use inside of assert() statements only.
*/
int sqlite3VdbeMemValidStrRep(Mem *p){
  char zBuf[100];
  char *z;
  int i, j, incr;
  if( (p->flags & MEM_Str)==0 ) return 1;
  if( p->flags & MEM_Term ){
    /* Insure that the string is properly zero-terminated.  Pay particular
    ** attention to the case where p->n is odd */
    if( p->szMalloc>0 && p->z==p->zMalloc ){
      assert( p->enc==SQLITE_UTF8 || p->szMalloc >= ((p->n+1)&~1)+2 );
      assert( p->enc!=SQLITE_UTF8 || p->szMalloc >= p->n+1 );
    }
    assert( p->z[p->n]==0 );
    assert( p->enc==SQLITE_UTF8 || p->z[(p->n+1)&~1]==0 );
    assert( p->enc==SQLITE_UTF8 || p->z[((p->n+1)&~1)+1]==0 );
  }
  if( (p->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 ) return 1;
  vdbeMemRenderNum(sizeof(zBuf), zBuf, p);
  z = p->z;
  i = j = 0;
  incr = 1;
  if( p->enc!=SQLITE_UTF8 ){
    incr = 2;
    if( p->enc==SQLITE_UTF16BE ) z++;
  }
  while( zBuf[j] ){
    if( zBuf[j++]!=z[i] ) return 0;
    i += incr;
  }
  return 1;
}
#endif /* SQLITE_DEBUG */

/*
** If pMem is an object with a valid string representation, this routine
** ensures the internal encoding for the string representation is
** 'desiredEnc', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE.
**
** If pMem is not a string object, or the encoding of the string
** representation is already stored using the requested encoding, then this
** routine is a no-op.
**
** SQLITE_OK is returned if the conversion is successful (or not required).
** SQLITE_NOMEM may be returned if a malloc() fails during conversion
** between formats.
*/
int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){
#ifndef SQLITE_OMIT_UTF16
  int rc;
#endif
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  assert( desiredEnc==SQLITE_UTF8 || desiredEnc==SQLITE_UTF16LE
           || desiredEnc==SQLITE_UTF16BE );
  
// ABS Label 13
if(desiredEnc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// COR Label 14
if((!(pMem->flags & 2) && pMem->enc == desiredEnc) != (!(pMem->flags & 2) || pMem->enc == desiredEnc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 14);
}

// ROR Label 15
if((pMem->enc != desiredEnc) != (pMem->enc == desiredEnc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}

// MCC Label 16
if(!(pMem->flags & 2) && pMem->enc == desiredEnc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 16);
}
// MCC Label 17
if(!(pMem->flags & 2) && !(pMem->enc == desiredEnc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 17);
}
// MCC Label 18
if(!(!(pMem->flags & 2)) && pMem->enc == desiredEnc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 18);
}
// MCC Label 19
if(!(!(pMem->flags & 2)) && !(pMem->enc == desiredEnc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 19);
}
if( !(pMem->flags&MEM_Str) || pMem->enc==desiredEnc ){
    return SQLITE_OK;
  }
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
#ifdef SQLITE_OMIT_UTF16
  return SQLITE_ERROR;
#else

  /* MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,
  ** then the encoding of the value may not have changed.
  */
  rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);
  assert(rc==SQLITE_OK    || rc==SQLITE_NOMEM);
  assert(rc==SQLITE_OK    || pMem->enc!=desiredEnc);
  assert(rc==SQLITE_NOMEM || pMem->enc==desiredEnc);
  
// ABS Label 20
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
return rc;
#endif
}

/*
** Make sure pMem->z points to a writable allocation of at least n bytes.
**
** If the bPreserve argument is true, then copy of the content of
** pMem->z into the new allocation.  pMem must be either a string or
** blob if bPreserve is true.  If bPreserve is false, any prior content
** in pMem->z is discarded.
*/
SQLITE_NOINLINE int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPreserve){
  assert( sqlite3VdbeCheckMemInvariants(pMem) );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  testcase( pMem->db==0 );

  /* If the bPreserve flag is set to true, then the memory cell must already
  ** contain a valid string or blob value.  */
  assert( bPreserve==0 || pMem->flags&(MEM_Blob|MEM_Str) );
  testcase( bPreserve && pMem->z==0 );

  assert( pMem->szMalloc==0
       || (pMem->flags==MEM_Undefined 
           && pMem->szMalloc<=sqlite3DbMallocSize(pMem->db,pMem->zMalloc))
       || pMem->szMalloc==sqlite3DbMallocSize(pMem->db,pMem->zMalloc));
  
// ABS Label 21
if(bPreserve < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
// ABS Label 22
if(pMem->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
// ABS Label 23
if(pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
// ABS Label 24
if(pMem->zMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

// COR Label 25
if((pMem->szMalloc > 0 && bPreserve || pMem->z == pMem->zMalloc) != (pMem->szMalloc > 0 && bPreserve && pMem->z == pMem->zMalloc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 25);
}
// COR Label 26
if((pMem->szMalloc > 0 || bPreserve) != (pMem->szMalloc > 0 && bPreserve))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 26);
}

// ROR Label 27
if((pMem->szMalloc <= 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
// ROR Label 28
if((pMem->szMalloc < 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((pMem->szMalloc >= 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
// ROR Label 30
if((pMem->z != pMem->zMalloc) != (pMem->z == pMem->zMalloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 30);
}

// MCC Label 31
if(pMem->szMalloc > 0 && bPreserve && pMem->z == pMem->zMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 31);
}
// MCC Label 32
if(pMem->szMalloc > 0 && bPreserve && !(pMem->z == pMem->zMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 32);
}
// MCC Label 33
if(pMem->szMalloc > 0 && !(bPreserve) && pMem->z == pMem->zMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 33);
}
// MCC Label 34
if(pMem->szMalloc > 0 && !(bPreserve) && !(pMem->z == pMem->zMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 34);
}
// MCC Label 35
if(!(pMem->szMalloc > 0) && bPreserve && pMem->z == pMem->zMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
// MCC Label 36
if(!(pMem->szMalloc > 0) && bPreserve && !(pMem->z == pMem->zMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 36);
}
// MCC Label 37
if(!(pMem->szMalloc > 0) && !(bPreserve) && pMem->z == pMem->zMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 37);
}
// MCC Label 38
if(!(pMem->szMalloc > 0) && !(bPreserve) && !(pMem->z == pMem->zMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 38);
}
if( pMem->szMalloc>0 && bPreserve && pMem->z==pMem->zMalloc ){
    
// ABS Label 39
if(pMem->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}
if( pMem->db ){
      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
    }else{
      pMem->zMalloc = sqlite3Realloc(pMem->z, n);
      
// ABS Label 40
if(pMem->zMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 40);
}

// ROR Label 41
if((pMem->zMalloc != 0) != (pMem->zMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 41);
}
if( pMem->zMalloc==0 ) { sqlite3_free(pMem->z);
}
      pMem->z = pMem->zMalloc;
    }
    bPreserve = 0;
  }else{
    
// ABS Label 42
if(pMem->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}

// ROR Label 43
if((pMem->szMalloc <= 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((pMem->szMalloc < 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}
// ROR Label 45
if((pMem->szMalloc >= 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
if( pMem->szMalloc>0 ) { 
// ABS Label 46
if(pMem->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
}
    pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
  }
  
// ABS Label 47
if(pMem->zMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ROR Label 48
if((pMem->zMalloc != 0) != (pMem->zMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
if( pMem->zMalloc==0 ){
    
// ABS Label 49
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
sqlite3VdbeMemSetNull(pMem);
    pMem->z = 0;
    pMem->szMalloc = 0;
    return SQLITE_NOMEM_BKPT;
  }else{
    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
  }

  
// ABS Label 50
if(bPreserve < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
// ABS Label 51
if(pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// COR Label 52
if((bPreserve || pMem->z) != (bPreserve && pMem->z))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 52);
}

// MCC Label 53
if(bPreserve && pMem->z ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 53);
}
// MCC Label 54
if(bPreserve && !(pMem->z) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(!(bPreserve) && pMem->z ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(bPreserve) && !(pMem->z) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
if( bPreserve && pMem->z ){
    assert( pMem->z!=pMem->zMalloc );
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
  }
  
// ROR Label 57
if(((pMem->flags & 1024) == 0) != ((pMem->flags & 1024) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
if( (pMem->flags&MEM_Dyn)!=0 ){
    assert( pMem->xDel!=0 && pMem->xDel!=SQLITE_DYNAMIC );
    pMem->xDel((void *)(pMem->z));
  }

  pMem->z = pMem->zMalloc;
  pMem->flags &= ~(MEM_Dyn|MEM_Ephem|MEM_Static);
  return SQLITE_OK;
}

/*
** Change the pMem->zMalloc allocation to be at least szNew bytes.
** If pMem->zMalloc already meets or exceeds the requested size, this
** routine is a no-op.
**
** Any prior string or blob content in the pMem object may be discarded.
** The pMem->xDel destructor is called, if it exists.  Though MEM_Str
** and MEM_Blob values may be discarded, MEM_Int, MEM_Real, MEM_IntReal,
** and MEM_Null values are preserved.
**
** Return SQLITE_OK on success or an error code (probably SQLITE_NOMEM)
** if unable to complete the resizing.
*/
int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew){
  assert( CORRUPT_DB || szNew>0 );
  assert( (pMem->flags & MEM_Dyn)==0 || pMem->szMalloc==0 );
  
// ABS Label 58
if(pMem->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
// ABS Label 59
if(szNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}

// ROR Label 60
if((pMem->szMalloc <= szNew) != (pMem->szMalloc < szNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
// ROR Label 61
if((pMem->szMalloc > szNew) != (pMem->szMalloc < szNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
// ROR Label 62
if((pMem->szMalloc >= szNew) != (pMem->szMalloc < szNew))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}
if( pMem->szMalloc<szNew ){
    return sqlite3VdbeMemGrow(pMem, szNew, 0);
  }
  assert( (pMem->flags & MEM_Dyn)==0 );
  pMem->z = pMem->zMalloc;
  pMem->flags &= (MEM_Null|MEM_Int|MEM_Real|MEM_IntReal);
  return SQLITE_OK;
}

/*
** It is already known that pMem contains an unterminated string.
** Add the zero terminator.
**
** Three bytes of zero are added.  In this way, there is guaranteed
** to be a double-zero byte at an even byte boundary in order to
** terminate a UTF16 string, even if the initial size of the buffer
** is an odd number of bytes.
*/
static SQLITE_NOINLINE int vdbeMemAddTerminator(Mem *pMem){
  if( sqlite3VdbeMemGrow(pMem, pMem->n+3, 1) ){
    return SQLITE_NOMEM_BKPT;
  }
  pMem->z[pMem->n] = 0;
  pMem->z[pMem->n+1] = 0;
  pMem->z[pMem->n+2] = 0;
  pMem->flags |= MEM_Term;
  return SQLITE_OK;
}

/*
** Change pMem so that its MEM_Str or MEM_Blob value is stored in
** MEM.zMalloc, where it can be safely written.
**
** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.
*/
int sqlite3VdbeMemMakeWriteable(Mem *pMem){
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  
// ROR Label 63
if(((pMem->flags & (2 | 16)) == 0) != ((pMem->flags & (2 | 16)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
if( (pMem->flags & (MEM_Str|MEM_Blob))!=0 ){
    if( ExpandBlob(pMem) ) { return SQLITE_NOMEM;
}
    
// ABS Label 64
if(pMem->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}
// ABS Label 65
if(pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
// ABS Label 66
if(pMem->zMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}

// COR Label 67
if((pMem->szMalloc == 0 && pMem->z != pMem->zMalloc) != (pMem->szMalloc == 0 || pMem->z != pMem->zMalloc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 67);
}

// ROR Label 68
if((pMem->szMalloc != 0) != (pMem->szMalloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}
// ROR Label 69
if((pMem->z == pMem->zMalloc) != (pMem->z != pMem->zMalloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 69);
}

// MCC Label 70
if(pMem->szMalloc == 0 && pMem->z != pMem->zMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 70);
}
// MCC Label 71
if(pMem->szMalloc == 0 && !(pMem->z != pMem->zMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if(!(pMem->szMalloc == 0) && pMem->z != pMem->zMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
// MCC Label 73
if(!(pMem->szMalloc == 0) && !(pMem->z != pMem->zMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
if( pMem->szMalloc==0 || pMem->z!=pMem->zMalloc ){
      int rc = vdbeMemAddTerminator(pMem);
      
// ABS Label 74
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}
if( rc ) { 
// ABS Label 75
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 75);
}
return rc;
}
    }
  }
  pMem->flags &= ~MEM_Ephem;
#ifdef SQLITE_DEBUG
  pMem->pScopyFrom = 0;
#endif

  return SQLITE_OK;
}

/*
** If the given Mem* has a zero-filled tail, turn it into an ordinary
** blob stored in dynamically allocated space.
*/
#ifndef SQLITE_OMIT_INCRBLOB
int sqlite3VdbeMemExpandBlob(Mem *pMem){
  int nByte;
  assert( pMem->flags & MEM_Zero );
  assert( (pMem->flags&MEM_Blob)!=0 || MemNullNochng(pMem) );
  testcase( sqlite3_value_nochange(pMem) );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );

  /* Set nByte to the number of bytes required to store the expanded blob. */
  nByte = pMem->n + pMem->u.nZero;
  
// ABS Label 76
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}

// ROR Label 77
if((nByte < 0) != (nByte <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
// ROR Label 78
if((nByte > 0) != (nByte <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
// ROR Label 79
if((nByte >= 0) != (nByte <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
if( nByte<=0 ){
    
// ROR Label 80
if(((pMem->flags & 16) != 0) != ((pMem->flags & 16) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
if( (pMem->flags & MEM_Blob)==0 ) { return SQLITE_OK;
}
    nByte = 1;
  }
  if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){
    return SQLITE_NOMEM_BKPT;
  }

  memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
  pMem->n += pMem->u.nZero;
  pMem->flags &= ~(MEM_Zero|MEM_Term);
  return SQLITE_OK;
}
#endif

/*
** Make sure the given Mem is \u0000 terminated.
*/
int sqlite3VdbeMemNulTerminate(Mem *pMem){
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  testcase( (pMem->flags & (MEM_Term|MEM_Str))==(MEM_Term|MEM_Str) );
  testcase( (pMem->flags & (MEM_Term|MEM_Str))==0 );
  
// ROR Label 81
if(((pMem->flags & (512 | 2)) == 2) != ((pMem->flags & (512 | 2)) != 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
if( (pMem->flags & (MEM_Term|MEM_Str))!=MEM_Str ){
    return SQLITE_OK;   /* Nothing to do */
  }else{
    return vdbeMemAddTerminator(pMem);
  }
}

/*
** Add MEM_Str to the set of representations for the given Mem.  This
** routine is only called if pMem is a number of some kind, not a NULL
** or a BLOB.
**
** Existing representations MEM_Int, MEM_Real, or MEM_IntReal are invalidated
** if bForce is true but are retained if bForce is false.
**
** A MEM_Null value will never be passed to this function. This function is
** used for converting values to text for returning to the user (i.e. via
** sqlite3_value_text()), or for ensuring that values to be used as btree
** keys are strings. In the former case a NULL pointer is returned the
** user and the latter is an internal programming error.
*/
int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){
  const int nByte = 32;

  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( !(pMem->flags&MEM_Zero) );
  assert( !(pMem->flags&(MEM_Str|MEM_Blob)) );
  assert( pMem->flags&(MEM_Int|MEM_Real|MEM_IntReal) );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );


  if( sqlite3VdbeMemClearAndResize(pMem, nByte) ){
    pMem->enc = 0;
    return SQLITE_NOMEM_BKPT;
  }

  
// ABS Label 82
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 82);
}

// ABS Label 83
if(pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}

// ABS Label 84
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}
vdbeMemRenderNum(nByte, pMem->z, pMem);
  assert( pMem->z!=0 );
  pMem->n = sqlite3Strlen30NN(pMem->z);
  pMem->enc = SQLITE_UTF8;
  pMem->flags |= MEM_Str|MEM_Term;
  
// ABS Label 86
if(bForce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
if( bForce ) { pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal);
}
  
// ABS Label 85
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
sqlite3VdbeChangeEncoding(pMem, enc);
  return SQLITE_OK;
}

/*
** Memory cell pMem contains the context of an aggregate function.
** This routine calls the finalize method for that function.  The
** result of the aggregate is stored back into pMem.
**
** Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK
** otherwise.
*/
int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){
  sqlite3_context ctx;
  Mem t;
  assert( pFunc!=0 );
  assert( pFunc->xFinalize!=0 );
  assert( (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef );
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  memset(&ctx, 0, sizeof(ctx));
  memset(&t, 0, sizeof(t));
  t.flags = MEM_Null;
  t.db = pMem->db;
  ctx.pOut = &t;
  ctx.pMem = pMem;
  ctx.pFunc = pFunc;
  pFunc->xFinalize(&ctx); /* IMP: R-24505-23230 */
  assert( (pMem->flags & MEM_Dyn)==0 );
  
// ABS Label 87
if(pMem->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}

// ROR Label 88
if((pMem->szMalloc <= 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 88);
}
// ROR Label 89
if((pMem->szMalloc < 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 89);
}
// ROR Label 90
if((pMem->szMalloc >= 0) != (pMem->szMalloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( pMem->szMalloc>0 ) { 
// ABS Label 91
if(pMem->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
}
  memcpy(pMem, &t, sizeof(t));
  
// ABS Label 92
if(ctx.isError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}
return ctx.isError;
}

/*
** Memory cell pAccum contains the context of an aggregate function.
** This routine calls the xValue method for that function and stores
** the results in memory cell pMem.
**
** SQLITE_ERROR is returned if xValue() reports an error. SQLITE_OK 
** otherwise.
*/
#ifndef SQLITE_OMIT_WINDOWFUNC
int sqlite3VdbeMemAggValue(Mem *pAccum, Mem *pOut, FuncDef *pFunc){
  sqlite3_context ctx;
  assert( pFunc!=0 );
  assert( pFunc->xValue!=0 );
  assert( (pAccum->flags & MEM_Null)!=0 || pFunc==pAccum->u.pDef );
  assert( pAccum->db==0 || sqlite3_mutex_held(pAccum->db->mutex) );
  memset(&ctx, 0, sizeof(ctx));
  
// ABS Label 93
if(pOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
sqlite3VdbeMemSetNull(pOut);
  ctx.pOut = pOut;
  ctx.pMem = pAccum;
  ctx.pFunc = pFunc;
  pFunc->xValue(&ctx);
  
// ABS Label 94
if(ctx.isError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}
return ctx.isError;
}
#endif /* SQLITE_OMIT_WINDOWFUNC */

/*
** If the memory cell contains a value that must be freed by
** invoking the external callback in Mem.xDel, then this routine
** will free that value.  It also sets Mem.flags to MEM_Null.
**
** This is a helper routine for sqlite3VdbeMemSetNull() and
** for sqlite3VdbeMemRelease().  Use those other routines as the
** entry point for releasing Mem resources.
*/
static SQLITE_NOINLINE void vdbeMemClearExternAndSetNull(Mem *p){
  assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) );
  assert( VdbeMemDynamic(p) );
  
// AOR Label 95
if(p->flags | 8192 != p->flags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 95);
}
// AOR Label 96
if(p->flags ^ 8192 != p->flags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 96);
}
if( p->flags&MEM_Agg ){
    
// ABS Label 97
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// ABS Label 98
if(p->u.pDef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
sqlite3VdbeMemFinalize(p, p->u.pDef);
    assert( (p->flags & MEM_Agg)==0 );
    testcase( p->flags & MEM_Dyn );
  }
  
// AOR Label 99
if(p->flags | 1024 != p->flags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 99);
}
// AOR Label 100
if(p->flags ^ 1024 != p->flags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 100);
}
if( p->flags&MEM_Dyn ){
    assert( p->xDel!=SQLITE_DYNAMIC && p->xDel!=0 );
    p->xDel((void *)p->z);
  }
  p->flags = MEM_Null;
}

/*
** Release memory held by the Mem p, both external memory cleared
** by p->xDel and memory in p->zMalloc.
**
** This is a helper routine invoked by sqlite3VdbeMemRelease() in
** the unusual case where there really is memory in p that needs
** to be freed.
*/
static SQLITE_NOINLINE void vdbeMemClear(Mem *p){
  
// MCC Label 101
if(( ((p)->flags & (8192 | 1024)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 101);
}
// MCC Label 102
if(( !(((p)->flags & (8192 | 1024)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
if( VdbeMemDynamic(p) ){
    
// ABS Label 103
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
vdbeMemClearExternAndSetNull(p);
  }
  
// ABS Label 104
if(p->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
if( p->szMalloc ){
    
// ABS Label 105
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}
sqlite3DbFreeNN(p->db, p->zMalloc);
    p->szMalloc = 0;
  }
  p->z = 0;
}

/*
** Release any memory resources held by the Mem.  Both the memory that is
** free by Mem.xDel and the Mem.zMalloc allocation are freed.
**
** Use this routine prior to clean up prior to abandoning a Mem, or to
** reset a Mem back to its minimum memory utilization.
**
** Use sqlite3VdbeMemSetNull() to release just the Mem.xDel space
** prior to inserting new content into the Mem.
*/
void sqlite3VdbeMemRelease(Mem *p){
  assert( sqlite3VdbeCheckMemInvariants(p) );
  
// ABS Label 106
if(p->szMalloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}

// COR Label 107
if(((((p)->flags & (8192 | 1024)) != 0) && p->szMalloc) != ((((p)->flags & (8192 | 1024)) != 0) || p->szMalloc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 107);
}

// MCC Label 108
if(( ((p)->flags & (8192 | 1024)) != 0 ) && p->szMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
// MCC Label 109
if(( ((p)->flags & (8192 | 1024)) != 0 ) && !(p->szMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 109);
}
// MCC Label 110
if(( !(((p)->flags & (8192 | 1024)) != 0) ) && p->szMalloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(( !(((p)->flags & (8192 | 1024)) != 0) ) && !(p->szMalloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
if( VdbeMemDynamic(p) || p->szMalloc ){
    
// ABS Label 112
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}
vdbeMemClear(p);
  }
}

/*
** Convert a 64-bit IEEE double into a 64-bit signed integer.
** If the double is out of range of a 64-bit signed integer then
** return the closest available 64-bit signed integer.
*/
static SQLITE_NOINLINE i64 doubleToInt64(double r){
#ifdef SQLITE_OMIT_FLOATING_POINT
  /* When floating-point is omitted, double and int64 are the same thing */
  return r;
#else
  /*
  ** Many compilers we encounter do not define constants for the
  ** minimum and maximum 64-bit integers, or they define them
  ** inconsistently.  And many do not understand the "LL" notation.
  ** So we define our own static constants here using nothing
  ** larger than a 32-bit integer constant.
  */
  static const i64 maxInt = LARGEST_INT64;
  static const i64 minInt = SMALLEST_INT64;

  
// ABS Label 113
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}

// ROR Label 114
if((r < (double)minInt) != (r <= (double)minInt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}
// ROR Label 115
if((r > (double)minInt) != (r <= (double)minInt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
// ROR Label 116
if((r >= (double)minInt) != (r <= (double)minInt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
if( r<=(double)minInt ){
    
// ABS Label 117
if(minInt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
return minInt;
  }else { 
// ABS Label 118
if(r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// ROR Label 119
if((r < (double)maxInt) != (r >= (double)maxInt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((r > (double)maxInt) != (r >= (double)maxInt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
// ROR Label 121
if((r <= (double)maxInt) != (r >= (double)maxInt))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
if( r>=(double)maxInt ){
    
// ABS Label 122
if(maxInt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}
return maxInt;
  }else{
    return (i64)r;
  };}

#endif
}

/*
** Return some kind of integer value which is the best we can do
** at representing the value that *pMem describes as an integer.
** If pMem is an integer, then the value is exact.  If pMem is
** a floating-point then the value returned is the integer part.
** If pMem is a string or blob, then we make an attempt to convert
** it into an integer and return that.  If pMem represents an
** an SQL-NULL value, return 0.
**
** If pMem represents a string value, its encoding might be changed.
*/
static SQLITE_NOINLINE i64 memIntValue(Mem *pMem){
  i64 value = 0;
  
// ABS Label 123
if(pMem->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}

// ABS Label 124
if(pMem->enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}
sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
  
// ABS Label 125
if(value < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 125);
}
return value;
}
i64 sqlite3VdbeIntValue(Mem *pMem){
  int flags;
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );
  flags = pMem->flags;
  
// ABS Label 126
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}

// AOR Label 127
if(flags | (4 | 32) != flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 127);
}
// AOR Label 128
if(flags ^ (4 | 32) != flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 128);
}
if( flags & (MEM_Int|MEM_IntReal) ){
    testcase( flags & MEM_IntReal );
    
// ABS Label 129
if(pMem->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}
return pMem->u.i;
  }else { 
// ABS Label 130
if(flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 130);
}

// AOR Label 131
if(flags | 8 != flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 131);
}
// AOR Label 132
if(flags ^ 8 != flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 132);
}
if( flags & MEM_Real ){
    return doubleToInt64(pMem->u.r);
  }else { 
// ABS Label 133
if(pMem->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}

// COR Label 134
if(((flags & (2 | 16)) != 0 || pMem->z != 0) != ((flags & (2 | 16)) != 0 && pMem->z != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 134);
}

// ROR Label 135
if(((flags & (2 | 16)) == 0) != ((flags & (2 | 16)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 135);
}
// ROR Label 136
if((pMem->z == 0) != (pMem->z != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 136);
}

// MCC Label 137
if((flags & (2 | 16)) != 0 && pMem->z != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
// MCC Label 138
if((flags & (2 | 16)) != 0 && !(pMem->z != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
// MCC Label 139
if(!((flags & (2 | 16)) != 0) && pMem->z != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 139);
}
// MCC Label 140
if(!((flags & (2 | 16)) != 0) && !(pMem->z != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 140);
}
if( (flags & (MEM_Str|MEM_Blob))!=0 && pMem->z!=0 ){
    return memIntValue(pMem);
  }else{
    return 0;
  };}
;}

}

/*
** Return the best representation of pMem that we can get into a
** double.  If pMem is already a double or an integer, return its
** value.  If it is a string or blob, try to convert it to a double.
** If it is a NULL, return 0.0.
*/
static SQLITE_NOINLINE double memRealValue(Mem *pMem){
  /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
  double val = (double)0;
  
// ABS Label 141
if(pMem->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}

// ABS Label 142
if(pMem->enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
  
// ABS Label 143
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}
return val;
}
double sqlite3VdbeRealValue(Mem *pMem){
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );
  
// AOR Label 144
if(pMem->flags | 8 != pMem->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 144);
}
// AOR Label 145
if(pMem->flags ^ 8 != pMem->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 145);
}
if( pMem->flags & MEM_Real ){
    
// ABS Label 146
if(pMem->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 146);
}
return pMem->u.r;
  }else { 
// AOR Label 147
if(pMem->flags | (4 | 32) != pMem->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 147);
}
// AOR Label 148
if(pMem->flags ^ (4 | 32) != pMem->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 148);
}
if( pMem->flags & (MEM_Int|MEM_IntReal) ){
    testcase( pMem->flags & MEM_IntReal );
    return (double)pMem->u.i;
  }else { 
// AOR Label 149
if(pMem->flags | (2 | 16) != pMem->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 149);
}
// AOR Label 150
if(pMem->flags ^ (2 | 16) != pMem->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 150);
}
if( pMem->flags & (MEM_Str|MEM_Blob) ){
    return memRealValue(pMem);
  }else{
    /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */
    return (double)0;
  };}
;}

}

/*
** Return 1 if pMem represents true, and return 0 if pMem represents false.
** Return the value ifNull if pMem is NULL.  
*/
int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){
  testcase( pMem->flags & MEM_IntReal );
  
// AOR Label 151
if(pMem->flags | (4 | 32) != pMem->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 151);
}
// AOR Label 152
if(pMem->flags ^ (4 | 32) != pMem->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 152);
}
if( pMem->flags & (MEM_Int|MEM_IntReal) ) { 
// ABS Label 153
if(pMem->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ROR Label 154
if((pMem->u.i == 0) != (pMem->u.i != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
return pMem->u.i!=0;
}
  
// AOR Label 155
if(pMem->flags | 1 != pMem->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 155);
}
// AOR Label 156
if(pMem->flags ^ 1 != pMem->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 156);
}
if( pMem->flags & MEM_Null ) { 
// ABS Label 157
if(ifNull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
return ifNull;
}
  return sqlite3VdbeRealValue(pMem)!=0.0;
}

/*
** The MEM structure is already a MEM_Real.  Try to also make it a
** MEM_Int if we can.
*/
void sqlite3VdbeIntegerAffinity(Mem *pMem){
  i64 ix;
  assert( pMem->flags & MEM_Real );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );

  ix = doubleToInt64(pMem->u.r);

  /* Only mark the value as an integer if
  **
  **    (1) the round-trip conversion real->int->real is a no-op, and
  **    (2) The integer is neither the largest nor the smallest
  **        possible integer (ticket #3922)
  **
  ** The second and third terms in the following conditional enforces
  ** the second condition under the assumption that addition overflow causes
  ** values to wrap around.
  */
  
// ABS Label 158
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}
// ABS Label 159
if(pMem->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 159);
}

// COR Label 160
if((pMem->u.r == ix && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) || ix < (4294967295U | (((i64)2147483647) << 32))) != (pMem->u.r == ix && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) && ix < (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 160);
}
// COR Label 161
if((pMem->u.r == ix || ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (pMem->u.r == ix && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 161);
}

// ROR Label 162
if((pMem->u.r != ix) != (pMem->u.r == ix))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((ix <= (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
// ROR Label 164
if((ix < (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
// ROR Label 165
if((ix >= (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((ix <= (4294967295U | (((i64)2147483647) << 32))) != (ix < (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
// ROR Label 167
if((ix > (4294967295U | (((i64)2147483647) << 32))) != (ix < (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((ix >= (4294967295U | (((i64)2147483647) << 32))) != (ix < (4294967295U | (((i64)2147483647) << 32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}

// MCC Label 169
if(pMem->u.r == ix && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) && ix < (4294967295U | (((i64)2147483647) << 32)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
// MCC Label 170
if(pMem->u.r == ix && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) && !(ix < (4294967295U | (((i64)2147483647) << 32))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
// MCC Label 171
if(pMem->u.r == ix && !(ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) && ix < (4294967295U | (((i64)2147483647) << 32)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 171);
}
// MCC Label 172
if(pMem->u.r == ix && !(ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) && !(ix < (4294967295U | (((i64)2147483647) << 32))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}
// MCC Label 173
if(!(pMem->u.r == ix) && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) && ix < (4294967295U | (((i64)2147483647) << 32)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 173);
}
// MCC Label 174
if(!(pMem->u.r == ix) && ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32))) && !(ix < (4294967295U | (((i64)2147483647) << 32))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 174);
}
// MCC Label 175
if(!(pMem->u.r == ix) && !(ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) && ix < (4294967295U | (((i64)2147483647) << 32)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 175);
}
// MCC Label 176
if(!(pMem->u.r == ix) && !(ix > (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) && !(ix < (4294967295U | (((i64)2147483647) << 32))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 176);
}
if( pMem->u.r==ix && ix>SMALLEST_INT64 && ix<LARGEST_INT64 ){
    pMem->u.i = ix;
    MemSetTypeFlag(pMem, MEM_Int);
  }
}

/*
** Convert pMem to type integer.  Invalidate any prior representations.
*/
int sqlite3VdbeMemIntegerify(Mem *pMem){
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );

  pMem->u.i = sqlite3VdbeIntValue(pMem);
  MemSetTypeFlag(pMem, MEM_Int);
  return SQLITE_OK;
}

/*
** Convert pMem so that it is of type MEM_Real.
** Invalidate any prior representations.
*/
int sqlite3VdbeMemRealify(Mem *pMem){
  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( EIGHT_BYTE_ALIGNMENT(pMem) );

  pMem->u.r = sqlite3VdbeRealValue(pMem);
  MemSetTypeFlag(pMem, MEM_Real);
  return SQLITE_OK;
}

/* Compare a floating point value to an integer.  Return true if the two
** values are the same within the precision of the floating point value.
**
** This function assumes that i was obtained by assignment from r1.
**
** For some versions of GCC on 32-bit machines, if you do the more obvious
** comparison of "r1==(double)i" you sometimes get an answer of false even
** though the r1 and (double)i values are bit-for-bit the same.
*/
int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){
  double r2 = (double)i;
  
// ABS Label 177
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 177);
}

// COR Label 178
if((r1 == 0. && (memcmp(&r1, &r2, sizeof (r1)) == 0 && i >= -2251799813685248LL && i < 2251799813685248LL)) != (r1 == 0. || (memcmp(&r1, &r2, sizeof (r1)) == 0 && i >= -2251799813685248LL && i < 2251799813685248LL)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 178);
}

// ROR Label 179
if((r1 != 0.) != (r1 == 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 179);
}

// MCC Label 180
if(r1 == 0. && ( 1 && i >= -2251799813685248LL && i < 2251799813685248LL ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(r1 == 0. && ( 1 && i >= -2251799813685248LL && !(i < 2251799813685248LL) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(r1 == 0. && ( 1 && !(i >= -2251799813685248LL) && i < 2251799813685248LL ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(r1 == 0. && ( 1 && !(i >= -2251799813685248LL) && !(i < 2251799813685248LL) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(!(r1 == 0.) && ( 1 && i >= -2251799813685248LL && i < 2251799813685248LL ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}
// MCC Label 185
if(!(r1 == 0.) && ( 1 && i >= -2251799813685248LL && !(i < 2251799813685248LL) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 185);
}
// MCC Label 186
if(!(r1 == 0.) && ( 1 && !(i >= -2251799813685248LL) && i < 2251799813685248LL ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 186);
}
// MCC Label 187
if(!(r1 == 0.) && ( 1 && !(i >= -2251799813685248LL) && !(i < 2251799813685248LL) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 187);
}
return r1==0.0
      || (memcmp(&r1, &r2, sizeof(r1))==0
          && i >= -2251799813685248LL && i < 2251799813685248LL);
}

/*
** Convert pMem so that it has type MEM_Real or MEM_Int.
** Invalidate any prior representations.
**
** Every effort is made to force the conversion, even if the input
** is a string that does not look completely like a number.  Convert
** as much of the string as we can and ignore the rest.
*/
int sqlite3VdbeMemNumerify(Mem *pMem){
  testcase( pMem->flags & MEM_Int );
  testcase( pMem->flags & MEM_Real );
  testcase( pMem->flags & MEM_IntReal );
  testcase( pMem->flags & MEM_Null );
  
// ROR Label 188
if(((pMem->flags & (4 | 8 | 32 | 1)) != 0) != ((pMem->flags & (4 | 8 | 32 | 1)) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
if( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))==0 ){
    int rc;
    sqlite3_int64 ix;
    assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );
    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
    rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
    if( ((rc==0 || rc==1) && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1)
     || sqlite3RealSameAsInt(pMem->u.r, (ix = (i64)pMem->u.r))
    ){
      pMem->u.i = ix;
      MemSetTypeFlag(pMem, MEM_Int);
    }else{
      MemSetTypeFlag(pMem, MEM_Real);
    }
  }
  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))!=0 );
  pMem->flags &= ~(MEM_Str|MEM_Blob|MEM_Zero);
  return SQLITE_OK;
}

/*
** Cast the datatype of the value in pMem according to the affinity
** "aff".  Casting is different from applying affinity in that a cast
** is forced.  In other words, the value is converted into the desired
** affinity even if that results in loss of data.  This routine is
** used (for example) to implement the SQL "cast()" operator.
*/
int sqlite3VdbeMemCast(Mem *pMem, u8 aff, u8 encoding){
  
// AOR Label 189
if(pMem->flags | 1 != pMem->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 189);
}
// AOR Label 190
if(pMem->flags ^ 1 != pMem->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 190);
}
if( pMem->flags & MEM_Null ) { return SQLITE_OK;
}
  switch( aff ){
    case SQLITE_AFF_BLOB: {   /* Really a cast to BLOB */
      
// ROR Label 191
if(((pMem->flags & 16) != 0) != ((pMem->flags & 16) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 191);
}
if( (pMem->flags & MEM_Blob)==0 ){
        
// ABS Label 192
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 192);
}

// ABS Label 193
if(encoding < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 193);
}
sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);
        assert( pMem->flags & MEM_Str || pMem->db->mallocFailed );
        
// AOR Label 194
if(pMem->flags | 2 != pMem->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 194);
}
// AOR Label 195
if(pMem->flags ^ 2 != pMem->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 195);
}
if( pMem->flags & MEM_Str ) { MemSetTypeFlag(pMem, MEM_Blob);
}
      }else{
        pMem->flags &= ~(MEM_TypeMask&~MEM_Blob);
      }
      break;
    }
    case SQLITE_AFF_NUMERIC: {
      
// ABS Label 196
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}
sqlite3VdbeMemNumerify(pMem);
      break;
    }
    case SQLITE_AFF_INTEGER: {
      
// ABS Label 197
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 197);
}
sqlite3VdbeMemIntegerify(pMem);
      break;
    }
    case SQLITE_AFF_REAL: {
      
// ABS Label 198
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}
sqlite3VdbeMemRealify(pMem);
      break;
    }
    default: {
      assert( aff==SQLITE_AFF_TEXT );
      assert( MEM_Str==(MEM_Blob>>3) );
      pMem->flags |= (pMem->flags&MEM_Blob)>>3;
      
// ABS Label 199
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 199);
}

// ABS Label 200
if(encoding < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);
      assert( pMem->flags & MEM_Str || pMem->db->mallocFailed );
      pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal|MEM_Blob|MEM_Zero);
      return sqlite3VdbeChangeEncoding(pMem, encoding);
    }
  }
  return SQLITE_OK;
}

/*
** Initialize bulk memory to be a consistent Mem object.
**
** The minimum amount of initialization feasible is performed.
*/
void sqlite3VdbeMemInit(Mem *pMem, sqlite3 *db, u16 flags){
  assert( (flags & ~MEM_TypeMask)==0 );
  pMem->flags = flags;
  pMem->db = db;
  pMem->szMalloc = 0;
}


/*
** Delete any previous value and set the value stored in *pMem to NULL.
**
** This routine calls the Mem.xDel destructor to dispose of values that
** require the destructor.  But it preserves the Mem.zMalloc memory allocation.
** To free all resources, use sqlite3VdbeMemRelease(), which both calls this
** routine to invoke the destructor and deallocates Mem.zMalloc.
**
** Use this routine to reset the Mem prior to insert a new value.
**
** Use sqlite3VdbeMemRelease() to complete erase the Mem prior to abandoning it.
*/
void sqlite3VdbeMemSetNull(Mem *pMem){
  
// MCC Label 201
if(( ((pMem)->flags & (8192 | 1024)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 201);
}
// MCC Label 202
if(( !(((pMem)->flags & (8192 | 1024)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 202);
}
if( VdbeMemDynamic(pMem) ){
    
// ABS Label 203
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 203);
}
vdbeMemClearExternAndSetNull(pMem);
  }else{
    pMem->flags = MEM_Null;
  }
}
void sqlite3ValueSetNull(sqlite3_value *p){
  sqlite3VdbeMemSetNull((Mem*)p); 
}

/*
** Delete any previous value and set the value to be a BLOB of length
** n containing all zeros.
*/
void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){
  
// ABS Label 204
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}
sqlite3VdbeMemRelease(pMem);
  pMem->flags = MEM_Blob|MEM_Zero;
  pMem->n = 0;
  
// ABS Label 205
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 205);
}

// ROR Label 206
if((n <= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 206);
}
// ROR Label 207
if((n > 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 207);
}
// ROR Label 208
if((n >= 0) != (n < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
if( n<0 ) { n = 0;
}
  pMem->u.nZero = n;
  pMem->enc = SQLITE_UTF8;
  pMem->z = 0;
}

/*
** The pMem is known to contain content that needs to be destroyed prior
** to a value change.  So invoke the destructor, then set the value to
** a 64-bit integer.
*/
static SQLITE_NOINLINE void vdbeReleaseAndSetInt64(Mem *pMem, i64 val){
  
// ABS Label 209
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 209);
}
sqlite3VdbeMemSetNull(pMem);
  pMem->u.i = val;
  pMem->flags = MEM_Int;
}

/*
** Delete any previous value and set the value stored in *pMem to val,
** manifest type INTEGER.
*/
void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){
  
// MCC Label 210
if(( ((pMem)->flags & (8192 | 1024)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 210);
}
// MCC Label 211
if(( !(((pMem)->flags & (8192 | 1024)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 211);
}
if( VdbeMemDynamic(pMem) ){
    
// ABS Label 212
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// ABS Label 213
if(val < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}
vdbeReleaseAndSetInt64(pMem, val);
  }else{
    pMem->u.i = val;
    pMem->flags = MEM_Int;
  }
}

/* A no-op destructor */
void sqlite3NoopDestructor(void *p){ UNUSED_PARAMETER(p); }

/*
** Set the value stored in *pMem should already be a NULL.
** Also store a pointer to go with it.
*/
void sqlite3VdbeMemSetPointer(
  Mem *pMem,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
){
  assert( pMem->flags==MEM_Null );
  pMem->u.zPType = zPType ? zPType : "";
  pMem->z = pPtr;
  pMem->flags = MEM_Null|MEM_Dyn|MEM_Subtype|MEM_Term;
  pMem->eSubtype = 'p';
  pMem->xDel = xDestructor ? xDestructor : sqlite3NoopDestructor;
}

#ifndef SQLITE_OMIT_FLOATING_POINT
/*
** Delete any previous value and set the value stored in *pMem to val,
** manifest type REAL.
*/
void sqlite3VdbeMemSetDouble(Mem *pMem, double val){
  
// ABS Label 214
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}
sqlite3VdbeMemSetNull(pMem);
  if( !sqlite3IsNaN(val) ){
    pMem->u.r = val;
    pMem->flags = MEM_Real;
  }
}
#endif

#ifdef SQLITE_DEBUG
/*
** Return true if the Mem holds a RowSet object.  This routine is intended
** for use inside of assert() statements.
*/
int sqlite3VdbeMemIsRowSet(const Mem *pMem){
  return (pMem->flags&(MEM_Blob|MEM_Dyn))==(MEM_Blob|MEM_Dyn)
         && pMem->xDel==sqlite3RowSetDelete;
}
#endif

/*
** Delete any previous value and set the value of pMem to be an
** empty boolean index.
**
** Return SQLITE_OK on success and SQLITE_NOMEM if a memory allocation
** error occurs.
*/
int sqlite3VdbeMemSetRowSet(Mem *pMem){
  
// ABS Label 215
if(pMem->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 215);
}
sqlite3 *db = pMem->db;
  RowSet *p;
  assert( db!=0 );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  
// ABS Label 216
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}
sqlite3VdbeMemRelease(pMem);
  p = sqlite3RowSetInit(db);
  
// ABS Label 217
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 217);
}

// ROR Label 218
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
if( p==0 ) { return SQLITE_NOMEM;
}
  pMem->z = (char*)p;
  pMem->flags = MEM_Blob|MEM_Dyn;
  pMem->xDel = sqlite3RowSetDelete;
  return SQLITE_OK;
}

/*
** Return true if the Mem object contains a TEXT or BLOB that is
** too large - whose size exceeds SQLITE_MAX_LENGTH.
*/
int sqlite3VdbeMemTooBig(Mem *p){
  assert( p->db!=0 );
  
// AOR Label 219
if(p->flags | (2 | 16) != p->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 219);
}
// AOR Label 220
if(p->flags ^ (2 | 16) != p->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 220);
}
if( p->flags & (MEM_Str|MEM_Blob) ){
    
// ABS Label 221
if(p->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
int n = p->n;
    
// AOR Label 222
if(p->flags | 16384 != p->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 222);
}
// AOR Label 223
if(p->flags ^ 16384 != p->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 223);
}
if( p->flags & MEM_Zero ){
      n += p->u.nZero;
    }
    
// ABS Label 224
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 224);
}
// ABS Label 225
if(p->db->aLimit[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 225);
}

// ROR Label 226
if((n <= p->db->aLimit[0]) != (n > p->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 226);
}
// ROR Label 227
if((n < p->db->aLimit[0]) != (n > p->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 227);
}
// ROR Label 228
if((n >= p->db->aLimit[0]) != (n > p->db->aLimit[0]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 228);
}
return n>p->db->aLimit[SQLITE_LIMIT_LENGTH];
  }
  return 0; 
}

#ifdef SQLITE_DEBUG
/*
** This routine prepares a memory cell for modification by breaking
** its link to a shallow copy and by marking any current shallow
** copies of this cell as invalid.
**
** This is used for testing and debugging only - to help ensure that shallow
** copies (created by OP_SCopy) are not misused.
*/
void sqlite3VdbeMemAboutToChange(Vdbe *pVdbe, Mem *pMem){
  int i;
  Mem *pX;
  for(i=1, pX=pVdbe->aMem+1; i<pVdbe->nMem; i++, pX++){
    if( pX->pScopyFrom==pMem ){
      u16 mFlags;
      if( pVdbe->db->flags & SQLITE_VdbeTrace ){
        sqlite3DebugPrintf("Invalidate R[%d] due to change in R[%d]\n",
          (int)(pX - pVdbe->aMem), (int)(pMem - pVdbe->aMem));
      }
      /* If pX is marked as a shallow copy of pMem, then try to verify that
      ** no significant changes have been made to pX since the OP_SCopy.
      ** A significant change would indicated a missed call to this
      ** function for pX.  Minor changes, such as adding or removing a
      ** dual type, are allowed, as long as the underlying value is the
      ** same. */
      mFlags = pMem->flags & pX->flags & pX->mScopyFlags;
      assert( (mFlags&(MEM_Int|MEM_IntReal))==0 || pMem->u.i==pX->u.i );
      
      /* pMem is the register that is changing.  But also mark pX as
      ** undefined so that we can quickly detect the shallow-copy error */
      pX->flags = MEM_Undefined;
      pX->pScopyFrom = 0;
    }
  }
  pMem->pScopyFrom = 0;
}
#endif /* SQLITE_DEBUG */

/*
** Make an shallow copy of pFrom into pTo.  Prior contents of
** pTo are freed.  The pFrom->z field is not duplicated.  If
** pFrom->z is used, then pTo->z points to the same thing as pFrom->z
** and flags gets srcType (either MEM_Ephem or MEM_Static).
*/
static SQLITE_NOINLINE void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType){
  
// ABS Label 229
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}
vdbeMemClearExternAndSetNull(pTo);
  assert( !VdbeMemDynamic(pTo) );
  
// ABS Label 230
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 230);
}

// ABS Label 231
if(pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ABS Label 232
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 232);
}
sqlite3VdbeMemShallowCopy(pTo, pFrom, eType);
}
void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){
  assert( !sqlite3VdbeMemIsRowSet(pFrom) );
  assert( pTo->db==pFrom->db );
  
// MCC Label 233
if(( ((pTo)->flags & (8192 | 1024)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
// MCC Label 234
if(( !(((pTo)->flags & (8192 | 1024)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
if( VdbeMemDynamic(pTo) ){ 
// ABS Label 235
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}

// ABS Label 236
if(pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}

// ABS Label 237
if(srcType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}
vdbeClrCopy(pTo,pFrom,srcType); return; }
  memcpy(pTo, pFrom, MEMCELLSIZE);
  
// ROR Label 238
if(((pFrom->flags & 2048) != 0) != ((pFrom->flags & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
if( (pFrom->flags&MEM_Static)==0 ){
    pTo->flags &= ~(MEM_Dyn|MEM_Static|MEM_Ephem);
    assert( srcType==MEM_Ephem || srcType==MEM_Static );
    pTo->flags |= srcType;
  }
}

/*
** Make a full copy of pFrom into pTo.  Prior contents of pTo are
** freed before the copy is made.
*/
int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){
  int rc = SQLITE_OK;

  assert( !sqlite3VdbeMemIsRowSet(pFrom) );
  
// MCC Label 239
if(( ((pTo)->flags & (8192 | 1024)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 239);
}
// MCC Label 240
if(( !(((pTo)->flags & (8192 | 1024)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
if( VdbeMemDynamic(pTo) ) { 
// ABS Label 241
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 241);
}
vdbeMemClearExternAndSetNull(pTo);
}
  memcpy(pTo, pFrom, MEMCELLSIZE);
  pTo->flags &= ~MEM_Dyn;
  
// AOR Label 242
if(pTo->flags | (2 | 16) != pTo->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 242);
}
// AOR Label 243
if(pTo->flags ^ (2 | 16) != pTo->flags & (2 | 16))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 243);
}
if( pTo->flags&(MEM_Str|MEM_Blob) ){
    
// ROR Label 244
if((0 != (pFrom->flags & 2048)) != (0 == (pFrom->flags & 2048)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}
if( 0==(pFrom->flags&MEM_Static) ){
      pTo->flags |= MEM_Ephem;
      rc = sqlite3VdbeMemMakeWriteable(pTo);
    }
  }

  
// ABS Label 245
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 245);
}
return rc;
}

/*
** Transfer the contents of pFrom to pTo. Any existing value in pTo is
** freed. If pFrom contains ephemeral data, a copy is made.
**
** pFrom contains an SQL NULL when this routine returns.
*/
void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){
  assert( pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) );
  assert( pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) );
  assert( pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db );

  
// ABS Label 246
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 246);
}
sqlite3VdbeMemRelease(pTo);
  memcpy(pTo, pFrom, sizeof(Mem));
  pFrom->flags = MEM_Null;
  pFrom->szMalloc = 0;
}

/*
** Change the value of a Mem to be a string or a BLOB.
**
** The memory management strategy depends on the value of the xDel
** parameter. If the value passed is SQLITE_TRANSIENT, then the 
** string is copied into a (possibly existing) buffer managed by the 
** Mem structure. Otherwise, any existing buffer is freed and the
** pointer copied.
**
** If the string is too large (if it exceeds the SQLITE_LIMIT_LENGTH
** size limit) then no memory allocation occurs.  If the string can be
** stored without allocating memory, then it is.  If a memory allocation
** is required to store the string, then value of pMem is unchanged.  In
** either case, SQLITE_TOOBIG is returned.
*/
int sqlite3VdbeMemSetStr(
  Mem *pMem,          /* Memory cell to set to string value */
  const char *z,      /* String pointer */
  i64 n,              /* Bytes in string, or negative */
  u8 enc,             /* Encoding of z.  0 for BLOBs */
  void (*xDel)(void*) /* Destructor function */
){
  
// ABS Label 247
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 247);
}
i64 nByte = n;      /* New value for pMem->n */
  int iLimit;         /* Maximum allowed string or blob size */
  u16 flags = 0;      /* New value for pMem->flags */

  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
  assert( !sqlite3VdbeMemIsRowSet(pMem) );

  /* If z is a NULL pointer, set pMem to contain an SQL NULL. */
  if( !z ){
    
// ABS Label 248
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}
sqlite3VdbeMemSetNull(pMem);
    return SQLITE_OK;
  }

  
// ABS Label 249
if(pMem->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}
if( pMem->db ){
    iLimit = pMem->db->aLimit[SQLITE_LIMIT_LENGTH];
  }else{
    iLimit = SQLITE_MAX_LENGTH;
  }
  flags = (enc==0?MEM_Blob:MEM_Str);
  
// ABS Label 250
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 250);
}

// ROR Label 251
if((nByte <= 0) != (nByte < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}
// ROR Label 252
if((nByte > 0) != (nByte < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
// ROR Label 253
if((nByte >= 0) != (nByte < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 253);
}
if( nByte<0 ){
    assert( enc!=0 );
    
// ROR Label 254
if((enc != 1) != (enc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
if( enc==SQLITE_UTF8 ){
      nByte = strlen(z);
    }else{
      nByte = 0;

// ABS Label 255
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}

// COR Label 256
if((nByte <= iLimit || (z[nByte] | z[nByte + 1])) != (nByte <= iLimit && (z[nByte] | z[nByte + 1])))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 256);
}

// ROR Label 257
if((nByte < iLimit) != (nByte <= iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
// ROR Label 258
if((nByte > iLimit) != (nByte <= iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 258);
}
// ROR Label 259
if((nByte >= iLimit) != (nByte <= iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 259);
}

// MCC Label 260
if(nByte <= iLimit && ( z[nByte] | z[nByte + 1] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 260);
}
// MCC Label 261
if(nByte <= iLimit && ( !(z[nByte] | z[nByte + 1]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 261);
}
// MCC Label 262
if(!(nByte <= iLimit) && ( z[nByte] | z[nByte + 1] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 262);
}
// MCC Label 263
if(!(nByte <= iLimit) && ( !(z[nByte] | z[nByte + 1]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 263);
}
for(; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){};
// ABS Label 264
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}

// COR Label 265
if((nByte <= iLimit || (z[nByte] | z[nByte + 1])) != (nByte <= iLimit && (z[nByte] | z[nByte + 1])))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 265);
}

// ROR Label 266
if((nByte < iLimit) != (nByte <= iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}
// ROR Label 267
if((nByte > iLimit) != (nByte <= iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((nByte >= iLimit) != (nByte <= iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}

// MCC Label 269
if(nByte <= iLimit && ( z[nByte] | z[nByte + 1] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(nByte <= iLimit && ( !(z[nByte] | z[nByte + 1]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
// MCC Label 271
if(!(nByte <= iLimit) && ( z[nByte] | z[nByte + 1] ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 271);
}
// MCC Label 272
if(!(nByte <= iLimit) && ( !(z[nByte] | z[nByte + 1]) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 272);
}

    }
    flags |= MEM_Term;
  }

  /* The following block sets the new values of Mem.z and Mem.xDel. It
  ** also sets a flag in local variable "flags" to indicate the memory
  ** management (one of MEM_Dyn or MEM_Static).
  */
  
// ABS Label 273
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}

// ROR Label 274
if((xDel != ((sqlite3_destructor_type)-1)) != (xDel == ((sqlite3_destructor_type)-1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 274);
}
if( xDel==SQLITE_TRANSIENT ){
    
// ABS Label 275
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
i64 nAlloc = nByte;
    
// AOR Label 276
if(flags | 512 != flags & 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 276);
}
// AOR Label 277
if(flags ^ 512 != flags & 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 277);
}
if( flags&MEM_Term ){
      nAlloc += (enc==SQLITE_UTF8?1:2);
    }
    
// ABS Label 278
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}

// ROR Label 279
if((nByte <= iLimit) != (nByte > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((nByte < iLimit) != (nByte > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((nByte >= iLimit) != (nByte > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}
if( nByte>iLimit ){
      return sqlite3ErrorToParser(pMem->db, SQLITE_TOOBIG);
    }
    testcase( nAlloc==0 );
    testcase( nAlloc==31 );
    testcase( nAlloc==32 );
    if( sqlite3VdbeMemClearAndResize(pMem, (int)MAX(nAlloc,32)) ){
      return SQLITE_NOMEM_BKPT;
    }
    memcpy(pMem->z, z, nAlloc);
  }else{
    
// ABS Label 282
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 282);
}
sqlite3VdbeMemRelease(pMem);
    pMem->z = (char *)z;
    
// ABS Label 283
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((xDel != ((sqlite3_destructor_type)sqlite3OomFault)) != (xDel == ((sqlite3_destructor_type)sqlite3OomFault)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
if( xDel==SQLITE_DYNAMIC ){
      pMem->zMalloc = pMem->z;
      pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
    }else{
      pMem->xDel = xDel;
      flags |= ((xDel==SQLITE_STATIC)?MEM_Static:MEM_Dyn);
    }
  }

  pMem->n = (int)(nByte & 0x7fffffff);
  pMem->flags = flags;
  
// ABS Label 285
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}
if( enc ){
    pMem->enc = enc;
#ifdef SQLITE_ENABLE_SESSION
  }else if( pMem->db==0 ){
    pMem->enc = SQLITE_UTF8;
#endif
  }else{
    assert( pMem->db!=0 );
    pMem->enc = ENC(pMem->db);
  }

#ifndef SQLITE_OMIT_UTF16
  if( enc>SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem) ){
    return SQLITE_NOMEM_BKPT;
  }
#endif

  
// ABS Label 286
if(nByte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}

// ROR Label 287
if((nByte <= iLimit) != (nByte > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}
// ROR Label 288
if((nByte < iLimit) != (nByte > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 288);
}
// ROR Label 289
if((nByte >= iLimit) != (nByte > iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 289);
}
if( nByte>iLimit ){
    return sqlite3ErrorToParser(pMem->db, SQLITE_TOOBIG);
  }

  return SQLITE_OK;
}

/*
** Move data out of a btree key or data field and into a Mem structure.
** The data is payload from the entry that pCur is currently pointing
** to.  offset and amt determine what portion of the data or key to retrieve.
** The result is written into the pMem element.
**
** The pMem object must have been initialized.  This routine will use
** pMem->zMalloc to hold the content from the btree, if possible.  New
** pMem->zMalloc space will be allocated if necessary.  The calling routine
** is responsible for making sure that the pMem object is eventually
** destroyed.
**
** If this routine fails for any reason (malloc returns NULL or unable
** to read from the disk) then the pMem is left in an inconsistent state.
*/
int sqlite3VdbeMemFromBtree(
  BtCursor *pCur,   /* Cursor pointing at record to retrieve. */
  u32 offset,       /* Offset from the start of data to return bytes from. */
  u32 amt,          /* Number of bytes to return. */
  Mem *pMem         /* OUT: Return data in this Mem structure. */
){
  int rc;
  pMem->flags = MEM_Null;
  if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){
    return SQLITE_CORRUPT_BKPT;
  }
  if( SQLITE_OK==(rc = sqlite3VdbeMemClearAndResize(pMem, amt+1)) ){
    rc = sqlite3BtreePayload(pCur, offset, amt, pMem->z);
    
// ABS Label 290
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ROR Label 291
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 291);
}
if( rc==SQLITE_OK ){
      pMem->z[amt] = 0;   /* Overrun area used when reading malformed records */
      pMem->flags = MEM_Blob;
      pMem->n = (int)amt;
    }else{
      
// ABS Label 292
if(pMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}
sqlite3VdbeMemRelease(pMem);
    }
  }
  
// ABS Label 293
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
return rc;
}
int sqlite3VdbeMemFromBtreeZeroOffset(
  BtCursor *pCur,   /* Cursor pointing at record to retrieve. */
  u32 amt,          /* Number of bytes to return. */
  Mem *pMem         /* OUT: Return data in this Mem structure. */
){
  u32 available = 0;  /* Number of bytes available on the local btree page */
  int rc = SQLITE_OK; /* Return code */

  assert( sqlite3BtreeCursorIsValid(pCur) );
  assert( !VdbeMemDynamic(pMem) );

  /* Note: the calls to BtreeKeyFetch() and DataFetch() below assert() 
  ** that both the BtShared and database handle mutexes are held. */
  assert( !sqlite3VdbeMemIsRowSet(pMem) );
  pMem->z = (char *)sqlite3BtreePayloadFetch(pCur, &available);
  assert( pMem->z!=0 );

  
// ABS Label 294
if(amt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
// ABS Label 295
if(available < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}

// ROR Label 296
if((amt < available) != (amt <= available))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
// ROR Label 297
if((amt > available) != (amt <= available))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}
// ROR Label 298
if((amt >= available) != (amt <= available))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}
if( amt<=available ){
    pMem->flags = MEM_Blob|MEM_Ephem;
    pMem->n = (int)amt;
  }else{
    rc = sqlite3VdbeMemFromBtree(pCur, 0, amt, pMem);
  }

  
// ABS Label 299
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
return rc;
}

/*
** The pVal argument is known to be a value other than NULL.
** Convert it into a string with encoding enc and return a pointer
** to a zero-terminated version of that string.
*/
static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc){
  assert( pVal!=0 );
  assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );
  assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );
  assert( !sqlite3VdbeMemIsRowSet(pVal) );
  assert( (pVal->flags & (MEM_Null))==0 );
  
// AOR Label 300
if(pVal->flags | (16 | 2) != pVal->flags & (16 | 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 300);
}
// AOR Label 301
if(pVal->flags ^ (16 | 2) != pVal->flags & (16 | 2))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 301);
}
if( pVal->flags & (MEM_Blob|MEM_Str) ){
#ifdef MAGMA_ENABLE_FIXES
    if( ExpandBlob(pVal) ) return 0;
#endif
#ifdef MAGMA_ENABLE_CANARIES
    MAGMA_LOG("SQL009", ExpandBlob(pVal));
#endif
    pVal->flags |= MEM_Str;
    
// ROR Label 303
if((pVal->enc == (enc & ~8)) != (pVal->enc != (enc & ~8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 303);
}
if( pVal->enc != (enc & ~SQLITE_UTF16_ALIGNED) ){
      
// ABS Label 304
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}

// AOR Label 305
if(enc | ~8 != enc & ~8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 305);
}
// AOR Label 306
if(enc ^ ~8 != enc & ~8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 306);
}
sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);
    }
    
// COR Label 307
if(((enc & 8) != 0 || 1 == (1 & ((int)(long)(pVal->z)))) != ((enc & 8) != 0 && 1 == (1 & ((int)(long)(pVal->z)))))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 307);
}

// ROR Label 308
if(((enc & 8) == 0) != ((enc & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 308);
}
// ROR Label 309
if((1 != (1 & ((int)(long)(pVal->z)))) != (1 == (1 & ((int)(long)(pVal->z)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}

// MCC Label 310
if((enc & 8) != 0 && 1 == (1 & ((int)(long)(pVal->z))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 310);
}
// MCC Label 311
if((enc & 8) != 0 && !(1 == (1 & ((int)(long)(pVal->z)))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 311);
}
// MCC Label 312
if(!((enc & 8) != 0) && 1 == (1 & ((int)(long)(pVal->z))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 312);
}
// MCC Label 313
if(!((enc & 8) != 0) && !(1 == (1 & ((int)(long)(pVal->z)))) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 313);
}
if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){
      assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );
      if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){
        return 0;
      }
    }
    
// ABS Label 302
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}
sqlite3VdbeMemNulTerminate(pVal); /* IMP: R-31275-44060 */
  }else{
    
// ABS Label 314
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}

// ABS Label 315
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
sqlite3VdbeMemStringify(pVal, enc, 0);
    assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );
  }
  assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0
              || pVal->db->mallocFailed );
  
// ROR Label 316
if((pVal->enc != (enc & ~8)) != (pVal->enc == (enc & ~8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 316);
}
if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){
    assert( sqlite3VdbeMemValidStrRep(pVal) );
    return pVal->z;
  }else{
    return 0;
  }
}

/* This function is only available internally, it is not part of the
** external API. It works in a similar way to sqlite3_value_text(),
** except the data returned is in the encoding specified by the second
** parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or
** SQLITE_UTF8.
**
** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.
** If that is the case, then the result must be aligned on an even byte
** boundary.
*/
const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){
  if( !pVal ) { return 0;
}
  assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );
  assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );
  assert( !sqlite3VdbeMemIsRowSet(pVal) );
  
// COR Label 317
if(((pVal->flags & (2 | 512)) == (2 | 512) || pVal->enc == enc) != ((pVal->flags & (2 | 512)) == (2 | 512) && pVal->enc == enc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 317);
}

// ROR Label 318
if(((pVal->flags & (2 | 512)) != (2 | 512)) != ((pVal->flags & (2 | 512)) == (2 | 512)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 318);
}
// ROR Label 319
if((pVal->enc != enc) != (pVal->enc == enc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 319);
}

// MCC Label 320
if((pVal->flags & (2 | 512)) == (2 | 512) && pVal->enc == enc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 320);
}
// MCC Label 321
if((pVal->flags & (2 | 512)) == (2 | 512) && !(pVal->enc == enc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 321);
}
// MCC Label 322
if(!((pVal->flags & (2 | 512)) == (2 | 512)) && pVal->enc == enc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 322);
}
// MCC Label 323
if(!((pVal->flags & (2 | 512)) == (2 | 512)) && !(pVal->enc == enc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 323);
}
if( (pVal->flags&(MEM_Str|MEM_Term))==(MEM_Str|MEM_Term) && pVal->enc==enc ){
    assert( sqlite3VdbeMemValidStrRep(pVal) );
    return pVal->z;
  }
  
// AOR Label 324
if(pVal->flags | 1 != pVal->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 324);
}
// AOR Label 325
if(pVal->flags ^ 1 != pVal->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 325);
}
if( pVal->flags&MEM_Null ){
    return 0;
  }
  return valueToText(pVal, enc);
}

/*
** Create a new sqlite3_value object.
*/
sqlite3_value *sqlite3ValueNew(sqlite3 *db){
  Mem *p = sqlite3DbMallocZero(db, sizeof(*p));
  
// ABS Label 326
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
if( p ){
    p->flags = MEM_Null;
    p->db = db;
  }
  
// ABS Label 327
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
return p;
}

/*
** Context object passed by sqlite3Stat4ProbeSetValue() through to 
** valueNew(). See comments above valueNew() for details.
*/
struct ValueNewStat4Ctx {
  Parse *pParse;
  Index *pIdx;
  UnpackedRecord **ppRec;
  int iVal;
};

/*
** Allocate and return a pointer to a new sqlite3_value object. If
** the second argument to this function is NULL, the object is allocated
** by calling sqlite3ValueNew().
**
** Otherwise, if the second argument is non-zero, then this function is 
** being called indirectly by sqlite3Stat4ProbeSetValue(). If it has not
** already been allocated, allocate the UnpackedRecord structure that 
** that function will return to its caller here. Then return a pointer to
** an sqlite3_value within the UnpackedRecord.a[] array.
*/
static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
#ifdef SQLITE_ENABLE_STAT4
  if( p ){
    UnpackedRecord *pRec = p->ppRec[0];

    if( pRec==0 ){
      Index *pIdx = p->pIdx;      /* Index being probed */
      int nByte;                  /* Bytes of space to allocate */
      int i;                      /* Counter variable */
      int nCol = pIdx->nColumn;   /* Number of index columns including rowid */
  
      nByte = sizeof(Mem) * nCol + ROUND8(sizeof(UnpackedRecord));
      pRec = (UnpackedRecord*)sqlite3DbMallocZero(db, nByte);
      if( pRec ){
        pRec->pKeyInfo = sqlite3KeyInfoOfIndex(p->pParse, pIdx);
        if( pRec->pKeyInfo ){
          assert( pRec->pKeyInfo->nAllField==nCol );
          assert( pRec->pKeyInfo->enc==ENC(db) );
          pRec->aMem = (Mem *)((u8*)pRec + ROUND8(sizeof(UnpackedRecord)));
          for(i=0; i<nCol; i++){
            pRec->aMem[i].flags = MEM_Null;
            pRec->aMem[i].db = db;
          }
        }else{
          sqlite3DbFreeNN(db, pRec);
          pRec = 0;
        }
      }
      if( pRec==0 ) return 0;
      p->ppRec[0] = pRec;
    }
  
    pRec->nField = p->iVal+1;
    return &pRec->aMem[p->iVal];
  }
#else
  UNUSED_PARAMETER(p);
#endif /* defined(SQLITE_ENABLE_STAT4) */
  return sqlite3ValueNew(db);
}

/*
** The expression object indicated by the second argument is guaranteed
** to be a scalar SQL function. If
**
**   * all function arguments are SQL literals,
**   * one of the SQLITE_FUNC_CONSTANT or _SLOCHNG function flags is set, and
**   * the SQLITE_FUNC_NEEDCOLL function flag is not set,
**
** then this routine attempts to invoke the SQL function. Assuming no
** error occurs, output parameter (*ppVal) is set to point to a value 
** object containing the result before returning SQLITE_OK.
**
** Affinity aff is applied to the result of the function before returning.
** If the result is a text value, the sqlite3_value object uses encoding 
** enc.
**
** If the conditions above are not met, this function returns SQLITE_OK
** and sets (*ppVal) to NULL. Or, if an error occurs, (*ppVal) is set to
** NULL and an SQLite error code returned.
*/
#ifdef SQLITE_ENABLE_STAT4
static int valueFromFunction(
  sqlite3 *db,                    /* The database connection */
  Expr *p,                        /* The expression to evaluate */
  u8 enc,                         /* Encoding to use */
  u8 aff,                         /* Affinity to use */
  sqlite3_value **ppVal,          /* Write the new value here */
  struct ValueNewStat4Ctx *pCtx   /* Second argument for valueNew() */
){
  sqlite3_context ctx;            /* Context object for function invocation */
  sqlite3_value **apVal = 0;      /* Function arguments */
  int nVal = 0;                   /* Size of apVal[] array */
  FuncDef *pFunc = 0;             /* Function definition */
  sqlite3_value *pVal = 0;        /* New value */
  int rc = SQLITE_OK;             /* Return code */
  ExprList *pList = 0;            /* Function arguments */
  int i;                          /* Iterator variable */

  assert( pCtx!=0 );
  assert( (p->flags & EP_TokenOnly)==0 );
  pList = p->x.pList;
  if( pList ) nVal = pList->nExpr;
  pFunc = sqlite3FindFunction(db, p->u.zToken, nVal, enc, 0);
  assert( pFunc );
  if( (pFunc->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG))==0 
   || (pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)
  ){
    return SQLITE_OK;
  }

  if( pList ){
    apVal = (sqlite3_value**)sqlite3DbMallocZero(db, sizeof(apVal[0]) * nVal);
    if( apVal==0 ){
      rc = SQLITE_NOMEM_BKPT;
      goto value_from_function_out;
    }
    for(i=0; i<nVal; i++){
      rc = sqlite3ValueFromExpr(db, pList->a[i].pExpr, enc, aff, &apVal[i]);
      if( apVal[i]==0 || rc!=SQLITE_OK ) goto value_from_function_out;
    }
  }

  pVal = valueNew(db, pCtx);
  if( pVal==0 ){
    rc = SQLITE_NOMEM_BKPT;
    goto value_from_function_out;
  }

  assert( pCtx->pParse->rc==SQLITE_OK );
  memset(&ctx, 0, sizeof(ctx));
  ctx.pOut = pVal;
  ctx.pFunc = pFunc;
  pFunc->xSFunc(&ctx, nVal, apVal);
  if( ctx.isError ){
    rc = ctx.isError;
    sqlite3ErrorMsg(pCtx->pParse, "%s", sqlite3_value_text(pVal));
  }else{
    sqlite3ValueApplyAffinity(pVal, aff, SQLITE_UTF8);
    assert( rc==SQLITE_OK );
    rc = sqlite3VdbeChangeEncoding(pVal, enc);
    if( rc==SQLITE_OK && sqlite3VdbeMemTooBig(pVal) ){
      rc = SQLITE_TOOBIG;
      pCtx->pParse->nErr++;
    }
  }
  pCtx->pParse->rc = rc;

 value_from_function_out:
  if( rc!=SQLITE_OK ){
    pVal = 0;
  }
  if( apVal ){
    for(i=0; i<nVal; i++){
      sqlite3ValueFree(apVal[i]);
    }
    sqlite3DbFreeNN(db, apVal);
  }

  *ppVal = pVal;
  return rc;
}
#else
# define valueFromFunction(a,b,c,d,e,f) SQLITE_OK
#endif /* defined(SQLITE_ENABLE_STAT4) */

/*
** Extract a value from the supplied expression in the manner described
** above sqlite3ValueFromExpr(). Allocate the sqlite3_value object
** using valueNew().
**
** If pCtx is NULL and an error occurs after the sqlite3_value object
** has been allocated, it is freed before returning. Or, if pCtx is not
** NULL, it is assumed that the caller will free any allocated object
** in all cases.
*/
static int valueFromExpr(
  sqlite3 *db,                    /* The database connection */
  Expr *pExpr,                    /* The expression to evaluate */
  u8 enc,                         /* Encoding to use */
  u8 affinity,                    /* Affinity to use */
  sqlite3_value **ppVal,          /* Write the new value here */
  struct ValueNewStat4Ctx *pCtx   /* Second argument for valueNew() */
){
  int op;
  char *zVal = 0;
  sqlite3_value *pVal = 0;
  int negInt = 1;
  const char *zNeg = "";
  int rc = SQLITE_OK;

  assert( pExpr!=0 );
  while( (op = pExpr->op)==TK_UPLUS || op==TK_SPAN ) { pExpr = pExpr->pLeft;
};
#if defined(SQLITE_ENABLE_STAT4)
  if( op==TK_REGISTER ) op = pExpr->op2;
#else
  
// MCC Label 330
if(( op == 175 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 330);
}
// MCC Label 331
if(( !(op == 175) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 331);
}
if( NEVER(op==TK_REGISTER) ) { op = pExpr->op2;
}
#endif

  /* Compressed expressions only appear when parsing the DEFAULT clause
  ** on a table column definition, and hence only when pCtx==0.  This
  ** check ensures that an EP_TokenOnly expression is never passed down
  ** into valueFromFunction(). */
  assert( (pExpr->flags & EP_TokenOnly)==0 || pCtx==0 );

  
// ABS Label 332
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}

// ROR Label 333
if((op != 36) != (op == 36))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 333);
}
if( op==TK_CAST ){
    u8 aff = sqlite3AffinityType(pExpr->u.zToken,0);
    rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
    testcase( rc!=SQLITE_OK );
    
// ABS Label 334
if(*ppVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
if( *ppVal ){
      
// ABS Label 335
if(*ppVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}

// ABS Label 336
if(aff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}
sqlite3VdbeMemCast(*ppVal, aff, SQLITE_UTF8);
      
// ABS Label 337
if(*ppVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}

// ABS Label 338
if(affinity < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
sqlite3ValueApplyAffinity(*ppVal, affinity, SQLITE_UTF8);
    }
    
// ABS Label 339
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}
return rc;
  }

  /* Handle negative integers in a single step.  This is needed in the
  ** case when the value is -9223372036854775808.
  */
  
// ABS Label 340
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// COR Label 341
if((op == 172 || (pExpr->pLeft->op == 154 || pExpr->pLeft->op == 152)) != (op == 172 && (pExpr->pLeft->op == 154 || pExpr->pLeft->op == 152)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 341);
}

// ROR Label 342
if((op != 172) != (op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 342);
}

// MCC Label 343
if(op == 172 && ( pExpr->pLeft->op == 154 && pExpr->pLeft->op == 152 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 343);
}
// MCC Label 344
if(op == 172 && ( pExpr->pLeft->op == 154 && !(pExpr->pLeft->op == 152) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 344);
}
// MCC Label 345
if(op == 172 && ( !(pExpr->pLeft->op == 154) && pExpr->pLeft->op == 152 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 345);
}
// MCC Label 346
if(op == 172 && ( !(pExpr->pLeft->op == 154) && !(pExpr->pLeft->op == 152) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 346);
}
// MCC Label 347
if(!(op == 172) && ( pExpr->pLeft->op == 154 && pExpr->pLeft->op == 152 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 347);
}
// MCC Label 348
if(!(op == 172) && ( pExpr->pLeft->op == 154 && !(pExpr->pLeft->op == 152) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 348);
}
// MCC Label 349
if(!(op == 172) && ( !(pExpr->pLeft->op == 154) && pExpr->pLeft->op == 152 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 349);
}
// MCC Label 350
if(!(op == 172) && ( !(pExpr->pLeft->op == 154) && !(pExpr->pLeft->op == 152) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
if( op==TK_UMINUS
   && (pExpr->pLeft->op==TK_INTEGER || pExpr->pLeft->op==TK_FLOAT) ){
    pExpr = pExpr->pLeft;
    op = pExpr->op;
    negInt = -1;
    zNeg = "-";
  }

  
// ABS Label 351
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 351);
}

// COR Label 352
if((op == 116 || op == 152 && op == 154) != (op == 116 || op == 152 || op == 154))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 352);
}
// COR Label 353
if((op == 116 && op == 152) != (op == 116 || op == 152))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 353);
}

// ROR Label 354
if((op != 116) != (op == 116))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 354);
}
// ROR Label 355
if((op != 152) != (op == 152))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 355);
}
// ROR Label 356
if((op != 154) != (op == 154))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 356);
}

// MCC Label 357
if(op == 116 && op == 152 && op == 154 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 357);
}
// MCC Label 358
if(op == 116 && op == 152 && !(op == 154) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 358);
}
// MCC Label 359
if(op == 116 && !(op == 152) && op == 154 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 359);
}
// MCC Label 360
if(op == 116 && !(op == 152) && !(op == 154) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 360);
}
// MCC Label 361
if(!(op == 116) && op == 152 && op == 154 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 361);
}
// MCC Label 362
if(!(op == 116) && op == 152 && !(op == 154) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 362);
}
// MCC Label 363
if(!(op == 116) && !(op == 152) && op == 154 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 363);
}
// MCC Label 364
if(!(op == 116) && !(op == 152) && !(op == 154) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 364);
}
if( op==TK_STRING || op==TK_FLOAT || op==TK_INTEGER ){
    pVal = valueNew(db, pCtx);
    
// ABS Label 365
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 365);
}

// ROR Label 366
if((pVal != 0) != (pVal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 366);
}
if( pVal==0 ) { goto no_mem;
}
    
// MCC Label 367
if(( ((pExpr)->flags & (1024)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 367);
}
// MCC Label 368
if(( !(((pExpr)->flags & (1024)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
if( ExprHasProperty(pExpr, EP_IntValue) ){
      
// ABS Label 369
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 369);
}

// AOR Label 370
if((i64)pExpr->u.iValue - negInt != (i64)pExpr->u.iValue * negInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 370);
}
// AOR Label 371
if((i64)pExpr->u.iValue + negInt != (i64)pExpr->u.iValue * negInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 371);
}
// AOR Label 372
if((i64)pExpr->u.iValue / negInt != (i64)pExpr->u.iValue * negInt)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 372);
}
sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);
    }else{
      zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
      
// ABS Label 374
if(zVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}

// ROR Label 375
if((zVal != 0) != (zVal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 375);
}
if( zVal==0 ) { goto no_mem;
}
      
// ABS Label 373
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}
sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);
    }
    
// COR Label 376
if(((op == 154 || op == 152) || affinity == 65) != ((op == 154 || op == 152) && affinity == 65))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 376);
}

// ROR Label 377
if((affinity != 65) != (affinity == 65))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}

// MCC Label 378
if(( op == 154 && op == 152 ) && affinity == 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 378);
}
// MCC Label 379
if(( op == 154 && op == 152 ) && !(affinity == 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 379);
}
// MCC Label 380
if(( op == 154 && !(op == 152) ) && affinity == 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 380);
}
// MCC Label 381
if(( op == 154 && !(op == 152) ) && !(affinity == 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 381);
}
// MCC Label 382
if(( !(op == 154) && op == 152 ) && affinity == 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 382);
}
// MCC Label 383
if(( !(op == 154) && op == 152 ) && !(affinity == 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 383);
}
// MCC Label 384
if(( !(op == 154) && !(op == 152) ) && affinity == 65 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 384);
}
// MCC Label 385
if(( !(op == 154) && !(op == 152) ) && !(affinity == 65) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 385);
}
if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_BLOB ){
      
// ABS Label 386
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 386);
}
sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);
    }else{
      
// ABS Label 387
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// ABS Label 388
if(affinity < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 388);
}
sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);
    }
    assert( (pVal->flags & MEM_IntReal)==0 );
    
// AOR Label 389
if(pVal->flags | (4 | 32 | 8) != pVal->flags & (4 | 32 | 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 389);
}
// AOR Label 390
if(pVal->flags ^ (4 | 32 | 8) != pVal->flags & (4 | 32 | 8))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 390);
}
if( pVal->flags & (MEM_Int|MEM_IntReal|MEM_Real) ){
      testcase( pVal->flags & MEM_Int );
      testcase( pVal->flags & MEM_Real );
      pVal->flags &= ~MEM_Str;
    }
    
// ROR Label 391
if((enc == 1) != (enc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}
if( enc!=SQLITE_UTF8 ){
      rc = sqlite3VdbeChangeEncoding(pVal, enc);
    }
  }else { 
// ABS Label 392
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

// ROR Label 393
if((op != 172) != (op == 172))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 393);
}
if( op==TK_UMINUS ) {
    /* This branch happens for multiple negative signs.  Ex: -(-5) */
    if( SQLITE_OK==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx) 
     && pVal!=0
    ){
      
// ABS Label 394
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}
sqlite3VdbeMemNumerify(pVal);
      
// AOR Label 398
if(pVal->flags | 8 != pVal->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 398);
}
// AOR Label 399
if(pVal->flags ^ 8 != pVal->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 399);
}
if( pVal->flags & MEM_Real ){
        pVal->u.r = -pVal->u.r;
      }else { 
// ABS Label 400
if(pVal->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 400);
}

// ROR Label 401
if((pVal->u.i != (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))) != (pVal->u.i == (((i64)-1) - (4294967295U | (((i64)2147483647) << 32)))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 401);
}
if( pVal->u.i==SMALLEST_INT64 ){
#ifndef SQLITE_OMIT_FLOATING_POINT
        pVal->u.r = -(double)SMALLEST_INT64;
#else
        pVal->u.r = LARGEST_INT64;
#endif
        MemSetTypeFlag(pVal, MEM_Real);
      }else{
        pVal->u.i = -pVal->u.i;
      };}

      
// ABS Label 395
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 395);
}

// ABS Label 396
if(affinity < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 396);
}

// ABS Label 397
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
sqlite3ValueApplyAffinity(pVal, affinity, enc);
    }
  }else { 
// ABS Label 402
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 402);
}

// ROR Label 403
if((op != 120) != (op == 120))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
if( op==TK_NULL ){
    pVal = valueNew(db, pCtx);
    
// ABS Label 405
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}

// ROR Label 406
if((pVal != 0) != (pVal == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 406);
}
if( pVal==0 ) { goto no_mem;
}
    
// ABS Label 404
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}
sqlite3VdbeMemSetNull(pVal);
  }
#ifndef SQLITE_OMIT_BLOB_LITERAL
  else { 
// ABS Label 407
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}

// ROR Label 408
if((op != 153) != (op == 153))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 408);
}
if( op==TK_BLOB ){
    int nVal;
    assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );
    assert( pExpr->u.zToken[1]=='\'' );
    pVal = valueNew(db, pCtx);
    if( !pVal ) { goto no_mem;
}
    zVal = &pExpr->u.zToken[2];
    nVal = sqlite3Strlen30(zVal)-1;
    assert( zVal[nVal]=='\'' );
    
// ABS Label 409
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}
sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,
                         0, SQLITE_DYNAMIC);
  }
#endif
#ifdef SQLITE_ENABLE_STAT4
  else if( op==TK_FUNCTION && pCtx!=0 ){
    rc = valueFromFunction(db, pExpr, enc, affinity, &pVal, pCtx);
  }
#endif
  else { 
// ABS Label 410
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ROR Label 411
if((op != 169) != (op == 169))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 411);
}
if( op==TK_TRUEFALSE ){
    pVal = valueNew(db, pCtx);
    
// ABS Label 412
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}
if( pVal ){
      pVal->flags = MEM_Int;
      pVal->u.i = pExpr->u.zToken[4]==0;
    }
  };}
;}
;}
;}


  *ppVal = pVal;
  
// ABS Label 413
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
return rc;

no_mem:
#ifdef SQLITE_ENABLE_STAT4
  if( pCtx==0 || pCtx->pParse->nErr==0 )
#endif
    sqlite3OomFault(db);
  
// ABS Label 328
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}
sqlite3DbFree(db, zVal);
  assert( *ppVal==0 );
#ifdef SQLITE_ENABLE_STAT4
  if( pCtx==0 ) sqlite3ValueFree(pVal);
#else
  assert( pCtx==0 ); 
// ABS Label 329
if(pVal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
sqlite3ValueFree(pVal);
#endif
  return SQLITE_NOMEM_BKPT;
}

/*
** Create a new sqlite3_value object, containing the value of pExpr.
**
** This only works for very simple expressions that consist of one constant
** token (i.e. "5", "5.1", "'a string'"). If the expression can
** be converted directly into a value, then the value is allocated and
** a pointer written to *ppVal. The caller is responsible for deallocating
** the value by passing it to sqlite3ValueFree() later on. If the expression
** cannot be converted to a value, then *ppVal is set to NULL.
*/
int sqlite3ValueFromExpr(
  sqlite3 *db,              /* The database connection */
  Expr *pExpr,              /* The expression to evaluate */
  u8 enc,                   /* Encoding to use */
  u8 affinity,              /* Affinity to use */
  sqlite3_value **ppVal     /* Write the new value here */
){
  return pExpr ? valueFromExpr(db, pExpr, enc, affinity, ppVal, 0) : 0;
}

#ifdef SQLITE_ENABLE_STAT4
/*
** Attempt to extract a value from pExpr and use it to construct *ppVal.
**
** If pAlloc is not NULL, then an UnpackedRecord object is created for
** pAlloc if one does not exist and the new value is added to the
** UnpackedRecord object.
**
** A value is extracted in the following cases:
**
**  * (pExpr==0). In this case the value is assumed to be an SQL NULL,
**
**  * The expression is a bound variable, and this is a reprepare, or
**
**  * The expression is a literal value.
**
** On success, *ppVal is made to point to the extracted value.  The caller
** is responsible for ensuring that the value is eventually freed.
*/
static int stat4ValueFromExpr(
  Parse *pParse,                  /* Parse context */
  Expr *pExpr,                    /* The expression to extract a value from */
  u8 affinity,                    /* Affinity to use */
  struct ValueNewStat4Ctx *pAlloc,/* How to allocate space.  Or NULL */
  sqlite3_value **ppVal           /* OUT: New value object (or NULL) */
){
  int rc = SQLITE_OK;
  sqlite3_value *pVal = 0;
  sqlite3 *db = pParse->db;

  /* Skip over any TK_COLLATE nodes */
  pExpr = sqlite3ExprSkipCollate(pExpr);

  assert( pExpr==0 || pExpr->op!=TK_REGISTER || pExpr->op2!=TK_VARIABLE );
  if( !pExpr ){
    pVal = valueNew(db, pAlloc);
    if( pVal ){
      sqlite3VdbeMemSetNull((Mem*)pVal);
    }
  }else if( pExpr->op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){
    Vdbe *v;
    int iBindVar = pExpr->iColumn;
    sqlite3VdbeSetVarmask(pParse->pVdbe, iBindVar);
    if( (v = pParse->pReprepare)!=0 ){
      pVal = valueNew(db, pAlloc);
      if( pVal ){
        rc = sqlite3VdbeMemCopy((Mem*)pVal, &v->aVar[iBindVar-1]);
        sqlite3ValueApplyAffinity(pVal, affinity, ENC(db));
        pVal->db = pParse->db;
      }
    }
  }else{
    rc = valueFromExpr(db, pExpr, ENC(db), affinity, &pVal, pAlloc);
  }

  assert( pVal==0 || pVal->db==db );
  *ppVal = pVal;
  return rc;
}

/*
** This function is used to allocate and populate UnpackedRecord 
** structures intended to be compared against sample index keys stored 
** in the sqlite_stat4 table.
**
** A single call to this function populates zero or more fields of the
** record starting with field iVal (fields are numbered from left to
** right starting with 0). A single field is populated if:
**
**  * (pExpr==0). In this case the value is assumed to be an SQL NULL,
**
**  * The expression is a bound variable, and this is a reprepare, or
**
**  * The sqlite3ValueFromExpr() function is able to extract a value 
**    from the expression (i.e. the expression is a literal value).
**
** Or, if pExpr is a TK_VECTOR, one field is populated for each of the
** vector components that match either of the two latter criteria listed
** above.
**
** Before any value is appended to the record, the affinity of the 
** corresponding column within index pIdx is applied to it. Before
** this function returns, output parameter *pnExtract is set to the
** number of values appended to the record.
**
** When this function is called, *ppRec must either point to an object
** allocated by an earlier call to this function, or must be NULL. If it
** is NULL and a value can be successfully extracted, a new UnpackedRecord
** is allocated (and *ppRec set to point to it) before returning.
**
** Unless an error is encountered, SQLITE_OK is returned. It is not an
** error if a value cannot be extracted from pExpr. If an error does
** occur, an SQLite error code is returned.
*/
int sqlite3Stat4ProbeSetValue(
  Parse *pParse,                  /* Parse context */
  Index *pIdx,                    /* Index being probed */
  UnpackedRecord **ppRec,         /* IN/OUT: Probe record */
  Expr *pExpr,                    /* The expression to extract a value from */
  int nElem,                      /* Maximum number of values to append */
  int iVal,                       /* Array element to populate */
  int *pnExtract                  /* OUT: Values appended to the record */
){
  int rc = SQLITE_OK;
  int nExtract = 0;

  if( pExpr==0 || pExpr->op!=TK_SELECT ){
    int i;
    struct ValueNewStat4Ctx alloc;

    alloc.pParse = pParse;
    alloc.pIdx = pIdx;
    alloc.ppRec = ppRec;

    for(i=0; i<nElem; i++){
      sqlite3_value *pVal = 0;
      Expr *pElem = (pExpr ? sqlite3VectorFieldSubexpr(pExpr, i) : 0);
      u8 aff = sqlite3IndexColumnAffinity(pParse->db, pIdx, iVal+i);
      alloc.iVal = iVal+i;
      rc = stat4ValueFromExpr(pParse, pElem, aff, &alloc, &pVal);
      if( !pVal ) break;
      nExtract++;
    }
  }

  *pnExtract = nExtract;
  return rc;
}

/*
** Attempt to extract a value from expression pExpr using the methods
** as described for sqlite3Stat4ProbeSetValue() above. 
**
** If successful, set *ppVal to point to a new value object and return 
** SQLITE_OK. If no value can be extracted, but no other error occurs
** (e.g. OOM), return SQLITE_OK and set *ppVal to NULL. Or, if an error
** does occur, return an SQLite error code. The final value of *ppVal
** is undefined in this case.
*/
int sqlite3Stat4ValueFromExpr(
  Parse *pParse,                  /* Parse context */
  Expr *pExpr,                    /* The expression to extract a value from */
  u8 affinity,                    /* Affinity to use */
  sqlite3_value **ppVal           /* OUT: New value object (or NULL) */
){
  return stat4ValueFromExpr(pParse, pExpr, affinity, 0, ppVal);
}

/*
** Extract the iCol-th column from the nRec-byte record in pRec.  Write
** the column value into *ppVal.  If *ppVal is initially NULL then a new
** sqlite3_value object is allocated.
**
** If *ppVal is initially NULL then the caller is responsible for 
** ensuring that the value written into *ppVal is eventually freed.
*/
int sqlite3Stat4Column(
  sqlite3 *db,                    /* Database handle */
  const void *pRec,               /* Pointer to buffer containing record */
  int nRec,                       /* Size of buffer pRec in bytes */
  int iCol,                       /* Column to extract */
  sqlite3_value **ppVal           /* OUT: Extracted value */
){
  u32 t = 0;                      /* a column type code */
  int nHdr;                       /* Size of the header in the record */
  int iHdr;                       /* Next unread header byte */
  int iField;                     /* Next unread data byte */
  int szField = 0;                /* Size of the current data field */
  int i;                          /* Column index */
  u8 *a = (u8*)pRec;              /* Typecast byte array */
  Mem *pMem = *ppVal;             /* Write result into this Mem object */

  assert( iCol>0 );
  iHdr = getVarint32(a, nHdr);
  if( nHdr>nRec || iHdr>=nHdr ) return SQLITE_CORRUPT_BKPT;
  iField = nHdr;
  for(i=0; i<=iCol; i++){
    iHdr += getVarint32(&a[iHdr], t);
    testcase( iHdr==nHdr );
    testcase( iHdr==nHdr+1 );
    if( iHdr>nHdr ) return SQLITE_CORRUPT_BKPT;
    szField = sqlite3VdbeSerialTypeLen(t);
    iField += szField;
  }
  testcase( iField==nRec );
  testcase( iField==nRec+1 );
  if( iField>nRec ) return SQLITE_CORRUPT_BKPT;
  if( pMem==0 ){
    pMem = *ppVal = sqlite3ValueNew(db);
    if( pMem==0 ) return SQLITE_NOMEM_BKPT;
  }
  sqlite3VdbeSerialGet(&a[iField-szField], t, pMem);
  pMem->enc = ENC(db);
  return SQLITE_OK;
}

/*
** Unless it is NULL, the argument must be an UnpackedRecord object returned
** by an earlier call to sqlite3Stat4ProbeSetValue(). This call deletes
** the object.
*/
void sqlite3Stat4ProbeFree(UnpackedRecord *pRec){
  if( pRec ){
    int i;
    int nCol = pRec->pKeyInfo->nAllField;
    Mem *aMem = pRec->aMem;
    sqlite3 *db = aMem[0].db;
    for(i=0; i<nCol; i++){
      sqlite3VdbeMemRelease(&aMem[i]);
    }
    sqlite3KeyInfoUnref(pRec->pKeyInfo);
    sqlite3DbFreeNN(db, pRec);
  }
}
#endif /* ifdef SQLITE_ENABLE_STAT4 */

/*
** Change the string value of an sqlite3_value object
*/
void sqlite3ValueSetStr(
  sqlite3_value *v,     /* Value to be set */
  int n,                /* Length of string z */
  const void *z,        /* Text of the new string */
  u8 enc,               /* Encoding to use */
  void (*xDel)(void*)   /* Destructor for the string */
){
  
// ABS Label 414
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}
if( v ) { 
// ABS Label 415
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}

// ABS Label 416
if(xDel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
}
}

/*
** Free an sqlite3_value object
*/
void sqlite3ValueFree(sqlite3_value *v){
  if( !v ) { return;
}
  sqlite3VdbeMemRelease((Mem *)v);
  
// ABS Label 417
if(((Mem *)v)->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
sqlite3DbFreeNN(((Mem*)v)->db, v);
}

/*
** The sqlite3ValueBytes() routine returns the number of bytes in the
** sqlite3_value object assuming that it uses the encoding "enc".
** The valueBytes() routine is a helper function.
*/
static SQLITE_NOINLINE int valueBytes(sqlite3_value *pVal, u8 enc){
  return valueToText(pVal, enc)!=0 ? pVal->n : 0;
}
int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){
  Mem *p = (Mem*)pVal;
  assert( (p->flags & MEM_Null)==0 || (p->flags & (MEM_Str|MEM_Blob))==0 );
  
// COR Label 418
if(((p->flags & 2) != 0 || pVal->enc == enc) != ((p->flags & 2) != 0 && pVal->enc == enc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 418);
}

// ROR Label 419
if(((p->flags & 2) == 0) != ((p->flags & 2) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}
// ROR Label 420
if((pVal->enc != enc) != (pVal->enc == enc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}

// MCC Label 421
if((p->flags & 2) != 0 && pVal->enc == enc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 421);
}
// MCC Label 422
if((p->flags & 2) != 0 && !(pVal->enc == enc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 422);
}
// MCC Label 423
if(!((p->flags & 2) != 0) && pVal->enc == enc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 423);
}
// MCC Label 424
if(!((p->flags & 2) != 0) && !(pVal->enc == enc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 424);
}
if( (p->flags & MEM_Str)!=0 && pVal->enc==enc ){
    
// ABS Label 425
if(p->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}
return p->n;
  }
  
// ROR Label 426
if(((p->flags & 16) == 0) != ((p->flags & 16) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 426);
}
if( (p->flags & MEM_Blob)!=0 ){
    
// AOR Label 427
if(p->flags | 16384 != p->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 427);
}
// AOR Label 428
if(p->flags ^ 16384 != p->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 428);
}
if( p->flags & MEM_Zero ){
      
// ABS Label 429
if(p->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}
// ABS Label 430
if(p->u.nZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}

// AOR Label 431
if(p->n - p->u.nZero != p->n + p->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 431);
}
// AOR Label 432
if(p->n / p->u.nZero != p->n + p->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 432);
}
// AOR Label 433
if(p->n * p->u.nZero != p->n + p->u.nZero)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 433);
}
return p->n + p->u.nZero;
    }else{
      
// ABS Label 434
if(p->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}
return p->n;
    }
  }
  
// AOR Label 435
if(p->flags | 1 != p->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 435);
}
// AOR Label 436
if(p->flags ^ 1 != p->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 436);
}
if( p->flags & MEM_Null ) { return 0;
}
  return valueBytes(pVal, enc);
}
