/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2008 August 16
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains routines used for walking the parser tree for
** an SQL statement.
*/
#include "sqliteInt.h"
#include <stdlib.h>
#include <string.h>


#if !defined(SQLITE_OMIT_WINDOWFUNC)
/*
** Walk all expressions linked into the list of Window objects passed
** as the second argument.
*/
static int walkWindowList(Walker *pWalker, Window *pList, int bOneOnly){
  Window *pWin;
  pWin = pList;

// ABS Label 7
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
for(; pWin; pWin=pWin->pNextWin){
    int rc;
    rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);
    
// ABS Label 9
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
if( rc ) { return WRC_Abort;
}
    rc = sqlite3WalkExprList(pWalker, pWin->pPartition);
    
// ABS Label 10
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}
if( rc ) { return WRC_Abort;
}
    rc = sqlite3WalkExpr(pWalker, pWin->pFilter);
    
// ABS Label 11
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
if( rc ) { return WRC_Abort;
}
    rc = sqlite3WalkExpr(pWalker, pWin->pStart);
    
// ABS Label 12
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
if( rc ) { return WRC_Abort;
}
    rc = sqlite3WalkExpr(pWalker, pWin->pEnd);
    
// ABS Label 13
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
if( rc ) { return WRC_Abort;
}
    
// ABS Label 14
if(bOneOnly < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
if( bOneOnly ) { break;
}
  };
// ABS Label 8
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

  return WRC_Continue;
}
#endif

/*
** Walk an expression tree.  Invoke the callback once for each node
** of the expression, while descending.  (In other words, the callback
** is invoked before visiting children.)
**
** The return value from the callback should be one of the WRC_*
** constants to specify how to proceed with the walk.
**
**    WRC_Continue      Continue descending down the tree.
**
**    WRC_Prune         Do not descend into child nodes, but allow
**                      the walk to continue with sibling nodes.
**
**    WRC_Abort         Do no more callbacks.  Unwind the stack and
**                      return from the top-level walk call.
**
** The return value from this routine is WRC_Abort to abandon the tree walk
** and WRC_Continue to continue.
*/
static SQLITE_NOINLINE int walkExpr(Walker *pWalker, Expr *pExpr){
  int rc;
  testcase( ExprHasProperty(pExpr, EP_TokenOnly) );
  testcase( ExprHasProperty(pExpr, EP_Reduced) );
  while(1){
    rc = pWalker->xExprCallback(pWalker, pExpr);
    
// ABS Label 15
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
if( rc ) { 
// ABS Label 16
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// AOR Label 17
if(rc | 2 != rc & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 17);
}
// AOR Label 18
if(rc ^ 2 != rc & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 18);
}
return rc & WRC_Abort;
}
    if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){
      assert( pExpr->x.pList==0 || pExpr->pRight==0 );
      if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) { return WRC_Abort;
}
      
// ABS Label 19
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
if( pExpr->pRight ){
        assert( !ExprHasProperty(pExpr, EP_WinFunc) );
        pExpr = pExpr->pRight;
        continue;
      }else { 
// MCC Label 20
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 20);
}
// MCC Label 21
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 21);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
        assert( !ExprHasProperty(pExpr, EP_WinFunc) );
        if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) { return WRC_Abort;
}
      }else{
        
// ABS Label 22
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
if( pExpr->x.pList ){
          if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) { return WRC_Abort;
}
        }
#ifndef SQLITE_OMIT_WINDOWFUNC
        
// MCC Label 23
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 23);
}
// MCC Label 24
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 24);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
          if( walkWindowList(pWalker, pExpr->y.pWin, 1) ) { return WRC_Abort;
}
        }
#endif
      };}

    }
    break;
  };
  return WRC_Continue;
}
int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){
  return pExpr ? walkExpr(pWalker,pExpr) : WRC_Continue;
}

/*
** Call sqlite3WalkExpr() for every expression in list p or until
** an abort request is seen.
*/
int sqlite3WalkExprList(Walker *pWalker, ExprList *p){
  int i;
  struct ExprList_item *pItem;
  
// ABS Label 25
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
if( p ){
    i = p->nExpr , pItem = p->a;

// ABS Label 26
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// ROR Label 27
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
// ROR Label 28
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
for(; i>0; i--, pItem++){
      if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) { return WRC_Abort;
}
    };
// ABS Label 30
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// ROR Label 31
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}

  }
  return WRC_Continue;
}

/*
** This is a no-op callback for Walker->xSelectCallback2.  If this
** callback is set, then the Select->pWinDefn list is traversed.
*/
void sqlite3WalkWinDefnDummyCallback(Walker *pWalker, Select *p){
  UNUSED_PARAMETER(pWalker);
  UNUSED_PARAMETER(p);
  /* No-op */
}

/*
** Walk all expressions associated with SELECT statement p.  Do
** not invoke the SELECT callback on p, but do (of course) invoke
** any expr callbacks and SELECT callbacks that come from subqueries.
** Return WRC_Abort or WRC_Continue.
*/
int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){
  if( sqlite3WalkExprList(pWalker, p->pEList) ) { return WRC_Abort;
}
  if( sqlite3WalkExpr(pWalker, p->pWhere) ) { return WRC_Abort;
}
  if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) { return WRC_Abort;
}
  if( sqlite3WalkExpr(pWalker, p->pHaving) ) { return WRC_Abort;
}
  if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) { return WRC_Abort;
}
  if( sqlite3WalkExpr(pWalker, p->pLimit) ) { return WRC_Abort;
}
#if !defined(SQLITE_OMIT_WINDOWFUNC)
  
// ABS Label 34
if(p->pWinDefn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
if( p->pWinDefn ){
    Parse *pParse;
    if( pWalker->xSelectCallback2==sqlite3WalkWinDefnDummyCallback
     || ((pParse = pWalker->pParse)!=0 && IN_RENAME_OBJECT)
#ifndef SQLITE_OMIT_CTE
     || pWalker->xSelectCallback2==sqlite3SelectPopWith
#endif
    ){
      /* The following may return WRC_Abort if there are unresolvable
      ** symbols (e.g. a table that does not exist) in a window definition. */
      int rc = walkWindowList(pWalker, p->pWinDefn, 0);
      
// ABS Label 35
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}
return rc;
    }
  }
#endif
  return WRC_Continue;
}

/*
** Walk the parse trees associated with all subqueries in the
** FROM clause of SELECT statement p.  Do not invoke the select
** callback on p, but do invoke it on each FROM clause subquery
** and on any subqueries further down in the tree.  Return 
** WRC_Abort or WRC_Continue;
*/
int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
  SrcList *pSrc;
  int i;
  SrcItem *pItem;

  pSrc = p->pSrc;
  
// ABS Label 36
if((pSrc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 36);
}
if( ALWAYS(pSrc) ){
    i = pSrc->nSrc , pItem = pSrc->a;

// ABS Label 37
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}

// ROR Label 38
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
// ROR Label 39
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 39);
}
// ROR Label 40
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
for(; i>0; i--, pItem++){
      if( pItem->pSelect && sqlite3WalkSelect(pWalker, pItem->pSelect) ){
        return WRC_Abort;
      }
      if( pItem->fg.isTabFunc
       && sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg)
      ){
        return WRC_Abort;
      }
    };
// ABS Label 41
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// ROR Label 42
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 42);
}
// ROR Label 43
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 43);
}
// ROR Label 44
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 44);
}

  }
  return WRC_Continue;
}

/*
** Call sqlite3WalkExpr() for every expression in Select statement p.
** Invoke sqlite3WalkSelect() for subqueries in the FROM clause and
** on the compound select chain, p->pPrior. 
**
** If it is not NULL, the xSelectCallback() callback is invoked before
** the walk of the expressions and FROM clause. The xSelectCallback2()
** method is invoked following the walk of the expressions and FROM clause,
** but only if both xSelectCallback and xSelectCallback2 are both non-NULL
** and if the expressions and FROM clause both return WRC_Continue;
**
** Return WRC_Continue under normal conditions.  Return WRC_Abort if
** there is an abort request.
**
** If the Walker does not have an xSelectCallback() then this routine
** is a no-op returning WRC_Continue.
*/
int sqlite3WalkSelect(Walker *pWalker, Select *p){
  int rc;
  
// ABS Label 45
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// ROR Label 46
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 46);
}
if( p==0 ) { return WRC_Continue;
}
  
// ABS Label 47
if(pWalker->xSelectCallback < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}

// ROR Label 48
if((pWalker->xSelectCallback != 0) != (pWalker->xSelectCallback == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
if( pWalker->xSelectCallback==0 ) { return WRC_Continue;
}
  
// ABS Label 49
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}

// ROR Label 50
if((p == 0) != (p != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
do{
    rc = pWalker->xSelectCallback(pWalker, p);
    
// ABS Label 53
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
if( rc ) { 
// ABS Label 54
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// AOR Label 55
if(rc | 2 != rc & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 55);
}
// AOR Label 56
if(rc ^ 2 != rc & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 56);
}
return rc & WRC_Abort;
}
    if( sqlite3WalkSelectExpr(pWalker, p)
     || sqlite3WalkSelectFrom(pWalker, p)
    ){
      return WRC_Abort;
    }
    
// ABS Label 57
if(pWalker->xSelectCallback2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 57);
}
if( pWalker->xSelectCallback2 ){
      
// ABS Label 58
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}

// ABS Label 59
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
pWalker->xSelectCallback2(pWalker, p);
    }
    p = p->pPrior;
  }while( p!=0 );
// ABS Label 51
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

// ROR Label 52
if((p == 0) != (p != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}
;
  return WRC_Continue;
}

/* Increase the walkerDepth when entering a subquery, and
** descrease when leaving the subquery.
*/
int sqlite3WalkerDepthIncrease(Walker *pWalker, Select *pSelect){
  UNUSED_PARAMETER(pSelect);
  pWalker->walkerDepth++;
  return WRC_Continue;
}
void sqlite3WalkerDepthDecrease(Walker *pWalker, Select *pSelect){
  UNUSED_PARAMETER(pSelect);
  pWalker->walkerDepth--;
}


/*
** No-op routine for the parse-tree walker.
**
** When this routine is the Walker.xExprCallback then expression trees
** are walked without any actions being taken at each node.  Presumably,
** when this routine is used for Walker.xExprCallback then 
** Walker.xSelectCallback is set to do something useful for every 
** subquery in the parser tree.
*/
int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  return WRC_Continue;
}

/*
** No-op routine for the parse-tree walker for SELECT statements.
** subquery in the parser tree.
*/
int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  return WRC_Continue;
}
