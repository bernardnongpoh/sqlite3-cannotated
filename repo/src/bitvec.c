/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2008 February 16
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file implements an object that represents a fixed-length
** bitmap.  Bits are numbered starting with 1.
**
** A bitmap is used to record which pages of a database file have been
** journalled during a transaction, or which pages have the "dont-write"
** property.  Usually only a few pages are meet either condition.
** So the bitmap is usually sparse and has low cardinality.
** But sometimes (for example when during a DROP of a large table) most
** or all of the pages in a database can get journalled.  In those cases, 
** the bitmap becomes dense with high cardinality.  The algorithm needs 
** to handle both cases well.
**
** The size of the bitmap is fixed when the object is created.
**
** All bits are clear when the bitmap is created.  Individual bits
** may be set or cleared one at a time.
**
** Test operations are about 100 times more common that set operations.
** Clear operations are exceedingly rare.  There are usually between
** 5 and 500 set operations per Bitvec object, though the number of sets can
** sometimes grow into tens of thousands or larger.  The size of the
** Bitvec object is the number of pages in the database file at the
** start of a transaction, and is thus usually less than a few thousand,
** but can be as large as 2 billion for a really big database.
*/
#include "sqliteInt.h"

/* Size of the Bitvec structure in bytes. */
#define BITVEC_SZ        512

/* Round the union size down to the nearest pointer boundary, since that's how 
** it will be aligned within the Bitvec struct. */
#define BITVEC_USIZE \
    (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))

/* Type of the array "element" for the bitmap representation. 
** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE. 
** Setting this to the "natural word" size of your CPU may improve
** performance. */
#define BITVEC_TELEM     u8
/* Size, in bits, of the bitmap element. */
#define BITVEC_SZELEM    8
/* Number of elements in a bitmap array. */
#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))
/* Number of bits in the bitmap array. */
#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM)

/* Number of u32 values in hash table. */
#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))
/* Maximum number of entries in hash table before 
** sub-dividing and re-hashing. */
#define BITVEC_MXHASH    (BITVEC_NINT/2)
/* Hashing function for the aHash representation.
** Empirical testing showed that the *37 multiplier 
** (an arbitrary prime)in the hash function provided 
** no fewer collisions than the no-op *1. */
#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT)

#define BITVEC_NPTR      (BITVEC_USIZE/sizeof(Bitvec *))


/*
** A bitmap is an instance of the following structure.
**
** This bitmap records the existence of zero or more bits
** with values between 1 and iSize, inclusive.
**
** There are three possible representations of the bitmap.
** If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight
** bitmap.  The least significant bit is bit 1.
**
** If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is
** a hash table that will hold up to BITVEC_MXHASH distinct values.
**
** Otherwise, the value i is redirected into one of BITVEC_NPTR
** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap
** handles up to iDivisor separate values of i.  apSub[0] holds
** values between 1 and iDivisor.  apSub[1] holds values between
** iDivisor+1 and 2*iDivisor.  apSub[N] holds values between
** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalized
** to hold deal with values between 1 and iDivisor.
*/
struct Bitvec {
  u32 iSize;      /* Maximum bit index.  Max iSize is 4,294,967,296. */
  u32 nSet;       /* Number of bits that are set - only valid for aHash
                  ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,
                  ** this would be 125. */
  u32 iDivisor;   /* Number of bits handled by each apSub[] entry. */
                  /* Should >=0 for apSub element. */
                  /* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */
                  /* For a BITVEC_SZ of 512, this would be 34,359,739. */
  union {
    BITVEC_TELEM aBitmap[BITVEC_NELEM];    /* Bitmap representation */
    u32 aHash[BITVEC_NINT];      /* Hash table representation */
    Bitvec *apSub[BITVEC_NPTR];  /* Recursive representation */
  } u;
};

/*
** Create a new bitmap object able to handle bits between 0 and iSize,
** inclusive.  Return a pointer to the new object.  Return NULL if 
** malloc fails.
*/
Bitvec *sqlite3BitvecCreate(u32 iSize){
  Bitvec *p;
  assert( sizeof(*p)==BITVEC_SZ );
  p = sqlite3MallocZero( sizeof(*p) );
  
// ABS Label 7
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
if( p ){
    p->iSize = iSize;
  }
  
// ABS Label 8
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}
return p;
}

/*
** Check to see if the i-th bit is set.  Return true or false.
** If p is NULL (if the bitmap has not been created) or if
** i is out of range, then return false.
*/
int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){
  assert( p!=0 );
  i--;
  
// ABS Label 9
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
// ABS Label 10
if(p->iSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}

// ROR Label 11
if((i < p->iSize) != (i >= p->iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 11);
}
// ROR Label 12
if((i > p->iSize) != (i >= p->iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 12);
}
// ROR Label 13
if((i <= p->iSize) != (i >= p->iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
if( i>=p->iSize ) { return 0;
}
  
// ABS Label 14
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
while( p->iDivisor ){
    
// ABS Label 16
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}
// ABS Label 17
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}

// AOR Label 18
if(i - p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 18);
}
// AOR Label 19
if(i + p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 19);
}
// AOR Label 20
if(i * p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 20);
}
u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return 0;
    }
  };
// ABS Label 15
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}

  
// ROR Label 21
if((p->iSize < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
// ROR Label 22
if((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}
// ROR Label 23
if((p->iSize >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
if( p->iSize<=BITVEC_NBIT ){
    
// ROR Label 24
if(((p->u.aBitmap[i / 8] & (1 << (i & (8 - 1)))) == 0) != ((p->u.aBitmap[i / 8] & (1 << (i & (8 - 1)))) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;
  } else{
    u32 h = BITVEC_HASH(i++);
    
// ABS Label 25
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
// ABS Label 26
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
while( p->u.aHash[h] ){
      
// ABS Label 29
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
// ABS Label 30
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
// ABS Label 31
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// ROR Label 32
if((p->u.aHash[h] != i) != (p->u.aHash[h] == i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
if( p->u.aHash[h]==i ) { return 1;
}
      h = (h+1) % BITVEC_NINT;
    };
// ABS Label 27
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
// ABS Label 28
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

    return 0;
  }
}
int sqlite3BitvecTest(Bitvec *p, u32 i){
  return p!=0 && sqlite3BitvecTestNotNull(p,i);
}

/*
** Set the i-th bit.  Return 0 on success and an error code if
** anything goes wrong.
**
** This routine might cause sub-bitmaps to be allocated.  Failing
** to get the memory needed to hold the sub-bitmap is the only
** that can go wrong with an insert, assuming p and i are valid.
**
** The calling function must ensure that p is a valid Bitvec object
** and that the value for "i" is within range of the Bitvec object.
** Otherwise the behavior is undefined.
*/
int sqlite3BitvecSet(Bitvec *p, u32 i){
  u32 h;
  
// ABS Label 33
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}

// ROR Label 34
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
if( p==0 ) { return SQLITE_OK;
}
  assert( i>0 );
  assert( i<=p->iSize );
  i--;
  
// ABS Label 35
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// COR Label 36
if(((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) || p->iDivisor) != ((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) && p->iDivisor))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 36);
}

// MCC Label 37
if(( p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8) ) && p->iDivisor ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 37);
}
// MCC Label 38
if(( p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8) ) && !(p->iDivisor) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 38);
}
// MCC Label 39
if(( !(p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) ) && p->iDivisor ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 39);
}
// MCC Label 40
if(( !(p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) ) && !(p->iDivisor) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
while((p->iSize > BITVEC_NBIT) && p->iDivisor) {
    
// ABS Label 47
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}
// ABS Label 48
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// AOR Label 49
if(i - p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 49);
}
// AOR Label 50
if(i + p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 50);
}
// AOR Label 51
if(i * p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 51);
}
u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    
// ABS Label 52
if(bin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
// ABS Label 53
if(p->u.apSub[bin] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}

// ROR Label 54
if((p->u.apSub[bin] != 0) != (p->u.apSub[bin] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 54);
}
if( p->u.apSub[bin]==0 ){
      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );
      
// ABS Label 55
if(bin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 55);
}
// ABS Label 56
if(p->u.apSub[bin] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 56);
}

// ROR Label 57
if((p->u.apSub[bin] != 0) != (p->u.apSub[bin] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
if( p->u.apSub[bin]==0 ) { return SQLITE_NOMEM_BKPT;
}
    }
    p = p->u.apSub[bin];
  };
// ABS Label 41
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}

// COR Label 42
if(((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) || p->iDivisor) != ((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) && p->iDivisor))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 42);
}

// MCC Label 43
if(( p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8) ) && p->iDivisor ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 43);
}
// MCC Label 44
if(( p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8) ) && !(p->iDivisor) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 44);
}
// MCC Label 45
if(( !(p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) ) && p->iDivisor ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 45);
}
// MCC Label 46
if(( !(p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) ) && !(p->iDivisor) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 46);
}

  
// ROR Label 58
if((p->iSize < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}
// ROR Label 59
if((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}
// ROR Label 60
if((p->iSize >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
if( p->iSize<=BITVEC_NBIT ){
    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));
    return SQLITE_OK;
  }
  h = BITVEC_HASH(i++);
  /* if there wasn't a hash collision, and this doesn't */
  /* completely fill the hash, then just add it without */
  /* worring about sub-dividing and re-hashing. */
  if( !p->u.aHash[h] ){
    
// ROR Label 61
if((p->nSet <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)) != (p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
// ROR Label 62
if((p->nSet > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)) != (p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}
// ROR Label 63
if((p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)) != (p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) - 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
if (p->nSet<(BITVEC_NINT-1)) {
      goto bitvec_set_end;
    } else {
      goto bitvec_set_rehash;
    }
  }
  /* there was a collision, check to see if it's already */
  /* in hash, if not, try to find a spot for it */
  
// ABS Label 64
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}
// ABS Label 65
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
do {
    
// ABS Label 68
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}
// ABS Label 69
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 69);
}
// ABS Label 70
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 70);
}

// ROR Label 71
if((p->u.aHash[h] != i) != (p->u.aHash[h] == i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}
if( p->u.aHash[h]==i ) { return SQLITE_OK;
}
    h++;
    
// ROR Label 72
if((h < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 72);
}
// ROR Label 73
if((h > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 73);
}
// ROR Label 74
if((h <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
if( h>=BITVEC_NINT ) { h = 0;
}
  } while( p->u.aHash[h] );
// ABS Label 66
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}
// ABS Label 67
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 67);
}
;
  /* we didn't find it in the hash.  h points to the first */
  /* available free spot. check to see if this is going to */
  /* make our hash too "full".  */
bitvec_set_rehash:
  
// ROR Label 75
if((p->nSet < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)) != (p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
// ROR Label 76
if((p->nSet > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)) != (p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
// ROR Label 77
if((p->nSet <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)) != (p->nSet >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32)) / 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 77);
}
if( p->nSet>=BITVEC_MXHASH ){
    unsigned int j;
    int rc;
    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));
    
// ABS Label 78
if(aiValues < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 78);
}

// ROR Label 79
if((aiValues != 0) != (aiValues == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
if( aiValues==0 ){
      return SQLITE_NOMEM_BKPT;
    }else{
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;
      rc = sqlite3BitvecSet(p, i);
      j = 0;

// ROR Label 80
if((j <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
// ROR Label 81
if((j > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 81);
}
// ROR Label 82
if((j >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
for(; j<BITVEC_NINT; j++){
        
// ABS Label 86
if(aiValues[j] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
// ABS Label 87
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
if( aiValues[j] ) { rc |= sqlite3BitvecSet(p, aiValues[j]);
}
      };
// ROR Label 83
if((j <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
// ROR Label 84
if((j > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 84);
}
// ROR Label 85
if((j >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}

      sqlite3StackFree(0, aiValues);
      
// ABS Label 88
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}
return rc;
    }
  }
bitvec_set_end:
  p->nSet++;
  p->u.aHash[h] = i;
  return SQLITE_OK;
}

/*
** Clear the i-th bit.
**
** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storage
** that BitvecClear can use to rebuilt its hash table.
*/
void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){
  
// ABS Label 89
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 89);
}

// ROR Label 90
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
if( p==0 ) { return;
}
  assert( i>0 );
  i--;
  
// ABS Label 91
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 91);
}
while( p->iDivisor ){
    
// ABS Label 93
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}
// ABS Label 94
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// AOR Label 95
if(i - p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 95);
}
// AOR Label 96
if(i + p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 96);
}
// AOR Label 97
if(i * p->iDivisor != i / p->iDivisor)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 97);
}
u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return;
    }
  };
// ABS Label 92
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

  
// ROR Label 98
if((p->iSize < (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
// ROR Label 99
if((p->iSize > (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 99);
}
// ROR Label 100
if((p->iSize >= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)) != (p->iSize <= (((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u8)) * 8)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}
if( p->iSize<=BITVEC_NBIT ){
    p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));
  }else{
    unsigned int j;
    u32 *aiValues = pBuf;
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    p->nSet = 0;
    j = 0;

// ROR Label 101
if((j <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 101);
}
// ROR Label 102
if((j > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 102);
}
// ROR Label 103
if((j >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 103);
}
for(; j<BITVEC_NINT; j++){
      
// ABS Label 107
if(aiValues[j] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
// ABS Label 108
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}

// COR Label 109
if((aiValues[j] || aiValues[j] != (i + 1)) != (aiValues[j] && aiValues[j] != (i + 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 109);
}

// ROR Label 110
if((aiValues[j] == (i + 1)) != (aiValues[j] != (i + 1)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}

// MCC Label 111
if(aiValues[j] && aiValues[j] != (i + 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
// MCC Label 112
if(aiValues[j] && !(aiValues[j] != (i + 1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 112);
}
// MCC Label 113
if(!(aiValues[j]) && aiValues[j] != (i + 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 113);
}
// MCC Label 114
if(!(aiValues[j]) && !(aiValues[j] != (i + 1)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 114);
}
if( aiValues[j] && aiValues[j]!=(i+1) ){
        u32 h = BITVEC_HASH(aiValues[j]-1);
        p->nSet++;
        
// ABS Label 115
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}
// ABS Label 116
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
while( p->u.aHash[h] ){
          h++;
          
// ROR Label 119
if((h < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((h > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
// ROR Label 121
if((h <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (h >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
if( h>=BITVEC_NINT ) { h = 0;
}
        };
// ABS Label 117
if(h < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
// ABS Label 118
if(p->u.aHash[h] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

        p->u.aHash[h] = aiValues[j];
      }
    };
// ROR Label 104
if((j <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
// ROR Label 105
if((j > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
// ROR Label 106
if((j >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))) != (j < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(u32))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}

  }
}

/*
** Destroy a bitmap object.  Reclaim all memory used.
*/
void sqlite3BitvecDestroy(Bitvec *p){
  
// ABS Label 122
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// ROR Label 123
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
if( p==0 ) { return;
}
  
// ABS Label 124
if(p->iDivisor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 124);
}
if( p->iDivisor ){
    unsigned int i;
    i = 0;

// ROR Label 125
if((i <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))) != (i < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}
// ROR Label 126
if((i > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))) != (i < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}
// ROR Label 127
if((i >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))) != (i < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 127);
}
for(; i<BITVEC_NPTR; i++){
      
// ABS Label 131
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 131);
}
// ABS Label 132
if(p->u.apSub[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 132);
}
sqlite3BitvecDestroy(p->u.apSub[i]);
    };
// ROR Label 128
if((i <= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))) != (i < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}
// ROR Label 129
if((i > ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))) != (i < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 129);
}
// ROR Label 130
if((i >= ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))) != (i < ((((512 - (3 * sizeof(u32))) / sizeof(Bitvec *)) * sizeof(Bitvec *)) / sizeof(Bitvec *))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}

  }
  sqlite3_free(p);
}

/*
** Return the value of the iSize parameter specified when Bitvec *p
** was created.
*/
u32 sqlite3BitvecSize(Bitvec *p){
  
// ABS Label 133
if(p->iSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
return p->iSize;
}

#ifndef SQLITE_UNTESTABLE
/*
** Let V[] be an array of unsigned characters sufficient to hold
** up to N bits.  Let I be an integer between 0 and N.  0<=I<N.
** Then the following macros can be used to set, clear, or test
** individual bits within V.
*/
#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))
#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))
#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0

/*
** This routine runs an extensive test of the Bitvec code.
**
** The input is an array of integers that acts as a program
** to test the Bitvec.  The integers are opcodes followed
** by 0, 1, or 3 operands, depending on the opcode.  Another
** opcode follows immediately after the last operand.
**
** There are 6 opcodes numbered from 0 through 5.  0 is the
** "halt" opcode and causes the test to end.
**
**    0          Halt and return the number of errors
**    1 N S X    Set N bits beginning with S and incrementing by X
**    2 N S X    Clear N bits beginning with S and incrementing by X
**    3 N        Set N randomly chosen bits
**    4 N        Clear N randomly chosen bits
**    5 N S X    Set N bits from S increment X in array only, not in bitvec
**
** The opcodes 1 through 4 perform set and clear operations are performed
** on both a Bitvec object and on a linear array of bits obtained from malloc.
** Opcode 5 works on the linear array only, not on the Bitvec.
** Opcode 5 is used to deliberately induce a fault in order to
** confirm that error detection works.
**
** At the conclusion of the test the linear array is compared
** against the Bitvec object.  If there are any differences,
** an error is returned.  If they are the same, zero is returned.
**
** If a memory allocation error occurs, return -1.
*/
int sqlite3BitvecBuiltinTest(int sz, int *aOp){
  Bitvec *pBitvec = 0;
  unsigned char *pV = 0;
  int rc = -1;
  int i, nx, pc, op;
  void *pTmpSpace;

  /* Allocate the Bitvec to be tested and a linear array of
  ** bits to act as the reference */
  pBitvec = sqlite3BitvecCreate( sz );
  pV = sqlite3MallocZero( (sz+7)/8 + 1 );
  pTmpSpace = sqlite3_malloc64(BITVEC_SZ);
  
// ABS Label 136
if(pBitvec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}
// ABS Label 137
if(pTmpSpace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 137);
}
// ABS Label 138
if(pV < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}

// COR Label 139
if((pBitvec == 0 || pV == 0 && pTmpSpace == 0) != (pBitvec == 0 || pV == 0 || pTmpSpace == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 139);
}
// COR Label 140
if((pBitvec == 0 && pV == 0) != (pBitvec == 0 || pV == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 140);
}

// ROR Label 141
if((pBitvec != 0) != (pBitvec == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 141);
}
// ROR Label 142
if((pV != 0) != (pV == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 142);
}
// ROR Label 143
if((pTmpSpace != 0) != (pTmpSpace == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 143);
}

// MCC Label 144
if(pBitvec == 0 && pV == 0 && pTmpSpace == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 144);
}
// MCC Label 145
if(pBitvec == 0 && pV == 0 && !(pTmpSpace == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 145);
}
// MCC Label 146
if(pBitvec == 0 && !(pV == 0) && pTmpSpace == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 146);
}
// MCC Label 147
if(pBitvec == 0 && !(pV == 0) && !(pTmpSpace == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(!(pBitvec == 0) && pV == 0 && pTmpSpace == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
// MCC Label 149
if(!(pBitvec == 0) && pV == 0 && !(pTmpSpace == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 149);
}
// MCC Label 150
if(!(pBitvec == 0) && !(pV == 0) && pTmpSpace == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 150);
}
// MCC Label 151
if(!(pBitvec == 0) && !(pV == 0) && !(pTmpSpace == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 151);
}
if( pBitvec==0 || pV==0 || pTmpSpace==0  ) { goto bitvec_end;
}

  /* NULL pBitvec tests */
  sqlite3BitvecSet(0, 1);
  
// ABS Label 134
if(pTmpSpace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}
sqlite3BitvecClear(0, 1, pTmpSpace);

  /* Run the program */
  pc = 0;
  while( (op = aOp[pc])!=0 ){
    switch( op ){
      case 1:
      case 2:
      case 5: {
        nx = 4;
        i = aOp[pc+2] - 1;
        aOp[pc+2] += aOp[pc+3];
        break;
      }
      case 3:
      case 4: 
      default: {
        nx = 2;
        sqlite3_randomness(sizeof(i), &i);
        break;
      }
    }
    if( (--aOp[pc+1]) > 0 ) { nx = 0;
}
    pc += nx;
    i = (i & 0x7fffffff)%sz;
    
// ROR Label 152
if(((op & 1) == 0) != ((op & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 152);
}
if( (op & 1)!=0 ){
      SETBIT(pV, (i+1));
      
// ABS Label 153
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// ROR Label 154
if((op == 5) != (op != 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
if( op!=5 ){
        if( sqlite3BitvecSet(pBitvec, i+1) ) { goto bitvec_end;
}
      }
    }else{
      CLEARBIT(pV, (i+1));
      
// ABS Label 155
if(pBitvec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 155);
}

// ABS Label 156
if(pTmpSpace < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 156);
}
sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);
    }
  };

  /* Test to make sure the linear array exactly matches the
  ** Bitvec object.  Start with the assumption that they do
  ** match (rc==0).  Change rc to non-zero if a discrepancy
  ** is found.
  */
  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)
          + sqlite3BitvecTest(pBitvec, 0)
          + (sqlite3BitvecSize(pBitvec) - sz);
  i = 1;

// ABS Label 157
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 157);
}
// ABS Label 158
if(sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 158);
}

// ROR Label 159
if((i < sz) != (i <= sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 159);
}
// ROR Label 160
if((i > sz) != (i <= sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 160);
}
// ROR Label 161
if((i >= sz) != (i <= sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
for(; i<=sz; i++){
    if(  (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){
      rc = i;
      break;
    }
  };
// ABS Label 162
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 162);
}
// ABS Label 163
if(sz < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 163);
}

// ROR Label 164
if((i < sz) != (i <= sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
// ROR Label 165
if((i > sz) != (i <= sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 165);
}
// ROR Label 166
if((i >= sz) != (i <= sz))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}


  /* Free allocated structure */
bitvec_end:
  sqlite3_free(pTmpSpace);
  sqlite3_free(pV);
  
// ABS Label 135
if(pBitvec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 135);
}
sqlite3BitvecDestroy(pBitvec);
  
// ABS Label 167
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 167);
}
return rc;
}
#endif /* SQLITE_UNTESTABLE */
