/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains C code routines that are called by the parser
** to handle SELECT statements in SQLite.
*/
#include "sqliteInt.h"

/*
** An instance of the following object is used to record information about
** how to process the DISTINCT keyword, to simplify passing that information
** into the selectInnerLoop() routine.
*/
typedef struct DistinctCtx DistinctCtx;
struct DistinctCtx {
  u8 isTnct;      /* True if the DISTINCT keyword is present */
  u8 eTnctType;   /* One of the WHERE_DISTINCT_* operators */
  int tabTnct;    /* Ephemeral table used for DISTINCT processing */
  int addrTnct;   /* Address of OP_OpenEphemeral opcode for tabTnct */
};

/*
** An instance of the following object is used to record information about
** the ORDER BY (or GROUP BY) clause of query is being coded.
**
** The aDefer[] array is used by the sorter-references optimization. For
** example, assuming there is no index that can be used for the ORDER BY,
** for the query:
**
**     SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10;
**
** it may be more efficient to add just the "a" values to the sorter, and
** retrieve the associated "bigblob" values directly from table t1 as the
** 10 smallest "a" values are extracted from the sorter.
**
** When the sorter-reference optimization is used, there is one entry in the
** aDefer[] array for each database table that may be read as values are
** extracted from the sorter.
*/
typedef struct SortCtx SortCtx;
struct SortCtx {
  ExprList *pOrderBy;   /* The ORDER BY (or GROUP BY clause) */
  int nOBSat;           /* Number of ORDER BY terms satisfied by indices */
  int iECursor;         /* Cursor number for the sorter */
  int regReturn;        /* Register holding block-output return address */
  int labelBkOut;       /* Start label for the block-output subroutine */
  int addrSortIndex;    /* Address of the OP_SorterOpen or OP_OpenEphemeral */
  int labelDone;        /* Jump here when done, ex: LIMIT reached */
  int labelOBLopt;      /* Jump here when sorter is full */
  u8 sortFlags;         /* Zero or more SORTFLAG_* bits */
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
  u8 nDefer;            /* Number of valid entries in aDefer[] */
  struct DeferredCsr {
    Table *pTab;        /* Table definition */
    int iCsr;           /* Cursor number for table */
    int nKey;           /* Number of PK columns for table pTab (>=1) */
  } aDefer[4];
#endif
  struct RowLoadInfo *pDeferredRowLoad;  /* Deferred row loading info or NULL */
};
#define SORTFLAG_UseSorter  0x01   /* Use SorterOpen instead of OpenEphemeral */

/*
** Delete all the content of a Select structure.  Deallocate the structure
** itself depending on the value of bFree
**
** If bFree==1, call sqlite3DbFree() on the p object.
** If bFree==0, Leave the first Select object unfreed
*/
static void clearSelect(sqlite3 *db, Select *p, int bFree){
  
// ABS Label 7
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
while( p ){
    
// ABS Label 9
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
Select *pPrior = p->pPrior;
    
// ABS Label 10
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}

// ABS Label 11
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
sqlite3ExprListDelete(db, p->pEList);
    
// ABS Label 12
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}

// ABS Label 13
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
sqlite3SrcListDelete(db, p->pSrc);
    
// ABS Label 14
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ABS Label 15
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
sqlite3ExprDelete(db, p->pWhere);
    
// ABS Label 16
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ABS Label 17
if(p->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
sqlite3ExprListDelete(db, p->pGroupBy);
    
// ABS Label 18
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ABS Label 19
if(p->pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3ExprDelete(db, p->pHaving);
    
// ABS Label 20
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}

// ABS Label 21
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
sqlite3ExprListDelete(db, p->pOrderBy);
    
// ABS Label 22
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}

// ABS Label 23
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3ExprDelete(db, p->pLimit);
    
// ABS Label 24
if((p->pWith) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
if( OK_IF_ALWAYS_TRUE(p->pWith) ) { 
// ABS Label 25
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}

// ABS Label 26
if(p->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3WithDelete(db, p->pWith);
}
#ifndef SQLITE_OMIT_WINDOWFUNC
    
// ABS Label 27
if((p->pWinDefn) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){
      
// ABS Label 28
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ABS Label 29
if(p->pWinDefn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 29);
}
sqlite3WindowListDelete(db, p->pWinDefn);
    }
    
// ABS Label 30
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
while( p->pWin ){
      assert( p->pWin->ppThis==&p->pWin );
      
// ABS Label 32
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
sqlite3WindowUnlinkFromSelect(p->pWin);
    };
// ABS Label 31
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

#endif
    
// ABS Label 33
if(bFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
if( bFree ) { 
// ABS Label 34
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
sqlite3DbFreeNN(db, p);
}
    p = pPrior;
    bFree = 1;
  };
// ABS Label 8
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

}

/*
** Initialize a SelectDest structure.
*/
void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){
  pDest->eDest = (u8)eDest;
  pDest->iSDParm = iParm;
  pDest->iSDParm2 = 0;
  pDest->zAffSdst = 0;
  pDest->iSdst = 0;
  pDest->nSdst = 0;
}


/*
** Allocate a new Select structure and return a pointer to that
** structure.
*/
Select *sqlite3SelectNew(
  Parse *pParse,        /* Parsing context */
  ExprList *pEList,     /* which columns to include in the result */
  SrcList *pSrc,        /* the FROM clause -- which tables to scan */
  Expr *pWhere,         /* the WHERE clause */
  ExprList *pGroupBy,   /* the GROUP BY clause */
  Expr *pHaving,        /* the HAVING clause */
  ExprList *pOrderBy,   /* the ORDER BY clause */
  u32 selFlags,         /* Flag parameters, such as SF_Distinct */
  Expr *pLimit          /* LIMIT value.  NULL means not used */
){
  Select *pNew, *pAllocated;
  Select standin;
  pAllocated = pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );
  
// ABS Label 35
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 35);
}

// ROR Label 36
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
if( pNew==0 ){
    assert( pParse->db->mallocFailed );
    pNew = &standin;
  }
  
// ABS Label 37
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 37);
}

// ROR Label 38
if((pEList != 0) != (pEList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}
if( pEList==0 ){
    pEList = sqlite3ExprListAppend(pParse, 0,
                                   sqlite3Expr(pParse->db,TK_ASTERISK,0));
  }
  pNew->pEList = pEList;
  pNew->op = TK_SELECT;
  pNew->selFlags = selFlags;
  pNew->iLimit = 0;
  pNew->iOffset = 0;
  pNew->selId = ++pParse->nSelect;
  pNew->addrOpenEphm[0] = -1;
  pNew->addrOpenEphm[1] = -1;
  pNew->nSelectRow = 0;
  
// ABS Label 39
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 39);
}

// ROR Label 40
if((pSrc != 0) != (pSrc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 40);
}
if( pSrc==0 ) { pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));
}
  pNew->pSrc = pSrc;
  pNew->pWhere = pWhere;
  pNew->pGroupBy = pGroupBy;
  pNew->pHaving = pHaving;
  pNew->pOrderBy = pOrderBy;
  pNew->pPrior = 0;
  pNew->pNext = 0;
  pNew->pLimit = pLimit;
  pNew->pWith = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
  pNew->pWin = 0;
  pNew->pWinDefn = 0;
#endif
  
// ABS Label 41
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
if( pParse->db->mallocFailed ) {
    
// ABS Label 42
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 42);
}

// ABS Label 43
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}

// ABS Label 44
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// ROR Label 45
if((pNew == &standin) != (pNew != &standin))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
clearSelect(pParse->db, pNew, pNew!=&standin);
    pAllocated = 0;
  }else{
    assert( pNew->pSrc!=0 || pParse->nErr>0 );
  }
  
// ABS Label 46
if(pAllocated < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
return pAllocated;
}


/*
** Delete the given Select structure and all of its substructures.
*/
void sqlite3SelectDelete(sqlite3 *db, Select *p){
  
// ABS Label 47
if((p) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}
if( OK_IF_ALWAYS_TRUE(p) ) { 
// ABS Label 48
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// ABS Label 49
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}
clearSelect(db, p, 1);
}
}

/*
** Return a pointer to the right-most SELECT statement in a compound.
*/
static Select *findRightmost(Select *p){
  
// ABS Label 50
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 50);
}
while( p->pNext ) { p = p->pNext;
};
// ABS Label 51
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}

  
// ABS Label 52
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
return p;
}

/*
** Given 1 to 3 identifiers preceding the JOIN keyword, determine the
** type of join.  Return an integer constant that expresses that type
** in terms of the following bit values:
**
**     JT_INNER
**     JT_CROSS
**     JT_OUTER
**     JT_NATURAL
**     JT_LEFT
**     JT_RIGHT
**
** A full outer join is the combination of JT_LEFT and JT_RIGHT.
**
** If an illegal or unsupported join type is seen, then still return
** a join type, but put an error in the pParse structure.
*/
int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){
  int jointype = 0;
  Token *apAll[3];
  Token *p;
                             /*   0123456789 123456789 123456789 123 */
  static const char zKeyText[] = "naturaleftouterightfullinnercross";
  static const struct {
    u8 i;        /* Beginning of keyword text in zKeyText[] */
    u8 nChar;    /* Length of the keyword in characters */
    u8 code;     /* Join type mask */
  } aKeyword[] = {
    /* natural */ { 0,  7, JT_NATURAL                },
    /* left    */ { 6,  4, JT_LEFT|JT_OUTER          },
    /* outer   */ { 10, 5, JT_OUTER                  },
    /* right   */ { 14, 5, JT_RIGHT|JT_OUTER         },
    /* full    */ { 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER },
    /* inner   */ { 23, 5, JT_INNER                  },
    /* cross   */ { 28, 5, JT_INNER|JT_CROSS         },
  };
  int i, j;
  apAll[0] = pA;
  apAll[1] = pB;
  apAll[2] = pC;
  i = 0;

// ABS Label 53
if(apAll[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
// ABS Label 54
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// COR Label 55
if((i < 3 || apAll[i]) != (i < 3 && apAll[i]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 55);
}

// ROR Label 56
if((i <= 3) != (i < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
// ROR Label 57
if((i > 3) != (i < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
// ROR Label 58
if((i >= 3) != (i < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 58);
}

// MCC Label 59
if(i < 3 && apAll[i] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 59);
}
// MCC Label 60
if(i < 3 && !(apAll[i]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(!(i < 3) && apAll[i] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(i < 3) && !(apAll[i]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
for(; i<3 && apAll[i]; i++){
    p = apAll[i];
    j = 0;

// ABS Label 73
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}

// ROR Label 74
if((j <= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 74);
}
// ROR Label 75
if((j > ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
// ROR Label 76
if((j >= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 76);
}
for(; j<ArraySize(aKeyword); j++){
      if( p->n==aKeyword[j].nChar 
          && sqlite3StrNICmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){
        jointype |= aKeyword[j].code;
        break;
      }
    };
// ABS Label 77
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((j <= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
// ROR Label 79
if((j > ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
// ROR Label 80
if((j >= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}

    testcase( j==0 || j==1 || j==2 || j==3 || j==4 || j==5 || j==6 );
    
// ABS Label 81
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ROR Label 82
if((j < ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j >= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
// ROR Label 83
if((j > ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j >= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 83);
}
// ROR Label 84
if((j <= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))) != (j >= ((int)(sizeof (aKeyword) / sizeof (aKeyword[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 84);
}
if( j>=ArraySize(aKeyword) ){
      jointype |= JT_ERROR;
      break;
    }
  };
// ABS Label 63
if(apAll[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 63);
}
// ABS Label 64
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 64);
}

// COR Label 65
if((i < 3 || apAll[i]) != (i < 3 && apAll[i]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 65);
}

// ROR Label 66
if((i <= 3) != (i < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 66);
}
// ROR Label 67
if((i > 3) != (i < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
// ROR Label 68
if((i >= 3) != (i < 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 68);
}

// MCC Label 69
if(i < 3 && apAll[i] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 69);
}
// MCC Label 70
if(i < 3 && !(apAll[i]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 70);
}
// MCC Label 71
if(!(i < 3) && apAll[i] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 71);
}
// MCC Label 72
if(!(i < 3) && !(apAll[i]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}

  
// COR Label 85
if(((jointype & (1 | 32)) == (1 | 32) && (jointype & 64) != 0) != ((jointype & (1 | 32)) == (1 | 32) || (jointype & 64) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 85);
}

// ROR Label 86
if(((jointype & (1 | 32)) != (1 | 32)) != ((jointype & (1 | 32)) == (1 | 32)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
// ROR Label 87
if(((jointype & 64) == 0) != ((jointype & 64) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}

// MCC Label 88
if((jointype & (1 | 32)) == (1 | 32) && (jointype & 64) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 88);
}
// MCC Label 89
if((jointype & (1 | 32)) == (1 | 32) && !((jointype & 64) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 89);
}
// MCC Label 90
if(!((jointype & (1 | 32)) == (1 | 32)) && (jointype & 64) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 90);
}
// MCC Label 91
if(!((jointype & (1 | 32)) == (1 | 32)) && !((jointype & 64) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 91);
}
if(
     (jointype & (JT_INNER|JT_OUTER))==(JT_INNER|JT_OUTER) ||
     (jointype & JT_ERROR)!=0
  ){
    const char *zSp = " ";
    assert( pB!=0 );
    
// ABS Label 97
if(pC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 97);
}

// ROR Label 98
if((pC != 0) != (pC == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 98);
}
if( pC==0 ){ zSp++; }
    
// ABS Label 92
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 92);
}

// ABS Label 93
if(pA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 93);
}

// ABS Label 94
if(pB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 94);
}

// ABS Label 95
if(zSp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 95);
}

// ABS Label 96
if(pC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 96);
}
sqlite3ErrorMsg(pParse, "unknown or unsupported join type: "
       "%T %T%s%T", pA, pB, zSp, pC);
    jointype = JT_INNER;
  }else { 
// COR Label 99
if(((jointype & 32) != 0 || (jointype & (8 | 16)) != 8) != ((jointype & 32) != 0 && (jointype & (8 | 16)) != 8))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 99);
}

// ROR Label 100
if(((jointype & 32) == 0) != ((jointype & 32) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 100);
}
// ROR Label 101
if(((jointype & (8 | 16)) == 8) != ((jointype & (8 | 16)) != 8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 101);
}

// MCC Label 102
if((jointype & 32) != 0 && (jointype & (8 | 16)) != 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 102);
}
// MCC Label 103
if((jointype & 32) != 0 && !((jointype & (8 | 16)) != 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 103);
}
// MCC Label 104
if(!((jointype & 32) != 0) && (jointype & (8 | 16)) != 8 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 104);
}
// MCC Label 105
if(!((jointype & 32) != 0) && !((jointype & (8 | 16)) != 8) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 105);
}
if( (jointype & JT_OUTER)!=0 
         && (jointype & (JT_LEFT|JT_RIGHT))!=JT_LEFT ){
    
// ABS Label 106
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 106);
}
sqlite3ErrorMsg(pParse, 
      "RIGHT and FULL OUTER JOINs are not currently supported");
    jointype = JT_INNER;
  };}

  
// ABS Label 107
if(jointype < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 107);
}
return jointype;
}

/*
** Return the index of a column in a table.  Return -1 if the column
** is not contained in the table.
*/
int sqlite3ColumnIndex(Table *pTab, const char *zCol){
  int i;
  u8 h = sqlite3StrIHash(zCol);
  Column *pCol;
  pCol = pTab->aCol , i = 0;

// ABS Label 108
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 108);
}

// ROR Label 109
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 109);
}
// ROR Label 110
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 110);
}
// ROR Label 111
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 111);
}
for(; i<pTab->nCol; pCol++, i++){
    if( pCol->hName==h && sqlite3StrICmp(pCol->zName, zCol)==0 ) { 
// ABS Label 116
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 116);
}
return i;
}
  };
// ABS Label 112
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ROR Label 113
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
// ROR Label 114
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 114);
}
// ROR Label 115
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}

  return -1;
}

/*
** Search the first N tables in pSrc, from left to right, looking for a
** table that has a column named zCol.  
**
** When found, set *piTab and *piCol to the table index and column index
** of the matching column and return TRUE.
**
** If not found, return FALSE.
*/
static int tableAndColumnIndex(
  SrcList *pSrc,       /* Array of tables to search */
  int N,               /* Number of tables in pSrc->a[] to search */
  const char *zCol,    /* Name of the column we are looking for */
  int *piTab,          /* Write index of pSrc->a[] here */
  int *piCol,          /* Write index of pSrc->a[*piTab].pTab->aCol[] here */
  int bIgnoreHidden    /* True to ignore hidden columns */
){
  int i;               /* For looping over tables in pSrc */
  int iCol;            /* Index of column matching zCol */

  assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */
  i = 0;

// ABS Label 117
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 117);
}
// ABS Label 118
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// ROR Label 119
if((i <= N) != (i < N))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((i > N) != (i < N))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
// ROR Label 121
if((i >= N) != (i < N))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}
for(; i<N; i++){
    iCol = sqlite3ColumnIndex(pSrc->a[i].pTab, zCol);
    
// ABS Label 127
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}

// COR Label 128
if((iCol >= 0 || (bIgnoreHidden == 0 || (((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0)) != (iCol >= 0 && (bIgnoreHidden == 0 || (((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 128);
}

// ROR Label 129
if((iCol < 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 129);
}
// ROR Label 130
if((iCol > 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if((iCol <= 0) != (iCol >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}

// MCC Label 132
if(iCol >= 0 && ( bIgnoreHidden == 0 && (((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 132);
}
// MCC Label 133
if(iCol >= 0 && ( bIgnoreHidden == 0 && !((((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 133);
}
// MCC Label 134
if(iCol >= 0 && ( !(bIgnoreHidden == 0) && (((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 134);
}
// MCC Label 135
if(iCol >= 0 && ( !(bIgnoreHidden == 0) && !((((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
// MCC Label 136
if(!(iCol >= 0) && ( bIgnoreHidden == 0 && (((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 136);
}
// MCC Label 137
if(!(iCol >= 0) && ( bIgnoreHidden == 0 && !((((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
// MCC Label 138
if(!(iCol >= 0) && ( !(bIgnoreHidden == 0) && (((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
// MCC Label 139
if(!(iCol >= 0) && ( !(bIgnoreHidden == 0) && !((((&pSrc->a[i].pTab->aCol[iCol])->colFlags & 2) != 0) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 139);
}
if( iCol>=0 
     && (bIgnoreHidden==0 || IsHiddenColumn(&pSrc->a[i].pTab->aCol[iCol])==0)
    ){
      
// ABS Label 140
if(piTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 140);
}
if( piTab ){
        *piTab = i;
        *piCol = iCol;
      }
      return 1;
    }
  };
// ABS Label 122
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}
// ABS Label 123
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 123);
}

// ROR Label 124
if((i <= N) != (i < N))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 124);
}
// ROR Label 125
if((i > N) != (i < N))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 125);
}
// ROR Label 126
if((i >= N) != (i < N))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 126);
}

  return 0;
}

/*
** This function is used to add terms implied by JOIN syntax to the
** WHERE clause expression of a SELECT statement. The new term, which
** is ANDed with the existing WHERE clause, is of the form:
**
**    (tab1.col1 = tab2.col2)
**
** where tab1 is the iSrc'th table in SrcList pSrc and tab2 is the 
** (iSrc+1)'th. Column col1 is column iColLeft of tab1, and col2 is
** column iColRight of tab2.
*/
static void addWhereTerm(
  Parse *pParse,                  /* Parsing context */
  SrcList *pSrc,                  /* List of tables in FROM clause */
  int iLeft,                      /* Index of first table to join in pSrc */
  int iColLeft,                   /* Index of column in first table */
  int iRight,                     /* Index of second table in pSrc */
  int iColRight,                  /* Index of column in second table */
  int isOuterJoin,                /* True if this is an OUTER join */
  Expr **ppWhere                  /* IN/OUT: The WHERE clause to add to */
){
  
// ABS Label 141
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 141);
}
sqlite3 *db = pParse->db;
  Expr *pE1;
  Expr *pE2;
  Expr *pEq;

  assert( iLeft<iRight );
  assert( pSrc->nSrc>iRight );
  assert( pSrc->a[iLeft].pTab );
  assert( pSrc->a[iRight].pTab );

  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);
  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);

  pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2);
  
// ABS Label 142
if(isOuterJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 142);
}
// ABS Label 143
if(pEq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 143);
}

// COR Label 144
if((pEq || isOuterJoin) != (pEq && isOuterJoin))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 144);
}

// MCC Label 145
if(pEq && isOuterJoin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 145);
}
// MCC Label 146
if(pEq && !(isOuterJoin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 146);
}
// MCC Label 147
if(!(pEq) && isOuterJoin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(!(pEq) && !(isOuterJoin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
if( pEq && isOuterJoin ){
    ExprSetProperty(pEq, EP_FromJoin);
    assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );
    ExprSetVVAProperty(pEq, EP_NoReduce);
    pEq->iRightJoinTable = pE2->iTable;
  }
  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);
}

/*
** Set the EP_FromJoin property on all terms of the given expression.
** And set the Expr.iRightJoinTable to iTable for every term in the
** expression.
**
** The EP_FromJoin property is used on terms of an expression to tell
** the LEFT OUTER JOIN processing logic that this term is part of the
** join restriction specified in the ON or USING clause and not a part
** of the more general WHERE clause.  These terms are moved over to the
** WHERE clause during join processing but we need to remember that they
** originated in the ON or USING clause.
**
** The Expr.iRightJoinTable tells the WHERE clause processing that the
** expression depends on table iRightJoinTable even if that table is not
** explicitly mentioned in the expression.  That information is needed
** for cases like this:
**
**    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5
**
** The where clause needs to defer the handling of the t1.x=5
** term until after the t2 loop of the join.  In that way, a
** NULL t2 row will be inserted whenever t1.x!=5.  If we do not
** defer the handling of t1.x=5, it will be processed immediately
** after the t1 loop and rows with t1.x!=5 will never appear in
** the output, which is incorrect.
*/
void sqlite3SetJoinExpr(Expr *p, int iTable){
  
// ABS Label 149
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 149);
}
while( p ){
    ExprSetProperty(p, EP_FromJoin);
    assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );
    ExprSetVVAProperty(p, EP_NoReduce);
    p->iRightJoinTable = iTable;
    
// ABS Label 153
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 153);
}

// COR Label 154
if((p->op == 171 || p->x.pList) != (p->op == 171 && p->x.pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 154);
}

// ROR Label 155
if((p->op != 171) != (p->op == 171))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 155);
}

// MCC Label 156
if(p->op == 171 && p->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 156);
}
// MCC Label 157
if(p->op == 171 && !(p->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
// MCC Label 158
if(!(p->op == 171) && p->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
// MCC Label 159
if(!(p->op == 171) && !(p->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 159);
}
if( p->op==TK_FUNCTION && p->x.pList ){
      int i;
      i = 0;

// ABS Label 160
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 160);
}
// ABS Label 161
if(p->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 161);
}

// ROR Label 162
if((i <= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((i > p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
// ROR Label 164
if((i >= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 164);
}
for(; i<p->x.pList->nExpr; i++){
        
// ABS Label 170
if(p->x.pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 170);
}

// ABS Label 171
if(iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 171);
}
sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);
      };
// ABS Label 165
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}
// ABS Label 166
if(p->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 166);
}

// ROR Label 167
if((i <= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
// ROR Label 168
if((i > p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 168);
}
// ROR Label 169
if((i >= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 169);
}

    }
    
// ABS Label 151
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// ABS Label 152
if(iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 152);
}
sqlite3SetJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  };
// ABS Label 150
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 150);
}
 
}

/* Undo the work of sqlite3SetJoinExpr(). In the expression p, convert every
** term that is marked with EP_FromJoin and iRightJoinTable==iTable into
** an ordinary term that omits the EP_FromJoin mark.
**
** This happens when a LEFT JOIN is simplified into an ordinary JOIN.
*/
static void unsetJoinExpr(Expr *p, int iTable){
  
// ABS Label 172
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 172);
}
while( p ){
    
// COR Label 176
if(((((p)->flags & (1)) != 0) || (iTable < 0 || p->iRightJoinTable == iTable)) != ((((p)->flags & (1)) != 0) && (iTable < 0 || p->iRightJoinTable == iTable)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 176);
}

// MCC Label 177
if(( ((p)->flags & (1)) != 0 ) && ( iTable < 0 && p->iRightJoinTable == iTable ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(( ((p)->flags & (1)) != 0 ) && ( iTable < 0 && !(p->iRightJoinTable == iTable) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(( ((p)->flags & (1)) != 0 ) && ( !(iTable < 0) && p->iRightJoinTable == iTable ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(( ((p)->flags & (1)) != 0 ) && ( !(iTable < 0) && !(p->iRightJoinTable == iTable) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
// MCC Label 181
if(( !(((p)->flags & (1)) != 0) ) && ( iTable < 0 && p->iRightJoinTable == iTable ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 181);
}
// MCC Label 182
if(( !(((p)->flags & (1)) != 0) ) && ( iTable < 0 && !(p->iRightJoinTable == iTable) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 182);
}
// MCC Label 183
if(( !(((p)->flags & (1)) != 0) ) && ( !(iTable < 0) && p->iRightJoinTable == iTable ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 183);
}
// MCC Label 184
if(( !(((p)->flags & (1)) != 0) ) && ( !(iTable < 0) && !(p->iRightJoinTable == iTable) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 184);
}
if( ExprHasProperty(p, EP_FromJoin)
     && (iTable<0 || p->iRightJoinTable==iTable) ){
      ExprClearProperty(p, EP_FromJoin);
    }
    
// ABS Label 185
if(iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
// ABS Label 186
if(p->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// COR Label 187
if((p->op == 166 || p->iTable == iTable) != (p->op == 166 && p->iTable == iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 187);
}

// ROR Label 188
if((p->op != 166) != (p->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
// ROR Label 189
if((p->iTable != iTable) != (p->iTable == iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}

// MCC Label 190
if(p->op == 166 && p->iTable == iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 190);
}
// MCC Label 191
if(p->op == 166 && !(p->iTable == iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 191);
}
// MCC Label 192
if(!(p->op == 166) && p->iTable == iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 192);
}
// MCC Label 193
if(!(p->op == 166) && !(p->iTable == iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 193);
}
if( p->op==TK_COLUMN && p->iTable==iTable ){
      ExprClearProperty(p, EP_CanBeNull);
    }
    
// ABS Label 194
if(p->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 194);
}

// COR Label 195
if((p->op == 171 || p->x.pList) != (p->op == 171 && p->x.pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 195);
}

// ROR Label 196
if((p->op != 171) != (p->op == 171))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 196);
}

// MCC Label 197
if(p->op == 171 && p->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
// MCC Label 198
if(p->op == 171 && !(p->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 198);
}
// MCC Label 199
if(!(p->op == 171) && p->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 199);
}
// MCC Label 200
if(!(p->op == 171) && !(p->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 200);
}
if( p->op==TK_FUNCTION && p->x.pList ){
      int i;
      i = 0;

// ABS Label 201
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}
// ABS Label 202
if(p->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}

// ROR Label 203
if((i <= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
// ROR Label 204
if((i > p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 204);
}
// ROR Label 205
if((i >= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
for(; i<p->x.pList->nExpr; i++){
        
// ABS Label 211
if(p->x.pList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}

// ABS Label 212
if(iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}
unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);
      };
// ABS Label 206
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
// ABS Label 207
if(p->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ROR Label 208
if((i <= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((i > p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((i >= p->x.pList->nExpr) != (i < p->x.pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}

    }
    
// ABS Label 174
if(p->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ABS Label 175
if(iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 175);
}
unsetJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  };
// ABS Label 173
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}
 
}

/*
** This routine processes the join information for a SELECT statement.
** ON and USING clauses are converted into extra terms of the WHERE clause.
** NATURAL joins also create extra WHERE clause terms.
**
** The terms of a FROM clause are contained in the Select.pSrc structure.
** The left most table is the first entry in Select.pSrc.  The right-most
** table is the last entry.  The join operator is held in the entry to
** the left.  Thus entry 0 contains the join operator for the join between
** entries 0 and 1.  Any ON or USING clauses associated with the join are
** also attached to the left entry.
**
** This routine returns the number of errors encountered.
*/
static int sqliteProcessJoin(Parse *pParse, Select *p){
  SrcList *pSrc;                  /* All tables in the FROM clause */
  int i, j;                       /* Loop counters */
  SrcItem *pLeft;                 /* Left table being joined */
  SrcItem *pRight;                /* Right table being joined */

  pSrc = p->pSrc;
  pLeft = &pSrc->a[0];
  pRight = &pLeft[1];
  i = 0;

// ABS Label 213
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 213);
}
// ABS Label 214
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}

// AOR Label 215
if(pSrc->nSrc / 1 != pSrc->nSrc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 215);
}
// AOR Label 216
if(pSrc->nSrc + 1 != pSrc->nSrc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 216);
}
// AOR Label 217
if(pSrc->nSrc * 1 != pSrc->nSrc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 217);
}

// ROR Label 218
if((i <= pSrc->nSrc - 1) != (i < pSrc->nSrc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 218);
}
// ROR Label 219
if((i > pSrc->nSrc - 1) != (i < pSrc->nSrc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
// ROR Label 220
if((i >= pSrc->nSrc - 1) != (i < pSrc->nSrc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 220);
}
for(; i<pSrc->nSrc-1; i++, pRight++, pLeft++){
    
// ABS Label 229
if(pRight->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 229);
}
Table *pRightTab = pRight->pTab;
    int isOuter;

    
// MCC Label 230
if(( pLeft->pTab == 0 && pRightTab == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 230);
}
// MCC Label 231
if(( pLeft->pTab == 0 && !(pRightTab == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 231);
}
// MCC Label 232
if(( !(pLeft->pTab == 0) && pRightTab == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 232);
}
// MCC Label 233
if(( !(pLeft->pTab == 0) && !(pRightTab == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 233);
}
if( NEVER(pLeft->pTab==0 || pRightTab==0) ) { continue;
}
    isOuter = (pRight->fg.jointype & JT_OUTER)!=0;

    /* When the NATURAL keyword is present, add WHERE clause terms for
    ** every column that the two tables have in common.
    */
    
// AOR Label 234
if(pRight->fg.jointype | 4 != pRight->fg.jointype & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 234);
}
// AOR Label 235
if(pRight->fg.jointype ^ 4 != pRight->fg.jointype & 4)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 235);
}
if( pRight->fg.jointype & JT_NATURAL ){
      
// ABS Label 236
if(pRight->pOn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 236);
}
// ABS Label 237
if(pRight->pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 237);
}

// COR Label 238
if((pRight->pOn && pRight->pUsing) != (pRight->pOn || pRight->pUsing))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 238);
}

// MCC Label 239
if(pRight->pOn && pRight->pUsing ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 239);
}
// MCC Label 240
if(pRight->pOn && !(pRight->pUsing) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 240);
}
// MCC Label 241
if(!(pRight->pOn) && pRight->pUsing ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 241);
}
// MCC Label 242
if(!(pRight->pOn) && !(pRight->pUsing) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 242);
}
if( pRight->pOn || pRight->pUsing ){
        
// ABS Label 243
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 243);
}
sqlite3ErrorMsg(pParse, "a NATURAL join may not have "
           "an ON or USING clause", 0);
        return 1;
      }
      j = 0;

// ABS Label 244
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 244);
}

// ROR Label 245
if((j <= pRightTab->nCol) != (j < pRightTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 245);
}
// ROR Label 246
if((j > pRightTab->nCol) != (j < pRightTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 246);
}
// ROR Label 247
if((j >= pRightTab->nCol) != (j < pRightTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 247);
}
for(; j<pRightTab->nCol; j++){
        char *zName;   /* Name of column in the right table */
        int iLeft;     /* Matching left table */
        int iLeftCol;  /* Matching column in the left table */

        
// MCC Label 252
if(( ((&pRightTab->aCol[j])->colFlags & 2) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 252);
}
// MCC Label 253
if(( !(((&pRightTab->aCol[j])->colFlags & 2) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 253);
}
if( IsHiddenColumn(&pRightTab->aCol[j]) ) { continue;
}
        zName = pRightTab->aCol[j].zName;
        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol, 1) ){
          
// ABS Label 254
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}

// ABS Label 255
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 255);
}

// ABS Label 256
if(iLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}

// ABS Label 257
if(iLeftCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}

// ABS Label 258
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// AOR Label 259
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 259);
}
// AOR Label 260
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 260);
}
// AOR Label 261
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 261);
}

// ABS Label 262
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 262);
}

// ABS Label 263
if(isOuter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 263);
}
addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,
                isOuter, &p->pWhere);
        }
      };
// ABS Label 248
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 248);
}

// ROR Label 249
if((j <= pRightTab->nCol) != (j < pRightTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 249);
}
// ROR Label 250
if((j > pRightTab->nCol) != (j < pRightTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((j >= pRightTab->nCol) != (j < pRightTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}

    }

    /* Disallow both ON and USING clauses in the same join
    */
    
// ABS Label 264
if(pRight->pOn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 264);
}
// ABS Label 265
if(pRight->pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}

// COR Label 266
if((pRight->pOn || pRight->pUsing) != (pRight->pOn && pRight->pUsing))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 266);
}

// MCC Label 267
if(pRight->pOn && pRight->pUsing ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
// MCC Label 268
if(pRight->pOn && !(pRight->pUsing) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 268);
}
// MCC Label 269
if(!(pRight->pOn) && pRight->pUsing ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 269);
}
// MCC Label 270
if(!(pRight->pOn) && !(pRight->pUsing) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 270);
}
if( pRight->pOn && pRight->pUsing ){
      
// ABS Label 271
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}
sqlite3ErrorMsg(pParse, "cannot have both ON and USING "
        "clauses in the same join");
      return 1;
    }

    /* Add the ON clause to the end of the WHERE clause, connected by
    ** an AND operator.
    */
    
// ABS Label 272
if(pRight->pOn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 272);
}
if( pRight->pOn ){
      
// ABS Label 273
if(isOuter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 273);
}
if( isOuter ) { 
// ABS Label 274
if(pRight->pOn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 274);
}

// ABS Label 275
if(pRight->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 275);
}
sqlite3SetJoinExpr(pRight->pOn, pRight->iCursor);
}
      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);
      pRight->pOn = 0;
    }

    /* Create extra terms on the WHERE clause for each column named
    ** in the USING clause.  Example: If the two tables to be joined are 
    ** A and B and the USING clause names X, Y, and Z, then add this
    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z
    ** Report an error if any column mentioned in the USING clause is
    ** not contained in both tables to be joined.
    */
    
// ABS Label 276
if(pRight->pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 276);
}
if( pRight->pUsing ){
      
// ABS Label 277
if(pRight->pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 277);
}
IdList *pList = pRight->pUsing;
      j = 0;

// ABS Label 278
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 278);
}
// ABS Label 279
if(pList->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 279);
}

// ROR Label 280
if((j <= pList->nId) != (j < pList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((j > pList->nId) != (j < pList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}
// ROR Label 282
if((j >= pList->nId) != (j < pList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
for(; j<pList->nId; j++){
        char *zName;     /* Name of the term in the USING clause */
        int iLeft;       /* Table on the left with matching column name */
        int iLeftCol;    /* Column number of matching column on the left */
        int iRightCol;   /* Column number of matching column on the right */

        zName = pList->a[j].zName;
        iRightCol = sqlite3ColumnIndex(pRightTab, zName);
        if( iRightCol<0
         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol, 0)
        ){
          
// ABS Label 298
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}

// ABS Label 299
if(zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
sqlite3ErrorMsg(pParse, "cannot join using column %s - column "
            "not present in both tables", zName);
          return 1;
        }
        
// ABS Label 288
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}

// ABS Label 289
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}

// ABS Label 290
if(iLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}

// ABS Label 291
if(iLeftCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ABS Label 292
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 292);
}

// AOR Label 293
if(i - 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 293);
}
// AOR Label 294
if(i / 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 294);
}
// AOR Label 295
if(i * 1 != i + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 295);
}

// ABS Label 296
if(iRightCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}

// ABS Label 297
if(isOuter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,
                     isOuter, &p->pWhere);
      };
// ABS Label 283
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}
// ABS Label 284
if(pList->nId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 284);
}

// ROR Label 285
if((j <= pList->nId) != (j < pList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 285);
}
// ROR Label 286
if((j > pList->nId) != (j < pList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
// ROR Label 287
if((j >= pList->nId) != (j < pList->nId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 287);
}

    }
  };
// ABS Label 221
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 221);
}
// ABS Label 222
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 222);
}

// AOR Label 223
if(pSrc->nSrc / 1 != pSrc->nSrc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 223);
}
// AOR Label 224
if(pSrc->nSrc + 1 != pSrc->nSrc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 224);
}
// AOR Label 225
if(pSrc->nSrc * 1 != pSrc->nSrc - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 225);
}

// ROR Label 226
if((i <= pSrc->nSrc - 1) != (i < pSrc->nSrc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 226);
}
// ROR Label 227
if((i > pSrc->nSrc - 1) != (i < pSrc->nSrc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 227);
}
// ROR Label 228
if((i >= pSrc->nSrc - 1) != (i < pSrc->nSrc - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 228);
}

  return 0;
}

/*
** An instance of this object holds information (beyond pParse and pSelect)
** needed to load the next result row that is to be added to the sorter.
*/
typedef struct RowLoadInfo RowLoadInfo;
struct RowLoadInfo {
  int regResult;               /* Store results in array of registers here */
  u8 ecelFlags;                /* Flag argument to ExprCodeExprList() */
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
  ExprList *pExtra;            /* Extra columns needed by sorter refs */
  int regExtraResult;          /* Where to load the extra columns */
#endif
};

/*
** This routine does the work of loading query data into an array of
** registers so that it can be added to the sorter.
*/
static void innerLoopLoadRow(
  Parse *pParse,             /* Statement under construction */
  Select *pSelect,           /* The query being coded */
  RowLoadInfo *pInfo         /* Info needed to complete the row load */
){
  
// ABS Label 300
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}

// ABS Label 301
if(pSelect->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ABS Label 302
if(pInfo->regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 302);
}

// ABS Label 303
if(pInfo->ecelFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,
                          0, pInfo->ecelFlags);
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
  if( pInfo->pExtra ){
    sqlite3ExprCodeExprList(pParse, pInfo->pExtra, pInfo->regExtraResult, 0, 0);
    sqlite3ExprListDelete(pParse->db, pInfo->pExtra);
  }
#endif
}

/*
** Code the OP_MakeRecord instruction that generates the entry to be
** added into the sorter.
**
** Return the register in which the result is stored.
*/
static int makeSorterRecord(
  Parse *pParse,
  SortCtx *pSort,
  Select *pSelect,
  int regBase,
  int nBase
){
  
// ABS Label 304
if(pSort->nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
int nOBSat = pSort->nOBSat;
  
// ABS Label 305
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
Vdbe *v = pParse->pVdbe;
  int regOut = ++pParse->nMem;
  
// ABS Label 318
if(pSort->pDeferredRowLoad < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
if( pSort->pDeferredRowLoad ){
    
// ABS Label 319
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}

// ABS Label 320
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}

// ABS Label 321
if(pSort->pDeferredRowLoad < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);
  }
  
// ABS Label 306
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}

// ABS Label 307
if(nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
// ABS Label 308
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// AOR Label 309
if(regBase - nOBSat != regBase + nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 309);
}
// AOR Label 310
if(regBase / nOBSat != regBase + nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 310);
}
// AOR Label 311
if(regBase * nOBSat != regBase + nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 311);
}

// ABS Label 312
if(nBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 312);
}
// ABS Label 313
if(nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}

// AOR Label 314
if(nBase / nOBSat != nBase - nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 314);
}
// AOR Label 315
if(nBase + nOBSat != nBase - nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 315);
}
// AOR Label 316
if(nBase * nOBSat != nBase - nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 316);
}

// ABS Label 317
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase+nOBSat, nBase-nOBSat, regOut);
  
// ABS Label 322
if(regOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}
return regOut;
}

/*
** Generate code that will push the record in registers regData
** through regData+nData-1 onto the sorter.
*/
static void pushOntoSorter(
  Parse *pParse,         /* Parser context */
  SortCtx *pSort,        /* Information about the ORDER BY clause */
  Select *pSelect,       /* The whole SELECT statement */
  int regData,           /* First register holding data to be sorted */
  int regOrigData,       /* First register holding data before packing */
  int nData,             /* Number of elements in the regData data array */
  int nPrefixReg         /* No. of reg prior to regData available for use */
){
  
// ABS Label 323
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
Vdbe *v = pParse->pVdbe;                         /* Stmt under construction */
  int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter)==0);
  
// ABS Label 324
if(pSort->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}
int nExpr = pSort->pOrderBy->nExpr;              /* No. of ORDER BY terms */
  
// ABS Label 325
if(bSeq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}
// ABS Label 326
if(nData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
// ABS Label 327
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}

// AOR Label 328
if(nExpr + bSeq - nData != nExpr + bSeq + nData)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 328);
}
// AOR Label 329
if(nExpr + bSeq / nData != nExpr + bSeq + nData)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 329);
}
// AOR Label 330
if(nExpr + bSeq * nData != nExpr + bSeq + nData)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 330);
}
// AOR Label 331
if(nExpr - bSeq != nExpr + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 331);
}
// AOR Label 332
if(nExpr / bSeq != nExpr + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 332);
}
// AOR Label 333
if(nExpr * bSeq != nExpr + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 333);
}
int nBase = nExpr + bSeq + nData;                /* Fields in sorter record */
  int regBase;                                     /* Regs for sorter record */
  int regRecord = 0;                               /* Assembled sorter record */
  
// ABS Label 334
if(pSort->nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 334);
}
int nOBSat = pSort->nOBSat;                      /* ORDER BY terms to skip */
  int op;                            /* Opcode to add sorter record to sorter */
  int iLimit;                        /* LIMIT counter */
  int iSkip = 0;                     /* End of the sorter insert loop */

  assert( bSeq==0 || bSeq==1 );

  /* Three cases:
  **   (1) The data to be sorted has already been packed into a Record
  **       by a prior OP_MakeRecord.  In this case nData==1 and regData
  **       will be completely unrelated to regOrigData.
  **   (2) All output columns are included in the sort record.  In that
  **       case regData==regOrigData.
  **   (3) Some output columns are omitted from the sort record due to
  **       the SQLITE_ENABLE_SORTER_REFERENCE optimization, or due to the
  **       SQLITE_ECEL_OMITREF optimization, or due to the 
  **       SortCtx.pDeferredRowLoad optimiation.  In any of these cases
  **       regOrigData is 0 to prevent this routine from trying to copy
  **       values that might not yet exist.
  */
  assert( nData==1 || regData==regOrigData || regOrigData==0 );

  
// ABS Label 353
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 353);
}
if( nPrefixReg ){
    assert( nPrefixReg==nExpr+bSeq );
    regBase = regData - nPrefixReg;
  }else{
    regBase = pParse->nMem + 1;
    pParse->nMem += nBase;
  }
  assert( pSelect->iOffset==0 || pSelect->iLimit!=0 );
  iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;
  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);
  
// ABS Label 335
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}

// ABS Label 336
if(pSort->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ABS Label 337
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}

// ABS Label 338
if(regOrigData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,
                          SQLITE_ECEL_DUP | (regOrigData? SQLITE_ECEL_REF : 0));
  
// ABS Label 354
if(bSeq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
if( bSeq ){
    
// ABS Label 355
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}

// ABS Label 356
if(pSort->iECursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// ABS Label 357
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 357);
}
// ABS Label 358
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 358);
}

// AOR Label 359
if(regBase - nExpr != regBase + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 359);
}
// AOR Label 360
if(regBase / nExpr != regBase + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 360);
}
// AOR Label 361
if(regBase * nExpr != regBase + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 361);
}
sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase+nExpr);
  }
  
// ABS Label 362
if(nData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 362);
}
// ABS Label 363
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 363);
}

// COR Label 364
if((nPrefixReg == 0 || nData > 0) != (nPrefixReg == 0 && nData > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 364);
}

// ROR Label 365
if((nPrefixReg != 0) != (nPrefixReg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 365);
}
// ROR Label 366
if((nData <= 0) != (nData > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 366);
}
// ROR Label 367
if((nData < 0) != (nData > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 367);
}
// ROR Label 368
if((nData >= 0) != (nData > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 368);
}

// MCC Label 369
if(nPrefixReg == 0 && nData > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 369);
}
// MCC Label 370
if(nPrefixReg == 0 && !(nData > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}
// MCC Label 371
if(!(nPrefixReg == 0) && nData > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 371);
}
// MCC Label 372
if(!(nPrefixReg == 0) && !(nData > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 372);
}
if( nPrefixReg==0 && nData>0 ){
    
// ABS Label 373
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 373);
}

// ABS Label 374
if(regData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 374);
}

// ABS Label 375
if(bSeq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}
// ABS Label 376
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 376);
}
// ABS Label 377
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 377);
}

// AOR Label 378
if(regBase + nExpr - bSeq != regBase + nExpr + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 378);
}
// AOR Label 379
if(regBase + nExpr / bSeq != regBase + nExpr + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 379);
}
// AOR Label 380
if(regBase + nExpr * bSeq != regBase + nExpr + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 380);
}
// AOR Label 381
if(regBase - nExpr != regBase + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 381);
}
// AOR Label 382
if(regBase / nExpr != regBase + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 382);
}
// AOR Label 383
if(regBase * nExpr != regBase + nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 383);
}

// ABS Label 384
if(nData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 384);
}
sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);
  }
  
// ABS Label 385
if(nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 385);
}

// ROR Label 386
if((nOBSat <= 0) != (nOBSat > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}
// ROR Label 387
if((nOBSat < 0) != (nOBSat > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 387);
}
// ROR Label 388
if((nOBSat >= 0) != (nOBSat > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 388);
}
if( nOBSat>0 ){
    int regPrevKey;   /* The first nOBSat columns of the previous row */
    int addrFirst;    /* Address of the OP_IfNot opcode */
    int addrJmp;      /* Address of the OP_Jump opcode */
    VdbeOp *pOp;      /* Opcode that opens the sorter */
    int nKey;         /* Number of sorting key columns, including OP_Sequence */
    KeyInfo *pKI;     /* Original KeyInfo on the sorter table */

    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
    regPrevKey = pParse->nMem+1;
    pParse->nMem += pSort->nOBSat;
    nKey = nExpr - pSort->nOBSat + bSeq;
    
// ABS Label 416
if(bSeq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 416);
}
if( bSeq ){
      addrFirst = sqlite3VdbeAddOp1(v, OP_IfNot, regBase+nExpr); 
    }else{
      addrFirst = sqlite3VdbeAddOp1(v, OP_SequenceTest, pSort->iECursor);
    }
    VdbeCoverage(v);
    
// ABS Label 389
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 389);
}

// ABS Label 390
if(regPrevKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 390);
}

// ABS Label 391
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 391);
}

// ABS Label 392
if(pSort->nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}
sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);
    pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
    
// ABS Label 417
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
if( pParse->db->mallocFailed ) { return;
}
    pOp->p2 = nKey + nData;
    pKI = pOp->p4.pKeyInfo;
    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */
    
// ABS Label 393
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 393);
}
sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);
    testcase( pKI->nAllField > pKI->nKeyField+2 );
    pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,
                                           pKI->nAllField-pKI->nKeyField-1);
    pOp = 0; /* Ensure pOp not used after sqltie3VdbeAddOp3() */
    addrJmp = sqlite3VdbeCurrentAddr(v);
    
// ABS Label 394
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 394);
}

// ABS Label 395
if(addrJmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 395);
}

// AOR Label 396
if(addrJmp - 1 != addrJmp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 396);
}
// AOR Label 397
if(addrJmp / 1 != addrJmp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 397);
}
// AOR Label 398
if(addrJmp * 1 != addrJmp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 398);
}

// ABS Label 399
if(addrJmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 399);
}

// AOR Label 400
if(addrJmp - 1 != addrJmp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 400);
}
// AOR Label 401
if(addrJmp / 1 != addrJmp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 401);
}
// AOR Label 402
if(addrJmp * 1 != addrJmp + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 402);
}
sqlite3VdbeAddOp3(v, OP_Jump, addrJmp+1, 0, addrJmp+1); VdbeCoverage(v);
    pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);
    pSort->regReturn = ++pParse->nMem;
    
// ABS Label 403
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 403);
}

// ABS Label 404
if(pSort->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 404);
}

// ABS Label 405
if(pSort->labelBkOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 405);
}
sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);
    
// ABS Label 406
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 406);
}

// ABS Label 407
if(pSort->iECursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 407);
}
sqlite3VdbeAddOp1(v, OP_ResetSorter, pSort->iECursor);
    
// ABS Label 418
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}
if( iLimit ){
      
// ABS Label 419
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 419);
}

// ABS Label 420
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 420);
}

// ABS Label 421
if(pSort->labelDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 421);
}
sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, pSort->labelDone);
      VdbeCoverage(v);
    }
    
// ABS Label 408
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 408);
}

// ABS Label 409
if(addrFirst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 409);
}
sqlite3VdbeJumpHere(v, addrFirst);
    
// ABS Label 410
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 410);
}

// ABS Label 411
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}

// ABS Label 412
if(regPrevKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 412);
}

// ABS Label 413
if(pSort->nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 413);
}
sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);
    
// ABS Label 414
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 414);
}

// ABS Label 415
if(addrJmp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}
sqlite3VdbeJumpHere(v, addrJmp);
  }
  
// ABS Label 422
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}
if( iLimit ){
    /* At this point the values for the new sorter entry are stored
    ** in an array of registers. They need to be composed into a record
    ** and inserted into the sorter if either (a) there are currently
    ** less than LIMIT+OFFSET items or (b) the new record is smaller than 
    ** the largest record currently in the sorter. If (b) is true and there
    ** are already LIMIT+OFFSET items in the sorter, delete the largest
    ** entry before inserting the new one. This way there are never more 
    ** than LIMIT+OFFSET items in the sorter.
    **
    ** If the new record does not need to be inserted into the sorter,
    ** jump to the next iteration of the loop. If the pSort->labelOBLopt
    ** value is not zero, then it is a label of where to jump.  Otherwise,
    ** just bypass the row insert logic.  See the header comment on the
    ** sqlite3WhereOrderByLimitOptLabel() function for additional info.
    */
    
// ABS Label 423
if(pSort->iECursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 423);
}
int iCsr = pSort->iECursor;
    
// ABS Label 424
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 424);
}

// ABS Label 425
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 425);
}
sqlite3VdbeAddOp2(v, OP_IfNotZero, iLimit, sqlite3VdbeCurrentAddr(v)+4);
    VdbeCoverage(v);
    
// ABS Label 426
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}

// ABS Label 427
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 427);
}
sqlite3VdbeAddOp2(v, OP_Last, iCsr, 0);
    iSkip = sqlite3VdbeAddOp4Int(v, OP_IdxLE,
                                 iCsr, 0, regBase+nOBSat, nExpr-nOBSat);
    VdbeCoverage(v);
    
// ABS Label 428
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 428);
}

// ABS Label 429
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 429);
}
sqlite3VdbeAddOp1(v, OP_Delete, iCsr);
  }
  
// ABS Label 430
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}

// ROR Label 431
if((regRecord != 0) != (regRecord == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 431);
}
if( regRecord==0 ){
    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
  }
  
// AOR Label 432
if(pSort->sortFlags | 1 != pSort->sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 432);
}
// AOR Label 433
if(pSort->sortFlags ^ 1 != pSort->sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 433);
}
if( pSort->sortFlags & SORTFLAG_UseSorter ){
    op = OP_SorterInsert;
  }else{
    op = OP_IdxInsert;
  }
  
// ABS Label 339
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}

// ABS Label 340
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 340);
}

// ABS Label 341
if(pSort->iECursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 341);
}

// ABS Label 342
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 342);
}

// ABS Label 343
if(nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 343);
}
// ABS Label 344
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 344);
}

// AOR Label 345
if(regBase - nOBSat != regBase + nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 345);
}
// AOR Label 346
if(regBase / nOBSat != regBase + nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 346);
}
// AOR Label 347
if(regBase * nOBSat != regBase + nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 347);
}

// ABS Label 348
if(nBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 348);
}
// ABS Label 349
if(nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 349);
}

// AOR Label 350
if(nBase / nOBSat != nBase - nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 350);
}
// AOR Label 351
if(nBase + nOBSat != nBase - nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 351);
}
// AOR Label 352
if(nBase * nOBSat != nBase - nOBSat)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 352);
}
sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,
                       regBase+nOBSat, nBase-nOBSat);
  
// ABS Label 434
if(iSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 434);
}
if( iSkip ){
    
// ABS Label 435
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}

// ABS Label 436
if(iSkip < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 436);
}
sqlite3VdbeChangeP2(v, iSkip,
         pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));
  }
}

/*
** Add code to implement the OFFSET
*/
static void codeOffset(
  Vdbe *v,          /* Generate code into this VM */
  int iOffset,      /* Register holding the offset counter */
  int iContinue     /* Jump here to skip the current record */
){
  
// ABS Label 437
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 437);
}

// ROR Label 438
if((iOffset <= 0) != (iOffset > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}
// ROR Label 439
if((iOffset < 0) != (iOffset > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 439);
}
// ROR Label 440
if((iOffset >= 0) != (iOffset > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 440);
}
if( iOffset>0 ){
    
// ABS Label 441
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 441);
}

// ABS Label 442
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 442);
}

// ABS Label 443
if(iContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 443);
}
sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);
    VdbeComment((v, "OFFSET"));
  }
}

/*
** Add code that will check to make sure the array of registers starting at
** iMem form a distinct entry. This is used by both "SELECT DISTINCT ..." and
** distinct aggregates ("SELECT count(DISTINCT <expr>) ..."). Three strategies
** are available. Which is used depends on the value of parameter eTnctType,
** as follows:
**
**   WHERE_DISTINCT_UNORDERED/WHERE_DISTINCT_NOOP:
**     Build an ephemeral table that contains all entries seen before and
**     skip entries which have been seen before.
**
**     Parameter iTab is the cursor number of an ephemeral table that must
**     be opened before the VM code generated by this routine is executed.
**     The ephemeral cursor table is queried for a record identical to the
**     record formed by the current array of registers. If one is found,
**     jump to VM address addrRepeat. Otherwise, insert a new record into
**     the ephemeral cursor and proceed.
**
**     The returned value in this case is a copy of parameter iTab.
**
**   WHERE_DISTINCT_ORDERED:
**     In this case rows are being delivered sorted order. The ephermal
**     table is not required. Instead, the current set of values
**     is compared against previous row. If they match, the new row
**     is not distinct and control jumps to VM address addrRepeat. Otherwise,
**     the VM program proceeds with processing the new row.
**
**     The returned value in this case is the register number of the first
**     in an array of registers used to store the previous result row so that
**     it can be compared to the next. The caller must ensure that this
**     register is initialized to NULL.  (The fixDistinctOpenEph() routine
**     will take care of this initialization.)
**
**   WHERE_DISTINCT_UNIQUE:
**     In this case it has already been determined that the rows are distinct.
**     No special action is required. The return value is zero.
**
** Parameter pEList is the list of expressions used to generated the 
** contents of each row. It is used by this routine to determine (a) 
** how many elements there are in the array of registers and (b) the 
** collation sequences that should be used for the comparisons if 
** eTnctType is WHERE_DISTINCT_ORDERED.
*/
static int codeDistinct(
  Parse *pParse,     /* Parsing and code generating context */
  int eTnctType,     /* WHERE_DISTINCT_* value */
  int iTab,          /* A sorting index used to test for distinctness */
  int addrRepeat,    /* Jump to here if not distinct */
  ExprList *pEList,  /* Expression for each element */
  int regElem        /* First element */
){
  int iRet = 0;
  
// ABS Label 444
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 444);
}
int nResultCol = pEList->nExpr;
  
// ABS Label 445
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 445);
}
Vdbe *v = pParse->pVdbe;

  switch( eTnctType ){
    case WHERE_DISTINCT_ORDERED: {
      int i;
      int iJump;              /* Jump destination */
      int regPrev;            /* Previous row content */

      /* Allocate space for the previous row */
      iRet = regPrev = pParse->nMem+1;
      pParse->nMem += nResultCol;

      iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;
      i = 0;

// ABS Label 453
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}
// ABS Label 454
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 454);
}

// ROR Label 455
if((i <= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}
// ROR Label 456
if((i > nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 456);
}
// ROR Label 457
if((i >= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 457);
}
for(; i<nResultCol; i++){
        CollSeq *pColl = sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);
        
// ABS Label 465
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 465);
}
// ABS Label 466
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 466);
}

// AOR Label 467
if(nResultCol / 1 != nResultCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 467);
}
// AOR Label 468
if(nResultCol + 1 != nResultCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 468);
}
// AOR Label 469
if(nResultCol * 1 != nResultCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 469);
}

// ROR Label 470
if((i <= nResultCol - 1) != (i < nResultCol - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 470);
}
// ROR Label 471
if((i > nResultCol - 1) != (i < nResultCol - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 471);
}
// ROR Label 472
if((i >= nResultCol - 1) != (i < nResultCol - 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 472);
}
if( i<nResultCol-1 ){
          
// ABS Label 473
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}

// ABS Label 474
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 474);
}
// ABS Label 475
if(regElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 475);
}

// AOR Label 476
if(regElem - i != regElem + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 476);
}
// AOR Label 477
if(regElem / i != regElem + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 477);
}
// AOR Label 478
if(regElem * i != regElem + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 478);
}

// ABS Label 479
if(iJump < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 479);
}

// ABS Label 480
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 480);
}
// ABS Label 481
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 481);
}

// AOR Label 482
if(regPrev - i != regPrev + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 482);
}
// AOR Label 483
if(regPrev / i != regPrev + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 483);
}
// AOR Label 484
if(regPrev * i != regPrev + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 484);
}
sqlite3VdbeAddOp3(v, OP_Ne, regElem+i, iJump, regPrev+i);
          VdbeCoverage(v);
        }else{
          
// ABS Label 485
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 485);
}

// ABS Label 486
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 486);
}
// ABS Label 487
if(regElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}

// AOR Label 488
if(regElem - i != regElem + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 488);
}
// AOR Label 489
if(regElem / i != regElem + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 489);
}
// AOR Label 490
if(regElem * i != regElem + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 490);
}

// ABS Label 491
if(addrRepeat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 491);
}

// ABS Label 492
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 492);
}
// ABS Label 493
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 493);
}

// AOR Label 494
if(regPrev - i != regPrev + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 494);
}
// AOR Label 495
if(regPrev / i != regPrev + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 495);
}
// AOR Label 496
if(regPrev * i != regPrev + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 496);
}
sqlite3VdbeAddOp3(v, OP_Eq, regElem+i, addrRepeat, regPrev+i);
          VdbeCoverage(v);
         }
        
// ABS Label 463
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 463);
}
sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);
        
// ABS Label 464
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 464);
}
sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);
      };
// ABS Label 458
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}
// ABS Label 459
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 459);
}

// ROR Label 460
if((i <= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 460);
}
// ROR Label 461
if((i > nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}
// ROR Label 462
if((i >= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}

      assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );
      
// ABS Label 446
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 446);
}

// ABS Label 447
if(regElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 447);
}

// ABS Label 448
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 448);
}

// ABS Label 449
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}

// AOR Label 450
if(nResultCol / 1 != nResultCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 450);
}
// AOR Label 451
if(nResultCol + 1 != nResultCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 451);
}
// AOR Label 452
if(nResultCol * 1 != nResultCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 452);
}
sqlite3VdbeAddOp3(v, OP_Copy, regElem, regPrev, nResultCol-1);
      break;
    }

    case WHERE_DISTINCT_UNIQUE: {
      /* nothing to do */
      break;
    }

    default: {
      int r1 = sqlite3GetTempReg(pParse);
      
// ABS Label 497
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 497);
}

// ABS Label 498
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 498);
}

// ABS Label 499
if(addrRepeat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 499);
}

// ABS Label 500
if(regElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}

// ABS Label 501
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 501);
}
sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, regElem, nResultCol);
      VdbeCoverage(v);
      
// ABS Label 502
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 502);
}

// ABS Label 503
if(regElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 503);
}

// ABS Label 504
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 504);
}

// ABS Label 505
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 505);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regElem, nResultCol, r1);
      
// ABS Label 506
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 506);
}

// ABS Label 507
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 507);
}

// ABS Label 508
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 508);
}

// ABS Label 509
if(regElem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 509);
}

// ABS Label 510
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, regElem, nResultCol);
      
// ABS Label 511
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 511);
}
sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
      
// ABS Label 512
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 512);
}

// ABS Label 513
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 513);
}
sqlite3ReleaseTempReg(pParse, r1);
      iRet = iTab;
      break;
    }
  }

  
// ABS Label 514
if(iRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}
return iRet;
}

/*
** This routine runs after codeDistinct().  It makes necessary
** adjustments to the OP_OpenEphemeral opcode that the codeDistinct()
** routine made use of.  This processing must be done separately since
** sometimes codeDistinct is called before the OP_OpenEphemeral is actually
** laid down.
**
** WHERE_DISTINCT_NOOP:
** WHERE_DISTINCT_UNORDERED:
**
**     No adjustments necessary.  This function is a no-op.
**
** WHERE_DISTINCT_UNIQUE:
**
**     The ephemeral table is not needed.  So change the
**     OP_OpenEphemeral opcode into an OP_Noop.
**
** WHERE_DISTINCT_ORDERED:
**
**     The ephemeral table is not needed.  But we do need register
**     iVal to be initialized to NULL.  So change the OP_OpenEphemeral
**     into an OP_Null on the iVal register.
*/
static void fixDistinctOpenEph(
  Parse *pParse,     /* Parsing and code generating context */
  int eTnctType,     /* WHERE_DISTINCT_* value */
  int iVal,          /* Value returned by codeDistinct() */
  int iOpenEphAddr   /* Address of OP_OpenEphemeral instruction for iTab */
){
  
// ABS Label 515
if(eTnctType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 515);
}

// COR Label 516
if((eTnctType == 1 && eTnctType == 2) != (eTnctType == 1 || eTnctType == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 516);
}

// ROR Label 517
if((eTnctType != 1) != (eTnctType == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 517);
}
// ROR Label 518
if((eTnctType != 2) != (eTnctType == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 518);
}

// MCC Label 519
if(eTnctType == 1 && eTnctType == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 519);
}
// MCC Label 520
if(eTnctType == 1 && !(eTnctType == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 520);
}
// MCC Label 521
if(!(eTnctType == 1) && eTnctType == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 521);
}
// MCC Label 522
if(!(eTnctType == 1) && !(eTnctType == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 522);
}
if( eTnctType==WHERE_DISTINCT_UNIQUE || eTnctType==WHERE_DISTINCT_ORDERED ){
    
// ABS Label 523
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 523);
}
Vdbe *v = pParse->pVdbe;
    
// ABS Label 524
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 524);
}

// ABS Label 525
if(iOpenEphAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 525);
}
sqlite3VdbeChangeToNoop(v, iOpenEphAddr);
    if( sqlite3VdbeGetOp(v, iOpenEphAddr+1)->opcode==OP_Explain ){
      
// ABS Label 526
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// ABS Label 527
if(iOpenEphAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 527);
}

// AOR Label 528
if(iOpenEphAddr - 1 != iOpenEphAddr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 528);
}
// AOR Label 529
if(iOpenEphAddr / 1 != iOpenEphAddr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 529);
}
// AOR Label 530
if(iOpenEphAddr * 1 != iOpenEphAddr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 530);
}
sqlite3VdbeChangeToNoop(v, iOpenEphAddr+1);
    }
    
// ABS Label 531
if(eTnctType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 531);
}

// ROR Label 532
if((eTnctType != 2) != (eTnctType == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 532);
}
if( eTnctType==WHERE_DISTINCT_ORDERED ){
      /* Change the OP_OpenEphemeral to an OP_Null that sets the MEM_Cleared 
      ** bit on the first register of the previous value.  This will cause the
      ** OP_Ne added in codeDistinct() to always fail on the first iteration of
      ** the loop even if the first row is all NULLs.  */
      VdbeOp *pOp = sqlite3VdbeGetOp(v, iOpenEphAddr);
      pOp->opcode = OP_Null;
      pOp->p1 = 1;
      pOp->p2 = iVal;
    }
  }
}

#ifdef SQLITE_ENABLE_SORTER_REFERENCES
/*
** This function is called as part of inner-loop generation for a SELECT
** statement with an ORDER BY that is not optimized by an index. It 
** determines the expressions, if any, that the sorter-reference 
** optimization should be used for. The sorter-reference optimization
** is used for SELECT queries like:
**
**   SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10
**
** If the optimization is used for expression "bigblob", then instead of
** storing values read from that column in the sorter records, the PK of
** the row from table t1 is stored instead. Then, as records are extracted from
** the sorter to return to the user, the required value of bigblob is
** retrieved directly from table t1. If the values are very large, this 
** can be more efficient than storing them directly in the sorter records.
**
** The ExprList_item.bSorterRef flag is set for each expression in pEList 
** for which the sorter-reference optimization should be enabled. 
** Additionally, the pSort->aDefer[] array is populated with entries
** for all cursors required to evaluate all selected expressions. Finally.
** output variable (*ppExtra) is set to an expression list containing
** expressions for all extra PK values that should be stored in the
** sorter records.
*/
static void selectExprDefer(
  Parse *pParse,                  /* Leave any error here */
  SortCtx *pSort,                 /* Sorter context */
  ExprList *pEList,               /* Expressions destined for sorter */
  ExprList **ppExtra              /* Expressions to append to sorter record */
){
  int i;
  int nDefer = 0;
  ExprList *pExtra = 0;
  for(i=0; i<pEList->nExpr; i++){
    struct ExprList_item *pItem = &pEList->a[i];
    if( pItem->u.x.iOrderByCol==0 ){
      Expr *pExpr = pItem->pExpr;
      Table *pTab = pExpr->y.pTab;
      if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 && pTab && !IsVirtual(pTab)
       && (pTab->aCol[pExpr->iColumn].colFlags & COLFLAG_SORTERREF)
      ){
        int j;
        for(j=0; j<nDefer; j++){
          if( pSort->aDefer[j].iCsr==pExpr->iTable ) break;
        }
        if( j==nDefer ){
          if( nDefer==ArraySize(pSort->aDefer) ){
            continue;
          }else{
            int nKey = 1;
            int k;
            Index *pPk = 0;
            if( !HasRowid(pTab) ){
              pPk = sqlite3PrimaryKeyIndex(pTab);
              nKey = pPk->nKeyCol;
            }
            for(k=0; k<nKey; k++){
              Expr *pNew = sqlite3PExpr(pParse, TK_COLUMN, 0, 0);
              if( pNew ){
                pNew->iTable = pExpr->iTable;
                pNew->y.pTab = pExpr->y.pTab;
                pNew->iColumn = pPk ? pPk->aiColumn[k] : -1;
                pExtra = sqlite3ExprListAppend(pParse, pExtra, pNew);
              }
            }
            pSort->aDefer[nDefer].pTab = pExpr->y.pTab;
            pSort->aDefer[nDefer].iCsr = pExpr->iTable;
            pSort->aDefer[nDefer].nKey = nKey;
            nDefer++;
          }
        }
        pItem->bSorterRef = 1;
      }
    }
  }
  pSort->nDefer = (u8)nDefer;
  *ppExtra = pExtra;
}
#endif

/*
** This routine generates the code for the inside of the inner loop
** of a SELECT.
**
** If srcTab is negative, then the p->pEList expressions
** are evaluated in order to get the data for this row.  If srcTab is
** zero or more, then data is pulled from srcTab and p->pEList is used only 
** to get the number of columns and the collation sequence for each column.
*/
static void selectInnerLoop(
  Parse *pParse,          /* The parser context */
  Select *p,              /* The complete select statement being coded */
  int srcTab,             /* Pull data from this table if non-negative */
  SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */
  DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */
  SelectDest *pDest,      /* How to dispose of the results */
  int iContinue,          /* Jump here to continue with next row */
  int iBreak              /* Jump here to break out of the inner loop */
){
  
// ABS Label 533
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 533);
}
Vdbe *v = pParse->pVdbe;
  int i;
  int hasDistinct;            /* True if the DISTINCT keyword is present */
  int eDest = pDest->eDest;   /* How to dispose of results */
  
// ABS Label 534
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 534);
}
int iParm = pDest->iSDParm; /* First argument to disposal method */
  int nResultCol;             /* Number of result columns */
  int nPrefixReg = 0;         /* Number of extra registers before regResult */
  RowLoadInfo sRowLoadInfo;   /* Info for deferred row loading */

  /* Usually, regResult is the first cell in an array of memory cells
  ** containing the current result row. In this case regOrig is set to the
  ** same value. However, if the results are being sent to the sorter, the
  ** values for any expressions that are also part of the sort-key are omitted
  ** from this array. In this case regOrig is set to zero.  */
  int regResult;              /* Start of memory holding current results */
  int regOrig;                /* Start of memory holding full result (or 0) */

  assert( v );
  assert( p->pEList!=0 );
  hasDistinct = pDistinct ? pDistinct->eTnctType : WHERE_DISTINCT_NOOP;
  
// ABS Label 535
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}
// ABS Label 536
if(pSort->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}

// COR Label 537
if((pSort || pSort->pOrderBy == 0) != (pSort && pSort->pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 537);
}

// ROR Label 538
if((pSort->pOrderBy != 0) != (pSort->pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 538);
}

// MCC Label 539
if(pSort && pSort->pOrderBy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 539);
}
// MCC Label 540
if(pSort && !(pSort->pOrderBy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 540);
}
// MCC Label 541
if(!(pSort) && pSort->pOrderBy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 541);
}
// MCC Label 542
if(!(pSort) && !(pSort->pOrderBy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 542);
}
if( pSort && pSort->pOrderBy==0 ) { pSort = 0;
}
  
// ABS Label 543
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}

// COR Label 544
if((pSort == 0 || !hasDistinct) != (pSort == 0 && !hasDistinct))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 544);
}

// ROR Label 545
if((pSort != 0) != (pSort == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 545);
}

// MCC Label 546
if(pSort == 0 && !hasDistinct ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 546);
}
// MCC Label 547
if(pSort == 0 && !(!hasDistinct) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 547);
}
// MCC Label 548
if(!(pSort == 0) && !hasDistinct ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 548);
}
// MCC Label 549
if(!(pSort == 0) && !(!hasDistinct) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 549);
}
if( pSort==0 && !hasDistinct ){
    assert( iContinue!=0 );
    
// ABS Label 550
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 550);
}

// ABS Label 551
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 551);
}

// ABS Label 552
if(iContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 552);
}
codeOffset(v, p->iOffset, iContinue);
  }

  /* Pull the requested columns.
  */
  nResultCol = p->pEList->nExpr;

  
// ABS Label 553
if(pDest->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 553);
}

// ROR Label 554
if((pDest->iSdst != 0) != (pDest->iSdst == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 554);
}
if( pDest->iSdst==0 ){
    
// ABS Label 555
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 555);
}
if( pSort ){
      nPrefixReg = pSort->pOrderBy->nExpr;
      if( !(pSort->sortFlags & SORTFLAG_UseSorter) ) { nPrefixReg++;
}
      pParse->nMem += nPrefixReg;
    }
    pDest->iSdst = pParse->nMem+1;
    pParse->nMem += nResultCol;
  }else { 
// ABS Label 556
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 556);
}
// ABS Label 557
if(pDest->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 557);
}
// ABS Label 558
if(pParse->nMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 558);
}

// AOR Label 559
if(pDest->iSdst - nResultCol != pDest->iSdst + nResultCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 559);
}
// AOR Label 560
if(pDest->iSdst / nResultCol != pDest->iSdst + nResultCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 560);
}
// AOR Label 561
if(pDest->iSdst * nResultCol != pDest->iSdst + nResultCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 561);
}

// ROR Label 562
if((pDest->iSdst + nResultCol <= pParse->nMem) != (pDest->iSdst + nResultCol > pParse->nMem))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 562);
}
// ROR Label 563
if((pDest->iSdst + nResultCol < pParse->nMem) != (pDest->iSdst + nResultCol > pParse->nMem))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 563);
}
// ROR Label 564
if((pDest->iSdst + nResultCol >= pParse->nMem) != (pDest->iSdst + nResultCol > pParse->nMem))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 564);
}
if( pDest->iSdst+nResultCol > pParse->nMem ){
    /* This is an error condition that can result, for example, when a SELECT
    ** on the right-hand side of an INSERT contains more result columns than
    ** there are columns in the table on the left.  The error will be caught
    ** and reported later.  But we need to make sure enough memory is allocated
    ** to avoid other spurious errors in the meantime. */
    pParse->nMem += nResultCol;
  };}

  pDest->nSdst = nResultCol;
  regOrig = regResult = pDest->iSdst;
  
// ABS Label 565
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 565);
}

// ROR Label 566
if((srcTab < 0) != (srcTab >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 566);
}
// ROR Label 567
if((srcTab > 0) != (srcTab >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 567);
}
// ROR Label 568
if((srcTab <= 0) != (srcTab >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 568);
}
if( srcTab>=0 ){
    i = 0;

// ABS Label 569
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 569);
}
// ABS Label 570
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 570);
}

// ROR Label 571
if((i <= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 571);
}
// ROR Label 572
if((i > nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 572);
}
// ROR Label 573
if((i >= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 573);
}
for(; i<nResultCol; i++){
      
// ABS Label 579
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 579);
}

// ABS Label 580
if(srcTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 580);
}

// ABS Label 581
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 581);
}

// ABS Label 582
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 582);
}
// ABS Label 583
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 583);
}

// AOR Label 584
if(regResult - i != regResult + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 584);
}
// AOR Label 585
if(regResult / i != regResult + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 585);
}
// AOR Label 586
if(regResult * i != regResult + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 586);
}
sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);
      VdbeComment((v, "%s", p->pEList->a[i].zEName));
    };
// ABS Label 574
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 574);
}
// ABS Label 575
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 575);
}

// ROR Label 576
if((i <= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 576);
}
// ROR Label 577
if((i > nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 577);
}
// ROR Label 578
if((i >= nResultCol) != (i < nResultCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 578);
}

  }else { 
// ABS Label 587
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 587);
}

// ROR Label 588
if((eDest == 3) != (eDest != 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 588);
}
if( eDest!=SRT_Exists ){
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
    ExprList *pExtra = 0;
#endif
    /* If the destination is an EXISTS(...) expression, the actual
    ** values returned by the SELECT are not required.
    */
    u8 ecelFlags;    /* "ecel" is an abbreviation of "ExprCodeExprList" */
    ExprList *pEList;
    
// ABS Label 589
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 589);
}

// COR Label 590
if((eDest == 10 || eDest == 9 && eDest == 13) != (eDest == 10 || eDest == 9 || eDest == 13))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 590);
}
// COR Label 591
if((eDest == 10 && eDest == 9) != (eDest == 10 || eDest == 9))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 591);
}

// ROR Label 592
if((eDest != 10) != (eDest == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 592);
}
// ROR Label 593
if((eDest != 9) != (eDest == 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((eDest != 13) != (eDest == 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}

// MCC Label 595
if(eDest == 10 && eDest == 9 && eDest == 13 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 595);
}
// MCC Label 596
if(eDest == 10 && eDest == 9 && !(eDest == 13) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 596);
}
// MCC Label 597
if(eDest == 10 && !(eDest == 9) && eDest == 13 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 597);
}
// MCC Label 598
if(eDest == 10 && !(eDest == 9) && !(eDest == 13) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 598);
}
// MCC Label 599
if(!(eDest == 10) && eDest == 9 && eDest == 13 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 599);
}
// MCC Label 600
if(!(eDest == 10) && eDest == 9 && !(eDest == 13) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 600);
}
// MCC Label 601
if(!(eDest == 10) && !(eDest == 9) && eDest == 13 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 601);
}
// MCC Label 602
if(!(eDest == 10) && !(eDest == 9) && !(eDest == 13) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 602);
}
if( eDest==SRT_Mem || eDest==SRT_Output || eDest==SRT_Coroutine ){
      ecelFlags = SQLITE_ECEL_DUP;
    }else{
      ecelFlags = 0;
    }
    
// ABS Label 603
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 603);
}
// ABS Label 604
if(hasDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 604);
}
// ABS Label 605
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 605);
}

// COR Label 606
if((pSort && hasDistinct == 0 && eDest != 12 || eDest != 14) != (pSort && hasDistinct == 0 && eDest != 12 && eDest != 14))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 606);
}
// COR Label 607
if((pSort && hasDistinct == 0 || eDest != 12) != (pSort && hasDistinct == 0 && eDest != 12))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 607);
}
// COR Label 608
if((pSort || hasDistinct == 0) != (pSort && hasDistinct == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 608);
}

// ROR Label 609
if((hasDistinct != 0) != (hasDistinct == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 609);
}
// ROR Label 610
if((eDest == 12) != (eDest != 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 610);
}
// ROR Label 611
if((eDest == 14) != (eDest != 14))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 611);
}

// MCC Label 612
if(pSort && hasDistinct == 0 && eDest != 12 && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 612);
}
// MCC Label 613
if(pSort && hasDistinct == 0 && eDest != 12 && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 613);
}
// MCC Label 614
if(pSort && hasDistinct == 0 && !(eDest != 12) && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 614);
}
// MCC Label 615
if(pSort && hasDistinct == 0 && !(eDest != 12) && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 615);
}
// MCC Label 616
if(pSort && !(hasDistinct == 0) && eDest != 12 && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 616);
}
// MCC Label 617
if(pSort && !(hasDistinct == 0) && eDest != 12 && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 617);
}
// MCC Label 618
if(pSort && !(hasDistinct == 0) && !(eDest != 12) && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 618);
}
// MCC Label 619
if(pSort && !(hasDistinct == 0) && !(eDest != 12) && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 619);
}
// MCC Label 620
if(!(pSort) && hasDistinct == 0 && eDest != 12 && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 620);
}
// MCC Label 621
if(!(pSort) && hasDistinct == 0 && eDest != 12 && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 621);
}
// MCC Label 622
if(!(pSort) && hasDistinct == 0 && !(eDest != 12) && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 622);
}
// MCC Label 623
if(!(pSort) && hasDistinct == 0 && !(eDest != 12) && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 623);
}
// MCC Label 624
if(!(pSort) && !(hasDistinct == 0) && eDest != 12 && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(!(pSort) && !(hasDistinct == 0) && eDest != 12 && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
// MCC Label 626
if(!(pSort) && !(hasDistinct == 0) && !(eDest != 12) && eDest != 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 626);
}
// MCC Label 627
if(!(pSort) && !(hasDistinct == 0) && !(eDest != 12) && !(eDest != 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 627);
}
if( pSort && hasDistinct==0 && eDest!=SRT_EphemTab && eDest!=SRT_Table ){
      /* For each expression in p->pEList that is a copy of an expression in
      ** the ORDER BY clause (pSort->pOrderBy), set the associated 
      ** iOrderByCol value to one more than the index of the ORDER BY 
      ** expression within the sort-key that pushOntoSorter() will generate.
      ** This allows the p->pEList field to be omitted from the sorted record,
      ** saving space and CPU cycles.  */
      ecelFlags |= (SQLITE_ECEL_OMITREF|SQLITE_ECEL_REF);

      i = pSort->nOBSat;

// ABS Label 628
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}
// ABS Label 629
if(pSort->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 629);
}

// ROR Label 630
if((i <= pSort->pOrderBy->nExpr) != (i < pSort->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 630);
}
// ROR Label 631
if((i > pSort->pOrderBy->nExpr) != (i < pSort->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 631);
}
// ROR Label 632
if((i >= pSort->pOrderBy->nExpr) != (i < pSort->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 632);
}
for(; i<pSort->pOrderBy->nExpr; i++){
        int j;
        if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){
          p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;
        }
      };
// ABS Label 633
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 633);
}
// ABS Label 634
if(pSort->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 634);
}

// ROR Label 635
if((i <= pSort->pOrderBy->nExpr) != (i < pSort->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 635);
}
// ROR Label 636
if((i > pSort->pOrderBy->nExpr) != (i < pSort->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 636);
}
// ROR Label 637
if((i >= pSort->pOrderBy->nExpr) != (i < pSort->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}

#ifdef SQLITE_ENABLE_SORTER_REFERENCES
      selectExprDefer(pParse, pSort, p->pEList, &pExtra);
      if( pExtra && pParse->db->mallocFailed==0 ){
        /* If there are any extra PK columns to add to the sorter records,
        ** allocate extra memory cells and adjust the OpenEphemeral 
        ** instruction to account for the larger records. This is only
        ** required if there are one or more WITHOUT ROWID tables with
        ** composite primary keys in the SortCtx.aDefer[] array.  */
        VdbeOp *pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
        pOp->p2 += (pExtra->nExpr - pSort->nDefer);
        pOp->p4.pKeyInfo->nAllField += (pExtra->nExpr - pSort->nDefer);
        pParse->nMem += pExtra->nExpr;
      }
#endif

      /* Adjust nResultCol to account for columns that are omitted
      ** from the sorter by the optimizations in this branch */
      pEList = p->pEList;
      i = 0;

// ABS Label 638
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 638);
}
// ABS Label 639
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 639);
}

// ROR Label 640
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 640);
}
// ROR Label 641
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 641);
}
// ROR Label 642
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}
for(; i<pEList->nExpr; i++){
        
// ROR Label 648
if((pEList->a[i].u.x.iOrderByCol <= 0) != (pEList->a[i].u.x.iOrderByCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 648);
}
// ROR Label 649
if((pEList->a[i].u.x.iOrderByCol < 0) != (pEList->a[i].u.x.iOrderByCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 649);
}
// ROR Label 650
if((pEList->a[i].u.x.iOrderByCol >= 0) != (pEList->a[i].u.x.iOrderByCol > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 650);
}
if( pEList->a[i].u.x.iOrderByCol>0
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
         || pEList->a[i].bSorterRef
#endif
        ){
          nResultCol--;
          regOrig = 0;
        }
      };
// ABS Label 643
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 643);
}
// ABS Label 644
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 644);
}

// ROR Label 645
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 645);
}
// ROR Label 646
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 646);
}
// ROR Label 647
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 647);
}


      testcase( regOrig );
      testcase( eDest==SRT_Set );
      testcase( eDest==SRT_Mem );
      testcase( eDest==SRT_Coroutine );
      testcase( eDest==SRT_Output );
      assert( eDest==SRT_Set || eDest==SRT_Mem 
           || eDest==SRT_Coroutine || eDest==SRT_Output
           || eDest==SRT_Upfrom );
    }
    sRowLoadInfo.regResult = regResult;
    sRowLoadInfo.ecelFlags = ecelFlags;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
    sRowLoadInfo.pExtra = pExtra;
    sRowLoadInfo.regExtraResult = regResult + nResultCol;
    if( pExtra ) nResultCol += pExtra->nExpr;
#endif
    
// ABS Label 651
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}
// ABS Label 652
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 652);
}

// COR Label 653
if((p->iLimit && (ecelFlags & 8) != 0 || nPrefixReg > 0) != (p->iLimit && (ecelFlags & 8) != 0 && nPrefixReg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 653);
}
// COR Label 654
if((p->iLimit || (ecelFlags & 8) != 0) != (p->iLimit && (ecelFlags & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 654);
}

// ROR Label 655
if(((ecelFlags & 8) == 0) != ((ecelFlags & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 655);
}
// ROR Label 656
if((nPrefixReg <= 0) != (nPrefixReg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 656);
}
// ROR Label 657
if((nPrefixReg < 0) != (nPrefixReg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 657);
}
// ROR Label 658
if((nPrefixReg >= 0) != (nPrefixReg > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 658);
}

// MCC Label 659
if(p->iLimit && (ecelFlags & 8) != 0 && nPrefixReg > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 659);
}
// MCC Label 660
if(p->iLimit && (ecelFlags & 8) != 0 && !(nPrefixReg > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 660);
}
// MCC Label 661
if(p->iLimit && !((ecelFlags & 8) != 0) && nPrefixReg > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 661);
}
// MCC Label 662
if(p->iLimit && !((ecelFlags & 8) != 0) && !(nPrefixReg > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 662);
}
// MCC Label 663
if(!(p->iLimit) && (ecelFlags & 8) != 0 && nPrefixReg > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 663);
}
// MCC Label 664
if(!(p->iLimit) && (ecelFlags & 8) != 0 && !(nPrefixReg > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 664);
}
// MCC Label 665
if(!(p->iLimit) && !((ecelFlags & 8) != 0) && nPrefixReg > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 665);
}
// MCC Label 666
if(!(p->iLimit) && !((ecelFlags & 8) != 0) && !(nPrefixReg > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 666);
}
if( p->iLimit
     && (ecelFlags & SQLITE_ECEL_OMITREF)!=0 
     && nPrefixReg>0
    ){
      assert( pSort!=0 );
      assert( hasDistinct==0 );
      pSort->pDeferredRowLoad = &sRowLoadInfo;
      regOrig = 0;
    }else{
      
// ABS Label 667
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 667);
}

// ABS Label 668
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 668);
}
innerLoopLoadRow(pParse, p, &sRowLoadInfo);
    }
  };}


  /* If the DISTINCT keyword was present on the SELECT statement
  ** and this row has been seen before, then do not make this row
  ** part of the result.
  */
  
// ABS Label 669
if(hasDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}
if( hasDistinct ){
    int eType = pDistinct->eTnctType;
    
// ABS Label 670
if(pDistinct->tabTnct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 670);
}
int iTab = pDistinct->tabTnct;
    assert( nResultCol==p->pEList->nExpr );
    iTab = codeDistinct(pParse, eType, iTab, iContinue, p->pEList, regResult);
    
// ABS Label 671
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}

// ABS Label 672
if(eType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}

// ABS Label 673
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 673);
}

// ABS Label 674
if(pDistinct->addrTnct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 674);
}
fixDistinctOpenEph(pParse, eType, iTab, pDistinct->addrTnct);
    
// ABS Label 675
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 675);
}

// ROR Label 676
if((pSort != 0) != (pSort == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 676);
}
if( pSort==0 ){
      
// ABS Label 677
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 677);
}

// ABS Label 678
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}

// ABS Label 679
if(iContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 679);
}
codeOffset(v, p->iOffset, iContinue);
    }
  }

  switch( eDest ){
    /* In this mode, write each query result to the key of the temporary
    ** table iParm.
    */
#ifndef SQLITE_OMIT_COMPOUND_SELECT
    case SRT_Union: {
      int r1;
      r1 = sqlite3GetTempReg(pParse);
      
// ABS Label 680
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}

// ABS Label 681
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 681);
}

// ABS Label 682
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 682);
}

// ABS Label 683
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 683);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);
      
// ABS Label 684
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 684);
}

// ABS Label 685
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 685);
}

// ABS Label 686
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}

// ABS Label 687
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}

// ABS Label 688
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);
      
// ABS Label 689
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}

// ABS Label 690
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}
sqlite3ReleaseTempReg(pParse, r1);
      break;
    }

    /* Construct a record from the query result, but instead of
    ** saving that record, use it as a key to delete elements from
    ** the temporary table iParm.
    */
    case SRT_Except: {
      
// ABS Label 691
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}

// ABS Label 692
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}

// ABS Label 693
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 693);
}

// ABS Label 694
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}
sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nResultCol);
      break;
    }
#endif /* SQLITE_OMIT_COMPOUND_SELECT */

    /* Store the result as data using a unique key.
    */
    case SRT_Fifo:
    case SRT_DistFifo:
    case SRT_Table:
    case SRT_EphemTab: {
      int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);
      testcase( eDest==SRT_Table );
      testcase( eDest==SRT_EphemTab );
      testcase( eDest==SRT_Fifo );
      testcase( eDest==SRT_DistFifo );
      
// ABS Label 695
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}

// ABS Label 696
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}

// ABS Label 697
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}

// ABS Label 698
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 698);
}
// ABS Label 699
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 699);
}

// AOR Label 700
if(r1 - nPrefixReg != r1 + nPrefixReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 700);
}
// AOR Label 701
if(r1 / nPrefixReg != r1 + nPrefixReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 701);
}
// AOR Label 702
if(r1 * nPrefixReg != r1 + nPrefixReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 702);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1+nPrefixReg);
#ifndef SQLITE_OMIT_CTE
      
// ABS Label 709
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}

// ROR Label 710
if((eDest != 5) != (eDest == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 710);
}
if( eDest==SRT_DistFifo ){
        /* If the destination is DistFifo, then cursor (iParm+1) is open
        ** on an ephemeral index. If the current row is already present
        ** in the index, do not write it to the output. If not, add the
        ** current row to the index and proceed with writing it to the
        ** output table as well.  */
        int addr = sqlite3VdbeCurrentAddr(v) + 4;
        
// ABS Label 711
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 711);
}

// ABS Label 712
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}

// AOR Label 713
if(iParm - 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 713);
}
// AOR Label 714
if(iParm / 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 714);
}
// AOR Label 715
if(iParm * 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 715);
}

// ABS Label 716
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}

// ABS Label 717
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 717);
}
sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, addr, r1, 0);
        VdbeCoverage(v);
        
// ABS Label 718
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 718);
}

// ABS Label 719
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 719);
}

// AOR Label 720
if(iParm - 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 720);
}
// AOR Label 721
if(iParm / 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 721);
}
// AOR Label 722
if(iParm * 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 722);
}

// ABS Label 723
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 723);
}

// ABS Label 724
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 724);
}

// ABS Label 725
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 725);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm+1, r1,regResult,nResultCol);
        assert( pSort==0 );
      }
#endif
      
// ABS Label 726
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 726);
}
if( pSort ){
        assert( regResult==regOrig );
        
// ABS Label 727
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}

// ABS Label 728
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}

// ABS Label 729
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}

// ABS Label 730
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
// ABS Label 731
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

// AOR Label 732
if(r1 - nPrefixReg != r1 + nPrefixReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 732);
}
// AOR Label 733
if(r1 / nPrefixReg != r1 + nPrefixReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 733);
}
// AOR Label 734
if(r1 * nPrefixReg != r1 + nPrefixReg)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 734);
}

// ABS Label 735
if(regOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 735);
}

// ABS Label 736
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 736);
}
pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);
      }else{
        int r2 = sqlite3GetTempReg(pParse);
        
// ABS Label 737
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 737);
}

// ABS Label 738
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 738);
}

// ABS Label 739
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 739);
}
sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);
        
// ABS Label 740
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}

// ABS Label 741
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}

// ABS Label 742
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}

// ABS Label 743
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}
sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);
        
// ABS Label 744
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 744);
}
sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
        
// ABS Label 745
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 745);
}

// ABS Label 746
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 746);
}
sqlite3ReleaseTempReg(pParse, r2);
      }
      
// ABS Label 703
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 703);
}

// ABS Label 704
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 704);
}

// ABS Label 705
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}

// AOR Label 706
if(nPrefixReg - 1 != nPrefixReg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 706);
}
// AOR Label 707
if(nPrefixReg / 1 != nPrefixReg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 707);
}
// AOR Label 708
if(nPrefixReg * 1 != nPrefixReg + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 708);
}
sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);
      break;
    }

    case SRT_Upfrom: {
      
// ABS Label 747
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}
if( pSort ){
        
// ABS Label 748
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// ABS Label 749
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 749);
}

// ABS Label 750
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 750);
}

// ABS Label 751
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 751);
}

// ABS Label 752
if(regOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 752);
}

// ABS Label 753
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 753);
}

// ABS Label 754
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 754);
}
pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
      }else{
        
// ABS Label 755
if(pDest->iSDParm2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}
int i2 = pDest->iSDParm2;
        int r1 = sqlite3GetTempReg(pParse);

        /* If the UPDATE FROM join is an aggregate that matches no rows, it
        ** might still be trying to return one row, because that is what
        ** aggregates do.  Don't record that empty row in the output table. */
        
// ABS Label 756
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}

// ABS Label 757
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}

// ABS Label 758
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}
sqlite3VdbeAddOp2(v, OP_IsNull, regResult, iBreak); VdbeCoverage(v);

        
// ABS Label 759
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}

// ABS Label 760
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}

// AOR Label 761
if(regResult - (i2 < 0) != regResult + (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 761);
}
// AOR Label 762
if(regResult / (i2 < 0) != regResult + (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 762);
}
// AOR Label 763
if(regResult * (i2 < 0) != regResult + (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 763);
}

// ABS Label 764
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}

// AOR Label 765
if(nResultCol / (i2 < 0) != nResultCol - (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 765);
}
// AOR Label 766
if(nResultCol + (i2 < 0) != nResultCol - (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 766);
}
// AOR Label 767
if(nResultCol * (i2 < 0) != nResultCol - (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 767);
}

// ABS Label 768
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 768);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord,
                          regResult+(i2<0), nResultCol-(i2<0), r1);
        
// ABS Label 769
if(i2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 769);
}

// ROR Label 770
if((i2 <= 0) != (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 770);
}
// ROR Label 771
if((i2 > 0) != (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 771);
}
// ROR Label 772
if((i2 >= 0) != (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 772);
}
if( i2<0 ){
          
// ABS Label 773
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 773);
}

// ABS Label 774
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}

// ABS Label 775
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// ABS Label 776
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 776);
}
sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);
        }else{
          
// ABS Label 777
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 777);
}

// ABS Label 778
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 778);
}

// ABS Label 779
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 779);
}

// ABS Label 780
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 780);
}

// ABS Label 781
if(i2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 781);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);
        }
      }
      break;
    }

#ifndef SQLITE_OMIT_SUBQUERY
    /* If we are creating a set for an "expr IN (SELECT ...)" construct,
    ** then there should be a single item on the stack.  Write this
    ** item into the set table with bogus data.
    */
    case SRT_Set: {
      
// ABS Label 782
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 782);
}
if( pSort ){
        /* At first glance you would think we could optimize out the
        ** ORDER BY in this case since the order of entries in the set
        ** does not matter.  But there might be a LIMIT clause, in which
        ** case the order does matter */
        
// ABS Label 783
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}

// ABS Label 784
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}

// ABS Label 785
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// ABS Label 786
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 786);
}

// ABS Label 787
if(regOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 787);
}

// ABS Label 788
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 788);
}

// ABS Label 789
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 789);
}
pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
      }else{
        int r1 = sqlite3GetTempReg(pParse);
        assert( sqlite3Strlen30(pDest->zAffSdst)==nResultCol );
        
// ABS Label 790
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 790);
}

// ABS Label 791
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 791);
}

// ABS Label 792
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 792);
}

// ABS Label 793
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}

// ABS Label 794
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 794);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol, 
            r1, pDest->zAffSdst, nResultCol);
        
// ABS Label 795
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 795);
}

// ABS Label 796
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}

// ABS Label 797
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}

// ABS Label 798
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}

// ABS Label 799
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);
        
// ABS Label 800
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}

// ABS Label 801
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}
sqlite3ReleaseTempReg(pParse, r1);
      }
      break;
    }


    /* If any row exist in the result set, record that fact and abort.
    */
    case SRT_Exists: {
      
// ABS Label 802
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 802);
}

// ABS Label 803
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 803);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);
      /* The LIMIT clause will terminate the loop for us */
      break;
    }

    /* If this is a scalar select that is part of an expression, then
    ** store the results in the appropriate memory cell or array of 
    ** memory cells and break out of the scan loop.
    */
    case SRT_Mem: {
      
// ABS Label 804
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 804);
}
if( pSort ){
        assert( nResultCol<=pDest->nSdst );
        
// ABS Label 805
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}

// ABS Label 806
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}

// ABS Label 807
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}

// ABS Label 808
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}

// ABS Label 809
if(regOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}

// ABS Label 810
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}

// ABS Label 811
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
      }else{
        assert( nResultCol==pDest->nSdst );
        assert( regResult==iParm );
        /* The LIMIT clause will jump out of the loop for us */
      }
      break;
    }
#endif /* #ifndef SQLITE_OMIT_SUBQUERY */

    case SRT_Coroutine:       /* Send data to a co-routine */
    case SRT_Output: {        /* Return the results */
      testcase( eDest==SRT_Coroutine );
      testcase( eDest==SRT_Output );
      
// ABS Label 812
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}
if( pSort ){
        
// ABS Label 813
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}

// ABS Label 814
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ABS Label 815
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}

// ABS Label 816
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// ABS Label 817
if(regOrig < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 817);
}

// ABS Label 818
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 818);
}

// ABS Label 819
if(nPrefixReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 819);
}
pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,
                       nPrefixReg);
      }else { 
// ABS Label 820
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}

// ROR Label 821
if((eDest != 13) != (eDest == 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 821);
}
if( eDest==SRT_Coroutine ){
        
// ABS Label 822
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}

// ABS Label 823
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}
sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
      }else{
        
// ABS Label 824
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}

// ABS Label 825
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 825);
}

// ABS Label 826
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 826);
}
sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nResultCol);
      };}

      break;
    }

#ifndef SQLITE_OMIT_CTE
    /* Write the results into a priority queue that is order according to
    ** pDest->pOrderBy (in pSO).  pDest->iSDParm (in iParm) is the cursor for an
    ** index with pSO->nExpr+2 columns.  Build a key using pSO for the first
    ** pSO->nExpr columns, then make sure all keys are unique by adding a
    ** final OP_Sequence column.  The last column is the record as a blob.
    */
    case SRT_DistQueue:
    case SRT_Queue: {
      int nKey;
      int r1, r2, r3;
      int addrTest = 0;
      ExprList *pSO;
      pSO = pDest->pOrderBy;
      assert( pSO );
      nKey = pSO->nExpr;
      r1 = sqlite3GetTempReg(pParse);
      r2 = sqlite3GetTempRange(pParse, nKey+2);
      r3 = r2+nKey+1;
      
// ABS Label 861
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 861);
}

// ROR Label 862
if((eDest != 6) != (eDest == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 862);
}
if( eDest==SRT_DistQueue ){
        /* If the destination is DistQueue, then cursor (iParm+1) is open
        ** on a second ephemeral index that holds all values every previously
        ** added to the queue. */
        addrTest = sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, 0, 
                                        regResult, nResultCol);
        VdbeCoverage(v);
      }
      
// ABS Label 827
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}

// ABS Label 828
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// ABS Label 829
if(nResultCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}

// ABS Label 830
if(r3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r3);
      
// ABS Label 863
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 863);
}

// ROR Label 864
if((eDest != 6) != (eDest == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 864);
}
if( eDest==SRT_DistQueue ){
        
// ABS Label 865
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 865);
}

// ABS Label 866
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 866);
}

// AOR Label 867
if(iParm - 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 867);
}
// AOR Label 868
if(iParm / 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 868);
}
// AOR Label 869
if(iParm * 1 != iParm + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 869);
}

// ABS Label 870
if(r3 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 870);
}
sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm+1, r3);
        
// ABS Label 871
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 871);
}
sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);
      }
      i = 0;

// ABS Label 872
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 872);
}
// ABS Label 873
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 873);
}

// ROR Label 874
if((i <= nKey) != (i < nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 874);
}
// ROR Label 875
if((i > nKey) != (i < nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 875);
}
// ROR Label 876
if((i >= nKey) != (i < nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 876);
}
for(; i<nKey; i++){
        
// ABS Label 882
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 882);
}

// ABS Label 883
if(regResult < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 883);
}

// AOR Label 884
if(regResult + pSO->a[i].u.x.iOrderByCol / 1 != regResult + pSO->a[i].u.x.iOrderByCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 884);
}
// AOR Label 885
if(regResult + pSO->a[i].u.x.iOrderByCol + 1 != regResult + pSO->a[i].u.x.iOrderByCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 885);
}
// AOR Label 886
if(regResult + pSO->a[i].u.x.iOrderByCol * 1 != regResult + pSO->a[i].u.x.iOrderByCol - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 886);
}
// AOR Label 887
if(regResult - pSO->a[i].u.x.iOrderByCol != regResult + pSO->a[i].u.x.iOrderByCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 887);
}
// AOR Label 888
if(regResult / pSO->a[i].u.x.iOrderByCol != regResult + pSO->a[i].u.x.iOrderByCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 888);
}
// AOR Label 889
if(regResult * pSO->a[i].u.x.iOrderByCol != regResult + pSO->a[i].u.x.iOrderByCol)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 889);
}

// ABS Label 890
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 890);
}
// ABS Label 891
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 891);
}

// AOR Label 892
if(r2 - i != r2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 892);
}
// AOR Label 893
if(r2 / i != r2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 893);
}
// AOR Label 894
if(r2 * i != r2 + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 894);
}
sqlite3VdbeAddOp2(v, OP_SCopy,
                          regResult + pSO->a[i].u.x.iOrderByCol - 1,
                          r2+i);
      };
// ABS Label 877
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 877);
}
// ABS Label 878
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 878);
}

// ROR Label 879
if((i <= nKey) != (i < nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 879);
}
// ROR Label 880
if((i > nKey) != (i < nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 880);
}
// ROR Label 881
if((i >= nKey) != (i < nKey))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 881);
}

      
// ABS Label 831
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 831);
}

// ABS Label 832
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 832);
}

// ABS Label 833
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 833);
}
// ABS Label 834
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 834);
}

// AOR Label 835
if(r2 - nKey != r2 + nKey)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 835);
}
// AOR Label 836
if(r2 / nKey != r2 + nKey)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 836);
}
// AOR Label 837
if(r2 * nKey != r2 + nKey)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 837);
}
sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2+nKey);
      
// ABS Label 838
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 838);
}

// ABS Label 839
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 839);
}

// ABS Label 840
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 840);
}

// AOR Label 841
if(nKey - 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 841);
}
// AOR Label 842
if(nKey / 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 842);
}
// AOR Label 843
if(nKey * 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 843);
}

// ABS Label 844
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 844);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey+2, r1);
      
// ABS Label 845
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 845);
}

// ABS Label 846
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 846);
}

// ABS Label 847
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 847);
}

// ABS Label 848
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 848);
}

// ABS Label 849
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 849);
}

// AOR Label 850
if(nKey - 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 850);
}
// AOR Label 851
if(nKey / 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 851);
}
// AOR Label 852
if(nKey * 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 852);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, r2, nKey+2);
      
// ABS Label 895
if(addrTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 895);
}
if( addrTest ) { 
// ABS Label 896
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 896);
}

// ABS Label 897
if(addrTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 897);
}
sqlite3VdbeJumpHere(v, addrTest);
}
      
// ABS Label 853
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 853);
}

// ABS Label 854
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 854);
}
sqlite3ReleaseTempReg(pParse, r1);
      
// ABS Label 855
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 855);
}

// ABS Label 856
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 856);
}

// ABS Label 857
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 857);
}

// AOR Label 858
if(nKey - 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 858);
}
// AOR Label 859
if(nKey / 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 859);
}
// AOR Label 860
if(nKey * 2 != nKey + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 860);
}
sqlite3ReleaseTempRange(pParse, r2, nKey+2);
      break;
    }
#endif /* SQLITE_OMIT_CTE */



#if !defined(SQLITE_OMIT_TRIGGER)
    /* Discard the results.  This is used for SELECT statements inside
    ** the body of a TRIGGER.  The purpose of such selects is to call
    ** user-defined functions that have side effects.  We do not care
    ** about the actual results of the select.
    */
    default: {
      assert( eDest==SRT_Discard );
      break;
    }
#endif
  }

  /* Jump to the end of the loop if the LIMIT is reached.  Except, if
  ** there is a sorter, in which case the sorter has already limited
  ** the output for us.
  */
  
// ABS Label 898
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 898);
}
// ABS Label 899
if(pSort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 899);
}

// COR Label 900
if((pSort == 0 || p->iLimit) != (pSort == 0 && p->iLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 900);
}

// ROR Label 901
if((pSort != 0) != (pSort == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 901);
}

// MCC Label 902
if(pSort == 0 && p->iLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 902);
}
// MCC Label 903
if(pSort == 0 && !(p->iLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 903);
}
// MCC Label 904
if(!(pSort == 0) && p->iLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 904);
}
// MCC Label 905
if(!(pSort == 0) && !(p->iLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 905);
}
if( pSort==0 && p->iLimit ){
    
// ABS Label 906
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 906);
}

// ABS Label 907
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 907);
}

// ABS Label 908
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 908);
}
sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);
  }
}

/*
** Allocate a KeyInfo object sufficient for an index of N key columns and
** X extra columns.
*/
KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){
  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);
  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);
  
// ABS Label 909
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 909);
}
if( p ){
    p->aSortFlags = (u8*)&p->aColl[N+X];
    p->nKeyField = (u16)N;
    p->nAllField = (u16)(N+X);
    p->enc = ENC(db);
    p->db = db;
    p->nRef = 1;
    memset(&p[1], 0, nExtra);
  }else{
    
// ABS Label 910
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 910);
}
sqlite3OomFault(db);
  }
  
// ABS Label 911
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 911);
}
return p;
}

/*
** Deallocate a KeyInfo object
*/
void sqlite3KeyInfoUnref(KeyInfo *p){
  
// ABS Label 912
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 912);
}
if( p ){
    assert( p->nRef>0 );
    p->nRef--;
    
// ABS Label 913
if(p->nRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 913);
}

// ROR Label 914
if((p->nRef != 0) != (p->nRef == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 914);
}
if( p->nRef==0 ) { 
// ABS Label 915
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 915);
}
sqlite3DbFreeNN(p->db, p);
}
  }
}

/*
** Make a new pointer to a KeyInfo object
*/
KeyInfo *sqlite3KeyInfoRef(KeyInfo *p){
  
// ABS Label 916
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 916);
}
if( p ){
    assert( p->nRef>0 );
    p->nRef++;
  }
  
// ABS Label 917
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 917);
}
return p;
}

#ifdef SQLITE_DEBUG
/*
** Return TRUE if a KeyInfo object can be change.  The KeyInfo object
** can only be changed if this is just a single reference to the object.
**
** This routine is used only inside of assert() statements.
*/
int sqlite3KeyInfoIsWriteable(KeyInfo *p){ return p->nRef==1; }
#endif /* SQLITE_DEBUG */

/*
** Given an expression list, generate a KeyInfo structure that records
** the collating sequence for each expression in that expression list.
**
** If the ExprList is an ORDER BY or GROUP BY clause then the resulting
** KeyInfo structure is appropriate for initializing a virtual index to
** implement that clause.  If the ExprList is the result set of a SELECT
** then the KeyInfo structure is appropriate for initializing a virtual
** index to implement a DISTINCT test.
**
** Space to hold the KeyInfo structure is obtained from malloc.  The calling
** function is responsible for seeing that this structure is eventually
** freed.
*/
KeyInfo *sqlite3KeyInfoFromExprList(
  Parse *pParse,       /* Parsing context */
  ExprList *pList,     /* Form the KeyInfo object from this ExprList */
  int iStart,          /* Begin with this column of pList */
  int nExtra           /* Add this many extra columns to the end */
){
  int nExpr;
  KeyInfo *pInfo;
  struct ExprList_item *pItem;
  
// ABS Label 918
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 918);
}
sqlite3 *db = pParse->db;
  int i;

  nExpr = pList->nExpr;
  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);
  
// ABS Label 919
if(pInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 919);
}
if( pInfo ){
    assert( sqlite3KeyInfoIsWriteable(pInfo) );
    i = iStart , pItem = pList->a + iStart;

// ABS Label 920
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 920);
}
// ABS Label 921
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 921);
}

// ROR Label 922
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 922);
}
// ROR Label 923
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 923);
}
// ROR Label 924
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 924);
}
for(; i<nExpr; i++, pItem++){
      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
      pInfo->aSortFlags[i-iStart] = pItem->sortFlags;
    };
// ABS Label 925
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 925);
}
// ABS Label 926
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 926);
}

// ROR Label 927
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 927);
}
// ROR Label 928
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 928);
}
// ROR Label 929
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 929);
}

  }
  
// ABS Label 930
if(pInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 930);
}
return pInfo;
}

/*
** Name of the connection operator, used for error messages.
*/
const char *sqlite3SelectOpName(int id){
  char *z;
  switch( id ){
    case TK_ALL:       z = "UNION ALL";   break;
    case TK_INTERSECT: z = "INTERSECT";   break;
    case TK_EXCEPT:    z = "EXCEPT";      break;
    default:           z = "UNION";       break;
  }
  return z;
}

#ifndef SQLITE_OMIT_EXPLAIN
/*
** Unless an "EXPLAIN QUERY PLAN" command is being processed, this function
** is a no-op. Otherwise, it adds a single row of output to the EQP result,
** where the caption is of the form:
**
**   "USE TEMP B-TREE FOR xxx"
**
** where xxx is one of "DISTINCT", "ORDER BY" or "GROUP BY". Exactly which
** is determined by the zUsage argument.
*/
static void explainTempTable(Parse *pParse, const char *zUsage){
  ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s", zUsage));
}

/*
** Assign expression b to lvalue a. A second, no-op, version of this macro
** is provided when SQLITE_OMIT_EXPLAIN is defined. This allows the code
** in sqlite3Select() to assign values to structure member variables that
** only exist if SQLITE_OMIT_EXPLAIN is not defined without polluting the
** code with #ifndef directives.
*/
# define explainSetInteger(a, b) a = b

#else
/* No-op versions of the explainXXX() functions and macros. */
# define explainTempTable(y,z)
# define explainSetInteger(y,z)
#endif


/*
** If the inner loop was generated using a non-null pOrderBy argument,
** then the results were placed in a sorter.  After the loop is terminated
** we need to run the sorter and output the results.  The following
** routine generates the code needed to do that.
*/
static void generateSortTail(
  Parse *pParse,    /* Parsing context */
  Select *p,        /* The SELECT statement */
  SortCtx *pSort,   /* Information on the ORDER BY clause */
  int nColumn,      /* Number of columns of data */
  SelectDest *pDest /* Write the sorted results here */
){
  
// ABS Label 933
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 933);
}
Vdbe *v = pParse->pVdbe;                     /* The prepared statement */
  
// ABS Label 934
if(pSort->labelDone < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 934);
}
int addrBreak = pSort->labelDone;            /* Jump here to exit loop */
  int addrContinue = sqlite3VdbeMakeLabel(pParse);/* Jump here for next cycle */
  int addr;                       /* Top of output loop. Jump for Next. */
  int addrOnce = 0;
  int iTab;
  
// ABS Label 935
if(pSort->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 935);
}
ExprList *pOrderBy = pSort->pOrderBy;
  int eDest = pDest->eDest;
  
// ABS Label 936
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 936);
}
int iParm = pDest->iSDParm;
  int regRow;
  int regRowid;
  int iCol;
  int nKey;                       /* Number of key columns in sorter record */
  int iSortTab;                   /* Sorter cursor to read from */
  int i;
  int bSeq;                       /* True if sorter record includes seq. no. */
  int nRefKey = 0;
  struct ExprList_item *aOutEx = p->pEList->a;

  assert( addrBreak<0 );
  
// ABS Label 941
if(pSort->labelBkOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 941);
}
if( pSort->labelBkOut ){
    
// ABS Label 942
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 942);
}

// ABS Label 943
if(pSort->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 943);
}

// ABS Label 944
if(pSort->labelBkOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 944);
}
sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);
    
// ABS Label 945
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 945);
}

// ABS Label 946
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 946);
}
sqlite3VdbeGoto(v, addrBreak);
    
// ABS Label 947
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 947);
}

// ABS Label 948
if(pSort->labelBkOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 948);
}
sqlite3VdbeResolveLabel(v, pSort->labelBkOut);
  }

#ifdef SQLITE_ENABLE_SORTER_REFERENCES
  /* Open any cursors needed for sorter-reference expressions */
  for(i=0; i<pSort->nDefer; i++){
    Table *pTab = pSort->aDefer[i].pTab;
    int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
    sqlite3OpenTable(pParse, pSort->aDefer[i].iCsr, iDb, pTab, OP_OpenRead);
    nRefKey = MAX(nRefKey, pSort->aDefer[i].nKey);
  }
#endif

  iTab = pSort->iECursor;
  
// ABS Label 949
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 949);
}

// COR Label 950
if((eDest == 9 || eDest == 13 && eDest == 10) != (eDest == 9 || eDest == 13 || eDest == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 950);
}
// COR Label 951
if((eDest == 9 && eDest == 13) != (eDest == 9 || eDest == 13))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 951);
}

// ROR Label 952
if((eDest != 9) != (eDest == 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 952);
}
// ROR Label 953
if((eDest != 13) != (eDest == 13))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 953);
}
// ROR Label 954
if((eDest != 10) != (eDest == 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 954);
}

// MCC Label 955
if(eDest == 9 && eDest == 13 && eDest == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 955);
}
// MCC Label 956
if(eDest == 9 && eDest == 13 && !(eDest == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 956);
}
// MCC Label 957
if(eDest == 9 && !(eDest == 13) && eDest == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 957);
}
// MCC Label 958
if(eDest == 9 && !(eDest == 13) && !(eDest == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 958);
}
// MCC Label 959
if(!(eDest == 9) && eDest == 13 && eDest == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 959);
}
// MCC Label 960
if(!(eDest == 9) && eDest == 13 && !(eDest == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 960);
}
// MCC Label 961
if(!(eDest == 9) && !(eDest == 13) && eDest == 10 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 961);
}
// MCC Label 962
if(!(eDest == 9) && !(eDest == 13) && !(eDest == 10) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 962);
}
if( eDest==SRT_Output || eDest==SRT_Coroutine || eDest==SRT_Mem ){
    regRowid = 0;
    regRow = pDest->iSdst;
  }else{
    regRowid = sqlite3GetTempReg(pParse);
    
// ABS Label 963
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 963);
}

// COR Label 964
if((eDest == 12 && eDest == 14) != (eDest == 12 || eDest == 14))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 964);
}

// ROR Label 965
if((eDest != 12) != (eDest == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 965);
}
// ROR Label 966
if((eDest != 14) != (eDest == 14))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 966);
}

// MCC Label 967
if(eDest == 12 && eDest == 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 967);
}
// MCC Label 968
if(eDest == 12 && !(eDest == 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 968);
}
// MCC Label 969
if(!(eDest == 12) && eDest == 14 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 969);
}
// MCC Label 970
if(!(eDest == 12) && !(eDest == 14) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 970);
}
if( eDest==SRT_EphemTab || eDest==SRT_Table ){
      regRow = sqlite3GetTempReg(pParse);
      nColumn = 0;
    }else{
      regRow = sqlite3GetTempRange(pParse, nColumn);
    }
  }
  nKey = pOrderBy->nExpr - pSort->nOBSat;
  
// AOR Label 971
if(pSort->sortFlags | 1 != pSort->sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 971);
}
// AOR Label 972
if(pSort->sortFlags ^ 1 != pSort->sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 972);
}
if( pSort->sortFlags & SORTFLAG_UseSorter ){
    int regSortOut = ++pParse->nMem;
    iSortTab = pParse->nTab++;
    
// ABS Label 995
if(pSort->labelBkOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 995);
}
if( pSort->labelBkOut ){
      addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
    }
    
// ABS Label 973
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 973);
}

// ABS Label 974
if(iSortTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 974);
}

// ABS Label 975
if(regSortOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 975);
}

// ABS Label 976
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 976);
}
// ABS Label 977
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 977);
}
// ABS Label 978
if(nRefKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 978);
}

// AOR Label 979
if(nKey + 1 + nColumn - nRefKey != nKey + 1 + nColumn + nRefKey)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 979);
}
// AOR Label 980
if(nKey + 1 + nColumn / nRefKey != nKey + 1 + nColumn + nRefKey)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 980);
}
// AOR Label 981
if(nKey + 1 + nColumn * nRefKey != nKey + 1 + nColumn + nRefKey)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 981);
}
// AOR Label 982
if(nKey + 1 - nColumn != nKey + 1 + nColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 982);
}
// AOR Label 983
if(nKey + 1 / nColumn != nKey + 1 + nColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 983);
}
// AOR Label 984
if(nKey + 1 * nColumn != nKey + 1 + nColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 984);
}
// AOR Label 985
if(nKey - 1 != nKey + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 985);
}
// AOR Label 986
if(nKey / 1 != nKey + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 986);
}
// AOR Label 987
if(nKey * 1 != nKey + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 987);
}
sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut, 
        nKey+1+nColumn+nRefKey);
    
// ABS Label 996
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 996);
}
if( addrOnce ) { 
// ABS Label 997
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 997);
}

// ABS Label 998
if(addrOnce < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 998);
}
sqlite3VdbeJumpHere(v, addrOnce);
}
    addr = 1 + sqlite3VdbeAddOp2(v, OP_SorterSort, iTab, addrBreak);
    VdbeCoverage(v);
    
// ABS Label 988
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 988);
}

// ABS Label 989
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 989);
}

// ABS Label 990
if(addrContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 990);
}
codeOffset(v, p->iOffset, addrContinue);
    
// ABS Label 991
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 991);
}

// ABS Label 992
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 992);
}

// ABS Label 993
if(regSortOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 993);
}

// ABS Label 994
if(iSortTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 994);
}
sqlite3VdbeAddOp3(v, OP_SorterData, iTab, regSortOut, iSortTab);
    bSeq = 0;
  }else{
    addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak); VdbeCoverage(v);
    
// ABS Label 999
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 999);
}

// ABS Label 1000
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1000);
}

// ABS Label 1001
if(addrContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1001);
}
codeOffset(v, p->iOffset, addrContinue);
    iSortTab = iTab;
    bSeq = 1;
  }
  i = 0 , iCol = nKey + bSeq - 1;

// ABS Label 1002
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1002);
}
// ABS Label 1003
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1003);
}

// ROR Label 1004
if((i <= nColumn) != (i < nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1004);
}
// ROR Label 1005
if((i > nColumn) != (i < nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1005);
}
// ROR Label 1006
if((i >= nColumn) != (i < nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1006);
}
for(; i<nColumn; i++){
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
    if( aOutEx[i].bSorterRef ) continue;
#endif
    
// ROR Label 1012
if((aOutEx[i].u.x.iOrderByCol != 0) != (aOutEx[i].u.x.iOrderByCol == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1012);
}
if( aOutEx[i].u.x.iOrderByCol==0 ) { iCol++;
}
  };
// ABS Label 1007
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1007);
}
// ABS Label 1008
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1008);
}

// ROR Label 1009
if((i <= nColumn) != (i < nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1009);
}
// ROR Label 1010
if((i > nColumn) != (i < nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1010);
}
// ROR Label 1011
if((i >= nColumn) != (i < nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1011);
}

#ifdef SQLITE_ENABLE_SORTER_REFERENCES
  if( pSort->nDefer ){
    int iKey = iCol+1;
    int regKey = sqlite3GetTempRange(pParse, nRefKey);

    for(i=0; i<pSort->nDefer; i++){
      int iCsr = pSort->aDefer[i].iCsr;
      Table *pTab = pSort->aDefer[i].pTab;
      int nKey = pSort->aDefer[i].nKey;

      sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);
      if( HasRowid(pTab) ){
        sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey);
        sqlite3VdbeAddOp3(v, OP_SeekRowid, iCsr, 
            sqlite3VdbeCurrentAddr(v)+1, regKey);
      }else{
        int k;
        int iJmp;
        assert( sqlite3PrimaryKeyIndex(pTab)->nKeyCol==nKey );
        for(k=0; k<nKey; k++){
          sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey+k);
        }
        iJmp = sqlite3VdbeCurrentAddr(v);
        sqlite3VdbeAddOp4Int(v, OP_SeekGE, iCsr, iJmp+2, regKey, nKey);
        sqlite3VdbeAddOp4Int(v, OP_IdxLE, iCsr, iJmp+3, regKey, nKey);
        sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);
      }
    }
    sqlite3ReleaseTempRange(pParse, regKey, nRefKey);
  }
#endif
  i = nColumn - 1;

// ABS Label 1013
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1013);
}

// ROR Label 1014
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1014);
}
// ROR Label 1015
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1015);
}
// ROR Label 1016
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1016);
}
for(; i>=0; i--){
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
    if( aOutEx[i].bSorterRef ){
      sqlite3ExprCode(pParse, aOutEx[i].pExpr, regRow+i);
    }else
#endif
    {
      int iRead;
      
// ABS Label 1029
if(aOutEx[i].u.x.iOrderByCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1029);
}
if( aOutEx[i].u.x.iOrderByCol ){
        iRead = aOutEx[i].u.x.iOrderByCol-1;
      }else{
        iRead = iCol--;
      }
      
// ABS Label 1021
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1021);
}

// ABS Label 1022
if(iSortTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1022);
}

// ABS Label 1023
if(iRead < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1023);
}

// ABS Label 1024
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1024);
}
// ABS Label 1025
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1025);
}

// AOR Label 1026
if(regRow - i != regRow + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1026);
}
// AOR Label 1027
if(regRow / i != regRow + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1027);
}
// AOR Label 1028
if(regRow * i != regRow + i)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1028);
}
sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);
      VdbeComment((v, "%s", aOutEx[i].zEName));
    }
  };
// ABS Label 1017
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1017);
}

// ROR Label 1018
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1018);
}
// ROR Label 1019
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1019);
}
// ROR Label 1020
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1020);
}

  switch( eDest ){
    case SRT_Table:
    case SRT_EphemTab: {
      
// ABS Label 1030
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1030);
}

// ABS Label 1031
if(iSortTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1031);
}

// ABS Label 1032
if(bSeq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1032);
}
// ABS Label 1033
if(nKey < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1033);
}

// AOR Label 1034
if(nKey - bSeq != nKey + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1034);
}
// AOR Label 1035
if(nKey / bSeq != nKey + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1035);
}
// AOR Label 1036
if(nKey * bSeq != nKey + bSeq)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1036);
}

// ABS Label 1037
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1037);
}
sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey+bSeq, regRow);
      
// ABS Label 1038
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1038);
}

// ABS Label 1039
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1039);
}

// ABS Label 1040
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1040);
}
sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);
      
// ABS Label 1041
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1041);
}

// ABS Label 1042
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1042);
}

// ABS Label 1043
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1043);
}

// ABS Label 1044
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1044);
}
sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);
      
// ABS Label 1045
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1045);
}
sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
      break;
    }
#ifndef SQLITE_OMIT_SUBQUERY
    case SRT_Set: {
      assert( nColumn==sqlite3Strlen30(pDest->zAffSdst) );
      
// ABS Label 1046
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1046);
}

// ABS Label 1047
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1047);
}

// ABS Label 1048
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1048);
}

// ABS Label 1049
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1049);
}

// ABS Label 1050
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1050);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, nColumn, regRowid,
                        pDest->zAffSdst, nColumn);
      
// ABS Label 1051
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1051);
}

// ABS Label 1052
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1052);
}

// ABS Label 1053
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1053);
}

// ABS Label 1054
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1054);
}

// ABS Label 1055
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1055);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, regRowid, regRow, nColumn);
      break;
    }
    case SRT_Mem: {
      /* The LIMIT clause will terminate the loop for us */
      break;
    }
#endif
    case SRT_Upfrom: {
      
// ABS Label 1056
if(pDest->iSDParm2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1056);
}
int i2 = pDest->iSDParm2;
      int r1 = sqlite3GetTempReg(pParse);
      
// ABS Label 1057
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1057);
}

// ABS Label 1058
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1058);
}

// AOR Label 1059
if(regRow - (i2 < 0) != regRow + (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1059);
}
// AOR Label 1060
if(regRow / (i2 < 0) != regRow + (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1060);
}
// AOR Label 1061
if(regRow * (i2 < 0) != regRow + (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1061);
}

// ABS Label 1062
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1062);
}

// AOR Label 1063
if(nColumn / (i2 < 0) != nColumn - (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1063);
}
// AOR Label 1064
if(nColumn + (i2 < 0) != nColumn - (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1064);
}
// AOR Label 1065
if(nColumn * (i2 < 0) != nColumn - (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1065);
}

// ABS Label 1066
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1066);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);
      
// ABS Label 1067
if(i2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1067);
}

// ROR Label 1068
if((i2 <= 0) != (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1068);
}
// ROR Label 1069
if((i2 > 0) != (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1069);
}
// ROR Label 1070
if((i2 >= 0) != (i2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1070);
}
if( i2<0 ){
        
// ABS Label 1071
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1071);
}

// ABS Label 1072
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1072);
}

// ABS Label 1073
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1073);
}

// ABS Label 1074
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1074);
}
sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);
      }else{
        
// ABS Label 1075
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1075);
}

// ABS Label 1076
if(iParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1076);
}

// ABS Label 1077
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1077);
}

// ABS Label 1078
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1078);
}

// ABS Label 1079
if(i2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1079);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);
      }
      break;
    }
    default: {
      assert( eDest==SRT_Output || eDest==SRT_Coroutine ); 
      testcase( eDest==SRT_Output );
      testcase( eDest==SRT_Coroutine );
      
// ABS Label 1080
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1080);
}

// ROR Label 1081
if((eDest != 9) != (eDest == 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1081);
}
if( eDest==SRT_Output ){
        
// ABS Label 1082
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1082);
}

// ABS Label 1083
if(pDest->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1083);
}

// ABS Label 1084
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1084);
}
sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iSdst, nColumn);
      }else{
        
// ABS Label 1085
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1085);
}

// ABS Label 1086
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1086);
}
sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
      }
      break;
    }
  }
  
// ABS Label 1087
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1087);
}
if( regRowid ){
    
// ABS Label 1090
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1090);
}

// ROR Label 1091
if((eDest != 11) != (eDest == 11))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1091);
}
if( eDest==SRT_Set ){
      
// ABS Label 1092
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1092);
}

// ABS Label 1093
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1093);
}

// ABS Label 1094
if(nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1094);
}
sqlite3ReleaseTempRange(pParse, regRow, nColumn);
    }else{
      
// ABS Label 1095
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1095);
}

// ABS Label 1096
if(regRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1096);
}
sqlite3ReleaseTempReg(pParse, regRow);
    }
    
// ABS Label 1088
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1088);
}

// ABS Label 1089
if(regRowid < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1089);
}
sqlite3ReleaseTempReg(pParse, regRowid);
  }
  /* The bottom of the loop
  */
  
// ABS Label 937
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 937);
}

// ABS Label 938
if(addrContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 938);
}
sqlite3VdbeResolveLabel(v, addrContinue);
  
// AOR Label 1097
if(pSort->sortFlags | 1 != pSort->sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1097);
}
// AOR Label 1098
if(pSort->sortFlags ^ 1 != pSort->sortFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1098);
}
if( pSort->sortFlags & SORTFLAG_UseSorter ){
    
// ABS Label 1099
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1099);
}

// ABS Label 1100
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1100);
}

// ABS Label 1101
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1101);
}
sqlite3VdbeAddOp2(v, OP_SorterNext, iTab, addr); VdbeCoverage(v);
  }else{
    
// ABS Label 1102
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1102);
}

// ABS Label 1103
if(iTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1103);
}

// ABS Label 1104
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1104);
}
sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); VdbeCoverage(v);
  }
  
// ABS Label 1105
if(pSort->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1105);
}
if( pSort->regReturn ) { 
// ABS Label 1106
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1106);
}

// ABS Label 1107
if(pSort->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1107);
}
sqlite3VdbeAddOp1(v, OP_Return, pSort->regReturn);
}
  
// ABS Label 939
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 939);
}

// ABS Label 940
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 940);
}
sqlite3VdbeResolveLabel(v, addrBreak);
}

/*
** Return a pointer to a string containing the 'declaration type' of the
** expression pExpr. The string may be treated as static by the caller.
**
** Also try to estimate the size of the returned value and return that
** result in *pEstWidth.
**
** The declaration type is the exact datatype definition extracted from the
** original CREATE TABLE statement if the expression is a column. The
** declaration type for a ROWID field is INTEGER. Exactly when an expression
** is considered a column can be complex in the presence of subqueries. The
** result-set expression in all of the following SELECT statements is 
** considered a column by this function.
**
**   SELECT col FROM tbl;
**   SELECT (SELECT col FROM tbl;
**   SELECT (SELECT col FROM tbl);
**   SELECT abc FROM (SELECT col AS abc FROM tbl);
** 
** The declaration type for any expression other than a column is NULL.
**
** This routine has either 3 or 6 parameters depending on whether or not
** the SQLITE_ENABLE_COLUMN_METADATA compile-time option is used.
*/
#ifdef SQLITE_ENABLE_COLUMN_METADATA
# define columnType(A,B,C,D,E) columnTypeImpl(A,B,C,D,E)
#else /* if !defined(SQLITE_ENABLE_COLUMN_METADATA) */
# define columnType(A,B,C,D,E) columnTypeImpl(A,B)
#endif
static const char *columnTypeImpl(
  NameContext *pNC, 
#ifndef SQLITE_ENABLE_COLUMN_METADATA
  Expr *pExpr
#else
  Expr *pExpr,
  const char **pzOrigDb,
  const char **pzOrigTab,
  const char **pzOrigCol
#endif
){
  char const *zType = 0;
  int j;
#ifdef SQLITE_ENABLE_COLUMN_METADATA
  char const *zOrigDb = 0;
  char const *zOrigTab = 0;
  char const *zOrigCol = 0;
#endif

  assert( pExpr!=0 );
  assert( pNC->pSrcList!=0 );
  switch( pExpr->op ){
    case TK_COLUMN: {
      /* The expression is a column. Locate the table the column is being
      ** extracted from in NameContext.pSrcList. This table may be real
      ** database table or a subquery.
      */
      Table *pTab = 0;            /* Table structure column is extracted from */
      Select *pS = 0;             /* Select the column is extracted from */
      int iCol = pExpr->iColumn;  /* Index of column in pTab */
      
// ABS Label 1108
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1108);
}

// COR Label 1109
if((pNC || !pTab) != (pNC && !pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1109);
}

// MCC Label 1110
if(pNC && !pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1110);
}
// MCC Label 1111
if(pNC && !(!pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1111);
}
// MCC Label 1112
if(!(pNC) && !pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1112);
}
// MCC Label 1113
if(!(pNC) && !(!pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1113);
}
while( pNC && !pTab ){
        
// ABS Label 1120
if(pNC->pSrcList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1120);
}
SrcList *pTabList = pNC->pSrcList;
        j = 0;

// ABS Label 1121
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1121);
}
// ABS Label 1122
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1122);
}
// ABS Label 1123
if(pTabList->a[j].iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1123);
}
// ABS Label 1124
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1124);
}

// COR Label 1125
if((j < pTabList->nSrc || pTabList->a[j].iCursor != pExpr->iTable) != (j < pTabList->nSrc && pTabList->a[j].iCursor != pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1125);
}

// ROR Label 1126
if((j <= pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1126);
}
// ROR Label 1127
if((j > pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1127);
}
// ROR Label 1128
if((j >= pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1128);
}
// ROR Label 1129
if((pTabList->a[j].iCursor == pExpr->iTable) != (pTabList->a[j].iCursor != pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1129);
}

// MCC Label 1130
if(j < pTabList->nSrc && pTabList->a[j].iCursor != pExpr->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1130);
}
// MCC Label 1131
if(j < pTabList->nSrc && !(pTabList->a[j].iCursor != pExpr->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1131);
}
// MCC Label 1132
if(!(j < pTabList->nSrc) && pTabList->a[j].iCursor != pExpr->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1132);
}
// MCC Label 1133
if(!(j < pTabList->nSrc) && !(pTabList->a[j].iCursor != pExpr->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1133);
}
for(;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++) {;
};
// ABS Label 1134
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1134);
}
// ABS Label 1135
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1135);
}
// ABS Label 1136
if(pTabList->a[j].iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1136);
}
// ABS Label 1137
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1137);
}

// COR Label 1138
if((j < pTabList->nSrc || pTabList->a[j].iCursor != pExpr->iTable) != (j < pTabList->nSrc && pTabList->a[j].iCursor != pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1138);
}

// ROR Label 1139
if((j <= pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1139);
}
// ROR Label 1140
if((j > pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1140);
}
// ROR Label 1141
if((j >= pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1141);
}
// ROR Label 1142
if((pTabList->a[j].iCursor == pExpr->iTable) != (pTabList->a[j].iCursor != pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1142);
}

// MCC Label 1143
if(j < pTabList->nSrc && pTabList->a[j].iCursor != pExpr->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1143);
}
// MCC Label 1144
if(j < pTabList->nSrc && !(pTabList->a[j].iCursor != pExpr->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1144);
}
// MCC Label 1145
if(!(j < pTabList->nSrc) && pTabList->a[j].iCursor != pExpr->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1145);
}
// MCC Label 1146
if(!(j < pTabList->nSrc) && !(pTabList->a[j].iCursor != pExpr->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1146);
}

        
// ABS Label 1147
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1147);
}
// ABS Label 1148
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1148);
}

// ROR Label 1149
if((j <= pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1149);
}
// ROR Label 1150
if((j > pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1150);
}
// ROR Label 1151
if((j >= pTabList->nSrc) != (j < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1151);
}
if( j<pTabList->nSrc ){
          pTab = pTabList->a[j].pTab;
          pS = pTabList->a[j].pSelect;
        }else{
          pNC = pNC->pNext;
        }
      };
// ABS Label 1114
if(pNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1114);
}

// COR Label 1115
if((pNC || !pTab) != (pNC && !pTab))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1115);
}

// MCC Label 1116
if(pNC && !pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1116);
}
// MCC Label 1117
if(pNC && !(!pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1117);
}
// MCC Label 1118
if(!(pNC) && !pTab ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1118);
}
// MCC Label 1119
if(!(pNC) && !(!pTab) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1119);
}


      
// ABS Label 1152
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1152);
}

// ROR Label 1153
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1153);
}
if( pTab==0 ){
        /* At one time, code such as "SELECT new.x" within a trigger would
        ** cause this condition to run.  Since then, we have restructured how
        ** trigger code is generated and so this condition is no longer 
        ** possible. However, it can still be true for statements like
        ** the following:
        **
        **   CREATE TABLE t1(col INTEGER);
        **   SELECT (SELECT t1.col) FROM FROM t1;
        **
        ** when columnType() is called on the expression "t1.col" in the 
        ** sub-select. In this case, set the column type to NULL, even
        ** though it should really be "INTEGER".
        **
        ** This is not a problem, as the column type of "t1.col" is never
        ** used. When columnType() is called on the expression 
        ** "(SELECT t1.col)", the correct type is returned (see the TK_SELECT
        ** branch below.  */
        break;
      }

      assert( pTab && pExpr->y.pTab==pTab );
      
// ABS Label 1154
if(pS < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1154);
}
if( pS ){
        /* The "table" is actually a sub-select or a view in the FROM clause
        ** of the SELECT statement. Return the declaration type and origin
        ** data for the result-set column of the sub-select.
        */
        
// ABS Label 1155
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1155);
}
// ABS Label 1156
if(pS->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1156);
}

// COR Label 1157
if((iCol < pS->pEList->nExpr || (iCol >= 0)) != (iCol < pS->pEList->nExpr && (iCol >= 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1157);
}

// ROR Label 1158
if((iCol <= pS->pEList->nExpr) != (iCol < pS->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1158);
}
// ROR Label 1159
if((iCol > pS->pEList->nExpr) != (iCol < pS->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1159);
}
// ROR Label 1160
if((iCol >= pS->pEList->nExpr) != (iCol < pS->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1160);
}

// MCC Label 1161
if(iCol < pS->pEList->nExpr && ( iCol >= 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1161);
}
// MCC Label 1162
if(iCol < pS->pEList->nExpr && ( !(iCol >= 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1162);
}
// MCC Label 1163
if(!(iCol < pS->pEList->nExpr) && ( iCol >= 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1163);
}
// MCC Label 1164
if(!(iCol < pS->pEList->nExpr) && ( !(iCol >= 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1164);
}
if( iCol<pS->pEList->nExpr
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
         && iCol>=0
#else
         && ALWAYS(iCol>=0)
#endif
        ){ 
          /* If iCol is less than zero, then the expression requests the
          ** rowid of the sub-select or view. This expression is legal (see 
          ** test case misc2.2.2) - it always evaluates to NULL.
          */
          NameContext sNC;
          
// ABS Label 1165
if(pS->pEList->a[iCol].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1165);
}
Expr *p = pS->pEList->a[iCol].pExpr;
          sNC.pSrcList = pS->pSrc;
          sNC.pNext = pNC;
          sNC.pParse = pNC->pParse;
          zType = columnType(&sNC, p,&zOrigDb,&zOrigTab,&zOrigCol); 
        }
      }else{
        /* A real table or a CTE table */
        assert( !pS );
#ifdef SQLITE_ENABLE_COLUMN_METADATA
        if( iCol<0 ) iCol = pTab->iPKey;
        assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );
        if( iCol<0 ){
          zType = "INTEGER";
          zOrigCol = "rowid";
        }else{
          zOrigCol = pTab->aCol[iCol].zName;
          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);
        }
        zOrigTab = pTab->zName;
        if( pNC->pParse && pTab->pSchema ){
          int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);
          zOrigDb = pNC->pParse->db->aDb[iDb].zDbSName;
        }
#else
        assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );
        
// ABS Label 1166
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1166);
}

// ROR Label 1167
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1167);
}
// ROR Label 1168
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1168);
}
// ROR Label 1169
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1169);
}
if( iCol<0 ){
          zType = "INTEGER";
        }else{
          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);
        }
#endif
      }
      break;
    }
#ifndef SQLITE_OMIT_SUBQUERY
    case TK_SELECT: {
      /* The expression is a sub-select. Return the declaration type and
      ** origin info for the single column in the result set of the SELECT
      ** statement.
      */
      NameContext sNC;
      
// ABS Label 1170
if(pExpr->x.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1170);
}
Select *pS = pExpr->x.pSelect;
      
// ABS Label 1171
if(pS->pEList->a[0].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1171);
}
Expr *p = pS->pEList->a[0].pExpr;
      assert( ExprHasProperty(pExpr, EP_xIsSelect) );
      sNC.pSrcList = pS->pSrc;
      sNC.pNext = pNC;
      sNC.pParse = pNC->pParse;
      zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol); 
      break;
    }
#endif
  }

#ifdef SQLITE_ENABLE_COLUMN_METADATA  
  if( pzOrigDb ){
    assert( pzOrigTab && pzOrigCol );
    *pzOrigDb = zOrigDb;
    *pzOrigTab = zOrigTab;
    *pzOrigCol = zOrigCol;
  }
#endif
  
// ABS Label 1172
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1172);
}
return zType;
}

/*
** Generate code that will tell the VDBE the declaration types of columns
** in the result set.
*/
static void generateColumnTypes(
  Parse *pParse,      /* Parser context */
  SrcList *pTabList,  /* List of tables */
  ExprList *pEList    /* Expressions defining the result set */
){
#ifndef SQLITE_OMIT_DECLTYPE
  
// ABS Label 1173
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1173);
}
Vdbe *v = pParse->pVdbe;
  int i;
  NameContext sNC;
  sNC.pSrcList = pTabList;
  sNC.pParse = pParse;
  sNC.pNext = 0;
  i = 0;

// ABS Label 1174
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1174);
}
// ABS Label 1175
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1175);
}

// ROR Label 1176
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1176);
}
// ROR Label 1177
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1177);
}
// ROR Label 1178
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1178);
}
for(; i<pEList->nExpr; i++){
    
// ABS Label 1184
if(pEList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1184);
}
Expr *p = pEList->a[i].pExpr;
    const char *zType;
#ifdef SQLITE_ENABLE_COLUMN_METADATA
    const char *zOrigDb = 0;
    const char *zOrigTab = 0;
    const char *zOrigCol = 0;
    zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);

    /* The vdbe must make its own copy of the column-type and other 
    ** column specific strings, in case the schema is reset before this
    ** virtual machine is deleted.
    */
    sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);
    sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);
    sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);
#else
    zType = columnType(&sNC, p, 0, 0, 0);
#endif
    
// ABS Label 1185
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1185);
}

// ABS Label 1186
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1186);
}

// ABS Label 1187
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1187);
}
sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);
  };
// ABS Label 1179
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1179);
}
// ABS Label 1180
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1180);
}

// ROR Label 1181
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1181);
}
// ROR Label 1182
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1182);
}
// ROR Label 1183
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1183);
}

#endif /* !defined(SQLITE_OMIT_DECLTYPE) */
}


/*
** Compute the column names for a SELECT statement.
**
** The only guarantee that SQLite makes about column names is that if the
** column has an AS clause assigning it a name, that will be the name used.
** That is the only documented guarantee.  However, countless applications
** developed over the years have made baseless assumptions about column names
** and will break if those assumptions changes.  Hence, use extreme caution
** when modifying this routine to avoid breaking legacy.
**
** See Also: sqlite3ColumnsFromExprList()
**
** The PRAGMA short_column_names and PRAGMA full_column_names settings are
** deprecated.  The default setting is short=ON, full=OFF.  99.9% of all
** applications should operate this way.  Nevertheless, we need to support the
** other modes for legacy:
**
**    short=OFF, full=OFF:      Column name is the text of the expression has it
**                              originally appears in the SELECT statement.  In
**                              other words, the zSpan of the result expression.
**
**    short=ON, full=OFF:       (This is the default setting).  If the result
**                              refers directly to a table column, then the
**                              result column name is just the table column
**                              name: COLUMN.  Otherwise use zSpan.
**
**    full=ON, short=ANY:       If the result refers directly to a table column,
**                              then the result column name with the table name
**                              prefix, ex: TABLE.COLUMN.  Otherwise use zSpan.
*/
void sqlite3GenerateColumnNames(
  Parse *pParse,      /* Parser context */
  Select *pSelect     /* Generate column names for this SELECT statement */
){
  
// ABS Label 1188
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1188);
}
Vdbe *v = pParse->pVdbe;
  int i;
  Table *pTab;
  SrcList *pTabList;
  ExprList *pEList;
  
// ABS Label 1189
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1189);
}
sqlite3 *db = pParse->db;
  int fullName;    /* TABLE.COLUMN if no AS clause and is a direct table ref */
  int srcName;     /* COLUMN or TABLE.COLUMN if no AS clause and is direct */

#ifndef SQLITE_OMIT_EXPLAIN
  /* If this is an EXPLAIN, skip this step */
  
// ABS Label 1195
if(pParse->explain < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1195);
}
if( pParse->explain ){
    return;
  }
#endif

  
// ABS Label 1196
if(pParse->colNamesSet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1196);
}
if( pParse->colNamesSet ) { return;
}
  /* Column names are determined by the left-most term of a compound select */
  
// ABS Label 1197
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1197);
}
while( pSelect->pPrior ) { pSelect = pSelect->pPrior;
};
// ABS Label 1198
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1198);
}

  SELECTTRACE(1,pParse,pSelect,("generating column names\n"));
  pTabList = pSelect->pSrc;
  pEList = pSelect->pEList;
  assert( v!=0 );
  assert( pTabList!=0 );
  pParse->colNamesSet = 1;
  fullName = (db->flags & SQLITE_FullColNames)!=0;
  srcName = (db->flags & SQLITE_ShortColNames)!=0 || fullName;
  
// ABS Label 1190
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1190);
}

// ABS Label 1191
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1191);
}
sqlite3VdbeSetNumCols(v, pEList->nExpr);
  i = 0;

// ABS Label 1199
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1199);
}
// ABS Label 1200
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1200);
}

// ROR Label 1201
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1201);
}
// ROR Label 1202
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1202);
}
// ROR Label 1203
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1203);
}
for(; i<pEList->nExpr; i++){
    
// ABS Label 1209
if(pEList->a[i].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1209);
}
Expr *p = pEList->a[i].pExpr;

    assert( p!=0 );
    assert( p->op!=TK_AGG_COLUMN );  /* Agg processing has not run yet */
    assert( p->op!=TK_COLUMN || p->y.pTab!=0 ); /* Covering idx not yet coded */
    
// ABS Label 1210
if(pEList->a[i].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1210);
}

// COR Label 1211
if((pEList->a[i].zEName || pEList->a[i].eEName == 0) != (pEList->a[i].zEName && pEList->a[i].eEName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1211);
}

// ROR Label 1212
if((pEList->a[i].eEName != 0) != (pEList->a[i].eEName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1212);
}

// MCC Label 1213
if(pEList->a[i].zEName && pEList->a[i].eEName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1213);
}
// MCC Label 1214
if(pEList->a[i].zEName && !(pEList->a[i].eEName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1214);
}
// MCC Label 1215
if(!(pEList->a[i].zEName) && pEList->a[i].eEName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1215);
}
// MCC Label 1216
if(!(pEList->a[i].zEName) && !(pEList->a[i].eEName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1216);
}
if( pEList->a[i].zEName && pEList->a[i].eEName==ENAME_NAME ){
      /* An AS clause always takes first priority */
      
// ABS Label 1217
if(pEList->a[i].zEName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1217);
}
char *zName = pEList->a[i].zEName;
      
// ABS Label 1218
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1218);
}

// ABS Label 1219
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1219);
}
sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);
    }else { 
// ABS Label 1220
if(srcName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1220);
}

// COR Label 1221
if((srcName || p->op == 166) != (srcName && p->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1221);
}

// ROR Label 1222
if((p->op != 166) != (p->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1222);
}

// MCC Label 1223
if(srcName && p->op == 166 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1223);
}
// MCC Label 1224
if(srcName && !(p->op == 166) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1224);
}
// MCC Label 1225
if(!(srcName) && p->op == 166 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1225);
}
// MCC Label 1226
if(!(srcName) && !(p->op == 166) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1226);
}
if( srcName && p->op==TK_COLUMN ){
      char *zCol;
      int iCol = p->iColumn;
      pTab = p->y.pTab;
      assert( pTab!=0 );
      
// ABS Label 1227
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1227);
}

// ROR Label 1228
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1228);
}
// ROR Label 1229
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1229);
}
// ROR Label 1230
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1230);
}
if( iCol<0 ) { iCol = pTab->iPKey;
}
      assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );
      
// ABS Label 1231
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1231);
}

// ROR Label 1232
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1232);
}
// ROR Label 1233
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1233);
}
// ROR Label 1234
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1234);
}
if( iCol<0 ){
        zCol = "rowid";
      }else{
        zCol = pTab->aCol[iCol].zName;
      }
      
// ABS Label 1235
if(fullName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1235);
}
if( fullName ){
        char *zName = 0;
        zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
        
// ABS Label 1236
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1236);
}

// ABS Label 1237
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1237);
}
sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);
      }else{
        
// ABS Label 1238
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1238);
}

// ABS Label 1239
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1239);
}
sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);
      }
    }else{
      const char *z = pEList->a[i].zEName;
      z = z==0 ? sqlite3MPrintf(db, "column%d", i+1) : sqlite3DbStrDup(db, z);
      
// ABS Label 1240
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1240);
}

// ABS Label 1241
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1241);
}

// ABS Label 1242
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1242);
}
sqlite3VdbeSetColName(v, i, COLNAME_NAME, z, SQLITE_DYNAMIC);
    };}

  };
// ABS Label 1204
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1204);
}
// ABS Label 1205
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1205);
}

// ROR Label 1206
if((i <= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1206);
}
// ROR Label 1207
if((i > pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1207);
}
// ROR Label 1208
if((i >= pEList->nExpr) != (i < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1208);
}

  
// ABS Label 1192
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1192);
}

// ABS Label 1193
if(pTabList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1193);
}

// ABS Label 1194
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1194);
}
generateColumnTypes(pParse, pTabList, pEList);
}

/*
** Given an expression list (which is really the list of expressions
** that form the result set of a SELECT statement) compute appropriate
** column names for a table that would hold the expression list.
**
** All column names will be unique.
**
** Only the column names are computed.  Column.zType, Column.zColl,
** and other fields of Column are zeroed.
**
** Return SQLITE_OK on success.  If a memory allocation error occurs,
** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.
**
** The only guarantee that SQLite makes about column names is that if the
** column has an AS clause assigning it a name, that will be the name used.
** That is the only documented guarantee.  However, countless applications
** developed over the years have made baseless assumptions about column names
** and will break if those assumptions changes.  Hence, use extreme caution
** when modifying this routine to avoid breaking legacy.
**
** See Also: sqlite3GenerateColumnNames()
*/
int sqlite3ColumnsFromExprList(
  Parse *pParse,          /* Parsing context */
  ExprList *pEList,       /* Expr list from which to derive column names */
  i16 *pnCol,             /* Write the number of columns here */
  Column **paCol          /* Write the new column list here */
){
  
// ABS Label 1243
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1243);
}
sqlite3 *db = pParse->db;   /* Database connection */
  int i, j;                   /* Loop counters */
  u32 cnt;                    /* Index added to make the name unique */
  Column *aCol, *pCol;        /* For looping over result columns */
  int nCol;                   /* Number of columns in the result set */
  char *zName;                /* Column name */
  int nName;                  /* Size of name in zName[] */
  Hash ht;                    /* Hash table of column names */
  Table *pTab;

  sqlite3HashInit(&ht);
  
// ABS Label 1244
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1244);
}
if( pEList ){
    nCol = pEList->nExpr;
    aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);
    testcase( aCol==0 );
    
// MCC Label 1245
if(( nCol > 32767 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1245);
}
// MCC Label 1246
if(( !(nCol > 32767) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1246);
}
if( NEVER(nCol>32767) ) { nCol = 32767;
}
  }else{
    nCol = 0;
    aCol = 0;
  }
  assert( nCol==(i16)nCol );
  *pnCol = nCol;
  *paCol = aCol;

  i = 0 , pCol = aCol;

// ABS Label 1247
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1247);
}
// ABS Label 1248
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1248);
}

// COR Label 1249
if((i < nCol || !db->mallocFailed) != (i < nCol && !db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1249);
}

// ROR Label 1250
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1250);
}
// ROR Label 1251
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1251);
}
// ROR Label 1252
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1252);
}

// MCC Label 1253
if(i < nCol && !db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1253);
}
// MCC Label 1254
if(i < nCol && !(!db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1254);
}
// MCC Label 1255
if(!(i < nCol) && !db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1255);
}
// MCC Label 1256
if(!(i < nCol) && !(!db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1256);
}
for(; i<nCol && !db->mallocFailed; i++, pCol++){
    /* Get an appropriate name for the column
    */
    if( (zName = pEList->a[i].zEName)!=0 && pEList->a[i].eEName==ENAME_NAME ){
      /* If the column contains an "AS <name>" phrase, use <name> as the name */
    }else{
      Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);
      
// COR Label 1267
if(((pColExpr != 0) || pColExpr->op == 140) != ((pColExpr != 0) && pColExpr->op == 140))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1267);
}

// ROR Label 1268
if((pColExpr->op != 140) != (pColExpr->op == 140))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1268);
}

// MCC Label 1269
if(( pColExpr != 0 ) && pColExpr->op == 140 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1269);
}
// MCC Label 1270
if(( pColExpr != 0 ) && !(pColExpr->op == 140) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1270);
}
// MCC Label 1271
if(( !(pColExpr != 0) ) && pColExpr->op == 140 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1271);
}
// MCC Label 1272
if(( !(pColExpr != 0) ) && !(pColExpr->op == 140) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1272);
}
while( ALWAYS(pColExpr!=0) && pColExpr->op==TK_DOT ){
        pColExpr = pColExpr->pRight;
        assert( pColExpr!=0 );
      };
// COR Label 1273
if(((pColExpr != 0) || pColExpr->op == 140) != ((pColExpr != 0) && pColExpr->op == 140))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1273);
}

// ROR Label 1274
if((pColExpr->op != 140) != (pColExpr->op == 140))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1274);
}

// MCC Label 1275
if(( pColExpr != 0 ) && pColExpr->op == 140 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1275);
}
// MCC Label 1276
if(( pColExpr != 0 ) && !(pColExpr->op == 140) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1276);
}
// MCC Label 1277
if(( !(pColExpr != 0) ) && pColExpr->op == 140 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1277);
}
// MCC Label 1278
if(( !(pColExpr != 0) ) && !(pColExpr->op == 140) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1278);
}

      if( pColExpr->op==TK_COLUMN && (pTab = pColExpr->y.pTab)!=0 ){
        /* For columns use the column name name */
        int iCol = pColExpr->iColumn;
        
// ABS Label 1279
if(iCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1279);
}

// ROR Label 1280
if((iCol <= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1280);
}
// ROR Label 1281
if((iCol > 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1281);
}
// ROR Label 1282
if((iCol >= 0) != (iCol < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1282);
}
if( iCol<0 ) { iCol = pTab->iPKey;
}
        zName = iCol>=0 ? pTab->aCol[iCol].zName : "rowid";
      }else { 
// ROR Label 1283
if((pColExpr->op != 59) != (pColExpr->op == 59))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1283);
}
if( pColExpr->op==TK_ID ){
        assert( !ExprHasProperty(pColExpr, EP_IntValue) );
        zName = pColExpr->u.zToken;
      }else{
        /* Use the original text of the column expression as its name */
        zName = pEList->a[i].zEName;
      };}

    }
    if( zName && !sqlite3IsTrueOrFalse(zName) ){
      zName = sqlite3DbStrDup(db, zName);
    }else{
      zName = sqlite3MPrintf(db,"column%d",i+1);
    }

    /* Make sure the column name is unique.  If the name is not unique,
    ** append an integer to the name so that it becomes unique.
    */
    cnt = 0;
    while( zName && sqlite3HashFind(&ht, zName)!=0 ){
      nName = sqlite3Strlen30(zName);
      
// ABS Label 1284
if(nName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1284);
}

// ROR Label 1285
if((nName <= 0) != (nName > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1285);
}
// ROR Label 1286
if((nName < 0) != (nName > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1286);
}
// ROR Label 1287
if((nName >= 0) != (nName > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1287);
}
if( nName>0 ){
        j = nName - 1;

// ABS Label 1288
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1288);
}

// COR Label 1289
if((j > 0 || (sqlite3CtypeMap[(unsigned char)(zName[j])] & 4)) != (j > 0 && (sqlite3CtypeMap[(unsigned char)(zName[j])] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1289);
}

// ROR Label 1290
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1290);
}
// ROR Label 1291
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1291);
}
// ROR Label 1292
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1292);
}

// MCC Label 1293
if(j > 0 && ( sqlite3CtypeMap[(unsigned char)(zName[j])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1293);
}
// MCC Label 1294
if(j > 0 && ( !(sqlite3CtypeMap[(unsigned char)(zName[j])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1294);
}
// MCC Label 1295
if(!(j > 0) && ( sqlite3CtypeMap[(unsigned char)(zName[j])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1295);
}
// MCC Label 1296
if(!(j > 0) && ( !(sqlite3CtypeMap[(unsigned char)(zName[j])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1296);
}
for(; j>0 && sqlite3Isdigit(zName[j]); j--){};
// ABS Label 1297
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1297);
}

// COR Label 1298
if((j > 0 || (sqlite3CtypeMap[(unsigned char)(zName[j])] & 4)) != (j > 0 && (sqlite3CtypeMap[(unsigned char)(zName[j])] & 4)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1298);
}

// ROR Label 1299
if((j <= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1299);
}
// ROR Label 1300
if((j < 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1300);
}
// ROR Label 1301
if((j >= 0) != (j > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1301);
}

// MCC Label 1302
if(j > 0 && ( sqlite3CtypeMap[(unsigned char)(zName[j])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1302);
}
// MCC Label 1303
if(j > 0 && ( !(sqlite3CtypeMap[(unsigned char)(zName[j])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1303);
}
// MCC Label 1304
if(!(j > 0) && ( sqlite3CtypeMap[(unsigned char)(zName[j])] & 4 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1304);
}
// MCC Label 1305
if(!(j > 0) && ( !(sqlite3CtypeMap[(unsigned char)(zName[j])] & 4) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1305);
}

        
// ROR Label 1306
if((zName[j] != ':') != (zName[j] == ':'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1306);
}
if( zName[j]==':' ) { nName = j;
}
      }
      zName = sqlite3MPrintf(db, "%.*z:%u", nName, zName, ++cnt);
      
// ABS Label 1307
if(cnt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1307);
}

// ROR Label 1308
if((cnt <= 3) != (cnt > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1308);
}
// ROR Label 1309
if((cnt < 3) != (cnt > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1309);
}
// ROR Label 1310
if((cnt >= 3) != (cnt > 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1310);
}
if( cnt>3 ) { sqlite3_randomness(sizeof(cnt), &cnt);
}
    };
    pCol->zName = zName;
    pCol->hName = sqlite3StrIHash(zName);
    sqlite3ColumnPropertiesFromName(0, pCol);
    if( zName && sqlite3HashInsert(&ht, zName, pCol)==pCol ){
      
// ABS Label 1311
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1311);
}
sqlite3OomFault(db);
    }
  };
// ABS Label 1257
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1257);
}
// ABS Label 1258
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1258);
}

// COR Label 1259
if((i < nCol || !db->mallocFailed) != (i < nCol && !db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1259);
}

// ROR Label 1260
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1260);
}
// ROR Label 1261
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1261);
}
// ROR Label 1262
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1262);
}

// MCC Label 1263
if(i < nCol && !db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1263);
}
// MCC Label 1264
if(i < nCol && !(!db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1264);
}
// MCC Label 1265
if(!(i < nCol) && !db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1265);
}
// MCC Label 1266
if(!(i < nCol) && !(!db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1266);
}

  sqlite3HashClear(&ht);
  
// ABS Label 1312
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1312);
}
if( db->mallocFailed ){
    j = 0;

// ABS Label 1314
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1314);
}
// ABS Label 1315
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1315);
}

// ROR Label 1316
if((j <= i) != (j < i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1316);
}
// ROR Label 1317
if((j > i) != (j < i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1317);
}
// ROR Label 1318
if((j >= i) != (j < i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1318);
}
for(; j<i; j++){
      
// ABS Label 1324
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1324);
}
sqlite3DbFree(db, aCol[j].zName);
    };
// ABS Label 1319
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1319);
}
// ABS Label 1320
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1320);
}

// ROR Label 1321
if((j <= i) != (j < i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1321);
}
// ROR Label 1322
if((j > i) != (j < i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1322);
}
// ROR Label 1323
if((j >= i) != (j < i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1323);
}

    
// ABS Label 1313
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1313);
}
sqlite3DbFree(db, aCol);
    *paCol = 0;
    *pnCol = 0;
    return SQLITE_NOMEM_BKPT;
  }
  return SQLITE_OK;
}

/*
** Add type and collation information to a column list based on
** a SELECT statement.
** 
** The column list presumably came from selectColumnNamesFromExprList().
** The column list has only names, not types or collations.  This
** routine goes through and adds the types and collations.
**
** This routine requires that all identifiers in the SELECT
** statement be resolved.
*/
void sqlite3SelectAddColumnTypeAndCollation(
  Parse *pParse,        /* Parsing contexts */
  Table *pTab,          /* Add column type information to this table */
  Select *pSelect,      /* SELECT used to determine types and collations */
  char aff              /* Default affinity for columns */
){
  
// ABS Label 1325
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1325);
}
sqlite3 *db = pParse->db;
  NameContext sNC;
  Column *pCol;
  CollSeq *pColl;
  int i;
  Expr *p;
  struct ExprList_item *a;

  assert( pSelect!=0 );
  assert( (pSelect->selFlags & SF_Resolved)!=0 );
  assert( pTab->nCol==pSelect->pEList->nExpr || db->mallocFailed );
  
// ABS Label 1326
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1326);
}
if( db->mallocFailed ) { return;
}
  memset(&sNC, 0, sizeof(sNC));
  sNC.pSrcList = pSelect->pSrc;
  a = pSelect->pEList->a;
  i = 0 , pCol = pTab->aCol;

// ABS Label 1327
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1327);
}

// ROR Label 1328
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1328);
}
// ROR Label 1329
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1329);
}
// ROR Label 1330
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1330);
}
for(; i<pTab->nCol; i++, pCol++){
    const char *zType;
    int n, m;
    pTab->tabFlags |= (pCol->colFlags & COLFLAG_NOINSERT);
    p = a[i].pExpr;
    zType = columnType(&sNC, p, 0, 0, 0);
    /* pCol->szEst = ... // Column size est for SELECT tables never used */
    pCol->affinity = sqlite3ExprAffinity(p);
    
// ABS Label 1335
if(zType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1335);
}
if( zType ){
      m = sqlite3Strlen30(zType);
      n = sqlite3Strlen30(pCol->zName);
      pCol->zName = sqlite3DbReallocOrFree(db, pCol->zName, n+m+2);
      
// ABS Label 1336
if(pCol->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1336);
}
if( pCol->zName ){
        memcpy(&pCol->zName[n+1], zType, m+1);
        pCol->colFlags |= COLFLAG_HASTYPE;
      }
    }
    
// ROR Label 1337
if((pCol->affinity < 64) != (pCol->affinity <= 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1337);
}
// ROR Label 1338
if((pCol->affinity > 64) != (pCol->affinity <= 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1338);
}
// ROR Label 1339
if((pCol->affinity >= 64) != (pCol->affinity <= 64))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1339);
}
if( pCol->affinity<=SQLITE_AFF_NONE ) { pCol->affinity = aff;
}
    pColl = sqlite3ExprCollSeq(pParse, p);
    
// ABS Label 1340
if(pCol->zColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1340);
}
// ABS Label 1341
if(pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1341);
}

// COR Label 1342
if((pColl || pCol->zColl == 0) != (pColl && pCol->zColl == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1342);
}

// ROR Label 1343
if((pCol->zColl != 0) != (pCol->zColl == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1343);
}

// MCC Label 1344
if(pColl && pCol->zColl == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1344);
}
// MCC Label 1345
if(pColl && !(pCol->zColl == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1345);
}
// MCC Label 1346
if(!(pColl) && pCol->zColl == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1346);
}
// MCC Label 1347
if(!(pColl) && !(pCol->zColl == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1347);
}
if( pColl && pCol->zColl==0 ){
      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);
    }
  };
// ABS Label 1331
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1331);
}

// ROR Label 1332
if((i <= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1332);
}
// ROR Label 1333
if((i > pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1333);
}
// ROR Label 1334
if((i >= pTab->nCol) != (i < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1334);
}

  pTab->szTabRow = 1; /* Any non-zero value works */
}

/*
** Given a SELECT statement, generate a Table structure that describes
** the result set of that SELECT.
*/
Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){
  Table *pTab;
  
// ABS Label 1348
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1348);
}
sqlite3 *db = pParse->db;
  u64 savedFlags;

  savedFlags = db->flags;
  db->flags &= ~(u64)SQLITE_FullColNames;
  db->flags |= SQLITE_ShortColNames;
  
// ABS Label 1349
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1349);
}

// ABS Label 1350
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1350);
}
sqlite3SelectPrep(pParse, pSelect, 0);
  db->flags = savedFlags;
  
// ABS Label 1357
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1357);
}
if( pParse->nErr ) { return 0;
}
  
// ABS Label 1358
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1358);
}
while( pSelect->pPrior ) { pSelect = pSelect->pPrior;
};
// ABS Label 1359
if(pSelect->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1359);
}

  pTab = sqlite3DbMallocZero(db, sizeof(Table) );
  
// ABS Label 1360
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1360);
}

// ROR Label 1361
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1361);
}
if( pTab==0 ){
    return 0;
  }
  pTab->nTabRef = 1;
  pTab->zName = 0;
  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
  
// ABS Label 1351
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1351);
}

// ABS Label 1352
if(pSelect->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1352);
}
sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
  
// ABS Label 1353
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1353);
}

// ABS Label 1354
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1354);
}

// ABS Label 1355
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1355);
}

// ABS Label 1356
if(aff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1356);
}
sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);
  pTab->iPKey = -1;
  
// ABS Label 1362
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1362);
}
if( db->mallocFailed ){
    
// ABS Label 1363
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1363);
}

// ABS Label 1364
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1364);
}
sqlite3DeleteTable(db, pTab);
    return 0;
  }
  
// ABS Label 1365
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1365);
}
return pTab;
}

/*
** Get a VDBE for the given parser context.  Create a new one if necessary.
** If an error occurs, return NULL and leave a message in pParse.
*/
Vdbe *sqlite3GetVdbe(Parse *pParse){
  
// ABS Label 1366
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1366);
}
if( pParse->pVdbe ){
    
// ABS Label 1367
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1367);
}
return pParse->pVdbe;
  }
  
// ABS Label 1368
if(pParse->pToplevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1368);
}

// COR Label 1369
if((pParse->pToplevel == 0 || (((pParse->db)->dbOptFlags & (8)) == 0)) != (pParse->pToplevel == 0 && (((pParse->db)->dbOptFlags & (8)) == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1369);
}

// ROR Label 1370
if((pParse->pToplevel != 0) != (pParse->pToplevel == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1370);
}

// MCC Label 1371
if(pParse->pToplevel == 0 && ( ((pParse->db)->dbOptFlags & (8)) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1371);
}
// MCC Label 1372
if(pParse->pToplevel == 0 && ( !(((pParse->db)->dbOptFlags & (8)) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1372);
}
// MCC Label 1373
if(!(pParse->pToplevel == 0) && ( ((pParse->db)->dbOptFlags & (8)) == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1373);
}
// MCC Label 1374
if(!(pParse->pToplevel == 0) && ( !(((pParse->db)->dbOptFlags & (8)) == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1374);
}
if( pParse->pToplevel==0
   && OptimizationEnabled(pParse->db,SQLITE_FactorOutConst)
  ){
    pParse->okConstFactor = 1;
  }
  return sqlite3VdbeCreate(pParse);
}


/*
** Compute the iLimit and iOffset fields of the SELECT based on the
** pLimit expressions.  pLimit->pLeft and pLimit->pRight hold the expressions
** that appear in the original SQL statement after the LIMIT and OFFSET
** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset 
** are the integer memory register numbers for counters used to compute 
** the limit and offset.  If there is no limit and/or offset, then 
** iLimit and iOffset are negative.
**
** This routine changes the values of iLimit and iOffset only if
** a limit or offset is defined by pLimit->pLeft and pLimit->pRight.  iLimit
** and iOffset should have been preset to appropriate default values (zero)
** prior to calling this routine.
**
** The iOffset register (if it exists) is initialized to the value
** of the OFFSET.  The iLimit register is initialized to LIMIT.  Register
** iOffset+1 is initialized to LIMIT+OFFSET.
**
** Only if pLimit->pLeft!=0 do the limit registers get
** redefined.  The UNION ALL operator uses this property to force
** the reuse of the same limit and offset registers across multiple
** SELECT statements.
*/
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
  Vdbe *v = 0;
  int iLimit = 0;
  int iOffset;
  int n;
  
// ABS Label 1375
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1375);
}
Expr *pLimit = p->pLimit;

  
// ABS Label 1376
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1376);
}
if( p->iLimit ) { return;
}

  /* 
  ** "LIMIT -1" always shows all rows.  There is some
  ** controversy about what the correct behavior should be.
  ** The current implementation interprets "LIMIT 0" to mean
  ** no rows.
  */
  
// ABS Label 1377
if(pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1377);
}
if( pLimit ){
    assert( pLimit->op==TK_LIMIT );
    assert( pLimit->pLeft!=0 );
    p->iLimit = iLimit = ++pParse->nMem;
    v = sqlite3GetVdbe(pParse);
    assert( v!=0 );
    if( sqlite3ExprIsInteger(pLimit->pLeft, &n) ){
      
// ABS Label 1378
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1378);
}

// ABS Label 1379
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1379);
}

// ABS Label 1380
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1380);
}
sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);
      VdbeComment((v, "LIMIT counter"));
      
// ABS Label 1381
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1381);
}

// ROR Label 1382
if((n != 0) != (n == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1382);
}
if( n==0 ){
        
// ABS Label 1383
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1383);
}

// ABS Label 1384
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1384);
}
sqlite3VdbeGoto(v, iBreak);
      }else { if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){
        p->nSelectRow = sqlite3LogEst((u64)n);
        p->selFlags |= SF_FixedLimit;
      };}

    }else{
      
// ABS Label 1385
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1385);
}

// ABS Label 1386
if(pLimit->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1386);
}

// ABS Label 1387
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1387);
}
sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);
      
// ABS Label 1388
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1388);
}

// ABS Label 1389
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1389);
}
sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);
      VdbeComment((v, "LIMIT counter"));
      
// ABS Label 1390
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1390);
}

// ABS Label 1391
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1391);
}

// ABS Label 1392
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1392);
}
sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);
    }
    
// ABS Label 1393
if(pLimit->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1393);
}
if( pLimit->pRight ){
      p->iOffset = iOffset = ++pParse->nMem;
      pParse->nMem++;   /* Allocate an extra register for limit+offset */
      
// ABS Label 1394
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1394);
}

// ABS Label 1395
if(pLimit->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1395);
}

// ABS Label 1396
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1396);
}
sqlite3ExprCode(pParse, pLimit->pRight, iOffset);
      
// ABS Label 1397
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1397);
}

// ABS Label 1398
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1398);
}
sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);
      VdbeComment((v, "OFFSET counter"));
      
// ABS Label 1399
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1399);
}

// ABS Label 1400
if(iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1400);
}

// ABS Label 1401
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1401);
}

// AOR Label 1402
if(iOffset - 1 != iOffset + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1402);
}
// AOR Label 1403
if(iOffset / 1 != iOffset + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1403);
}
// AOR Label 1404
if(iOffset * 1 != iOffset + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1404);
}

// ABS Label 1405
if(iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1405);
}
sqlite3VdbeAddOp3(v, OP_OffsetLimit, iLimit, iOffset+1, iOffset);
      VdbeComment((v, "LIMIT+OFFSET"));
    }
  }
}

#ifndef SQLITE_OMIT_COMPOUND_SELECT
/*
** Return the appropriate collating sequence for the iCol-th column of
** the result set for the compound-select statement "p".  Return NULL if
** the column has no default collating sequence.
**
** The collating sequence for the compound select is taken from the
** left-most term of the select that has a collating sequence.
*/
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){
  CollSeq *pRet;
  
// ABS Label 1406
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1406);
}
if( p->pPrior ){
    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
  }else{
    pRet = 0;
  }
  assert( iCol>=0 );
  /* iCol must be less than p->pEList->nExpr.  Otherwise an error would
  ** have been thrown during name resolution and we would not have gotten
  ** this far */
  
// ABS Label 1407
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1407);
}

// COR Label 1408
if((pRet == 0 || (iCol < p->pEList->nExpr)) != (pRet == 0 && (iCol < p->pEList->nExpr)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1408);
}

// ROR Label 1409
if((pRet != 0) != (pRet == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1409);
}

// MCC Label 1410
if(pRet == 0 && ( iCol < p->pEList->nExpr ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1410);
}
// MCC Label 1411
if(pRet == 0 && ( !(iCol < p->pEList->nExpr) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1411);
}
// MCC Label 1412
if(!(pRet == 0) && ( iCol < p->pEList->nExpr ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1412);
}
// MCC Label 1413
if(!(pRet == 0) && ( !(iCol < p->pEList->nExpr) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1413);
}
if( pRet==0 && ALWAYS(iCol<p->pEList->nExpr) ){
    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);
  }
  
// ABS Label 1414
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1414);
}
return pRet;
}

/*
** The select statement passed as the second parameter is a compound SELECT
** with an ORDER BY clause. This function allocates and returns a KeyInfo
** structure suitable for implementing the ORDER BY.
**
** Space to hold the KeyInfo structure is obtained from malloc. The calling
** function is responsible for ensuring that this structure is eventually
** freed.
*/
static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){
  
// ABS Label 1415
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1415);
}
ExprList *pOrderBy = p->pOrderBy;
  
// ABS Label 1416
if(p->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1416);
}
int nOrderBy = p->pOrderBy->nExpr;
  
// ABS Label 1417
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1417);
}
sqlite3 *db = pParse->db;
  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);
  
// ABS Label 1418
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1418);
}
if( pRet ){
    int i;
    i = 0;

// ABS Label 1419
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1419);
}
// ABS Label 1420
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1420);
}

// ROR Label 1421
if((i <= nOrderBy) != (i < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1421);
}
// ROR Label 1422
if((i > nOrderBy) != (i < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1422);
}
// ROR Label 1423
if((i >= nOrderBy) != (i < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1423);
}
for(; i<nOrderBy; i++){
      struct ExprList_item *pItem = &pOrderBy->a[i];
      
// ABS Label 1429
if(pItem->pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1429);
}
Expr *pTerm = pItem->pExpr;
      CollSeq *pColl;

      
// ABS Label 1430
if(pTerm->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1430);
}

// AOR Label 1431
if(pTerm->flags | 256 != pTerm->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1431);
}
// AOR Label 1432
if(pTerm->flags ^ 256 != pTerm->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1432);
}
if( pTerm->flags & EP_Collate ){
        pColl = sqlite3ExprCollSeq(pParse, pTerm);
      }else{
        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);
        
// ABS Label 1433
if(pColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1433);
}

// ROR Label 1434
if((pColl != 0) != (pColl == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1434);
}
if( pColl==0 ) { pColl = db->pDfltColl;
}
        pOrderBy->a[i].pExpr =
          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);
      }
      assert( sqlite3KeyInfoIsWriteable(pRet) );
      pRet->aColl[i] = pColl;
      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;
    };
// ABS Label 1424
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1424);
}
// ABS Label 1425
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1425);
}

// ROR Label 1426
if((i <= nOrderBy) != (i < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1426);
}
// ROR Label 1427
if((i > nOrderBy) != (i < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1427);
}
// ROR Label 1428
if((i >= nOrderBy) != (i < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1428);
}

  }

  
// ABS Label 1435
if(pRet < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1435);
}
return pRet;
}

#ifndef SQLITE_OMIT_CTE
/*
** This routine generates VDBE code to compute the content of a WITH RECURSIVE
** query of the form:
**
**   <recursive-table> AS (<setup-query> UNION [ALL] <recursive-query>)
**                         \___________/             \_______________/
**                           p->pPrior                      p
**
**
** There is exactly one reference to the recursive-table in the FROM clause
** of recursive-query, marked with the SrcList->a[].fg.isRecursive flag.
**
** The setup-query runs once to generate an initial set of rows that go
** into a Queue table.  Rows are extracted from the Queue table one by
** one.  Each row extracted from Queue is output to pDest.  Then the single
** extracted row (now in the iCurrent table) becomes the content of the
** recursive-table for a recursive-query run.  The output of the recursive-query
** is added back into the Queue table.  Then another row is extracted from Queue
** and the iteration continues until the Queue table is empty.
**
** If the compound query operator is UNION then no duplicate rows are ever
** inserted into the Queue table.  The iDistinct table keeps a copy of all rows
** that have ever been inserted into Queue and causes duplicates to be
** discarded.  If the operator is UNION ALL, then duplicates are allowed.
** 
** If the query has an ORDER BY, then entries in the Queue table are kept in
** ORDER BY order and the first entry is extracted for each cycle.  Without
** an ORDER BY, the Queue table is just a FIFO.
**
** If a LIMIT clause is provided, then the iteration stops after LIMIT rows
** have been output to pDest.  A LIMIT of zero means to output no rows and a
** negative LIMIT means to output all rows.  If there is also an OFFSET clause
** with a positive value, then the first OFFSET outputs are discarded rather
** than being sent to pDest.  The LIMIT count does not begin until after OFFSET
** rows have been skipped.
*/
static void generateWithRecursiveQuery(
  Parse *pParse,        /* Parsing context */
  Select *p,            /* The recursive SELECT to be coded */
  SelectDest *pDest     /* What to do with query results */
){
  
// ABS Label 1436
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1436);
}
SrcList *pSrc = p->pSrc;      /* The FROM clause of the recursive query */
  
// ABS Label 1437
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1437);
}
int nCol = p->pEList->nExpr;  /* Number of columns in the recursive table */
  
// ABS Label 1438
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1438);
}
Vdbe *v = pParse->pVdbe;      /* The prepared statement under construction */
  
// ABS Label 1439
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1439);
}
Select *pSetup = p->pPrior;   /* The setup query */
  Select *pFirstRec;            /* Left-most recursive term */
  int addrTop;                  /* Top of the loop */
  int addrCont, addrBreak;      /* CONTINUE and BREAK addresses */
  int iCurrent = 0;             /* The Current table */
  int regCurrent;               /* Register holding Current table */
  int iQueue;                   /* The Queue table */
  int iDistinct = 0;            /* To ensure unique results if UNION */
  int eDest = SRT_Fifo;         /* How to write to Queue */
  SelectDest destQueue;         /* SelectDest targetting the Queue table */
  int i;                        /* Loop counter */
  int rc;                       /* Result code */
  ExprList *pOrderBy;           /* The ORDER BY clause */
  Expr *pLimit;                 /* Saved LIMIT and OFFSET */
  int regLimit, regOffset;      /* Registers used by LIMIT and OFFSET */

#ifndef SQLITE_OMIT_WINDOWFUNC
  
// ABS Label 1472
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1472);
}
if( p->pWin ){
    
// ABS Label 1473
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1473);
}
sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
    return;
  }
#endif

  /* Obtain authorization to do a recursive query */
  if( sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0) ) { return;
}

  /* Process the LIMIT and OFFSET clauses, if they exist */
  addrBreak = sqlite3VdbeMakeLabel(pParse);
  p->nSelectRow = 320;  /* 4 billion rows */
  
// ABS Label 1440
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1440);
}

// ABS Label 1441
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1441);
}

// ABS Label 1442
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1442);
}
computeLimitRegisters(pParse, p, addrBreak);
  pLimit = p->pLimit;
  regLimit = p->iLimit;
  regOffset = p->iOffset;
  p->pLimit = 0;
  p->iLimit = p->iOffset = 0;
  pOrderBy = p->pOrderBy;

  /* Locate the cursor number of the Current table */
  i = 0;

// MCC Label 1474
if(( i < pSrc->nSrc ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1474);
}
// MCC Label 1475
if(( !(i < pSrc->nSrc) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1475);
}
for(; ALWAYS(i<pSrc->nSrc); i++){
    
// ABS Label 1478
if(pSrc->a[i].fg.isRecursive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1478);
}
if( pSrc->a[i].fg.isRecursive ){
      iCurrent = pSrc->a[i].iCursor;
      break;
    }
  };
// MCC Label 1476
if(( i < pSrc->nSrc ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1476);
}
// MCC Label 1477
if(( !(i < pSrc->nSrc) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1477);
}


  /* Allocate cursors numbers for Queue and Distinct.  The cursor number for
  ** the Distinct table must be exactly one greater than Queue in order
  ** for the SRT_DistFifo and SRT_DistQueue destinations to work. */
  iQueue = pParse->nTab++;
  
// ROR Label 1479
if((p->op != 133) != (p->op == 133))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1479);
}
if( p->op==TK_UNION ){
    eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;
    iDistinct = pParse->nTab++;
  }else{
    eDest = pOrderBy ? SRT_Queue : SRT_Fifo;
  }
  
// ABS Label 1443
if(eDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1443);
}

// ABS Label 1444
if(iQueue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1444);
}
sqlite3SelectDestInit(&destQueue, eDest, iQueue);

  /* Allocate cursors for Current, Queue, and Distinct. */
  regCurrent = ++pParse->nMem;
  
// ABS Label 1445
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1445);
}

// ABS Label 1446
if(iCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1446);
}

// ABS Label 1447
if(regCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1447);
}

// ABS Label 1448
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1448);
}
sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);
  
// ABS Label 1480
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1480);
}
if( pOrderBy ){
    KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);
    
// ABS Label 1481
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1481);
}

// ABS Label 1482
if(iQueue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1482);
}

// ABS Label 1483
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1483);
}

// AOR Label 1484
if(pOrderBy->nExpr - 2 != pOrderBy->nExpr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1484);
}
// AOR Label 1485
if(pOrderBy->nExpr / 2 != pOrderBy->nExpr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1485);
}
// AOR Label 1486
if(pOrderBy->nExpr * 2 != pOrderBy->nExpr + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1486);
}
sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr+2, 0,
                      (char*)pKeyInfo, P4_KEYINFO);
    destQueue.pOrderBy = pOrderBy;
  }else{
    
// ABS Label 1487
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1487);
}

// ABS Label 1488
if(iQueue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1488);
}

// ABS Label 1489
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1489);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);
  }
  VdbeComment((v, "Queue table"));
  
// ABS Label 1490
if(iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1490);
}
if( iDistinct ){
    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);
    p->selFlags |= SF_UsesEphemeral;
  }

  /* Detach the ORDER BY clause from the compound SELECT */
  p->pOrderBy = 0;

  /* Figure out how many elements of the compound SELECT are part of the
  ** recursive query.  Make sure no recursive elements use aggregate
  ** functions.  Mark the recursive elements as UNION ALL even if they
  ** are really UNION because the distinctness will be enforced by the
  ** iDistinct table.  pFirstRec is left pointing to the left-most
  ** recursive term of the CTE.
  */
  pFirstRec = p;
  pFirstRec = p;

// MCC Label 1491
if(( pFirstRec != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1491);
}
// MCC Label 1492
if(( !(pFirstRec != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1492);
}
for(; ALWAYS(pFirstRec!=0); pFirstRec=pFirstRec->pPrior){
    
// ABS Label 1495
if(pFirstRec->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1495);
}

// AOR Label 1496
if(pFirstRec->selFlags | 8 != pFirstRec->selFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1496);
}
// AOR Label 1497
if(pFirstRec->selFlags ^ 8 != pFirstRec->selFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1497);
}
if( pFirstRec->selFlags & SF_Aggregate ){
      
// ABS Label 1498
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1498);
}
sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
      goto end_of_recursive_query;
    }
    pFirstRec->op = TK_ALL;
    
// ROR Label 1499
if(((pFirstRec->pPrior->selFlags & 8192) != 0) != ((pFirstRec->pPrior->selFlags & 8192) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1499);
}
if( (pFirstRec->pPrior->selFlags & SF_Recursive)==0 ) { break;
}
  };
// MCC Label 1493
if(( pFirstRec != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1493);
}
// MCC Label 1494
if(( !(pFirstRec != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1494);
}


  /* Store the results of the setup-query in Queue. */
  pSetup = pFirstRec->pPrior;
  pSetup->pNext = 0;
  ExplainQueryPlan((pParse, 1, "SETUP"));
  rc = sqlite3Select(pParse, pSetup, &destQueue);
  pSetup->pNext = p;
  
// ABS Label 1500
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1500);
}
if( rc ) { goto end_of_recursive_query;
}

  /* Find the next row in the Queue and output that row */
  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);

  /* Transfer the next row in Queue over to Current */
  
// ABS Label 1450
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1450);
}

// ABS Label 1451
if(iCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1451);
}
sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent); /* To reset column cache */
  
// ABS Label 1501
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1501);
}
if( pOrderBy ){
    
// ABS Label 1502
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1502);
}

// ABS Label 1503
if(iQueue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1503);
}

// ABS Label 1504
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1504);
}

// AOR Label 1505
if(pOrderBy->nExpr - 1 != pOrderBy->nExpr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1505);
}
// AOR Label 1506
if(pOrderBy->nExpr / 1 != pOrderBy->nExpr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1506);
}
// AOR Label 1507
if(pOrderBy->nExpr * 1 != pOrderBy->nExpr + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1507);
}

// ABS Label 1508
if(regCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1508);
}
sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr+1, regCurrent);
  }else{
    
// ABS Label 1509
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1509);
}

// ABS Label 1510
if(iQueue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1510);
}

// ABS Label 1511
if(regCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1511);
}
sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);
  }
  
// ABS Label 1452
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1452);
}

// ABS Label 1453
if(iQueue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1453);
}
sqlite3VdbeAddOp1(v, OP_Delete, iQueue);

  /* Output the single row in Current */
  addrCont = sqlite3VdbeMakeLabel(pParse);
  
// ABS Label 1454
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1454);
}

// ABS Label 1455
if(regOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1455);
}

// ABS Label 1456
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1456);
}
codeOffset(v, regOffset, addrCont);
  
// ABS Label 1457
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1457);
}

// ABS Label 1458
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1458);
}

// ABS Label 1459
if(iCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1459);
}

// ABS Label 1460
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1460);
}

// ABS Label 1461
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1461);
}

// ABS Label 1462
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1462);
}
selectInnerLoop(pParse, p, iCurrent,
      0, 0, pDest, addrCont, addrBreak);
  
// ABS Label 1512
if(regLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1512);
}
if( regLimit ){
    
// ABS Label 1513
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1513);
}

// ABS Label 1514
if(regLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1514);
}

// ABS Label 1515
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1515);
}
sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);
    VdbeCoverage(v);
  }
  
// ABS Label 1463
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1463);
}

// ABS Label 1464
if(addrCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1464);
}
sqlite3VdbeResolveLabel(v, addrCont);

  /* Execute the recursive SELECT taking the single row in Current as
  ** the value for the recursive-table. Store the results in the Queue.
  */
  pFirstRec->pPrior = 0;
  ExplainQueryPlan((pParse, 1, "RECURSIVE STEP"));
  
// ABS Label 1466
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1466);
}

// ABS Label 1467
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1467);
}
sqlite3Select(pParse, p, &destQueue);
  assert( pFirstRec->pPrior==0 );
  pFirstRec->pPrior = pSetup;

  /* Keep running the loop until the Queue is empty */
  
// ABS Label 1468
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1468);
}

// ABS Label 1469
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1469);
}
sqlite3VdbeGoto(v, addrTop);
  
// ABS Label 1470
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1470);
}

// ABS Label 1471
if(addrBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1471);
}
sqlite3VdbeResolveLabel(v, addrBreak);

end_of_recursive_query:
  sqlite3ExprListDelete(pParse->db, p->pOrderBy);
  p->pOrderBy = pOrderBy;
  p->pLimit = pLimit;
  return;
}
#endif /* SQLITE_OMIT_CTE */

/* Forward references */
static int multiSelectOrderBy(
  Parse *pParse,        /* Parsing context */
  Select *p,            /* The right-most of SELECTs to be coded */
  SelectDest *pDest     /* What to do with query results */
);

/*
** Handle the special case of a compound-select that originates from a
** VALUES clause.  By handling this as a special case, we avoid deep
** recursion, and thus do not need to enforce the SQLITE_LIMIT_COMPOUND_SELECT
** on a VALUES clause.
**
** Because the Select object originates from a VALUES clause:
**   (1) There is no LIMIT or OFFSET or else there is a LIMIT of exactly 1
**   (2) All terms are UNION ALL
**   (3) There is no ORDER BY clause
**
** The "LIMIT of exactly 1" case of condition (1) comes about when a VALUES
** clause occurs within scalar expression (ex: "SELECT (VALUES(1),(2),(3))").
** The sqlite3CodeSubselect will have added the LIMIT 1 clause in tht case.
** Since the limit is exactly 1, we only need to evalutes the left-most VALUES.
*/
static int multiSelectValues(
  Parse *pParse,        /* Parsing context */
  Select *p,            /* The right-most of SELECTs to be coded */
  SelectDest *pDest     /* What to do with query results */
){
  int nRow = 1;
  int rc = 0;
  
// ABS Label 1516
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1516);
}

// ROR Label 1517
if((p->pLimit != 0) != (p->pLimit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1517);
}
int bShowAll = p->pLimit==0;
  assert( p->selFlags & SF_MultiValue );
  do{
    assert( p->selFlags & SF_Values );
    assert( p->op==TK_ALL || (p->op==TK_SELECT && p->pPrior==0) );
    assert( p->pNext==0 || p->pEList->nExpr==p->pNext->pEList->nExpr );
#ifndef SQLITE_OMIT_WINDOWFUNC
    
// ABS Label 1520
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1520);
}
if( p->pWin ) { return -1;
}
#endif
    
// ABS Label 1521
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1521);
}

// ROR Label 1522
if((p->pPrior != 0) != (p->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1522);
}
if( p->pPrior==0 ) { break;
}
    assert( p->pPrior->pNext==p );
    p = p->pPrior;
    nRow += bShowAll;
  }while(1);;
  ExplainQueryPlan((pParse, 0, "SCAN %d CONSTANT ROW%s", nRow,
                    nRow==1 ? "" : "S"));
  
// ABS Label 1523
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1523);
}
while( p ){
    
// ABS Label 1525
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1525);
}

// ABS Label 1526
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1526);
}

// ABS Label 1527
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1527);
}
selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);
    if( !bShowAll ) { break;
}
    p->nSelectRow = nRow;
    p = p->pNext;
  };
// ABS Label 1524
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1524);
}

  
// ABS Label 1528
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1528);
}
return rc;
}

/*
** Return true if the SELECT statement which is known to be the recursive
** part of a recursive CTE still has its anchor terms attached.  If the
** anchor terms have already been removed, then return false.
*/
static int hasAnchor(Select *p){
  
// ABS Label 1529
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1529);
}

// COR Label 1530
if((p || (p->selFlags & 8192) != 0) != (p && (p->selFlags & 8192) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1530);
}

// ROR Label 1531
if(((p->selFlags & 8192) == 0) != ((p->selFlags & 8192) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1531);
}

// MCC Label 1532
if(p && (p->selFlags & 8192) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1532);
}
// MCC Label 1533
if(p && !((p->selFlags & 8192) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1533);
}
// MCC Label 1534
if(!(p) && (p->selFlags & 8192) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1534);
}
// MCC Label 1535
if(!(p) && !((p->selFlags & 8192) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1535);
}
while( p && (p->selFlags & SF_Recursive)!=0 ){ p = p->pPrior; };
// ABS Label 1536
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1536);
}

// COR Label 1537
if((p || (p->selFlags & 8192) != 0) != (p && (p->selFlags & 8192) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1537);
}

// ROR Label 1538
if(((p->selFlags & 8192) == 0) != ((p->selFlags & 8192) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1538);
}

// MCC Label 1539
if(p && (p->selFlags & 8192) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1539);
}
// MCC Label 1540
if(p && !((p->selFlags & 8192) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1540);
}
// MCC Label 1541
if(!(p) && (p->selFlags & 8192) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1541);
}
// MCC Label 1542
if(!(p) && !((p->selFlags & 8192) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1542);
}

  
// ABS Label 1543
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1543);
}

// ROR Label 1544
if((p == 0) != (p != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1544);
}
return p!=0;
}

/*
** This routine is called to process a compound query form from
** two or more separate queries using UNION, UNION ALL, EXCEPT, or
** INTERSECT
**
** "p" points to the right-most of the two queries.  the query on the
** left is p->pPrior.  The left query could also be a compound query
** in which case this routine will be called recursively. 
**
** The results of the total query are to be written into a destination
** of type eDest with parameter iParm.
**
** Example 1:  Consider a three-way compound SQL statement.
**
**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3
**
** This statement is parsed up as follows:
**
**     SELECT c FROM t3
**      |
**      `----->  SELECT b FROM t2
**                |
**                `------>  SELECT a FROM t1
**
** The arrows in the diagram above represent the Select.pPrior pointer.
** So if this routine is called with p equal to the t3 query, then
** pPrior will be the t2 query.  p->op will be TK_UNION in this case.
**
** Notice that because of the way SQLite parses compound SELECTs, the
** individual selects always group from left to right.
*/
static int multiSelect(
  Parse *pParse,        /* Parsing context */
  Select *p,            /* The right-most of SELECTs to be coded */
  SelectDest *pDest     /* What to do with query results */
){
  int rc = SQLITE_OK;   /* Success code from a subroutine */
  Select *pPrior;       /* Another SELECT immediately to our left */
  Vdbe *v;              /* Generate code to this VDBE */
  SelectDest dest;      /* Alternative data destination */
  Select *pDelete = 0;  /* Chain of simple selects to delete */
  sqlite3 *db;          /* Database connection */

  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only
  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.
  */
  assert( p && p->pPrior );  /* Calling function guarantees this much */
  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );
  assert( p->selFlags & SF_Compound );
  db = pParse->db;
  pPrior = p->pPrior;
  dest = *pDest;
  assert( pPrior->pOrderBy==0 );
  assert( pPrior->pLimit==0 );

  v = sqlite3GetVdbe(pParse);
  assert( v!=0 );  /* The VDBE already created by calling function */

  /* Create the destination temporary table if necessary
  */
  
// ROR Label 1547
if((dest.eDest != 12) != (dest.eDest == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1547);
}
if( dest.eDest==SRT_EphemTab ){
    assert( p->pEList );
    
// ABS Label 1548
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1548);
}

// ABS Label 1549
if(dest.iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1549);
}

// ABS Label 1550
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1550);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);
    dest.eDest = SRT_Table;
  }

  /* Special handling for a compound-select that originates as a VALUES clause.
  */
  
// ABS Label 1551
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1551);
}

// AOR Label 1552
if(p->selFlags | 1024 != p->selFlags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1552);
}
// AOR Label 1553
if(p->selFlags ^ 1024 != p->selFlags & 1024)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1553);
}
if( p->selFlags & SF_MultiValue ){
    rc = multiSelectValues(pParse, p, &dest);
    
// ABS Label 1554
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1554);
}

// ROR Label 1555
if((rc < 0) != (rc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1555);
}
// ROR Label 1556
if((rc > 0) != (rc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1556);
}
// ROR Label 1557
if((rc <= 0) != (rc >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1557);
}
if( rc>=0 ) { goto multi_select_end;
}
    rc = SQLITE_OK;
  }

  /* Make sure all SELECTs in the statement have the same number of elements
  ** in their result sets.
  */
  assert( p->pEList && pPrior->pEList );
  assert( p->pEList->nExpr==pPrior->pEList->nExpr );

#ifndef SQLITE_OMIT_CTE
  if( (p->selFlags & SF_Recursive)!=0 && hasAnchor(p) ){
    
// ABS Label 1558
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1558);
}

// ABS Label 1559
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1559);
}
generateWithRecursiveQuery(pParse, p, &dest);
  }else {
#endif

  /* Compound SELECTs that have an ORDER BY clause are handled separately.
  */
  
// ABS Label 1560
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1560);
}
if( p->pOrderBy ){
    return multiSelectOrderBy(pParse, p, pDest);
  }else{

#ifndef SQLITE_OMIT_EXPLAIN
    
// ABS Label 1561
if(pPrior->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1561);
}

// ROR Label 1562
if((pPrior->pPrior != 0) != (pPrior->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1562);
}
if( pPrior->pPrior==0 ){
      ExplainQueryPlan((pParse, 1, "COMPOUND QUERY"));
      ExplainQueryPlan((pParse, 1, "LEFT-MOST SUBQUERY"));
    }
#endif

    /* Generate code for the left and right SELECT statements.
    */
    switch( p->op ){
      case TK_ALL: {
        int addr = 0;
        int nLimit = 0;  /* Initialize to suppress harmless compiler warning */
        assert( !pPrior->pLimit );
        pPrior->iLimit = p->iLimit;
        pPrior->iOffset = p->iOffset;
        pPrior->pLimit = p->pLimit;
        SELECTTRACE(1, pParse, p, ("multiSelect UNION ALL left...\n"));
        rc = sqlite3Select(pParse, pPrior, &dest);
        pPrior->pLimit = 0;
        
// ABS Label 1566
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1566);
}
if( rc ){
          goto multi_select_end;
        }
        p->pPrior = 0;
        p->iLimit = pPrior->iLimit;
        p->iOffset = pPrior->iOffset;
        
// ABS Label 1567
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1567);
}
if( p->iLimit ){
          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);
          VdbeComment((v, "Jump ahead if LIMIT reached"));
          
// ABS Label 1568
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1568);
}
if( p->iOffset ){
            
// ABS Label 1569
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1569);
}

// ABS Label 1570
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1570);
}

// ABS Label 1571
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1571);
}

// AOR Label 1572
if(p->iOffset - 1 != p->iOffset + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1572);
}
// AOR Label 1573
if(p->iOffset / 1 != p->iOffset + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1573);
}
// AOR Label 1574
if(p->iOffset * 1 != p->iOffset + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1574);
}

// ABS Label 1575
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1575);
}
sqlite3VdbeAddOp3(v, OP_OffsetLimit,
                              p->iLimit, p->iOffset+1, p->iOffset);
          }
        }
        ExplainQueryPlan((pParse, 1, "UNION ALL"));
        SELECTTRACE(1, pParse, p, ("multiSelect UNION ALL right...\n"));
        rc = sqlite3Select(pParse, p, &dest);
        testcase( rc!=SQLITE_OK );
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
        if( p->pLimit
         && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit)
         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) 
        ){
          p->nSelectRow = sqlite3LogEst((u64)nLimit);
        }
        
// ABS Label 1576
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1576);
}
if( addr ){
          
// ABS Label 1577
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1577);
}

// ABS Label 1578
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1578);
}
sqlite3VdbeJumpHere(v, addr);
        }
        break;
      }
      case TK_EXCEPT:
      case TK_UNION: {
        int unionTab;    /* Cursor number of the temp table holding result */
        u8 op = 0;       /* One of the SRT_ operations to apply to self */
        int priorOp;     /* The SRT_ operation to apply to prior selects */
        Expr *pLimit;    /* Saved values of p->nLimit  */
        int addr;
        SelectDest uniondest;
  
        testcase( p->op==TK_EXCEPT );
        testcase( p->op==TK_UNION );
        priorOp = SRT_Union;
        
// ABS Label 1584
if(priorOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1584);
}

// ROR Label 1585
if((dest.eDest != priorOp) != (dest.eDest == priorOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1585);
}
if( dest.eDest==priorOp ){
          /* We can reuse a temporary table generated by a SELECT to our
          ** right.
          */
          assert( p->pLimit==0 );      /* Not allowed on leftward elements */
          unionTab = dest.iSDParm;
        }else{
          /* We will need to create our own temporary table to hold the
          ** intermediate results.
          */
          unionTab = pParse->nTab++;
          assert( p->pOrderBy==0 );
          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);
          assert( p->addrOpenEphm[0] == -1 );
          p->addrOpenEphm[0] = addr;
          findRightmost(p)->selFlags |= SF_UsesEphemeral;
          assert( p->pEList );
        }
          
  
        /* Code the SELECT statements to our left
        */
        assert( !pPrior->pOrderBy );
        
// ABS Label 1579
if(priorOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1579);
}

// ABS Label 1580
if(unionTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1580);
}
sqlite3SelectDestInit(&uniondest, priorOp, unionTab);
        SELECTTRACE(1, pParse, p, ("multiSelect EXCEPT/UNION left...\n"));
        rc = sqlite3Select(pParse, pPrior, &uniondest);
        
// ABS Label 1586
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1586);
}
if( rc ){
          goto multi_select_end;
        }
  
        /* Code the current SELECT statement
        */
        
// ROR Label 1587
if((p->op != 135) != (p->op == 135))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1587);
}
if( p->op==TK_EXCEPT ){
          op = SRT_Except;
        }else{
          assert( p->op==TK_UNION );
          op = SRT_Union;
        }
        p->pPrior = 0;
        pLimit = p->pLimit;
        p->pLimit = 0;
        uniondest.eDest = op;
        ExplainQueryPlan((pParse, 1, "%s USING TEMP B-TREE",
                          sqlite3SelectOpName(p->op)));
        SELECTTRACE(1, pParse, p, ("multiSelect EXCEPT/UNION right...\n"));
        rc = sqlite3Select(pParse, p, &uniondest);
        testcase( rc!=SQLITE_OK );
        assert( p->pOrderBy==0 );
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        p->pOrderBy = 0;
        
// ROR Label 1588
if((p->op != 133) != (p->op == 133))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1588);
}
if( p->op==TK_UNION ){
          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
        }
        
// ABS Label 1582
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1582);
}

// ABS Label 1583
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1583);
}
sqlite3ExprDelete(db, p->pLimit);
        p->pLimit = pLimit;
        p->iLimit = 0;
        p->iOffset = 0;
  
        /* Convert the data in the temporary table into whatever form
        ** it is that we currently need.
        */
        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );
        assert( p->pEList || db->mallocFailed );
        
// ABS Label 1589
if(priorOp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1589);
}

// COR Label 1590
if((dest.eDest != priorOp || db->mallocFailed == 0) != (dest.eDest != priorOp && db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1590);
}

// ROR Label 1591
if((dest.eDest == priorOp) != (dest.eDest != priorOp))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1591);
}
// ROR Label 1592
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1592);
}

// MCC Label 1593
if(dest.eDest != priorOp && db->mallocFailed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1593);
}
// MCC Label 1594
if(dest.eDest != priorOp && !(db->mallocFailed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1594);
}
// MCC Label 1595
if(!(dest.eDest != priorOp) && db->mallocFailed == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1595);
}
// MCC Label 1596
if(!(dest.eDest != priorOp) && !(db->mallocFailed == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1596);
}
if( dest.eDest!=priorOp && db->mallocFailed==0 ){
          int iCont, iBreak, iStart;
          iBreak = sqlite3VdbeMakeLabel(pParse);
          iCont = sqlite3VdbeMakeLabel(pParse);
          
// ABS Label 1597
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1597);
}

// ABS Label 1598
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1598);
}

// ABS Label 1599
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1599);
}
computeLimitRegisters(pParse, p, iBreak);
          
// ABS Label 1600
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1600);
}

// ABS Label 1601
if(unionTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1601);
}

// ABS Label 1602
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1602);
}
sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);
          iStart = sqlite3VdbeCurrentAddr(v);
          
// ABS Label 1603
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1603);
}

// ABS Label 1604
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1604);
}

// ABS Label 1605
if(unionTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1605);
}

// ABS Label 1606
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1606);
}

// ABS Label 1607
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1607);
}
selectInnerLoop(pParse, p, unionTab,
                          0, 0, &dest, iCont, iBreak);
          
// ABS Label 1608
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1608);
}

// ABS Label 1609
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1609);
}
sqlite3VdbeResolveLabel(v, iCont);
          
// ABS Label 1610
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1610);
}

// ABS Label 1611
if(unionTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1611);
}

// ABS Label 1612
if(iStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1612);
}
sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);
          
// ABS Label 1613
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1613);
}

// ABS Label 1614
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1614);
}
sqlite3VdbeResolveLabel(v, iBreak);
          
// ABS Label 1615
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1615);
}

// ABS Label 1616
if(unionTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1616);
}
sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);
        }
        break;
      }
      default: assert( p->op==TK_INTERSECT ); {
        int tab1, tab2;
        int iCont, iBreak, iStart;
        Expr *pLimit;
        int addr;
        SelectDest intersectdest;
        int r1;
  
        /* INTERSECT is different from the others since it requires
        ** two temporary tables.  Hence it has its own case.  Begin
        ** by allocating the tables we will need.
        */
        tab1 = pParse->nTab++;
        tab2 = pParse->nTab++;
        assert( p->pOrderBy==0 );
  
        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);
        assert( p->addrOpenEphm[0] == -1 );
        p->addrOpenEphm[0] = addr;
        findRightmost(p)->selFlags |= SF_UsesEphemeral;
        assert( p->pEList );
  
        /* Code the SELECTs to our left into temporary table "tab1".
        */
        
// ABS Label 1617
if(tab1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1617);
}
sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);
        SELECTTRACE(1, pParse, p, ("multiSelect INTERSECT left...\n"));
        rc = sqlite3Select(pParse, pPrior, &intersectdest);
        
// ABS Label 1649
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1649);
}
if( rc ){
          goto multi_select_end;
        }
  
        /* Code the current SELECT into temporary table "tab2"
        */
        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);
        assert( p->addrOpenEphm[1] == -1 );
        p->addrOpenEphm[1] = addr;
        p->pPrior = 0;
        pLimit = p->pLimit;
        p->pLimit = 0;
        intersectdest.iSDParm = tab2;
        ExplainQueryPlan((pParse, 1, "%s USING TEMP B-TREE",
                          sqlite3SelectOpName(p->op)));
        SELECTTRACE(1, pParse, p, ("multiSelect INTERSECT right...\n"));
        rc = sqlite3Select(pParse, p, &intersectdest);
        testcase( rc!=SQLITE_OK );
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        
// ROR Label 1650
if((p->nSelectRow <= pPrior->nSelectRow) != (p->nSelectRow > pPrior->nSelectRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1650);
}
// ROR Label 1651
if((p->nSelectRow < pPrior->nSelectRow) != (p->nSelectRow > pPrior->nSelectRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1651);
}
// ROR Label 1652
if((p->nSelectRow >= pPrior->nSelectRow) != (p->nSelectRow > pPrior->nSelectRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1652);
}
if( p->nSelectRow>pPrior->nSelectRow ){
          p->nSelectRow = pPrior->nSelectRow;
        }
        
// ABS Label 1619
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1619);
}

// ABS Label 1620
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1620);
}
sqlite3ExprDelete(db, p->pLimit);
        p->pLimit = pLimit;
  
        /* Generate code to take the intersection of the two temporary
        ** tables.
        */
        
// ABS Label 1653
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1653);
}
if( rc ) { break;
}
        assert( p->pEList );
        iBreak = sqlite3VdbeMakeLabel(pParse);
        iCont = sqlite3VdbeMakeLabel(pParse);
        
// ABS Label 1621
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1621);
}

// ABS Label 1622
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1622);
}

// ABS Label 1623
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1623);
}
computeLimitRegisters(pParse, p, iBreak);
        
// ABS Label 1624
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1624);
}

// ABS Label 1625
if(tab1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1625);
}

// ABS Label 1626
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1626);
}
sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);
        r1 = sqlite3GetTempReg(pParse);
        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);
        
// ABS Label 1627
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1627);
}

// ABS Label 1628
if(tab2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1628);
}

// ABS Label 1629
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1629);
}

// ABS Label 1630
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1630);
}
sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);
        VdbeCoverage(v);
        
// ABS Label 1631
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1631);
}

// ABS Label 1632
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1632);
}
sqlite3ReleaseTempReg(pParse, r1);
        
// ABS Label 1633
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1633);
}

// ABS Label 1634
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1634);
}

// ABS Label 1635
if(tab1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1635);
}

// ABS Label 1636
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1636);
}

// ABS Label 1637
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1637);
}
selectInnerLoop(pParse, p, tab1,
                        0, 0, &dest, iCont, iBreak);
        
// ABS Label 1638
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1638);
}

// ABS Label 1639
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1639);
}
sqlite3VdbeResolveLabel(v, iCont);
        
// ABS Label 1640
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1640);
}

// ABS Label 1641
if(tab1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1641);
}

// ABS Label 1642
if(iStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1642);
}
sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);
        
// ABS Label 1643
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1643);
}

// ABS Label 1644
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1644);
}
sqlite3VdbeResolveLabel(v, iBreak);
        
// ABS Label 1645
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1645);
}

// ABS Label 1646
if(tab2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1646);
}
sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);
        
// ABS Label 1647
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1647);
}

// ABS Label 1648
if(tab1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1648);
}
sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);
        break;
      }
    }
  
  #ifndef SQLITE_OMIT_EXPLAIN
    
// ABS Label 1654
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1654);
}

// ROR Label 1655
if((p->pNext != 0) != (p->pNext == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1655);
}
if( p->pNext==0 ){
      ExplainQueryPlanPop(pParse);
    }
  #endif
  };}

#ifdef MAGMA_ENABLE_FIXES
  if( pParse->nErr ) goto multi_select_end;
#endif
#ifdef MAGMA_ENABLE_CANARIES
  MAGMA_LOG("SQL014", pParse->nErr != 0);
#endif
  /* Compute collating sequences used by 
  ** temporary tables needed to implement the compound select.
  ** Attach the KeyInfo structure to all temporary tables.
  **
  ** This section is run by the right-most SELECT statement only.
  ** SELECT statements to the left always skip this part.  The right-most
  ** SELECT might also skip this part if it has no ORDER BY clause and
  ** no temp tables are required.
  */
  
// ABS Label 1657
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1657);
}

// AOR Label 1658
if(p->selFlags | 32 != p->selFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1658);
}
// AOR Label 1659
if(p->selFlags ^ 32 != p->selFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1659);
}
if( p->selFlags & SF_UsesEphemeral ){
    int i;                        /* Loop counter */
    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */
    Select *pLoop;                /* For looping through SELECT statements */
    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */
    int nCol;                     /* Number of columns in result set */

    assert( p->pNext==0 );
    nCol = p->pEList->nExpr;
    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);
    if( !pKeyInfo ){
      rc = SQLITE_NOMEM_BKPT;
      goto multi_select_end;
    }
    i = 0 , apColl = pKeyInfo->aColl;

// ABS Label 1661
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1661);
}
// ABS Label 1662
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1662);
}

// ROR Label 1663
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1663);
}
// ROR Label 1664
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1664);
}
// ROR Label 1665
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1665);
}
for(; i<nCol; i++, apColl++){
      *apColl = multiSelectCollSeq(pParse, p, i);
      
// ABS Label 1671
if(*apColl < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1671);
}

// ROR Label 1672
if((0 != *apColl) != (0 == *apColl))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1672);
}
if( 0==*apColl ){
        *apColl = db->pDfltColl;
      }
    };
// ABS Label 1666
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1666);
}
// ABS Label 1667
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1667);
}

// ROR Label 1668
if((i <= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1668);
}
// ROR Label 1669
if((i > nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1669);
}
// ROR Label 1670
if((i >= nCol) != (i < nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1670);
}


    pLoop = p;

// ABS Label 1673
if(pLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1673);
}
for(; pLoop; pLoop=pLoop->pPrior){
      i = 0;

// ABS Label 1675
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1675);
}

// ROR Label 1676
if((i <= 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1676);
}
// ROR Label 1677
if((i > 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1677);
}
// ROR Label 1678
if((i >= 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1678);
}
for(; i<2; i++){
        
// ABS Label 1683
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1683);
}
// ABS Label 1684
if(pLoop->addrOpenEphm[i] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1684);
}
int addr = pLoop->addrOpenEphm[i];
        
// ABS Label 1690
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1690);
}

// ROR Label 1691
if((addr <= 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1691);
}
// ROR Label 1692
if((addr > 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1692);
}
// ROR Label 1693
if((addr >= 0) != (addr < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1693);
}
if( addr<0 ){
          /* If [0] is unused then [1] is also unused.  So we can
          ** always safely abort as soon as the first unused slot is found */
          assert( pLoop->addrOpenEphm[1]<0 );
          break;
        }
        
// ABS Label 1685
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1685);
}

// ABS Label 1686
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1686);
}

// ABS Label 1687
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1687);
}
sqlite3VdbeChangeP2(v, addr, nCol);
        
// ABS Label 1688
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1688);
}

// ABS Label 1689
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1689);
}
sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),
                            P4_KEYINFO);
        pLoop->addrOpenEphm[i] = -1;
      };
// ABS Label 1679
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1679);
}

// ROR Label 1680
if((i <= 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1680);
}
// ROR Label 1681
if((i > 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1681);
}
// ROR Label 1682
if((i >= 2) != (i < 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1682);
}

    };
// ABS Label 1674
if(pLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1674);
}

    
// ABS Label 1660
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1660);
}
sqlite3KeyInfoUnref(pKeyInfo);
  }

multi_select_end:
  pDest->iSdst = dest.iSdst;
  pDest->nSdst = dest.nSdst;
  
// ABS Label 1545
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1545);
}

// ABS Label 1546
if(pDelete < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1546);
}
sqlite3SelectDelete(db, pDelete);
  
// ABS Label 1694
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1694);
}
return rc;
}
#endif /* SQLITE_OMIT_COMPOUND_SELECT */

/*
** Error message for when two or more terms of a compound select have different
** size result sets.
*/
void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){
  
// ABS Label 1695
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1695);
}

// AOR Label 1696
if(p->selFlags | 512 != p->selFlags & 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1696);
}
// AOR Label 1697
if(p->selFlags ^ 512 != p->selFlags & 512)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1697);
}
if( p->selFlags & SF_Values ){
    
// ABS Label 1698
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1698);
}
sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
  }else{
    
// ABS Label 1699
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1699);
}
sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s"
      " do not have the same number of result columns",
      sqlite3SelectOpName(p->op));
  }
}

/*
** Code an output subroutine for a coroutine implementation of a
** SELECT statment.
**
** The data to be output is contained in pIn->iSdst.  There are
** pIn->nSdst columns to be output.  pDest is where the output should
** be sent.
**
** regReturn is the number of the register holding the subroutine
** return address.
**
** If regPrev>0 then it is the first register in a vector that
** records the previous output.  mem[regPrev] is a flag that is false
** if there has been no previous output.  If regPrev>0 then code is
** generated to suppress duplicates.  pKeyInfo is used for comparing
** keys.
**
** If the LIMIT found in p->iLimit is reached, jump immediately to
** iBreak.
*/
static int generateOutputSubroutine(
  Parse *pParse,          /* Parsing context */
  Select *p,              /* The SELECT statement */
  SelectDest *pIn,        /* Coroutine supplying data */
  SelectDest *pDest,      /* Where to send the data */
  int regReturn,          /* The return address register */
  int regPrev,            /* Previous result register.  No uniqueness if 0 */
  KeyInfo *pKeyInfo,      /* For comparing with previous entry */
  int iBreak              /* Jump here if we hit the LIMIT */
){
  
// ABS Label 1700
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1700);
}
Vdbe *v = pParse->pVdbe;
  int iContinue;
  int addr;

  addr = sqlite3VdbeCurrentAddr(v);
  iContinue = sqlite3VdbeMakeLabel(pParse);

  /* Suppress duplicates for UNION, EXCEPT, and INTERSECT 
  */
  
// ABS Label 1708
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1708);
}
if( regPrev ){
    int addr1, addr2;
    addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);
    addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,
                              (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
    
// ABS Label 1709
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1709);
}

// ABS Label 1710
if(addr2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1710);
}

// AOR Label 1711
if(addr2 - 2 != addr2 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1711);
}
// AOR Label 1712
if(addr2 / 2 != addr2 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1712);
}
// AOR Label 1713
if(addr2 * 2 != addr2 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1713);
}

// ABS Label 1714
if(iContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1714);
}

// ABS Label 1715
if(addr2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1715);
}

// AOR Label 1716
if(addr2 - 2 != addr2 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1716);
}
// AOR Label 1717
if(addr2 / 2 != addr2 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1717);
}
// AOR Label 1718
if(addr2 * 2 != addr2 + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1718);
}
sqlite3VdbeAddOp3(v, OP_Jump, addr2+2, iContinue, addr2+2); VdbeCoverage(v);
    
// ABS Label 1719
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1719);
}

// ABS Label 1720
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1720);
}
sqlite3VdbeJumpHere(v, addr1);
    
// ABS Label 1721
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1721);
}

// ABS Label 1722
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1722);
}

// ABS Label 1723
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1723);
}

// AOR Label 1724
if(regPrev - 1 != regPrev + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1724);
}
// AOR Label 1725
if(regPrev / 1 != regPrev + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1725);
}
// AOR Label 1726
if(regPrev * 1 != regPrev + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1726);
}

// ABS Label 1727
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1727);
}

// AOR Label 1728
if(pIn->nSdst / 1 != pIn->nSdst - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1728);
}
// AOR Label 1729
if(pIn->nSdst + 1 != pIn->nSdst - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1729);
}
// AOR Label 1730
if(pIn->nSdst * 1 != pIn->nSdst - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 1730);
}
sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev+1, pIn->nSdst-1);
    
// ABS Label 1731
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1731);
}

// ABS Label 1732
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1732);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);
  }
  
// ABS Label 1733
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1733);
}
if( pParse->db->mallocFailed ) { return 0;
}

  /* Suppress the first OFFSET entries if there is an OFFSET clause
  */
  
// ABS Label 1701
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1701);
}

// ABS Label 1702
if(p->iOffset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1702);
}

// ABS Label 1703
if(iContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1703);
}
codeOffset(v, p->iOffset, iContinue);

  assert( pDest->eDest!=SRT_Exists );
  assert( pDest->eDest!=SRT_Table );
  switch( pDest->eDest ){
    /* Store the result as data using a unique key.
    */
    case SRT_EphemTab: {
      int r1 = sqlite3GetTempReg(pParse);
      int r2 = sqlite3GetTempReg(pParse);
      
// ABS Label 1734
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1734);
}

// ABS Label 1735
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1735);
}

// ABS Label 1736
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1736);
}

// ABS Label 1737
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1737);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, r1);
      
// ABS Label 1738
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1738);
}

// ABS Label 1739
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1739);
}

// ABS Label 1740
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1740);
}
sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iSDParm, r2);
      
// ABS Label 1741
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1741);
}

// ABS Label 1742
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1742);
}

// ABS Label 1743
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1743);
}

// ABS Label 1744
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1744);
}
sqlite3VdbeAddOp3(v, OP_Insert, pDest->iSDParm, r1, r2);
      
// ABS Label 1745
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1745);
}
sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
      
// ABS Label 1746
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1746);
}

// ABS Label 1747
if(r2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1747);
}
sqlite3ReleaseTempReg(pParse, r2);
      
// ABS Label 1748
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1748);
}

// ABS Label 1749
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1749);
}
sqlite3ReleaseTempReg(pParse, r1);
      break;
    }

#ifndef SQLITE_OMIT_SUBQUERY
    /* If we are creating a set for an "expr IN (SELECT ...)".
    */
    case SRT_Set: {
      int r1;
      testcase( pIn->nSdst>1 );
      r1 = sqlite3GetTempReg(pParse);
      
// ABS Label 1750
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1750);
}

// ABS Label 1751
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1751);
}

// ABS Label 1752
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1752);
}

// ABS Label 1753
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1753);
}

// ABS Label 1754
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1754);
}
sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, 
          r1, pDest->zAffSdst, pIn->nSdst);
      
// ABS Label 1755
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1755);
}

// ABS Label 1756
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1756);
}

// ABS Label 1757
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1757);
}

// ABS Label 1758
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1758);
}

// ABS Label 1759
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1759);
}
sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pDest->iSDParm, r1,
                           pIn->iSdst, pIn->nSdst);
      
// ABS Label 1760
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1760);
}

// ABS Label 1761
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1761);
}
sqlite3ReleaseTempReg(pParse, r1);
      break;
    }

    /* If this is a scalar select that is part of an expression, then
    ** store the results in the appropriate memory cell and break out
    ** of the scan loop.  Note that the select might return multiple columns
    ** if it is the RHS of a row-value IN operator.
    */
    case SRT_Mem: {
      testcase( pIn->nSdst>1 );
      
// ABS Label 1762
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1762);
}

// ABS Label 1763
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1763);
}

// ABS Label 1764
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1764);
}

// ABS Label 1765
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1765);
}
sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);
      /* The LIMIT clause will jump out of the loop for us */
      break;
    }
#endif /* #ifndef SQLITE_OMIT_SUBQUERY */

    /* The results are stored in a sequence of registers
    ** starting at pDest->iSdst.  Then the co-routine yields.
    */
    case SRT_Coroutine: {
      
// ABS Label 1772
if(pDest->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1772);
}

// ROR Label 1773
if((pDest->iSdst != 0) != (pDest->iSdst == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1773);
}
if( pDest->iSdst==0 ){
        pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);
        pDest->nSdst = pIn->nSdst;
      }
      
// ABS Label 1766
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1766);
}

// ABS Label 1767
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1767);
}

// ABS Label 1768
if(pDest->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1768);
}

// ABS Label 1769
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1769);
}
sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);
      
// ABS Label 1770
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1770);
}

// ABS Label 1771
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1771);
}
sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);
      break;
    }

    /* If none of the above, then the result destination must be
    ** SRT_Output.  This routine is never called with any other
    ** destination other than the ones handled above or SRT_Output.
    **
    ** For SRT_Output, results are stored in a sequence of registers.  
    ** Then the OP_ResultRow opcode is used to cause sqlite3_step() to
    ** return the next row of result.
    */
    default: {
      assert( pDest->eDest==SRT_Output );
      
// ABS Label 1774
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1774);
}

// ABS Label 1775
if(pIn->iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1775);
}

// ABS Label 1776
if(pIn->nSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1776);
}
sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iSdst, pIn->nSdst);
      break;
    }
  }

  /* Jump to the end of the loop if the LIMIT is reached.
  */
  
// ABS Label 1777
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1777);
}
if( p->iLimit ){
    
// ABS Label 1778
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1778);
}

// ABS Label 1779
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1779);
}

// ABS Label 1780
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1780);
}
sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);
  }

  /* Generate the subroutine return
  */
  
// ABS Label 1704
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1704);
}

// ABS Label 1705
if(iContinue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1705);
}
sqlite3VdbeResolveLabel(v, iContinue);
  
// ABS Label 1706
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1706);
}

// ABS Label 1707
if(regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1707);
}
sqlite3VdbeAddOp1(v, OP_Return, regReturn);

  
// ABS Label 1781
if(addr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1781);
}
return addr;
}

/*
** Alternative compound select code generator for cases when there
** is an ORDER BY clause.
**
** We assume a query of the following form:
**
**      <selectA>  <operator>  <selectB>  ORDER BY <orderbylist>
**
** <operator> is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea
** is to code both <selectA> and <selectB> with the ORDER BY clause as
** co-routines.  Then run the co-routines in parallel and merge the results
** into the output.  In addition to the two coroutines (called selectA and
** selectB) there are 7 subroutines:
**
**    outA:    Move the output of the selectA coroutine into the output
**             of the compound query.
**
**    outB:    Move the output of the selectB coroutine into the output
**             of the compound query.  (Only generated for UNION and
**             UNION ALL.  EXCEPT and INSERTSECT never output a row that
**             appears only in B.)
**
**    AltB:    Called when there is data from both coroutines and A<B.
**
**    AeqB:    Called when there is data from both coroutines and A==B.
**
**    AgtB:    Called when there is data from both coroutines and A>B.
**
**    EofA:    Called when data is exhausted from selectA.
**
**    EofB:    Called when data is exhausted from selectB.
**
** The implementation of the latter five subroutines depend on which 
** <operator> is used:
**
**
**             UNION ALL         UNION            EXCEPT          INTERSECT
**          -------------  -----------------  --------------  -----------------
**   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA
**
**   AeqB:   outA, nextA         nextA             nextA         outA, nextA
**
**   AgtB:   outB, nextB      outB, nextB          nextB            nextB
**
**   EofA:   outB, nextB      outB, nextB          halt             halt
**
**   EofB:   outA, nextA      outA, nextA       outA, nextA         halt
**
** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA
** causes an immediate jump to EofA and an EOF on B following nextB causes
** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or
** following nextX causes a jump to the end of the select processing.
**
** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled
** within the output subroutine.  The regPrev register set holds the previously
** output value.  A comparison is made against this value and the output
** is skipped if the next results would be the same as the previous.
**
** The implementation plan is to implement the two coroutines and seven
** subroutines first, then put the control logic at the bottom.  Like this:
**
**          goto Init
**     coA: coroutine for left query (A)
**     coB: coroutine for right query (B)
**    outA: output one row of A
**    outB: output one row of B (UNION and UNION ALL only)
**    EofA: ...
**    EofB: ...
**    AltB: ...
**    AeqB: ...
**    AgtB: ...
**    Init: initialize coroutine registers
**          yield coA
**          if eof(A) goto EofA
**          yield coB
**          if eof(B) goto EofB
**    Cmpr: Compare A, B
**          Jump AltB, AeqB, AgtB
**     End: ...
**
** We call AltB, AeqB, AgtB, EofA, and EofB "subroutines" but they are not
** actually called using Gosub and they do not Return.  EofA and EofB loop
** until all data is exhausted then jump to the "end" labe.  AltB, AeqB,
** and AgtB jump to either L2 or to one of EofA or EofB.
*/
#ifndef SQLITE_OMIT_COMPOUND_SELECT
static int multiSelectOrderBy(
  Parse *pParse,        /* Parsing context */
  Select *p,            /* The right-most of SELECTs to be coded */
  SelectDest *pDest     /* What to do with query results */
){
  int i, j;             /* Loop counters */
  Select *pPrior;       /* Another SELECT immediately to our left */
  Vdbe *v;              /* Generate code to this VDBE */
  SelectDest destA;     /* Destination for coroutine A */
  SelectDest destB;     /* Destination for coroutine B */
  int regAddrA;         /* Address register for select-A coroutine */
  int regAddrB;         /* Address register for select-B coroutine */
  int addrSelectA;      /* Address of the select-A coroutine */
  int addrSelectB;      /* Address of the select-B coroutine */
  int regOutA;          /* Address register for the output-A subroutine */
  int regOutB;          /* Address register for the output-B subroutine */
  int addrOutA;         /* Address of the output-A subroutine */
  int addrOutB = 0;     /* Address of the output-B subroutine */
  int addrEofA;         /* Address of the select-A-exhausted subroutine */
  int addrEofA_noB;     /* Alternate addrEofA if B is uninitialized */
  int addrEofB;         /* Address of the select-B-exhausted subroutine */
  int addrAltB;         /* Address of the A<B subroutine */
  int addrAeqB;         /* Address of the A==B subroutine */
  int addrAgtB;         /* Address of the A>B subroutine */
  int regLimitA;        /* Limit register for select-A */
  int regLimitB;        /* Limit register for select-A */
  int regPrev;          /* A range of registers to hold previous output */
  int savedLimit;       /* Saved value of p->iLimit */
  int savedOffset;      /* Saved value of p->iOffset */
  int labelCmpr;        /* Label for the start of the merge algorithm */
  int labelEnd;         /* Label for the end of the overall SELECT stmt */
  int addr1;            /* Jump instructions that get retargetted */
  int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */
  KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */
  KeyInfo *pKeyMerge;   /* Comparison information for merging rows */
  sqlite3 *db;          /* Database connection */
  ExprList *pOrderBy;   /* The ORDER BY clause */
  int nOrderBy;         /* Number of terms in the ORDER BY clause */
  u32 *aPermute;        /* Mapping from ORDER BY terms to result set columns */

  assert( p->pOrderBy!=0 );
  assert( pKeyDup==0 ); /* "Managed" code needs this.  Ticket #3382. */
  db = pParse->db;
  v = pParse->pVdbe;
  assert( v!=0 );       /* Already thrown the error if VDBE alloc failed */
  labelEnd = sqlite3VdbeMakeLabel(pParse);
  labelCmpr = sqlite3VdbeMakeLabel(pParse);


  /* Patch up the ORDER BY clause
  */
  op = p->op;  
  pPrior = p->pPrior;
  assert( pPrior->pOrderBy==0 );
  pOrderBy = p->pOrderBy;
  assert( pOrderBy );
  nOrderBy = pOrderBy->nExpr;

  /* For operators other than UNION ALL we have to make sure that
  ** the ORDER BY clause covers every term of the result set.  Add
  ** terms to the ORDER BY clause as necessary.
  */
  
// ABS Label 1841
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1841);
}

// ROR Label 1842
if((op == 134) != (op != 134))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1842);
}
if( op!=TK_ALL ){
    i = 1;

// ABS Label 1843
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1843);
}
// ABS Label 1844
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1844);
}

// COR Label 1845
if((db->mallocFailed == 0 || i <= p->pEList->nExpr) != (db->mallocFailed == 0 && i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1845);
}

// ROR Label 1846
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1846);
}
// ROR Label 1847
if((i < p->pEList->nExpr) != (i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1847);
}
// ROR Label 1848
if((i > p->pEList->nExpr) != (i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1848);
}
// ROR Label 1849
if((i >= p->pEList->nExpr) != (i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1849);
}

// MCC Label 1850
if(db->mallocFailed == 0 && i <= p->pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1850);
}
// MCC Label 1851
if(db->mallocFailed == 0 && !(i <= p->pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1851);
}
// MCC Label 1852
if(!(db->mallocFailed == 0) && i <= p->pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1852);
}
// MCC Label 1853
if(!(db->mallocFailed == 0) && !(i <= p->pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1853);
}
for(; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){
      struct ExprList_item *pItem;
      j = 0 , pItem = pOrderBy->a;

// ABS Label 1865
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1865);
}
// ABS Label 1866
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1866);
}

// ROR Label 1867
if((j <= nOrderBy) != (j < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1867);
}
// ROR Label 1868
if((j > nOrderBy) != (j < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1868);
}
// ROR Label 1869
if((j >= nOrderBy) != (j < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1869);
}
for(; j<nOrderBy; j++, pItem++){
        assert( pItem->u.x.iOrderByCol>0 );
        
// ABS Label 1875
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1875);
}

// ROR Label 1876
if((pItem->u.x.iOrderByCol != i) != (pItem->u.x.iOrderByCol == i))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1876);
}
if( pItem->u.x.iOrderByCol==i ) { break;
}
      };
// ABS Label 1870
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1870);
}
// ABS Label 1871
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1871);
}

// ROR Label 1872
if((j <= nOrderBy) != (j < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1872);
}
// ROR Label 1873
if((j > nOrderBy) != (j < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1873);
}
// ROR Label 1874
if((j >= nOrderBy) != (j < nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1874);
}

      
// ABS Label 1877
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1877);
}
// ABS Label 1878
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1878);
}

// ROR Label 1879
if((j != nOrderBy) != (j == nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1879);
}
if( j==nOrderBy ){
        Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);
        
// ABS Label 1880
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1880);
}

// ROR Label 1881
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1881);
}
if( pNew==0 ) { return SQLITE_NOMEM_BKPT;
}
        pNew->flags |= EP_IntValue;
        pNew->u.iValue = i;
        p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
        
// ABS Label 1882
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1882);
}
if( pOrderBy ) { pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;
}
      }
    };
// ABS Label 1854
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1854);
}
// ABS Label 1855
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1855);
}

// COR Label 1856
if((db->mallocFailed == 0 || i <= p->pEList->nExpr) != (db->mallocFailed == 0 && i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1856);
}

// ROR Label 1857
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1857);
}
// ROR Label 1858
if((i < p->pEList->nExpr) != (i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1858);
}
// ROR Label 1859
if((i > p->pEList->nExpr) != (i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1859);
}
// ROR Label 1860
if((i >= p->pEList->nExpr) != (i <= p->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1860);
}

// MCC Label 1861
if(db->mallocFailed == 0 && i <= p->pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1861);
}
// MCC Label 1862
if(db->mallocFailed == 0 && !(i <= p->pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1862);
}
// MCC Label 1863
if(!(db->mallocFailed == 0) && i <= p->pEList->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1863);
}
// MCC Label 1864
if(!(db->mallocFailed == 0) && !(i <= p->pEList->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1864);
}

  }

  /* Compute the comparison permutation and keyinfo that is used with
  ** the permutation used to determine if the next
  ** row of results comes from selectA or selectB.  Also add explicit
  ** collations to the ORDER BY clause terms so that when the subqueries
  ** to the right and the left are evaluated, they use the correct
  ** collation.
  */
  aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));
  
// ABS Label 1883
if(aPermute < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1883);
}
if( aPermute ){
    struct ExprList_item *pItem;
    aPermute[0] = nOrderBy;
    i = 1 , pItem = pOrderBy->a;

// ABS Label 1884
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1884);
}
// ABS Label 1885
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1885);
}

// ROR Label 1886
if((i < nOrderBy) != (i <= nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1886);
}
// ROR Label 1887
if((i > nOrderBy) != (i <= nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1887);
}
// ROR Label 1888
if((i >= nOrderBy) != (i <= nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1888);
}
for(; i<=nOrderBy; i++, pItem++){
      assert( pItem->u.x.iOrderByCol>0 );
      assert( pItem->u.x.iOrderByCol<=p->pEList->nExpr );
      aPermute[i] = pItem->u.x.iOrderByCol - 1;
    };
// ABS Label 1889
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1889);
}
// ABS Label 1890
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1890);
}

// ROR Label 1891
if((i < nOrderBy) != (i <= nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1891);
}
// ROR Label 1892
if((i > nOrderBy) != (i <= nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1892);
}
// ROR Label 1893
if((i >= nOrderBy) != (i <= nOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1893);
}

    pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);
  }else{
    pKeyMerge = 0;
  }

  /* Reattach the ORDER BY clause to the query.
  */
  p->pOrderBy = pOrderBy;
  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);

  /* Allocate a range of temporary registers and the KeyInfo needed
  ** for the logic that removes duplicate result rows when the
  ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).
  */
  
// ABS Label 1894
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1894);
}

// ROR Label 1895
if((op != 134) != (op == 134))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1895);
}
if( op==TK_ALL ){
    regPrev = 0;
  }else{
    
// ABS Label 1896
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1896);
}
int nExpr = p->pEList->nExpr;
    assert( nOrderBy>=nExpr || db->mallocFailed );
    regPrev = pParse->nMem+1;
    pParse->nMem += nExpr+1;
    
// ABS Label 1897
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1897);
}

// ABS Label 1898
if(regPrev < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1898);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);
    pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);
    
// ABS Label 1899
if(pKeyDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1899);
}
if( pKeyDup ){
      assert( sqlite3KeyInfoIsWriteable(pKeyDup) );
      i = 0;

// ABS Label 1900
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1900);
}
// ABS Label 1901
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1901);
}

// ROR Label 1902
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1902);
}
// ROR Label 1903
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1903);
}
// ROR Label 1904
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1904);
}
for(; i<nExpr; i++){
        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
        pKeyDup->aSortFlags[i] = 0;
      };
// ABS Label 1905
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1905);
}
// ABS Label 1906
if(nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1906);
}

// ROR Label 1907
if((i <= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1907);
}
// ROR Label 1908
if((i > nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1908);
}
// ROR Label 1909
if((i >= nExpr) != (i < nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1909);
}

    }
  }
 
  /* Separate the left and the right query from one another
  */
  p->pPrior = 0;
  pPrior->pNext = 0;
  
// ABS Label 1782
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1782);
}

// ABS Label 1783
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1783);
}

// ABS Label 1784
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1784);
}
sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
  
// ABS Label 1910
if(pPrior->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1910);
}

// ROR Label 1911
if((pPrior->pPrior != 0) != (pPrior->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1911);
}
if( pPrior->pPrior==0 ){
    
// ABS Label 1912
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1912);
}

// ABS Label 1913
if(pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1913);
}

// ABS Label 1914
if(pPrior->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1914);
}
sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
  }

  /* Compute the limit registers */
  
// ABS Label 1785
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1785);
}

// ABS Label 1786
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1786);
}

// ABS Label 1787
if(labelEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1787);
}
computeLimitRegisters(pParse, p, labelEnd);
  
// ABS Label 1915
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1915);
}
// ABS Label 1916
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1916);
}

// COR Label 1917
if((p->iLimit || op == 134) != (p->iLimit && op == 134))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1917);
}

// ROR Label 1918
if((op != 134) != (op == 134))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1918);
}

// MCC Label 1919
if(p->iLimit && op == 134 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1919);
}
// MCC Label 1920
if(p->iLimit && !(op == 134) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1920);
}
// MCC Label 1921
if(!(p->iLimit) && op == 134 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1921);
}
// MCC Label 1922
if(!(p->iLimit) && !(op == 134) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1922);
}
if( p->iLimit && op==TK_ALL ){
    regLimitA = ++pParse->nMem;
    regLimitB = ++pParse->nMem;
    
// ABS Label 1923
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1923);
}

// ABS Label 1924
if(regLimitA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1924);
}
sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit,
                                  regLimitA);
    
// ABS Label 1925
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1925);
}

// ABS Label 1926
if(regLimitA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1926);
}

// ABS Label 1927
if(regLimitB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1927);
}
sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);
  }else{
    regLimitA = regLimitB = 0;
  }
  
// ABS Label 1788
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1788);
}

// ABS Label 1789
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1789);
}
sqlite3ExprDelete(db, p->pLimit);
  p->pLimit = 0;

  regAddrA = ++pParse->nMem;
  regAddrB = ++pParse->nMem;
  regOutA = ++pParse->nMem;
  regOutB = ++pParse->nMem;
  
// ABS Label 1790
if(regAddrA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1790);
}
sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);
  
// ABS Label 1791
if(regAddrB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1791);
}
sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);

  ExplainQueryPlan((pParse, 1, "MERGE (%s)", sqlite3SelectOpName(p->op)));

  /* Generate a coroutine to evaluate the SELECT statement to the
  ** left of the compound operator - the "A" select.
  */
  addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;
  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);
  VdbeComment((v, "left SELECT"));
  pPrior->iLimit = regLimitA;
  ExplainQueryPlan((pParse, 1, "LEFT"));
  
// ABS Label 1794
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1794);
}

// ABS Label 1795
if(pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1795);
}
sqlite3Select(pParse, pPrior, &destA);
  
// ABS Label 1796
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1796);
}

// ABS Label 1797
if(regAddrA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1797);
}
sqlite3VdbeEndCoroutine(v, regAddrA);
  
// ABS Label 1798
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1798);
}

// ABS Label 1799
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1799);
}
sqlite3VdbeJumpHere(v, addr1);

  /* Generate a coroutine to evaluate the SELECT statement on 
  ** the right - the "B" select
  */
  addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;
  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);
  VdbeComment((v, "right SELECT"));
  savedLimit = p->iLimit;
  savedOffset = p->iOffset;
  p->iLimit = regLimitB;
  p->iOffset = 0;  
  ExplainQueryPlan((pParse, 1, "RIGHT"));
  
// ABS Label 1801
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1801);
}

// ABS Label 1802
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1802);
}
sqlite3Select(pParse, p, &destB);
  p->iLimit = savedLimit;
  p->iOffset = savedOffset;
  
// ABS Label 1803
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1803);
}

// ABS Label 1804
if(regAddrB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1804);
}
sqlite3VdbeEndCoroutine(v, regAddrB);

  /* Generate a subroutine that outputs the current row of the A
  ** select as the next output row of the compound select.
  */
  VdbeNoopComment((v, "Output routine for A"));
  addrOutA = generateOutputSubroutine(pParse,
                 p, &destA, pDest, regOutA,
                 regPrev, pKeyDup, labelEnd);
  
  /* Generate a subroutine that outputs the current row of the B
  ** select as the next output row of the compound select.
  */
  
// ABS Label 1928
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1928);
}

// COR Label 1929
if((op == 134 && op == 133) != (op == 134 || op == 133))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1929);
}

// ROR Label 1930
if((op != 134) != (op == 134))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1930);
}
// ROR Label 1931
if((op != 133) != (op == 133))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1931);
}

// MCC Label 1932
if(op == 134 && op == 133 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1932);
}
// MCC Label 1933
if(op == 134 && !(op == 133) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1933);
}
// MCC Label 1934
if(!(op == 134) && op == 133 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1934);
}
// MCC Label 1935
if(!(op == 134) && !(op == 133) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1935);
}
if( op==TK_ALL || op==TK_UNION ){
    VdbeNoopComment((v, "Output routine for B"));
    addrOutB = generateOutputSubroutine(pParse,
                 p, &destB, pDest, regOutB,
                 regPrev, pKeyDup, labelEnd);
  }
  
// ABS Label 1805
if(pKeyDup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1805);
}
sqlite3KeyInfoUnref(pKeyDup);

  /* Generate a subroutine to run when the results from select A
  ** are exhausted and only data in select B remains.
  */
  
// ABS Label 1936
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1936);
}

// COR Label 1937
if((op == 135 && op == 136) != (op == 135 || op == 136))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1937);
}

// ROR Label 1938
if((op != 135) != (op == 135))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1938);
}
// ROR Label 1939
if((op != 136) != (op == 136))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1939);
}

// MCC Label 1940
if(op == 135 && op == 136 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1940);
}
// MCC Label 1941
if(op == 135 && !(op == 136) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1941);
}
// MCC Label 1942
if(!(op == 135) && op == 136 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1942);
}
// MCC Label 1943
if(!(op == 135) && !(op == 136) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1943);
}
if( op==TK_EXCEPT || op==TK_INTERSECT ){
    addrEofA_noB = addrEofA = labelEnd;
  }else{  
    VdbeNoopComment((v, "eof-A subroutine"));
    addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);
    addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);
                                     VdbeCoverage(v);
    
// ABS Label 1944
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1944);
}

// ABS Label 1945
if(addrEofA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1945);
}
sqlite3VdbeGoto(v, addrEofA);
    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
  }

  /* Generate a subroutine to run when the results from select B
  ** are exhausted and only data in select A remains.
  */
  
// ABS Label 1946
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1946);
}

// ROR Label 1947
if((op != 136) != (op == 136))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1947);
}
if( op==TK_INTERSECT ){
    addrEofB = addrEofA;
    
// ROR Label 1948
if((p->nSelectRow <= pPrior->nSelectRow) != (p->nSelectRow > pPrior->nSelectRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1948);
}
// ROR Label 1949
if((p->nSelectRow < pPrior->nSelectRow) != (p->nSelectRow > pPrior->nSelectRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1949);
}
// ROR Label 1950
if((p->nSelectRow >= pPrior->nSelectRow) != (p->nSelectRow > pPrior->nSelectRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1950);
}
if( p->nSelectRow > pPrior->nSelectRow ) { p->nSelectRow = pPrior->nSelectRow;
}
  }else{  
    VdbeNoopComment((v, "eof-B subroutine"));
    addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);
    
// ABS Label 1951
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1951);
}

// ABS Label 1952
if(regAddrA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1952);
}

// ABS Label 1953
if(labelEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1953);
}
sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);
    
// ABS Label 1954
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1954);
}

// ABS Label 1955
if(addrEofB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1955);
}
sqlite3VdbeGoto(v, addrEofB);
  }

  /* Generate code to handle the case of A<B
  */
  VdbeNoopComment((v, "A-lt-B subroutine"));
  addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);
  
// ABS Label 1806
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1806);
}

// ABS Label 1807
if(regAddrA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1807);
}

// ABS Label 1808
if(addrEofA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1808);
}
sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);
  
// ABS Label 1809
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1809);
}

// ABS Label 1810
if(labelCmpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1810);
}
sqlite3VdbeGoto(v, labelCmpr);

  /* Generate code to handle the case of A==B
  */
  
// ABS Label 1956
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1956);
}

// ROR Label 1957
if((op != 134) != (op == 134))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1957);
}
if( op==TK_ALL ){
    addrAeqB = addrAltB;
  }else { 
// ABS Label 1958
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1958);
}

// ROR Label 1959
if((op != 136) != (op == 136))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1959);
}
if( op==TK_INTERSECT ){
    addrAeqB = addrAltB;
    addrAltB++;
  }else{
    VdbeNoopComment((v, "A-eq-B subroutine"));
    addrAeqB =
    sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);
    
// ABS Label 1960
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1960);
}

// ABS Label 1961
if(labelCmpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1961);
}
sqlite3VdbeGoto(v, labelCmpr);
  };}


  /* Generate code to handle the case of A>B
  */
  VdbeNoopComment((v, "A-gt-B subroutine"));
  addrAgtB = sqlite3VdbeCurrentAddr(v);
  
// ABS Label 1962
if(op < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1962);
}

// COR Label 1963
if((op == 134 && op == 133) != (op == 134 || op == 133))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1963);
}

// ROR Label 1964
if((op != 134) != (op == 134))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1964);
}
// ROR Label 1965
if((op != 133) != (op == 133))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1965);
}

// MCC Label 1966
if(op == 134 && op == 133 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1966);
}
// MCC Label 1967
if(op == 134 && !(op == 133) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1967);
}
// MCC Label 1968
if(!(op == 134) && op == 133 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1968);
}
// MCC Label 1969
if(!(op == 134) && !(op == 133) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1969);
}
if( op==TK_ALL || op==TK_UNION ){
    
// ABS Label 1970
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1970);
}

// ABS Label 1971
if(regOutB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1971);
}

// ABS Label 1972
if(addrOutB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1972);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);
  }
  
// ABS Label 1811
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1811);
}

// ABS Label 1812
if(regAddrB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1812);
}

// ABS Label 1813
if(addrEofB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1813);
}
sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);
  
// ABS Label 1814
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1814);
}

// ABS Label 1815
if(labelCmpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1815);
}
sqlite3VdbeGoto(v, labelCmpr);

  /* This code runs once to initialize everything.
  */
  
// ABS Label 1816
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1816);
}

// ABS Label 1817
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1817);
}
sqlite3VdbeJumpHere(v, addr1);
  
// ABS Label 1818
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1818);
}

// ABS Label 1819
if(regAddrA < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1819);
}

// ABS Label 1820
if(addrEofA_noB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1820);
}
sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);
  
// ABS Label 1821
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1821);
}

// ABS Label 1822
if(regAddrB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1822);
}

// ABS Label 1823
if(addrEofB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1823);
}
sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);

  /* Implement the main merge loop
  */
  
// ABS Label 1824
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1824);
}

// ABS Label 1825
if(labelCmpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1825);
}
sqlite3VdbeResolveLabel(v, labelCmpr);
  
// ABS Label 1826
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1826);
}
sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);
  
// ABS Label 1827
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1827);
}

// ABS Label 1828
if(destA.iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1828);
}

// ABS Label 1829
if(destB.iSdst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1829);
}

// ABS Label 1830
if(nOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1830);
}
sqlite3VdbeAddOp4(v, OP_Compare, destA.iSdst, destB.iSdst, nOrderBy,
                         (char*)pKeyMerge, P4_KEYINFO);
  
// ABS Label 1831
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1831);
}
sqlite3VdbeChangeP5(v, OPFLAG_PERMUTE);
  
// ABS Label 1832
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1832);
}

// ABS Label 1833
if(addrAltB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1833);
}

// ABS Label 1834
if(addrAeqB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1834);
}

// ABS Label 1835
if(addrAgtB < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1835);
}
sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); VdbeCoverage(v);

  /* Jump to the this point in order to terminate the query.
  */
  
// ABS Label 1836
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1836);
}

// ABS Label 1837
if(labelEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1837);
}
sqlite3VdbeResolveLabel(v, labelEnd);

  /* Reassembly the compound query so that it will be freed correctly
  ** by the calling function */
  
// ABS Label 1973
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1973);
}
if( p->pPrior ){
    
// ABS Label 1974
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1974);
}

// ABS Label 1975
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1975);
}
sqlite3SelectDelete(db, p->pPrior);
  }
  p->pPrior = pPrior;
  pPrior->pNext = p;

  
// ABS Label 1838
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1838);
}

// ABS Label 1839
if(pPrior->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1839);
}
sqlite3ExprListDelete(db, pPrior->pOrderBy);
  pPrior->pOrderBy = 0;

  /*** TBD:  Insert subroutine calls to close cursors on incomplete
  **** subqueries ****/
  ExplainQueryPlanPop(pParse);
  
// ABS Label 1976
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1976);
}

// ROR Label 1977
if((pParse->nErr == 0) != (pParse->nErr != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1977);
}
return pParse->nErr!=0;
}
#endif

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)

/* An instance of the SubstContext object describes an substitution edit
** to be performed on a parse tree.
**
** All references to columns in table iTable are to be replaced by corresponding
** expressions in pEList.
*/
typedef struct SubstContext {
  Parse *pParse;            /* The parsing context */
  int iTable;               /* Replace references to this table */
  int iNewTable;            /* New table number */
  int isLeftJoin;           /* Add TK_IF_NULL_ROW opcodes on each replacement */
  ExprList *pEList;         /* Replacement expressions */
} SubstContext;

/* Forward Declarations */
static void substExprList(SubstContext*, ExprList*);
static void substSelect(SubstContext*, Select*, int);

/*
** Scan through the expression pExpr.  Replace every reference to
** a column in table number iTable with a copy of the iColumn-th
** entry in pEList.  (But leave references to the ROWID column 
** unchanged.)
**
** This routine is part of the flattening procedure.  A subquery
** whose result set is defined by pEList appears as entry in the
** FROM clause of a SELECT such that the VDBE cursor assigned to that
** FORM clause entry is iTable.  This routine makes the necessary 
** changes to pExpr so that it refers directly to the source table
** of the subquery rather the result set of the subquery.
*/
static Expr *substExpr(
  SubstContext *pSubst,  /* Description of the substitution */
  Expr *pExpr            /* Expr in which substitution occurs */
){
  
// ABS Label 1978
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1978);
}

// ROR Label 1979
if((pExpr != 0) != (pExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1979);
}
if( pExpr==0 ) { return 0;
}
  
// ABS Label 1980
if(pExpr->iRightJoinTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1980);
}
// ABS Label 1981
if(pSubst->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1981);
}

// COR Label 1982
if(((((pExpr)->flags & (1)) != 0) || pExpr->iRightJoinTable == pSubst->iTable) != ((((pExpr)->flags & (1)) != 0) && pExpr->iRightJoinTable == pSubst->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1982);
}

// ROR Label 1983
if((pExpr->iRightJoinTable != pSubst->iTable) != (pExpr->iRightJoinTable == pSubst->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1983);
}

// MCC Label 1984
if(( ((pExpr)->flags & (1)) != 0 ) && pExpr->iRightJoinTable == pSubst->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1984);
}
// MCC Label 1985
if(( ((pExpr)->flags & (1)) != 0 ) && !(pExpr->iRightJoinTable == pSubst->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1985);
}
// MCC Label 1986
if(( !(((pExpr)->flags & (1)) != 0) ) && pExpr->iRightJoinTable == pSubst->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1986);
}
// MCC Label 1987
if(( !(((pExpr)->flags & (1)) != 0) ) && !(pExpr->iRightJoinTable == pSubst->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1987);
}
if( ExprHasProperty(pExpr, EP_FromJoin)
   && pExpr->iRightJoinTable==pSubst->iTable
  ){
    pExpr->iRightJoinTable = pSubst->iNewTable;
  }
  
// ABS Label 1988
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1988);
}
// ABS Label 1989
if(pSubst->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 1989);
}

// COR Label 1990
if((pExpr->op == 166 && pExpr->iTable == pSubst->iTable || !(((pExpr)->flags & (8)) != 0)) != (pExpr->op == 166 && pExpr->iTable == pSubst->iTable && !(((pExpr)->flags & (8)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1990);
}
// COR Label 1991
if((pExpr->op == 166 || pExpr->iTable == pSubst->iTable) != (pExpr->op == 166 && pExpr->iTable == pSubst->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 1991);
}

// ROR Label 1992
if((pExpr->op != 166) != (pExpr->op == 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1992);
}
// ROR Label 1993
if((pExpr->iTable != pSubst->iTable) != (pExpr->iTable == pSubst->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 1993);
}

// MCC Label 1994
if(pExpr->op == 166 && pExpr->iTable == pSubst->iTable && !(((pExpr)->flags & (8)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1994);
}
// MCC Label 1995
if(pExpr->op == 166 && pExpr->iTable == pSubst->iTable && !(!(((pExpr)->flags & (8)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1995);
}
// MCC Label 1996
if(pExpr->op == 166 && !(pExpr->iTable == pSubst->iTable) && !(((pExpr)->flags & (8)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1996);
}
// MCC Label 1997
if(pExpr->op == 166 && !(pExpr->iTable == pSubst->iTable) && !(!(((pExpr)->flags & (8)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1997);
}
// MCC Label 1998
if(!(pExpr->op == 166) && pExpr->iTable == pSubst->iTable && !(((pExpr)->flags & (8)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1998);
}
// MCC Label 1999
if(!(pExpr->op == 166) && pExpr->iTable == pSubst->iTable && !(!(((pExpr)->flags & (8)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 1999);
}
// MCC Label 2000
if(!(pExpr->op == 166) && !(pExpr->iTable == pSubst->iTable) && !(((pExpr)->flags & (8)) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2000);
}
// MCC Label 2001
if(!(pExpr->op == 166) && !(pExpr->iTable == pSubst->iTable) && !(!(((pExpr)->flags & (8)) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2001);
}
if( pExpr->op==TK_COLUMN
   && pExpr->iTable==pSubst->iTable
   && !ExprHasProperty(pExpr, EP_FixedCol)
  ){
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
    if( pExpr->iColumn<0 ){
      pExpr->op = TK_NULL;
    }else
#endif
    {
      Expr *pNew;
      
// ABS Label 2002
if(pSubst->pEList->a[pExpr->iColumn].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2002);
}
Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;
      Expr ifNullRow;
      assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );
      assert( pExpr->pRight==0 );
      if( sqlite3ExprIsVector(pCopy) ){
        
// ABS Label 2003
if(pSubst->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2003);
}

// ABS Label 2004
if(pCopy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2004);
}
sqlite3VectorErrorMsg(pSubst->pParse, pCopy);
      }else{
        
// ABS Label 2005
if(pSubst->pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2005);
}
sqlite3 *db = pSubst->pParse->db;
        
// ABS Label 2008
if(pSubst->isLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2008);
}

// COR Label 2009
if((pSubst->isLeftJoin || pCopy->op != 166) != (pSubst->isLeftJoin && pCopy->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2009);
}

// ROR Label 2010
if((pCopy->op == 166) != (pCopy->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2010);
}

// MCC Label 2011
if(pSubst->isLeftJoin && pCopy->op != 166 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2011);
}
// MCC Label 2012
if(pSubst->isLeftJoin && !(pCopy->op != 166) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2012);
}
// MCC Label 2013
if(!(pSubst->isLeftJoin) && pCopy->op != 166 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2013);
}
// MCC Label 2014
if(!(pSubst->isLeftJoin) && !(pCopy->op != 166) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2014);
}
if( pSubst->isLeftJoin && pCopy->op!=TK_COLUMN ){
          memset(&ifNullRow, 0, sizeof(ifNullRow));
          ifNullRow.op = TK_IF_NULL_ROW;
          ifNullRow.pLeft = pCopy;
          ifNullRow.iTable = pSubst->iNewTable;
          ifNullRow.flags = EP_IfNullRow;
          pCopy = &ifNullRow;
        }
        testcase( ExprHasProperty(pCopy, EP_Subquery) );
        pNew = sqlite3ExprDup(db, pCopy, 0);
        
// ABS Label 2015
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2015);
}
if( db->mallocFailed ){
          
// ABS Label 2016
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2016);
}

// ABS Label 2017
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2017);
}
sqlite3ExprDelete(db, pNew);
          
// ABS Label 2018
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2018);
}
return pExpr;
        }
        
// ABS Label 2019
if(pSubst->isLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2019);
}
if( pSubst->isLeftJoin ){
          ExprSetProperty(pNew, EP_CanBeNull);
        }
        
// MCC Label 2020
if(( ((pExpr)->flags & (1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2020);
}
// MCC Label 2021
if(( !(((pExpr)->flags & (1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2021);
}
if( ExprHasProperty(pExpr,EP_FromJoin) ){
          
// ABS Label 2022
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2022);
}

// ABS Label 2023
if(pExpr->iRightJoinTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2023);
}
sqlite3SetJoinExpr(pNew, pExpr->iRightJoinTable);
        }
        
// ABS Label 2006
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2006);
}

// ABS Label 2007
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2007);
}
sqlite3ExprDelete(db, pExpr);
        pExpr = pNew;

        /* Ensure that the expression now has an implicit collation sequence,
        ** just as it did when it was a column of a view or sub-query. */
        
// COR Label 2024
if((pExpr->op != 166 || pExpr->op != 112) != (pExpr->op != 166 && pExpr->op != 112))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2024);
}

// ROR Label 2025
if((pExpr->op == 166) != (pExpr->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2025);
}
// ROR Label 2026
if((pExpr->op == 112) != (pExpr->op != 112))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2026);
}

// MCC Label 2027
if(pExpr->op != 166 && pExpr->op != 112 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2027);
}
// MCC Label 2028
if(pExpr->op != 166 && !(pExpr->op != 112) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2028);
}
// MCC Label 2029
if(!(pExpr->op != 166) && pExpr->op != 112 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2029);
}
// MCC Label 2030
if(!(pExpr->op != 166) && !(pExpr->op != 112) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2030);
}
if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){
          CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);
          pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr, 
              (pColl ? pColl->zName : "BINARY")
          );
        }
        ExprClearProperty(pExpr, EP_Collate);
      }
    }
  }else{
    
// ABS Label 2031
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2031);
}
// ABS Label 2032
if(pSubst->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2032);
}

// COR Label 2033
if((pExpr->op == 178 || pExpr->iTable == pSubst->iTable) != (pExpr->op == 178 && pExpr->iTable == pSubst->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2033);
}

// ROR Label 2034
if((pExpr->op != 178) != (pExpr->op == 178))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2034);
}
// ROR Label 2035
if((pExpr->iTable != pSubst->iTable) != (pExpr->iTable == pSubst->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2035);
}

// MCC Label 2036
if(pExpr->op == 178 && pExpr->iTable == pSubst->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2036);
}
// MCC Label 2037
if(pExpr->op == 178 && !(pExpr->iTable == pSubst->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2037);
}
// MCC Label 2038
if(!(pExpr->op == 178) && pExpr->iTable == pSubst->iTable ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2038);
}
// MCC Label 2039
if(!(pExpr->op == 178) && !(pExpr->iTable == pSubst->iTable) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2039);
}
if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){
      pExpr->iTable = pSubst->iNewTable;
    }
    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);
    pExpr->pRight = substExpr(pSubst, pExpr->pRight);
    
// MCC Label 2040
if(( ((pExpr)->flags & (2048)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2040);
}
// MCC Label 2041
if(( !(((pExpr)->flags & (2048)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2041);
}
if( ExprHasProperty(pExpr, EP_xIsSelect) ){
      
// ABS Label 2042
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2042);
}

// ABS Label 2043
if(pExpr->x.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2043);
}
substSelect(pSubst, pExpr->x.pSelect, 1);
    }else{
      
// ABS Label 2044
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2044);
}

// ABS Label 2045
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2045);
}
substExprList(pSubst, pExpr->x.pList);
    }
#ifndef SQLITE_OMIT_WINDOWFUNC
    
// MCC Label 2046
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2046);
}
// MCC Label 2047
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2047);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
      
// ABS Label 2048
if(pExpr->y.pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2048);
}
Window *pWin = pExpr->y.pWin;
      pWin->pFilter = substExpr(pSubst, pWin->pFilter);
      
// ABS Label 2049
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2049);
}

// ABS Label 2050
if(pWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2050);
}
substExprList(pSubst, pWin->pPartition);
      
// ABS Label 2051
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2051);
}

// ABS Label 2052
if(pWin->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2052);
}
substExprList(pSubst, pWin->pOrderBy);
    }
#endif
  }
  
// ABS Label 2053
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2053);
}
return pExpr;
}
static void substExprList(
  SubstContext *pSubst, /* Description of the substitution */
  ExprList *pList       /* List to scan and in which to make substitutes */
){
  int i;
  
// ABS Label 2054
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2054);
}

// ROR Label 2055
if((pList != 0) != (pList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2055);
}
if( pList==0 ) { return;
}
  i = 0;

// ABS Label 2056
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2056);
}
// ABS Label 2057
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2057);
}

// ROR Label 2058
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2058);
}
// ROR Label 2059
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2059);
}
// ROR Label 2060
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2060);
}
for(; i<pList->nExpr; i++){
    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);
  };
// ABS Label 2061
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2061);
}
// ABS Label 2062
if(pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2062);
}

// ROR Label 2063
if((i <= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2063);
}
// ROR Label 2064
if((i > pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2064);
}
// ROR Label 2065
if((i >= pList->nExpr) != (i < pList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2065);
}

}
static void substSelect(
  SubstContext *pSubst, /* Description of the substitution */
  Select *p,            /* SELECT statement in which to make substitutions */
  int doPrior           /* Do substitutes on p->pPrior too */
){
  SrcList *pSrc;
  SrcItem *pItem;
  int i;
  if( !p ) { return;
}
  do{
    
// ABS Label 2066
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2066);
}

// ABS Label 2067
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2067);
}
substExprList(pSubst, p->pEList);
    
// ABS Label 2068
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2068);
}

// ABS Label 2069
if(p->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2069);
}
substExprList(pSubst, p->pGroupBy);
    
// ABS Label 2070
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2070);
}

// ABS Label 2071
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2071);
}
substExprList(pSubst, p->pOrderBy);
    p->pHaving = substExpr(pSubst, p->pHaving);
    p->pWhere = substExpr(pSubst, p->pWhere);
    pSrc = p->pSrc;
    assert( pSrc!=0 );
    i = pSrc->nSrc , pItem = pSrc->a;

// ABS Label 2072
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2072);
}

// ROR Label 2073
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2073);
}
// ROR Label 2074
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2074);
}
// ROR Label 2075
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2075);
}
for(; i>0; i--, pItem++){
      
// ABS Label 2080
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2080);
}

// ABS Label 2081
if(pItem->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2081);
}
substSelect(pSubst, pItem->pSelect, 1);
      
// ABS Label 2082
if(pItem->fg.isTabFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2082);
}
if( pItem->fg.isTabFunc ){
        
// ABS Label 2083
if(pSubst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2083);
}

// ABS Label 2084
if(pItem->u1.pFuncArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2084);
}
substExprList(pSubst, pItem->u1.pFuncArg);
      }
    };
// ABS Label 2076
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2076);
}

// ROR Label 2077
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2077);
}
// ROR Label 2078
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2078);
}
// ROR Label 2079
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2079);
}

  }while( doPrior && (p = p->pPrior)!=0 );;
}
#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
/*
** pSelect is a SELECT statement and pSrcItem is one item in the FROM
** clause of that SELECT.
**
** This routine scans the entire SELECT statement and recomputes the
** pSrcItem->colUsed mask.
*/
static int recomputeColumnsUsedExpr(Walker *pWalker, Expr *pExpr){
  SrcItem *pItem;
  
// ROR Label 2085
if((pExpr->op == 166) != (pExpr->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2085);
}
if( pExpr->op!=TK_COLUMN ) { return WRC_Continue;
}
  pItem = pWalker->u.pSrcItem;
  
// ABS Label 2086
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2086);
}
// ABS Label 2087
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2087);
}

// ROR Label 2088
if((pItem->iCursor == pExpr->iTable) != (pItem->iCursor != pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2088);
}
if( pItem->iCursor!=pExpr->iTable ) { return WRC_Continue;
}
  
// ROR Label 2089
if((pExpr->iColumn <= 0) != (pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2089);
}
// ROR Label 2090
if((pExpr->iColumn > 0) != (pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2090);
}
// ROR Label 2091
if((pExpr->iColumn >= 0) != (pExpr->iColumn < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2091);
}
if( pExpr->iColumn<0 ) { return WRC_Continue;
}
  pItem->colUsed |= sqlite3ExprColUsed(pExpr);
  return WRC_Continue;
}
static void recomputeColumnsUsed(
  Select *pSelect,                 /* The complete SELECT statement */
  SrcItem *pSrcItem                /* Which FROM clause item to recompute */
){
  Walker w;
  
// MCC Label 2093
if(( pSrcItem->pTab == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2093);
}
// MCC Label 2094
if(( !(pSrcItem->pTab == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2094);
}
if( NEVER(pSrcItem->pTab==0) ) { return;
}
  memset(&w, 0, sizeof(w));
  w.xExprCallback = recomputeColumnsUsedExpr;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.u.pSrcItem = pSrcItem;
  pSrcItem->colUsed = 0;
  
// ABS Label 2092
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2092);
}
sqlite3WalkSelect(&w, pSelect);
}
#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
/*
** Assign new cursor numbers to each of the items in pSrc. For each
** new cursor number assigned, set an entry in the aCsrMap[] array 
** to map the old cursor number to the new:
**
**     aCsrMap[iOld] = iNew;
**
** The array is guaranteed by the caller to be large enough for all
** existing cursor numbers in pSrc.
**
** If pSrc contains any sub-selects, call this routine recursively
** on the FROM clause of each such sub-select, with iExcept set to -1.
*/
static void srclistRenumberCursors(
  Parse *pParse,                  /* Parse context */
  int *aCsrMap,                   /* Array to store cursor mappings in */
  SrcList *pSrc,                  /* FROM clause to renumber */
  int iExcept                     /* FROM clause item to skip */
){
  int i;
  SrcItem *pItem;
  i = 0 , pItem = pSrc->a;

// ABS Label 2095
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2095);
}
// ABS Label 2096
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2096);
}

// ROR Label 2097
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2097);
}
// ROR Label 2098
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2098);
}
// ROR Label 2099
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2099);
}
for(; i<pSrc->nSrc; i++, pItem++){
    
// ABS Label 2105
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2105);
}
// ABS Label 2106
if(iExcept < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2106);
}

// ROR Label 2107
if((i == iExcept) != (i != iExcept))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2107);
}
if( i!=iExcept ){
      Select *p;
      
// ABS Label 2108
if(aCsrMap[pItem->iCursor] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2108);
}
// ABS Label 2109
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2109);
}

// COR Label 2110
if((!pItem->fg.isRecursive && aCsrMap[pItem->iCursor] == 0) != (!pItem->fg.isRecursive || aCsrMap[pItem->iCursor] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2110);
}

// ROR Label 2111
if((aCsrMap[pItem->iCursor] != 0) != (aCsrMap[pItem->iCursor] == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2111);
}

// MCC Label 2112
if(!pItem->fg.isRecursive && aCsrMap[pItem->iCursor] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2112);
}
// MCC Label 2113
if(!pItem->fg.isRecursive && !(aCsrMap[pItem->iCursor] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2113);
}
// MCC Label 2114
if(!(!pItem->fg.isRecursive) && aCsrMap[pItem->iCursor] == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2114);
}
// MCC Label 2115
if(!(!pItem->fg.isRecursive) && !(aCsrMap[pItem->iCursor] == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2115);
}
if( !pItem->fg.isRecursive || aCsrMap[pItem->iCursor]==0 ){
        aCsrMap[pItem->iCursor] = pParse->nTab++;
      }
      pItem->iCursor = aCsrMap[pItem->iCursor];
      p = pItem->pSelect;

// ABS Label 2116
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2116);
}
for(; p; p=p->pPrior){
        
// ABS Label 2118
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2118);
}

// ABS Label 2119
if(aCsrMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2119);
}

// ABS Label 2120
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2120);
}
srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);
      };
// ABS Label 2117
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2117);
}

    }
  };
// ABS Label 2100
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2100);
}
// ABS Label 2101
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2101);
}

// ROR Label 2102
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2102);
}
// ROR Label 2103
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2103);
}
// ROR Label 2104
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2104);
}

}

/*
** Expression walker callback used by renumberCursors() to update
** Expr objects to match newly assigned cursor numbers.
*/
static int renumberCursorsCb(Walker *pWalker, Expr *pExpr){
  
// ABS Label 2121
if(pWalker->u.aiCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2121);
}
int *aCsrMap = pWalker->u.aiCol;
  int op = pExpr->op;
  
// ABS Label 2122
if(aCsrMap[pExpr->iTable] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2122);
}
// ABS Label 2123
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2123);
}

// COR Label 2124
if(((op == 166 || op == 178) || aCsrMap[pExpr->iTable]) != ((op == 166 || op == 178) && aCsrMap[pExpr->iTable]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2124);
}

// MCC Label 2125
if(( op == 166 && op == 178 ) && aCsrMap[pExpr->iTable] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2125);
}
// MCC Label 2126
if(( op == 166 && op == 178 ) && !(aCsrMap[pExpr->iTable]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2126);
}
// MCC Label 2127
if(( op == 166 && !(op == 178) ) && aCsrMap[pExpr->iTable] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2127);
}
// MCC Label 2128
if(( op == 166 && !(op == 178) ) && !(aCsrMap[pExpr->iTable]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2128);
}
// MCC Label 2129
if(( !(op == 166) && op == 178 ) && aCsrMap[pExpr->iTable] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2129);
}
// MCC Label 2130
if(( !(op == 166) && op == 178 ) && !(aCsrMap[pExpr->iTable]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2130);
}
// MCC Label 2131
if(( !(op == 166) && !(op == 178) ) && aCsrMap[pExpr->iTable] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2131);
}
// MCC Label 2132
if(( !(op == 166) && !(op == 178) ) && !(aCsrMap[pExpr->iTable]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2132);
}
if( (op==TK_COLUMN || op==TK_IF_NULL_ROW) && aCsrMap[pExpr->iTable] ){
    pExpr->iTable = aCsrMap[pExpr->iTable];
  }
  
// ABS Label 2133
if(aCsrMap[pExpr->iRightJoinTable] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2133);
}
// ABS Label 2134
if(pExpr->iRightJoinTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2134);
}

// COR Label 2135
if(((((pExpr)->flags & (1)) != 0) || aCsrMap[pExpr->iRightJoinTable]) != ((((pExpr)->flags & (1)) != 0) && aCsrMap[pExpr->iRightJoinTable]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2135);
}

// MCC Label 2136
if(( ((pExpr)->flags & (1)) != 0 ) && aCsrMap[pExpr->iRightJoinTable] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2136);
}
// MCC Label 2137
if(( ((pExpr)->flags & (1)) != 0 ) && !(aCsrMap[pExpr->iRightJoinTable]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2137);
}
// MCC Label 2138
if(( !(((pExpr)->flags & (1)) != 0) ) && aCsrMap[pExpr->iRightJoinTable] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2138);
}
// MCC Label 2139
if(( !(((pExpr)->flags & (1)) != 0) ) && !(aCsrMap[pExpr->iRightJoinTable]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2139);
}
if( ExprHasProperty(pExpr, EP_FromJoin) && aCsrMap[pExpr->iRightJoinTable] ){
    pExpr->iRightJoinTable = aCsrMap[pExpr->iRightJoinTable];
  }
  return WRC_Continue;
}

/*
** Assign a new cursor number to each cursor in the FROM clause (Select.pSrc)
** of the SELECT statement passed as the second argument, and to each 
** cursor in the FROM clause of any FROM clause sub-selects, recursively.
** Except, do not assign a new cursor number to the iExcept'th element in
** the FROM clause of (*p). Update all expressions and other references 
** to refer to the new cursor numbers.
**
** Argument aCsrMap is an array that may be used for temporary working
** space. Two guarantees are made by the caller:
**
**   * the array is larger than the largest cursor number used within the
**     select statement passed as an argument, and
**
**   * the array entries for all cursor numbers that do *not* appear in 
**     FROM clauses of the select statement as described above are 
**     initialized to zero.
*/
static void renumberCursors(
  Parse *pParse,                  /* Parse context */
  Select *p,                      /* Select to renumber cursors within */
  int iExcept,                    /* FROM clause item to skip */
  int *aCsrMap                    /* Working space */
){
  Walker w;
  
// ABS Label 2140
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2140);
}

// ABS Label 2141
if(aCsrMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2141);
}

// ABS Label 2142
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2142);
}

// ABS Label 2143
if(iExcept < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2143);
}
srclistRenumberCursors(pParse, aCsrMap, p->pSrc, iExcept);
  memset(&w, 0, sizeof(w));
  w.u.aiCol = aCsrMap;
  w.xExprCallback = renumberCursorsCb;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  
// ABS Label 2144
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2144);
}
sqlite3WalkSelect(&w, p);
}
#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
/*
** This routine attempts to flatten subqueries as a performance optimization.
** This routine returns 1 if it makes changes and 0 if no flattening occurs.
**
** To understand the concept of flattening, consider the following
** query:
**
**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z<100) WHERE a>5
**
** The default way of implementing this query is to execute the
** subquery first and store the results in a temporary table, then
** run the outer query on that temporary table.  This requires two
** passes over the data.  Furthermore, because the temporary table
** has no indices, the WHERE clause on the outer query cannot be
** optimized.
**
** This routine attempts to rewrite queries such as the above into
** a single flat select, like this:
**
**     SELECT x+y AS a FROM t1 WHERE z<100 AND a>5
**
** The code generated for this simplification gives the same result
** but only has to scan the data once.  And because indices might 
** exist on the table t1, a complete scan of the data might be
** avoided.
**
** Flattening is subject to the following constraints:
**
**  (**)  We no longer attempt to flatten aggregate subqueries. Was:
**        The subquery and the outer query cannot both be aggregates.
**
**  (**)  We no longer attempt to flatten aggregate subqueries. Was:
**        (2) If the subquery is an aggregate then
**        (2a) the outer query must not be a join and
**        (2b) the outer query must not use subqueries
**             other than the one FROM-clause subquery that is a candidate
**             for flattening.  (This is due to ticket [2f7170d73bf9abf80]
**             from 2015-02-09.)
**
**   (3)  If the subquery is the right operand of a LEFT JOIN then
**        (3a) the subquery may not be a join and
**        (3b) the FROM clause of the subquery may not contain a virtual
**             table and
**        (3c) the outer query may not be an aggregate.
**        (3d) the outer query may not be DISTINCT.
**
**   (4)  The subquery can not be DISTINCT.
**
**  (**)  At one point restrictions (4) and (5) defined a subset of DISTINCT
**        sub-queries that were excluded from this optimization. Restriction 
**        (4) has since been expanded to exclude all DISTINCT subqueries.
**
**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:
**        If the subquery is aggregate, the outer query may not be DISTINCT.
**
**   (7)  The subquery must have a FROM clause.  TODO:  For subqueries without
**        A FROM clause, consider adding a FROM clause with the special
**        table sqlite_once that consists of a single row containing a
**        single NULL.
**
**   (8)  If the subquery uses LIMIT then the outer query may not be a join.
**
**   (9)  If the subquery uses LIMIT then the outer query may not be aggregate.
**
**  (**)  Restriction (10) was removed from the code on 2005-02-05 but we
**        accidently carried the comment forward until 2014-09-15.  Original
**        constraint: "If the subquery is aggregate then the outer query 
**        may not use LIMIT."
**
**  (11)  The subquery and the outer query may not both have ORDER BY clauses.
**
**  (**)  Not implemented.  Subsumed into restriction (3).  Was previously
**        a separate restriction deriving from ticket #350.
**
**  (13)  The subquery and outer query may not both use LIMIT.
**
**  (14)  The subquery may not use OFFSET.
**
**  (15)  If the outer query is part of a compound select, then the
**        subquery may not use LIMIT.
**        (See ticket #2339 and ticket [02a8e81d44]).
**
**  (16)  If the outer query is aggregate, then the subquery may not
**        use ORDER BY.  (Ticket #2942)  This used to not matter
**        until we introduced the group_concat() function.  
**
**  (17)  If the subquery is a compound select, then
**        (17a) all compound operators must be a UNION ALL, and
**        (17b) no terms within the subquery compound may be aggregate
**              or DISTINCT, and
**        (17c) every term within the subquery compound must have a FROM clause
**        (17d) the outer query may not be
**              (17d1) aggregate, or
**              (17d2) DISTINCT
**        (17e) the subquery may not contain window functions, and
**        (17f) the subquery must not be the RHS of a LEFT JOIN.
**
**        The parent and sub-query may contain WHERE clauses. Subject to
**        rules (11), (13) and (14), they may also contain ORDER BY,
**        LIMIT and OFFSET clauses.  The subquery cannot use any compound
**        operator other than UNION ALL because all the other compound
**        operators have an implied DISTINCT which is disallowed by
**        restriction (4).
**
**        Also, each component of the sub-query must return the same number
**        of result columns. This is actually a requirement for any compound
**        SELECT statement, but all the code here does is make sure that no
**        such (illegal) sub-query is flattened. The caller will detect the
**        syntax error and return a detailed message.
**
**  (18)  If the sub-query is a compound select, then all terms of the
**        ORDER BY clause of the parent must be copies of a term returned
**        by the parent query.
**
**  (19)  If the subquery uses LIMIT then the outer query may not
**        have a WHERE clause.
**
**  (20)  If the sub-query is a compound select, then it must not use
**        an ORDER BY clause.  Ticket #3773.  We could relax this constraint
**        somewhat by saying that the terms of the ORDER BY clause must
**        appear as unmodified result columns in the outer query.  But we
**        have other optimizations in mind to deal with that case.
**
**  (21)  If the subquery uses LIMIT then the outer query may not be
**        DISTINCT.  (See ticket [752e1646fc]).
**
**  (22)  The subquery may not be a recursive CTE.
**
**  (23)  If the outer query is a recursive CTE, then the sub-query may not be
**        a compound query.  This restriction is because transforming the
**        parent to a compound query confuses the code that handles
**        recursive queries in multiSelect().
**
**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:
**        The subquery may not be an aggregate that uses the built-in min() or 
**        or max() functions.  (Without this restriction, a query like:
**        "SELECT x FROM (SELECT max(y), x FROM t1)" would not necessarily
**        return the value X for which Y was maximal.)
**
**  (25)  If either the subquery or the parent query contains a window
**        function in the select list or ORDER BY clause, flattening
**        is not attempted.
**
**
** In this routine, the "p" parameter is a pointer to the outer query.
** The subquery is p->pSrc->a[iFrom].  isAgg is true if the outer query
** uses aggregates.
**
** If flattening is not attempted, this routine is a no-op and returns 0.
** If flattening is attempted this routine returns 1.
**
** All of the expression analysis must occur on both the outer query and
** the subquery before this routine runs.
*/
static int flattenSubquery(
  Parse *pParse,       /* Parsing context */
  Select *p,           /* The parent or outer SELECT statement */
  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */
  int isAgg            /* True if outer SELECT uses aggregate functions */
){
  
// ABS Label 2145
if(pParse->zAuthContext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2145);
}
const char *zSavedAuthContext = pParse->zAuthContext;
  Select *pParent;    /* Current UNION ALL term of the other query */
  Select *pSub;       /* The inner query or "subquery" */
  Select *pSub1;      /* Pointer to the rightmost select in sub-query */
  SrcList *pSrc;      /* The FROM clause of the outer query */
  SrcList *pSubSrc;   /* The FROM clause of the subquery */
  int iParent;        /* VDBE cursor number of the pSub result set temp table */
  int iNewParent = -1;/* Replacement table for iParent */
  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    
  int i;              /* Loop counter */
  Expr *pWhere;                    /* The WHERE clause */
  SrcItem *pSubitem;               /* The subquery */
  
// ABS Label 2146
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2146);
}
sqlite3 *db = pParse->db;
  Walker w;                        /* Walker to persist agginfo data */
  int *aCsrMap = 0;

  /* Check to see if flattening is permitted.  Return 0 if not.
  */
  assert( p!=0 );
  assert( p->pPrior==0 );
  
// MCC Label 2156
if(( ((db)->dbOptFlags & (1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2156);
}
// MCC Label 2157
if(( !(((db)->dbOptFlags & (1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2157);
}
if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) { return 0;
}
  pSrc = p->pSrc;
  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );
  pSubitem = &pSrc->a[iFrom];
  iParent = pSubitem->iCursor;
  pSub = pSubitem->pSelect;
  assert( pSub!=0 );

#ifndef SQLITE_OMIT_WINDOWFUNC
  
// ABS Label 2158
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2158);
}
// ABS Label 2159
if(pSub->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2159);
}

// COR Label 2160
if((p->pWin && pSub->pWin) != (p->pWin || pSub->pWin))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2160);
}

// MCC Label 2161
if(p->pWin && pSub->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2161);
}
// MCC Label 2162
if(p->pWin && !(pSub->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2162);
}
// MCC Label 2163
if(!(p->pWin) && pSub->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2163);
}
// MCC Label 2164
if(!(p->pWin) && !(pSub->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2164);
}
if( p->pWin || pSub->pWin ) { return 0;                  /* Restriction (25) */
}
#endif

  pSubSrc = pSub->pSrc;
  assert( pSubSrc );
  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,
  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET
  ** because they could be computed at compile-time.  But when LIMIT and OFFSET
  ** became arbitrary expressions, we were forced to add restrictions (13)
  ** and (14). */
  
// ABS Label 2165
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2165);
}
// ABS Label 2166
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2166);
}

// COR Label 2167
if((pSub->pLimit || p->pLimit) != (pSub->pLimit && p->pLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2167);
}

// MCC Label 2168
if(pSub->pLimit && p->pLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2168);
}
// MCC Label 2169
if(pSub->pLimit && !(p->pLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2169);
}
// MCC Label 2170
if(!(pSub->pLimit) && p->pLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2170);
}
// MCC Label 2171
if(!(pSub->pLimit) && !(p->pLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2171);
}
if( pSub->pLimit && p->pLimit ) { return 0;              /* Restriction (13) */
}
  
// ABS Label 2172
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2172);
}
// ABS Label 2173
if(pSub->pLimit->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2173);
}

// COR Label 2174
if((pSub->pLimit || pSub->pLimit->pRight) != (pSub->pLimit && pSub->pLimit->pRight))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2174);
}

// MCC Label 2175
if(pSub->pLimit && pSub->pLimit->pRight ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2175);
}
// MCC Label 2176
if(pSub->pLimit && !(pSub->pLimit->pRight) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2176);
}
// MCC Label 2177
if(!(pSub->pLimit) && pSub->pLimit->pRight ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2177);
}
// MCC Label 2178
if(!(pSub->pLimit) && !(pSub->pLimit->pRight) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2178);
}
if( pSub->pLimit && pSub->pLimit->pRight ) { return 0;   /* Restriction (14) */
}
  
// ABS Label 2179
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2179);
}

// COR Label 2180
if(((p->selFlags & 256) != 0 || pSub->pLimit) != ((p->selFlags & 256) != 0 && pSub->pLimit))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2180);
}

// ROR Label 2181
if(((p->selFlags & 256) == 0) != ((p->selFlags & 256) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2181);
}

// MCC Label 2182
if((p->selFlags & 256) != 0 && pSub->pLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2182);
}
// MCC Label 2183
if((p->selFlags & 256) != 0 && !(pSub->pLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2183);
}
// MCC Label 2184
if(!((p->selFlags & 256) != 0) && pSub->pLimit ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2184);
}
// MCC Label 2185
if(!((p->selFlags & 256) != 0) && !(pSub->pLimit) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2185);
}
if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){
    return 0;                                            /* Restriction (15) */
  }
  
// ABS Label 2186
if(pSubSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2186);
}

// ROR Label 2187
if((pSubSrc->nSrc != 0) != (pSubSrc->nSrc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2187);
}
if( pSubSrc->nSrc==0 ) { return 0;                       /* Restriction (7)  */
}
  
// ABS Label 2188
if(pSub->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2188);
}

// AOR Label 2189
if(pSub->selFlags | 1 != pSub->selFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2189);
}
// AOR Label 2190
if(pSub->selFlags ^ 1 != pSub->selFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2190);
}
if( pSub->selFlags & SF_Distinct ) { return 0;           /* Restriction (4)  */
}
  
// ABS Label 2191
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2191);
}

// COR Label 2192
if((pSub->pLimit || (pSrc->nSrc > 1 || isAgg)) != (pSub->pLimit && (pSrc->nSrc > 1 || isAgg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2192);
}

// MCC Label 2193
if(pSub->pLimit && ( pSrc->nSrc > 1 && isAgg ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2193);
}
// MCC Label 2194
if(pSub->pLimit && ( pSrc->nSrc > 1 && !(isAgg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2194);
}
// MCC Label 2195
if(pSub->pLimit && ( !(pSrc->nSrc > 1) && isAgg ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2195);
}
// MCC Label 2196
if(pSub->pLimit && ( !(pSrc->nSrc > 1) && !(isAgg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2196);
}
// MCC Label 2197
if(!(pSub->pLimit) && ( pSrc->nSrc > 1 && isAgg ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2197);
}
// MCC Label 2198
if(!(pSub->pLimit) && ( pSrc->nSrc > 1 && !(isAgg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2198);
}
// MCC Label 2199
if(!(pSub->pLimit) && ( !(pSrc->nSrc > 1) && isAgg ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2199);
}
// MCC Label 2200
if(!(pSub->pLimit) && ( !(pSrc->nSrc > 1) && !(isAgg) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2200);
}
if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
     return 0;         /* Restrictions (8)(9) */
  }
  
// ABS Label 2201
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2201);
}
// ABS Label 2202
if(pSub->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2202);
}

// COR Label 2203
if((p->pOrderBy || pSub->pOrderBy) != (p->pOrderBy && pSub->pOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2203);
}

// MCC Label 2204
if(p->pOrderBy && pSub->pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2204);
}
// MCC Label 2205
if(p->pOrderBy && !(pSub->pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2205);
}
// MCC Label 2206
if(!(p->pOrderBy) && pSub->pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2206);
}
// MCC Label 2207
if(!(p->pOrderBy) && !(pSub->pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2207);
}
if( p->pOrderBy && pSub->pOrderBy ){
     return 0;                                           /* Restriction (11) */
  }
  
// ABS Label 2208
if(isAgg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2208);
}
// ABS Label 2209
if(pSub->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2209);
}

// COR Label 2210
if((isAgg || pSub->pOrderBy) != (isAgg && pSub->pOrderBy))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2210);
}

// MCC Label 2211
if(isAgg && pSub->pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2211);
}
// MCC Label 2212
if(isAgg && !(pSub->pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2212);
}
// MCC Label 2213
if(!(isAgg) && pSub->pOrderBy ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2213);
}
// MCC Label 2214
if(!(isAgg) && !(pSub->pOrderBy) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2214);
}
if( isAgg && pSub->pOrderBy ) { return 0;                /* Restriction (16) */
}
  
// ABS Label 2215
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2215);
}
// ABS Label 2216
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2216);
}

// COR Label 2217
if((pSub->pLimit || p->pWhere) != (pSub->pLimit && p->pWhere))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2217);
}

// MCC Label 2218
if(pSub->pLimit && p->pWhere ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2218);
}
// MCC Label 2219
if(pSub->pLimit && !(p->pWhere) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2219);
}
// MCC Label 2220
if(!(pSub->pLimit) && p->pWhere ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2220);
}
// MCC Label 2221
if(!(pSub->pLimit) && !(p->pWhere) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2221);
}
if( pSub->pLimit && p->pWhere ) { return 0;              /* Restriction (19) */
}
  
// ABS Label 2222
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2222);
}

// COR Label 2223
if((pSub->pLimit || (p->selFlags & 1) != 0) != (pSub->pLimit && (p->selFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2223);
}

// ROR Label 2224
if(((p->selFlags & 1) == 0) != ((p->selFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2224);
}

// MCC Label 2225
if(pSub->pLimit && (p->selFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2225);
}
// MCC Label 2226
if(pSub->pLimit && !((p->selFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2226);
}
// MCC Label 2227
if(!(pSub->pLimit) && (p->selFlags & 1) != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2227);
}
// MCC Label 2228
if(!(pSub->pLimit) && !((p->selFlags & 1) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2228);
}
if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){
     return 0;         /* Restriction (21) */
  }
  
// ABS Label 2229
if(pSub->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2229);
}

// AOR Label 2230
if(pSub->selFlags | (8192) != pSub->selFlags & (8192))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2230);
}
// AOR Label 2231
if(pSub->selFlags ^ (8192) != pSub->selFlags & (8192))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2231);
}
if( pSub->selFlags & (SF_Recursive) ){
    return 0; /* Restrictions (22) */
  }

  /*
  ** If the subquery is the right operand of a LEFT JOIN, then the
  ** subquery may not be a join itself (3a). Example of why this is not
  ** allowed:
  **
  **         t1 LEFT OUTER JOIN (t2 JOIN t3)
  **
  ** If we flatten the above, we would get
  **
  **         (t1 LEFT OUTER JOIN t2) JOIN t3
  **
  ** which is not at all the same thing.
  **
  ** If the subquery is the right operand of a LEFT JOIN, then the outer
  ** query cannot be an aggregate. (3c)  This is an artifact of the way
  ** aggregates are processed - there is no mechanism to determine if
  ** the LEFT JOIN table should be all-NULL.
  **
  ** See also tickets #306, #350, and #3300.
  */
  
// ROR Label 2232
if(((pSubitem->fg.jointype & 32) == 0) != ((pSubitem->fg.jointype & 32) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2232);
}
if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
    isLeftJoin = 1;
    
// ABS Label 2233
if(((pSubSrc->a[0].pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2233);
}
// ABS Label 2234
if(isAgg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2234);
}
// ABS Label 2235
if(pSubSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2235);
}

// COR Label 2236
if((pSubSrc->nSrc > 1 || isAgg && ((pSubSrc->a[0].pTab)->nModuleArg)) != (pSubSrc->nSrc > 1 || isAgg || ((pSubSrc->a[0].pTab)->nModuleArg)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2236);
}
// COR Label 2237
if((pSubSrc->nSrc > 1 && isAgg) != (pSubSrc->nSrc > 1 || isAgg))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2237);
}

// ROR Label 2238
if((pSubSrc->nSrc <= 1) != (pSubSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2238);
}
// ROR Label 2239
if((pSubSrc->nSrc < 1) != (pSubSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2239);
}
// ROR Label 2240
if((pSubSrc->nSrc >= 1) != (pSubSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2240);
}

// MCC Label 2241
if(pSubSrc->nSrc > 1 && isAgg && ((pSubSrc->a[0].pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2241);
}
// MCC Label 2242
if(pSubSrc->nSrc > 1 && isAgg && !(((pSubSrc->a[0].pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2242);
}
// MCC Label 2243
if(pSubSrc->nSrc > 1 && !(isAgg) && ((pSubSrc->a[0].pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2243);
}
// MCC Label 2244
if(pSubSrc->nSrc > 1 && !(isAgg) && !(((pSubSrc->a[0].pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2244);
}
// MCC Label 2245
if(!(pSubSrc->nSrc > 1) && isAgg && ((pSubSrc->a[0].pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2245);
}
// MCC Label 2246
if(!(pSubSrc->nSrc > 1) && isAgg && !(((pSubSrc->a[0].pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2246);
}
// MCC Label 2247
if(!(pSubSrc->nSrc > 1) && !(isAgg) && ((pSubSrc->a[0].pTab)->nModuleArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2247);
}
// MCC Label 2248
if(!(pSubSrc->nSrc > 1) && !(isAgg) && !(((pSubSrc->a[0].pTab)->nModuleArg)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2248);
}
if( pSubSrc->nSrc>1                   /* (3a) */
     || isAgg                             /* (3b) */
     || IsVirtual(pSubSrc->a[0].pTab)     /* (3c) */
#ifdef MAGMA_ENABLE_FIXES
     || (p->selFlags & SF_Distinct)!=0    /* (3d) */
#endif
    ){
      return 0;
    }
#ifdef MAGMA_ENABLE_CANARIES
    MAGMA_LOG("SQL003", (p->selFlags & SF_Distinct)!=0);
#endif
  }
#ifdef SQLITE_EXTRA_IFNULLROW
  else if( iFrom>0 && !isAgg ){
    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for
    ** every reference to any result column from subquery in a join, even
    ** though they are not necessary.  This will stress-test the OP_IfNullRow 
    ** opcode. */
    isLeftJoin = -1;
  }
#endif

  /* Restriction (17): If the sub-query is a compound SELECT, then it must
  ** use only the UNION ALL operator. And none of the simple select queries
  ** that make up the compound SELECT are allowed to be aggregate or distinct
  ** queries.
  */
  
// ABS Label 2249
if(pSub->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2249);
}
if( pSub->pPrior ){
    
// ABS Label 2250
if(pSub->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2250);
}
if( pSub->pOrderBy ){
      return 0;  /* Restriction (20) */
    }
    
// ABS Label 2251
if(isAgg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2251);
}
// ABS Label 2252
if(isLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2252);
}

// COR Label 2253
if((isAgg || (p->selFlags & 1) != 0 && isLeftJoin > 0) != (isAgg || (p->selFlags & 1) != 0 || isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2253);
}
// COR Label 2254
if((isAgg && (p->selFlags & 1) != 0) != (isAgg || (p->selFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2254);
}

// ROR Label 2255
if(((p->selFlags & 1) == 0) != ((p->selFlags & 1) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2255);
}
// ROR Label 2256
if((isLeftJoin <= 0) != (isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2256);
}
// ROR Label 2257
if((isLeftJoin < 0) != (isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2257);
}
// ROR Label 2258
if((isLeftJoin >= 0) != (isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2258);
}

// MCC Label 2259
if(isAgg && (p->selFlags & 1) != 0 && isLeftJoin > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2259);
}
// MCC Label 2260
if(isAgg && (p->selFlags & 1) != 0 && !(isLeftJoin > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2260);
}
// MCC Label 2261
if(isAgg && !((p->selFlags & 1) != 0) && isLeftJoin > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2261);
}
// MCC Label 2262
if(isAgg && !((p->selFlags & 1) != 0) && !(isLeftJoin > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2262);
}
// MCC Label 2263
if(!(isAgg) && (p->selFlags & 1) != 0 && isLeftJoin > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2263);
}
// MCC Label 2264
if(!(isAgg) && (p->selFlags & 1) != 0 && !(isLeftJoin > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2264);
}
// MCC Label 2265
if(!(isAgg) && !((p->selFlags & 1) != 0) && isLeftJoin > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2265);
}
// MCC Label 2266
if(!(isAgg) && !((p->selFlags & 1) != 0) && !(isLeftJoin > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2266);
}
if( isAgg || (p->selFlags & SF_Distinct)!=0 || isLeftJoin>0 ){
      return 0; /* (17d1), (17d2), or (17f) */
    }
    pSub1 = pSub;

// ABS Label 2267
if(pSub1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2267);
}
for(; pSub1; pSub1=pSub1->pPrior){
      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );
      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );
      assert( pSub->pSrc!=0 );
      assert( (pSub->selFlags & SF_Recursive)==0 );
      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );
      
// ABS Label 2269
if(pSub1->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2269);
}
// ABS Label 2270
if(pSub1->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2270);
}

// COR Label 2271
if(((pSub1->selFlags & (1 | 8)) != 0 || (pSub1->pPrior && pSub1->op != 134) || pSub1->pSrc->nSrc < 1 && pSub1->pWin) != ((pSub1->selFlags & (1 | 8)) != 0 || (pSub1->pPrior && pSub1->op != 134) || pSub1->pSrc->nSrc < 1 || pSub1->pWin))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2271);
}
// COR Label 2272
if(((pSub1->selFlags & (1 | 8)) != 0 || (pSub1->pPrior && pSub1->op != 134) && pSub1->pSrc->nSrc < 1) != ((pSub1->selFlags & (1 | 8)) != 0 || (pSub1->pPrior && pSub1->op != 134) || pSub1->pSrc->nSrc < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2272);
}
// COR Label 2273
if(((pSub1->selFlags & (1 | 8)) != 0 && (pSub1->pPrior && pSub1->op != 134)) != ((pSub1->selFlags & (1 | 8)) != 0 || (pSub1->pPrior && pSub1->op != 134)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2273);
}

// ROR Label 2274
if(((pSub1->selFlags & (1 | 8)) == 0) != ((pSub1->selFlags & (1 | 8)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2274);
}
// ROR Label 2275
if((pSub1->pSrc->nSrc <= 1) != (pSub1->pSrc->nSrc < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2275);
}
// ROR Label 2276
if((pSub1->pSrc->nSrc > 1) != (pSub1->pSrc->nSrc < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2276);
}
// ROR Label 2277
if((pSub1->pSrc->nSrc >= 1) != (pSub1->pSrc->nSrc < 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2277);
}

// MCC Label 2278
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2278);
}
// MCC Label 2279
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2279);
}
// MCC Label 2280
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2280);
}
// MCC Label 2281
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2281);
}
// MCC Label 2282
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2282);
}
// MCC Label 2283
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2283);
}
// MCC Label 2284
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2284);
}
// MCC Label 2285
if((pSub1->selFlags & (1 | 8)) != 0 && ( pSub1->pPrior && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2285);
}
// MCC Label 2286
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2286);
}
// MCC Label 2287
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2287);
}
// MCC Label 2288
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2288);
}
// MCC Label 2289
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2289);
}
// MCC Label 2290
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2290);
}
// MCC Label 2291
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2291);
}
// MCC Label 2292
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2292);
}
// MCC Label 2293
if((pSub1->selFlags & (1 | 8)) != 0 && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2293);
}
// MCC Label 2294
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2294);
}
// MCC Label 2295
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2295);
}
// MCC Label 2296
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2296);
}
// MCC Label 2297
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2297);
}
// MCC Label 2298
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2298);
}
// MCC Label 2299
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2299);
}
// MCC Label 2300
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2300);
}
// MCC Label 2301
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( pSub1->pPrior && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2301);
}
// MCC Label 2302
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2302);
}
// MCC Label 2303
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && pSub1->op != 134 ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2303);
}
// MCC Label 2304
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2304);
}
// MCC Label 2305
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && pSub1->op != 134 ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2305);
}
// MCC Label 2306
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2306);
}
// MCC Label 2307
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && pSub1->pSrc->nSrc < 1 && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2307);
}
// MCC Label 2308
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && pSub1->pWin ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2308);
}
// MCC Label 2309
if(!((pSub1->selFlags & (1 | 8)) != 0) && ( !(pSub1->pPrior) && !(pSub1->op != 134) ) && !(pSub1->pSrc->nSrc < 1) && !(pSub1->pWin) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2309);
}
if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */
       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */
       || pSub1->pSrc->nSrc<1                                  /* (17c) */
#ifndef SQLITE_OMIT_WINDOWFUNC
       || pSub1->pWin                                          /* (17e) */
#endif
      ){
        return 0;
      }
      testcase( pSub1->pSrc->nSrc>1 );
    };
// ABS Label 2268
if(pSub1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2268);
}


    /* Restriction (18). */
    
// ABS Label 2310
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2310);
}
if( p->pOrderBy ){
      int ii;
      ii = 0;

// ABS Label 2311
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2311);
}
// ABS Label 2312
if(p->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2312);
}

// ROR Label 2313
if((ii <= p->pOrderBy->nExpr) != (ii < p->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2313);
}
// ROR Label 2314
if((ii > p->pOrderBy->nExpr) != (ii < p->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2314);
}
// ROR Label 2315
if((ii >= p->pOrderBy->nExpr) != (ii < p->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2315);
}
for(; ii<p->pOrderBy->nExpr; ii++){
        
// ROR Label 2321
if((p->pOrderBy->a[ii].u.x.iOrderByCol != 0) != (p->pOrderBy->a[ii].u.x.iOrderByCol == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2321);
}
if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) { return 0;
}
      };
// ABS Label 2316
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2316);
}
// ABS Label 2317
if(p->pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2317);
}

// ROR Label 2318
if((ii <= p->pOrderBy->nExpr) != (ii < p->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2318);
}
// ROR Label 2319
if((ii > p->pOrderBy->nExpr) != (ii < p->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2319);
}
// ROR Label 2320
if((ii >= p->pOrderBy->nExpr) != (ii < p->pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2320);
}

    }

    /* Restriction (23) */
    
// MCC Label 2322
if(( p->selFlags & 8192 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2322);
}
// MCC Label 2323
if(( !(p->selFlags & 8192) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2323);
}
if( (p->selFlags & SF_Recursive) ) { return 0;
}

    
// ABS Label 2324
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2324);
}

// ROR Label 2325
if((pSrc->nSrc <= 1) != (pSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2325);
}
// ROR Label 2326
if((pSrc->nSrc < 1) != (pSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2326);
}
// ROR Label 2327
if((pSrc->nSrc >= 1) != (pSrc->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2327);
}
if( pSrc->nSrc>1 ){
      
// ABS Label 2328
if(pParse->nSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2328);
}

// ROR Label 2329
if((pParse->nSelect <= 500) != (pParse->nSelect > 500))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2329);
}
// ROR Label 2330
if((pParse->nSelect < 500) != (pParse->nSelect > 500))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2330);
}
// ROR Label 2331
if((pParse->nSelect >= 500) != (pParse->nSelect > 500))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2331);
}
if( pParse->nSelect>500 ) { return 0;
}
      aCsrMap = sqlite3DbMallocZero(db, pParse->nTab*sizeof(int));
    }
  }

  /***** If we reach this point, flattening is permitted. *****/
  SELECTTRACE(1,pParse,p,("flatten %u.%p from term %d\n",
                   pSub->selId, pSub, iFrom));

  /* Authorize the subquery */
  pParse->zAuthContext = pSubitem->zName;
  TESTONLY(i =) 
// ABS Label 2147
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2147);
}
sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);
  testcase( i==SQLITE_DENY );
  pParse->zAuthContext = zSavedAuthContext;

  /* Delete the transient structures associated with thesubquery */
  pSub1 = pSubitem->pSelect;
  
// ABS Label 2148
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2148);
}
sqlite3DbFree(db, pSubitem->zDatabase);
  
// ABS Label 2149
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2149);
}
sqlite3DbFree(db, pSubitem->zName);
  
// ABS Label 2150
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2150);
}
sqlite3DbFree(db, pSubitem->zAlias);
  pSubitem->zDatabase = 0;
  pSubitem->zName = 0;
  pSubitem->zAlias = 0;
  pSubitem->pSelect = 0;
  assert( pSubitem->pOn==0 );

  /* If the sub-query is a compound SELECT statement, then (by restrictions
  ** 17 and 18 above) it must be a UNION ALL and the parent query must 
  ** be of the form:
  **
  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> 
  **
  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block
  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or 
  ** OFFSET clauses and joins them to the left-hand-side of the original
  ** using UNION ALL operators. In this case N is the number of simple
  ** select statements in the compound sub-query.
  **
  ** Example:
  **
  **     SELECT a+1 FROM (
  **        SELECT x FROM tab
  **        UNION ALL
  **        SELECT y FROM tab
  **        UNION ALL
  **        SELECT abs(z*2) FROM tab2
  **     ) WHERE a!=5 ORDER BY 1
  **
  ** Transformed into:
  **
  **     SELECT x+1 FROM tab WHERE x+1!=5
  **     UNION ALL
  **     SELECT y+1 FROM tab WHERE y+1!=5
  **     UNION ALL
  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5
  **     ORDER BY 1
  **
  ** We call this the "compound-subquery flattening".
  */
  pSub = pSub->pPrior;

// ABS Label 2332
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2332);
}
for(; pSub; pSub=pSub->pPrior){
    Select *pNew;
    
// ABS Label 2334
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2334);
}
ExprList *pOrderBy = p->pOrderBy;
    
// ABS Label 2335
if(p->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2335);
}
Expr *pLimit = p->pLimit;
    
// ABS Label 2336
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2336);
}
Select *pPrior = p->pPrior;
    
// ABS Label 2337
if(pSubitem->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2337);
}
Table *pItemTab = pSubitem->pTab;
    pSubitem->pTab = 0;
    p->pOrderBy = 0;
    p->pPrior = 0;
    p->pLimit = 0;
    pNew = sqlite3SelectDup(db, p, 0);
    p->pLimit = pLimit;
    p->pOrderBy = pOrderBy;
    p->op = TK_ALL;
    pSubitem->pTab = pItemTab;
    
// ABS Label 2338
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2338);
}

// ROR Label 2339
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2339);
}
if( pNew==0 ){
      p->pPrior = pPrior;
    }else{
      pNew->selId = ++pParse->nSelect;
      
// ABS Label 2340
if(aCsrMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2340);
}

// COR Label 2341
if((aCsrMap || (db->mallocFailed == 0)) != (aCsrMap && (db->mallocFailed == 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2341);
}

// MCC Label 2342
if(aCsrMap && ( db->mallocFailed == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2342);
}
// MCC Label 2343
if(aCsrMap && ( !(db->mallocFailed == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2343);
}
// MCC Label 2344
if(!(aCsrMap) && ( db->mallocFailed == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2344);
}
// MCC Label 2345
if(!(aCsrMap) && ( !(db->mallocFailed == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2345);
}
if( aCsrMap && ALWAYS(db->mallocFailed==0) ){
        
// ABS Label 2346
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2346);
}

// ABS Label 2347
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2347);
}

// ABS Label 2348
if(iFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2348);
}

// ABS Label 2349
if(aCsrMap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2349);
}
renumberCursors(pParse, pNew, iFrom, aCsrMap);
      }
      pNew->pPrior = pPrior;
      
// ABS Label 2350
if(pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2350);
}
if( pPrior ) { pPrior->pNext = pNew;
}
      pNew->pNext = p;
      p->pPrior = pNew;
      SELECTTRACE(2,pParse,p,("compound-subquery flattener"
                              " creates %u as peer\n",pNew->selId));
    }
    assert( pSubitem->pSelect==0 );
  };
// ABS Label 2333
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2333);
}

  
// ABS Label 2151
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2151);
}
sqlite3DbFree(db, aCsrMap);
  
// ABS Label 2351
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2351);
}
if( db->mallocFailed ){
    pSubitem->pSelect = pSub1;
    return 1;
  }

  /* Defer deleting the Table object associated with the
  ** subquery until code generation is
  ** complete, since there may still exist Expr.pTab entries that
  ** refer to the subquery even after flattening.  Ticket #3346.
  **
  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.
  */
  
// MCC Label 2352
if(( pSubitem->pTab != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2352);
}
// MCC Label 2353
if(( !(pSubitem->pTab != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2353);
}
if( ALWAYS(pSubitem->pTab!=0) ){
    
// ABS Label 2354
if(pSubitem->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2354);
}
Table *pTabToDel = pSubitem->pTab;
    
// ABS Label 2355
if(pTabToDel->nTabRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2355);
}

// ROR Label 2356
if((pTabToDel->nTabRef != 1) != (pTabToDel->nTabRef == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2356);
}
if( pTabToDel->nTabRef==1 ){
      Parse *pToplevel = sqlite3ParseToplevel(pParse);
      
// ABS Label 2357
if(pToplevel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2357);
}
sqlite3ParserAddCleanup(pToplevel, 
         (void(*)(sqlite3*,void*))sqlite3DeleteTable,
         pTabToDel);
      testcase( pToplevel->earlyCleanup );
    }else{
      pTabToDel->nTabRef--;
    }
    pSubitem->pTab = 0;
  }

  /* The following loop runs once for each term in a compound-subquery
  ** flattening (as described above).  If we are doing a different kind
  ** of flattening - a flattening other than a compound-subquery flattening -
  ** then this loop only runs once.
  **
  ** This loop moves all of the FROM elements of the subquery into the
  ** the FROM clause of the outer query.  Before doing this, remember
  ** the cursor number for the original outer query FROM element in
  ** iParent.  The iParent cursor will never be used.  Subsequent code
  ** will scan expressions looking for iParent references and replace
  ** those references with expressions that resolve to the subquery FROM
  ** elements we are now copying in.
  */
  pSub = pSub1;
  pParent = p;

// ABS Label 2358
if(pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2358);
}
for(; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
    int nSubSrc;
    u8 jointype = 0;
    assert( pSub!=0 );
    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */
    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */
    pSrc = pParent->pSrc;     /* FROM clause of the outer query */

    
// ABS Label 2360
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2360);
}
// ABS Label 2361
if(pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2361);
}

// ROR Label 2362
if((pParent != p) != (pParent == p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2362);
}
if( pParent==p ){
      jointype = pSubitem->fg.jointype;     /* First time through the loop */
    }
    
    /* The subquery uses a single slot of the FROM clause of the outer
    ** query.  If the subquery has more than one element in its FROM clause,
    ** then expand the outer query to make space for it to hold all elements
    ** of the subquery.
    **
    ** Example:
    **
    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;
    **
    ** The outer query has 3 slots in its FROM clause.  One slot of the
    ** outer query (the middle slot) is used by the subquery.  The next
    ** block of code will expand the outer query FROM clause to 4 slots.
    ** The middle slot is expanded to two slots in order to make space
    ** for the two elements in the FROM clause of the subquery.
    */
    
// ABS Label 2363
if(nSubSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2363);
}

// ROR Label 2364
if((nSubSrc <= 1) != (nSubSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2364);
}
// ROR Label 2365
if((nSubSrc < 1) != (nSubSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2365);
}
// ROR Label 2366
if((nSubSrc >= 1) != (nSubSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2366);
}
if( nSubSrc>1 ){
      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);
      
// ABS Label 2367
if(pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2367);
}

// ROR Label 2368
if((pSrc != 0) != (pSrc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2368);
}
if( pSrc==0 ) { break;
}
      pParent->pSrc = pSrc;
    }

    /* Transfer the FROM clause terms from the subquery into the
    ** outer query.
    */
    i = 0;

// ABS Label 2369
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2369);
}
// ABS Label 2370
if(nSubSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2370);
}

// ROR Label 2371
if((i <= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2371);
}
// ROR Label 2372
if((i > nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2372);
}
// ROR Label 2373
if((i >= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2373);
}
for(; i<nSubSrc; i++){
      
// ABS Label 2379
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2379);
}

// ABS Label 2380
if(pSrc->a[i + iFrom].pUsing < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2380);
}
sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);
      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );
      pSrc->a[i+iFrom] = pSubSrc->a[i];
      iNewParent = pSubSrc->a[i].iCursor;
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
    };
// ABS Label 2374
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2374);
}
// ABS Label 2375
if(nSubSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2375);
}

// ROR Label 2376
if((i <= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2376);
}
// ROR Label 2377
if((i > nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2377);
}
// ROR Label 2378
if((i >= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2378);
}

    pSrc->a[iFrom].fg.jointype = jointype;
  
    /* Now begin substituting subquery result set expressions for 
    ** references to the iParent in the outer query.
    ** 
    ** Example:
    **
    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;
    **   \                     \_____________ subquery __________/          /
    **    \_____________________ outer query ______________________________/
    **
    ** We look at every expression in the outer query and every place we see
    ** "a" we substitute "x*3" and every place we see "b" we substitute "y+10".
    */
    
// ABS Label 2381
if(pSub->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2381);
}

// COR Label 2382
if((pSub->pOrderBy || (pParent->selFlags & 4194304) == 0) != (pSub->pOrderBy && (pParent->selFlags & 4194304) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2382);
}

// ROR Label 2383
if(((pParent->selFlags & 4194304) != 0) != ((pParent->selFlags & 4194304) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2383);
}

// MCC Label 2384
if(pSub->pOrderBy && (pParent->selFlags & 4194304) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2384);
}
// MCC Label 2385
if(pSub->pOrderBy && !((pParent->selFlags & 4194304) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2385);
}
// MCC Label 2386
if(!(pSub->pOrderBy) && (pParent->selFlags & 4194304) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2386);
}
// MCC Label 2387
if(!(pSub->pOrderBy) && !((pParent->selFlags & 4194304) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2387);
}
if( pSub->pOrderBy && (pParent->selFlags & SF_NoopOrderBy)==0 ){
      /* At this point, any non-zero iOrderByCol values indicate that the
      ** ORDER BY column expression is identical to the iOrderByCol'th
      ** expression returned by SELECT statement pSub. Since these values
      ** do not necessarily correspond to columns in SELECT statement pParent,
      ** zero them before transfering the ORDER BY clause.
      **
      ** Not doing this may cause an error if a subsequent call to this
      ** function attempts to flatten a compound sub-query into pParent
      ** (the only way this can happen is if the compound sub-query is
      ** currently part of pSub->pSrc). See ticket [d11a6e908f].  */
      
// ABS Label 2388
if(pSub->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2388);
}
ExprList *pOrderBy = pSub->pOrderBy;
      i = 0;

// ABS Label 2389
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2389);
}
// ABS Label 2390
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2390);
}

// ROR Label 2391
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2391);
}
// ROR Label 2392
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2392);
}
// ROR Label 2393
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2393);
}
for(; i<pOrderBy->nExpr; i++){
        pOrderBy->a[i].u.x.iOrderByCol = 0;
      };
// ABS Label 2394
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2394);
}
// ABS Label 2395
if(pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2395);
}

// ROR Label 2396
if((i <= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2396);
}
// ROR Label 2397
if((i > pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2397);
}
// ROR Label 2398
if((i >= pOrderBy->nExpr) != (i < pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2398);
}

      assert( pParent->pOrderBy==0 );
      pParent->pOrderBy = pOrderBy;
      pSub->pOrderBy = 0;
    }
    pWhere = pSub->pWhere;
    pSub->pWhere = 0;
    
// ABS Label 2399
if(isLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2399);
}

// ROR Label 2400
if((isLeftJoin <= 0) != (isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2400);
}
// ROR Label 2401
if((isLeftJoin < 0) != (isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2401);
}
// ROR Label 2402
if((isLeftJoin >= 0) != (isLeftJoin > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2402);
}
if( isLeftJoin>0 ){
      
// ABS Label 2403
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2403);
}

// ABS Label 2404
if(iNewParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2404);
}
sqlite3SetJoinExpr(pWhere, iNewParent);
    }
    
// ABS Label 2405
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2405);
}
if( pWhere ){
      
// ABS Label 2406
if(pParent->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2406);
}
if( pParent->pWhere ){
        pParent->pWhere = sqlite3PExpr(pParse, TK_AND, pWhere, pParent->pWhere);
      }else{
        pParent->pWhere = pWhere;
      }
    }
    
// ROR Label 2407
if((db->mallocFailed != 0) != (db->mallocFailed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2407);
}
if( db->mallocFailed==0 ){
      SubstContext x;
      x.pParse = pParse;
      x.iTable = iParent;
      x.iNewTable = iNewParent;
      x.isLeftJoin = isLeftJoin;
      x.pEList = pSub->pEList;
      
// ABS Label 2408
if(pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2408);
}
substSelect(&x, pParent, 0);
    }
  
    /* The flattened query is a compound if either the inner or the
    ** outer query is a compound. */
    pParent->selFlags |= pSub->selFlags & SF_Compound;
    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */
  
    /*
    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;
    **
    ** One is tempted to try to add a and b to combine the limits.  But this
    ** does not work if either limit is negative.
    */
    
// ABS Label 2409
if(pSub->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2409);
}
if( pSub->pLimit ){
      pParent->pLimit = pSub->pLimit;
      pSub->pLimit = 0;
    }

    /* Recompute the SrcList_item.colUsed masks for the flattened
    ** tables. */
    i = 0;

// ABS Label 2410
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2410);
}
// ABS Label 2411
if(nSubSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2411);
}

// ROR Label 2412
if((i <= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2412);
}
// ROR Label 2413
if((i > nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2413);
}
// ROR Label 2414
if((i >= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2414);
}
for(; i<nSubSrc; i++){
      
// ABS Label 2420
if(pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2420);
}
recomputeColumnsUsed(pParent, &pSrc->a[i+iFrom]);
    };
// ABS Label 2415
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2415);
}
// ABS Label 2416
if(nSubSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2416);
}

// ROR Label 2417
if((i <= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2417);
}
// ROR Label 2418
if((i > nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2418);
}
// ROR Label 2419
if((i >= nSubSrc) != (i < nSubSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2419);
}

  };
// ABS Label 2359
if(pParent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2359);
}


  /* Finially, delete what is left of the subquery and return
  ** success.
  */
  
// ABS Label 2152
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2152);
}
sqlite3AggInfoPersistWalkerInit(&w, pParse);
  
// ABS Label 2153
if(pSub1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2153);
}
sqlite3WalkSelect(&w,pSub1);
  
// ABS Label 2154
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2154);
}

// ABS Label 2155
if(pSub1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2155);
}
sqlite3SelectDelete(db, pSub1);

#if SELECTTRACE_ENABLED
  if( sqlite3SelectTrace & 0x100 ){
    SELECTTRACE(0x100,pParse,p,("After flattening:\n"));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif

  return 1;
}
#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */

/*
** A structure to keep track of all of the column values that are fixed to
** a known value due to WHERE clause constraints of the form COLUMN=VALUE.
*/
typedef struct WhereConst WhereConst;
struct WhereConst {
  Parse *pParse;   /* Parsing context */
  u8 *pOomFault;   /* Pointer to pParse->db->mallocFailed */
  int nConst;      /* Number for COLUMN=CONSTANT terms */
  int nChng;       /* Number of times a constant is propagated */
  int bHasAffBlob; /* At least one column in apExpr[] as affinity BLOB */
  Expr **apExpr;   /* [i*2] is COLUMN and [i*2+1] is VALUE */
};

/*
** Add a new entry to the pConst object.  Except, do not add duplicate
** pColumn entires.  Also, do not add if doing so would not be appropriate.
**
** The caller guarantees the pColumn is a column and pValue is a constant.
** This routine has to do some additional checks before completing the
** insert.
*/
static void constInsert(
  WhereConst *pConst,  /* The WhereConst into which we are inserting */
  Expr *pColumn,       /* The COLUMN part of the constraint */
  Expr *pValue,        /* The VALUE part of the constraint */
  Expr *pExpr          /* Overall expression: COLUMN=VALUE or VALUE=COLUMN */
){
  int i;
  assert( pColumn->op==TK_COLUMN );
  assert( sqlite3ExprIsConstant(pValue) );

  
// MCC Label 2421
if(( ((pColumn)->flags & (8)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2421);
}
// MCC Label 2422
if(( !(((pColumn)->flags & (8)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2422);
}
if( ExprHasProperty(pColumn, EP_FixedCol) ) { return;
}
  if( sqlite3ExprAffinity(pValue)!=0 ) { return;
}
  if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr)) ){
    return;
  }

  /* 2018-10-25 ticket [cf5ed20f]
  ** Make sure the same pColumn is not inserted more than once */
  i = 0;

// ABS Label 2423
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2423);
}
// ABS Label 2424
if(pConst->nConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2424);
}

// ROR Label 2425
if((i <= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2425);
}
// ROR Label 2426
if((i > pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2426);
}
// ROR Label 2427
if((i >= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2427);
}
for(; i<pConst->nConst; i++){
    const Expr *pE2 = pConst->apExpr[i*2];
    assert( pE2->op==TK_COLUMN );
    
// ABS Label 2433
if(pColumn->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2433);
}
// ABS Label 2434
if(pE2->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2434);
}

// COR Label 2435
if((pE2->iTable == pColumn->iTable || pE2->iColumn == pColumn->iColumn) != (pE2->iTable == pColumn->iTable && pE2->iColumn == pColumn->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2435);
}

// ROR Label 2436
if((pE2->iTable != pColumn->iTable) != (pE2->iTable == pColumn->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2436);
}
// ROR Label 2437
if((pE2->iColumn != pColumn->iColumn) != (pE2->iColumn == pColumn->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2437);
}

// MCC Label 2438
if(pE2->iTable == pColumn->iTable && pE2->iColumn == pColumn->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2438);
}
// MCC Label 2439
if(pE2->iTable == pColumn->iTable && !(pE2->iColumn == pColumn->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2439);
}
// MCC Label 2440
if(!(pE2->iTable == pColumn->iTable) && pE2->iColumn == pColumn->iColumn ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2440);
}
// MCC Label 2441
if(!(pE2->iTable == pColumn->iTable) && !(pE2->iColumn == pColumn->iColumn) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2441);
}
if( pE2->iTable==pColumn->iTable
     && pE2->iColumn==pColumn->iColumn
    ){
      return;  /* Already present.  Return without doing anything. */
    }
  };
// ABS Label 2428
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2428);
}
// ABS Label 2429
if(pConst->nConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2429);
}

// ROR Label 2430
if((i <= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2430);
}
// ROR Label 2431
if((i > pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2431);
}
// ROR Label 2432
if((i >= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2432);
}

  if( sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){
    pConst->bHasAffBlob = 1;
  }

  pConst->nConst++;
  pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,
                         pConst->nConst*2*sizeof(Expr*));
  
// ABS Label 2442
if(pConst->apExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2442);
}

// ROR Label 2443
if((pConst->apExpr != 0) != (pConst->apExpr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2443);
}
if( pConst->apExpr==0 ){
    pConst->nConst = 0;
  }else{
    pConst->apExpr[pConst->nConst*2-2] = pColumn;
    pConst->apExpr[pConst->nConst*2-1] = pValue;
  }
}

/*
** Find all terms of COLUMN=VALUE or VALUE=COLUMN in pExpr where VALUE
** is a constant expression and where the term must be true because it
** is part of the AND-connected terms of the expression.  For each term
** found, add it to the pConst structure.
*/
static void findConstInWhere(WhereConst *pConst, Expr *pExpr){
  Expr *pRight, *pLeft;
  
// MCC Label 2444
if(( pExpr == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2444);
}
// MCC Label 2445
if(( !(pExpr == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2445);
}
if( NEVER(pExpr==0) ) { return;
}
  
// MCC Label 2446
if(( ((pExpr)->flags & (1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2446);
}
// MCC Label 2447
if(( !(((pExpr)->flags & (1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2447);
}
if( ExprHasProperty(pExpr, EP_FromJoin) ) { return;
}
  
// ROR Label 2448
if((pExpr->op != 44) != (pExpr->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2448);
}
if( pExpr->op==TK_AND ){
    
// ABS Label 2449
if(pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2449);
}

// ABS Label 2450
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2450);
}
findConstInWhere(pConst, pExpr->pRight);
    
// ABS Label 2451
if(pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2451);
}

// ABS Label 2452
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2452);
}
findConstInWhere(pConst, pExpr->pLeft);
    return;
  }
  
// ROR Label 2453
if((pExpr->op == 53) != (pExpr->op != 53))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2453);
}
if( pExpr->op!=TK_EQ ) { return;
}
  pRight = pExpr->pRight;
  pLeft = pExpr->pLeft;
  assert( pRight!=0 );
  assert( pLeft!=0 );
  if( pRight->op==TK_COLUMN && sqlite3ExprIsConstant(pLeft) ){
    
// ABS Label 2454
if(pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2454);
}

// ABS Label 2455
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2455);
}

// ABS Label 2456
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2456);
}

// ABS Label 2457
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2457);
}
constInsert(pConst,pRight,pLeft,pExpr);
  }
  if( pLeft->op==TK_COLUMN && sqlite3ExprIsConstant(pRight) ){
    
// ABS Label 2458
if(pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2458);
}

// ABS Label 2459
if(pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2459);
}

// ABS Label 2460
if(pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2460);
}

// ABS Label 2461
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2461);
}
constInsert(pConst,pLeft,pRight,pExpr);
  }
}

/*
** This is a helper function for Walker callback propagateConstantExprRewrite().
**
** Argument pExpr is a candidate expression to be replaced by a value. If 
** pExpr is equivalent to one of the columns named in pWalker->u.pConst, 
** then overwrite it with the corresponding value. Except, do not do so
** if argument bIgnoreAffBlob is non-zero and the affinity of pExpr
** is SQLITE_AFF_BLOB.
*/
static int propagateConstantExprRewriteOne(
  WhereConst *pConst,
  Expr *pExpr, 
  int bIgnoreAffBlob
){
  int i;
  
// ABS Label 2462
if(pConst->pOomFault[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2462);
}
if( pConst->pOomFault[0] ) { return WRC_Prune;
}
  
// ROR Label 2463
if((pExpr->op == 166) != (pExpr->op != 166))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2463);
}
if( pExpr->op!=TK_COLUMN ) { return WRC_Continue;
}
  
// MCC Label 2464
if(( ((pExpr)->flags & (8 | 1)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2464);
}
// MCC Label 2465
if(( !(((pExpr)->flags & (8 | 1)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2465);
}
if( ExprHasProperty(pExpr, EP_FixedCol|EP_FromJoin) ){
    testcase( ExprHasProperty(pExpr, EP_FixedCol) );
    testcase( ExprHasProperty(pExpr, EP_FromJoin) );
    return WRC_Continue;
  }
  i = 0;

// ABS Label 2466
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2466);
}
// ABS Label 2467
if(pConst->nConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2467);
}

// ROR Label 2468
if((i <= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2468);
}
// ROR Label 2469
if((i > pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2469);
}
// ROR Label 2470
if((i >= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2470);
}
for(; i<pConst->nConst; i++){
    
// ABS Label 2476
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2476);
}
// ABS Label 2477
if(pConst->apExpr[i * 2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2477);
}

// AOR Label 2478
if(i - 2 != i * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2478);
}
// AOR Label 2479
if(i + 2 != i * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2479);
}
// AOR Label 2480
if(i / 2 != i * 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2480);
}
Expr *pColumn = pConst->apExpr[i*2];
    
// ABS Label 2481
if(pColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2481);
}
// ABS Label 2482
if(pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2482);
}

// ROR Label 2483
if((pColumn != pExpr) != (pColumn == pExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2483);
}
if( pColumn==pExpr ) { continue;
}
    
// ABS Label 2484
if(pColumn->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2484);
}
// ABS Label 2485
if(pExpr->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2485);
}

// ROR Label 2486
if((pColumn->iTable == pExpr->iTable) != (pColumn->iTable != pExpr->iTable))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2486);
}
if( pColumn->iTable!=pExpr->iTable ) { continue;
}
    
// ROR Label 2487
if((pColumn->iColumn == pExpr->iColumn) != (pColumn->iColumn != pExpr->iColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2487);
}
if( pColumn->iColumn!=pExpr->iColumn ) { continue;
}
    if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){
      break;
    }
    /* A match is found.  Add the EP_FixedCol property */
    pConst->nChng++;
    ExprClearProperty(pExpr, EP_Leaf);
    ExprSetProperty(pExpr, EP_FixedCol);
    assert( pExpr->pLeft==0 );
    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);
    
// ABS Label 2488
if(pConst->pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2488);
}
if( pConst->pParse->db->mallocFailed ) { return WRC_Prune;
}
    break;
  };
// ABS Label 2471
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2471);
}
// ABS Label 2472
if(pConst->nConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2472);
}

// ROR Label 2473
if((i <= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2473);
}
// ROR Label 2474
if((i > pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2474);
}
// ROR Label 2475
if((i >= pConst->nConst) != (i < pConst->nConst))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2475);
}

  return WRC_Prune;
}

/*
** This is a Walker expression callback. pExpr is a node from the WHERE
** clause of a SELECT statement. This function examines pExpr to see if
** any substitutions based on the contents of pWalker->u.pConst should
** be made to pExpr or its immediate children.
**
** A substitution is made if:
**
**   + pExpr is a column with an affinity other than BLOB that matches
**     one of the columns in pWalker->u.pConst, or
**
**   + pExpr is a binary comparison operator (=, <=, >=, <, >) that
**     uses an affinity other than TEXT and one of its immediate
**     children is a column that matches one of the columns in 
**     pWalker->u.pConst.
*/
static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){
  
// ABS Label 2489
if(pWalker->u.pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2489);
}
WhereConst *pConst = pWalker->u.pConst;
  assert( TK_GT==TK_EQ+1 );
  assert( TK_LE==TK_EQ+2 );
  assert( TK_LT==TK_EQ+3 );
  assert( TK_GE==TK_EQ+4 );
  
// ABS Label 2490
if(pConst->bHasAffBlob < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2490);
}
if( pConst->bHasAffBlob ){
    
// COR Label 2491
if(((pExpr->op >= 53 && pExpr->op <= 57) && pExpr->op == 45) != ((pExpr->op >= 53 && pExpr->op <= 57) || pExpr->op == 45))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2491);
}

// ROR Label 2492
if((pExpr->op != 45) != (pExpr->op == 45))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2492);
}

// MCC Label 2493
if(( pExpr->op >= 53 && pExpr->op <= 57 ) && pExpr->op == 45 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2493);
}
// MCC Label 2494
if(( pExpr->op >= 53 && pExpr->op <= 57 ) && !(pExpr->op == 45) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2494);
}
// MCC Label 2495
if(( pExpr->op >= 53 && !(pExpr->op <= 57) ) && pExpr->op == 45 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2495);
}
// MCC Label 2496
if(( pExpr->op >= 53 && !(pExpr->op <= 57) ) && !(pExpr->op == 45) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2496);
}
// MCC Label 2497
if(( !(pExpr->op >= 53) && pExpr->op <= 57 ) && pExpr->op == 45 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2497);
}
// MCC Label 2498
if(( !(pExpr->op >= 53) && pExpr->op <= 57 ) && !(pExpr->op == 45) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2498);
}
// MCC Label 2499
if(( !(pExpr->op >= 53) && !(pExpr->op <= 57) ) && pExpr->op == 45 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2499);
}
// MCC Label 2500
if(( !(pExpr->op >= 53) && !(pExpr->op <= 57) ) && !(pExpr->op == 45) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2500);
}
if( (pExpr->op>=TK_EQ && pExpr->op<=TK_GE)
     || pExpr->op==TK_IS
    ){
      
// ABS Label 2501
if(pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2501);
}

// ABS Label 2502
if(pExpr->pLeft < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2502);
}
propagateConstantExprRewriteOne(pConst, pExpr->pLeft, 0);
      
// ABS Label 2503
if(pConst->pOomFault[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2503);
}
if( pConst->pOomFault[0] ) { return WRC_Prune;
}
      if( sqlite3ExprAffinity(pExpr->pLeft)!=SQLITE_AFF_TEXT ){
        
// ABS Label 2504
if(pConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2504);
}

// ABS Label 2505
if(pExpr->pRight < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2505);
}
propagateConstantExprRewriteOne(pConst, pExpr->pRight, 0);
      }
    }
  }
  return propagateConstantExprRewriteOne(pConst, pExpr, pConst->bHasAffBlob);
}

/*
** The WHERE-clause constant propagation optimization.
**
** If the WHERE clause contains terms of the form COLUMN=CONSTANT or
** CONSTANT=COLUMN that are top-level AND-connected terms that are not
** part of a ON clause from a LEFT JOIN, then throughout the query
** replace all other occurrences of COLUMN with CONSTANT.
**
** For example, the query:
**
**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=t1.a AND t3.c=t2.b
**
** Is transformed into
**
**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=39 AND t3.c=39
**
** Return true if any transformations where made and false if not.
**
** Implementation note:  Constant propagation is tricky due to affinity
** and collating sequence interactions.  Consider this example:
**
**    CREATE TABLE t1(a INT,b TEXT);
**    INSERT INTO t1 VALUES(123,'0123');
**    SELECT * FROM t1 WHERE a=123 AND b=a;
**    SELECT * FROM t1 WHERE a=123 AND b=123;
**
** The two SELECT statements above should return different answers.  b=a
** is alway true because the comparison uses numeric affinity, but b=123
** is false because it uses text affinity and '0123' is not the same as '123'.
** To work around this, the expression tree is not actually changed from
** "b=a" to "b=123" but rather the "a" in "b=a" is tagged with EP_FixedCol
** and the "123" value is hung off of the pLeft pointer.  Code generator
** routines know to generate the constant "123" instead of looking up the
** column value.  Also, to avoid collation problems, this optimization is
** only attempted if the "a=123" term uses the default BINARY collation.
**
** 2021-05-25 forum post 6a06202608: Another troublesome case is...
**
**    CREATE TABLE t1(x);
**    INSERT INTO t1 VALUES(10.0);
**    SELECT 1 FROM t1 WHERE x=10 AND x LIKE 10;
**
** The query should return no rows, because the t1.x value is '10.0' not '10'
** and '10.0' is not LIKE '10'.  But if we are not careful, the first WHERE
** term "x=10" will cause the second WHERE term to become "10 LIKE 10",
** resulting in a false positive.  To avoid this, constant propagation for
** columns with BLOB affinity is only allowed if the constant is used with
** operators ==, <=, <, >=, >, or IS in a way that will cause the correct
** type conversions to occur.  See logic associated with the bHasAffBlob flag
** for details.
*/
static int propagateConstants(
  Parse *pParse,   /* The parsing context */
  Select *p        /* The query in which to propagate constants */
){
  WhereConst x;
  Walker w;
  int nChng = 0;
  x.pParse = pParse;
  x.pOomFault = &pParse->db->mallocFailed;
  
// ABS Label 2506
if(x.nChng < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2506);
}
do{
    x.nConst = 0;
    x.nChng = 0;
    x.apExpr = 0;
    x.bHasAffBlob = 0;
    
// ABS Label 2508
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2508);
}
findConstInWhere(&x, p->pWhere);
    
// ABS Label 2509
if(x.nConst < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2509);
}
if( x.nConst ){
      memset(&w, 0, sizeof(w));
      w.pParse = pParse;
      w.xExprCallback = propagateConstantExprRewrite;
      w.xSelectCallback = sqlite3SelectWalkNoop;
      w.xSelectCallback2 = 0;
      w.walkerDepth = 0;
      w.u.pConst = &x;
      
// ABS Label 2510
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2510);
}
sqlite3WalkExpr(&w, p->pWhere);
      
// ABS Label 2511
if(x.pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2511);
}
sqlite3DbFree(x.pParse->db, x.apExpr);
      nChng += x.nChng;
    }
  }while( x.nChng );
// ABS Label 2507
if(x.nChng < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2507);
}
;  
  
// ABS Label 2512
if(nChng < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2512);
}
return nChng;
}

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
# if !defined(SQLITE_OMIT_WINDOWFUNC)
/*
** This function is called to determine whether or not it is safe to
** push WHERE clause expression pExpr down to FROM clause sub-query
** pSubq, which contains at least one window function. Return 1
** if it is safe and the expression should be pushed down, or 0 
** otherwise.
**
** It is only safe to push the expression down if it consists only 
** of constants and copies of expressions that appear in the PARTITION
** BY clause of all window function used by the sub-query. It is safe
** to filter out entire partitions, but not rows within partitions, as
** this may change the results of the window functions.
**
** At the time this function is called it is guaranteed that 
**
**   * the sub-query uses only one distinct window frame, and 
**   * that the window frame has a PARTITION BY clase.
*/
static int pushDownWindowCheck(Parse *pParse, Select *pSubq, Expr *pExpr){
  assert( pSubq->pWin->pPartition );
  assert( (pSubq->selFlags & SF_MultiPart)==0 );
  assert( pSubq->pPrior==0 );
  return sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq->pWin->pPartition);
}
# endif /* SQLITE_OMIT_WINDOWFUNC */
#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
/*
** Make copies of relevant WHERE clause terms of the outer query into
** the WHERE clause of subquery.  Example:
**
**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1) WHERE x=5 AND y=10;
**
** Transformed into:
**
**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1 WHERE a=5 AND c-d=10)
**     WHERE x=5 AND y=10;
**
** The hope is that the terms added to the inner query will make it more
** efficient.
**
** Do not attempt this optimization if:
**
**   (1) (** This restriction was removed on 2017-09-29.  We used to
**           disallow this optimization for aggregate subqueries, but now
**           it is allowed by putting the extra terms on the HAVING clause.
**           The added HAVING clause is pointless if the subquery lacks
**           a GROUP BY clause.  But such a HAVING clause is also harmless
**           so there does not appear to be any reason to add extra logic
**           to suppress it. **)
**
**   (2) The inner query is the recursive part of a common table expression.
**
**   (3) The inner query has a LIMIT clause (since the changes to the WHERE
**       clause would change the meaning of the LIMIT).
**
**   (4) The inner query is the right operand of a LEFT JOIN and the
**       expression to be pushed down does not come from the ON clause
**       on that LEFT JOIN.
**
**   (5) The WHERE clause expression originates in the ON or USING clause
**       of a LEFT JOIN where iCursor is not the right-hand table of that
**       left join.  An example:
**
**           SELECT *
**           FROM (SELECT 1 AS a1 UNION ALL SELECT 2) AS aa
**           JOIN (SELECT 1 AS b2 UNION ALL SELECT 2) AS bb ON (a1=b2)
**           LEFT JOIN (SELECT 8 AS c3 UNION ALL SELECT 9) AS cc ON (b2=2);
**
**       The correct answer is three rows:  (1,1,NULL),(2,2,8),(2,2,9).
**       But if the (b2=2) term were to be pushed down into the bb subquery,
**       then the (1,1,NULL) row would be suppressed.
**
**   (6) Window functions make things tricky as changes to the WHERE clause 
**       of the inner query could change the window over which window 
**       functions are calculated. Therefore, do not attempt the optimization
**       if:
**
**     (6a) The inner query uses multiple incompatible window partitions.
**
**     (6b) The inner query is a compound and uses window-functions. 
**
**     (6c) The WHERE clause does not consist entirely of constants and
**          copies of expressions found in the PARTITION BY clause of
**          all window-functions used by the sub-query. It is safe to
**          filter out entire partitions, as this does not change the 
**          window over which any window-function is calculated.
**
**   (7) The inner query is a Common Table Expression (CTE) that should
**       be materialized.  (This restriction is implemented in the calling
**       routine.)
**
** Return 0 if no changes are made and non-zero if one or more WHERE clause
** terms are duplicated into the subquery.
*/
static int pushDownWhereTerms(
  Parse *pParse,        /* Parse context (for malloc() and error reporting) */
  Select *pSubq,        /* The subquery whose WHERE clause is to be augmented */
  Expr *pWhere,         /* The WHERE clause of the outer query */
  int iCursor,          /* Cursor number of the subquery */
  int isLeftJoin        /* True if pSubq is the right term of a LEFT JOIN */
){
  Expr *pNew;
  int nChng = 0;
  
// ABS Label 2513
if(pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2513);
}

// ROR Label 2514
if((pWhere != 0) != (pWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2514);
}
if( pWhere==0 ) { return 0;
}
  
// ABS Label 2515
if(pSubq->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2515);
}

// AOR Label 2516
if(pSubq->selFlags | (8192 | 33554432) != pSubq->selFlags & (8192 | 33554432))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2516);
}
// AOR Label 2517
if(pSubq->selFlags ^ (8192 | 33554432) != pSubq->selFlags & (8192 | 33554432))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2517);
}
if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ) { return 0;
}

#ifndef SQLITE_OMIT_WINDOWFUNC
  
// ABS Label 2518
if(pSubq->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2518);
}
if( pSubq->pPrior ){
    Select *pSel;
    pSel = pSubq;

// ABS Label 2519
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2519);
}
for(; pSel; pSel=pSel->pPrior){
      
// ABS Label 2521
if(pSel->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2521);
}
if( pSel->pWin ) { return 0;    /* restriction (6b) */
}
    };
// ABS Label 2520
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2520);
}

  }else{
    
// ABS Label 2522
if(pSubq->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2522);
}
// ABS Label 2523
if(pSubq->pWin->pPartition < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2523);
}

// COR Label 2524
if((pSubq->pWin || pSubq->pWin->pPartition == 0) != (pSubq->pWin && pSubq->pWin->pPartition == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2524);
}

// ROR Label 2525
if((pSubq->pWin->pPartition != 0) != (pSubq->pWin->pPartition == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2525);
}

// MCC Label 2526
if(pSubq->pWin && pSubq->pWin->pPartition == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2526);
}
// MCC Label 2527
if(pSubq->pWin && !(pSubq->pWin->pPartition == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2527);
}
// MCC Label 2528
if(!(pSubq->pWin) && pSubq->pWin->pPartition == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2528);
}
// MCC Label 2529
if(!(pSubq->pWin) && !(pSubq->pWin->pPartition == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2529);
}
if( pSubq->pWin && pSubq->pWin->pPartition==0 ) { return 0;
}
  }
#endif

#ifdef SQLITE_DEBUG
  /* Only the first term of a compound can have a WITH clause.  But make
  ** sure no other terms are marked SF_Recursive in case something changes
  ** in the future.
  */
  {
    Select *pX;  
    for(pX=pSubq; pX; pX=pX->pPrior){
      assert( (pX->selFlags & (SF_Recursive))==0 );
    }
  }
#endif

  
// ABS Label 2530
if(pSubq->pLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2530);
}

// ROR Label 2531
if((pSubq->pLimit == 0) != (pSubq->pLimit != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2531);
}
if( pSubq->pLimit!=0 ){
    return 0; /* restriction (3) */
  }
  
// ROR Label 2532
if((pWhere->op != 44) != (pWhere->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2532);
}
while( pWhere->op==TK_AND ){
    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight,
                                iCursor, isLeftJoin);
    pWhere = pWhere->pLeft;
  };
// ROR Label 2533
if((pWhere->op != 44) != (pWhere->op == 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2533);
}

  
// ABS Label 2534
if(isLeftJoin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2534);
}

// COR Label 2535
if((isLeftJoin || ((((pWhere)->flags & (1)) != 0) == 0 || pWhere->iRightJoinTable != iCursor)) != (isLeftJoin && ((((pWhere)->flags & (1)) != 0) == 0 || pWhere->iRightJoinTable != iCursor)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2535);
}

// MCC Label 2536
if(isLeftJoin && ( (((pWhere)->flags & (1)) != 0) == 0 && pWhere->iRightJoinTable != iCursor ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2536);
}
// MCC Label 2537
if(isLeftJoin && ( (((pWhere)->flags & (1)) != 0) == 0 && !(pWhere->iRightJoinTable != iCursor) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2537);
}
// MCC Label 2538
if(isLeftJoin && ( !((((pWhere)->flags & (1)) != 0) == 0) && pWhere->iRightJoinTable != iCursor ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2538);
}
// MCC Label 2539
if(isLeftJoin && ( !((((pWhere)->flags & (1)) != 0) == 0) && !(pWhere->iRightJoinTable != iCursor) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2539);
}
// MCC Label 2540
if(!(isLeftJoin) && ( (((pWhere)->flags & (1)) != 0) == 0 && pWhere->iRightJoinTable != iCursor ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2540);
}
// MCC Label 2541
if(!(isLeftJoin) && ( (((pWhere)->flags & (1)) != 0) == 0 && !(pWhere->iRightJoinTable != iCursor) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2541);
}
// MCC Label 2542
if(!(isLeftJoin) && ( !((((pWhere)->flags & (1)) != 0) == 0) && pWhere->iRightJoinTable != iCursor ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2542);
}
// MCC Label 2543
if(!(isLeftJoin) && ( !((((pWhere)->flags & (1)) != 0) == 0) && !(pWhere->iRightJoinTable != iCursor) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2543);
}
if( isLeftJoin
   && (ExprHasProperty(pWhere,EP_FromJoin)==0
         || pWhere->iRightJoinTable!=iCursor)
  ){
    return 0; /* restriction (4) */
  }
  
// ABS Label 2544
if(iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2544);
}
// ABS Label 2545
if(pWhere->iRightJoinTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2545);
}

// COR Label 2546
if(((((pWhere)->flags & (1)) != 0) || pWhere->iRightJoinTable != iCursor) != ((((pWhere)->flags & (1)) != 0) && pWhere->iRightJoinTable != iCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2546);
}

// ROR Label 2547
if((pWhere->iRightJoinTable == iCursor) != (pWhere->iRightJoinTable != iCursor))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2547);
}

// MCC Label 2548
if(( ((pWhere)->flags & (1)) != 0 ) && pWhere->iRightJoinTable != iCursor ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2548);
}
// MCC Label 2549
if(( ((pWhere)->flags & (1)) != 0 ) && !(pWhere->iRightJoinTable != iCursor) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2549);
}
// MCC Label 2550
if(( !(((pWhere)->flags & (1)) != 0) ) && pWhere->iRightJoinTable != iCursor ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2550);
}
// MCC Label 2551
if(( !(((pWhere)->flags & (1)) != 0) ) && !(pWhere->iRightJoinTable != iCursor) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2551);
}
if( ExprHasProperty(pWhere,EP_FromJoin) && pWhere->iRightJoinTable!=iCursor ){
    return 0; /* restriction (5) */
  }
  if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){
    nChng++;
    pSubq->selFlags |= SF_PushDown;
    
// ABS Label 2552
if(pSubq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2552);
}
while( pSubq ){
      SubstContext x;
      pNew = sqlite3ExprDup(pParse->db, pWhere, 0);
      
// ABS Label 2554
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2554);
}
unsetJoinExpr(pNew, -1);
      x.pParse = pParse;
      x.iTable = iCursor;
      x.iNewTable = iCursor;
      x.isLeftJoin = 0;
      x.pEList = pSubq->pEList;
      pNew = substExpr(&x, pNew);
#ifndef SQLITE_OMIT_WINDOWFUNC
      if( pSubq->pWin && 0==pushDownWindowCheck(pParse, pSubq, pNew) ){
        /* Restriction 6c has prevented push-down in this case */
        
// ABS Label 2555
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2555);
}

// ABS Label 2556
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2556);
}
sqlite3ExprDelete(pParse->db, pNew);
        nChng--;
        break;
      }
#endif
      
// ABS Label 2557
if(pSubq->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2557);
}

// AOR Label 2558
if(pSubq->selFlags | 8 != pSubq->selFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2558);
}
// AOR Label 2559
if(pSubq->selFlags ^ 8 != pSubq->selFlags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2559);
}
if( pSubq->selFlags & SF_Aggregate ){
        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);
      }else{
        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);
      }
      pSubq = pSubq->pPrior;
    };
// ABS Label 2553
if(pSubq < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2553);
}

  }
  
// ABS Label 2560
if(nChng < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2560);
}
return nChng;
}
#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */

/*
** The pFunc is the only aggregate function in the query.  Check to see
** if the query is a candidate for the min/max optimization. 
**
** If the query is a candidate for the min/max optimization, then set
** *ppMinMax to be an ORDER BY clause to be used for the optimization
** and return either WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX depending on
** whether pFunc is a min() or max() function.
**
** If the query is not a candidate for the min/max optimization, return
** WHERE_ORDERBY_NORMAL (which must be zero).
**
** This routine must be called after aggregate functions have been
** located but before their arguments have been subjected to aggregate
** analysis.
*/
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){
  int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */
  
// ABS Label 2561
if(pFunc->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2561);
}
ExprList *pEList = pFunc->x.pList;    /* Arguments to agg function */
  const char *zFunc;                    /* Name of aggregate function pFunc */
  ExprList *pOrderBy;
  u8 sortFlags = 0;

  assert( *ppMinMax==0 );
  assert( pFunc->op==TK_AGG_FUNCTION );
  assert( !IsWindowFunc(pFunc) );
  
// ABS Label 2562
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2562);
}
// ABS Label 2563
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2563);
}

// COR Label 2564
if((pEList == 0 || pEList->nExpr != 1 || (((pFunc)->flags & (16777216)) != 0) && (((db)->dbOptFlags & (65536)) != 0)) != (pEList == 0 || pEList->nExpr != 1 || (((pFunc)->flags & (16777216)) != 0) || (((db)->dbOptFlags & (65536)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2564);
}
// COR Label 2565
if((pEList == 0 || pEList->nExpr != 1 && (((pFunc)->flags & (16777216)) != 0)) != (pEList == 0 || pEList->nExpr != 1 || (((pFunc)->flags & (16777216)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2565);
}
// COR Label 2566
if((pEList == 0 && pEList->nExpr != 1) != (pEList == 0 || pEList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2566);
}

// ROR Label 2567
if((pEList != 0) != (pEList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2567);
}
// ROR Label 2568
if((pEList->nExpr == 1) != (pEList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2568);
}

// MCC Label 2569
if(pEList == 0 && pEList->nExpr != 1 && ( ((pFunc)->flags & (16777216)) != 0 ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2569);
}
// MCC Label 2570
if(pEList == 0 && pEList->nExpr != 1 && ( ((pFunc)->flags & (16777216)) != 0 ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2570);
}
// MCC Label 2571
if(pEList == 0 && pEList->nExpr != 1 && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2571);
}
// MCC Label 2572
if(pEList == 0 && pEList->nExpr != 1 && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2572);
}
// MCC Label 2573
if(pEList == 0 && !(pEList->nExpr != 1) && ( ((pFunc)->flags & (16777216)) != 0 ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2573);
}
// MCC Label 2574
if(pEList == 0 && !(pEList->nExpr != 1) && ( ((pFunc)->flags & (16777216)) != 0 ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2574);
}
// MCC Label 2575
if(pEList == 0 && !(pEList->nExpr != 1) && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2575);
}
// MCC Label 2576
if(pEList == 0 && !(pEList->nExpr != 1) && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2576);
}
// MCC Label 2577
if(!(pEList == 0) && pEList->nExpr != 1 && ( ((pFunc)->flags & (16777216)) != 0 ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2577);
}
// MCC Label 2578
if(!(pEList == 0) && pEList->nExpr != 1 && ( ((pFunc)->flags & (16777216)) != 0 ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2578);
}
// MCC Label 2579
if(!(pEList == 0) && pEList->nExpr != 1 && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2579);
}
// MCC Label 2580
if(!(pEList == 0) && pEList->nExpr != 1 && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2580);
}
// MCC Label 2581
if(!(pEList == 0) && !(pEList->nExpr != 1) && ( ((pFunc)->flags & (16777216)) != 0 ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2581);
}
// MCC Label 2582
if(!(pEList == 0) && !(pEList->nExpr != 1) && ( ((pFunc)->flags & (16777216)) != 0 ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2582);
}
// MCC Label 2583
if(!(pEList == 0) && !(pEList->nExpr != 1) && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( ((db)->dbOptFlags & (65536)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2583);
}
// MCC Label 2584
if(!(pEList == 0) && !(pEList->nExpr != 1) && ( !(((pFunc)->flags & (16777216)) != 0) ) && ( !(((db)->dbOptFlags & (65536)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2584);
}
if( pEList==0 
   || pEList->nExpr!=1
   || ExprHasProperty(pFunc, EP_WinFunc)
   || OptimizationDisabled(db, SQLITE_MinMaxOpt)
  ){
    return eRet;
  }
  zFunc = pFunc->u.zToken;
  if( sqlite3StrICmp(zFunc, "min")==0 ){
    eRet = WHERE_ORDERBY_MIN;
    if( sqlite3ExprCanBeNull(pEList->a[0].pExpr) ){
      sortFlags = KEYINFO_ORDER_BIGNULL;
    }
  }else { if( sqlite3StrICmp(zFunc, "max")==0 ){
    eRet = WHERE_ORDERBY_MAX;
    sortFlags = KEYINFO_ORDER_DESC;
  }else{
    return eRet;
  };}

  *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);
  assert( pOrderBy!=0 || db->mallocFailed );
  
// ABS Label 2585
if(pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2585);
}
if( pOrderBy ) { pOrderBy->a[0].sortFlags = sortFlags;
}
  return eRet;
}

/*
** The select statement passed as the first argument is an aggregate query.
** The second argument is the associated aggregate-info object. This 
** function tests if the SELECT is of the form:
**
**   SELECT count(*) FROM <tbl>
**
** where table is a database table, not a sub-select or view. If the query
** does match this pattern, then a pointer to the Table object representing
** <tbl> is returned. Otherwise, 0 is returned.
*/
static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){
  Table *pTab;
  Expr *pExpr;

  assert( !p->pGroupBy );

  
// ABS Label 2586
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2586);
}
// ABS Label 2587
if(p->pSrc->a[0].pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2587);
}
// ABS Label 2588
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2588);
}
// ABS Label 2589
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2589);
}

// COR Label 2590
if((p->pWhere || p->pEList->nExpr != 1 || p->pSrc->nSrc != 1 && p->pSrc->a[0].pSelect) != (p->pWhere || p->pEList->nExpr != 1 || p->pSrc->nSrc != 1 || p->pSrc->a[0].pSelect))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2590);
}
// COR Label 2591
if((p->pWhere || p->pEList->nExpr != 1 && p->pSrc->nSrc != 1) != (p->pWhere || p->pEList->nExpr != 1 || p->pSrc->nSrc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2591);
}
// COR Label 2592
if((p->pWhere && p->pEList->nExpr != 1) != (p->pWhere || p->pEList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2592);
}

// ROR Label 2593
if((p->pEList->nExpr == 1) != (p->pEList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2593);
}
// ROR Label 2594
if((p->pSrc->nSrc == 1) != (p->pSrc->nSrc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2594);
}

// MCC Label 2595
if(p->pWhere && p->pEList->nExpr != 1 && p->pSrc->nSrc != 1 && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2595);
}
// MCC Label 2596
if(p->pWhere && p->pEList->nExpr != 1 && p->pSrc->nSrc != 1 && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2596);
}
// MCC Label 2597
if(p->pWhere && p->pEList->nExpr != 1 && !(p->pSrc->nSrc != 1) && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2597);
}
// MCC Label 2598
if(p->pWhere && p->pEList->nExpr != 1 && !(p->pSrc->nSrc != 1) && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2598);
}
// MCC Label 2599
if(p->pWhere && !(p->pEList->nExpr != 1) && p->pSrc->nSrc != 1 && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2599);
}
// MCC Label 2600
if(p->pWhere && !(p->pEList->nExpr != 1) && p->pSrc->nSrc != 1 && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2600);
}
// MCC Label 2601
if(p->pWhere && !(p->pEList->nExpr != 1) && !(p->pSrc->nSrc != 1) && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2601);
}
// MCC Label 2602
if(p->pWhere && !(p->pEList->nExpr != 1) && !(p->pSrc->nSrc != 1) && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2602);
}
// MCC Label 2603
if(!(p->pWhere) && p->pEList->nExpr != 1 && p->pSrc->nSrc != 1 && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2603);
}
// MCC Label 2604
if(!(p->pWhere) && p->pEList->nExpr != 1 && p->pSrc->nSrc != 1 && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2604);
}
// MCC Label 2605
if(!(p->pWhere) && p->pEList->nExpr != 1 && !(p->pSrc->nSrc != 1) && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2605);
}
// MCC Label 2606
if(!(p->pWhere) && p->pEList->nExpr != 1 && !(p->pSrc->nSrc != 1) && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2606);
}
// MCC Label 2607
if(!(p->pWhere) && !(p->pEList->nExpr != 1) && p->pSrc->nSrc != 1 && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2607);
}
// MCC Label 2608
if(!(p->pWhere) && !(p->pEList->nExpr != 1) && p->pSrc->nSrc != 1 && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2608);
}
// MCC Label 2609
if(!(p->pWhere) && !(p->pEList->nExpr != 1) && !(p->pSrc->nSrc != 1) && p->pSrc->a[0].pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2609);
}
// MCC Label 2610
if(!(p->pWhere) && !(p->pEList->nExpr != 1) && !(p->pSrc->nSrc != 1) && !(p->pSrc->a[0].pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2610);
}
if( p->pWhere || p->pEList->nExpr!=1 
   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect
  ){
    return 0;
  }
  pTab = p->pSrc->a[0].pTab;
  pExpr = p->pEList->a[0].pExpr;
  assert( pTab && !pTab->pSelect && pExpr );

  
// ABS Label 2611
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2611);
}
if( IsVirtual(pTab) ) { return 0;
}
  
// ROR Label 2612
if((pExpr->op == 167) != (pExpr->op != 167))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2612);
}
if( pExpr->op!=TK_AGG_FUNCTION ) { return 0;
}
  
// MCC Label 2613
if(( pAggInfo->nFunc == 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2613);
}
// MCC Label 2614
if(( !(pAggInfo->nFunc == 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2614);
}
if( NEVER(pAggInfo->nFunc==0) ) { return 0;
}
  
// ROR Label 2615
if(((pAggInfo->aFunc[0].pFunc->funcFlags & 256) != 0) != ((pAggInfo->aFunc[0].pFunc->funcFlags & 256) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2615);
}
if( (pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT)==0 ) { return 0;
}
  
// MCC Label 2616
if(( ((pExpr)->flags & (2 | 16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2616);
}
// MCC Label 2617
if(( !(((pExpr)->flags & (2 | 16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2617);
}
if( ExprHasProperty(pExpr, EP_Distinct|EP_WinFunc) ) { return 0;
}

  
// ABS Label 2618
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2618);
}
return pTab;
}

/*
** If the source-list item passed as an argument was augmented with an
** INDEXED BY clause, then try to locate the specified index. If there
** was such a clause and the named index cannot be found, return 
** SQLITE_ERROR and leave an error in pParse. Otherwise, populate 
** pFrom->pIndex and return SQLITE_OK.
*/
int sqlite3IndexedByLookup(Parse *pParse, SrcItem *pFrom){
  
// ABS Label 2619
if(pFrom->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2619);
}
Table *pTab = pFrom->pTab;
  
// ABS Label 2620
if(pFrom->u1.zIndexedBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2620);
}
char *zIndexedBy = pFrom->u1.zIndexedBy;
  Index *pIdx;
  assert( pTab!=0 );
  assert( pFrom->fg.isIndexedBy!=0 );

  pIdx = pTab->pIndex;
for(; 
      pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy); 
      pIdx=pIdx->pNext
  ) {;
};
  if( !pIdx ){
    
// ABS Label 2621
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2621);
}

// ABS Label 2622
if(zIndexedBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2622);
}
sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, 0);
    pParse->checkSchema = 1;
    return SQLITE_ERROR;
  }
  pFrom->u2.pIBIndex = pIdx;
  return SQLITE_OK;
}

/*
** Detect compound SELECT statements that use an ORDER BY clause with 
** an alternative collating sequence.
**
**    SELECT ... FROM t1 EXCEPT SELECT ... FROM t2 ORDER BY .. COLLATE ...
**
** These are rewritten as a subquery:
**
**    SELECT * FROM (SELECT ... FROM t1 EXCEPT SELECT ... FROM t2)
**     ORDER BY ... COLLATE ...
**
** This transformation is necessary because the multiSelectOrderBy() routine
** above that generates the code for a compound SELECT with an ORDER BY clause
** uses a merge algorithm that requires the same collating sequence on the
** result columns as on the ORDER BY clause.  See ticket
** http://www.sqlite.org/src/info/6709574d2a
**
** This transformation is only needed for EXCEPT, INTERSECT, and UNION.
** The UNION ALL operator works fine with multiSelectOrderBy() even when
** there are COLLATE terms in the ORDER BY.
*/
static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
  int i;
  Select *pNew;
  Select *pX;
  sqlite3 *db;
  struct ExprList_item *a;
  SrcList *pNewSrc;
  Parse *pParse;
  Token dummy;

  
// ABS Label 2623
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2623);
}

// ROR Label 2624
if((p->pPrior != 0) != (p->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2624);
}
if( p->pPrior==0 ) { return WRC_Continue;
}
  
// ABS Label 2625
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2625);
}

// ROR Label 2626
if((p->pOrderBy != 0) != (p->pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2626);
}
if( p->pOrderBy==0 ) { return WRC_Continue;
}
  pX = p;

// ABS Label 2627
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2627);
}

// COR Label 2628
if((pX || (pX->op == 134 || pX->op == 137)) != (pX && (pX->op == 134 || pX->op == 137)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2628);
}

// MCC Label 2629
if(pX && ( pX->op == 134 && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2629);
}
// MCC Label 2630
if(pX && ( pX->op == 134 && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2630);
}
// MCC Label 2631
if(pX && ( !(pX->op == 134) && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2631);
}
// MCC Label 2632
if(pX && ( !(pX->op == 134) && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2632);
}
// MCC Label 2633
if(!(pX) && ( pX->op == 134 && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2633);
}
// MCC Label 2634
if(!(pX) && ( pX->op == 134 && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2634);
}
// MCC Label 2635
if(!(pX) && ( !(pX->op == 134) && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2635);
}
// MCC Label 2636
if(!(pX) && ( !(pX->op == 134) && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2636);
}
for(; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){};
// ABS Label 2637
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2637);
}

// COR Label 2638
if((pX || (pX->op == 134 || pX->op == 137)) != (pX && (pX->op == 134 || pX->op == 137)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2638);
}

// MCC Label 2639
if(pX && ( pX->op == 134 && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2639);
}
// MCC Label 2640
if(pX && ( pX->op == 134 && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2640);
}
// MCC Label 2641
if(pX && ( !(pX->op == 134) && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2641);
}
// MCC Label 2642
if(pX && ( !(pX->op == 134) && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2642);
}
// MCC Label 2643
if(!(pX) && ( pX->op == 134 && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2643);
}
// MCC Label 2644
if(!(pX) && ( pX->op == 134 && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2644);
}
// MCC Label 2645
if(!(pX) && ( !(pX->op == 134) && pX->op == 137 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2645);
}
// MCC Label 2646
if(!(pX) && ( !(pX->op == 134) && !(pX->op == 137) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2646);
}

  
// ABS Label 2647
if(pX < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2647);
}

// ROR Label 2648
if((pX != 0) != (pX == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2648);
}
if( pX==0 ) { return WRC_Continue;
}
  a = p->pOrderBy->a;
#ifndef SQLITE_OMIT_WINDOWFUNC
  /* If iOrderByCol is already non-zero, then it has already been matched
  ** to a result column of the SELECT statement. This occurs when the
  ** SELECT is rewritten for window-functions processing and then passed
  ** to sqlite3SelectPrep() and similar a second time. The rewriting done
  ** by this function is not required in this case. */
  
// ABS Label 2649
if(a[0].u.x.iOrderByCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2649);
}
if( a[0].u.x.iOrderByCol ) { return WRC_Continue;
}
#endif
  i = p->pOrderBy->nExpr - 1;

// ABS Label 2650
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2650);
}

// ROR Label 2651
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2651);
}
// ROR Label 2652
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2652);
}
// ROR Label 2653
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2653);
}
for(; i>=0; i--){
    
// ABS Label 2658
if(a[i].pExpr->flags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2658);
}

// AOR Label 2659
if(a[i].pExpr->flags | 256 != a[i].pExpr->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2659);
}
// AOR Label 2660
if(a[i].pExpr->flags ^ 256 != a[i].pExpr->flags & 256)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2660);
}
if( a[i].pExpr->flags & EP_Collate ) { break;
}
  };
// ABS Label 2654
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2654);
}

// ROR Label 2655
if((i < 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2655);
}
// ROR Label 2656
if((i > 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2656);
}
// ROR Label 2657
if((i <= 0) != (i >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2657);
}

  
// ABS Label 2661
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2661);
}

// ROR Label 2662
if((i <= 0) != (i < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2662);
}
// ROR Label 2663
if((i > 0) != (i < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2663);
}
// ROR Label 2664
if((i >= 0) != (i < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2664);
}
if( i<0 ) { return WRC_Continue;
}

  /* If we reach this point, that means the transformation is required. */

  pParse = pWalker->pParse;
  db = pParse->db;
  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );
  
// ABS Label 2665
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2665);
}

// ROR Label 2666
if((pNew != 0) != (pNew == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2666);
}
if( pNew==0 ) { return WRC_Abort;
}
  memset(&dummy, 0, sizeof(dummy));
  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);
  
// ABS Label 2667
if(pNewSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2667);
}

// ROR Label 2668
if((pNewSrc != 0) != (pNewSrc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2668);
}
if( pNewSrc==0 ) { return WRC_Abort;
}
  *pNew = *p;
  p->pSrc = pNewSrc;
  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));
  p->op = TK_SELECT;
  p->pWhere = 0;
  pNew->pGroupBy = 0;
  pNew->pHaving = 0;
  pNew->pOrderBy = 0;
  p->pPrior = 0;
  p->pNext = 0;
  p->pWith = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
  p->pWinDefn = 0;
#endif
  p->selFlags &= ~SF_Compound;
  assert( (p->selFlags & SF_Converted)==0 );
  p->selFlags |= SF_Converted;
  assert( pNew->pPrior!=0 );
  pNew->pPrior->pNext = pNew;
  pNew->pLimit = 0;
  return WRC_Continue;
}

/*
** Check to see if the FROM clause term pFrom has table-valued function
** arguments.  If it does, leave an error message in pParse and return
** non-zero, since pFrom is not allowed to be a table-valued function.
*/
static int cannotBeFunction(Parse *pParse, SrcItem *pFrom){
  
// ABS Label 2669
if(pFrom->fg.isTabFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2669);
}
if( pFrom->fg.isTabFunc ){
    
// ABS Label 2670
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2670);
}

// ABS Label 2671
if(pFrom->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2671);
}
sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom->zName);
    return 1;
  }
  return 0;
}

#ifndef SQLITE_OMIT_CTE
/*
** Argument pWith (which may be NULL) points to a linked list of nested 
** WITH contexts, from inner to outermost. If the table identified by 
** FROM clause element pItem is really a common-table-expression (CTE) 
** then return a pointer to the CTE definition for that table. Otherwise
** return NULL.
**
** If a non-NULL value is returned, set *ppContext to point to the With
** object that the returned CTE belongs to.
*/
static struct Cte *searchWith(
  With *pWith,                    /* Current innermost WITH clause */
  SrcItem *pItem,                 /* FROM clause element to resolve */
  With **ppContext                /* OUT: WITH clause return value belongs to */
){
  const char *zName = pItem->zName;
  With *p;
  assert( pItem->zDatabase==0 );
  assert( zName!=0 );
  p = pWith;

// ABS Label 2672
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2672);
}
for(; p; p=p->pOuter){
    int i;
    i = 0;

// ABS Label 2674
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2674);
}
// ABS Label 2675
if(p->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2675);
}

// ROR Label 2676
if((i <= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2676);
}
// ROR Label 2677
if((i > p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2677);
}
// ROR Label 2678
if((i >= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2678);
}
for(; i<p->nCte; i++){
      if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){
        *ppContext = p;
        return &p->a[i];
      }
    };
// ABS Label 2679
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2679);
}
// ABS Label 2680
if(p->nCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2680);
}

// ROR Label 2681
if((i <= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2681);
}
// ROR Label 2682
if((i > p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2682);
}
// ROR Label 2683
if((i >= p->nCte) != (i < p->nCte))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2683);
}

    
// ABS Label 2684
if(p->bView < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2684);
}
if( p->bView ) { break;
}
  };
// ABS Label 2673
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2673);
}

  return 0;
}

/* The code generator maintains a stack of active WITH clauses
** with the inner-most WITH clause being at the top of the stack.
**
** This routine pushes the WITH clause passed as the second argument
** onto the top of the stack. If argument bFree is true, then this
** WITH clause will never be popped from the stack but should instead
** be freed along with the Parse object. In other cases, when
** bFree==0, the With object will be freed along with the SELECT 
** statement with which it is associated.
**
** This routine returns a copy of pWith.  Or, if bFree is true and
** the pWith object is destroyed immediately due to an OOM condition,
** then this routine return NULL.
**
** If bFree is true, do not continue to use the pWith pointer after
** calling this routine,  Instead, use only the return value.
*/
With *sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){
  
// ABS Label 2685
if(pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2685);
}
if( pWith ){
    
// ABS Label 2686
if(bFree < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2686);
}
if( bFree ){
      pWith = (With*)sqlite3ParserAddCleanup(pParse, 
                      (void(*)(sqlite3*,void*))sqlite3WithDelete,
                      pWith);
      
// ABS Label 2687
if(pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2687);
}

// ROR Label 2688
if((pWith != 0) != (pWith == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2688);
}
if( pWith==0 ) { return 0;
}
    }
    
// ABS Label 2689
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2689);
}

// ROR Label 2690
if((pParse->nErr != 0) != (pParse->nErr == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2690);
}
if( pParse->nErr==0 ){
      assert( pParse->pWith!=pWith );
      pWith->pOuter = pParse->pWith;
      pParse->pWith = pWith;
    }
  }
  
// ABS Label 2691
if(pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2691);
}
return pWith;
}

/*
** This function checks if argument pFrom refers to a CTE declared by 
** a WITH clause on the stack currently maintained by the parser (on the
** pParse->pWith linked list).  And if currently processing a CTE
** CTE expression, through routine checks to see if the reference is
** a recursive reference to the CTE.
**
** If pFrom matches a CTE according to either of these two above, pFrom->pTab
** and other fields are populated accordingly.
**
** Return 0 if no match is found. 
** Return 1 if a match is found.
** Return 2 if an error condition is detected.
*/
static int resolveFromTermToCte(
  Parse *pParse,                  /* The parsing context */
  Walker *pWalker,                /* Current tree walker */
  SrcItem *pFrom                  /* The FROM clause term to check */
){
  Cte *pCte;               /* Matched CTE (or NULL if no match) */
  With *pWith;             /* The matching WITH */

  assert( pFrom->pTab==0 );
  
// ABS Label 2692
if(pParse->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2692);
}

// ROR Label 2693
if((pParse->pWith != 0) != (pParse->pWith == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2693);
}
if( pParse->pWith==0 ){
    /* There are no WITH clauses in the stack.  No match is possible */
    return 0;
  }
  
// ABS Label 2694
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2694);
}
if( pParse->nErr ){
    /* Prior errors might have left pParse->pWith in a goofy state, so
    ** go no further. */
    return 0;
  }
  
// ABS Label 2695
if(pFrom->zDatabase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2695);
}

// ROR Label 2696
if((pFrom->zDatabase == 0) != (pFrom->zDatabase != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2696);
}
if( pFrom->zDatabase!=0 ){
    /* The FROM term contains a schema qualifier (ex: main.t1) and so
    ** it cannot possibly be a CTE reference. */
    return 0;
  }
  
// ABS Label 2697
if(pFrom->fg.notCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2697);
}
if( pFrom->fg.notCte ){
    /* The FROM term is specifically excluded from matching a CTE.
    **   (1)  It is part of a trigger that used to have zDatabase but had
    **        zDatabase removed by sqlite3FixTriggerStep().
    **   (2)  This is the first term in the FROM clause of an UPDATE.
    */
    return 0;
  }
  pCte = searchWith(pParse->pWith, pFrom, &pWith);
  
// ABS Label 2698
if(pCte < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2698);
}
if( pCte ){
    
// ABS Label 2699
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2699);
}
sqlite3 *db = pParse->db;
    Table *pTab;
    ExprList *pEList;
    Select *pSel;
    Select *pLeft;                /* Left-most SELECT statement */
    Select *pRecTerm;             /* Left-most recursive term */
    int bMayRecursive;            /* True if compound joined by UNION [ALL] */
    With *pSavedWith;             /* Initial value of pParse->pWith */
    int iRecTab = -1;             /* Cursor for recursive table */
    CteUse *pCteUse;

    /* If pCte->zCteErr is non-NULL at this point, then this is an illegal
    ** recursive reference to CTE pCte. Leave an error in pParse and return
    ** early. If pCte->zCteErr is NULL, then this is not a recursive reference.
    ** In this case, proceed.  */
    
// ABS Label 2702
if(pCte->zCteErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2702);
}
if( pCte->zCteErr ){
      
// ABS Label 2703
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2703);
}

// ABS Label 2704
if(pCte->zCteErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2704);
}

// ABS Label 2705
if(pCte->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2705);
}
sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);
      return 2;
    }
    if( cannotBeFunction(pParse, pFrom) ) { return 2;
}

    assert( pFrom->pTab==0 );
    pTab = sqlite3DbMallocZero(db, sizeof(Table));
    
// ABS Label 2706
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2706);
}

// ROR Label 2707
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2707);
}
if( pTab==0 ) { return 2;
}
    pCteUse = pCte->pUse;
    
// ABS Label 2708
if(pCteUse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2708);
}

// ROR Label 2709
if((pCteUse != 0) != (pCteUse == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2709);
}
if( pCteUse==0 ){
      pCte->pUse = pCteUse = sqlite3DbMallocZero(db, sizeof(pCteUse[0]));
      if( pCteUse==0
       || sqlite3ParserAddCleanup(pParse,sqlite3DbFree,pCteUse)==0
      ){
        
// ABS Label 2710
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2710);
}
sqlite3DbFree(db, pTab);
        return 2;
      }
      pCteUse->eM10d = pCte->eM10d;
    }
    pFrom->pTab = pTab;
    pTab->nTabRef = 1;
    pTab->zName = sqlite3DbStrDup(db, pCte->zName);
    pTab->iPKey = -1;
    pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
    pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;
    pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);
    
// ABS Label 2711
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2711);
}
if( db->mallocFailed ) { return 2;
}
    pFrom->pSelect->selFlags |= SF_CopyCte;
    assert( pFrom->pSelect );
    pFrom->fg.isCte = 1;
    pFrom->u2.pCteUse = pCteUse;
    pCteUse->nUse++;
    
// ABS Label 2712
if(pCteUse->nUse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2712);
}

// COR Label 2713
if((pCteUse->nUse >= 2 || pCteUse->eM10d == 1) != (pCteUse->nUse >= 2 && pCteUse->eM10d == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2713);
}

// ROR Label 2714
if((pCteUse->nUse < 2) != (pCteUse->nUse >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2714);
}
// ROR Label 2715
if((pCteUse->nUse > 2) != (pCteUse->nUse >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2715);
}
// ROR Label 2716
if((pCteUse->nUse <= 2) != (pCteUse->nUse >= 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2716);
}
// ROR Label 2717
if((pCteUse->eM10d != 1) != (pCteUse->eM10d == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2717);
}

// MCC Label 2718
if(pCteUse->nUse >= 2 && pCteUse->eM10d == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2718);
}
// MCC Label 2719
if(pCteUse->nUse >= 2 && !(pCteUse->eM10d == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2719);
}
// MCC Label 2720
if(!(pCteUse->nUse >= 2) && pCteUse->eM10d == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2720);
}
// MCC Label 2721
if(!(pCteUse->nUse >= 2) && !(pCteUse->eM10d == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2721);
}
if( pCteUse->nUse>=2 && pCteUse->eM10d==M10d_Any ){
      pCteUse->eM10d = M10d_Yes;
    }

    /* Check if this is a recursive CTE. */
    pRecTerm = pSel = pFrom->pSelect;
    bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );
    
// ABS Label 2722
if(bMayRecursive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2722);
}

// COR Label 2723
if((bMayRecursive || pRecTerm->op == pSel->op) != (bMayRecursive && pRecTerm->op == pSel->op))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2723);
}

// ROR Label 2724
if((pRecTerm->op != pSel->op) != (pRecTerm->op == pSel->op))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2724);
}

// MCC Label 2725
if(bMayRecursive && pRecTerm->op == pSel->op ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2725);
}
// MCC Label 2726
if(bMayRecursive && !(pRecTerm->op == pSel->op) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2726);
}
// MCC Label 2727
if(!(bMayRecursive) && pRecTerm->op == pSel->op ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2727);
}
// MCC Label 2728
if(!(bMayRecursive) && !(pRecTerm->op == pSel->op) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2728);
}
while( bMayRecursive && pRecTerm->op==pSel->op ){
      int i;
      
// ABS Label 2736
if(pRecTerm->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2736);
}
SrcList *pSrc = pRecTerm->pSrc;
      assert( pRecTerm->pPrior!=0 );
      i = 0;

// ABS Label 2737
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2737);
}
// ABS Label 2738
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2738);
}

// ROR Label 2739
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2739);
}
// ROR Label 2740
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2740);
}
// ROR Label 2741
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2741);
}
for(; i<pSrc->nSrc; i++){
        SrcItem *pItem = &pSrc->a[i];
        if( pItem->zDatabase==0 
         && pItem->zName!=0 
         && 0==sqlite3StrICmp(pItem->zName, pCte->zName)
        ){
          pItem->pTab = pTab;
          pTab->nTabRef++;
          pItem->fg.isRecursive = 1;
          
// ABS Label 2747
if(pRecTerm->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2747);
}

// AOR Label 2748
if(pRecTerm->selFlags | 8192 != pRecTerm->selFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2748);
}
// AOR Label 2749
if(pRecTerm->selFlags ^ 8192 != pRecTerm->selFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2749);
}
if( pRecTerm->selFlags & SF_Recursive ){
            
// ABS Label 2750
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2750);
}

// ABS Label 2751
if(pCte->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2751);
}
sqlite3ErrorMsg(pParse,
               "multiple references to recursive table: %s", pCte->zName
            );
            return 2;
          }
          pRecTerm->selFlags |= SF_Recursive;
          
// ABS Label 2752
if(iRecTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2752);
}

// ROR Label 2753
if((iRecTab <= 0) != (iRecTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2753);
}
// ROR Label 2754
if((iRecTab > 0) != (iRecTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2754);
}
// ROR Label 2755
if((iRecTab >= 0) != (iRecTab < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2755);
}
if( iRecTab<0 ) { iRecTab = pParse->nTab++;
}
          pItem->iCursor = iRecTab;
        }
      };
// ABS Label 2742
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2742);
}
// ABS Label 2743
if(pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2743);
}

// ROR Label 2744
if((i <= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2744);
}
// ROR Label 2745
if((i > pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2745);
}
// ROR Label 2746
if((i >= pSrc->nSrc) != (i < pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2746);
}

      
// ROR Label 2756
if(((pRecTerm->selFlags & 8192) != 0) != ((pRecTerm->selFlags & 8192) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2756);
}
if( (pRecTerm->selFlags & SF_Recursive)==0 ) { break;
}
      pRecTerm = pRecTerm->pPrior;
    };
// ABS Label 2729
if(bMayRecursive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2729);
}

// COR Label 2730
if((bMayRecursive || pRecTerm->op == pSel->op) != (bMayRecursive && pRecTerm->op == pSel->op))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2730);
}

// ROR Label 2731
if((pRecTerm->op != pSel->op) != (pRecTerm->op == pSel->op))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2731);
}

// MCC Label 2732
if(bMayRecursive && pRecTerm->op == pSel->op ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2732);
}
// MCC Label 2733
if(bMayRecursive && !(pRecTerm->op == pSel->op) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2733);
}
// MCC Label 2734
if(!(bMayRecursive) && pRecTerm->op == pSel->op ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2734);
}
// MCC Label 2735
if(!(bMayRecursive) && !(pRecTerm->op == pSel->op) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2735);
}


    pCte->zCteErr = "circular reference: %s";
    pSavedWith = pParse->pWith;
    pParse->pWith = pWith;
    
// ABS Label 2757
if(pSel->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2757);
}

// AOR Label 2758
if(pSel->selFlags | 8192 != pSel->selFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2758);
}
// AOR Label 2759
if(pSel->selFlags ^ 8192 != pSel->selFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2759);
}
if( pSel->selFlags & SF_Recursive ){
      int rc;
      assert( pRecTerm!=0 );
      assert( (pRecTerm->selFlags & SF_Recursive)==0 );
      assert( pRecTerm->pNext!=0 );
      assert( (pRecTerm->pNext->selFlags & SF_Recursive)!=0 );
      assert( pRecTerm->pWith==0 );
      pRecTerm->pWith = pSel->pWith;
      rc = sqlite3WalkSelect(pWalker, pRecTerm);
      pRecTerm->pWith = 0;
      
// ABS Label 2760
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2760);
}
if( rc ){
        pParse->pWith = pSavedWith;
        return 2;
      }
    }else{
      if( sqlite3WalkSelect(pWalker, pSel) ){
        pParse->pWith = pSavedWith;
        return 2;
      }
    }
    pParse->pWith = pWith;

    pLeft = pSel;

// ABS Label 2761
if(pLeft->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2761);
}
for(; pLeft->pPrior; pLeft=pLeft->pPrior) {;
};
// ABS Label 2762
if(pLeft->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2762);
}

    pEList = pLeft->pEList;
    
// ABS Label 2763
if(pCte->pCols < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2763);
}
if( pCte->pCols ){
      
// ABS Label 2764
if(pCte->pCols->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2764);
}
// ABS Label 2765
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2765);
}
// ABS Label 2766
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2766);
}

// COR Label 2767
if((pEList || pEList->nExpr != pCte->pCols->nExpr) != (pEList && pEList->nExpr != pCte->pCols->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2767);
}

// ROR Label 2768
if((pEList->nExpr == pCte->pCols->nExpr) != (pEList->nExpr != pCte->pCols->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2768);
}

// MCC Label 2769
if(pEList && pEList->nExpr != pCte->pCols->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2769);
}
// MCC Label 2770
if(pEList && !(pEList->nExpr != pCte->pCols->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2770);
}
// MCC Label 2771
if(!(pEList) && pEList->nExpr != pCte->pCols->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2771);
}
// MCC Label 2772
if(!(pEList) && !(pEList->nExpr != pCte->pCols->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2772);
}
if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){
        
// ABS Label 2773
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2773);
}

// ABS Label 2774
if(pCte->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2774);
}

// ABS Label 2775
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2775);
}

// ABS Label 2776
if(pCte->pCols->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2776);
}
sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",
            pCte->zName, pEList->nExpr, pCte->pCols->nExpr
        );
        pParse->pWith = pSavedWith;
        return 2;
      }
      pEList = pCte->pCols;
    }

    
// ABS Label 2700
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2700);
}

// ABS Label 2701
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2701);
}
sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);
    
// ABS Label 2777
if(bMayRecursive < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2777);
}
if( bMayRecursive ){
      
// ABS Label 2780
if(pSel->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2780);
}

// AOR Label 2781
if(pSel->selFlags | 8192 != pSel->selFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2781);
}
// AOR Label 2782
if(pSel->selFlags ^ 8192 != pSel->selFlags & 8192)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 2782);
}
if( pSel->selFlags & SF_Recursive ){
        pCte->zCteErr = "multiple recursive references: %s";
      }else{
        pCte->zCteErr = "recursive reference in a subquery: %s";
      }
      
// ABS Label 2778
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2778);
}

// ABS Label 2779
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2779);
}
sqlite3WalkSelect(pWalker, pSel);
    }
    pCte->zCteErr = 0;
    pParse->pWith = pSavedWith;
    return 1;  /* Success */
  }
  return 0;  /* No match */
}
#endif

#ifndef SQLITE_OMIT_CTE
/*
** If the SELECT passed as the second argument has an associated WITH 
** clause, pop it from the stack stored as part of the Parse object.
**
** This function is used as the xSelectCallback2() callback by
** sqlite3SelectExpand() when walking a SELECT tree to resolve table
** names and other FROM clause elements. 
*/
void sqlite3SelectPopWith(Walker *pWalker, Select *p){
  
// ABS Label 2783
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2783);
}
Parse *pParse = pWalker->pParse;
  
// ABS Label 2784
if((pParse->pWith) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2784);
}
// ABS Label 2785
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2785);
}

// COR Label 2786
if(((pParse->pWith) || p->pPrior == 0) != ((pParse->pWith) && p->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2786);
}

// ROR Label 2787
if((p->pPrior != 0) != (p->pPrior == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2787);
}

// MCC Label 2788
if((pParse->pWith) && p->pPrior == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2788);
}
// MCC Label 2789
if((pParse->pWith) && !(p->pPrior == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2789);
}
// MCC Label 2790
if(!((pParse->pWith)) && p->pPrior == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2790);
}
// MCC Label 2791
if(!((pParse->pWith)) && !(p->pPrior == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2791);
}
if( OK_IF_ALWAYS_TRUE(pParse->pWith) && p->pPrior==0 ){
    With *pWith = findRightmost(p)->pWith;
    
// ABS Label 2792
if(pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2792);
}

// ROR Label 2793
if((pWith == 0) != (pWith != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2793);
}
if( pWith!=0 ){
      assert( pParse->pWith==pWith || pParse->nErr );
      pParse->pWith = pWith->pOuter;
    }
  }
}
#endif

/*
** The SrcList_item structure passed as the second argument represents a
** sub-query in the FROM clause of a SELECT statement. This function
** allocates and populates the SrcList_item.pTab object. If successful,
** SQLITE_OK is returned. Otherwise, if an OOM error is encountered,
** SQLITE_NOMEM.
*/
int sqlite3ExpandSubquery(Parse *pParse, SrcItem *pFrom){
  
// ABS Label 2794
if(pFrom->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2794);
}
Select *pSel = pFrom->pSelect;
  Table *pTab;

  assert( pSel );
  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));
  
// ABS Label 2797
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2797);
}

// ROR Label 2798
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2798);
}
if( pTab==0 ) { return SQLITE_NOMEM;
}
  pTab->nTabRef = 1;
  
// ABS Label 2799
if(pFrom->zAlias < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2799);
}
if( pFrom->zAlias ){
    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);
  }else{
    pTab->zName = sqlite3MPrintf(pParse->db, "subquery_%u", pSel->selId);
  }
  
// ABS Label 2800
if(pSel->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2800);
}
while( pSel->pPrior ){ pSel = pSel->pPrior; };
// ABS Label 2801
if(pSel->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2801);
}

  
// ABS Label 2795
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2795);
}

// ABS Label 2796
if(pSel->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2796);
}
sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);
  pTab->iPKey = -1;
  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
#ifndef SQLITE_ALLOW_ROWID_IN_VIEW
  /* The usual case - do not allow ROWID on a subquery */
  pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;
#else
  pTab->tabFlags |= TF_Ephemeral;  /* Legacy compatibility mode */
#endif


  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;
}

/*
** This routine is a Walker callback for "expanding" a SELECT statement.
** "Expanding" means to do the following:
**
**    (1)  Make sure VDBE cursor numbers have been assigned to every
**         element of the FROM clause.
**
**    (2)  Fill in the pTabList->a[].pTab fields in the SrcList that 
**         defines FROM clause.  When views appear in the FROM clause,
**         fill pTabList->a[].pSelect with a copy of the SELECT statement
**         that implements the view.  A copy is made of the view's SELECT
**         statement so that we can freely modify or delete that statement
**         without worrying about messing up the persistent representation
**         of the view.
**
**    (3)  Add terms to the WHERE clause to accommodate the NATURAL keyword
**         on joins and the ON and USING clause of joins.
**
**    (4)  Scan the list of columns in the result set (pEList) looking
**         for instances of the "*" operator or the TABLE.* operator.
**         If found, expand each "*" to be every column in every table
**         and TABLE.* to be every column in TABLE.
**
*/
static int selectExpander(Walker *pWalker, Select *p){
  
// ABS Label 2802
if(pWalker->pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2802);
}
Parse *pParse = pWalker->pParse;
  int i, j, k, rc;
  SrcList *pTabList;
  ExprList *pEList;
  SrcItem *pFrom;
  
// ABS Label 2803
if(pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2803);
}
sqlite3 *db = pParse->db;
  Expr *pE, *pRight, *pExpr;
  u16 selFlags = p->selFlags;
  u32 elistFlags = 0;

  p->selFlags |= SF_Expanded;
  
// ABS Label 2808
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2808);
}
if( db->mallocFailed  ){
    return WRC_Abort;
  }
  assert( p->pSrc!=0 );
  
// ROR Label 2809
if(((selFlags & 64) == 0) != ((selFlags & 64) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2809);
}
if( (selFlags & SF_Expanded)!=0 ){
    return WRC_Prune;
  }
  
// ABS Label 2810
if(pWalker->eCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2810);
}
if( pWalker->eCode ){
    /* Renumber selId because it has been copied from a view */
    p->selId = ++pParse->nSelect;
  }
  pTabList = p->pSrc;
  pEList = p->pEList;
  
// ABS Label 2811
if(pParse->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2811);
}

// COR Label 2812
if((pParse->pWith || (p->selFlags & 2097152)) != (pParse->pWith && (p->selFlags & 2097152)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2812);
}

// MCC Label 2813
if(pParse->pWith && ( p->selFlags & 2097152 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2813);
}
// MCC Label 2814
if(pParse->pWith && ( !(p->selFlags & 2097152) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2814);
}
// MCC Label 2815
if(!(pParse->pWith) && ( p->selFlags & 2097152 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2815);
}
// MCC Label 2816
if(!(pParse->pWith) && ( !(p->selFlags & 2097152) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2816);
}
if( pParse->pWith && (p->selFlags & SF_View) ){
    
// ABS Label 2817
if(p->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2817);
}

// ROR Label 2818
if((p->pWith != 0) != (p->pWith == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2818);
}
if( p->pWith==0 ){
      p->pWith = (With*)sqlite3DbMallocZero(db, sizeof(With));
      
// ABS Label 2819
if(p->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2819);
}

// ROR Label 2820
if((p->pWith != 0) != (p->pWith == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2820);
}
if( p->pWith==0 ){
        return WRC_Abort;
      }
    }
    p->pWith->bView = 1;
  }
  
// ABS Label 2804
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2804);
}

// ABS Label 2805
if(p->pWith < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2805);
}
sqlite3WithPush(pParse, p->pWith, 0);

  /* Make sure cursor numbers have been assigned to all entries in
  ** the FROM clause of the SELECT statement.
  */
  
// ABS Label 2806
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2806);
}

// ABS Label 2807
if(pTabList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2807);
}
sqlite3SrcListAssignCursors(pParse, pTabList);

  /* Look up every table named in the FROM clause of the select.  If
  ** an entry of the FROM clause is a subquery instead of a table or view,
  ** then create a transient table structure to describe the subquery.
  */
  i = 0 , pFrom = pTabList->a;

// ABS Label 2821
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2821);
}
// ABS Label 2822
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2822);
}

// ROR Label 2823
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2823);
}
// ROR Label 2824
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2824);
}
// ROR Label 2825
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2825);
}
for(; i<pTabList->nSrc; i++, pFrom++){
    Table *pTab;
    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );
    
// ABS Label 2831
if(pFrom->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2831);
}
if( pFrom->pTab ) { continue;
}
    assert( pFrom->fg.isRecursive==0 );
    
// ABS Label 2832
if(pFrom->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2832);
}

// ROR Label 2833
if((pFrom->zName != 0) != (pFrom->zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2833);
}
if( pFrom->zName==0 ){
#ifndef SQLITE_OMIT_SUBQUERY
      
// ABS Label 2834
if(pFrom->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2834);
}
Select *pSel = pFrom->pSelect;
      /* A sub-query in the FROM clause of a SELECT */
      assert( pSel!=0 );
      assert( pFrom->pTab==0 );
      if( sqlite3WalkSelect(pWalker, pSel) ) { return WRC_Abort;
}
      if( sqlite3ExpandSubquery(pParse, pFrom) ) { return WRC_Abort;
}
#endif
#ifndef SQLITE_OMIT_CTE
    }else { if( (rc = resolveFromTermToCte(pParse, pWalker, pFrom))!=0 ){
      
// ABS Label 2835
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2835);
}

// ROR Label 2836
if((rc <= 1) != (rc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2836);
}
// ROR Label 2837
if((rc < 1) != (rc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2837);
}
// ROR Label 2838
if((rc >= 1) != (rc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2838);
}
if( rc>1 ) { return WRC_Abort;
}
      pTab = pFrom->pTab;
      assert( pTab!=0 );
#endif
    }else{
      /* An ordinary table or view name in the FROM clause */
      assert( pFrom->pTab==0 );
      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);
      
// ABS Label 2839
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2839);
}

// ROR Label 2840
if((pTab != 0) != (pTab == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2840);
}
if( pTab==0 ) { return WRC_Abort;
}
      
// ABS Label 2841
if(pTab->nTabRef < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2841);
}

// ROR Label 2842
if((pTab->nTabRef < 65535) != (pTab->nTabRef >= 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2842);
}
// ROR Label 2843
if((pTab->nTabRef > 65535) != (pTab->nTabRef >= 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2843);
}
// ROR Label 2844
if((pTab->nTabRef <= 65535) != (pTab->nTabRef >= 65535))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2844);
}
if( pTab->nTabRef>=0xffff ){
        
// ABS Label 2845
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2845);
}

// ABS Label 2846
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2846);
}
sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535",
           pTab->zName);
        pFrom->pTab = 0;
        return WRC_Abort;
      }
      pTab->nTabRef++;
      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){
        return WRC_Abort;
      }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
      
// ABS Label 2847
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2847);
}
// ABS Label 2848
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2848);
}

// COR Label 2849
if((((pTab)->nModuleArg) && pTab->pSelect) != (((pTab)->nModuleArg) || pTab->pSelect))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2849);
}

// MCC Label 2850
if(((pTab)->nModuleArg) && pTab->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2850);
}
// MCC Label 2851
if(((pTab)->nModuleArg) && !(pTab->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2851);
}
// MCC Label 2852
if(!(((pTab)->nModuleArg)) && pTab->pSelect ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2852);
}
// MCC Label 2853
if(!(((pTab)->nModuleArg)) && !(pTab->pSelect) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2853);
}
if( IsVirtual(pTab) || pTab->pSelect ){
        i16 nCol;
        u8 eCodeOrig = pWalker->eCode;
        if( sqlite3ViewGetColumnNames(pParse, pTab) ) { return WRC_Abort;
}
        assert( pFrom->pSelect==0 );
        
// ABS Label 2856
if(db->aDb[1].pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2856);
}
// ABS Label 2857
if(pTab->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2857);
}
// ABS Label 2858
if(pTab->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2858);
}

// COR Label 2859
if((pTab->pSelect && (db->flags & 2147483648U) == 0 || pTab->pSchema != db->aDb[1].pSchema) != (pTab->pSelect && (db->flags & 2147483648U) == 0 && pTab->pSchema != db->aDb[1].pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2859);
}
// COR Label 2860
if((pTab->pSelect || (db->flags & 2147483648U) == 0) != (pTab->pSelect && (db->flags & 2147483648U) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2860);
}

// ROR Label 2861
if(((db->flags & 2147483648U) != 0) != ((db->flags & 2147483648U) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2861);
}
// ROR Label 2862
if((pTab->pSchema == db->aDb[1].pSchema) != (pTab->pSchema != db->aDb[1].pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2862);
}

// MCC Label 2863
if(pTab->pSelect && (db->flags & 2147483648U) == 0 && pTab->pSchema != db->aDb[1].pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2863);
}
// MCC Label 2864
if(pTab->pSelect && (db->flags & 2147483648U) == 0 && !(pTab->pSchema != db->aDb[1].pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2864);
}
// MCC Label 2865
if(pTab->pSelect && !((db->flags & 2147483648U) == 0) && pTab->pSchema != db->aDb[1].pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2865);
}
// MCC Label 2866
if(pTab->pSelect && !((db->flags & 2147483648U) == 0) && !(pTab->pSchema != db->aDb[1].pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2866);
}
// MCC Label 2867
if(!(pTab->pSelect) && (db->flags & 2147483648U) == 0 && pTab->pSchema != db->aDb[1].pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2867);
}
// MCC Label 2868
if(!(pTab->pSelect) && (db->flags & 2147483648U) == 0 && !(pTab->pSchema != db->aDb[1].pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2868);
}
// MCC Label 2869
if(!(pTab->pSelect) && !((db->flags & 2147483648U) == 0) && pTab->pSchema != db->aDb[1].pSchema ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2869);
}
// MCC Label 2870
if(!(pTab->pSelect) && !((db->flags & 2147483648U) == 0) && !(pTab->pSchema != db->aDb[1].pSchema) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2870);
}
if( pTab->pSelect
         && (db->flags & SQLITE_EnableView)==0
         && pTab->pSchema!=db->aDb[1].pSchema
        ){
          
// ABS Label 2871
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2871);
}

// ABS Label 2872
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2872);
}
sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited",
            pTab->zName);
        }
#ifndef SQLITE_OMIT_VIRTUALTABLE
        assert( SQLITE_VTABRISK_Normal==1 && SQLITE_VTABRISK_High==2 );
        
// ABS Label 2873
if(((pTab)->nModuleArg) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2873);
}

// COR Label 2874
if((((pTab)->nModuleArg) && pFrom->fg.fromDDL && (pTab->pVTable != 0) || pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) != (((pTab)->nModuleArg) && pFrom->fg.fromDDL && (pTab->pVTable != 0) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2874);
}
// COR Label 2875
if((((pTab)->nModuleArg) && pFrom->fg.fromDDL || (pTab->pVTable != 0)) != (((pTab)->nModuleArg) && pFrom->fg.fromDDL && (pTab->pVTable != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2875);
}
// COR Label 2876
if((((pTab)->nModuleArg) || pFrom->fg.fromDDL) != (((pTab)->nModuleArg) && pFrom->fg.fromDDL))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2876);
}

// ROR Label 2877
if((pTab->pVTable->eVtabRisk <= ((db->flags & 128) != 0)) != (pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2877);
}
// ROR Label 2878
if((pTab->pVTable->eVtabRisk < ((db->flags & 128) != 0)) != (pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2878);
}
// ROR Label 2879
if((pTab->pVTable->eVtabRisk >= ((db->flags & 128) != 0)) != (pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2879);
}

// MCC Label 2880
if(((pTab)->nModuleArg) && pFrom->fg.fromDDL && ( pTab->pVTable != 0 ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2880);
}
// MCC Label 2881
if(((pTab)->nModuleArg) && pFrom->fg.fromDDL && ( pTab->pVTable != 0 ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2881);
}
// MCC Label 2882
if(((pTab)->nModuleArg) && pFrom->fg.fromDDL && ( !(pTab->pVTable != 0) ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2882);
}
// MCC Label 2883
if(((pTab)->nModuleArg) && pFrom->fg.fromDDL && ( !(pTab->pVTable != 0) ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2883);
}
// MCC Label 2884
if(((pTab)->nModuleArg) && !(pFrom->fg.fromDDL) && ( pTab->pVTable != 0 ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2884);
}
// MCC Label 2885
if(((pTab)->nModuleArg) && !(pFrom->fg.fromDDL) && ( pTab->pVTable != 0 ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2885);
}
// MCC Label 2886
if(((pTab)->nModuleArg) && !(pFrom->fg.fromDDL) && ( !(pTab->pVTable != 0) ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2886);
}
// MCC Label 2887
if(((pTab)->nModuleArg) && !(pFrom->fg.fromDDL) && ( !(pTab->pVTable != 0) ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2887);
}
// MCC Label 2888
if(!(((pTab)->nModuleArg)) && pFrom->fg.fromDDL && ( pTab->pVTable != 0 ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2888);
}
// MCC Label 2889
if(!(((pTab)->nModuleArg)) && pFrom->fg.fromDDL && ( pTab->pVTable != 0 ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2889);
}
// MCC Label 2890
if(!(((pTab)->nModuleArg)) && pFrom->fg.fromDDL && ( !(pTab->pVTable != 0) ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2890);
}
// MCC Label 2891
if(!(((pTab)->nModuleArg)) && pFrom->fg.fromDDL && ( !(pTab->pVTable != 0) ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2891);
}
// MCC Label 2892
if(!(((pTab)->nModuleArg)) && !(pFrom->fg.fromDDL) && ( pTab->pVTable != 0 ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2892);
}
// MCC Label 2893
if(!(((pTab)->nModuleArg)) && !(pFrom->fg.fromDDL) && ( pTab->pVTable != 0 ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2893);
}
// MCC Label 2894
if(!(((pTab)->nModuleArg)) && !(pFrom->fg.fromDDL) && ( !(pTab->pVTable != 0) ) && pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2894);
}
// MCC Label 2895
if(!(((pTab)->nModuleArg)) && !(pFrom->fg.fromDDL) && ( !(pTab->pVTable != 0) ) && !(pTab->pVTable->eVtabRisk > ((db->flags & 128) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2895);
}
if( IsVirtual(pTab)
         && pFrom->fg.fromDDL
         && ALWAYS(pTab->pVTable!=0)
         && pTab->pVTable->eVtabRisk > ((db->flags & SQLITE_TrustedSchema)!=0)
        ){
          
// ABS Label 2896
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2896);
}

// ABS Label 2897
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2897);
}
sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"",
                                  pTab->zName);
        }
#endif
        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
        nCol = pTab->nCol;
        pTab->nCol = -1;
        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */
        
// ABS Label 2854
if(pWalker < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2854);
}

// ABS Label 2855
if(pFrom->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2855);
}
sqlite3WalkSelect(pWalker, pFrom->pSelect);
        pWalker->eCode = eCodeOrig;
        pTab->nCol = nCol;
      }
#endif
    };}


    /* Locate the index named by the INDEXED BY clause, if any. */
    if( pFrom->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pFrom) ){
      return WRC_Abort;
    }
  };
// ABS Label 2826
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2826);
}
// ABS Label 2827
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2827);
}

// ROR Label 2828
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2828);
}
// ROR Label 2829
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2829);
}
// ROR Label 2830
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2830);
}


  /* Process NATURAL keywords, and ON and USING clauses of joins.
  */
  if(
#ifdef MAGMA_ENABLE_FIXES
     pParse->nErr ||
#endif
     db->mallocFailed || sqliteProcessJoin(pParse, p) ){
      return WRC_Abort;
  }
#ifdef MAGMA_ENABLE_CANARIES
  MAGMA_LOG("SQL002", pParse->nErr);
#endif

  /* For every "*" that occurs in the column list, insert the names of
  ** all columns in all tables.  And for every TABLE.* insert the names
  ** of all columns in TABLE.  The parser inserted a special expression
  ** with the TK_ASTERISK operator for each "*" that it found in the column
  ** list.  The following code just has to locate the TK_ASTERISK
  ** expressions and expand each one to the list of all columns in
  ** all tables.
  **
  ** The first loop just checks to see if there are any "*" operators
  ** that need expanding.
  */
  k = 0;

// ABS Label 2898
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2898);
}
// ABS Label 2899
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2899);
}

// ROR Label 2900
if((k <= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2900);
}
// ROR Label 2901
if((k > pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2901);
}
// ROR Label 2902
if((k >= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2902);
}
for(; k<pEList->nExpr; k++){
    pE = pEList->a[k].pExpr;
    
// ROR Label 2908
if((pE->op != 179) != (pE->op == 179))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2908);
}
if( pE->op==TK_ASTERISK ) { break;
}
    assert( pE->op!=TK_DOT || pE->pRight!=0 );
    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );
    
// COR Label 2909
if((pE->op == 140 || pE->pRight->op == 179) != (pE->op == 140 && pE->pRight->op == 179))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2909);
}

// ROR Label 2910
if((pE->op != 140) != (pE->op == 140))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2910);
}
// ROR Label 2911
if((pE->pRight->op != 179) != (pE->pRight->op == 179))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2911);
}

// MCC Label 2912
if(pE->op == 140 && pE->pRight->op == 179 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2912);
}
// MCC Label 2913
if(pE->op == 140 && !(pE->pRight->op == 179) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2913);
}
// MCC Label 2914
if(!(pE->op == 140) && pE->pRight->op == 179 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2914);
}
// MCC Label 2915
if(!(pE->op == 140) && !(pE->pRight->op == 179) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2915);
}
if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) { break;
}
    elistFlags |= pE->flags;
  };
// ABS Label 2903
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2903);
}
// ABS Label 2904
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2904);
}

// ROR Label 2905
if((k <= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2905);
}
// ROR Label 2906
if((k > pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2906);
}
// ROR Label 2907
if((k >= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2907);
}

  
// ABS Label 2916
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2916);
}
// ABS Label 2917
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2917);
}

// ROR Label 2918
if((k <= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2918);
}
// ROR Label 2919
if((k > pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2919);
}
// ROR Label 2920
if((k >= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2920);
}
if( k<pEList->nExpr ){
    /*
    ** If we get here it means the result set contains one or more "*"
    ** operators that need to be expanded.  Loop through each expression
    ** in the result set and expand them one by one.
    */
    struct ExprList_item *a = pEList->a;
    ExprList *pNew = 0;
    int flags = pParse->db->flags;
    
// COR Label 2921
if(((flags & 4) != 0 || (flags & 64) == 0) != ((flags & 4) != 0 && (flags & 64) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2921);
}

// ROR Label 2922
if(((flags & 4) == 0) != ((flags & 4) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2922);
}
// ROR Label 2923
if(((flags & 64) != 0) != ((flags & 64) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2923);
}
int longNames = (flags & SQLITE_FullColNames)!=0
                      && (flags & SQLITE_ShortColNames)==0;

    k = 0;

// ABS Label 2926
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2926);
}
// ABS Label 2927
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2927);
}

// ROR Label 2928
if((k <= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2928);
}
// ROR Label 2929
if((k > pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2929);
}
// ROR Label 2930
if((k >= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2930);
}
for(; k<pEList->nExpr; k++){
      pE = a[k].pExpr;
      elistFlags |= pE->flags;
      pRight = pE->pRight;
      assert( pE->op!=TK_DOT || pRight!=0 );
      
// COR Label 2936
if((pE->op != 179 || (pE->op != 140 || pRight->op != 179)) != (pE->op != 179 && (pE->op != 140 || pRight->op != 179)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2936);
}

// ROR Label 2937
if((pE->op == 179) != (pE->op != 179))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2937);
}

// MCC Label 2938
if(pE->op != 179 && ( pE->op != 140 && pRight->op != 179 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2938);
}
// MCC Label 2939
if(pE->op != 179 && ( pE->op != 140 && !(pRight->op != 179) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2939);
}
// MCC Label 2940
if(pE->op != 179 && ( !(pE->op != 140) && pRight->op != 179 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2940);
}
// MCC Label 2941
if(pE->op != 179 && ( !(pE->op != 140) && !(pRight->op != 179) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2941);
}
// MCC Label 2942
if(!(pE->op != 179) && ( pE->op != 140 && pRight->op != 179 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2942);
}
// MCC Label 2943
if(!(pE->op != 179) && ( pE->op != 140 && !(pRight->op != 179) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2943);
}
// MCC Label 2944
if(!(pE->op != 179) && ( !(pE->op != 140) && pRight->op != 179 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2944);
}
// MCC Label 2945
if(!(pE->op != 179) && ( !(pE->op != 140) && !(pRight->op != 179) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2945);
}
if( pE->op!=TK_ASTERISK
       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)
      ){
        /* This particular expression does not need to be expanded.
        */
        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
        
// ABS Label 2946
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2946);
}
if( pNew ){
          pNew->a[pNew->nExpr-1].zEName = a[k].zEName;
          pNew->a[pNew->nExpr-1].eEName = a[k].eEName;
          a[k].zEName = 0;
        }
        a[k].pExpr = 0;
      }else{
        /* This expression is a "*" or a "TABLE.*" and needs to be
        ** expanded. */
        int tableSeen = 0;      /* Set to 1 when TABLE matches */
        char *zTName = 0;       /* text of name of TABLE */
        
// ROR Label 2947
if((pE->op != 140) != (pE->op == 140))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2947);
}
if( pE->op==TK_DOT ){
          assert( pE->pLeft!=0 );
          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );
          zTName = pE->pLeft->u.zToken;
        }
        i = 0 , pFrom = pTabList->a;

// ABS Label 2948
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2948);
}
// ABS Label 2949
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2949);
}

// ROR Label 2950
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2950);
}
// ROR Label 2951
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2951);
}
// ROR Label 2952
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2952);
}
for(; i<pTabList->nSrc; i++, pFrom++){
          
// ABS Label 2958
if(pFrom->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2958);
}
Table *pTab = pFrom->pTab;
          
// ABS Label 2959
if(pFrom->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2959);
}
Select *pSub = pFrom->pSelect;
          
// ABS Label 2960
if(pFrom->zAlias < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2960);
}
char *zTabName = pFrom->zAlias;
          const char *zSchemaName = 0;
          int iDb;
          
// ABS Label 2961
if(zTabName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2961);
}

// ROR Label 2962
if((zTabName != 0) != (zTabName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2962);
}
if( zTabName==0 ){
            zTabName = pTab->zName;
          }
          
// ABS Label 2963
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2963);
}
if( db->mallocFailed ) { break;
}
          
// ABS Label 2964
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2964);
}

// COR Label 2965
if((pSub == 0 && (pSub->selFlags & 2048) == 0) != (pSub == 0 || (pSub->selFlags & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2965);
}

// ROR Label 2966
if((pSub != 0) != (pSub == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2966);
}
// ROR Label 2967
if(((pSub->selFlags & 2048) != 0) != ((pSub->selFlags & 2048) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2967);
}

// MCC Label 2968
if(pSub == 0 && (pSub->selFlags & 2048) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2968);
}
// MCC Label 2969
if(pSub == 0 && !((pSub->selFlags & 2048) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2969);
}
// MCC Label 2970
if(!(pSub == 0) && (pSub->selFlags & 2048) == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2970);
}
// MCC Label 2971
if(!(pSub == 0) && !((pSub->selFlags & 2048) == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2971);
}
if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){
            pSub = 0;
            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){
              continue;
            }
            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : "*";
          }
          j = 0;

// ABS Label 2972
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2972);
}

// ROR Label 2973
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2973);
}
// ROR Label 2974
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2974);
}
// ROR Label 2975
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2975);
}
for(; j<pTab->nCol; j++){
            
// ABS Label 2980
if(pTab->aCol[j].zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2980);
}
char *zName = pTab->aCol[j].zName;
            char *zColname;  /* The computed column name */
            char *zToFree;   /* Malloced string that needs to be freed */
            Token sColname;  /* Computed column name as a token */

            assert( zName );
            if( zTName && pSub
             && sqlite3MatchEName(&pSub->pEList->a[j], 0, zTName, 0)==0
            ){
              continue;
            }

            /* If a column is marked as 'hidden', omit it from the expanded
            ** result-set list unless the SELECT has the SF_IncludeHidden
            ** bit set.
            */
            
// COR Label 2985
if(((p->selFlags & 131072) == 0 || (((&pTab->aCol[j])->colFlags & 2) != 0)) != ((p->selFlags & 131072) == 0 && (((&pTab->aCol[j])->colFlags & 2) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2985);
}

// ROR Label 2986
if(((p->selFlags & 131072) != 0) != ((p->selFlags & 131072) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2986);
}

// MCC Label 2987
if((p->selFlags & 131072) == 0 && ( ((&pTab->aCol[j])->colFlags & 2) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2987);
}
// MCC Label 2988
if((p->selFlags & 131072) == 0 && ( !(((&pTab->aCol[j])->colFlags & 2) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2988);
}
// MCC Label 2989
if(!((p->selFlags & 131072) == 0) && ( ((&pTab->aCol[j])->colFlags & 2) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2989);
}
// MCC Label 2990
if(!((p->selFlags & 131072) == 0) && ( !(((&pTab->aCol[j])->colFlags & 2) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2990);
}
if( (p->selFlags & SF_IncludeHidden)==0
             && IsHiddenColumn(&pTab->aCol[j]) 
            ){
              continue;
            }
            tableSeen = 1;

            
// ABS Label 2991
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2991);
}
// ABS Label 2992
if(zTName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2992);
}

// COR Label 2993
if((i > 0 || zTName == 0) != (i > 0 && zTName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 2993);
}

// ROR Label 2994
if((i <= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2994);
}
// ROR Label 2995
if((i < 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2995);
}
// ROR Label 2996
if((i >= 0) != (i > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2996);
}
// ROR Label 2997
if((zTName != 0) != (zTName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2997);
}

// MCC Label 2998
if(i > 0 && zTName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2998);
}
// MCC Label 2999
if(i > 0 && !(zTName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 2999);
}
// MCC Label 3000
if(!(i > 0) && zTName == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3000);
}
// MCC Label 3001
if(!(i > 0) && !(zTName == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3001);
}
if( i>0 && zTName==0 ){
              if( (pFrom->fg.jointype & JT_NATURAL)!=0
                && tableAndColumnIndex(pTabList, i, zName, 0, 0, 1)
              ){
                /* In a NATURAL join, omit the join columns from the 
                ** table to the right of the join */
                continue;
              }
              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){
                /* In a join with a USING clause, omit columns in the
                ** using clause from the table on the right. */
                continue;
              }
            }
            pRight = sqlite3Expr(db, TK_ID, zName);
            zColname = zName;
            zToFree = 0;
            
// ABS Label 3002
if(longNames < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3002);
}
// ABS Label 3003
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3003);
}

// COR Label 3004
if((longNames && pTabList->nSrc > 1) != (longNames || pTabList->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3004);
}

// ROR Label 3005
if((pTabList->nSrc <= 1) != (pTabList->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3005);
}
// ROR Label 3006
if((pTabList->nSrc < 1) != (pTabList->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3006);
}
// ROR Label 3007
if((pTabList->nSrc >= 1) != (pTabList->nSrc > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3007);
}

// MCC Label 3008
if(longNames && pTabList->nSrc > 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3008);
}
// MCC Label 3009
if(longNames && !(pTabList->nSrc > 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3009);
}
// MCC Label 3010
if(!(longNames) && pTabList->nSrc > 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3010);
}
// MCC Label 3011
if(!(longNames) && !(pTabList->nSrc > 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3011);
}
if( longNames || pTabList->nSrc>1 ){
              Expr *pLeft;
              pLeft = sqlite3Expr(db, TK_ID, zTabName);
              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);
              
// ABS Label 3012
if(zSchemaName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3012);
}
if( zSchemaName ){
                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);
                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);
              }
              
// ABS Label 3013
if(longNames < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3013);
}
if( longNames ){
                zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
                zToFree = zColname;
              }
            }else{
              pExpr = pRight;
            }
            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
            
// ABS Label 2981
if(zColname < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2981);
}
sqlite3TokenInit(&sColname, zColname);
            
// ABS Label 2982
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2982);
}

// ABS Label 2983
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2983);
}
sqlite3ExprListSetName(pParse, pNew, &sColname, 0);
            
// ABS Label 3014
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3014);
}

// COR Label 3015
if((pNew && (p->selFlags & 2048) != 0 || !(pParse->eParseMode >= 2)) != (pNew && (p->selFlags & 2048) != 0 && !(pParse->eParseMode >= 2)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3015);
}
// COR Label 3016
if((pNew || (p->selFlags & 2048) != 0) != (pNew && (p->selFlags & 2048) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3016);
}

// ROR Label 3017
if(((p->selFlags & 2048) == 0) != ((p->selFlags & 2048) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3017);
}

// MCC Label 3018
if(pNew && (p->selFlags & 2048) != 0 && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3018);
}
// MCC Label 3019
if(pNew && (p->selFlags & 2048) != 0 && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3019);
}
// MCC Label 3020
if(pNew && !((p->selFlags & 2048) != 0) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3020);
}
// MCC Label 3021
if(pNew && !((p->selFlags & 2048) != 0) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3021);
}
// MCC Label 3022
if(!(pNew) && (p->selFlags & 2048) != 0 && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3022);
}
// MCC Label 3023
if(!(pNew) && (p->selFlags & 2048) != 0 && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3023);
}
// MCC Label 3024
if(!(pNew) && !((p->selFlags & 2048) != 0) && !(pParse->eParseMode >= 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3024);
}
// MCC Label 3025
if(!(pNew) && !((p->selFlags & 2048) != 0) && !(!(pParse->eParseMode >= 2)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3025);
}
if( pNew && (p->selFlags & SF_NestedFrom)!=0 && !IN_RENAME_OBJECT ){
              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];
              
// ABS Label 3026
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3026);
}
sqlite3DbFree(db, pX->zEName);
              
// ABS Label 3027
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3027);
}
if( pSub ){
                pX->zEName = sqlite3DbStrDup(db, pSub->pEList->a[j].zEName);
                testcase( pX->zEName==0 );
              }else{
                pX->zEName = sqlite3MPrintf(db, "%s.%s.%s",
                                           zSchemaName, zTabName, zColname);
                testcase( pX->zEName==0 );
              }
              pX->eEName = ENAME_TAB;
            }
            
// ABS Label 2984
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2984);
}
sqlite3DbFree(db, zToFree);
          };
// ABS Label 2976
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2976);
}

// ROR Label 2977
if((j <= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2977);
}
// ROR Label 2978
if((j > pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2978);
}
// ROR Label 2979
if((j >= pTab->nCol) != (j < pTab->nCol))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2979);
}

        };
// ABS Label 2953
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2953);
}
// ABS Label 2954
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2954);
}

// ROR Label 2955
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2955);
}
// ROR Label 2956
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2956);
}
// ROR Label 2957
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2957);
}

        if( !tableSeen ){
          
// ABS Label 3028
if(zTName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3028);
}
if( zTName ){
            
// ABS Label 3029
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3029);
}

// ABS Label 3030
if(zTName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3030);
}
sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
          }else{
            
// ABS Label 3031
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3031);
}
sqlite3ErrorMsg(pParse, "no tables specified");
          }
        }
      }
    };
// ABS Label 2931
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2931);
}
// ABS Label 2932
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2932);
}

// ROR Label 2933
if((k <= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2933);
}
// ROR Label 2934
if((k > pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2934);
}
// ROR Label 2935
if((k >= pEList->nExpr) != (k < pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 2935);
}

    
// ABS Label 2924
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2924);
}

// ABS Label 2925
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 2925);
}
sqlite3ExprListDelete(db, pEList);
    p->pEList = pNew;
  }
  
// ABS Label 3032
if(p->pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3032);
}
if( p->pEList ){
    
// ABS Label 3033
if(db->aLimit[2] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3033);
}
// ABS Label 3034
if(p->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3034);
}

// ROR Label 3035
if((p->pEList->nExpr <= db->aLimit[2]) != (p->pEList->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3035);
}
// ROR Label 3036
if((p->pEList->nExpr < db->aLimit[2]) != (p->pEList->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3036);
}
// ROR Label 3037
if((p->pEList->nExpr >= db->aLimit[2]) != (p->pEList->nExpr > db->aLimit[2]))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3037);
}
if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){
      
// ABS Label 3038
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3038);
}
sqlite3ErrorMsg(pParse, "too many columns in result set");
      return WRC_Abort;
    }
    
// ROR Label 3039
if(((elistFlags & (4 | 2097152)) == 0) != ((elistFlags & (4 | 2097152)) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3039);
}
if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){
      p->selFlags |= SF_ComplexResult;
    }
  }
  return WRC_Continue;
}

#if SQLITE_DEBUG
/*
** Always assert.  This xSelectCallback2 implementation proves that the
** xSelectCallback2 is never invoked.
*/
void sqlite3SelectWalkAssert2(Walker *NotUsed, Select *NotUsed2){
  UNUSED_PARAMETER2(NotUsed, NotUsed2);
  assert( 0 );
}
#endif
/*
** This routine "expands" a SELECT statement and all of its subqueries.
** For additional information on what it means to "expand" a SELECT
** statement, see the comment on the selectExpand worker callback above.
**
** Expanding a SELECT statement is the first step in processing a
** SELECT statement.  The SELECT statement must be expanded before
** name resolution is performed.
**
** If anything goes wrong, an error message is written into pParse.
** The calling function can detect the problem by looking at pParse->nErr
** and/or pParse->db->mallocFailed.
*/
static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){
  Walker w;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.pParse = pParse;
  
// ABS Label 3041
if((pParse->hasCompound) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3041);
}
if( OK_IF_ALWAYS_TRUE(pParse->hasCompound) ){
    w.xSelectCallback = convertCompoundSelectToSubquery;
    w.xSelectCallback2 = 0;
    
// ABS Label 3042
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3042);
}
sqlite3WalkSelect(&w, pSelect);
  }
  w.xSelectCallback = selectExpander;
  w.xSelectCallback2 = sqlite3SelectPopWith;
  w.eCode = 0;
  
// ABS Label 3040
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3040);
}
sqlite3WalkSelect(&w, pSelect);
}


#ifndef SQLITE_OMIT_SUBQUERY
/*
** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()
** interface.
**
** For each FROM-clause subquery, add Column.zType and Column.zColl
** information to the Table structure that represents the result set
** of that subquery.
**
** The Table structure that represents the result set was constructed
** by selectExpander() but the type and collation information was omitted
** at that point because identifiers had not yet been resolved.  This
** routine is called after identifier resolution.
*/
static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
  Parse *pParse;
  int i;
  SrcList *pTabList;
  SrcItem *pFrom;

  assert( p->selFlags & SF_Resolved );
  
// ABS Label 3043
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3043);
}

// AOR Label 3044
if(p->selFlags | 128 != p->selFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3044);
}
// AOR Label 3045
if(p->selFlags ^ 128 != p->selFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3045);
}
if( p->selFlags & SF_HasTypeInfo ) { return;
}
  p->selFlags |= SF_HasTypeInfo;
  pParse = pWalker->pParse;
  pTabList = p->pSrc;
  i = 0 , pFrom = pTabList->a;

// ABS Label 3046
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3046);
}
// ABS Label 3047
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3047);
}

// ROR Label 3048
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3048);
}
// ROR Label 3049
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3049);
}
// ROR Label 3050
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3050);
}
for(; i<pTabList->nSrc; i++, pFrom++){
    
// ABS Label 3056
if(pFrom->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3056);
}
Table *pTab = pFrom->pTab;
    assert( pTab!=0 );
    
// ROR Label 3057
if(((pTab->tabFlags & 16384) == 0) != ((pTab->tabFlags & 16384) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3057);
}
if( (pTab->tabFlags & TF_Ephemeral)!=0 ){
      /* A sub-query in the FROM clause of a SELECT */
      
// ABS Label 3058
if(pFrom->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3058);
}
Select *pSel = pFrom->pSelect;
      
// ABS Label 3059
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3059);
}
if( pSel ){
        
// ABS Label 3063
if(pSel->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3063);
}
while( pSel->pPrior ) { pSel = pSel->pPrior;
};
// ABS Label 3064
if(pSel->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3064);
}

        
// ABS Label 3060
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3060);
}

// ABS Label 3061
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3061);
}

// ABS Label 3062
if(pSel < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3062);
}
sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,
                                               SQLITE_AFF_NONE);
      }
    }
  };
// ABS Label 3051
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3051);
}
// ABS Label 3052
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3052);
}

// ROR Label 3053
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3053);
}
// ROR Label 3054
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3054);
}
// ROR Label 3055
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3055);
}

}
#endif


/*
** This routine adds datatype and collating sequence information to
** the Table structures of all FROM-clause subqueries in a
** SELECT statement.
**
** Use this routine after name resolution.
*/
static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){
#ifndef SQLITE_OMIT_SUBQUERY
  Walker w;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.xSelectCallback2 = selectAddSubqueryTypeInfo;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.pParse = pParse;
  
// ABS Label 3065
if(pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3065);
}
sqlite3WalkSelect(&w, pSelect);
#endif
}


/*
** This routine sets up a SELECT statement for processing.  The
** following is accomplished:
**
**     *  VDBE Cursor numbers are assigned to all FROM-clause terms.
**     *  Ephemeral Table objects are created for all FROM-clause subqueries.
**     *  ON and USING clauses are shifted into WHERE statements
**     *  Wildcards "*" and "TABLE.*" in result sets are expanded.
**     *  Identifiers in expression are matched to tables.
**
** This routine acts recursively on all subqueries within the SELECT.
*/
void sqlite3SelectPrep(
  Parse *pParse,         /* The parser context */
  Select *p,             /* The SELECT statement being coded. */
  NameContext *pOuterNC  /* Name context for container */
){
  assert( p!=0 || pParse->db->mallocFailed );
  
// ABS Label 3073
if(pParse->db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3073);
}
if( pParse->db->mallocFailed ) { return;
}
  
// ABS Label 3074
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3074);
}

// AOR Label 3075
if(p->selFlags | 128 != p->selFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3075);
}
// AOR Label 3076
if(p->selFlags ^ 128 != p->selFlags & 128)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3076);
}
if( p->selFlags & SF_HasTypeInfo ) { return;
}
  
// ABS Label 3066
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3066);
}

// ABS Label 3067
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3067);
}
sqlite3SelectExpand(pParse, p);
  
// ABS Label 3077
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3077);
}

// COR Label 3078
if((pParse->nErr && pParse->db->mallocFailed) != (pParse->nErr || pParse->db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3078);
}

// MCC Label 3079
if(pParse->nErr && pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3079);
}
// MCC Label 3080
if(pParse->nErr && !(pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3080);
}
// MCC Label 3081
if(!(pParse->nErr) && pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3081);
}
// MCC Label 3082
if(!(pParse->nErr) && !(pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3082);
}
if( pParse->nErr || pParse->db->mallocFailed ) { return;
}
  
// ABS Label 3068
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3068);
}

// ABS Label 3069
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3069);
}

// ABS Label 3070
if(pOuterNC < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3070);
}
sqlite3ResolveSelectNames(pParse, p, pOuterNC);
  
// ABS Label 3083
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3083);
}

// COR Label 3084
if((pParse->nErr && pParse->db->mallocFailed) != (pParse->nErr || pParse->db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3084);
}

// MCC Label 3085
if(pParse->nErr && pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3085);
}
// MCC Label 3086
if(pParse->nErr && !(pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3086);
}
// MCC Label 3087
if(!(pParse->nErr) && pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3087);
}
// MCC Label 3088
if(!(pParse->nErr) && !(pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3088);
}
if( pParse->nErr || pParse->db->mallocFailed ) { return;
}
  
// ABS Label 3071
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3071);
}

// ABS Label 3072
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3072);
}
sqlite3SelectAddTypeInfo(pParse, p);
}

/*
** Reset the aggregate accumulator.
**
** The aggregate accumulator is a set of memory cells that hold
** intermediate results while calculating an aggregate.  This
** routine generates code that stores NULLs in all of those memory
** cells.
*/
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){
  
// ABS Label 3089
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3089);
}
Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pFunc;
  
// ABS Label 3090
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3090);
}
// ABS Label 3091
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3091);
}

// AOR Label 3092
if(pAggInfo->nFunc - pAggInfo->nColumn != pAggInfo->nFunc + pAggInfo->nColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3092);
}
// AOR Label 3093
if(pAggInfo->nFunc / pAggInfo->nColumn != pAggInfo->nFunc + pAggInfo->nColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3093);
}
// AOR Label 3094
if(pAggInfo->nFunc * pAggInfo->nColumn != pAggInfo->nFunc + pAggInfo->nColumn)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3094);
}
int nReg = pAggInfo->nFunc + pAggInfo->nColumn;
  
// ABS Label 3098
if(nReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3098);
}

// ROR Label 3099
if((nReg != 0) != (nReg == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3099);
}
if( nReg==0 ) { return;
}
  
// ABS Label 3100
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3100);
}

// COR Label 3101
if((pParse->nErr && pParse->db->mallocFailed) != (pParse->nErr || pParse->db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3101);
}

// MCC Label 3102
if(pParse->nErr && pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3102);
}
// MCC Label 3103
if(pParse->nErr && !(pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3103);
}
// MCC Label 3104
if(!(pParse->nErr) && pParse->db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3104);
}
// MCC Label 3105
if(!(pParse->nErr) && !(pParse->db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3105);
}
if( pParse->nErr || pParse->db->mallocFailed ) { return;
}
#ifdef SQLITE_DEBUG
  /* Verify that all AggInfo registers are within the range specified by
  ** AggInfo.mnReg..AggInfo.mxReg */
  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );
  for(i=0; i<pAggInfo->nColumn; i++){
    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg
         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );
  }
  for(i=0; i<pAggInfo->nFunc; i++){
    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg
         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );
  }
#endif
  
// ABS Label 3095
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3095);
}

// ABS Label 3096
if(pAggInfo->mnReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3096);
}

// ABS Label 3097
if(pAggInfo->mxReg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3097);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);
  pFunc = pAggInfo->aFunc , i = 0;

// ABS Label 3106
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3106);
}
// ABS Label 3107
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3107);
}

// ROR Label 3108
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3108);
}
// ROR Label 3109
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3109);
}
// ROR Label 3110
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3110);
}
for(; i<pAggInfo->nFunc; i++, pFunc++){
    
// ABS Label 3116
if(pFunc->iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3116);
}

// ROR Label 3117
if((pFunc->iDistinct < 0) != (pFunc->iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3117);
}
// ROR Label 3118
if((pFunc->iDistinct > 0) != (pFunc->iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3118);
}
// ROR Label 3119
if((pFunc->iDistinct <= 0) != (pFunc->iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3119);
}
if( pFunc->iDistinct>=0 ){
      
// ABS Label 3120
if(pFunc->pFExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3120);
}
Expr *pE = pFunc->pFExpr;
      assert( !ExprHasProperty(pE, EP_xIsSelect) );
      
// ABS Label 3121
if(pE->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3121);
}
// ABS Label 3122
if(pE->x.pList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3122);
}

// COR Label 3123
if((pE->x.pList == 0 && pE->x.pList->nExpr != 1) != (pE->x.pList == 0 || pE->x.pList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3123);
}

// ROR Label 3124
if((pE->x.pList != 0) != (pE->x.pList == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3124);
}
// ROR Label 3125
if((pE->x.pList->nExpr == 1) != (pE->x.pList->nExpr != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3125);
}

// MCC Label 3126
if(pE->x.pList == 0 && pE->x.pList->nExpr != 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3126);
}
// MCC Label 3127
if(pE->x.pList == 0 && !(pE->x.pList->nExpr != 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3127);
}
// MCC Label 3128
if(!(pE->x.pList == 0) && pE->x.pList->nExpr != 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3128);
}
// MCC Label 3129
if(!(pE->x.pList == 0) && !(pE->x.pList->nExpr != 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3129);
}
if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){
        
// ABS Label 3130
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3130);
}
sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "
           "argument");
        pFunc->iDistinct = -1;
      }else{
        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);
        pFunc->iDistAddr = sqlite3VdbeAddOp4(v, OP_OpenEphemeral, 
            pFunc->iDistinct, 0, 0, (char*)pKeyInfo, P4_KEYINFO);
        ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s(DISTINCT)",
                          pFunc->pFunc->zName));
      }
    }
  };
// ABS Label 3111
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3111);
}
// ABS Label 3112
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3112);
}

// ROR Label 3113
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3113);
}
// ROR Label 3114
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3114);
}
// ROR Label 3115
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3115);
}

}

/*
** Invoke the OP_AggFinalize opcode for every aggregate function
** in the AggInfo structure.
*/
static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){
  
// ABS Label 3133
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3133);
}
Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pF;
  i = 0 , pF = pAggInfo->aFunc;

// ABS Label 3134
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3134);
}
// ABS Label 3135
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3135);
}

// ROR Label 3136
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3136);
}
// ROR Label 3137
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3137);
}
// ROR Label 3138
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3138);
}
for(; i<pAggInfo->nFunc; i++, pF++){
    
// ABS Label 3144
if(pF->pFExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3144);
}
ExprList *pList = pF->pFExpr->x.pList;
    assert( !ExprHasProperty(pF->pFExpr, EP_xIsSelect) );
    
// ABS Label 3145
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3145);
}

// ABS Label 3146
if(pF->iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3146);
}
sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);
    
// ABS Label 3147
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3147);
}
sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);
  };
// ABS Label 3139
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3139);
}
// ABS Label 3140
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3140);
}

// ROR Label 3141
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3141);
}
// ROR Label 3142
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3142);
}
// ROR Label 3143
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3143);
}

}


/*
** Update the accumulator memory cells for an aggregate based on
** the current cursor position.
**
** If regAcc is non-zero and there are no min() or max() aggregates
** in pAggInfo, then only populate the pAggInfo->nAccumulator accumulator
** registers if register regAcc contains 0. The caller will take care
** of setting and clearing regAcc.
*/
static void updateAccumulator(
  Parse *pParse, 
  int regAcc, 
  AggInfo *pAggInfo,
  int eDistinctType
){
  
// ABS Label 3148
if(pParse->pVdbe < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3148);
}
Vdbe *v = pParse->pVdbe;
  int i;
  int regHit = 0;
  int addrHitTest = 0;
  struct AggInfo_func *pF;
  struct AggInfo_col *pC;

  pAggInfo->directMode = 1;
  i = 0 , pF = pAggInfo->aFunc;

// ABS Label 3149
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3149);
}
// ABS Label 3150
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3150);
}

// ROR Label 3151
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3151);
}
// ROR Label 3152
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3152);
}
// ROR Label 3153
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3153);
}
for(; i<pAggInfo->nFunc; i++, pF++){
    int nArg;
    int addrNext = 0;
    int regAgg;
    
// ABS Label 3159
if(pF->pFExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3159);
}
ExprList *pList = pF->pFExpr->x.pList;
    assert( !ExprHasProperty(pF->pFExpr, EP_xIsSelect) );
    assert( !IsWindowFunc(pF->pFExpr) );
    
// MCC Label 3168
if(( ((pF->pFExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3168);
}
// MCC Label 3169
if(( !(((pF->pFExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3169);
}
if( ExprHasProperty(pF->pFExpr, EP_WinFunc) ){
      
// ABS Label 3170
if(pF->pFExpr->y.pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3170);
}
Expr *pFilter = pF->pFExpr->y.pWin->pFilter;
      
// ABS Label 3174
if(pAggInfo->nAccumulator < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3174);
}
// ABS Label 3175
if(regAcc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3175);
}

// COR Label 3176
if((pAggInfo->nAccumulator && (pF->pFunc->funcFlags & 32) || regAcc) != (pAggInfo->nAccumulator && (pF->pFunc->funcFlags & 32) && regAcc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3176);
}
// COR Label 3177
if((pAggInfo->nAccumulator || (pF->pFunc->funcFlags & 32)) != (pAggInfo->nAccumulator && (pF->pFunc->funcFlags & 32)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3177);
}

// MCC Label 3178
if(pAggInfo->nAccumulator && ( pF->pFunc->funcFlags & 32 ) && regAcc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3178);
}
// MCC Label 3179
if(pAggInfo->nAccumulator && ( pF->pFunc->funcFlags & 32 ) && !(regAcc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3179);
}
// MCC Label 3180
if(pAggInfo->nAccumulator && ( !(pF->pFunc->funcFlags & 32) ) && regAcc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3180);
}
// MCC Label 3181
if(pAggInfo->nAccumulator && ( !(pF->pFunc->funcFlags & 32) ) && !(regAcc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3181);
}
// MCC Label 3182
if(!(pAggInfo->nAccumulator) && ( pF->pFunc->funcFlags & 32 ) && regAcc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3182);
}
// MCC Label 3183
if(!(pAggInfo->nAccumulator) && ( pF->pFunc->funcFlags & 32 ) && !(regAcc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3183);
}
// MCC Label 3184
if(!(pAggInfo->nAccumulator) && ( !(pF->pFunc->funcFlags & 32) ) && regAcc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3184);
}
// MCC Label 3185
if(!(pAggInfo->nAccumulator) && ( !(pF->pFunc->funcFlags & 32) ) && !(regAcc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3185);
}
if( pAggInfo->nAccumulator 
       && (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL) 
       && regAcc
      ){
        /* If regAcc==0, there there exists some min() or max() function
        ** without a FILTER clause that will ensure the magnet registers
        ** are populated. */
        
// ABS Label 3189
if(regHit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3189);
}

// ROR Label 3190
if((regHit != 0) != (regHit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3190);
}
if( regHit==0 ) { regHit = ++pParse->nMem;
}
        /* If this is the first row of the group (regAcc contains 0), clear the
        ** "magnet" register regHit so that the accumulator registers
        ** are populated if the FILTER clause jumps over the the 
        ** invocation of min() or max() altogether. Or, if this is not
        ** the first row (regAcc contains 1), set the magnet register so that
        ** the accumulators are not populated unless the min()/max() is invoked
        ** and indicates that they should be.  */
        
// ABS Label 3186
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3186);
}

// ABS Label 3187
if(regAcc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3187);
}

// ABS Label 3188
if(regHit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3188);
}
sqlite3VdbeAddOp2(v, OP_Copy, regAcc, regHit);
      }
      addrNext = sqlite3VdbeMakeLabel(pParse);
      
// ABS Label 3171
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3171);
}

// ABS Label 3172
if(pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3172);
}

// ABS Label 3173
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3173);
}
sqlite3ExprIfFalse(pParse, pFilter, addrNext, SQLITE_JUMPIFNULL);
    }
    
// ABS Label 3191
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3191);
}
if( pList ){
      nArg = pList->nExpr;
      regAgg = sqlite3GetTempRange(pParse, nArg);
      
// ABS Label 3192
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3192);
}

// ABS Label 3193
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3193);
}

// ABS Label 3194
if(regAgg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3194);
}
sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);
    }else{
      nArg = 0;
      regAgg = 0;
    }
    
// ABS Label 3195
if(pF->iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3195);
}
// ABS Label 3196
if(pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3196);
}

// COR Label 3197
if((pF->iDistinct >= 0 || pList) != (pF->iDistinct >= 0 && pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3197);
}

// ROR Label 3198
if((pF->iDistinct < 0) != (pF->iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3198);
}
// ROR Label 3199
if((pF->iDistinct > 0) != (pF->iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3199);
}
// ROR Label 3200
if((pF->iDistinct <= 0) != (pF->iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3200);
}

// MCC Label 3201
if(pF->iDistinct >= 0 && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3201);
}
// MCC Label 3202
if(pF->iDistinct >= 0 && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3202);
}
// MCC Label 3203
if(!(pF->iDistinct >= 0) && pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3203);
}
// MCC Label 3204
if(!(pF->iDistinct >= 0) && !(pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3204);
}
if( pF->iDistinct>=0 && pList ){
      
// ABS Label 3205
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3205);
}

// ROR Label 3206
if((addrNext != 0) != (addrNext == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3206);
}
if( addrNext==0 ){ 
        addrNext = sqlite3VdbeMakeLabel(pParse);
      }
      pF->iDistinct = codeDistinct(pParse, eDistinctType, 
          pF->iDistinct, addrNext, pList, regAgg);
    }
    
// ABS Label 3207
if(pF->pFunc->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3207);
}

// AOR Label 3208
if(pF->pFunc->funcFlags | 32 != pF->pFunc->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3208);
}
// AOR Label 3209
if(pF->pFunc->funcFlags ^ 32 != pF->pFunc->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3209);
}
if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){
      CollSeq *pColl = 0;
      struct ExprList_item *pItem;
      int j;
      assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */
      j = 0 , pItem = pList->a;

// ABS Label 3212
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3212);
}
// ABS Label 3213
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3213);
}

// COR Label 3214
if((!pColl || j < nArg) != (!pColl && j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3214);
}

// ROR Label 3215
if((j <= nArg) != (j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3215);
}
// ROR Label 3216
if((j > nArg) != (j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3216);
}
// ROR Label 3217
if((j >= nArg) != (j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3217);
}

// MCC Label 3218
if(!pColl && j < nArg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3218);
}
// MCC Label 3219
if(!pColl && !(j < nArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3219);
}
// MCC Label 3220
if(!(!pColl) && j < nArg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3220);
}
// MCC Label 3221
if(!(!pColl) && !(j < nArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3221);
}
for(; !pColl && j<nArg; j++, pItem++){
        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
      };
// ABS Label 3222
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3222);
}
// ABS Label 3223
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3223);
}

// COR Label 3224
if((!pColl || j < nArg) != (!pColl && j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3224);
}

// ROR Label 3225
if((j <= nArg) != (j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3225);
}
// ROR Label 3226
if((j > nArg) != (j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3226);
}
// ROR Label 3227
if((j >= nArg) != (j < nArg))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3227);
}

// MCC Label 3228
if(!pColl && j < nArg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3228);
}
// MCC Label 3229
if(!pColl && !(j < nArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3229);
}
// MCC Label 3230
if(!(!pColl) && j < nArg ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3230);
}
// MCC Label 3231
if(!(!pColl) && !(j < nArg) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3231);
}

      if( !pColl ){
        pColl = pParse->db->pDfltColl;
      }
      
// ABS Label 3232
if(pAggInfo->nAccumulator < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3232);
}
// ABS Label 3233
if(regHit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3233);
}

// COR Label 3234
if((regHit == 0 || pAggInfo->nAccumulator) != (regHit == 0 && pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3234);
}

// ROR Label 3235
if((regHit != 0) != (regHit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3235);
}

// MCC Label 3236
if(regHit == 0 && pAggInfo->nAccumulator ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3236);
}
// MCC Label 3237
if(regHit == 0 && !(pAggInfo->nAccumulator) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3237);
}
// MCC Label 3238
if(!(regHit == 0) && pAggInfo->nAccumulator ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3238);
}
// MCC Label 3239
if(!(regHit == 0) && !(pAggInfo->nAccumulator) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3239);
}
if( regHit==0 && pAggInfo->nAccumulator ) { regHit = ++pParse->nMem;
}
      
// ABS Label 3210
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3210);
}

// ABS Label 3211
if(regHit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3211);
}
sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0, (char *)pColl, P4_COLLSEQ);
    }
    
// ABS Label 3160
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3160);
}

// ABS Label 3161
if(regAgg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3161);
}

// ABS Label 3162
if(pF->iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3162);
}
sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, pF->iMem);
    
// ABS Label 3163
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3163);
}
sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);
    
// ABS Label 3164
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3164);
}
sqlite3VdbeChangeP5(v, (u8)nArg);
    
// ABS Label 3165
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3165);
}

// ABS Label 3166
if(regAgg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3166);
}

// ABS Label 3167
if(nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3167);
}
sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    
// ABS Label 3240
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3240);
}
if( addrNext ){
      
// ABS Label 3241
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3241);
}

// ABS Label 3242
if(addrNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3242);
}
sqlite3VdbeResolveLabel(v, addrNext);
    }
  };
// ABS Label 3154
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3154);
}
// ABS Label 3155
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3155);
}

// ROR Label 3156
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3156);
}
// ROR Label 3157
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3157);
}
// ROR Label 3158
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3158);
}

  
// ABS Label 3243
if(pAggInfo->nAccumulator < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3243);
}
// ABS Label 3244
if(regHit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3244);
}

// COR Label 3245
if((regHit == 0 || pAggInfo->nAccumulator) != (regHit == 0 && pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3245);
}

// ROR Label 3246
if((regHit != 0) != (regHit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3246);
}

// MCC Label 3247
if(regHit == 0 && pAggInfo->nAccumulator ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3247);
}
// MCC Label 3248
if(regHit == 0 && !(pAggInfo->nAccumulator) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3248);
}
// MCC Label 3249
if(!(regHit == 0) && pAggInfo->nAccumulator ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3249);
}
// MCC Label 3250
if(!(regHit == 0) && !(pAggInfo->nAccumulator) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3250);
}
if( regHit==0 && pAggInfo->nAccumulator ){
    regHit = regAcc;
  }
  
// ABS Label 3251
if(regHit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3251);
}
if( regHit ){
    addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);
  }
  i = 0 , pC = pAggInfo->aCol;

// ABS Label 3252
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3252);
}
// ABS Label 3253
if(pAggInfo->nAccumulator < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3253);
}

// ROR Label 3254
if((i <= pAggInfo->nAccumulator) != (i < pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3254);
}
// ROR Label 3255
if((i > pAggInfo->nAccumulator) != (i < pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3255);
}
// ROR Label 3256
if((i >= pAggInfo->nAccumulator) != (i < pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3256);
}
for(; i<pAggInfo->nAccumulator; i++, pC++){
    
// ABS Label 3262
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3262);
}

// ABS Label 3263
if(pC->pCExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3263);
}

// ABS Label 3264
if(pC->iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3264);
}
sqlite3ExprCode(pParse, pC->pCExpr, pC->iMem);
  };
// ABS Label 3257
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3257);
}
// ABS Label 3258
if(pAggInfo->nAccumulator < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3258);
}

// ROR Label 3259
if((i <= pAggInfo->nAccumulator) != (i < pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3259);
}
// ROR Label 3260
if((i > pAggInfo->nAccumulator) != (i < pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3260);
}
// ROR Label 3261
if((i >= pAggInfo->nAccumulator) != (i < pAggInfo->nAccumulator))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3261);
}


  pAggInfo->directMode = 0;
  
// ABS Label 3265
if(addrHitTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3265);
}
if( addrHitTest ){
    
// ABS Label 3266
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3266);
}

// ABS Label 3267
if(addrHitTest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3267);
}
sqlite3VdbeJumpHereOrPopInst(v, addrHitTest);
  }
}

/*
** Add a single OP_Explain instruction to the VDBE to explain a simple
** count(*) query ("SELECT count(*) FROM pTab").
*/
#ifndef SQLITE_OMIT_EXPLAIN
static void explainSimpleCount(
  Parse *pParse,                  /* Parse context */
  Table *pTab,                    /* Table being queried */
  Index *pIdx                     /* Index used to optimize scan, or NULL */
){
  
// ROR Label 3268
if((pParse->explain != 2) != (pParse->explain == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3268);
}
if( pParse->explain==2 ){
    int bCover = (pIdx!=0 && (HasRowid(pTab) || !IsPrimaryKeyIndex(pIdx)));
    
// ABS Label 3269
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3269);
}

// ABS Label 3270
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3270);
}
sqlite3VdbeExplain(pParse, 0, "SCAN %s%s%s",
        pTab->zName,
        bCover ? " USING COVERING INDEX " : "",
        bCover ? pIdx->zName : ""
    );
  }
}
#else
# define explainSimpleCount(a,b,c)
#endif

/*
** sqlite3WalkExpr() callback used by havingToWhere().
**
** If the node passed to the callback is a TK_AND node, return 
** WRC_Continue to tell sqlite3WalkExpr() to iterate through child nodes.
**
** Otherwise, return WRC_Prune. In this case, also check if the 
** sub-expression matches the criteria for being moved to the WHERE
** clause. If so, add it to the WHERE clause and replace the sub-expression
** within the HAVING expression with a constant "1".
*/
static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){
  
// ROR Label 3271
if((pExpr->op == 44) != (pExpr->op != 44))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3271);
}
if( pExpr->op!=TK_AND ){
    
// ABS Label 3272
if(pWalker->u.pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3272);
}
Select *pS = pWalker->u.pSelect;
    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) 
     && ExprAlwaysFalse(pExpr)==0
    ){
      
// ABS Label 3273
if(pWalker->pParse->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3273);
}
sqlite3 *db = pWalker->pParse->db;
      Expr *pNew = sqlite3Expr(db, TK_INTEGER, "1");
      
// ABS Label 3274
if(pNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3274);
}
if( pNew ){
        
// ABS Label 3275
if(pS->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3275);
}
Expr *pWhere = pS->pWhere;
        SWAP(Expr, *pNew, *pExpr);
        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);
        pS->pWhere = pNew;
        pWalker->eCode = 1;
      }
    }
    return WRC_Prune;
  }
  return WRC_Continue;
}

/*
** Transfer eligible terms from the HAVING clause of a query, which is
** processed after grouping, to the WHERE clause, which is processed before
** grouping. For example, the query:
**
**   SELECT * FROM <tables> WHERE a=? GROUP BY b HAVING b=? AND c=?
**
** can be rewritten as:
**
**   SELECT * FROM <tables> WHERE a=? AND b=? GROUP BY b HAVING c=?
**
** A term of the HAVING expression is eligible for transfer if it consists
** entirely of constants and expressions that are also GROUP BY terms that
** use the "BINARY" collation sequence.
*/
static void havingToWhere(Parse *pParse, Select *p){
  Walker sWalker;
  memset(&sWalker, 0, sizeof(sWalker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = havingToWhereExprCb;
  sWalker.u.pSelect = p;
  
// ABS Label 3277
if(p->pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3277);
}
sqlite3WalkExpr(&sWalker, p->pHaving);
#if SELECTTRACE_ENABLED
  if( sWalker.eCode && (sqlite3SelectTrace & 0x100)!=0 ){
    SELECTTRACE(0x100,pParse,p,("Move HAVING terms into WHERE:\n"));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif
}

/*
** Check to see if the pThis entry of pTabList is a self-join of a prior view.
** If it is, then return the SrcList_item for the prior view.  If it is not,
** then return 0.
*/
static SrcItem *isSelfJoinView(
  SrcList *pTabList,           /* Search for self-joins in this FROM clause */
  SrcItem *pThis               /* Search for prior reference to this subquery */
){
  SrcItem *pItem;
  assert( pThis->pSelect!=0 );
  
// ABS Label 3278
if(pThis->pSelect->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3278);
}

// AOR Label 3279
if(pThis->pSelect->selFlags | 16777216 != pThis->pSelect->selFlags & 16777216)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3279);
}
// AOR Label 3280
if(pThis->pSelect->selFlags ^ 16777216 != pThis->pSelect->selFlags & 16777216)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3280);
}
if( pThis->pSelect->selFlags & SF_PushDown ) { return 0;
}
  pItem = pTabList->a;

// ABS Label 3281
if(pItem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3281);
}
// ABS Label 3282
if(pThis < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3282);
}

// ROR Label 3283
if((pItem <= pThis) != (pItem < pThis))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3283);
}
// ROR Label 3284
if((pItem > pThis) != (pItem < pThis))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3284);
}
// ROR Label 3285
if((pItem >= pThis) != (pItem < pThis))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3285);
}
for(; pItem<pThis; pItem++){
    Select *pS1;
    
// ABS Label 3291
if(pItem->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3291);
}

// ROR Label 3292
if((pItem->pSelect != 0) != (pItem->pSelect == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3292);
}
if( pItem->pSelect==0 ) { continue;
}
    
// ABS Label 3293
if(pItem->fg.viaCoroutine < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3293);
}
if( pItem->fg.viaCoroutine ) { continue;
}
    
// ABS Label 3294
if(pItem->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3294);
}

// ROR Label 3295
if((pItem->zName != 0) != (pItem->zName == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3295);
}
if( pItem->zName==0 ) { continue;
}
    assert( pItem->pTab!=0 );
    assert( pThis->pTab!=0 );
    
// ABS Label 3296
if(pItem->pTab->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3296);
}
// ABS Label 3297
if(pThis->pTab->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3297);
}

// ROR Label 3298
if((pItem->pTab->pSchema == pThis->pTab->pSchema) != (pItem->pTab->pSchema != pThis->pTab->pSchema))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3298);
}
if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) { continue;
}
    if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) { continue;
}
    pS1 = pItem->pSelect;
    
// ABS Label 3299
if(pItem->pTab->pSchema < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3299);
}
// ABS Label 3300
if(pS1->selId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3300);
}
// ABS Label 3301
if(pThis->pSelect->selId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3301);
}

// COR Label 3302
if((pItem->pTab->pSchema == 0 || pThis->pSelect->selId != pS1->selId) != (pItem->pTab->pSchema == 0 && pThis->pSelect->selId != pS1->selId))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3302);
}

// ROR Label 3303
if((pItem->pTab->pSchema != 0) != (pItem->pTab->pSchema == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3303);
}
// ROR Label 3304
if((pThis->pSelect->selId == pS1->selId) != (pThis->pSelect->selId != pS1->selId))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3304);
}

// MCC Label 3305
if(pItem->pTab->pSchema == 0 && pThis->pSelect->selId != pS1->selId ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3305);
}
// MCC Label 3306
if(pItem->pTab->pSchema == 0 && !(pThis->pSelect->selId != pS1->selId) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3306);
}
// MCC Label 3307
if(!(pItem->pTab->pSchema == 0) && pThis->pSelect->selId != pS1->selId ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3307);
}
// MCC Label 3308
if(!(pItem->pTab->pSchema == 0) && !(pThis->pSelect->selId != pS1->selId) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3308);
}
if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){
      /* The query flattener left two different CTE tables with identical
      ** names in the same FROM clause. */
      continue;
    }
    
// ABS Label 3309
if(pItem->pSelect->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3309);
}

// AOR Label 3310
if(pItem->pSelect->selFlags | 16777216 != pItem->pSelect->selFlags & 16777216)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3310);
}
// AOR Label 3311
if(pItem->pSelect->selFlags ^ 16777216 != pItem->pSelect->selFlags & 16777216)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3311);
}
if( pItem->pSelect->selFlags & SF_PushDown ){
      /* The view was modified by some other optimization such as
      ** pushDownWhereTerms() */
      continue;
    }
    
// ABS Label 3312
if(pItem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3312);
}
return pItem;
  };
// ABS Label 3286
if(pItem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3286);
}
// ABS Label 3287
if(pThis < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3287);
}

// ROR Label 3288
if((pItem <= pThis) != (pItem < pThis))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3288);
}
// ROR Label 3289
if((pItem > pThis) != (pItem < pThis))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3289);
}
// ROR Label 3290
if((pItem >= pThis) != (pItem < pThis))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3290);
}

  return 0;
}

/*
** Deallocate a single AggInfo object
*/
static void agginfoFree(sqlite3 *db, AggInfo *p){
  
// ABS Label 3313
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3313);
}
sqlite3DbFree(db, p->aCol);
  
// ABS Label 3314
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3314);
}
sqlite3DbFree(db, p->aFunc);
  
// ABS Label 3315
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3315);
}
sqlite3DbFreeNN(db, p);
}

#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
/*
** Attempt to transform a query of the form
**
**    SELECT count(*) FROM (SELECT x FROM t1 UNION ALL SELECT y FROM t2)
**
** Into this:
**
**    SELECT (SELECT count(*) FROM t1)+(SELECT count(*) FROM t2)
**
** The transformation only works if all of the following are true:
**
**   *  The subquery is a UNION ALL of two or more terms
**   *  The subquery does not have a LIMIT clause
**   *  There is no WHERE or GROUP BY or HAVING clauses on the subqueries
**   *  The outer query is a simple count(*) with no WHERE clause or other
**      extraneous syntax.
**
** Return TRUE if the optimization is undertaken.
*/
static int countOfViewOptimization(Parse *pParse, Select *p){
  Select *pSub, *pPrior;
  Expr *pExpr;
  Expr *pCount;
  sqlite3 *db;
  if( (p->selFlags & SF_Aggregate)==0 ) return 0;   /* This is an aggregate */
  if( p->pEList->nExpr!=1 ) return 0;               /* Single result column */
  if( p->pWhere ) return 0;
  if( p->pGroupBy ) return 0;
  pExpr = p->pEList->a[0].pExpr;
  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */
  if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;  /* Is count() */
  if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */
  if( p->pSrc->nSrc!=1 ) return 0;                  /* One table in FROM  */
  pSub = p->pSrc->a[0].pSelect;
  if( pSub==0 ) return 0;                           /* The FROM is a subquery */
  if( pSub->pPrior==0 ) return 0;                   /* Must be a compound ry */
  do{
    if( pSub->op!=TK_ALL && pSub->pPrior ) return 0;  /* Must be UNION ALL */
    if( pSub->pWhere ) return 0;                      /* No WHERE clause */
    if( pSub->pLimit ) return 0;                      /* No LIMIT clause */
    if( pSub->selFlags & SF_Aggregate ) return 0;     /* Not an aggregate */
    pSub = pSub->pPrior;                              /* Repeat over compound */
  }while( pSub );

  /* If we reach this point then it is OK to perform the transformation */

  db = pParse->db;
  pCount = pExpr;
  pExpr = 0;
  pSub = p->pSrc->a[0].pSelect;
  p->pSrc->a[0].pSelect = 0;
  sqlite3SrcListDelete(db, p->pSrc);
  p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*p->pSrc));
  while( pSub ){
    Expr *pTerm;
    pPrior = pSub->pPrior;
    pSub->pPrior = 0;
    pSub->pNext = 0;
    pSub->selFlags |= SF_Aggregate;
    pSub->selFlags &= ~SF_Compound;
    pSub->nSelectRow = 0;
    sqlite3ExprListDelete(db, pSub->pEList);
    pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;
    pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);
    pTerm = sqlite3PExpr(pParse, TK_SELECT, 0, 0);
    sqlite3PExprAddSelect(pParse, pTerm, pSub);
    if( pExpr==0 ){
      pExpr = pTerm;
    }else{
      pExpr = sqlite3PExpr(pParse, TK_PLUS, pTerm, pExpr);
    }
    pSub = pPrior;
  }
  p->pEList->a[0].pExpr = pExpr;
  p->selFlags &= ~SF_Aggregate;

#if SELECTTRACE_ENABLED
  if( sqlite3SelectTrace & 0x400 ){
    SELECTTRACE(0x400,pParse,p,("After count-of-view optimization:\n"));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif
  return 1;
}
#endif /* SQLITE_COUNTOFVIEW_OPTIMIZATION */

/*
** Generate code for the SELECT statement given in the p argument.  
**
** The results are returned according to the SelectDest structure.
** See comments in sqliteInt.h for further information.
**
** This routine returns the number of errors.  If any errors are
** encountered, then an appropriate error message is left in
** pParse->zErrMsg.
**
** This routine does NOT free the Select structure passed in.  The
** calling function needs to do that.
*/
int sqlite3Select(
  Parse *pParse,         /* The parser context */
  Select *p,             /* The SELECT statement being coded. */
  SelectDest *pDest      /* What to do with the query results */
){
  int i, j;              /* Loop counters */
  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */
  Vdbe *v;               /* The virtual machine under construction */
  int isAgg;             /* True for select lists like "count(*)" */
  ExprList *pEList = 0;  /* List of columns to extract. */
  SrcList *pTabList;     /* List of tables to select from */
  Expr *pWhere;          /* The WHERE clause.  May be NULL */
  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */
  Expr *pHaving;         /* The HAVING clause.  May be NULL */
  AggInfo *pAggInfo = 0; /* Aggregate information */
  int rc = 1;            /* Value to return from this function */
  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */
  SortCtx sSort;         /* Info on how to code the ORDER BY clause */
  int iEnd;              /* Address of the end of the query */
  sqlite3 *db;           /* The database connection */
  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */
  u8 minMaxFlag;                 /* Flag for min/max queries */

  db = pParse->db;
  v = sqlite3GetVdbe(pParse);
  
// ABS Label 3326
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3326);
}
// ABS Label 3327
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3327);
}

// COR Label 3328
if((p == 0 || db->mallocFailed && pParse->nErr) != (p == 0 || db->mallocFailed || pParse->nErr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3328);
}
// COR Label 3329
if((p == 0 && db->mallocFailed) != (p == 0 || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3329);
}

// ROR Label 3330
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3330);
}

// MCC Label 3331
if(p == 0 && db->mallocFailed && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3331);
}
// MCC Label 3332
if(p == 0 && db->mallocFailed && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3332);
}
// MCC Label 3333
if(p == 0 && !(db->mallocFailed) && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3333);
}
// MCC Label 3334
if(p == 0 && !(db->mallocFailed) && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3334);
}
// MCC Label 3335
if(!(p == 0) && db->mallocFailed && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3335);
}
// MCC Label 3336
if(!(p == 0) && db->mallocFailed && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3336);
}
// MCC Label 3337
if(!(p == 0) && !(db->mallocFailed) && pParse->nErr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3337);
}
// MCC Label 3338
if(!(p == 0) && !(db->mallocFailed) && !(pParse->nErr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3338);
}
if( p==0 || db->mallocFailed || pParse->nErr ){
    return 1;
  }
  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) { return 1;
}
#if SELECTTRACE_ENABLED
  SELECTTRACE(1,pParse,p, ("begin processing:\n", pParse->addrExplain));
  if( sqlite3SelectTrace & 0x100 ){
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif

  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );
  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );
  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );
  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );
  
// MCC Label 3339
if(( (pDest->eDest) <= 6 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3339);
}
// MCC Label 3340
if(( !((pDest->eDest) <= 6) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3340);
}
if( IgnorableDistinct(pDest) ){
    assert(pDest->eDest==SRT_Exists     || pDest->eDest==SRT_Union || 
           pDest->eDest==SRT_Except     || pDest->eDest==SRT_Discard ||
           pDest->eDest==SRT_DistQueue  || pDest->eDest==SRT_DistFifo );
    /* All of these destinations are also able to ignore the ORDER BY clause */
    
// ABS Label 3341
if(p->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3341);
}
if( p->pOrderBy ){
#if SELECTTRACE_ENABLED
      SELECTTRACE(1,pParse,p, ("dropping superfluous ORDER BY:\n"));
      if( sqlite3SelectTrace & 0x100 ){
        sqlite3TreeViewExprList(0, p->pOrderBy, 0, "ORDERBY");
      }
#endif    
      
// ABS Label 3342
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3342);
}
sqlite3ParserAddCleanup(pParse,
        (void(*)(sqlite3*,void*))sqlite3ExprListDelete,
        p->pOrderBy);
      testcase( pParse->earlyCleanup );
      p->pOrderBy = 0;
    }
    p->selFlags &= ~SF_Distinct;
    p->selFlags |= SF_NoopOrderBy;
  }
  
// ABS Label 3316
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3316);
}

// ABS Label 3317
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3317);
}
sqlite3SelectPrep(pParse, p, 0);
  
// ABS Label 3343
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3343);
}

// COR Label 3344
if((pParse->nErr && db->mallocFailed) != (pParse->nErr || db->mallocFailed))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3344);
}

// MCC Label 3345
if(pParse->nErr && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3345);
}
// MCC Label 3346
if(pParse->nErr && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3346);
}
// MCC Label 3347
if(!(pParse->nErr) && db->mallocFailed ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3347);
}
// MCC Label 3348
if(!(pParse->nErr) && !(db->mallocFailed) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3348);
}
if( pParse->nErr || db->mallocFailed ){
    goto select_end;
  }
  assert( p->pEList!=0 );
#if SELECTTRACE_ENABLED
  if( sqlite3SelectTrace & 0x104 ){
    SELECTTRACE(0x104,pParse,p, ("after name resolution:\n"));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif

  /* If the SF_UFSrcCheck flag is set, then this function is being called
  ** as part of populating the temp table for an UPDATE...FROM statement.
  ** In this case, it is an error if the target object (pSrc->a[0]) name 
  ** or alias is duplicated within FROM clause (pSrc->a[1..n]).  
  **
  ** Postgres disallows this case too. The reason is that some other 
  ** systems handle this case differently, and not all the same way, 
  ** which is just confusing. To avoid this, we follow PG's lead and
  ** disallow it altogether.  */
  
// ABS Label 3349
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3349);
}

// AOR Label 3350
if(p->selFlags | 8388608 != p->selFlags & 8388608)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3350);
}
// AOR Label 3351
if(p->selFlags ^ 8388608 != p->selFlags & 8388608)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3351);
}
if( p->selFlags & SF_UFSrcCheck ){
    SrcItem *p0 = &p->pSrc->a[0];
    i = 1;

// ABS Label 3352
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3352);
}
// ABS Label 3353
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3353);
}

// ROR Label 3354
if((i <= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3354);
}
// ROR Label 3355
if((i > p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3355);
}
// ROR Label 3356
if((i >= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3356);
}
for(; i<p->pSrc->nSrc; i++){
      SrcItem *p1 = &p->pSrc->a[i];
      if( p0->pTab==p1->pTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){
        
// ABS Label 3362
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3362);
}
sqlite3ErrorMsg(pParse, 
            "target object/alias may not appear in FROM clause: %s", 
            p0->zAlias ? p0->zAlias : p0->pTab->zName
        );
        goto select_end;
      }
    };
// ABS Label 3357
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3357);
}
// ABS Label 3358
if(p->pSrc->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3358);
}

// ROR Label 3359
if((i <= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3359);
}
// ROR Label 3360
if((i > p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3360);
}
// ROR Label 3361
if((i >= p->pSrc->nSrc) != (i < p->pSrc->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3361);
}


    /* Clear the SF_UFSrcCheck flag. The check has already been performed,
    ** and leaving this flag set can cause errors if a compound sub-query
    ** in p->pSrc is flattened into this query and this function called
    ** again as part of compound SELECT processing.  */
    p->selFlags &= ~SF_UFSrcCheck;
  }

  
// ROR Label 3363
if((pDest->eDest != 9) != (pDest->eDest == 9))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3363);
}
if( pDest->eDest==SRT_Output ){
    
// ABS Label 3364
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3364);
}

// ABS Label 3365
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3365);
}
sqlite3GenerateColumnNames(pParse, p);
  }

#ifndef SQLITE_OMIT_WINDOWFUNC
  if( sqlite3WindowRewrite(pParse, p) ){
    assert( db->mallocFailed || pParse->nErr>0 );
    goto select_end;
  }
#if SELECTTRACE_ENABLED
  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){
    SELECTTRACE(0x104,pParse,p, ("after window rewrite:\n"));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif
#endif /* SQLITE_OMIT_WINDOWFUNC */
  pTabList = p->pSrc;
  isAgg = (p->selFlags & SF_Aggregate)!=0;
  memset(&sSort, 0, sizeof(sSort));
  sSort.pOrderBy = p->pOrderBy;

  /* Try to do various optimizations (flattening subqueries, and strength
  ** reduction of join operators) in the FROM clause up into the main query
  */
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
  i = 0;

// ABS Label 3366
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3366);
}
// ABS Label 3367
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3367);
}

// COR Label 3368
if((!p->pPrior || i < pTabList->nSrc) != (!p->pPrior && i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3368);
}

// ROR Label 3369
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3369);
}
// ROR Label 3370
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3370);
}
// ROR Label 3371
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3371);
}

// MCC Label 3372
if(!p->pPrior && i < pTabList->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3372);
}
// MCC Label 3373
if(!p->pPrior && !(i < pTabList->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3373);
}
// MCC Label 3374
if(!(!p->pPrior) && i < pTabList->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3374);
}
// MCC Label 3375
if(!(!p->pPrior) && !(i < pTabList->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3375);
}
for(; !p->pPrior && i<pTabList->nSrc; i++){
    SrcItem *pItem = &pTabList->a[i];
    
// ABS Label 3386
if(pItem->pSelect < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3386);
}
Select *pSub = pItem->pSelect;
    
// ABS Label 3387
if(pItem->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3387);
}
Table *pTab = pItem->pTab;

    /* The expander should have already created transient Table objects
    ** even for FROM clause elements such as subqueries that do not correspond
    ** to a real table */
    assert( pTab!=0 );

    /* Convert LEFT JOIN into JOIN if there are terms of the right table
    ** of the LEFT JOIN used in the WHERE clause.
    */
    if( (pItem->fg.jointype & JT_LEFT)!=0
     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)
     && OptimizationEnabled(db, SQLITE_SimplifyJoin)
    ){
      SELECTTRACE(0x100,pParse,p,
                ("LEFT-JOIN simplifies to JOIN on term %d\n",i));
      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);
      
// ABS Label 3388
if(p->pWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3388);
}

// ABS Label 3389
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3389);
}
unsetJoinExpr(p->pWhere, pItem->iCursor);
    }

    /* No futher action if this term of the FROM clause is no a subquery */
    
// ABS Label 3390
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3390);
}

// ROR Label 3391
if((pSub != 0) != (pSub == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3391);
}
if( pSub==0 ) { continue;
}

    /* Catch mismatch in the declared columns of a view and the number of
    ** columns in the SELECT on the RHS */
    
// ABS Label 3392
if(pSub->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3392);
}

// ROR Label 3393
if((pTab->nCol == pSub->pEList->nExpr) != (pTab->nCol != pSub->pEList->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3393);
}
if( pTab->nCol!=pSub->pEList->nExpr ){
      
// ABS Label 3394
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3394);
}

// ABS Label 3395
if(pTab->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3395);
}

// ABS Label 3396
if(pSub->pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3396);
}
sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d",
                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);
      goto select_end;
    }

    /* Do not try to flatten an aggregate subquery.
    **
    ** Flattening an aggregate subquery is only possible if the outer query
    ** is not a join.  But if the outer query is not a join, then the subquery
    ** will be implemented as a co-routine and there is no advantage to
    ** flattening in that case.
    */
    
// ROR Label 3397
if(((pSub->selFlags & 8) == 0) != ((pSub->selFlags & 8) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3397);
}
if( (pSub->selFlags & SF_Aggregate)!=0 ) { continue;
}
    assert( pSub->pGroupBy==0 );

    /* If the outer query contains a "complex" result set (that is,
    ** if the result set of the outer query uses functions or subqueries)
    ** and if the subquery contains an ORDER BY clause and if
    ** it will be implemented as a co-routine, then do not flatten.  This
    ** restriction allows SQL constructs like this:
    **
    **  SELECT expensive_function(x)
    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);
    **
    ** The expensive_function() is only computed on the 10 rows that
    ** are output, rather than every row of the table.
    **
    ** The requirement that the outer query have a complex result set
    ** means that flattening does occur on simpler SQL constraints without
    ** the expensive_function() like:
    **
    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);
    */
    
// ABS Label 3398
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3398);
}
// ABS Label 3399
if(pSub->pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3399);
}

// COR Label 3400
if((pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 || (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (8 | 2)) != 0)) != (pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (8 | 2)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3400);
}
// COR Label 3401
if((pSub->pOrderBy != 0 && i == 0 || (p->selFlags & 262144) != 0) != (pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3401);
}
// COR Label 3402
if((pSub->pOrderBy != 0 || i == 0) != (pSub->pOrderBy != 0 && i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3402);
}

// ROR Label 3403
if((pSub->pOrderBy == 0) != (pSub->pOrderBy != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3403);
}
// ROR Label 3404
if((i != 0) != (i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3404);
}
// ROR Label 3405
if(((p->selFlags & 262144) == 0) != ((p->selFlags & 262144) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3405);
}

// MCC Label 3406
if(pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3406);
}
// MCC Label 3407
if(pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3407);
}
// MCC Label 3408
if(pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3408);
}
// MCC Label 3409
if(pSub->pOrderBy != 0 && i == 0 && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3409);
}
// MCC Label 3410
if(pSub->pOrderBy != 0 && i == 0 && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3410);
}
// MCC Label 3411
if(pSub->pOrderBy != 0 && i == 0 && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3411);
}
// MCC Label 3412
if(pSub->pOrderBy != 0 && i == 0 && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3412);
}
// MCC Label 3413
if(pSub->pOrderBy != 0 && i == 0 && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3413);
}
// MCC Label 3414
if(pSub->pOrderBy != 0 && !(i == 0) && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3414);
}
// MCC Label 3415
if(pSub->pOrderBy != 0 && !(i == 0) && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3415);
}
// MCC Label 3416
if(pSub->pOrderBy != 0 && !(i == 0) && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3416);
}
// MCC Label 3417
if(pSub->pOrderBy != 0 && !(i == 0) && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3417);
}
// MCC Label 3418
if(pSub->pOrderBy != 0 && !(i == 0) && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3418);
}
// MCC Label 3419
if(pSub->pOrderBy != 0 && !(i == 0) && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3419);
}
// MCC Label 3420
if(pSub->pOrderBy != 0 && !(i == 0) && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3420);
}
// MCC Label 3421
if(pSub->pOrderBy != 0 && !(i == 0) && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3421);
}
// MCC Label 3422
if(!(pSub->pOrderBy != 0) && i == 0 && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3422);
}
// MCC Label 3423
if(!(pSub->pOrderBy != 0) && i == 0 && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3423);
}
// MCC Label 3424
if(!(pSub->pOrderBy != 0) && i == 0 && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3424);
}
// MCC Label 3425
if(!(pSub->pOrderBy != 0) && i == 0 && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3425);
}
// MCC Label 3426
if(!(pSub->pOrderBy != 0) && i == 0 && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3426);
}
// MCC Label 3427
if(!(pSub->pOrderBy != 0) && i == 0 && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3427);
}
// MCC Label 3428
if(!(pSub->pOrderBy != 0) && i == 0 && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3428);
}
// MCC Label 3429
if(!(pSub->pOrderBy != 0) && i == 0 && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3429);
}
// MCC Label 3430
if(!(pSub->pOrderBy != 0) && !(i == 0) && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3430);
}
// MCC Label 3431
if(!(pSub->pOrderBy != 0) && !(i == 0) && (p->selFlags & 262144) != 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3431);
}
// MCC Label 3432
if(!(pSub->pOrderBy != 0) && !(i == 0) && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3432);
}
// MCC Label 3433
if(!(pSub->pOrderBy != 0) && !(i == 0) && (p->selFlags & 262144) != 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3433);
}
// MCC Label 3434
if(!(pSub->pOrderBy != 0) && !(i == 0) && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3434);
}
// MCC Label 3435
if(!(pSub->pOrderBy != 0) && !(i == 0) && !((p->selFlags & 262144) != 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3435);
}
// MCC Label 3436
if(!(pSub->pOrderBy != 0) && !(i == 0) && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3436);
}
// MCC Label 3437
if(!(pSub->pOrderBy != 0) && !(i == 0) && !((p->selFlags & 262144) != 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3437);
}
if( pSub->pOrderBy!=0
     && i==0
     && (p->selFlags & SF_ComplexResult)!=0
     && (pTabList->nSrc==1
         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)
    ){
      continue;
    }

    if( flattenSubquery(pParse, p, i, isAgg) ){
      
// ABS Label 3438
if(pParse->nErr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3438);
}
if( pParse->nErr ) { goto select_end;
}
      /* This subquery can be absorbed into its parent. */
      i = -1;
    }
    pTabList = p->pSrc;
    
// ABS Label 3439
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3439);
}
if( db->mallocFailed ) { goto select_end;
}
    if( !IgnorableOrderby(pDest) ){
      sSort.pOrderBy = p->pOrderBy;
    }
  };
// ABS Label 3376
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3376);
}
// ABS Label 3377
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3377);
}

// COR Label 3378
if((!p->pPrior || i < pTabList->nSrc) != (!p->pPrior && i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3378);
}

// ROR Label 3379
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3379);
}
// ROR Label 3380
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3380);
}
// ROR Label 3381
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3381);
}

// MCC Label 3382
if(!p->pPrior && i < pTabList->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3382);
}
// MCC Label 3383
if(!p->pPrior && !(i < pTabList->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3383);
}
// MCC Label 3384
if(!(!p->pPrior) && i < pTabList->nSrc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3384);
}
// MCC Label 3385
if(!(!p->pPrior) && !(i < pTabList->nSrc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3385);
}

#endif

#ifndef SQLITE_OMIT_COMPOUND_SELECT
  /* Handle compound SELECT statements using the separate multiSelect()
  ** procedure.
  */
  
// ABS Label 3440
if(p->pPrior < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3440);
}
if( p->pPrior ){
    rc = multiSelect(pParse, p, pDest);
#if SELECTTRACE_ENABLED
    SELECTTRACE(0x1,pParse,p,("end compound-select processing\n"));
    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){
      sqlite3TreeViewSelect(0, p, 0);
    }
#endif
    
// ABS Label 3441
if(p->pNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3441);
}

// ROR Label 3442
if((p->pNext != 0) != (p->pNext == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3442);
}
if( p->pNext==0 ) { ExplainQueryPlanPop(pParse);
}
    
// ABS Label 3444
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3444);
}
return rc;
  }
#endif

  /* Do the WHERE-clause constant propagation optimization if this is
  ** a join.  No need to speed time on this operation for non-join queries
  ** as the equivalent optimization will be handled by query planner in
  ** sqlite3WhereBegin().
  */
  if( p->pWhere!=0
   && p->pWhere->op==TK_AND
   && OptimizationEnabled(db, SQLITE_PropagateConst)
   && propagateConstants(pParse, p)
  ){
#if SELECTTRACE_ENABLED
    if( sqlite3SelectTrace & 0x100 ){
      SELECTTRACE(0x100,pParse,p,("After constant propagation:\n"));
      sqlite3TreeViewSelect(0, p, 0);
    }
#endif
  }else{
    SELECTTRACE(0x100,pParse,p,("Constant propagation not helpful\n"));
  }

#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)
   && countOfViewOptimization(pParse, p)
  ){
    if( db->mallocFailed ) goto select_end;
    pEList = p->pEList;
    pTabList = p->pSrc;
  }
#endif

  /* For each term in the FROM clause, do two things:
  ** (1) Authorized unreferenced tables
  ** (2) Generate code for all sub-queries
  */
  i = 0;

// ABS Label 3445
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3445);
}
// ABS Label 3446
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3446);
}

// ROR Label 3447
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3447);
}
// ROR Label 3448
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3448);
}
// ROR Label 3449
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3449);
}
for(; i<pTabList->nSrc; i++){
    SrcItem *pItem = &pTabList->a[i];
    SrcItem *pPrior;
    SelectDest dest;
    Select *pSub;
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
    const char *zSavedAuthContext;
#endif

    /* Issue SQLITE_READ authorizations with a fake column name for any
    ** tables that are referenced but from which no values are extracted.
    ** Examples of where these kinds of null SQLITE_READ authorizations
    ** would occur:
    **
    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.""
    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.""
    **
    ** The fake column name is an empty string.  It is possible for a table to
    ** have a column named by the empty string, in which case there is no way to
    ** distinguish between an unreferenced table and an actual reference to the
    ** "" column. The original design was for the fake column name to be a NULL,
    ** which would be unambiguous.  But legacy authorization callbacks might
    ** assume the column name is non-NULL and segfault.  The use of an empty
    ** string for the fake column name seems safer.
    */
    
// ABS Label 3455
if(pItem->colUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3455);
}
// ABS Label 3456
if(pItem->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3456);
}

// COR Label 3457
if((pItem->colUsed == 0 || pItem->zName != 0) != (pItem->colUsed == 0 && pItem->zName != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3457);
}

// ROR Label 3458
if((pItem->colUsed != 0) != (pItem->colUsed == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3458);
}
// ROR Label 3459
if((pItem->zName == 0) != (pItem->zName != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3459);
}

// MCC Label 3460
if(pItem->colUsed == 0 && pItem->zName != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3460);
}
// MCC Label 3461
if(pItem->colUsed == 0 && !(pItem->zName != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3461);
}
// MCC Label 3462
if(!(pItem->colUsed == 0) && pItem->zName != 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3462);
}
// MCC Label 3463
if(!(pItem->colUsed == 0) && !(pItem->zName != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3463);
}
if( pItem->colUsed==0 && pItem->zName!=0 ){
      
// ABS Label 3464
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3464);
}
sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, "", pItem->zDatabase);
    }

#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
    /* Generate code for all sub-queries in the FROM clause
    */
    pSub = pItem->pSelect;
    
// ABS Label 3465
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3465);
}

// ROR Label 3466
if((pSub != 0) != (pSub == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3466);
}
if( pSub==0 ) { continue;
}

    /* The code for a subquery should only be generated once. */
    assert( pItem->addrFillSub==0 );

    /* Increment Parse.nHeight by the height of the largest expression
    ** tree referred to by this, the parent select. The child select
    ** may contain expression trees of at most
    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit
    ** more conservative than necessary, but much easier than enforcing
    ** an exact limit.
    */
    pParse->nHeight += sqlite3SelectExprHeight(p);

    /* Make copies of constant WHERE-clause terms in the outer query down
    ** inside the subquery.  This can help the subquery to run more efficiently.
    */
    if( OptimizationEnabled(db, SQLITE_PushDown)
     && (pItem->fg.isCte==0 || pItem->u2.pCteUse->eM10d!=M10d_Yes)
     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,
                           (pItem->fg.jointype & JT_OUTER)!=0)
    ){
#if SELECTTRACE_ENABLED
      if( sqlite3SelectTrace & 0x100 ){
        SELECTTRACE(0x100,pParse,p,
            ("After WHERE-clause push-down into subquery %d:\n", pSub->selId));
        sqlite3TreeViewSelect(0, p, 0);
      }
#endif
      assert( pItem->pSelect && (pItem->pSelect->selFlags & SF_PushDown)!=0 );
    }else{
      SELECTTRACE(0x100,pParse,p,("Push-down not possible\n"));
    }

    zSavedAuthContext = pParse->zAuthContext;
    pParse->zAuthContext = pItem->zName;

    /* Generate code to implement the subquery
    **
    ** The subquery is implemented as a co-routine if:
    **    (1)  the subquery is guaranteed to be the outer loop (so that
    **         it does not need to be computed more than once), and
    **    (2)  the subquery is not a CTE that should be materialized
    **
    ** TODO: Are there other reasons beside (1) and (2) to use a co-routine
    ** implementation?
    */
    
// ABS Label 3467
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3467);
}

// COR Label 3468
if((i == 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (8 | 2)) != 0) || (pItem->fg.isCte == 0 || pItem->u2.pCteUse->eM10d != 0)) != (i == 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (8 | 2)) != 0) && (pItem->fg.isCte == 0 || pItem->u2.pCteUse->eM10d != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3468);
}
// COR Label 3469
if((i == 0 || (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (8 | 2)) != 0)) != (i == 0 && (pTabList->nSrc == 1 || (pTabList->a[1].fg.jointype & (8 | 2)) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3469);
}

// ROR Label 3470
if((i != 0) != (i == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3470);
}

// MCC Label 3471
if(i == 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3471);
}
// MCC Label 3472
if(i == 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3472);
}
// MCC Label 3473
if(i == 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3473);
}
// MCC Label 3474
if(i == 0 && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3474);
}
// MCC Label 3475
if(i == 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3475);
}
// MCC Label 3476
if(i == 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3476);
}
// MCC Label 3477
if(i == 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3477);
}
// MCC Label 3478
if(i == 0 && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3478);
}
// MCC Label 3479
if(i == 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3479);
}
// MCC Label 3480
if(i == 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3480);
}
// MCC Label 3481
if(i == 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3481);
}
// MCC Label 3482
if(i == 0 && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3482);
}
// MCC Label 3483
if(i == 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3483);
}
// MCC Label 3484
if(i == 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3484);
}
// MCC Label 3485
if(i == 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3485);
}
// MCC Label 3486
if(i == 0 && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3486);
}
// MCC Label 3487
if(!(i == 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3487);
}
// MCC Label 3488
if(!(i == 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3488);
}
// MCC Label 3489
if(!(i == 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3489);
}
// MCC Label 3490
if(!(i == 0) && ( pTabList->nSrc == 1 && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3490);
}
// MCC Label 3491
if(!(i == 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3491);
}
// MCC Label 3492
if(!(i == 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3492);
}
// MCC Label 3493
if(!(i == 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3493);
}
// MCC Label 3494
if(!(i == 0) && ( pTabList->nSrc == 1 && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3494);
}
// MCC Label 3495
if(!(i == 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3495);
}
// MCC Label 3496
if(!(i == 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3496);
}
// MCC Label 3497
if(!(i == 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3497);
}
// MCC Label 3498
if(!(i == 0) && ( !(pTabList->nSrc == 1) && (pTabList->a[1].fg.jointype & (8 | 2)) != 0 ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3498);
}
// MCC Label 3499
if(!(i == 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3499);
}
// MCC Label 3500
if(!(i == 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( pItem->fg.isCte == 0 && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3500);
}
// MCC Label 3501
if(!(i == 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && pItem->u2.pCteUse->eM10d != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3501);
}
// MCC Label 3502
if(!(i == 0) && ( !(pTabList->nSrc == 1) && !((pTabList->a[1].fg.jointype & (8 | 2)) != 0) ) && ( !(pItem->fg.isCte == 0) && !(pItem->u2.pCteUse->eM10d != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3502);
}
if( i==0
     && (pTabList->nSrc==1
            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */
     && (pItem->fg.isCte==0 || pItem->u2.pCteUse->eM10d!=M10d_Yes)  /* (2) */
    ){
      /* Implement a co-routine that will return a single row of the result
      ** set on each invocation.
      */
      int addrTop = sqlite3VdbeCurrentAddr(v)+1;
     
      pItem->regReturn = ++pParse->nMem;
      
// ABS Label 3503
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3503);
}

// ABS Label 3504
if(pItem->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3504);
}

// ABS Label 3505
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3505);
}
sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);
      VdbeComment((v, "%!S", pItem));
      pItem->addrFillSub = addrTop;
      
// ABS Label 3506
if(pItem->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3506);
}
sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);
      ExplainQueryPlan((pParse, 1, "CO-ROUTINE %!S", pItem));
      
// ABS Label 3509
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3509);
}

// ABS Label 3510
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3510);
}
sqlite3Select(pParse, pSub, &dest);
      pItem->pTab->nRowLogEst = pSub->nSelectRow;
      pItem->fg.viaCoroutine = 1;
      pItem->regResult = dest.iSdst;
      
// ABS Label 3511
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3511);
}

// ABS Label 3512
if(pItem->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3512);
}
sqlite3VdbeEndCoroutine(v, pItem->regReturn);
      
// ABS Label 3513
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3513);
}

// ABS Label 3514
if(addrTop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3514);
}

// AOR Label 3515
if(addrTop / 1 != addrTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3515);
}
// AOR Label 3516
if(addrTop + 1 != addrTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3516);
}
// AOR Label 3517
if(addrTop * 1 != addrTop - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3517);
}
sqlite3VdbeJumpHere(v, addrTop-1);
      
// ABS Label 3518
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3518);
}
sqlite3ClearTempRegCache(pParse);
    }else { 
// ABS Label 3519
if(pItem->u2.pCteUse->addrM9e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3519);
}

// COR Label 3520
if((pItem->fg.isCte || pItem->u2.pCteUse->addrM9e > 0) != (pItem->fg.isCte && pItem->u2.pCteUse->addrM9e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3520);
}

// ROR Label 3521
if((pItem->u2.pCteUse->addrM9e <= 0) != (pItem->u2.pCteUse->addrM9e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3521);
}
// ROR Label 3522
if((pItem->u2.pCteUse->addrM9e < 0) != (pItem->u2.pCteUse->addrM9e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3522);
}
// ROR Label 3523
if((pItem->u2.pCteUse->addrM9e >= 0) != (pItem->u2.pCteUse->addrM9e > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3523);
}

// MCC Label 3524
if(pItem->fg.isCte && pItem->u2.pCteUse->addrM9e > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3524);
}
// MCC Label 3525
if(pItem->fg.isCte && !(pItem->u2.pCteUse->addrM9e > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3525);
}
// MCC Label 3526
if(!(pItem->fg.isCte) && pItem->u2.pCteUse->addrM9e > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3526);
}
// MCC Label 3527
if(!(pItem->fg.isCte) && !(pItem->u2.pCteUse->addrM9e > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3527);
}
if( pItem->fg.isCte && pItem->u2.pCteUse->addrM9e>0 ){
      /* This is a CTE for which materialization code has already been
      ** generated.  Invoke the subroutine to compute the materialization,
      ** the make the pItem->iCursor be a copy of the ephemerial table that
      ** holds the result of the materialization. */
      
// ABS Label 3528
if(pItem->u2.pCteUse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3528);
}
CteUse *pCteUse = pItem->u2.pCteUse;
      
// ABS Label 3529
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3529);
}

// ABS Label 3530
if(pCteUse->regRtn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3530);
}

// ABS Label 3531
if(pCteUse->addrM9e < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3531);
}
sqlite3VdbeAddOp2(v, OP_Gosub, pCteUse->regRtn, pCteUse->addrM9e);
      
// ABS Label 3532
if(pCteUse->iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3532);
}
// ABS Label 3533
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3533);
}

// ROR Label 3534
if((pItem->iCursor == pCteUse->iCur) != (pItem->iCursor != pCteUse->iCur))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3534);
}
if( pItem->iCursor!=pCteUse->iCur ){
        
// ABS Label 3535
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3535);
}

// ABS Label 3536
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3536);
}

// ABS Label 3537
if(pCteUse->iCur < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3537);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pCteUse->iCur);
      }
      pSub->nSelectRow = pCteUse->nRowEst;
    }else { if( (pPrior = isSelfJoinView(pTabList, pItem))!=0 ){
      /* This view has already been materialized by a prior entry in
      ** this same FROM clause.  Reuse it. */
      
// ABS Label 3541
if(pPrior->addrFillSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3541);
}
if( pPrior->addrFillSub ){
        
// ABS Label 3542
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3542);
}

// ABS Label 3543
if(pPrior->regReturn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3543);
}

// ABS Label 3544
if(pPrior->addrFillSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3544);
}
sqlite3VdbeAddOp2(v, OP_Gosub, pPrior->regReturn, pPrior->addrFillSub);
      }
      
// ABS Label 3538
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3538);
}

// ABS Label 3539
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3539);
}

// ABS Label 3540
if(pPrior->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3540);
}
sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);
      pSub->nSelectRow = pPrior->pSelect->nSelectRow;
    }else{
      /* Materialize the view.  If the view is not correlated, generate a
      ** subroutine to do the materialization so that subsequent uses of
      ** the same view can reuse the materialization. */
      int topAddr;
      int onceAddr = 0;
      int retAddr;

      pItem->regReturn = ++pParse->nMem;
      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);
      pItem->addrFillSub = topAddr+1;
      
// ROR Label 3554
if((pItem->fg.isCorrelated != 0) != (pItem->fg.isCorrelated == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3554);
}
if( pItem->fg.isCorrelated==0 ){
        /* If the subquery is not correlated and if we are not inside of
        ** a trigger, then we only need to compute the value of the subquery
        ** once. */
        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);
        VdbeComment((v, "materialize %!S", pItem));
      }else{
        VdbeNoopComment((v, "materialize %!S", pItem));
      }
      
// ABS Label 3545
if(pItem->iCursor < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3545);
}
sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);
      ExplainQueryPlan((pParse, 1, "MATERIALIZE %!S", pItem));
      
// ABS Label 3548
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3548);
}

// ABS Label 3549
if(pSub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3549);
}
sqlite3Select(pParse, pSub, &dest);
      pItem->pTab->nRowLogEst = pSub->nSelectRow;
      
// ABS Label 3555
if(onceAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3555);
}
if( onceAddr ) { 
// ABS Label 3556
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3556);
}

// ABS Label 3557
if(onceAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3557);
}
sqlite3VdbeJumpHere(v, onceAddr);
}
      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);
      VdbeComment((v, "end %!S", pItem));
      
// ABS Label 3550
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3550);
}

// ABS Label 3551
if(topAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3551);
}

// ABS Label 3552
if(retAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3552);
}
sqlite3VdbeChangeP1(v, topAddr, retAddr);
      
// ABS Label 3553
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3553);
}
sqlite3ClearTempRegCache(pParse);
      
// COR Label 3558
if((pItem->fg.isCte || pItem->fg.isCorrelated == 0) != (pItem->fg.isCte && pItem->fg.isCorrelated == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3558);
}

// ROR Label 3559
if((pItem->fg.isCorrelated != 0) != (pItem->fg.isCorrelated == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3559);
}

// MCC Label 3560
if(pItem->fg.isCte && pItem->fg.isCorrelated == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3560);
}
// MCC Label 3561
if(pItem->fg.isCte && !(pItem->fg.isCorrelated == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3561);
}
// MCC Label 3562
if(!(pItem->fg.isCte) && pItem->fg.isCorrelated == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3562);
}
// MCC Label 3563
if(!(pItem->fg.isCte) && !(pItem->fg.isCorrelated == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3563);
}
if( pItem->fg.isCte && pItem->fg.isCorrelated==0 ){
        
// ABS Label 3564
if(pItem->u2.pCteUse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3564);
}
CteUse *pCteUse = pItem->u2.pCteUse;
        pCteUse->addrM9e = pItem->addrFillSub;
        pCteUse->regRtn = pItem->regReturn;
        pCteUse->iCur = pItem->iCursor;
        pCteUse->nRowEst = pSub->nSelectRow;
      }
    };}
;}

    
// ABS Label 3565
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3565);
}
if( db->mallocFailed ) { goto select_end;
}
    pParse->nHeight -= sqlite3SelectExprHeight(p);
    pParse->zAuthContext = zSavedAuthContext;
#endif
  };
// ABS Label 3450
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3450);
}
// ABS Label 3451
if(pTabList->nSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3451);
}

// ROR Label 3452
if((i <= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3452);
}
// ROR Label 3453
if((i > pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3453);
}
// ROR Label 3454
if((i >= pTabList->nSrc) != (i < pTabList->nSrc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3454);
}


  /* Various elements of the SELECT copied into local variables for
  ** convenience */
  pEList = p->pEList;
  pWhere = p->pWhere;
  pGroupBy = p->pGroupBy;
  pHaving = p->pHaving;
  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;

#if SELECTTRACE_ENABLED
  if( sqlite3SelectTrace & 0x400 ){
    SELECTTRACE(0x400,pParse,p,("After all FROM-clause analysis:\n"));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif

  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and 
  ** if the select-list is the same as the ORDER BY list, then this query
  ** can be rewritten as a GROUP BY. In other words, this:
  **
  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz
  **
  ** is transformed to:
  **
  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz
  **
  ** The second form is preferred as a single index (or temp-table) may be 
  ** used for both the ORDER BY and DISTINCT processing. As originally 
  ** written the query must use a temp-table for at least one of the ORDER 
  ** BY and DISTINCT, and an index or separate temp-table for the other.
  */
  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct 
   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0
#ifdef MAGMA_ENABLE_FIXES
#ifndef SQLITE_OMIT_WINDOWFUNC
   && p->pWin==0
#endif
#endif
  ){
#ifdef MAGMA_ENABLE_CANARIES
#ifndef SQLITE_OMIT_WINDOWFUNC
    MAGMA_LOG("SQL006", p->pWin != 0);
#endif
#endif
    p->selFlags &= ~SF_Distinct;
    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);
    p->selFlags |= SF_Aggregate;
    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,
    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the
    ** original setting of the SF_Distinct flag, not the current setting */
    assert( sDistinct.isTnct );

#if SELECTTRACE_ENABLED
    if( sqlite3SelectTrace & 0x400 ){
      SELECTTRACE(0x400,pParse,p,("Transform DISTINCT into GROUP BY:\n"));
      sqlite3TreeViewSelect(0, p, 0);
    }
#endif
  }

  /* If there is an ORDER BY clause, then create an ephemeral index to
  ** do the sorting.  But this sorting ephemeral index might end up
  ** being unused if the data can be extracted in pre-sorted order.
  ** If that is the case, then the OP_OpenEphemeral instruction will be
  ** changed to an OP_Noop once we figure out that the sorting index is
  ** not needed.  The sSort.addrSortIndex variable is used to facilitate
  ** that change.
  */
  
// ABS Label 3566
if(sSort.pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3566);
}
if( sSort.pOrderBy ){
    KeyInfo *pKeyInfo;
    pKeyInfo = sqlite3KeyInfoFromExprList(
        pParse, sSort.pOrderBy, 0, pEList->nExpr);
    sSort.iECursor = pParse->nTab++;
    sSort.addrSortIndex =
      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,
          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,
          (char*)pKeyInfo, P4_KEYINFO
      );
  }else{
    sSort.addrSortIndex = -1;
  }

  /* If the output is destined for a temporary table, open that table.
  */
  
// ROR Label 3567
if((pDest->eDest != 12) != (pDest->eDest == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3567);
}
if( pDest->eDest==SRT_EphemTab ){
    
// ABS Label 3568
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3568);
}

// ABS Label 3569
if(pDest->iSDParm < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3569);
}

// ABS Label 3570
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3570);
}
sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);
  }

  /* Set the limiter.
  */
  iEnd = sqlite3VdbeMakeLabel(pParse);
  
// ROR Label 3571
if(((p->selFlags & 16384) != 0) != ((p->selFlags & 16384) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3571);
}
if( (p->selFlags & SF_FixedLimit)==0 ){
    p->nSelectRow = 320;  /* 4 billion rows */
  }
  
// ABS Label 3318
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3318);
}

// ABS Label 3319
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3319);
}

// ABS Label 3320
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3320);
}
computeLimitRegisters(pParse, p, iEnd);
  
// ABS Label 3572
if(p->iLimit < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3572);
}
// ABS Label 3573
if(sSort.addrSortIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3573);
}

// COR Label 3574
if((p->iLimit == 0 || sSort.addrSortIndex >= 0) != (p->iLimit == 0 && sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3574);
}

// ROR Label 3575
if((p->iLimit != 0) != (p->iLimit == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3575);
}
// ROR Label 3576
if((sSort.addrSortIndex < 0) != (sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3576);
}
// ROR Label 3577
if((sSort.addrSortIndex > 0) != (sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3577);
}
// ROR Label 3578
if((sSort.addrSortIndex <= 0) != (sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3578);
}

// MCC Label 3579
if(p->iLimit == 0 && sSort.addrSortIndex >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3579);
}
// MCC Label 3580
if(p->iLimit == 0 && !(sSort.addrSortIndex >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3580);
}
// MCC Label 3581
if(!(p->iLimit == 0) && sSort.addrSortIndex >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3581);
}
// MCC Label 3582
if(!(p->iLimit == 0) && !(sSort.addrSortIndex >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3582);
}
if( p->iLimit==0 && sSort.addrSortIndex>=0 ){
    
// ABS Label 3583
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3583);
}

// ABS Label 3584
if(sSort.addrSortIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3584);
}
sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);
    sSort.sortFlags |= SORTFLAG_UseSorter;
  }

  /* Open an ephemeral index to use for the distinct set.
  */
  
// ABS Label 3585
if(p->selFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3585);
}

// AOR Label 3586
if(p->selFlags | 1 != p->selFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3586);
}
// AOR Label 3587
if(p->selFlags ^ 1 != p->selFlags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3587);
}
if( p->selFlags & SF_Distinct ){
    sDistinct.tabTnct = pParse->nTab++;
    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,
                       sDistinct.tabTnct, 0, 0,
                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),
                       P4_KEYINFO);
    
// ABS Label 3588
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3588);
}
sqlite3VdbeChangeP5(v, BTREE_UNORDERED);
    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;
  }else{
    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;
  }

  
// ABS Label 3589
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3589);
}

// COR Label 3590
if((!isAgg || pGroupBy == 0) != (!isAgg && pGroupBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3590);
}

// ROR Label 3591
if((pGroupBy != 0) != (pGroupBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3591);
}

// MCC Label 3592
if(!isAgg && pGroupBy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3592);
}
// MCC Label 3593
if(!isAgg && !(pGroupBy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3593);
}
// MCC Label 3594
if(!(!isAgg) && pGroupBy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3594);
}
// MCC Label 3595
if(!(!isAgg) && !(pGroupBy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3595);
}
if( !isAgg && pGroupBy==0 ){
    /* No aggregate functions and no GROUP BY clause */
    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)
                   | (p->selFlags & SF_FixedLimit);
#ifndef SQLITE_OMIT_WINDOWFUNC
    
// ABS Label 3596
if(p->pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3596);
}
Window *pWin = p->pWin;      /* Main window object (or NULL) */
    
// ABS Label 3597
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3597);
}
if( pWin ){
      
// ABS Label 3598
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3598);
}

// ABS Label 3599
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3599);
}
sqlite3WindowCodeInit(pParse, p);
    }
#endif
    assert( WHERE_USE_LIMIT==SF_FixedLimit );


    /* Begin the database scan. */
    SELECTTRACE(1,pParse,p,("WhereBegin\n"));
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,
                               p->pEList, wctrlFlags, p->nSelectRow);
    
// ABS Label 3600
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3600);
}

// ROR Label 3601
if((pWInfo != 0) != (pWInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3601);
}
if( pWInfo==0 ) { goto select_end;
}
    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){
      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);
    }
    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){
      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);
    }
    
// ABS Label 3602
if(sSort.pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3602);
}
if( sSort.pOrderBy ){
      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);
      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);
      
// ABS Label 3603
if(sSort.nOBSat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3603);
}
// ABS Label 3604
if(sSort.pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3604);
}

// ROR Label 3605
if((sSort.nOBSat != sSort.pOrderBy->nExpr) != (sSort.nOBSat == sSort.pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3605);
}
if( sSort.nOBSat==sSort.pOrderBy->nExpr ){
        sSort.pOrderBy = 0;
      }
    }
    SELECTTRACE(1,pParse,p,("WhereBegin returns\n"));

    /* If sorting index that was created by a prior OP_OpenEphemeral 
    ** instruction ended up not being needed, then change the OP_OpenEphemeral
    ** into an OP_Noop.
    */
    
// ABS Label 3606
if(sSort.addrSortIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3606);
}
// ABS Label 3607
if(sSort.pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3607);
}

// COR Label 3608
if((sSort.addrSortIndex >= 0 || sSort.pOrderBy == 0) != (sSort.addrSortIndex >= 0 && sSort.pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3608);
}

// ROR Label 3609
if((sSort.addrSortIndex < 0) != (sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3609);
}
// ROR Label 3610
if((sSort.addrSortIndex > 0) != (sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3610);
}
// ROR Label 3611
if((sSort.addrSortIndex <= 0) != (sSort.addrSortIndex >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3611);
}
// ROR Label 3612
if((sSort.pOrderBy != 0) != (sSort.pOrderBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3612);
}

// MCC Label 3613
if(sSort.addrSortIndex >= 0 && sSort.pOrderBy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3613);
}
// MCC Label 3614
if(sSort.addrSortIndex >= 0 && !(sSort.pOrderBy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3614);
}
// MCC Label 3615
if(!(sSort.addrSortIndex >= 0) && sSort.pOrderBy == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3615);
}
// MCC Label 3616
if(!(sSort.addrSortIndex >= 0) && !(sSort.pOrderBy == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3616);
}
if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){
      
// ABS Label 3617
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3617);
}

// ABS Label 3618
if(sSort.addrSortIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3618);
}
sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
    }

    assert( p->pEList==pEList );
#ifndef SQLITE_OMIT_WINDOWFUNC
    
// ABS Label 3619
if(pWin < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3619);
}
if( pWin ){
      int addrGosub = sqlite3VdbeMakeLabel(pParse);
      int iCont = sqlite3VdbeMakeLabel(pParse);
      int iBreak = sqlite3VdbeMakeLabel(pParse);
      int regGosub = ++pParse->nMem;

      
// ABS Label 3620
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3620);
}

// ABS Label 3621
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3621);
}

// ABS Label 3622
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3622);
}

// ABS Label 3623
if(regGosub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3623);
}

// ABS Label 3624
if(addrGosub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3624);
}
sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);

      
// ABS Label 3625
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3625);
}

// ABS Label 3626
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3626);
}
sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);
      
// ABS Label 3627
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3627);
}

// ABS Label 3628
if(addrGosub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3628);
}
sqlite3VdbeResolveLabel(v, addrGosub);
      VdbeNoopComment((v, "inner-loop subroutine"));
      sSort.labelOBLopt = 0;
      
// ABS Label 3629
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3629);
}

// ABS Label 3630
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3630);
}

// ABS Label 3631
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3631);
}

// ABS Label 3632
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3632);
}

// ABS Label 3633
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3633);
}
selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);
      
// ABS Label 3634
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3634);
}

// ABS Label 3635
if(iCont < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3635);
}
sqlite3VdbeResolveLabel(v, iCont);
      
// ABS Label 3636
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3636);
}

// ABS Label 3637
if(regGosub < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3637);
}
sqlite3VdbeAddOp1(v, OP_Return, regGosub);
      VdbeComment((v, "end inner-loop subroutine"));
      
// ABS Label 3638
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3638);
}

// ABS Label 3639
if(iBreak < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3639);
}
sqlite3VdbeResolveLabel(v, iBreak);
    }else
#endif /* SQLITE_OMIT_WINDOWFUNC */
    {
      /* Use the standard inner loop. */
      
// ABS Label 3640
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3640);
}

// ABS Label 3641
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3641);
}

// ABS Label 3642
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3642);
}
selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,
          sqlite3WhereContinueLabel(pWInfo),
          sqlite3WhereBreakLabel(pWInfo));

      /* End the database scan loop.
      */
      SELECTTRACE(1,pParse,p,("WhereEnd\n"));
      
// ABS Label 3643
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3643);
}
sqlite3WhereEnd(pWInfo);
    }
  }else{
    /* This case when there exist aggregate functions or a GROUP BY clause
    ** or both */
    NameContext sNC;    /* Name context for processing aggregate information */
    int iAMem;          /* First Mem address for storing current GROUP BY */
    int iBMem;          /* First Mem address for previous GROUP BY */
    int iUseFlag;       /* Mem address holding flag indicating that at least
                        ** one row of the input to the aggregator has been
                        ** processed */
    int iAbortFlag;     /* Mem address which causes query abort if positive */
    int groupBySort;    /* Rows come from source in GROUP BY order */
    int addrEnd;        /* End of processing for this SELECT */
    int sortPTab = 0;   /* Pseudotable used to decode sorting results */
    int sortOut = 0;    /* Output register from the sorter */
    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */

    /* Remove any and all aliases between the result set and the
    ** GROUP BY clause.
    */
    
// ABS Label 3648
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3648);
}
if( pGroupBy ){
      int k;                        /* Loop counter */
      struct ExprList_item *pItem;  /* For looping over expression in a list */

      k = p->pEList->nExpr , pItem = p->pEList->a;

// ABS Label 3649
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3649);
}

// ROR Label 3650
if((k <= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3650);
}
// ROR Label 3651
if((k < 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3651);
}
// ROR Label 3652
if((k >= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3652);
}
for(; k>0; k--, pItem++){
        pItem->u.x.iAlias = 0;
      };
// ABS Label 3653
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3653);
}

// ROR Label 3654
if((k <= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3654);
}
// ROR Label 3655
if((k < 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3655);
}
// ROR Label 3656
if((k >= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3656);
}

      k = pGroupBy->nExpr , pItem = pGroupBy->a;

// ABS Label 3657
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3657);
}

// ROR Label 3658
if((k <= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3658);
}
// ROR Label 3659
if((k < 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3659);
}
// ROR Label 3660
if((k >= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3660);
}
for(; k>0; k--, pItem++){
        pItem->u.x.iAlias = 0;
      };
// ABS Label 3661
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3661);
}

// ROR Label 3662
if((k <= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3662);
}
// ROR Label 3663
if((k < 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3663);
}
// ROR Label 3664
if((k >= 0) != (k > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3664);
}

      assert( 66==sqlite3LogEst(100) );
      
// ROR Label 3665
if((p->nSelectRow <= 66) != (p->nSelectRow > 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3665);
}
// ROR Label 3666
if((p->nSelectRow < 66) != (p->nSelectRow > 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3666);
}
// ROR Label 3667
if((p->nSelectRow >= 66) != (p->nSelectRow > 66))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3667);
}
if( p->nSelectRow>66 ) { p->nSelectRow = 66;
}

      /* If there is both a GROUP BY and an ORDER BY clause and they are
      ** identical, then it may be possible to disable the ORDER BY clause 
      ** on the grounds that the GROUP BY will cause elements to come out 
      ** in the correct order. It also may not - the GROUP BY might use a
      ** database index that causes rows to be grouped together as required
      ** but not actually sorted. Either way, record the fact that the
      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp
      ** variable.  */
      
// ABS Label 3668
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3668);
}
// ABS Label 3669
if(sSort.pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3669);
}
// ABS Label 3670
if(sSort.pOrderBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3670);
}

// COR Label 3671
if((sSort.pOrderBy || pGroupBy->nExpr == sSort.pOrderBy->nExpr) != (sSort.pOrderBy && pGroupBy->nExpr == sSort.pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3671);
}

// ROR Label 3672
if((pGroupBy->nExpr != sSort.pOrderBy->nExpr) != (pGroupBy->nExpr == sSort.pOrderBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3672);
}

// MCC Label 3673
if(sSort.pOrderBy && pGroupBy->nExpr == sSort.pOrderBy->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3673);
}
// MCC Label 3674
if(sSort.pOrderBy && !(pGroupBy->nExpr == sSort.pOrderBy->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3674);
}
// MCC Label 3675
if(!(sSort.pOrderBy) && pGroupBy->nExpr == sSort.pOrderBy->nExpr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3675);
}
// MCC Label 3676
if(!(sSort.pOrderBy) && !(pGroupBy->nExpr == sSort.pOrderBy->nExpr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3676);
}
if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){
        int ii;
        /* The GROUP BY processing doesn't care whether rows are delivered in
        ** ASC or DESC order - only that each group is returned contiguously.
        ** So set the ASC/DESC flags in the GROUP BY to match those in the 
        ** ORDER BY to maximize the chances of rows being delivered in an 
        ** order that makes the ORDER BY redundant.  */
        ii = 0;

// ABS Label 3677
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3677);
}
// ABS Label 3678
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3678);
}

// ROR Label 3679
if((ii <= pGroupBy->nExpr) != (ii < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3679);
}
// ROR Label 3680
if((ii > pGroupBy->nExpr) != (ii < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3680);
}
// ROR Label 3681
if((ii >= pGroupBy->nExpr) != (ii < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3681);
}
for(; ii<pGroupBy->nExpr; ii++){
          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;
          pGroupBy->a[ii].sortFlags = sortFlags;
        };
// ABS Label 3682
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3682);
}
// ABS Label 3683
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3683);
}

// ROR Label 3684
if((ii <= pGroupBy->nExpr) != (ii < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3684);
}
// ROR Label 3685
if((ii > pGroupBy->nExpr) != (ii < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3685);
}
// ROR Label 3686
if((ii >= pGroupBy->nExpr) != (ii < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3686);
}

        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){
          orderByGrp = 1;
        }
      }
    }else{
      assert( 0==sqlite3LogEst(1) );
      p->nSelectRow = 0;
    }

    /* Create a label to jump to when we want to abort the query */
    addrEnd = sqlite3VdbeMakeLabel(pParse);

    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in
    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the
    ** SELECT statement.
    */
    pAggInfo = sqlite3DbMallocZero(db, sizeof(*pAggInfo) );
    
// ABS Label 3687
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3687);
}
if( pAggInfo ){
      
// ABS Label 3688
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3688);
}
sqlite3ParserAddCleanup(pParse,
          (void(*)(sqlite3*,void*))agginfoFree, pAggInfo);
      testcase( pParse->earlyCleanup );
    }
    
// ABS Label 3689
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3689);
}
if( db->mallocFailed ){
      goto select_end;
    }
    pAggInfo->selId = p->selId;
    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    sNC.uNC.pAggInfo = pAggInfo;
    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )
    pAggInfo->mnReg = pParse->nMem+1;
    pAggInfo->nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;
    pAggInfo->pGroupBy = pGroupBy;
    
// ABS Label 3644
if(pEList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3644);
}
sqlite3ExprAnalyzeAggList(&sNC, pEList);
    
// ABS Label 3645
if(sSort.pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3645);
}
sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);
    
// ABS Label 3690
if(pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3690);
}
if( pHaving ){
      
// ABS Label 3692
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3692);
}
if( pGroupBy ){
        assert( pWhere==p->pWhere );
        assert( pHaving==p->pHaving );
        assert( pGroupBy==p->pGroupBy );
        
// ABS Label 3693
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3693);
}

// ABS Label 3694
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3694);
}
havingToWhere(pParse, p);
        pWhere = p->pWhere;
      }
      
// ABS Label 3691
if(pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3691);
}
sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
    }
    pAggInfo->nAccumulator = pAggInfo->nColumn;
    
// ABS Label 3695
if(p->pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3695);
}
// ABS Label 3696
if(p->pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3696);
}
// ABS Label 3697
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3697);
}

// COR Label 3698
if((p->pGroupBy == 0 && p->pHaving == 0 || pAggInfo->nFunc == 1) != (p->pGroupBy == 0 && p->pHaving == 0 && pAggInfo->nFunc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3698);
}
// COR Label 3699
if((p->pGroupBy == 0 || p->pHaving == 0) != (p->pGroupBy == 0 && p->pHaving == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3699);
}

// ROR Label 3700
if((p->pGroupBy != 0) != (p->pGroupBy == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3700);
}
// ROR Label 3701
if((p->pHaving != 0) != (p->pHaving == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3701);
}
// ROR Label 3702
if((pAggInfo->nFunc != 1) != (pAggInfo->nFunc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3702);
}

// MCC Label 3703
if(p->pGroupBy == 0 && p->pHaving == 0 && pAggInfo->nFunc == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3703);
}
// MCC Label 3704
if(p->pGroupBy == 0 && p->pHaving == 0 && !(pAggInfo->nFunc == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3704);
}
// MCC Label 3705
if(p->pGroupBy == 0 && !(p->pHaving == 0) && pAggInfo->nFunc == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3705);
}
// MCC Label 3706
if(p->pGroupBy == 0 && !(p->pHaving == 0) && !(pAggInfo->nFunc == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3706);
}
// MCC Label 3707
if(!(p->pGroupBy == 0) && p->pHaving == 0 && pAggInfo->nFunc == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3707);
}
// MCC Label 3708
if(!(p->pGroupBy == 0) && p->pHaving == 0 && !(pAggInfo->nFunc == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3708);
}
// MCC Label 3709
if(!(p->pGroupBy == 0) && !(p->pHaving == 0) && pAggInfo->nFunc == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3709);
}
// MCC Label 3710
if(!(p->pGroupBy == 0) && !(p->pHaving == 0) && !(pAggInfo->nFunc == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3710);
}
if( p->pGroupBy==0 && p->pHaving==0 && pAggInfo->nFunc==1 ){
      minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);
    }else{
      minMaxFlag = WHERE_ORDERBY_NORMAL;
    }
    i = 0;

// ABS Label 3711
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3711);
}
// ABS Label 3712
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3712);
}

// ROR Label 3713
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3713);
}
// ROR Label 3714
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3714);
}
// ROR Label 3715
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3715);
}
for(; i<pAggInfo->nFunc; i++){
      
// ABS Label 3721
if(pAggInfo->aFunc[i].pFExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3721);
}
Expr *pExpr = pAggInfo->aFunc[i].pFExpr;
      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );
      sNC.ncFlags |= NC_InAggFunc;
      
// ABS Label 3722
if(pExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3722);
}
sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
      assert( !IsWindowFunc(pExpr) );
      
// MCC Label 3723
if(( ((pExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3723);
}
// MCC Label 3724
if(( !(((pExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3724);
}
if( ExprHasProperty(pExpr, EP_WinFunc) ){
        
// ABS Label 3725
if(pExpr->y.pWin->pFilter < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3725);
}
sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);
      }
#endif
      sNC.ncFlags &= ~NC_InAggFunc;
    };
// ABS Label 3716
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3716);
}
// ABS Label 3717
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3717);
}

// ROR Label 3718
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3718);
}
// ROR Label 3719
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3719);
}
// ROR Label 3720
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3720);
}

    pAggInfo->mxReg = pParse->nMem;
    
// ABS Label 3726
if(db->mallocFailed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3726);
}
if( db->mallocFailed ) { goto select_end;
}
#if SELECTTRACE_ENABLED
    if( sqlite3SelectTrace & 0x400 ){
      int ii;
      SELECTTRACE(0x400,pParse,p,("After aggregate analysis %p:\n", pAggInfo));
      sqlite3TreeViewSelect(0, p, 0);
      if( minMaxFlag ){
        sqlite3DebugPrintf("MIN/MAX Optimization (0x%02x) adds:\n", minMaxFlag);
        sqlite3TreeViewExprList(0, pMinMaxOrderBy, 0, "ORDERBY");
      }
      for(ii=0; ii<pAggInfo->nColumn; ii++){
        sqlite3DebugPrintf("agg-column[%d] iMem=%d\n",
            ii, pAggInfo->aCol[ii].iMem);
        sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pCExpr, 0);
      }
      for(ii=0; ii<pAggInfo->nFunc; ii++){
        sqlite3DebugPrintf("agg-func[%d]: iMem=%d\n",
            ii, pAggInfo->aFunc[ii].iMem);
        sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pFExpr, 0);
      }
    }
#endif


    /* Processing for aggregates with GROUP BY is very different and
    ** much more complex than aggregates without a GROUP BY.
    */
    
// ABS Label 3727
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3727);
}
if( pGroupBy ){
      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */
      int addr1;          /* A-vs-B comparision jump */
      int addrOutputRow;  /* Start of subroutine that outputs a result row */
      int regOutputRow;   /* Return address register for output subroutine */
      int addrSetAbort;   /* Set the abort flag and return */
      int addrTopOfLoop;  /* Top of the input loop */
      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */
      int addrReset;      /* Subroutine for resetting the accumulator */
      int regReset;       /* Return address register for reset subroutine */
      ExprList *pDistinct = 0;
      u16 distFlag = 0;
      int eDist = WHERE_DISTINCT_NOOP;

      
// ABS Label 3824
if(pAggInfo->aFunc[0].iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3824);
}
// ABS Label 3825
if(pAggInfo->aFunc[0].pFExpr->x.pList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3825);
}
// ABS Label 3826
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3826);
}

// COR Label 3827
if((pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 || pAggInfo->aFunc[0].pFExpr->x.pList) != (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 && pAggInfo->aFunc[0].pFExpr->x.pList))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3827);
}
// COR Label 3828
if((pAggInfo->nFunc == 1 || pAggInfo->aFunc[0].iDistinct >= 0) != (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3828);
}

// ROR Label 3829
if((pAggInfo->nFunc != 1) != (pAggInfo->nFunc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3829);
}
// ROR Label 3830
if((pAggInfo->aFunc[0].iDistinct < 0) != (pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3830);
}
// ROR Label 3831
if((pAggInfo->aFunc[0].iDistinct > 0) != (pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3831);
}
// ROR Label 3832
if((pAggInfo->aFunc[0].iDistinct <= 0) != (pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3832);
}

// MCC Label 3833
if(pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 && pAggInfo->aFunc[0].pFExpr->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3833);
}
// MCC Label 3834
if(pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 && !(pAggInfo->aFunc[0].pFExpr->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3834);
}
// MCC Label 3835
if(pAggInfo->nFunc == 1 && !(pAggInfo->aFunc[0].iDistinct >= 0) && pAggInfo->aFunc[0].pFExpr->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3835);
}
// MCC Label 3836
if(pAggInfo->nFunc == 1 && !(pAggInfo->aFunc[0].iDistinct >= 0) && !(pAggInfo->aFunc[0].pFExpr->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3836);
}
// MCC Label 3837
if(!(pAggInfo->nFunc == 1) && pAggInfo->aFunc[0].iDistinct >= 0 && pAggInfo->aFunc[0].pFExpr->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3837);
}
// MCC Label 3838
if(!(pAggInfo->nFunc == 1) && pAggInfo->aFunc[0].iDistinct >= 0 && !(pAggInfo->aFunc[0].pFExpr->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3838);
}
// MCC Label 3839
if(!(pAggInfo->nFunc == 1) && !(pAggInfo->aFunc[0].iDistinct >= 0) && pAggInfo->aFunc[0].pFExpr->x.pList ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3839);
}
// MCC Label 3840
if(!(pAggInfo->nFunc == 1) && !(pAggInfo->aFunc[0].iDistinct >= 0) && !(pAggInfo->aFunc[0].pFExpr->x.pList) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3840);
}
if( pAggInfo->nFunc==1 
       && pAggInfo->aFunc[0].iDistinct>=0
       && pAggInfo->aFunc[0].pFExpr->x.pList
      ){
        
// ABS Label 3841
if(pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3841);
}
Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);
        pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);
        distFlag = pDistinct ? (WHERE_WANT_DISTINCT|WHERE_AGG_DISTINCT) : 0;
      }

      /* If there is a GROUP BY clause we might need a sorting index to
      ** implement it.  Allocate that sorting index now.  If it turns out
      ** that we do not need it after all, the OP_SorterOpen instruction
      ** will be converted into a Noop.  
      */
      pAggInfo->sortingIdx = pParse->nTab++;
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy,
                                            0, pAggInfo->nColumn);
      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, 
          pAggInfo->sortingIdx, pAggInfo->nSortingColumn, 
          0, (char*)pKeyInfo, P4_KEYINFO);

      /* Initialize memory locations used by GROUP BY aggregate processing
      */
      iUseFlag = ++pParse->nMem;
      iAbortFlag = ++pParse->nMem;
      regOutputRow = ++pParse->nMem;
      addrOutputRow = sqlite3VdbeMakeLabel(pParse);
      regReset = ++pParse->nMem;
      addrReset = sqlite3VdbeMakeLabel(pParse);
      iAMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      iBMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      
// ABS Label 3728
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3728);
}

// ABS Label 3729
if(iAbortFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3729);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);
      VdbeComment((v, "clear abort flag"));
      
// ABS Label 3730
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3730);
}

// ABS Label 3731
if(iAMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3731);
}

// ABS Label 3732
if(iAMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3732);
}
// ABS Label 3733
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3733);
}

// AOR Label 3734
if(iAMem + pGroupBy->nExpr / 1 != iAMem + pGroupBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3734);
}
// AOR Label 3735
if(iAMem + pGroupBy->nExpr + 1 != iAMem + pGroupBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3735);
}
// AOR Label 3736
if(iAMem + pGroupBy->nExpr * 1 != iAMem + pGroupBy->nExpr - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3736);
}
// AOR Label 3737
if(iAMem - pGroupBy->nExpr != iAMem + pGroupBy->nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3737);
}
// AOR Label 3738
if(iAMem / pGroupBy->nExpr != iAMem + pGroupBy->nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3738);
}
// AOR Label 3739
if(iAMem * pGroupBy->nExpr != iAMem + pGroupBy->nExpr)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3739);
}
sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);

      /* Begin a loop that will extract all source rows in GROUP BY order.
      ** This might involve two separate loops with an OP_Sort in between, or
      ** it might be a single loop that uses an index to extract information
      ** in the right order to begin with.
      */
      
// ABS Label 3740
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3740);
}

// ABS Label 3741
if(regReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3741);
}

// ABS Label 3742
if(addrReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3742);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
      SELECTTRACE(1,pParse,p,("WhereBegin\n"));
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct,
          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0) | distFlag, 0
      );
      
// ABS Label 3842
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3842);
}

// ROR Label 3843
if((pWInfo != 0) != (pWInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3843);
}
if( pWInfo==0 ){
        
// ABS Label 3844
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3844);
}

// ABS Label 3845
if(pDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3845);
}
sqlite3ExprListDelete(db, pDistinct);
        goto select_end;
      }
      eDist = sqlite3WhereIsDistinct(pWInfo);
      SELECTTRACE(1,pParse,p,("WhereBegin returns\n"));
      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){
        /* The optimizer is able to deliver rows in group by order so
        ** we do not have to sort.  The OP_OpenEphemeral table will be
        ** cancelled later because we still need to use the pKeyInfo
        */
        groupBySort = 0;
      }else{
        /* Rows are coming out in undetermined order.  We have to push
        ** each row into a sorting index, terminate the first loop,
        ** then loop over the sorting index in order to get the output
        ** in sorted order
        */
        int regBase;
        int regRecord;
        int nCol;
        int nGroupBy;

        
// ABS Label 3846
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3846);
}
explainTempTable(pParse, 
            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?
                    "DISTINCT" : "GROUP BY");

        groupBySort = 1;
        nGroupBy = pGroupBy->nExpr;
        nCol = nGroupBy;
        j = nGroupBy;
        i = 0;

// ABS Label 3870
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3870);
}
// ABS Label 3871
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3871);
}

// ROR Label 3872
if((i <= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3872);
}
// ROR Label 3873
if((i > pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3873);
}
// ROR Label 3874
if((i >= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3874);
}
for(; i<pAggInfo->nColumn; i++){
          
// ABS Label 3880
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3880);
}

// ROR Label 3881
if((pAggInfo->aCol[i].iSorterColumn < j) != (pAggInfo->aCol[i].iSorterColumn >= j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3881);
}
// ROR Label 3882
if((pAggInfo->aCol[i].iSorterColumn > j) != (pAggInfo->aCol[i].iSorterColumn >= j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3882);
}
// ROR Label 3883
if((pAggInfo->aCol[i].iSorterColumn <= j) != (pAggInfo->aCol[i].iSorterColumn >= j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3883);
}
if( pAggInfo->aCol[i].iSorterColumn>=j ){
            nCol++;
            j++;
          }
        };
// ABS Label 3875
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3875);
}
// ABS Label 3876
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3876);
}

// ROR Label 3877
if((i <= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3877);
}
// ROR Label 3878
if((i > pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3878);
}
// ROR Label 3879
if((i >= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3879);
}

        regBase = sqlite3GetTempRange(pParse, nCol);
        
// ABS Label 3847
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3847);
}

// ABS Label 3848
if(pGroupBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3848);
}

// ABS Label 3849
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3849);
}
sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
        j = nGroupBy;
        i = 0;

// ABS Label 3884
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3884);
}
// ABS Label 3885
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3885);
}

// ROR Label 3886
if((i <= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3886);
}
// ROR Label 3887
if((i > pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3887);
}
// ROR Label 3888
if((i >= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3888);
}
for(; i<pAggInfo->nColumn; i++){
          struct AggInfo_col *pCol = &pAggInfo->aCol[i];
          
// ABS Label 3894
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3894);
}

// ROR Label 3895
if((pCol->iSorterColumn < j) != (pCol->iSorterColumn >= j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3895);
}
// ROR Label 3896
if((pCol->iSorterColumn > j) != (pCol->iSorterColumn >= j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3896);
}
// ROR Label 3897
if((pCol->iSorterColumn <= j) != (pCol->iSorterColumn >= j))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3897);
}
if( pCol->iSorterColumn>=j ){
            
// ABS Label 3898
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3898);
}
// ABS Label 3899
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3899);
}

// AOR Label 3900
if(j - regBase != j + regBase)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3900);
}
// AOR Label 3901
if(j / regBase != j + regBase)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3901);
}
// AOR Label 3902
if(j * regBase != j + regBase)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3902);
}
int r1 = j + regBase;
            
// ABS Label 3903
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3903);
}

// ABS Label 3904
if(pCol->pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3904);
}

// ABS Label 3905
if(pCol->iTable < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3905);
}

// ABS Label 3906
if(r1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3906);
}
sqlite3ExprCodeGetColumnOfTable(v,
                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);
            j++;
          }
        };
// ABS Label 3889
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3889);
}
// ABS Label 3890
if(pAggInfo->nColumn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3890);
}

// ROR Label 3891
if((i <= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3891);
}
// ROR Label 3892
if((i > pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3892);
}
// ROR Label 3893
if((i >= pAggInfo->nColumn) != (i < pAggInfo->nColumn))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3893);
}

        regRecord = sqlite3GetTempReg(pParse);
        
// ABS Label 3850
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3850);
}

// ABS Label 3851
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3851);
}

// ABS Label 3852
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3852);
}

// ABS Label 3853
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3853);
}
sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);
        
// ABS Label 3854
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3854);
}

// ABS Label 3855
if(pAggInfo->sortingIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3855);
}

// ABS Label 3856
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3856);
}
sqlite3VdbeAddOp2(v, OP_SorterInsert, pAggInfo->sortingIdx, regRecord);
        
// ABS Label 3857
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3857);
}

// ABS Label 3858
if(regRecord < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3858);
}
sqlite3ReleaseTempReg(pParse, regRecord);
        
// ABS Label 3859
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3859);
}

// ABS Label 3860
if(regBase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3860);
}

// ABS Label 3861
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3861);
}
sqlite3ReleaseTempRange(pParse, regBase, nCol);
        SELECTTRACE(1,pParse,p,("WhereEnd\n"));
        
// ABS Label 3862
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3862);
}
sqlite3WhereEnd(pWInfo);
        pAggInfo->sortingIdxPTab = sortPTab = pParse->nTab++;
        sortOut = sqlite3GetTempReg(pParse);
        
// ABS Label 3863
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3863);
}

// ABS Label 3864
if(sortPTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3864);
}

// ABS Label 3865
if(sortOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3865);
}

// ABS Label 3866
if(nCol < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3866);
}
sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);
        
// ABS Label 3867
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3867);
}

// ABS Label 3868
if(pAggInfo->sortingIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3868);
}

// ABS Label 3869
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3869);
}
sqlite3VdbeAddOp2(v, OP_SorterSort, pAggInfo->sortingIdx, addrEnd);
        VdbeComment((v, "GROUP BY sort")); VdbeCoverage(v);
        pAggInfo->useSortingIdx = 1;
      }

      /* If the index or temporary table used by the GROUP BY sort
      ** will naturally deliver rows in the order required by the ORDER BY
      ** clause, cancel the ephemeral table open coded earlier.
      **
      ** This is an optimization - the correct answer should result regardless.
      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to 
      ** disable this optimization for testing purposes.  */
      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) 
       && (groupBySort || sqlite3WhereIsSorted(pWInfo))
      ){
        sSort.pOrderBy = 0;
        
// ABS Label 3907
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3907);
}

// ABS Label 3908
if(sSort.addrSortIndex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3908);
}
sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
      }

      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...
      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)
      ** Then compare the current GROUP BY terms against the GROUP BY terms
      ** from the previous row currently stored in a0, a1, a2...
      */
      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
      
// ABS Label 3909
if(groupBySort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3909);
}
if( groupBySort ){
        
// ABS Label 3910
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3910);
}

// ABS Label 3911
if(pAggInfo->sortingIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3911);
}

// ABS Label 3912
if(sortOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3912);
}

// ABS Label 3913
if(sortPTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3913);
}
sqlite3VdbeAddOp3(v, OP_SorterData, pAggInfo->sortingIdx,
                          sortOut, sortPTab);
      }
      j = 0;

// ABS Label 3914
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3914);
}
// ABS Label 3915
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3915);
}

// ROR Label 3916
if((j <= pGroupBy->nExpr) != (j < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3916);
}
// ROR Label 3917
if((j > pGroupBy->nExpr) != (j < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3917);
}
// ROR Label 3918
if((j >= pGroupBy->nExpr) != (j < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3918);
}
for(; j<pGroupBy->nExpr; j++){
        
// ABS Label 3924
if(groupBySort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3924);
}
if( groupBySort ){
          
// ABS Label 3925
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3925);
}

// ABS Label 3926
if(sortPTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3926);
}

// ABS Label 3927
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3927);
}

// ABS Label 3928
if(iBMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3928);
}
// ABS Label 3929
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3929);
}

// AOR Label 3930
if(iBMem - j != iBMem + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3930);
}
// AOR Label 3931
if(iBMem / j != iBMem + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3931);
}
// AOR Label 3932
if(iBMem * j != iBMem + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3932);
}
sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);
        }else{
          pAggInfo->directMode = 1;
          
// ABS Label 3933
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3933);
}

// ABS Label 3934
if(pGroupBy->a[j].pExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3934);
}

// ABS Label 3935
if(iBMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3935);
}
// ABS Label 3936
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3936);
}

// AOR Label 3937
if(iBMem - j != iBMem + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3937);
}
// AOR Label 3938
if(iBMem / j != iBMem + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3938);
}
// AOR Label 3939
if(iBMem * j != iBMem + j)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3939);
}
sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);
        }
      };
// ABS Label 3919
if(j < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3919);
}
// ABS Label 3920
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3920);
}

// ROR Label 3921
if((j <= pGroupBy->nExpr) != (j < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3921);
}
// ROR Label 3922
if((j > pGroupBy->nExpr) != (j < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3922);
}
// ROR Label 3923
if((j >= pGroupBy->nExpr) != (j < pGroupBy->nExpr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3923);
}

      
// ABS Label 3743
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3743);
}

// ABS Label 3744
if(iAMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3744);
}

// ABS Label 3745
if(iBMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3745);
}

// ABS Label 3746
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3746);
}
sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,
                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);
      addr1 = sqlite3VdbeCurrentAddr(v);
      
// ABS Label 3747
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3747);
}

// ABS Label 3748
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3748);
}

// AOR Label 3749
if(addr1 - 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3749);
}
// AOR Label 3750
if(addr1 / 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3750);
}
// AOR Label 3751
if(addr1 * 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3751);
}

// ABS Label 3752
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3752);
}

// AOR Label 3753
if(addr1 - 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3753);
}
// AOR Label 3754
if(addr1 / 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3754);
}
// AOR Label 3755
if(addr1 * 1 != addr1 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3755);
}
sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);

      /* Generate code that runs whenever the GROUP BY changes.
      ** Changes in the GROUP BY are detected by the previous code
      ** block.  If there were no changes, this block is skipped.
      **
      ** This code copies current group by terms in b0,b1,b2,...
      ** over to a0,a1,a2.  It then calls the output subroutine
      ** and resets the aggregate accumulator registers in preparation
      ** for the next GROUP BY batch.
      */
      
// ABS Label 3756
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3756);
}

// ABS Label 3757
if(iBMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3757);
}

// ABS Label 3758
if(iAMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3758);
}

// ABS Label 3759
if(pGroupBy->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3759);
}
sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
      
// ABS Label 3760
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3760);
}

// ABS Label 3761
if(regOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3761);
}

// ABS Label 3762
if(addrOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3762);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);
      VdbeComment((v, "output one row"));
      
// ABS Label 3763
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3763);
}

// ABS Label 3764
if(iAbortFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3764);
}

// ABS Label 3765
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3765);
}
sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);
      VdbeComment((v, "check abort flag"));
      
// ABS Label 3766
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3766);
}

// ABS Label 3767
if(regReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3767);
}

// ABS Label 3768
if(addrReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3768);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
      VdbeComment((v, "reset accumulator"));

      /* Update the aggregate accumulators based on the content of
      ** the current row
      */
      
// ABS Label 3769
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3769);
}

// ABS Label 3770
if(addr1 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3770);
}
sqlite3VdbeJumpHere(v, addr1);
      
// ABS Label 3771
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3771);
}

// ABS Label 3772
if(iUseFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3772);
}

// ABS Label 3773
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3773);
}

// ABS Label 3774
if(eDist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3774);
}
updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);
      
// ABS Label 3775
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3775);
}

// ABS Label 3776
if(iUseFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3776);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);
      VdbeComment((v, "indicate data in accumulator"));

      /* End of the loop
      */
      
// ABS Label 3940
if(groupBySort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3940);
}
if( groupBySort ){
        
// ABS Label 3941
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3941);
}

// ABS Label 3942
if(pAggInfo->sortingIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3942);
}

// ABS Label 3943
if(addrTopOfLoop < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3943);
}
sqlite3VdbeAddOp2(v, OP_SorterNext, pAggInfo->sortingIdx,addrTopOfLoop);
        VdbeCoverage(v);
      }else{
        SELECTTRACE(1,pParse,p,("WhereEnd\n"));
        
// ABS Label 3944
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3944);
}
sqlite3WhereEnd(pWInfo);
        
// ABS Label 3945
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3945);
}

// ABS Label 3946
if(addrSortingIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3946);
}
sqlite3VdbeChangeToNoop(v, addrSortingIdx);
      }
      
// ABS Label 3777
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3777);
}

// ABS Label 3778
if(pDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3778);
}
sqlite3ExprListDelete(db, pDistinct);

      /* Output the final row of result
      */
      
// ABS Label 3779
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3779);
}

// ABS Label 3780
if(regOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3780);
}

// ABS Label 3781
if(addrOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3781);
}
sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);
      VdbeComment((v, "output final row"));

      /* Jump over the subroutines
      */
      
// ABS Label 3782
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3782);
}

// ABS Label 3783
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3783);
}
sqlite3VdbeGoto(v, addrEnd);

      /* Generate a subroutine that outputs a single row of the result
      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag
      ** is less than or equal to zero, the subroutine is a no-op.  If
      ** the processing calls for the query to abort, this subroutine
      ** increments the iAbortFlag memory location before returning in
      ** order to signal the caller to abort.
      */
      addrSetAbort = sqlite3VdbeCurrentAddr(v);
      
// ABS Label 3784
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3784);
}

// ABS Label 3785
if(iAbortFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3785);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);
      VdbeComment((v, "set abort flag"));
      
// ABS Label 3786
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3786);
}

// ABS Label 3787
if(regOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3787);
}
sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
      
// ABS Label 3788
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3788);
}

// ABS Label 3789
if(addrOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3789);
}
sqlite3VdbeResolveLabel(v, addrOutputRow);
      addrOutputRow = sqlite3VdbeCurrentAddr(v);
      
// ABS Label 3790
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3790);
}

// ABS Label 3791
if(iUseFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3791);
}

// ABS Label 3792
if(addrOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3792);
}

// AOR Label 3793
if(addrOutputRow - 2 != addrOutputRow + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3793);
}
// AOR Label 3794
if(addrOutputRow / 2 != addrOutputRow + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3794);
}
// AOR Label 3795
if(addrOutputRow * 2 != addrOutputRow + 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3795);
}
sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);
      VdbeCoverage(v);
      VdbeComment((v, "Groupby result generator entry point"));
      
// ABS Label 3796
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3796);
}

// ABS Label 3797
if(regOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3797);
}
sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
      
// ABS Label 3798
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3798);
}

// ABS Label 3799
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3799);
}
finalizeAggFunctions(pParse, pAggInfo);
      
// ABS Label 3800
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3800);
}

// ABS Label 3801
if(pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3801);
}

// ABS Label 3802
if(addrOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3802);
}

// AOR Label 3803
if(addrOutputRow - 1 != addrOutputRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3803);
}
// AOR Label 3804
if(addrOutputRow / 1 != addrOutputRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3804);
}
// AOR Label 3805
if(addrOutputRow * 1 != addrOutputRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3805);
}
sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);
      
// ABS Label 3806
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3806);
}

// ABS Label 3807
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3807);
}

// ABS Label 3808
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3808);
}

// ABS Label 3809
if(addrOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3809);
}

// AOR Label 3810
if(addrOutputRow - 1 != addrOutputRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3810);
}
// AOR Label 3811
if(addrOutputRow / 1 != addrOutputRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3811);
}
// AOR Label 3812
if(addrOutputRow * 1 != addrOutputRow + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 3812);
}

// ABS Label 3813
if(addrSetAbort < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3813);
}
selectInnerLoop(pParse, p, -1, &sSort,
                      &sDistinct, pDest,
                      addrOutputRow+1, addrSetAbort);
      
// ABS Label 3814
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3814);
}

// ABS Label 3815
if(regOutputRow < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3815);
}
sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);
      VdbeComment((v, "end groupby result generator"));

      /* Generate a subroutine that will reset the group-by accumulator
      */
      
// ABS Label 3816
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3816);
}

// ABS Label 3817
if(addrReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3817);
}
sqlite3VdbeResolveLabel(v, addrReset);
      
// ABS Label 3818
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3818);
}

// ABS Label 3819
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3819);
}
resetAccumulator(pParse, pAggInfo);
      
// ABS Label 3820
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3820);
}

// ABS Label 3821
if(iUseFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3821);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);
      VdbeComment((v, "indicate accumulator empty"));
      
// ABS Label 3822
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3822);
}

// ABS Label 3823
if(regReset < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3823);
}
sqlite3VdbeAddOp1(v, OP_Return, regReset);

      
// ABS Label 3947
if(eDist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3947);
}

// ROR Label 3948
if((eDist == 0) != (eDist != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3948);
}
if( eDist!=WHERE_DISTINCT_NOOP ){
        struct AggInfo_func *pF = &pAggInfo->aFunc[0];
        
// ABS Label 3949
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3949);
}

// ABS Label 3950
if(eDist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3950);
}

// ABS Label 3951
if(pF->iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3951);
}

// ABS Label 3952
if(pF->iDistAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3952);
}
fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);
      }
    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */
    else {
      Table *pTab;
      if( (pTab = isSimpleCount(p, pAggInfo))!=0 ){
        /* If isSimpleCount() returns a pointer to a Table structure, then
        ** the SQL statement is of the form:
        **
        **   SELECT count(*) FROM <tbl>
        **
        ** where the Table structure returned represents table <tbl>.
        **
        ** This statement is so common that it is optimized specially. The
        ** OP_Count instruction is executed either on the intkey table that
        ** contains the data for table <tbl> or on one of its indexes. It
        ** is better to execute the op on an index, as indexes are almost
        ** always spread across less pages than their corresponding tables.
        */
        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */
        Index *pIdx;                         /* Iterator variable */
        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */
        Index *pBest = 0;                    /* Best index found so far */
        
// ABS Label 3961
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3961);
}
Pgno iRoot = pTab->tnum;             /* Root page of scanned b-tree */

        
// ABS Label 3962
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3962);
}

// ABS Label 3963
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3963);
}
sqlite3CodeVerifySchema(pParse, iDb);
        
// ABS Label 3964
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3964);
}

// ABS Label 3965
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3965);
}

// ABS Label 3966
if(pTab->tnum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3966);
}
sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

        /* Search for the index that has the lowest scan cost.
        **
        ** (2011-04-15) Do not do a full scan of an unordered index.
        **
        ** (2013-10-03) Do not count the entries in a partial index.
        **
        ** In practice the KeyInfo structure will not be used. It is only 
        ** passed to keep OP_OpenRead happy.
        */
        if( !HasRowid(pTab) ) { pBest = sqlite3PrimaryKeyIndex(pTab);
}
        if( !p->pSrc->a[0].fg.notIndexed ){
          pIdx = pTab->pIndex;

// ABS Label 3978
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3978);
}
for(; pIdx; pIdx=pIdx->pNext){
            
// ABS Label 3980
if(pIdx->pPartIdxWhere < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3980);
}

// COR Label 3981
if((pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 || (!pBest || pIdx->szIdxRow < pBest->szIdxRow)) != (pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && (!pBest || pIdx->szIdxRow < pBest->szIdxRow)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3981);
}
// COR Label 3982
if((pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow || pIdx->pPartIdxWhere == 0) != (pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3982);
}
// COR Label 3983
if((pIdx->bUnordered == 0 || pIdx->szIdxRow < pTab->szTabRow) != (pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 3983);
}

// ROR Label 3984
if((pIdx->bUnordered != 0) != (pIdx->bUnordered == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3984);
}
// ROR Label 3985
if((pIdx->szIdxRow <= pTab->szTabRow) != (pIdx->szIdxRow < pTab->szTabRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3985);
}
// ROR Label 3986
if((pIdx->szIdxRow > pTab->szTabRow) != (pIdx->szIdxRow < pTab->szTabRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3986);
}
// ROR Label 3987
if((pIdx->szIdxRow >= pTab->szTabRow) != (pIdx->szIdxRow < pTab->szTabRow))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3987);
}
// ROR Label 3988
if((pIdx->pPartIdxWhere != 0) != (pIdx->pPartIdxWhere == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 3988);
}

// MCC Label 3989
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3989);
}
// MCC Label 3990
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3990);
}
// MCC Label 3991
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3991);
}
// MCC Label 3992
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3992);
}
// MCC Label 3993
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3993);
}
// MCC Label 3994
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3994);
}
// MCC Label 3995
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3995);
}
// MCC Label 3996
if(pIdx->bUnordered == 0 && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3996);
}
// MCC Label 3997
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3997);
}
// MCC Label 3998
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3998);
}
// MCC Label 3999
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 3999);
}
// MCC Label 4000
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4000);
}
// MCC Label 4001
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4001);
}
// MCC Label 4002
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4002);
}
// MCC Label 4003
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4003);
}
// MCC Label 4004
if(pIdx->bUnordered == 0 && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4004);
}
// MCC Label 4005
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4005);
}
// MCC Label 4006
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4006);
}
// MCC Label 4007
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4007);
}
// MCC Label 4008
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4008);
}
// MCC Label 4009
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4009);
}
// MCC Label 4010
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4010);
}
// MCC Label 4011
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4011);
}
// MCC Label 4012
if(!(pIdx->bUnordered == 0) && pIdx->szIdxRow < pTab->szTabRow && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4012);
}
// MCC Label 4013
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4013);
}
// MCC Label 4014
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4014);
}
// MCC Label 4015
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4015);
}
// MCC Label 4016
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && pIdx->pPartIdxWhere == 0 && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4016);
}
// MCC Label 4017
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !pBest && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4017);
}
// MCC Label 4018
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !pBest && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4018);
}
// MCC Label 4019
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && pIdx->szIdxRow < pBest->szIdxRow ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4019);
}
// MCC Label 4020
if(!(pIdx->bUnordered == 0) && !(pIdx->szIdxRow < pTab->szTabRow) && !(pIdx->pPartIdxWhere == 0) && ( !(!pBest) && !(pIdx->szIdxRow < pBest->szIdxRow) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4020);
}
if( pIdx->bUnordered==0
             && pIdx->szIdxRow<pTab->szTabRow
             && pIdx->pPartIdxWhere==0
             && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)
            ){
              pBest = pIdx;
            }
          };
// ABS Label 3979
if(pIdx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3979);
}

        }
        
// ABS Label 4021
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4021);
}
if( pBest ){
          iRoot = pBest->tnum;
          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
        }

        /* Open a read-only cursor, execute the OP_Count, close the cursor. */
        
// ABS Label 3967
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3967);
}

// ABS Label 3968
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3968);
}

// ABS Label 3969
if(iDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3969);
}
sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, (int)iRoot, iDb, 1);
        
// ABS Label 4022
if(pKeyInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4022);
}
if( pKeyInfo ){
          
// ABS Label 4023
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4023);
}
sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);
        }
        
// ABS Label 3970
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3970);
}

// ABS Label 3971
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3971);
}

// ABS Label 3972
if(pAggInfo->aFunc[0].iMem < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3972);
}
sqlite3VdbeAddOp2(v, OP_Count, iCsr, pAggInfo->aFunc[0].iMem);
        
// ABS Label 3973
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3973);
}

// ABS Label 3974
if(iCsr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3974);
}
sqlite3VdbeAddOp1(v, OP_Close, iCsr);
        
// ABS Label 3975
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3975);
}

// ABS Label 3976
if(pTab < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3976);
}

// ABS Label 3977
if(pBest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3977);
}
explainSimpleCount(pParse, pTab, pBest);
      }else{
        int regAcc = 0;           /* "populate accumulators" flag */
        ExprList *pDistinct = 0;
        u16 distFlag = 0;
        int eDist;

        /* If there are accumulator registers but no min() or max() functions
        ** without FILTER clauses, allocate register regAcc. Register regAcc
        ** will contain 0 the first time the inner loop runs, and 1 thereafter.
        ** The code generated by updateAccumulator() uses this to ensure
        ** that the accumulator registers are (a) updated only once if
        ** there are no min() or max functions or (b) always updated for the
        ** first row visited by the aggregate, so that they are updated at
        ** least once even if the FILTER clause means the min() or max() 
        ** function visits zero rows.  */
        
// ABS Label 4033
if(pAggInfo->nAccumulator < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4033);
}
if( pAggInfo->nAccumulator ){
          i = 0;

// ABS Label 4034
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4034);
}
// ABS Label 4035
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4035);
}

// ROR Label 4036
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4036);
}
// ROR Label 4037
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4037);
}
// ROR Label 4038
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4038);
}
for(; i<pAggInfo->nFunc; i++){
            
// MCC Label 4044
if(( ((pAggInfo->aFunc[i].pFExpr)->flags & (16777216)) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4044);
}
// MCC Label 4045
if(( !(((pAggInfo->aFunc[i].pFExpr)->flags & (16777216)) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4045);
}
if( ExprHasProperty(pAggInfo->aFunc[i].pFExpr, EP_WinFunc) ){
              continue;
            }
            
// ABS Label 4046
if(pAggInfo->aFunc[i].pFunc->funcFlags < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4046);
}

// AOR Label 4047
if(pAggInfo->aFunc[i].pFunc->funcFlags | 32 != pAggInfo->aFunc[i].pFunc->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 4047);
}
// AOR Label 4048
if(pAggInfo->aFunc[i].pFunc->funcFlags ^ 32 != pAggInfo->aFunc[i].pFunc->funcFlags & 32)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 4048);
}
if( pAggInfo->aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ){
              break;
            }
          };
// ABS Label 4039
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4039);
}
// ABS Label 4040
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4040);
}

// ROR Label 4041
if((i <= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4041);
}
// ROR Label 4042
if((i > pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4042);
}
// ROR Label 4043
if((i >= pAggInfo->nFunc) != (i < pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4043);
}

          
// ABS Label 4049
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4049);
}
// ABS Label 4050
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4050);
}

// ROR Label 4051
if((i != pAggInfo->nFunc) != (i == pAggInfo->nFunc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4051);
}
if( i==pAggInfo->nFunc ){
            regAcc = ++pParse->nMem;
            
// ABS Label 4052
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4052);
}

// ABS Label 4053
if(regAcc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4053);
}
sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);
          }
        }else { 
// ABS Label 4054
if(pAggInfo->aFunc[0].iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4054);
}
// ABS Label 4055
if(pAggInfo->nFunc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4055);
}

// COR Label 4056
if((pAggInfo->nFunc == 1 || pAggInfo->aFunc[0].iDistinct >= 0) != (pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 4056);
}

// ROR Label 4057
if((pAggInfo->nFunc != 1) != (pAggInfo->nFunc == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4057);
}
// ROR Label 4058
if((pAggInfo->aFunc[0].iDistinct < 0) != (pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4058);
}
// ROR Label 4059
if((pAggInfo->aFunc[0].iDistinct > 0) != (pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4059);
}
// ROR Label 4060
if((pAggInfo->aFunc[0].iDistinct <= 0) != (pAggInfo->aFunc[0].iDistinct >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4060);
}

// MCC Label 4061
if(pAggInfo->nFunc == 1 && pAggInfo->aFunc[0].iDistinct >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4061);
}
// MCC Label 4062
if(pAggInfo->nFunc == 1 && !(pAggInfo->aFunc[0].iDistinct >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4062);
}
// MCC Label 4063
if(!(pAggInfo->nFunc == 1) && pAggInfo->aFunc[0].iDistinct >= 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4063);
}
// MCC Label 4064
if(!(pAggInfo->nFunc == 1) && !(pAggInfo->aFunc[0].iDistinct >= 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 4064);
}
if( pAggInfo->nFunc==1 && pAggInfo->aFunc[0].iDistinct>=0 ){
          pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;
          distFlag = pDistinct ? (WHERE_WANT_DISTINCT|WHERE_AGG_DISTINCT) : 0;
        };}


        /* This case runs if the aggregate has no GROUP BY clause.  The
        ** processing is much simpler since there is only a single row
        ** of output.
        */
        assert( p->pGroupBy==0 );
        
// ABS Label 4024
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4024);
}

// ABS Label 4025
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4025);
}
resetAccumulator(pParse, pAggInfo);

        /* If this query is a candidate for the min/max optimization, then
        ** minMaxFlag will have been previously set to either
        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will
        ** be an appropriate ORDER BY expression for the optimization.
        */
        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );
        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );

        SELECTTRACE(1,pParse,p,("WhereBegin\n"));
        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,
                                   pDistinct, minMaxFlag|distFlag, 0);
        
// ABS Label 4065
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4065);
}

// ROR Label 4066
if((pWInfo != 0) != (pWInfo == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4066);
}
if( pWInfo==0 ){
          goto select_end;
        }
        SELECTTRACE(1,pParse,p,("WhereBegin returns\n"));
        eDist = sqlite3WhereIsDistinct(pWInfo);
        
// ABS Label 4026
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4026);
}

// ABS Label 4027
if(regAcc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4027);
}

// ABS Label 4028
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4028);
}

// ABS Label 4029
if(eDist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4029);
}
updateAccumulator(pParse, regAcc, pAggInfo, eDist);
        
// ABS Label 4067
if(eDist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4067);
}

// ROR Label 4068
if((eDist == 0) != (eDist != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4068);
}
if( eDist!=WHERE_DISTINCT_NOOP ){
          struct AggInfo_func *pF = &pAggInfo->aFunc[0];
          
// ABS Label 4069
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4069);
}

// ABS Label 4070
if(eDist < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4070);
}

// ABS Label 4071
if(pF->iDistinct < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4071);
}

// ABS Label 4072
if(pF->iDistAddr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4072);
}
fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);
        }

        
// ABS Label 4073
if(regAcc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4073);
}
if( regAcc ) { 
// ABS Label 4074
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4074);
}

// ABS Label 4075
if(regAcc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4075);
}
sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);
}
        
// ABS Label 4076
if(minMaxFlag < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4076);
}
if( minMaxFlag ){
          
// ABS Label 4077
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4077);
}

// ABS Label 4078
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4078);
}
sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);
        }
        SELECTTRACE(1,pParse,p,("WhereEnd\n"));
        
// ABS Label 4030
if(pWInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4030);
}
sqlite3WhereEnd(pWInfo);
        
// ABS Label 4031
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4031);
}

// ABS Label 4032
if(pAggInfo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4032);
}
finalizeAggFunctions(pParse, pAggInfo);
      }

      sSort.pOrderBy = 0;
      
// ABS Label 3953
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3953);
}

// ABS Label 3954
if(pHaving < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3954);
}

// ABS Label 3955
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3955);
}
sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);
      
// ABS Label 3956
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3956);
}

// ABS Label 3957
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3957);
}

// ABS Label 3958
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3958);
}

// ABS Label 3959
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3959);
}

// ABS Label 3960
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3960);
}
selectInnerLoop(pParse, p, -1, 0, 0, 
                      pDest, addrEnd, addrEnd);
    }
    
// ABS Label 3646
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3646);
}

// ABS Label 3647
if(addrEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3647);
}
sqlite3VdbeResolveLabel(v, addrEnd);
    
  } /* endif aggregate query */

  
// ROR Label 4079
if((sDistinct.eTnctType != 3) != (sDistinct.eTnctType == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 4079);
}
if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){
    
// ABS Label 4080
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4080);
}
explainTempTable(pParse, "DISTINCT");
  }

  /* If there is an ORDER BY clause, then we need to sort the results
  ** and send them to the callback one by one.
  */
  
// ABS Label 4081
if(sSort.pOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4081);
}
if( sSort.pOrderBy ){
    
// ABS Label 4082
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4082);
}
explainTempTable(pParse,
                     sSort.nOBSat>0 ? "RIGHT PART OF ORDER BY":"ORDER BY");
    assert( p->pEList==pEList );
    
// ABS Label 4083
if(pParse < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4083);
}

// ABS Label 4084
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4084);
}

// ABS Label 4085
if(pEList->nExpr < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4085);
}

// ABS Label 4086
if(pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4086);
}
generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);
  }

  /* Jump here to skip this query
  */
  
// ABS Label 3321
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3321);
}

// ABS Label 3322
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3322);
}
sqlite3VdbeResolveLabel(v, iEnd);

  /* The SELECT has been coded. If there is an error in the Parse structure,
  ** set the return code to 1. Otherwise 0. */
  rc = (pParse->nErr>0);

  /* Control jumps to here if an error is encountered above, or upon
  ** successful coding of the SELECT.
  */
select_end:
  assert( db->mallocFailed==0 || db->mallocFailed==1 );
  pParse->nErr += db->mallocFailed;
  
// ABS Label 3323
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3323);
}

// ABS Label 3324
if(pMinMaxOrderBy < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 3324);
}
sqlite3ExprListDelete(db, pMinMaxOrderBy);
#ifdef SQLITE_DEBUG
  if( pAggInfo && !db->mallocFailed ){
    for(i=0; i<pAggInfo->nColumn; i++){
      Expr *pExpr = pAggInfo->aCol[i].pCExpr;
      assert( pExpr!=0 );
      assert( pExpr->pAggInfo==pAggInfo );
      assert( pExpr->iAgg==i );
    }
    for(i=0; i<pAggInfo->nFunc; i++){
      Expr *pExpr = pAggInfo->aFunc[i].pFExpr;
      assert( pExpr!=0 );
      assert( pExpr->pAggInfo==pAggInfo );
      assert( pExpr->iAgg==i );
    }
  }
#endif

#if SELECTTRACE_ENABLED
  SELECTTRACE(0x1,pParse,p,("end processing\n"));
  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif
  ExplainQueryPlanPop(pParse);
  
// ABS Label 4087
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 4087);
}
return rc;
}
