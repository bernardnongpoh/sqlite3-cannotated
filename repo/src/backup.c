/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2009 January 28
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains the implementation of the sqlite3_backup_XXX() 
** API functions and the related features.
*/
#include "sqliteInt.h"
#include "btreeInt.h"

/*
** Structure allocated for each backup operation.
*/
struct sqlite3_backup {
  sqlite3* pDestDb;        /* Destination database handle */
  Btree *pDest;            /* Destination b-tree file */
  u32 iDestSchema;         /* Original schema cookie in destination */
  int bDestLocked;         /* True once a write-transaction is open on pDest */

  Pgno iNext;              /* Page number of the next source page to copy */
  sqlite3* pSrcDb;         /* Source database handle */
  Btree *pSrc;             /* Source b-tree file */

  int rc;                  /* Backup process error code */

  /* These two variables are set by every call to backup_step(). They are
  ** read by calls to backup_remaining() and backup_pagecount().
  */
  Pgno nRemaining;         /* Number of pages left to copy */
  Pgno nPagecount;         /* Total number of pages to copy */

  int isAttached;          /* True once backup has been registered with pager */
  sqlite3_backup *pNext;   /* Next backup associated with source pager */
};

/*
** THREAD SAFETY NOTES:
**
**   Once it has been created using backup_init(), a single sqlite3_backup
**   structure may be accessed via two groups of thread-safe entry points:
**
**     * Via the sqlite3_backup_XXX() API function backup_step() and 
**       backup_finish(). Both these functions obtain the source database
**       handle mutex and the mutex associated with the source BtShared 
**       structure, in that order.
**
**     * Via the BackupUpdate() and BackupRestart() functions, which are
**       invoked by the pager layer to report various state changes in
**       the page cache associated with the source database. The mutex
**       associated with the source database BtShared structure will always 
**       be held when either of these functions are invoked.
**
**   The other sqlite3_backup_XXX() API functions, backup_remaining() and
**   backup_pagecount() are not thread-safe functions. If they are called
**   while some other thread is calling backup_step() or backup_finish(),
**   the values returned may be invalid. There is no way for a call to
**   BackupUpdate() or BackupRestart() to interfere with backup_remaining()
**   or backup_pagecount().
**
**   Depending on the SQLite configuration, the database handles and/or
**   the Btree objects may have their own mutexes that require locking.
**   Non-sharable Btrees (in-memory databases for example), do not have
**   associated mutexes.
*/

/*
** Return a pointer corresponding to database zDb (i.e. "main", "temp")
** in connection handle pDb. If such a database cannot be found, return
** a NULL pointer and write an error message to pErrorDb.
**
** If the "temp" database is requested, it may need to be opened by this 
** function. If an error occurs while doing so, return 0 and write an 
** error message to pErrorDb.
*/
static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){
  int i = sqlite3FindDbName(pDb, zDb);

  
// ABS Label 7
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ROR Label 8
if((i != 1) != (i == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
if( i==1 ){
    Parse sParse;
    int rc = 0;
    memset(&sParse, 0, sizeof(sParse));
    sParse.db = pDb;
    if( sqlite3OpenTempDatabase(&sParse) ){
      
// ABS Label 10
if(pErrorDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 10);
}

// ABS Label 11
if(sParse.rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}

// ABS Label 12
if(sParse.zErrMsg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);
      rc = SQLITE_ERROR;
    }
    
// ABS Label 9
if(pErrorDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}
sqlite3DbFree(pErrorDb, sParse.zErrMsg);
    sqlite3ParserReset(&sParse);
    
// ABS Label 13
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}
if( rc ){
      return 0;
    }
  }

  
// ABS Label 14
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}

// ROR Label 15
if((i <= 0) != (i < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
// ROR Label 16
if((i > 0) != (i < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
// ROR Label 17
if((i >= 0) != (i < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
if( i<0 ){
    
// ABS Label 18
if(pErrorDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

// ABS Label 19
if(zDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
sqlite3ErrorWithMsg(pErrorDb, SQLITE_ERROR, "unknown database %s", zDb);
    return 0;
  }

  
// ABS Label 20
if(pDb->aDb[i].pBt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
return pDb->aDb[i].pBt;
}

/*
** Attempt to set the page size of the destination to match the page size
** of the source.
*/
static int setDestPgsz(sqlite3_backup *p){
  int rc;
  rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),0,0);
  
// ABS Label 21
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}
return rc;
}

/*
** Check that there is no open read-transaction on the b-tree passed as the
** second argument. If there is not, return SQLITE_OK. Otherwise, if there
** is an open read-transaction, return SQLITE_ERROR and leave an error 
** message in database handle db.
*/
static int checkReadTransaction(sqlite3 *db, Btree *p){
  if( sqlite3BtreeTxnState(p)!=SQLITE_TXN_NONE ){
    
// ABS Label 22
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
sqlite3ErrorWithMsg(db, SQLITE_ERROR, "destination database is in use");
    return SQLITE_ERROR;
  }
  return SQLITE_OK;
}

/*
** Create an sqlite3_backup process to copy the contents of zSrcDb from
** connection handle pSrcDb to zDestDb in pDestDb. If successful, return
** a pointer to the new sqlite3_backup object.
**
** If an error occurs, NULL is returned and an error code and error message
** stored in database handle pDestDb.
*/
sqlite3_backup *sqlite3_backup_init(
  sqlite3* pDestDb,                     /* Database to write to */
  const char *zDestDb,                  /* Name of database within pDestDb */
  sqlite3* pSrcDb,                      /* Database connection to read from */
  const char *zSrcDb                    /* Name of database within pSrcDb */
){
  sqlite3_backup *p;                    /* Value to return */

#ifdef SQLITE_ENABLE_API_ARMOR
  if( !sqlite3SafetyCheckOk(pSrcDb)||!sqlite3SafetyCheckOk(pDestDb) ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif

  /* Lock the source database handle. The destination database
  ** handle is not locked in this routine, but it is locked in
  ** sqlite3_backup_step(). The user is required to ensure that no
  ** other thread accesses the destination handle for the duration
  ** of the backup operation.  Any attempt to use the destination
  ** database connection while a backup is in progress may cause
  ** a malfunction or a deadlock.
  */
  
// ABS Label 23
if(pSrcDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
sqlite3_mutex_enter(pSrcDb->mutex);
  
// ABS Label 24
if(pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}
sqlite3_mutex_enter(pDestDb->mutex);

  
// ABS Label 27
if(pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}
// ABS Label 28
if(pSrcDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 28);
}

// ROR Label 29
if((pSrcDb != pDestDb) != (pSrcDb == pDestDb))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
if( pSrcDb==pDestDb ){
    
// ABS Label 30
if(pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
sqlite3ErrorWithMsg(
        pDestDb, SQLITE_ERROR, "source and destination must be distinct"
    );
    p = 0;
  }else {
    /* Allocate space for a new sqlite3_backup object...
    ** EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a
    ** call to sqlite3_backup_init() and is destroyed by a call to
    ** sqlite3_backup_finish(). */
    p = (sqlite3_backup *)sqlite3MallocZero(sizeof(sqlite3_backup));
    if( !p ){
      
// ABS Label 31
if(pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}
sqlite3Error(pDestDb, SQLITE_NOMEM_BKPT);
    }
  }

  /* If the allocation succeeded, populate the new object. */
  
// ABS Label 32
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 32);
}
if( p ){
    p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
    p->pDest = findBtree(pDestDb, pDestDb, zDestDb);
    p->pDestDb = pDestDb;
    p->pSrcDb = pSrcDb;
    p->iNext = 1;
    p->isAttached = 0;

    if( 0==p->pSrc || 0==p->pDest 
     || checkReadTransaction(pDestDb, p->pDest)!=SQLITE_OK 
     ){
      /* One (or both) of the named databases did not exist or an OOM
      ** error was hit. Or there is a transaction open on the destination
      ** database. The error has already been written into the pDestDb 
      ** handle. All that is left to do here is free the sqlite3_backup 
      ** structure.  */
      sqlite3_free(p);
      p = 0;
    }
  }
  
// ABS Label 33
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 33);
}
if( p ){
    p->pSrc->nBackup++;
  }

  
// ABS Label 25
if(pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
sqlite3_mutex_leave(pDestDb->mutex);
  
// ABS Label 26
if(pSrcDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3_mutex_leave(pSrcDb->mutex);
  
// ABS Label 34
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 34);
}
return p;
}

/*
** Argument rc is an SQLite error code. Return true if this error is 
** considered fatal if encountered during a backup operation. All errors
** are considered fatal except for SQLITE_BUSY and SQLITE_LOCKED.
*/
static int isFatalError(int rc){
  
// MCC Label 35
if(( rc != 0 && rc != 5 && ( rc != 6 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 35);
}
// MCC Label 36
if(( rc != 0 && rc != 5 && ( !(rc != 6) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 36);
}
// MCC Label 37
if(( rc != 0 && !(rc != 5) && ( rc != 6 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 37);
}
// MCC Label 38
if(( rc != 0 && !(rc != 5) && ( !(rc != 6) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 38);
}
// MCC Label 39
if(( !(rc != 0) && rc != 5 && ( rc != 6 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 39);
}
// MCC Label 40
if(( !(rc != 0) && rc != 5 && ( !(rc != 6) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(( !(rc != 0) && !(rc != 5) && ( rc != 6 ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(( !(rc != 0) && !(rc != 5) && ( !(rc != 6) ) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
return (rc!=SQLITE_OK && rc!=SQLITE_BUSY && ALWAYS(rc!=SQLITE_LOCKED));
}

/*
** Parameter zSrcData points to a buffer containing the data for 
** page iSrcPg from the source database. Copy this data into the 
** destination database.
*/
static int backupOnePage(
  sqlite3_backup *p,              /* Backup handle */
  Pgno iSrcPg,                    /* Source database page to backup */
  const u8 *zSrcData,             /* Source database page data */
  int bUpdate                     /* True for an update, false otherwise */
){
  Pager * const pDestPager = sqlite3BtreePager(p->pDest);
  const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);
  int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);
  const int nCopy = MIN(nSrcPgsz, nDestPgsz);
  
// AOR Label 43
if((i64)iSrcPg - (i64)nSrcPgsz != (i64)iSrcPg * (i64)nSrcPgsz)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 43);
}
// AOR Label 44
if((i64)iSrcPg + (i64)nSrcPgsz != (i64)iSrcPg * (i64)nSrcPgsz)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 44);
}
// AOR Label 45
if((i64)iSrcPg / (i64)nSrcPgsz != (i64)iSrcPg * (i64)nSrcPgsz)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 45);
}
const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;
  int rc = SQLITE_OK;
  i64 iOff;

  assert( sqlite3BtreeGetReserveNoMutex(p->pSrc)>=0 );
  assert( p->bDestLocked );
  assert( !isFatalError(p->rc) );
  assert( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) );
  assert( zSrcData );

  /* Catch the case where the destination is an in-memory database and the
  ** page sizes of the source and destination differ. 
  */
  if( nSrcPgsz!=nDestPgsz && sqlite3PagerIsMemdb(pDestPager) ){
    rc = SQLITE_READONLY;
  }

  /* This loop runs once for each destination page spanned by the source 
  ** page. For each iteration, variable iOff is set to the byte offset
  ** of the destination page.
  */
  iOff = iEnd - (i64)nSrcPgsz;

// ABS Label 46
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
// ABS Label 47
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}
// ABS Label 48
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}

// COR Label 49
if((rc == 0 || iOff < iEnd) != (rc == 0 && iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 49);
}

// ROR Label 50
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
// ROR Label 51
if((iOff <= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 51);
}
// ROR Label 52
if((iOff > iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 52);
}
// ROR Label 53
if((iOff >= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}

// MCC Label 54
if(rc == 0 && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(rc == 0 && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(rc == 0) && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
// MCC Label 57
if(!(rc == 0) && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
for(; rc==SQLITE_OK && iOff<iEnd; iOff+=nDestPgsz){
    DbPage *pDestPg = 0;
    
// AOR Label 70
if((Pgno)(iOff / nDestPgsz) - 1 != (Pgno)(iOff / nDestPgsz) + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 70);
}
// AOR Label 71
if((Pgno)(iOff / nDestPgsz) / 1 != (Pgno)(iOff / nDestPgsz) + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 71);
}
// AOR Label 72
if((Pgno)(iOff / nDestPgsz) * 1 != (Pgno)(iOff / nDestPgsz) + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 72);
}
Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;
    
// ABS Label 74
if(iDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 74);
}

// ROR Label 75
if((iDest != ((Pgno)((sqlite3PendingByte / ((p->pDest->pBt)->pageSize)) + 1))) != (iDest == ((Pgno)((sqlite3PendingByte / ((p->pDest->pBt)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 75);
}
if( iDest==PENDING_BYTE_PAGE(p->pDest->pBt) ) { continue;
}
    if( SQLITE_OK==(rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0))
     && SQLITE_OK==(rc = sqlite3PagerWrite(pDestPg))
    ){
      const u8 *zIn = &zSrcData[iOff%nSrcPgsz];
      u8 *zDestData = sqlite3PagerGetData(pDestPg);
      u8 *zOut = &zDestData[iOff%nDestPgsz];

      /* Copy the data from the source page into the destination page.
      ** Then clear the Btree layer MemPage.isInit flag. Both this module
      ** and the pager code use this trick (clearing the first byte
      ** of the page 'extra' space to invalidate the Btree layers
      ** cached parse of the page). MemPage.isInit is marked 
      ** "MUST BE FIRST" for this purpose.
      */
      memcpy(zOut, zIn, nCopy);
      ((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;
      
// ABS Label 76
if(bUpdate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
// ABS Label 77
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// COR Label 78
if((iOff == 0 || bUpdate == 0) != (iOff == 0 && bUpdate == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 78);
}

// ROR Label 79
if((iOff != 0) != (iOff == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
// ROR Label 80
if((bUpdate != 0) != (bUpdate == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}

// MCC Label 81
if(iOff == 0 && bUpdate == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 81);
}
// MCC Label 82
if(iOff == 0 && !(bUpdate == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 82);
}
// MCC Label 83
if(!(iOff == 0) && bUpdate == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 83);
}
// MCC Label 84
if(!(iOff == 0) && !(bUpdate == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 84);
}
if( iOff==0 && bUpdate==0 ){
        sqlite3Put4byte(&zOut[28], sqlite3BtreeLastPage(p->pSrc));
      }
    }
    
// ABS Label 73
if(pDestPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 73);
}
sqlite3PagerUnref(pDestPg);
  };
// ABS Label 58
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
// ABS Label 59
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}
// ABS Label 60
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 60);
}

// COR Label 61
if((rc == 0 || iOff < iEnd) != (rc == 0 && iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 61);
}

// ROR Label 62
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}
// ROR Label 63
if((iOff <= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 63);
}
// ROR Label 64
if((iOff > iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
// ROR Label 65
if((iOff >= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 65);
}

// MCC Label 66
if(rc == 0 && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 66);
}
// MCC Label 67
if(rc == 0 && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 67);
}
// MCC Label 68
if(!(rc == 0) && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 68);
}
// MCC Label 69
if(!(rc == 0) && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 69);
}


  
// ABS Label 85
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 85);
}
return rc;
}

/*
** If pFile is currently larger than iSize bytes, then truncate it to
** exactly iSize bytes. If pFile is not larger than iSize bytes, then
** this function is a no-op.
**
** Return SQLITE_OK if everything is successful, or an SQLite error 
** code if an error occurs.
*/
static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){
  i64 iCurrent;
  int rc = sqlite3OsFileSize(pFile, &iCurrent);
  
// ABS Label 86
if(iCurrent < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 86);
}
// ABS Label 87
if(iSize < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 87);
}
// ABS Label 88
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// COR Label 89
if((rc == 0 || iCurrent > iSize) != (rc == 0 && iCurrent > iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 89);
}

// ROR Label 90
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
// ROR Label 91
if((iCurrent <= iSize) != (iCurrent > iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((iCurrent < iSize) != (iCurrent > iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((iCurrent >= iSize) != (iCurrent > iSize))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}

// MCC Label 94
if(rc == 0 && iCurrent > iSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 94);
}
// MCC Label 95
if(rc == 0 && !(iCurrent > iSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 95);
}
// MCC Label 96
if(!(rc == 0) && iCurrent > iSize ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(!(rc == 0) && !(iCurrent > iSize) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
if( rc==SQLITE_OK && iCurrent>iSize ){
    rc = sqlite3OsTruncate(pFile, iSize);
  }
  
// ABS Label 98
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 98);
}
return rc;
}

/*
** Register this backup object with the associated source pager for
** callbacks when pages are changed or the cache invalidated.
*/
static void attachBackupObject(sqlite3_backup *p){
  sqlite3_backup **pp;
  assert( sqlite3BtreeHoldsMutex(p->pSrc) );
  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
  p->pNext = *pp;
  *pp = p;
  p->isAttached = 1;
}

/*
** Copy nPage pages from the source b-tree to the destination.
*/
int sqlite3_backup_step(sqlite3_backup *p, int nPage){
  int rc;
  int destMode;       /* Destination journal mode */
  int pgszSrc = 0;    /* Source page size */
  int pgszDest = 0;   /* Destination page size */

#ifdef SQLITE_ENABLE_API_ARMOR
  if( p==0 ) return SQLITE_MISUSE_BKPT;
#endif
  
// ABS Label 99
if(p->pSrcDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 99);
}
sqlite3_mutex_enter(p->pSrcDb->mutex);
  
// ABS Label 100
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}
sqlite3BtreeEnter(p->pSrc);
  
// ABS Label 103
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 103);
}
if( p->pDestDb ){
    
// ABS Label 104
if(p->pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 104);
}
sqlite3_mutex_enter(p->pDestDb->mutex);
  }

  rc = p->rc;
  if( !isFatalError(rc) ){
    Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);     /* Source pager */
    Pager * const pDestPager = sqlite3BtreePager(p->pDest);   /* Dest pager */
    int ii;                            /* Iterator variable */
    int nSrcPage = -1;                 /* Size of source db in pages */
    int bCloseTrans = 0;               /* True if src db requires unlocking */

    /* If the source pager is currently in a write-transaction, return
    ** SQLITE_BUSY immediately.
    */
    
// ABS Label 105
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 105);
}

// COR Label 106
if((p->pDestDb || p->pSrc->pBt->inTransaction == 2) != (p->pDestDb && p->pSrc->pBt->inTransaction == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 106);
}

// ROR Label 107
if((p->pSrc->pBt->inTransaction != 2) != (p->pSrc->pBt->inTransaction == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}

// MCC Label 108
if(p->pDestDb && p->pSrc->pBt->inTransaction == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
// MCC Label 109
if(p->pDestDb && !(p->pSrc->pBt->inTransaction == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 109);
}
// MCC Label 110
if(!(p->pDestDb) && p->pSrc->pBt->inTransaction == 2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(!(p->pDestDb) && !(p->pSrc->pBt->inTransaction == 2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}
if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){
      rc = SQLITE_BUSY;
    }else{
      rc = SQLITE_OK;
    }

    /* If there is no open read-transaction on the source database, open
    ** one now. If a transaction is opened here, then it will be closed
    ** before this function exits.
    */
    if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){
      rc = sqlite3BtreeBeginTrans(p->pSrc, 0, 0);
      bCloseTrans = 1;
    }

    /* If the destination database has not yet been locked (i.e. if this
    ** is the first call to backup_step() for the current backup operation),
    ** try to set its page size to the same as the source database. This
    ** is especially important on ZipVFS systems, as in that case it is
    ** not possible to create a database file that uses one page size by
    ** writing to it with another.  */
    if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){
      rc = SQLITE_NOMEM;
    }

    /* Lock the destination database, if it is not locked already. */
    if( SQLITE_OK==rc && p->bDestLocked==0
     && SQLITE_OK==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,
                                                (int*)&p->iDestSchema)) 
    ){
      p->bDestLocked = 1;
    }

    /* Do not allow backup if the destination database is in WAL mode
    ** and the page sizes are different between source and destination */
    pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);
    pgszDest = sqlite3BtreeGetPageSize(p->pDest);
    destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));
    
// ABS Label 112
if(destMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}
// ABS Label 113
if(pgszDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 113);
}
// ABS Label 114
if(pgszSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}
// ABS Label 115
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 115);
}

// COR Label 116
if((0 == rc && destMode == 5 || pgszSrc != pgszDest) != (0 == rc && destMode == 5 && pgszSrc != pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 116);
}
// COR Label 117
if((0 == rc || destMode == 5) != (0 == rc && destMode == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 117);
}

// ROR Label 118
if((0 != rc) != (0 == rc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 118);
}
// ROR Label 119
if((destMode != 5) != (destMode == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((pgszSrc == pgszDest) != (pgszSrc != pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}

// MCC Label 121
if(0 == rc && destMode == 5 && pgszSrc != pgszDest ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 121);
}
// MCC Label 122
if(0 == rc && destMode == 5 && !(pgszSrc != pgszDest) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 122);
}
// MCC Label 123
if(0 == rc && !(destMode == 5) && pgszSrc != pgszDest ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 123);
}
// MCC Label 124
if(0 == rc && !(destMode == 5) && !(pgszSrc != pgszDest) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 124);
}
// MCC Label 125
if(!(0 == rc) && destMode == 5 && pgszSrc != pgszDest ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 125);
}
// MCC Label 126
if(!(0 == rc) && destMode == 5 && !(pgszSrc != pgszDest) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 126);
}
// MCC Label 127
if(!(0 == rc) && !(destMode == 5) && pgszSrc != pgszDest ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 127);
}
// MCC Label 128
if(!(0 == rc) && !(destMode == 5) && !(pgszSrc != pgszDest) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 128);
}
if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){
      rc = SQLITE_READONLY;
    }
  
    /* Now that there is a read-lock on the source database, query the
    ** source pager for the number of pages in the database.
    */
    nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);
    assert( nSrcPage>=0 );
    ii = 0;

// ABS Label 129
if(p->iNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}

// COR Label 130
if(((nPage < 0 || ii < nPage) && p->iNext <= (Pgno)nSrcPage || !rc) != ((nPage < 0 || ii < nPage) && p->iNext <= (Pgno)nSrcPage && !rc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 130);
}
// COR Label 131
if(((nPage < 0 || ii < nPage) || p->iNext <= (Pgno)nSrcPage) != ((nPage < 0 || ii < nPage) && p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 131);
}

// ROR Label 132
if((p->iNext < (Pgno)nSrcPage) != (p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
// ROR Label 133
if((p->iNext > (Pgno)nSrcPage) != (p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 133);
}
// ROR Label 134
if((p->iNext >= (Pgno)nSrcPage) != (p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 134);
}

// MCC Label 135
if(( nPage < 0 && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 135);
}
// MCC Label 136
if(( nPage < 0 && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 136);
}
// MCC Label 137
if(( nPage < 0 && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 137);
}
// MCC Label 138
if(( nPage < 0 && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 138);
}
// MCC Label 139
if(( nPage < 0 && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 139);
}
// MCC Label 140
if(( nPage < 0 && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 140);
}
// MCC Label 141
if(( nPage < 0 && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 141);
}
// MCC Label 142
if(( nPage < 0 && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 142);
}
// MCC Label 143
if(( !(nPage < 0) && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 143);
}
// MCC Label 144
if(( !(nPage < 0) && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 144);
}
// MCC Label 145
if(( !(nPage < 0) && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 145);
}
// MCC Label 146
if(( !(nPage < 0) && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 146);
}
// MCC Label 147
if(( !(nPage < 0) && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(( !(nPage < 0) && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
// MCC Label 149
if(( !(nPage < 0) && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 149);
}
// MCC Label 150
if(( !(nPage < 0) && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 150);
}
for(; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
      
// ABS Label 173
if(p->iNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 173);
}
const Pgno iSrcPg = p->iNext;                 /* Source page number */
      
// ABS Label 174
if(iSrcPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 174);
}

// ROR Label 175
if((iSrcPg == ((Pgno)((sqlite3PendingByte / ((p->pSrc->pBt)->pageSize)) + 1))) != (iSrcPg != ((Pgno)((sqlite3PendingByte / ((p->pSrc->pBt)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
if( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) ){
        DbPage *pSrcPg;                             /* Source page object */
        rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg,PAGER_GET_READONLY);
        
// ABS Label 176
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 176);
}

// ROR Label 177
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 177);
}
if( rc==SQLITE_OK ){
          rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);
          
// ABS Label 178
if(pSrcPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 178);
}
sqlite3PagerUnref(pSrcPg);
        }
      }
      p->iNext++;
    };
// ABS Label 151
if(p->iNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// COR Label 152
if(((nPage < 0 || ii < nPage) && p->iNext <= (Pgno)nSrcPage || !rc) != ((nPage < 0 || ii < nPage) && p->iNext <= (Pgno)nSrcPage && !rc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 152);
}
// COR Label 153
if(((nPage < 0 || ii < nPage) || p->iNext <= (Pgno)nSrcPage) != ((nPage < 0 || ii < nPage) && p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 153);
}

// ROR Label 154
if((p->iNext < (Pgno)nSrcPage) != (p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 154);
}
// ROR Label 155
if((p->iNext > (Pgno)nSrcPage) != (p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 155);
}
// ROR Label 156
if((p->iNext >= (Pgno)nSrcPage) != (p->iNext <= (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 156);
}

// MCC Label 157
if(( nPage < 0 && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 157);
}
// MCC Label 158
if(( nPage < 0 && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 158);
}
// MCC Label 159
if(( nPage < 0 && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 159);
}
// MCC Label 160
if(( nPage < 0 && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 160);
}
// MCC Label 161
if(( nPage < 0 && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 161);
}
// MCC Label 162
if(( nPage < 0 && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 162);
}
// MCC Label 163
if(( nPage < 0 && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 163);
}
// MCC Label 164
if(( nPage < 0 && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 164);
}
// MCC Label 165
if(( !(nPage < 0) && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 165);
}
// MCC Label 166
if(( !(nPage < 0) && ii < nPage ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 166);
}
// MCC Label 167
if(( !(nPage < 0) && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 167);
}
// MCC Label 168
if(( !(nPage < 0) && ii < nPage ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 168);
}
// MCC Label 169
if(( !(nPage < 0) && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 169);
}
// MCC Label 170
if(( !(nPage < 0) && !(ii < nPage) ) && p->iNext <= (Pgno)nSrcPage && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 170);
}
// MCC Label 171
if(( !(nPage < 0) && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !rc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 171);
}
// MCC Label 172
if(( !(nPage < 0) && !(ii < nPage) ) && !(p->iNext <= (Pgno)nSrcPage) && !(!rc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 172);
}

    
// ABS Label 179
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 179);
}

// ROR Label 180
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 180);
}
if( rc==SQLITE_OK ){
      p->nPagecount = nSrcPage;
      p->nRemaining = nSrcPage+1-p->iNext;
      
// ABS Label 181
if(p->iNext < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}

// ROR Label 182
if((p->iNext <= (Pgno)nSrcPage) != (p->iNext > (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 182);
}
// ROR Label 183
if((p->iNext < (Pgno)nSrcPage) != (p->iNext > (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((p->iNext >= (Pgno)nSrcPage) != (p->iNext > (Pgno)nSrcPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
if( p->iNext>(Pgno)nSrcPage ){
        rc = SQLITE_DONE;
      }else { if( !p->isAttached ){
        
// ABS Label 185
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 185);
}
attachBackupObject(p);
      };}

    }
  
    /* Update the schema version field in the destination database. This
    ** is to make sure that the schema-version really does change in
    ** the case where the source and destination databases have the
    ** same schema version.
    */
    
// ABS Label 186
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ROR Label 187
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
if( rc==SQLITE_DONE ){
      
// ABS Label 188
if(nSrcPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 188);
}

// ROR Label 189
if((nSrcPage != 0) != (nSrcPage == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
if( nSrcPage==0 ){
        rc = sqlite3BtreeNewDb(p->pDest);
        nSrcPage = 1;
      }
      
// ABS Label 190
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}

// COR Label 191
if((rc == 0 && rc == 101) != (rc == 0 || rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 191);
}

// ROR Label 192
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((rc != 101) != (rc == 101))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}

// MCC Label 194
if(rc == 0 && rc == 101 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 194);
}
// MCC Label 195
if(rc == 0 && !(rc == 101) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 195);
}
// MCC Label 196
if(!(rc == 0) && rc == 101 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 196);
}
// MCC Label 197
if(!(rc == 0) && !(rc == 101) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 197);
}
if( rc==SQLITE_OK || rc==SQLITE_DONE ){
        rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1);
      }
      
// ABS Label 198
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 198);
}

// ROR Label 199
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}
if( rc==SQLITE_OK ){
        
// ABS Label 200
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
if( p->pDestDb ){
          
// ABS Label 201
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 201);
}
sqlite3ResetAllSchemasOfConnection(p->pDestDb);
        }
        
// ABS Label 202
if(destMode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 202);
}

// ROR Label 203
if((destMode != 5) != (destMode == 5))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 203);
}
if( destMode==PAGER_JOURNALMODE_WAL ){
          rc = sqlite3BtreeSetVersion(p->pDest, 2);
        }
      }
      
// ABS Label 204
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 204);
}

// ROR Label 205
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 205);
}
if( rc==SQLITE_OK ){
        int nDestTruncate;
        /* Set nDestTruncate to the final number of pages in the destination
        ** database. The complication here is that the destination page
        ** size may be different to the source page size. 
        **
        ** If the source page size is smaller than the destination page size, 
        ** round up. In this case the call to sqlite3OsTruncate() below will
        ** fix the size of the file. However it is important to call
        ** sqlite3PagerTruncateImage() here so that any pages in the 
        ** destination file that lie beyond the nDestTruncate page mark are
        ** journalled by PagerCommitPhaseOne() before they are destroyed
        ** by the file truncation.
        */
        assert( pgszSrc==sqlite3BtreeGetPageSize(p->pSrc) );
        assert( pgszDest==sqlite3BtreeGetPageSize(p->pDest) );
        
// ABS Label 206
if(pgszDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 206);
}
// ABS Label 207
if(pgszSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 207);
}

// ROR Label 208
if((pgszSrc <= pgszDest) != (pgszSrc < pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 208);
}
// ROR Label 209
if((pgszSrc > pgszDest) != (pgszSrc < pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 209);
}
// ROR Label 210
if((pgszSrc >= pgszDest) != (pgszSrc < pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 210);
}
if( pgszSrc<pgszDest ){
          
// ABS Label 211
if(pgszDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 211);
}
// ABS Label 212
if(pgszSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 212);
}

// AOR Label 213
if(pgszDest - pgszSrc != pgszDest / pgszSrc)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 213);
}
// AOR Label 214
if(pgszDest + pgszSrc != pgszDest / pgszSrc)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 214);
}
// AOR Label 215
if(pgszDest * pgszSrc != pgszDest / pgszSrc)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 215);
}
int ratio = pgszDest/pgszSrc;
          nDestTruncate = (nSrcPage+ratio-1)/ratio;
          
// ABS Label 216
if(nDestTruncate < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 216);
}

// ROR Label 217
if((nDestTruncate != (int)((Pgno)((sqlite3PendingByte / ((p->pDest->pBt)->pageSize)) + 1))) != (nDestTruncate == (int)((Pgno)((sqlite3PendingByte / ((p->pDest->pBt)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}
if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){
            nDestTruncate--;
          }
        }else{
          nDestTruncate = nSrcPage * (pgszSrc/pgszDest);
        }
        assert( nDestTruncate>0 );

        
// ABS Label 218
if(pgszDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}
// ABS Label 219
if(pgszSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 219);
}

// ROR Label 220
if((pgszSrc <= pgszDest) != (pgszSrc < pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 220);
}
// ROR Label 221
if((pgszSrc > pgszDest) != (pgszSrc < pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 221);
}
// ROR Label 222
if((pgszSrc >= pgszDest) != (pgszSrc < pgszDest))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 222);
}
if( pgszSrc<pgszDest ){
          /* If the source page-size is smaller than the destination page-size,
          ** two extra things may need to happen:
          **
          **   * The destination may need to be truncated, and
          **
          **   * Data stored on the pages immediately following the 
          **     pending-byte page in the source database may need to be
          **     copied into the destination database.
          */
          
// AOR Label 223
if((i64)pgszSrc - (i64)nSrcPage != (i64)pgszSrc * (i64)nSrcPage)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 223);
}
// AOR Label 224
if((i64)pgszSrc + (i64)nSrcPage != (i64)pgszSrc * (i64)nSrcPage)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 224);
}
// AOR Label 225
if((i64)pgszSrc / (i64)nSrcPage != (i64)pgszSrc * (i64)nSrcPage)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 225);
}
const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;
          sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);
          Pgno iPg;
          int nDstPage;
          i64 iOff;
          i64 iEnd;

          assert( pFile );
          assert( nDestTruncate==0 
              || (i64)nDestTruncate*(i64)pgszDest >= iSize || (
                nDestTruncate==(int)(PENDING_BYTE_PAGE(p->pDest->pBt)-1)
             && iSize>=PENDING_BYTE && iSize<=PENDING_BYTE+pgszDest
          ));

          /* This block ensures that all data required to recreate the original
          ** database has been stored in the journal for pDestPager and the
          ** journal synced to disk. So at this point we may safely modify
          ** the database file in any way, knowing that if a power failure
          ** occurs, the original database will be reconstructed from the 
          ** journal file.  */
          
// ABS Label 226
if(pDestPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
sqlite3PagerPagecount(pDestPager, &nDstPage);
          iPg = nDestTruncate;

// ABS Label 227
if(iPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}
// ABS Label 228
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 228);
}

// COR Label 229
if((rc == 0 || iPg <= (Pgno)nDstPage) != (rc == 0 && iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 229);
}

// ROR Label 230
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 230);
}
// ROR Label 231
if((iPg < (Pgno)nDstPage) != (iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 231);
}
// ROR Label 232
if((iPg > (Pgno)nDstPage) != (iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
// ROR Label 233
if((iPg >= (Pgno)nDstPage) != (iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 233);
}

// MCC Label 234
if(rc == 0 && iPg <= (Pgno)nDstPage ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 234);
}
// MCC Label 235
if(rc == 0 && !(iPg <= (Pgno)nDstPage) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 235);
}
// MCC Label 236
if(!(rc == 0) && iPg <= (Pgno)nDstPage ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 236);
}
// MCC Label 237
if(!(rc == 0) && !(iPg <= (Pgno)nDstPage) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 237);
}
for(; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){
            
// ABS Label 249
if(iPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}

// ROR Label 250
if((iPg == ((Pgno)((sqlite3PendingByte / ((p->pDest->pBt)->pageSize)) + 1))) != (iPg != ((Pgno)((sqlite3PendingByte / ((p->pDest->pBt)->pageSize)) + 1))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
if( iPg!=PENDING_BYTE_PAGE(p->pDest->pBt) ){
              DbPage *pPg;
              rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);
              
// ABS Label 251
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 251);
}

// ROR Label 252
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
if( rc==SQLITE_OK ){
                rc = sqlite3PagerWrite(pPg);
                
// ABS Label 253
if(pPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}
sqlite3PagerUnref(pPg);
              }
            }
          };
// ABS Label 238
if(iPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 238);
}
// ABS Label 239
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// COR Label 240
if((rc == 0 || iPg <= (Pgno)nDstPage) != (rc == 0 && iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 240);
}

// ROR Label 241
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((iPg < (Pgno)nDstPage) != (iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
// ROR Label 243
if((iPg > (Pgno)nDstPage) != (iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
// ROR Label 244
if((iPg >= (Pgno)nDstPage) != (iPg <= (Pgno)nDstPage))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}

// MCC Label 245
if(rc == 0 && iPg <= (Pgno)nDstPage ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(rc == 0 && !(iPg <= (Pgno)nDstPage) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
// MCC Label 247
if(!(rc == 0) && iPg <= (Pgno)nDstPage ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(!(rc == 0) && !(iPg <= (Pgno)nDstPage) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}

          
// ABS Label 254
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 254);
}

// ROR Label 255
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 255);
}
if( rc==SQLITE_OK ){
            rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);
          }

          /* Write the extra pages and truncate the database file as required */
          iEnd = MIN(PENDING_BYTE + pgszDest, iSize);
          iOff = sqlite3PendingByte + pgszSrc;

// ABS Label 256
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 256);
}
// ABS Label 257
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 257);
}
// ABS Label 258
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// COR Label 259
if((rc == 0 || iOff < iEnd) != (rc == 0 && iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 259);
}

// ROR Label 260
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 260);
}
// ROR Label 261
if((iOff <= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 261);
}
// ROR Label 262
if((iOff > iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((iOff >= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}

// MCC Label 264
if(rc == 0 && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 264);
}
// MCC Label 265
if(rc == 0 && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 265);
}
// MCC Label 266
if(!(rc == 0) && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 266);
}
// MCC Label 267
if(!(rc == 0) && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 267);
}
for(
            ; 
            rc==SQLITE_OK && iOff<iEnd; 
            iOff+=pgszSrc
          ){
            PgHdr *pSrcPg = 0;
            const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);
            rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0);
            
// ABS Label 281
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 281);
}

// ROR Label 282
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 282);
}
if( rc==SQLITE_OK ){
              u8 *zData = sqlite3PagerGetData(pSrcPg);
              rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);
            }
            
// ABS Label 280
if(pSrcPg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 280);
}
sqlite3PagerUnref(pSrcPg);
          };
// ABS Label 268
if(iEnd < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 268);
}
// ABS Label 269
if(iOff < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
// ABS Label 270
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}

// COR Label 271
if((rc == 0 || iOff < iEnd) != (rc == 0 && iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 271);
}

// ROR Label 272
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 272);
}
// ROR Label 273
if((iOff <= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 273);
}
// ROR Label 274
if((iOff > iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 274);
}
// ROR Label 275
if((iOff >= iEnd) != (iOff < iEnd))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 275);
}

// MCC Label 276
if(rc == 0 && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 276);
}
// MCC Label 277
if(rc == 0 && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 277);
}
// MCC Label 278
if(!(rc == 0) && iOff < iEnd ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 278);
}
// MCC Label 279
if(!(rc == 0) && !(iOff < iEnd) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 279);
}

          
// ABS Label 283
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 283);
}

// ROR Label 284
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 284);
}
if( rc==SQLITE_OK ){
            rc = backupTruncateFile(pFile, iSize);
          }

          /* Sync the database file to disk. */
          
// ABS Label 285
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 285);
}

// ROR Label 286
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 286);
}
if( rc==SQLITE_OK ){
            rc = sqlite3PagerSync(pDestPager, 0);
          }
        }else{
          
// ABS Label 287
if(pDestPager < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
sqlite3PagerTruncateImage(pDestPager, nDestTruncate);
          rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);
        }
    
        /* Finish committing the transaction to the destination database. */
        if( SQLITE_OK==rc
         && SQLITE_OK==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))
        ){
          rc = SQLITE_DONE;
        }
      }
    }
  
    /* If bCloseTrans is true, then this function opened a read transaction
    ** on the source database. Close the read transaction here. There is
    ** no need to check the return values of the btree methods here, as
    ** "committing" a read-only transaction cannot fail.
    */
    
// ABS Label 288
if(bCloseTrans < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}
if( bCloseTrans ){
      TESTONLY( int rc2 );
      TESTONLY( rc2  = ) 
// ABS Label 289
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 289);
}
sqlite3BtreeCommitPhaseOne(p->pSrc, 0);
      TESTONLY( rc2 |= ) 
// ABS Label 290
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 290);
}
sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
      assert( rc2==SQLITE_OK );
    }
  
    
// ABS Label 291
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 291);
}

// ROR Label 292
if((rc != (10 | (12 << 8))) != (rc == (10 | (12 << 8))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 292);
}
if( rc==SQLITE_IOERR_NOMEM ){
      rc = SQLITE_NOMEM_BKPT;
    }
    p->rc = rc;
  }
  
// ABS Label 293
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 293);
}
if( p->pDestDb ){
    
// ABS Label 294
if(p->pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 294);
}
sqlite3_mutex_leave(p->pDestDb->mutex);
  }
  
// ABS Label 101
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 101);
}
sqlite3BtreeLeave(p->pSrc);
  
// ABS Label 102
if(p->pSrcDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 102);
}
sqlite3_mutex_leave(p->pSrcDb->mutex);
  
// ABS Label 295
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 295);
}
return rc;
}

/*
** Release all resources associated with an sqlite3_backup* handle.
*/
int sqlite3_backup_finish(sqlite3_backup *p){
  sqlite3_backup **pp;                 /* Ptr to head of pagers backup list */
  sqlite3 *pSrcDb;                     /* Source database connection */
  int rc;                              /* Value to return */

  /* Enter the mutexes */
  
// ABS Label 301
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 301);
}

// ROR Label 302
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 302);
}
if( p==0 ) { return SQLITE_OK;
}
  pSrcDb = p->pSrcDb;
  
// ABS Label 296
if(pSrcDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 296);
}
sqlite3_mutex_enter(pSrcDb->mutex);
  
// ABS Label 297
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 297);
}
sqlite3BtreeEnter(p->pSrc);
  
// ABS Label 303
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
if( p->pDestDb ){
    
// ABS Label 304
if(p->pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
sqlite3_mutex_enter(p->pDestDb->mutex);
  }

  /* Detach this backup from the source pager. */
  
// ABS Label 305
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}
if( p->pDestDb ){
    p->pSrc->nBackup--;
  }
  
// ABS Label 306
if(p->isAttached < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 306);
}
if( p->isAttached ){
    pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
    assert( pp!=0 );
    
// ABS Label 307
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 307);
}
// ABS Label 308
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 308);
}

// ROR Label 309
if((*pp == p) != (*pp != p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 309);
}
while( *pp!=p ){
      pp = &(*pp)->pNext;
      assert( pp!=0 );
    };
// ABS Label 310
if(*pp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 310);
}
// ABS Label 311
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 311);
}

// ROR Label 312
if((*pp == p) != (*pp != p))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 312);
}

    *pp = p->pNext;
  }

  /* If a transaction is still open on the Btree, roll it back. */
  
// ABS Label 298
if(p->pDest < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 298);
}
sqlite3BtreeRollback(p->pDest, SQLITE_OK, 0);

  /* Set the error code of the destination database handle. */
  rc = (p->rc==SQLITE_DONE) ? SQLITE_OK : p->rc;
  
// ABS Label 313
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 313);
}
if( p->pDestDb ){
    
// ABS Label 314
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 314);
}

// ABS Label 315
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 315);
}
sqlite3Error(p->pDestDb, rc);

    /* Exit the mutexes and free the backup context structure. */
    
// ABS Label 316
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 316);
}
sqlite3LeaveMutexAndCloseZombie(p->pDestDb);
  }
  
// ABS Label 299
if(p->pSrc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 299);
}
sqlite3BtreeLeave(p->pSrc);
  
// ABS Label 317
if(p->pDestDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 317);
}
if( p->pDestDb ){
    /* EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a
    ** call to sqlite3_backup_init() and is destroyed by a call to
    ** sqlite3_backup_finish(). */
    sqlite3_free(p);
  }
  
// ABS Label 300
if(pSrcDb < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 300);
}
sqlite3LeaveMutexAndCloseZombie(pSrcDb);
  
// ABS Label 318
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 318);
}
return rc;
}

/*
** Return the number of pages still to be backed up as of the most recent
** call to sqlite3_backup_step().
*/
int sqlite3_backup_remaining(sqlite3_backup *p){
#ifdef SQLITE_ENABLE_API_ARMOR
  if( p==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  return p->nRemaining;
}

/*
** Return the total number of pages in the source database as of the most 
** recent call to sqlite3_backup_step().
*/
int sqlite3_backup_pagecount(sqlite3_backup *p){
#ifdef SQLITE_ENABLE_API_ARMOR
  if( p==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
  return p->nPagecount;
}

/*
** This function is called after the contents of page iPage of the
** source database have been modified. If page iPage has already been 
** copied into the destination database, then the data written to the
** destination is now invalidated. The destination copy of iPage needs
** to be updated with the new data before the backup operation is
** complete.
**
** It is assumed that the mutex associated with the BtShared object
** corresponding to the source database is held when this function is
** called.
*/
static SQLITE_NOINLINE void backupUpdate(
  sqlite3_backup *p,
  Pgno iPage,
  const u8 *aData
){
  assert( p!=0 );
  do{
    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );
    if( !isFatalError(p->rc) && iPage<p->iNext ){
      /* The backup process p has already copied page iPage. But now it
      ** has been modified by a transaction on the source pager. Copy
      ** the new data into the backup.
      */
      int rc;
      assert( p->pDestDb );
      
// ABS Label 319
if(p->pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 319);
}
sqlite3_mutex_enter(p->pDestDb->mutex);
      rc = backupOnePage(p, iPage, aData, 1);
      
// ABS Label 320
if(p->pDestDb->mutex < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
sqlite3_mutex_leave(p->pDestDb->mutex);
      assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );
      
// ABS Label 321
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}

// ROR Label 322
if((rc == 0) != (rc != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 322);
}
if( rc!=SQLITE_OK ){
        p->rc = rc;
      }
    }
  }while( (p = p->pNext)!=0 );;
}
void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){
  
// ABS Label 323
if(pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 323);
}
if( pBackup ) { 
// ABS Label 324
if(pBackup < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 324);
}

// ABS Label 325
if(iPage < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 325);
}

// ABS Label 326
if(aData < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 326);
}
backupUpdate(pBackup, iPage, aData);
}
}

/*
** Restart the backup process. This is called when the pager layer
** detects that the database has been modified by an external database
** connection. In this case there is no way of knowing which of the
** pages that have been copied into the destination database are still 
** valid and which are not, so the entire process needs to be restarted.
**
** It is assumed that the mutex associated with the BtShared object
** corresponding to the source database is held when this function is
** called.
*/
void sqlite3BackupRestart(sqlite3_backup *pBackup){
  sqlite3_backup *p;                   /* Iterator variable */
  p = pBackup;

// ABS Label 327
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 327);
}
for(; p; p=p->pNext){
    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );
    p->iNext = 1;
  };
// ABS Label 328
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 328);
}

}

#ifndef SQLITE_OMIT_VACUUM
/*
** Copy the complete content of pBtFrom into pBtTo.  A transaction
** must be active for both files.
**
** The size of file pTo may be reduced by this operation. If anything 
** goes wrong, the transaction on pTo is rolled back. If successful, the 
** transaction is committed before returning.
*/
int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
  int rc;
  sqlite3_file *pFd;              /* File descriptor for database pTo */
  sqlite3_backup b;
  
// ABS Label 329
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 329);
}
sqlite3BtreeEnter(pTo);
  
// ABS Label 330
if(pFrom < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 330);
}
sqlite3BtreeEnter(pFrom);

  assert( sqlite3BtreeTxnState(pTo)==SQLITE_TXN_WRITE );
  pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));
  
// ABS Label 332
if(pFd->pMethods < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 332);
}
if( pFd->pMethods ){
    i64 nByte = sqlite3BtreeGetPageSize(pFrom)*(i64)sqlite3BtreeLastPage(pFrom);
    rc = sqlite3OsFileControl(pFd, SQLITE_FCNTL_OVERWRITE, &nByte);
    
// ABS Label 333
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 333);
}

// ROR Label 334
if((rc != 12) != (rc == 12))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 334);
}
if( rc==SQLITE_NOTFOUND ) { rc = SQLITE_OK;
}
    
// ABS Label 335
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 335);
}
if( rc ) { goto copy_finished;
}
  }

  /* Set up an sqlite3_backup object. sqlite3_backup.pDestDb must be set
  ** to 0. This is used by the implementations of sqlite3_backup_step()
  ** and sqlite3_backup_finish() to detect that they are being called
  ** from this function, not directly by the user.
  */
  memset(&b, 0, sizeof(b));
  b.pSrcDb = pFrom->db;
  b.pSrc = pFrom;
  b.pDest = pTo;
  b.iNext = 1;

  /* 0x7FFFFFFF is the hard limit for the number of pages in a database
  ** file. By passing this as the number of pages to copy to
  ** sqlite3_backup_step(), we can guarantee that the copy finishes 
  ** within a single call (unless an error occurs). The assert() statement
  ** checks this assumption - (p->rc) should be set to either SQLITE_DONE 
  ** or an error code.  */
  sqlite3_backup_step(&b, 0x7FFFFFFF);
  assert( b.rc!=SQLITE_OK );

  rc = sqlite3_backup_finish(&b);
  
// ABS Label 336
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 336);
}

// ROR Label 337
if((rc != 0) != (rc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 337);
}
if( rc==SQLITE_OK ){
    pTo->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;
  }else{
    sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
  }

  assert( sqlite3BtreeTxnState(pTo)!=SQLITE_TXN_WRITE );
copy_finished:
  sqlite3BtreeLeave(pFrom);
  
// ABS Label 331
if(pTo < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 331);
}
sqlite3BtreeLeave(pTo);
  
// ABS Label 338
if(rc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
return rc;
}
#endif /* SQLITE_OMIT_VACUUM */
