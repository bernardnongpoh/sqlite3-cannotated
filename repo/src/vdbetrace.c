/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** 2009 November 25
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file contains code used to insert the values of host parameters
** (aka "wildcards") into the SQL text output by sqlite3_trace().
**
** The Vdbe parse-tree explainer is also found here.
*/
#include "sqliteInt.h"
#include "vdbeInt.h"

#ifndef SQLITE_OMIT_TRACE

/*
** zSql is a zero-terminated string of UTF-8 SQL text.  Return the number of
** bytes in this text up to but excluding the first character in
** a host parameter.  If the text contains no host parameters, return
** the total number of bytes in the text.
*/
static int findNextHostParameter(const char *zSql, int *pnToken){
  int tokenType;
  int nTotal = 0;
  int n;

  *pnToken = 0;
  
// ABS Label 7
if(zSql[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}
while( zSql[0] ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    assert( n>0 && tokenType!=TK_ILLEGAL );
    
// ABS Label 9
if(tokenType < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 9);
}

// ROR Label 10
if((tokenType != 155) != (tokenType == 155))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( tokenType==TK_VARIABLE ){
      *pnToken = n;
      break;
    }
    nTotal += n;
    zSql += n;
  };
// ABS Label 8
if(zSql[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 8);
}

  
// ABS Label 11
if(nTotal < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
return nTotal;
}

/*
** This function returns a pointer to a nul-terminated string in memory
** obtained from sqlite3DbMalloc(). If sqlite3.nVdbeExec is 1, then the
** string contains a copy of zRawSql but with host parameters expanded to 
** their current bindings. Or, if sqlite3.nVdbeExec is greater than 1, 
** then the returned string holds a copy of zRawSql with "-- " prepended
** to each line of text.
**
** If the SQLITE_TRACE_SIZE_LIMIT macro is defined to an integer, then
** then long strings and blobs are truncated to that many bytes.  This
** can be used to prevent unreasonably large trace strings when dealing
** with large (multi-megabyte) strings and blobs.
**
** The calling function is responsible for making sure the memory returned
** is eventually freed.
**
** ALGORITHM:  Scan the input string looking for host parameters in any of
** these forms:  ?, ?N, $A, @A, :A.  Take care to avoid text within
** string literals, quoted identifier names, and comments.  For text forms,
** the host parameter index is found by scanning the prepared
** statement for the corresponding OP_Variable opcode.  Once the host
** parameter index is known, locate the value in p->aVar[].  Then render
** the value as a literal in place of the host parameter name.
*/
char *sqlite3VdbeExpandSql(
  Vdbe *p,                 /* The prepared statement being evaluated */
  const char *zRawSql      /* Raw text of the SQL statement */
){
  sqlite3 *db;             /* The database connection */
  int idx = 0;             /* Index of a host parameter */
  int nextIndex = 1;       /* Index of next ? host parameter */
  int n;                   /* Length of a token prefix */
  int nToken;              /* Length of the parameter token */
  int i;                   /* Loop counter */
  Mem *pVar;               /* Value of a host parameter */
  StrAccum out;            /* Accumulate the output here */
#ifndef SQLITE_OMIT_UTF16
  Mem utf8;                /* Used to convert UTF16 into UTF8 for display */
#endif
  char zBase[100];         /* Initial working space */

  db = p->db;
  
// ABS Label 12
if(db->aLimit[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3StrAccumInit(&out, 0, zBase, sizeof(zBase), 
                      db->aLimit[SQLITE_LIMIT_LENGTH]);
  
// ABS Label 13
if(db->nVdbeExec < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 13);
}

// ROR Label 14
if((db->nVdbeExec <= 1) != (db->nVdbeExec > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 14);
}
// ROR Label 15
if((db->nVdbeExec < 1) != (db->nVdbeExec > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 15);
}
// ROR Label 16
if((db->nVdbeExec >= 1) != (db->nVdbeExec > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 16);
}
if( db->nVdbeExec>1 ){
    
// ABS Label 17
if(*zRawSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 17);
}
while( *zRawSql ){
      
// ABS Label 19
if(zRawSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 19);
}
const char *zStart = zRawSql;
      while( *(zRawSql++)!='\n' && *zRawSql ) {;
};
      sqlite3_str_append(&out, "-- ", 3);
      assert( (zRawSql - zStart) > 0 );
      
// ABS Label 20
if(zStart < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
sqlite3_str_append(&out, zStart, (int)(zRawSql-zStart));
    };
// ABS Label 18
if(*zRawSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 18);
}

  }else { 
// ROR Label 21
if((p->nVar != 0) != (p->nVar == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 21);
}
if( p->nVar==0 ){
    
// ABS Label 22
if(zRawSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 22);
}
sqlite3_str_append(&out, zRawSql, sqlite3Strlen30(zRawSql));
  }else{
    
// ABS Label 23
if(zRawSql[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 23);
}
while( zRawSql[0] ){
      n = findNextHostParameter(zRawSql, &nToken);
      assert( n>0 );
      
// ABS Label 25
if(zRawSql < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}

// ABS Label 26
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}
sqlite3_str_append(&out, zRawSql, n);
      zRawSql += n;
      assert( zRawSql[0] || nToken==0 );
      
// ABS Label 27
if(nToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 27);
}

// ROR Label 28
if((nToken != 0) != (nToken == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
if( nToken==0 ) { break;
}
      
// ROR Label 29
if((zRawSql[0] != '?') != (zRawSql[0] == '?'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
if( zRawSql[0]=='?' ){
        
// ABS Label 30
if(nToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}

// ROR Label 31
if((nToken <= 1) != (nToken > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 31);
}
// ROR Label 32
if((nToken < 1) != (nToken > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 32);
}
// ROR Label 33
if((nToken >= 1) != (nToken > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}
if( nToken>1 ){
          assert( sqlite3Isdigit(zRawSql[1]) );
          sqlite3GetInt32(&zRawSql[1], &idx);
        }else{
          idx = nextIndex;
        }
      }else{
        assert( zRawSql[0]==':' || zRawSql[0]=='$' ||
                zRawSql[0]=='@' || zRawSql[0]=='#' );
        testcase( zRawSql[0]==':' );
        testcase( zRawSql[0]=='$' );
        testcase( zRawSql[0]=='@' );
        testcase( zRawSql[0]=='#' );
        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
        assert( idx>0 );
      }
      zRawSql += nToken;
      nextIndex = MAX(idx + 1, nextIndex);
      assert( idx>0 && idx<=p->nVar );
      pVar = &p->aVar[idx-1];
      
// AOR Label 34
if(pVar->flags | 1 != pVar->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 34);
}
// AOR Label 35
if(pVar->flags ^ 1 != pVar->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 35);
}
if( pVar->flags & MEM_Null ){
        sqlite3_str_append(&out, "NULL", 4);
      }else { 
// AOR Label 36
if(pVar->flags | (4 | 32) != pVar->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 36);
}
// AOR Label 37
if(pVar->flags ^ (4 | 32) != pVar->flags & (4 | 32))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 37);
}
if( pVar->flags & (MEM_Int|MEM_IntReal) ){
        
// ABS Label 38
if(pVar->u.i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 38);
}
sqlite3_str_appendf(&out, "%lld", pVar->u.i);
      }else { 
// AOR Label 39
if(pVar->flags | 8 != pVar->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 39);
}
// AOR Label 40
if(pVar->flags ^ 8 != pVar->flags & 8)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 40);
}
if( pVar->flags & MEM_Real ){
        
// ABS Label 41
if(pVar->u.r < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 41);
}
sqlite3_str_appendf(&out, "%!.15g", pVar->u.r);
      }else { 
// AOR Label 42
if(pVar->flags | 2 != pVar->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 42);
}
// AOR Label 43
if(pVar->flags ^ 2 != pVar->flags & 2)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 43);
}
if( pVar->flags & MEM_Str ){
        int nOut;  /* Number of bytes of the string text to include in output */
#ifndef SQLITE_OMIT_UTF16
        
// ABS Label 44
if(((db)->enc) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}
u8 enc = ENC(db);
        
// ROR Label 47
if((enc == 1) != (enc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 47);
}
if( enc!=SQLITE_UTF8 ){
          memset(&utf8, 0, sizeof(utf8));
          utf8.db = db;
          
// ABS Label 48
if(enc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 48);
}
sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, SQLITE_STATIC);
          if( SQLITE_NOMEM==sqlite3VdbeChangeEncoding(&utf8, SQLITE_UTF8) ){
            out.accError = SQLITE_NOMEM;
            out.nAlloc = 0;
          }
          pVar = &utf8;
        }
#endif
        nOut = pVar->n;
#ifdef SQLITE_TRACE_SIZE_LIMIT
        if( nOut>SQLITE_TRACE_SIZE_LIMIT ){
          nOut = SQLITE_TRACE_SIZE_LIMIT;
          while( nOut<pVar->n && (pVar->z[nOut]&0xc0)==0x80 ){ nOut++; }
        }
#endif    
        
// ABS Label 45
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 45);
}

// ABS Label 46
if(pVar->z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
sqlite3_str_appendf(&out, "'%.*q'", nOut, pVar->z);
#ifdef SQLITE_TRACE_SIZE_LIMIT
        if( nOut<pVar->n ){
          sqlite3_str_appendf(&out, "/*+%d bytes*/", pVar->n-nOut);
        }
#endif
#ifndef SQLITE_OMIT_UTF16
        
// ROR Label 49
if((enc == 1) != (enc != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 49);
}
if( enc!=SQLITE_UTF8 ) { sqlite3VdbeMemRelease(&utf8);
}
#endif
      }else { 
// AOR Label 50
if(pVar->flags | 16384 != pVar->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 50);
}
// AOR Label 51
if(pVar->flags ^ 16384 != pVar->flags & 16384)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 51);
}
if( pVar->flags & MEM_Zero ){
        
// ABS Label 52
if(pVar->u.nZero < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 52);
}
sqlite3_str_appendf(&out, "zeroblob(%d)", pVar->u.nZero);
      }else{
        int nOut;  /* Number of bytes of the blob to include in output */
        assert( pVar->flags & MEM_Blob );
        sqlite3_str_append(&out, "x'", 2);
        nOut = pVar->n;
#ifdef SQLITE_TRACE_SIZE_LIMIT
        if( nOut>SQLITE_TRACE_SIZE_LIMIT ) nOut = SQLITE_TRACE_SIZE_LIMIT;
#endif
        i = 0;

// ABS Label 53
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 53);
}
// ABS Label 54
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 54);
}

// ROR Label 55
if((i <= nOut) != (i < nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 55);
}
// ROR Label 56
if((i > nOut) != (i < nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 56);
}
// ROR Label 57
if((i >= nOut) != (i < nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 57);
}
for(; i<nOut; i++){
          
// AOR Label 63
if(pVar->z[i] | 255 != pVar->z[i] & 255)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 63);
}
// AOR Label 64
if(pVar->z[i] ^ 255 != pVar->z[i] & 255)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 64);
}
sqlite3_str_appendf(&out, "%02x", pVar->z[i]&0xff);
        };
// ABS Label 58
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 58);
}
// ABS Label 59
if(nOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 59);
}

// ROR Label 60
if((i <= nOut) != (i < nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 60);
}
// ROR Label 61
if((i > nOut) != (i < nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 61);
}
// ROR Label 62
if((i >= nOut) != (i < nOut))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 62);
}

        sqlite3_str_append(&out, "'", 1);
#ifdef SQLITE_TRACE_SIZE_LIMIT
        if( nOut<pVar->n ){
          sqlite3_str_appendf(&out, "/*+%d bytes*/", pVar->n-nOut);
        }
#endif
      };}
;}
;}
;}

    };
// ABS Label 24
if(zRawSql[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 24);
}

  };}

  
// ABS Label 65
if(out.accError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
if( out.accError ) { sqlite3_str_reset(&out);
}
  return sqlite3StrAccumFinish(&out);
}

#endif /* #ifndef SQLITE_OMIT_TRACE */
