/*** Generated by CAnnotate ***/ 
// COVERAGE CRITERIA : ABS AOR COR ROR MCC 
#include "coverage.h"
/*
** The "printf" code that follows dates from the 1980's.  It is in
** the public domain. 
**
**************************************************************************
**
** This file contains code for a set of "printf"-like routines.  These
** routines format strings much like the printf() from the standard C
** library, though the implementation here has enhancements to support
** SQLite.
*/
#include "sqliteInt.h"

/*
** Conversion types fall into various categories as defined by the
** following enumeration.
*/
#define etRADIX       0 /* non-decimal integer types.  %x %o */
#define etFLOAT       1 /* Floating point.  %f */
#define etEXP         2 /* Exponentional notation. %e and %E */
#define etGENERIC     3 /* Floating or exponential, depending on exponent. %g */
#define etSIZE        4 /* Return number of characters processed so far. %n */
#define etSTRING      5 /* Strings. %s */
#define etDYNSTRING   6 /* Dynamically allocated strings. %z */
#define etPERCENT     7 /* Percent symbol. %% */
#define etCHARX       8 /* Characters. %c */
/* The rest are extensions, not normally found in printf() */
#define etSQLESCAPE   9 /* Strings with '\'' doubled.  %q */
#define etSQLESCAPE2 10 /* Strings with '\'' doubled and enclosed in '',
                          NULL pointers replaced by SQL NULL.  %Q */
#define etTOKEN      11 /* a pointer to a Token structure */
#define etSRCITEM    12 /* a pointer to a SrcItem */
#define etPOINTER    13 /* The %p conversion */
#define etSQLESCAPE3 14 /* %w -> Strings with '\"' doubled */
#define etORDINAL    15 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */
#define etDECIMAL    16 /* %d or %u, but not %x, %o */

#define etINVALID    17 /* Any unrecognized conversion type */


/*
** An "etByte" is an 8-bit unsigned value.
*/
typedef unsigned char etByte;

/*
** Each builtin conversion character (ex: the 'd' in "%d") is described
** by an instance of the following structure
*/
typedef struct et_info {   /* Information about each format field */
  char fmttype;            /* The format field code letter */
  etByte base;             /* The base for radix conversion */
  etByte flags;            /* One or more of FLAG_ constants below */
  etByte type;             /* Conversion paradigm */
  etByte charset;          /* Offset into aDigits[] of the digits string */
  etByte prefix;           /* Offset into aPrefix[] of the prefix string */
} et_info;

/*
** Allowed values for et_info.flags
*/
#define FLAG_SIGNED    1     /* True if the value to convert is signed */
#define FLAG_STRING    4     /* Allow infinite precision */


/*
** The following table is searched linearly, so it is good to put the
** most frequently used conversion types first.
*/
static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] = "-x0\000X0";
static const et_info fmtinfo[] = {
  {  'd', 10, 1, etDECIMAL,    0,  0 },
  {  's',  0, 4, etSTRING,     0,  0 },
  {  'g',  0, 1, etGENERIC,    30, 0 },
  {  'z',  0, 4, etDYNSTRING,  0,  0 },
  {  'q',  0, 4, etSQLESCAPE,  0,  0 },
  {  'Q',  0, 4, etSQLESCAPE2, 0,  0 },
  {  'w',  0, 4, etSQLESCAPE3, 0,  0 },
  {  'c',  0, 0, etCHARX,      0,  0 },
  {  'o',  8, 0, etRADIX,      0,  2 },
  {  'u', 10, 0, etDECIMAL,    0,  0 },
  {  'x', 16, 0, etRADIX,      16, 1 },
  {  'X', 16, 0, etRADIX,      0,  4 },
#ifndef SQLITE_OMIT_FLOATING_POINT
  {  'f',  0, 1, etFLOAT,      0,  0 },
  {  'e',  0, 1, etEXP,        30, 0 },
  {  'E',  0, 1, etEXP,        14, 0 },
  {  'G',  0, 1, etGENERIC,    14, 0 },
#endif
  {  'i', 10, 1, etDECIMAL,    0,  0 },
  {  'n',  0, 0, etSIZE,       0,  0 },
  {  '%',  0, 0, etPERCENT,    0,  0 },
  {  'p', 16, 0, etPOINTER,    0,  1 },

  /* All the rest are undocumented and are for internal use only */
  {  'T',  0, 0, etTOKEN,      0,  0 },
  {  'S',  0, 0, etSRCITEM,    0,  0 },
  {  'r', 10, 1, etORDINAL,    0,  0 },
};

/* Notes:
**
**    %S    Takes a pointer to SrcItem.  Shows name or database.name
**    %!S   Like %S but prefer the zName over the zAlias
*/

/* Floating point constants used for rounding */
static const double arRound[] = {
  5.0e-01, 5.0e-02, 5.0e-03, 5.0e-04, 5.0e-05,
  5.0e-06, 5.0e-07, 5.0e-08, 5.0e-09, 5.0e-10,
};

/*
** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point
** conversions will work.
*/
#ifndef SQLITE_OMIT_FLOATING_POINT
/*
** "*val" is a double such that 0.1 <= *val < 10.0
** Return the ascii code for the leading digit of *val, then
** multiply "*val" by 10.0 to renormalize.
**
** Example:
**     input:     *val = 3.14159
**     output:    *val = 1.4159    function return = '3'
**
** The counter *cnt is incremented each time.  After counter exceeds
** 16 (the number of significant digits in a 64-bit float) '0' is
** always returned.
*/
static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){
  int digit;
  LONGDOUBLE_TYPE d;
  
// ABS Label 7
if((*cnt) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 7);
}

// ROR Label 8
if(((*cnt) < 0) != ((*cnt) <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 8);
}
// ROR Label 9
if(((*cnt) > 0) != ((*cnt) <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 9);
}
// ROR Label 10
if(((*cnt) >= 0) != ((*cnt) <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 10);
}
if( (*cnt)<=0 ) { return '0';
}
  (*cnt)--;
  digit = (int)*val;
  d = digit;
  digit += '0';
  *val = (*val - d)*10.0;
  return (char)digit;
}
#endif /* SQLITE_OMIT_FLOATING_POINT */

/*
** Set the StrAccum object to an error mode.
*/
static void setStrAccumError(StrAccum *p, u8 eError){
  assert( eError==SQLITE_NOMEM || eError==SQLITE_TOOBIG );
  p->accError = eError;
  
// ABS Label 11
if(p->mxAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 11);
}
if( p->mxAlloc ) { 
// ABS Label 12
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 12);
}
sqlite3_str_reset(p);
}
  
// ROR Label 13
if((eError != 18) != (eError == 18))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 13);
}
if( eError==SQLITE_TOOBIG ) { 
// ABS Label 14
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 14);
}
sqlite3ErrorToParser(p->db, eError);
}
}

/*
** Extra argument values from a PrintfArguments object
*/
static sqlite3_int64 getIntArg(PrintfArguments *p){
  
// ABS Label 15
if(p->nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 15);
}
// ABS Label 16
if(p->nUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 16);
}

// ROR Label 17
if((p->nArg < p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 17);
}
// ROR Label 18
if((p->nArg > p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 18);
}
// ROR Label 19
if((p->nArg >= p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 19);
}
if( p->nArg<=p->nUsed ) { return 0;
}
  return sqlite3_value_int64(p->apArg[p->nUsed++]);
}
static double getDoubleArg(PrintfArguments *p){
  
// ABS Label 20
if(p->nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 20);
}
// ABS Label 21
if(p->nUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 21);
}

// ROR Label 22
if((p->nArg < p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 22);
}
// ROR Label 23
if((p->nArg > p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 23);
}
// ROR Label 24
if((p->nArg >= p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 24);
}
if( p->nArg<=p->nUsed ) { return 0.0;
}
  return sqlite3_value_double(p->apArg[p->nUsed++]);
}
static char *getTextArg(PrintfArguments *p){
  
// ABS Label 25
if(p->nArg < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 25);
}
// ABS Label 26
if(p->nUsed < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 26);
}

// ROR Label 27
if((p->nArg < p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 27);
}
// ROR Label 28
if((p->nArg > p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 28);
}
// ROR Label 29
if((p->nArg >= p->nUsed) != (p->nArg <= p->nUsed))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 29);
}
if( p->nArg<=p->nUsed ) { return 0;
}
  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);
}

/*
** Allocate memory for a temporary buffer needed for printf rendering.
**
** If the requested size of the temp buffer is larger than the size
** of the output buffer in pAccum, then cause an SQLITE_TOOBIG error.
** Do the size check before the memory allocation to prevent rogue
** SQL from requesting large allocations using the precision or width
** field of the printf() function.
*/
static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){
  char *z;
  
// ABS Label 30
if(pAccum->accError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 30);
}
if( pAccum->accError ) { return 0;
}
  
// ABS Label 31
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 31);
}

// COR Label 32
if((n > pAccum->nAlloc || n > pAccum->mxAlloc) != (n > pAccum->nAlloc && n > pAccum->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 32);
}

// ROR Label 33
if((n <= pAccum->nAlloc) != (n > pAccum->nAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 33);
}
// ROR Label 34
if((n < pAccum->nAlloc) != (n > pAccum->nAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 34);
}
// ROR Label 35
if((n >= pAccum->nAlloc) != (n > pAccum->nAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 35);
}
// ROR Label 36
if((n <= pAccum->mxAlloc) != (n > pAccum->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 36);
}
// ROR Label 37
if((n < pAccum->mxAlloc) != (n > pAccum->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 37);
}
// ROR Label 38
if((n >= pAccum->mxAlloc) != (n > pAccum->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 38);
}

// MCC Label 39
if(n > pAccum->nAlloc && n > pAccum->mxAlloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 39);
}
// MCC Label 40
if(n > pAccum->nAlloc && !(n > pAccum->mxAlloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 40);
}
// MCC Label 41
if(!(n > pAccum->nAlloc) && n > pAccum->mxAlloc ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 41);
}
// MCC Label 42
if(!(n > pAccum->nAlloc) && !(n > pAccum->mxAlloc) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 42);
}
if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){
    
// ABS Label 43
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 43);
}
setStrAccumError(pAccum, SQLITE_TOOBIG);
    return 0;
  }
  z = sqlite3DbMallocRaw(pAccum->db, n);
  
// ABS Label 44
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 44);
}

// ROR Label 45
if((z != 0) != (z == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 45);
}
if( z==0 ){
    
// ABS Label 46
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 46);
}
setStrAccumError(pAccum, SQLITE_NOMEM);
  }
  
// ABS Label 47
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 47);
}
return z;
}

/*
** On machines with a small stack size, you can redefine the
** SQLITE_PRINT_BUF_SIZE to be something smaller, if desired.
*/
#ifndef SQLITE_PRINT_BUF_SIZE
# define SQLITE_PRINT_BUF_SIZE 70
#endif
#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */

/*
** Hard limit on the precision of floating-point conversions.
*/
#ifndef SQLITE_PRINTF_PRECISION_LIMIT
# define SQLITE_FP_PRECISION_LIMIT 100000000
#endif

/*
** Render a string given by "fmt" into the StrAccum object.
*/
void sqlite3_str_vappendf(
  sqlite3_str *pAccum,       /* Accumulate results here */
  const char *fmt,           /* Format string */
  va_list ap                 /* arguments */
){
  int c;                     /* Next character in the format string */
  char *bufpt;               /* Pointer to the conversion buffer */
  int precision;             /* Precision of the current field */
  int length;                /* Length of the field */
  int idx;                   /* A general purpose loop counter */
  int width;                 /* Width of the current field */
  etByte flag_leftjustify;   /* True if "-" flag is present */
  etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */
  etByte flag_alternateform; /* True if "#" flag is present */
  etByte flag_altform2;      /* True if "!" flag is present */
  etByte flag_zeropad;       /* True if field width constant starts with zero */
  etByte flag_long;          /* 1 for the "l" flag, 2 for "ll", 0 by default */
  etByte done;               /* Loop termination flag */
  etByte cThousand;          /* Thousands separator for %d and %u */
  etByte xtype = etINVALID;  /* Conversion paradigm */
  u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */
  char prefix;               /* Prefix character.  "+" or "-" or " " or '\0'. */
  sqlite_uint64 longvalue;   /* Value for integer types */
  LONGDOUBLE_TYPE realvalue; /* Value for real types */
  const et_info *infop;      /* Pointer to the appropriate info structure */
  char *zOut;                /* Rendering buffer */
  int nOut;                  /* Size of the rendering buffer */
  char *zExtra = 0;          /* Malloced memory used by some conversion */
#ifndef SQLITE_OMIT_FLOATING_POINT
  int  exp, e2;              /* exponent of real numbers */
  int nsd;                   /* Number of significant digits returned */
  double rounder;            /* Used for rounding floating point values */
  etByte flag_dp;            /* True if decimal point should be shown */
  etByte flag_rtz;           /* True if trailing zeros should be removed */
#endif
  PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */
  char buf[etBUFSIZE];       /* Conversion buffer */

  /* pAccum never starts out with an empty buffer that was obtained from 
  ** malloc().  This precondition is required by the mprintf("%z...")
  ** optimization. */
  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );

  bufpt = 0;
  
// ROR Label 48
if(((pAccum->printfFlags & 2) == 0) != ((pAccum->printfFlags & 2) != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 48);
}
if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){
    pArgList = va_arg(ap, PrintfArguments*);
    bArgList = 1;
  }else{
    bArgList = 0;
  }
  for(; (c=(*fmt))!=0; ++fmt){
    
// ABS Label 49
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 49);
}

// ROR Label 50
if((c == '%') != (c != '%'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 50);
}
if( c!='%' ){
      bufpt = (char *)fmt;
#if HAVE_STRCHRNUL
      fmt = strchrnul(fmt, '%');
#else
      
// COR Label 52
if((*fmt || *fmt != '%') != (*fmt && *fmt != '%'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 52);
}

// ROR Label 53
if((*fmt == '%') != (*fmt != '%'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 53);
}

// MCC Label 54
if(*fmt && *fmt != '%' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 54);
}
// MCC Label 55
if(*fmt && !(*fmt != '%') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 55);
}
// MCC Label 56
if(!(*fmt) && *fmt != '%' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 56);
}
// MCC Label 57
if(!(*fmt) && !(*fmt != '%') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 57);
}
do{ fmt++; }while( *fmt && *fmt != '%' );
// COR Label 58
if((*fmt || *fmt != '%') != (*fmt && *fmt != '%'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 58);
}

// ROR Label 59
if((*fmt == '%') != (*fmt != '%'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 59);
}

// MCC Label 60
if(*fmt && *fmt != '%' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 60);
}
// MCC Label 61
if(*fmt && !(*fmt != '%') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 61);
}
// MCC Label 62
if(!(*fmt) && *fmt != '%' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 62);
}
// MCC Label 63
if(!(*fmt) && !(*fmt != '%') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 63);
}
;
#endif
      
// ABS Label 51
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 51);
}
sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));
      
// ROR Label 64
if((*fmt != 0) != (*fmt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 64);
}
if( *fmt==0 ) { break;
}
    }
    if( (c=(*++fmt))==0 ){
      
// ABS Label 65
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 65);
}
sqlite3_str_append(pAccum, "%", 1);
      break;
    }
    /* Find out what flags are present */
    flag_leftjustify = flag_prefix = cThousand =
     flag_alternateform = flag_altform2 = flag_zeropad = 0;
    done = 0;
    width = 0;
    flag_long = 0;
    precision = -1;
    do{
      switch( c ){
        case '-':   flag_leftjustify = 1;     break;
        case '+':   flag_prefix = '+';        break;
        case ' ':   flag_prefix = ' ';        break;
        case '#':   flag_alternateform = 1;   break;
        case '!':   flag_altform2 = 1;        break;
        case '0':   flag_zeropad = 1;         break;
        case ',':   cThousand = ',';          break;
        default:    done = 1;                 break;
        case 'l': {
          flag_long = 1;
          c = *++fmt;
          
// ABS Label 66
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 66);
}

// ROR Label 67
if((c != 'l') != (c == 'l'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 67);
}
if( c=='l' ){
            c = *++fmt;
            flag_long = 2;
          }
          done = 1;
          break;
        }
        case '1': case '2': case '3': case '4': case '5':
        case '6': case '7': case '8': case '9': {
          unsigned wx = c - '0';
          while( (c = *++fmt)>='0' && c<='9' ){
            wx = wx*10 + c - '0';
          };
          testcase( wx>0x7fffffff );
          width = wx & 0x7fffffff;
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
          if( width>SQLITE_PRINTF_PRECISION_LIMIT ){
            width = SQLITE_PRINTF_PRECISION_LIMIT;
          }
#endif
          
// ABS Label 68
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 68);
}

// COR Label 69
if((c != '.' || c != 'l') != (c != '.' && c != 'l'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 69);
}

// ROR Label 70
if((c == '.') != (c != '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 70);
}
// ROR Label 71
if((c == 'l') != (c != 'l'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 71);
}

// MCC Label 72
if(c != '.' && c != 'l' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 72);
}
// MCC Label 73
if(c != '.' && !(c != 'l') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 73);
}
// MCC Label 74
if(!(c != '.') && c != 'l' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 74);
}
// MCC Label 75
if(!(c != '.') && !(c != 'l') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 75);
}
if( c!='.' && c!='l' ){
            done = 1;
          }else{
            fmt--;
          }
          break;
        }
        case '*': {
          
// ABS Label 76
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 76);
}
if( bArgList ){
            width = (int)getIntArg(pArgList);
          }else{
            width = va_arg(ap,int);
          }
          
// ABS Label 77
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 77);
}

// ROR Label 78
if((width <= 0) != (width < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 78);
}
// ROR Label 79
if((width > 0) != (width < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 79);
}
// ROR Label 80
if((width >= 0) != (width < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 80);
}
if( width<0 ){
            flag_leftjustify = 1;
            width = width >= -2147483647 ? -width : 0;
          }
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
          if( width>SQLITE_PRINTF_PRECISION_LIMIT ){
            width = SQLITE_PRINTF_PRECISION_LIMIT;
          }
#endif
          if( (c = fmt[1])!='.' && c!='l' ){
            c = *++fmt;
            done = 1;
          }
          break;
        }
        case '.': {
          c = *++fmt;
          
// ABS Label 81
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 81);
}

// ROR Label 82
if((c != '*') != (c == '*'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 82);
}
if( c=='*' ){
            
// ABS Label 83
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 83);
}
if( bArgList ){
              precision = (int)getIntArg(pArgList);
            }else{
              precision = va_arg(ap,int);
            }
            
// ABS Label 84
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 84);
}

// ROR Label 85
if((precision <= 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 85);
}
// ROR Label 86
if((precision > 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 86);
}
// ROR Label 87
if((precision >= 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 87);
}
if( precision<0 ){
              precision = precision >= -2147483647 ? -precision : -1;
            }
            c = *++fmt;
          }else{
            unsigned px = 0;
            
// ABS Label 88
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 88);
}

// COR Label 89
if((c >= '0' || c <= '9') != (c >= '0' && c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 89);
}

// ROR Label 90
if((c < '0') != (c >= '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 90);
}
// ROR Label 91
if((c > '0') != (c >= '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 91);
}
// ROR Label 92
if((c <= '0') != (c >= '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 92);
}
// ROR Label 93
if((c < '9') != (c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 93);
}
// ROR Label 94
if((c > '9') != (c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 94);
}
// ROR Label 95
if((c >= '9') != (c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 95);
}

// MCC Label 96
if(c >= '0' && c <= '9' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 96);
}
// MCC Label 97
if(c >= '0' && !(c <= '9') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 97);
}
// MCC Label 98
if(!(c >= '0') && c <= '9' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 98);
}
// MCC Label 99
if(!(c >= '0') && !(c <= '9') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 99);
}
while( c>='0' && c<='9' ){
              px = px*10 + c - '0';
              c = *++fmt;
            };
// ABS Label 100
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 100);
}

// COR Label 101
if((c >= '0' || c <= '9') != (c >= '0' && c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 101);
}

// ROR Label 102
if((c < '0') != (c >= '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 102);
}
// ROR Label 103
if((c > '0') != (c >= '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 103);
}
// ROR Label 104
if((c <= '0') != (c >= '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 104);
}
// ROR Label 105
if((c < '9') != (c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 105);
}
// ROR Label 106
if((c > '9') != (c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 106);
}
// ROR Label 107
if((c >= '9') != (c <= '9'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 107);
}

// MCC Label 108
if(c >= '0' && c <= '9' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 108);
}
// MCC Label 109
if(c >= '0' && !(c <= '9') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 109);
}
// MCC Label 110
if(!(c >= '0') && c <= '9' ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 110);
}
// MCC Label 111
if(!(c >= '0') && !(c <= '9') ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 111);
}

            testcase( px>0x7fffffff );
            precision = px & 0x7fffffff;
          }
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
          if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){
            precision = SQLITE_PRINTF_PRECISION_LIMIT;
          }
#endif
          
// ABS Label 112
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 112);
}

// ROR Label 113
if((c != 'l') != (c == 'l'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 113);
}
if( c=='l' ){
            --fmt;
          }else{
            done = 1;
          }
          break;
        }
      }
    }while( !done && (c=(*++fmt))!=0 );;

    /* Fetch the info entry for the field */
    infop = &fmtinfo[0];
    xtype = etINVALID;
    idx = 0;

// ABS Label 114
if(idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 114);
}

// ROR Label 115
if((idx <= ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))) != (idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 115);
}
// ROR Label 116
if((idx > ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))) != (idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 116);
}
// ROR Label 117
if((idx >= ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))) != (idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 117);
}
for(; idx<ArraySize(fmtinfo); idx++){
      
// ABS Label 122
if(c < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 122);
}

// ROR Label 123
if((c != fmtinfo[idx].fmttype) != (c == fmtinfo[idx].fmttype))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 123);
}
if( c==fmtinfo[idx].fmttype ){
        infop = &fmtinfo[idx];
        xtype = infop->type;
        break;
      }
    };
// ABS Label 118
if(idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 118);
}

// ROR Label 119
if((idx <= ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))) != (idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 119);
}
// ROR Label 120
if((idx > ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))) != (idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 120);
}
// ROR Label 121
if((idx >= ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))) != (idx < ((int)(sizeof (fmtinfo) / sizeof (fmtinfo[0])))))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 121);
}


    /*
    ** At this point, variables are initialized as follows:
    **
    **   flag_alternateform          TRUE if a '#' is present.
    **   flag_altform2               TRUE if a '!' is present.
    **   flag_prefix                 '+' or ' ' or zero
    **   flag_leftjustify            TRUE if a '-' is present or if the
    **                               field width was negative.
    **   flag_zeropad                TRUE if the width began with 0.
    **   flag_long                   1 for "l", 2 for "ll"
    **   width                       The specified field width.  This is
    **                               always non-negative.  Zero is the default.
    **   precision                   The specified precision.  The default
    **                               is -1.
    **   xtype                       The class of the conversion.
    **   infop                       Pointer to the appropriate info struct.
    */
    assert( width>=0 );
    assert( precision>=(-1) );
    switch( xtype ){
      case etPOINTER:
        flag_long = sizeof(char*)==sizeof(i64) ? 2 :
                     sizeof(char*)==sizeof(long int) ? 1 : 0;
        /* no break */ deliberate_fall_through
      case etORDINAL:
      case etRADIX:      
        cThousand = 0;
        /* no break */ deliberate_fall_through
      case etDECIMAL:
        
// AOR Label 124
if(infop->flags | 1 != infop->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 124);
}
// AOR Label 125
if(infop->flags ^ 1 != infop->flags & 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 125);
}
if( infop->flags & FLAG_SIGNED ){
          i64 v;
          
// ABS Label 126
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 126);
}
if( bArgList ){
            v = getIntArg(pArgList);
          }else { 
// ABS Label 127
if(flag_long < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 127);
}
if( flag_long ){
            
// ROR Label 128
if((flag_long != 2) != (flag_long == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 128);
}
if( flag_long==2 ){
              v = va_arg(ap,i64) ;
            }else{
              v = va_arg(ap,long int);
            }
          }else{
            v = va_arg(ap,int);
          };}

          
// ABS Label 129
if(v < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 129);
}

// ROR Label 130
if((v <= 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 130);
}
// ROR Label 131
if((v > 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 131);
}
// ROR Label 132
if((v >= 0) != (v < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 132);
}
if( v<0 ){
            testcase( v==SMALLEST_INT64 );
            testcase( v==(-1) );
            longvalue = ~v;
            longvalue++;
            prefix = '-';
          }else{
            longvalue = v;
            prefix = flag_prefix;
          }
        }else{
          
// ABS Label 133
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 133);
}
if( bArgList ){
            longvalue = (u64)getIntArg(pArgList);
          }else { 
// ABS Label 134
if(flag_long < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 134);
}
if( flag_long ){
            
// ROR Label 135
if((flag_long != 2) != (flag_long == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 135);
}
if( flag_long==2 ){
              longvalue = va_arg(ap,u64);
            }else{
              longvalue = va_arg(ap,unsigned long int);
            }
          }else{
            longvalue = va_arg(ap,unsigned int);
          };}

          prefix = 0;
        }
        
// ABS Label 136
if(longvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 136);
}

// ROR Label 137
if((longvalue != 0) != (longvalue == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 137);
}
if( longvalue==0 ) { flag_alternateform = 0;
}
        
// ABS Label 138
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 138);
}
// ABS Label 139
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 139);
}

// AOR Label 140
if(width / (prefix != 0) != width - (prefix != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 140);
}
// AOR Label 141
if(width + (prefix != 0) != width - (prefix != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 141);
}
// AOR Label 142
if(width * (prefix != 0) != width - (prefix != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 142);
}

// COR Label 143
if((flag_zeropad || precision < width - (prefix != 0)) != (flag_zeropad && precision < width - (prefix != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 143);
}

// ROR Label 144
if((precision <= width - (prefix != 0)) != (precision < width - (prefix != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 144);
}
// ROR Label 145
if((precision > width - (prefix != 0)) != (precision < width - (prefix != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 145);
}
// ROR Label 146
if((precision >= width - (prefix != 0)) != (precision < width - (prefix != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 146);
}

// MCC Label 147
if(flag_zeropad && precision < width - (prefix != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 147);
}
// MCC Label 148
if(flag_zeropad && !(precision < width - (prefix != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 148);
}
// MCC Label 149
if(!(flag_zeropad) && precision < width - (prefix != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 149);
}
// MCC Label 150
if(!(flag_zeropad) && !(precision < width - (prefix != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 150);
}
if( flag_zeropad && precision<width-(prefix!=0) ){
          precision = width-(prefix!=0);
        }
        
// ABS Label 151
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 151);
}

// AOR Label 152
if(70 - 10 / 70 / 3 != 70 - 10 - 70 / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 152);
}
// AOR Label 153
if(70 - 10 + 70 / 3 != 70 - 10 - 70 / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 153);
}
// AOR Label 154
if(70 - 10 * 70 / 3 != 70 - 10 - 70 / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 154);
}
// AOR Label 155
if(70 / 10 != 70 - 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 155);
}
// AOR Label 156
if(70 + 10 != 70 - 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 156);
}
// AOR Label 157
if(70 * 10 != 70 - 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 157);
}
// AOR Label 158
if(70 - 3 != 70 / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 158);
}
// AOR Label 159
if(70 + 3 != 70 / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 159);
}
// AOR Label 160
if(70 * 3 != 70 / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 160);
}

// ROR Label 161
if((precision <= 70 - 10 - 70 / 3) != (precision < 70 - 10 - 70 / 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 161);
}
// ROR Label 162
if((precision > 70 - 10 - 70 / 3) != (precision < 70 - 10 - 70 / 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 162);
}
// ROR Label 163
if((precision >= 70 - 10 - 70 / 3) != (precision < 70 - 10 - 70 / 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 163);
}
if( precision<etBUFSIZE-10-etBUFSIZE/3 ){
          nOut = etBUFSIZE;
          zOut = buf;
        }else{
          u64 n;
          n = (u64)precision + 10;
          
// ABS Label 164
if(cThousand < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 164);
}
if( cThousand ) { n += precision/3;
}
          zOut = zExtra = printfTempBuf(pAccum, n);
          
// ABS Label 165
if(zOut < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 165);
}

// ROR Label 166
if((zOut != 0) != (zOut == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 166);
}
if( zOut==0 ) { return;
}
          nOut = (int)n;
        }
        bufpt = &zOut[nOut-1];
        
// ROR Label 167
if((xtype != 15) != (xtype == 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 167);
}
if( xtype==etORDINAL ){
          static const char zOrd[] = "thstndrd";
          int x = (int)(longvalue % 10);
          
// ABS Label 168
if(x < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 168);
}

// AOR Label 169
if((longvalue / 10) - 10 != (longvalue / 10) % 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 169);
}
// AOR Label 170
if((longvalue / 10) + 10 != (longvalue / 10) % 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 170);
}
// AOR Label 171
if((longvalue / 10) * 10 != (longvalue / 10) % 10)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 171);
}

// COR Label 172
if((x >= 4 && (longvalue / 10) % 10 == 1) != (x >= 4 || (longvalue / 10) % 10 == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 172);
}

// ROR Label 173
if((x < 4) != (x >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 173);
}
// ROR Label 174
if((x > 4) != (x >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 174);
}
// ROR Label 175
if((x <= 4) != (x >= 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 175);
}
// ROR Label 176
if(((longvalue / 10) % 10 != 1) != ((longvalue / 10) % 10 == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 176);
}

// MCC Label 177
if(x >= 4 && (longvalue / 10) % 10 == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 177);
}
// MCC Label 178
if(x >= 4 && !((longvalue / 10) % 10 == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 178);
}
// MCC Label 179
if(!(x >= 4) && (longvalue / 10) % 10 == 1 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 179);
}
// MCC Label 180
if(!(x >= 4) && !((longvalue / 10) % 10 == 1) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 180);
}
if( x>=4 || (longvalue/10)%10==1 ){
            x = 0;
          }
          *(--bufpt) = zOrd[x*2+1];
          *(--bufpt) = zOrd[x*2];
        }
        {
          const char *cset = &aDigits[infop->charset];
          
// ABS Label 181
if(infop->base < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 181);
}
u8 base = infop->base;
          
// ABS Label 182
if(longvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 182);
}

// ROR Label 183
if((longvalue <= 0) != (longvalue > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 183);
}
// ROR Label 184
if((longvalue < 0) != (longvalue > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 184);
}
// ROR Label 185
if((longvalue >= 0) != (longvalue > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 185);
}
do{                                           /* Convert to ascii */
            *(--bufpt) = cset[longvalue%base];
            longvalue = longvalue/base;
          }while( longvalue>0 );
// ABS Label 186
if(longvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 186);
}

// ROR Label 187
if((longvalue <= 0) != (longvalue > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 187);
}
// ROR Label 188
if((longvalue < 0) != (longvalue > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 188);
}
// ROR Label 189
if((longvalue >= 0) != (longvalue > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 189);
}
;
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        
// ABS Label 190
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 190);
}
// ABS Label 191
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 191);
}

// ROR Label 192
if((precision <= length) != (precision > length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 192);
}
// ROR Label 193
if((precision < length) != (precision > length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 193);
}
// ROR Label 194
if((precision >= length) != (precision > length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 194);
}
while( precision>length ){
          *(--bufpt) = '0';                             /* Zero pad */
          length++;
        };
// ABS Label 195
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 195);
}
// ABS Label 196
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 196);
}

// ROR Label 197
if((precision <= length) != (precision > length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 197);
}
// ROR Label 198
if((precision < length) != (precision > length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 198);
}
// ROR Label 199
if((precision >= length) != (precision > length))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 199);
}

        
// ABS Label 200
if(cThousand < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 200);
}
if( cThousand ){
          
// AOR Label 201
if((length - 1) - 3 != (length - 1) / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 201);
}
// AOR Label 202
if((length - 1) + 3 != (length - 1) / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 202);
}
// AOR Label 203
if((length - 1) * 3 != (length - 1) / 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 203);
}
int nn = (length - 1)/3;  /* Number of "," to insert */
          
// AOR Label 204
if((length - 1) % 3 - 1 != (length - 1) % 3 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 204);
}
// AOR Label 205
if((length - 1) % 3 / 1 != (length - 1) % 3 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 205);
}
// AOR Label 206
if((length - 1) % 3 * 1 != (length - 1) % 3 + 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 206);
}
// AOR Label 207
if((length - 1) - 3 != (length - 1) % 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 207);
}
// AOR Label 208
if((length - 1) + 3 != (length - 1) % 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 208);
}
// AOR Label 209
if((length - 1) * 3 != (length - 1) % 3)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 209);
}
int ix = (length - 1)%3 + 1;
          bufpt -= nn;
          idx = 0;

// ABS Label 210
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 210);
}

// ROR Label 211
if((nn <= 0) != (nn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 211);
}
// ROR Label 212
if((nn < 0) != (nn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 212);
}
// ROR Label 213
if((nn >= 0) != (nn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 213);
}
for(; nn>0; idx++){
            bufpt[idx] = bufpt[idx+nn];
            ix--;
            
// ABS Label 218
if(ix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 218);
}

// ROR Label 219
if((ix != 0) != (ix == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 219);
}
if( ix==0 ){
              bufpt[++idx] = cThousand;
              nn--;
              ix = 3;
            }
          };
// ABS Label 214
if(nn < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 214);
}

// ROR Label 215
if((nn <= 0) != (nn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 215);
}
// ROR Label 216
if((nn < 0) != (nn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 216);
}
// ROR Label 217
if((nn >= 0) != (nn > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 217);
}

        }
        
// ABS Label 220
if(prefix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 220);
}
if( prefix ) { *(--bufpt) = prefix;               /* Add sign */
}
        
// COR Label 221
if((flag_alternateform || infop->prefix) != (flag_alternateform && infop->prefix))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 221);
}

// MCC Label 222
if(flag_alternateform && infop->prefix ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 222);
}
// MCC Label 223
if(flag_alternateform && !(infop->prefix) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 223);
}
// MCC Label 224
if(!(flag_alternateform) && infop->prefix ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 224);
}
// MCC Label 225
if(!(flag_alternateform) && !(infop->prefix) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 225);
}
if( flag_alternateform && infop->prefix ){      /* Add "0" or "0x" */
          const char *pre;
          char x;
          pre = &aPrefix[infop->prefix];
          for(; (x=(*pre))!=0; pre++) { *(--bufpt) = x;
};
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        break;
      case etFLOAT:
      case etEXP:
      case etGENERIC:
        
// ABS Label 226
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 226);
}
if( bArgList ){
          realvalue = getDoubleArg(pArgList);
        }else{
          realvalue = va_arg(ap,double);
        }
#ifdef SQLITE_OMIT_FLOATING_POINT
        length = 0;
#else
        
// ABS Label 227
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 227);
}

// ROR Label 228
if((precision <= 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 228);
}
// ROR Label 229
if((precision > 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 229);
}
// ROR Label 230
if((precision >= 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 230);
}
if( precision<0 ) { precision = 6;         /* Set default precision */
}
#ifdef SQLITE_FP_PRECISION_LIMIT
        
// ABS Label 231
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 231);
}

// ROR Label 232
if((precision <= 100000000) != (precision > 100000000))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 232);
}
// ROR Label 233
if((precision < 100000000) != (precision > 100000000))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 233);
}
// ROR Label 234
if((precision >= 100000000) != (precision > 100000000))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 234);
}
if( precision>SQLITE_FP_PRECISION_LIMIT ){
          precision = SQLITE_FP_PRECISION_LIMIT;
        }
#endif
        
// ABS Label 235
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 235);
}

// ROR Label 236
if((realvalue <= 0.) != (realvalue < 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 236);
}
// ROR Label 237
if((realvalue > 0.) != (realvalue < 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 237);
}
// ROR Label 238
if((realvalue >= 0.) != (realvalue < 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 238);
}
if( realvalue<0.0 ){
          realvalue = -realvalue;
          prefix = '-';
        }else{
          prefix = flag_prefix;
        }
        
// ABS Label 239
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 239);
}

// COR Label 240
if((xtype == 3 || precision > 0) != (xtype == 3 && precision > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 240);
}

// ROR Label 241
if((xtype != 3) != (xtype == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 241);
}
// ROR Label 242
if((precision <= 0) != (precision > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 242);
}
// ROR Label 243
if((precision < 0) != (precision > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 243);
}
// ROR Label 244
if((precision >= 0) != (precision > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 244);
}

// MCC Label 245
if(xtype == 3 && precision > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 245);
}
// MCC Label 246
if(xtype == 3 && !(precision > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 246);
}
// MCC Label 247
if(!(xtype == 3) && precision > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 247);
}
// MCC Label 248
if(!(xtype == 3) && !(precision > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 248);
}
if( xtype==etGENERIC && precision>0 ) { precision--;
}
#ifdef MAGMA_ENABLE_FIXES
        testcase( precision>0xfff );
        idx = precision & 0xfff;
#else
        idx = precision;
#endif
        rounder = arRound[idx%10];
        
// ABS Label 249
if(idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 249);
}

// ROR Label 250
if((idx < 10) != (idx >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 250);
}
// ROR Label 251
if((idx > 10) != (idx >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 251);
}
// ROR Label 252
if((idx <= 10) != (idx >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 252);
}
while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; };
// ABS Label 253
if(idx < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 253);
}

// ROR Label 254
if((idx < 10) != (idx >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 254);
}
// ROR Label 255
if((idx > 10) != (idx >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 255);
}
// ROR Label 256
if((idx <= 10) != (idx >= 10))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 256);
}

        
// ROR Label 257
if((xtype != 1) != (xtype == 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 257);
}
if( xtype==etFLOAT ){
          double rx = (double)realvalue;
          sqlite3_uint64 u;
          int ex;
          memcpy(&u, &rx, sizeof(u));
          ex = -1023 + (int)((u>>52)&0x7ff);
          
// ABS Label 258
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 258);
}

// AOR Label 259
if(precision - (ex / 3) != precision + (ex / 3))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 259);
}
// AOR Label 260
if(precision / (ex / 3) != precision + (ex / 3))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 260);
}
// AOR Label 261
if(precision * (ex / 3) != precision + (ex / 3))  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 261);
}

// ROR Label 262
if((precision + (ex / 3) <= 15) != (precision + (ex / 3) < 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 262);
}
// ROR Label 263
if((precision + (ex / 3) > 15) != (precision + (ex / 3) < 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 263);
}
// ROR Label 264
if((precision + (ex / 3) >= 15) != (precision + (ex / 3) < 15))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 264);
}
if( precision+(ex/3) < 15 ) { rounder += realvalue*3e-16;
}
          realvalue += rounder;
        }
        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */
        exp = 0;
        if( sqlite3IsNaN((double)realvalue) ){
          bufpt = "NaN";
          length = 3;
          break;
        }
        
// ABS Label 265
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 265);
}

// ROR Label 266
if((realvalue <= 0.) != (realvalue > 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 266);
}
// ROR Label 267
if((realvalue < 0.) != (realvalue > 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 267);
}
// ROR Label 268
if((realvalue >= 0.) != (realvalue > 0.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 268);
}
if( realvalue>0.0 ){
          LONGDOUBLE_TYPE scale = 1.0;
          
// ABS Label 269
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 269);
}
// ABS Label 270
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 270);
}
// ABS Label 271
if(scale < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 271);
}

// AOR Label 272
if(1.0E+100 - scale != 1.0E+100 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 272);
}
// AOR Label 273
if(1.0E+100 + scale != 1.0E+100 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 273);
}
// AOR Label 274
if(1.0E+100 / scale != 1.0E+100 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 274);
}

// COR Label 275
if((realvalue >= 1.0E+100 * scale || exp <= 350) != (realvalue >= 1.0E+100 * scale && exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 275);
}

// ROR Label 276
if((realvalue < 1.0E+100 * scale) != (realvalue >= 1.0E+100 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 276);
}
// ROR Label 277
if((realvalue > 1.0E+100 * scale) != (realvalue >= 1.0E+100 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 277);
}
// ROR Label 278
if((realvalue <= 1.0E+100 * scale) != (realvalue >= 1.0E+100 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 278);
}
// ROR Label 279
if((exp < 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 279);
}
// ROR Label 280
if((exp > 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 280);
}
// ROR Label 281
if((exp >= 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 281);
}

// MCC Label 282
if(realvalue >= 1.0E+100 * scale && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 282);
}
// MCC Label 283
if(realvalue >= 1.0E+100 * scale && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 283);
}
// MCC Label 284
if(!(realvalue >= 1.0E+100 * scale) && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 284);
}
// MCC Label 285
if(!(realvalue >= 1.0E+100 * scale) && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 285);
}
while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;};
// ABS Label 286
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 286);
}
// ABS Label 287
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 287);
}
// ABS Label 288
if(scale < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 288);
}

// AOR Label 289
if(1.0E+100 - scale != 1.0E+100 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 289);
}
// AOR Label 290
if(1.0E+100 + scale != 1.0E+100 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 290);
}
// AOR Label 291
if(1.0E+100 / scale != 1.0E+100 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 291);
}

// COR Label 292
if((realvalue >= 1.0E+100 * scale || exp <= 350) != (realvalue >= 1.0E+100 * scale && exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 292);
}

// ROR Label 293
if((realvalue < 1.0E+100 * scale) != (realvalue >= 1.0E+100 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 293);
}
// ROR Label 294
if((realvalue > 1.0E+100 * scale) != (realvalue >= 1.0E+100 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 294);
}
// ROR Label 295
if((realvalue <= 1.0E+100 * scale) != (realvalue >= 1.0E+100 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 295);
}
// ROR Label 296
if((exp < 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 296);
}
// ROR Label 297
if((exp > 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 297);
}
// ROR Label 298
if((exp >= 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 298);
}

// MCC Label 299
if(realvalue >= 1.0E+100 * scale && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 299);
}
// MCC Label 300
if(realvalue >= 1.0E+100 * scale && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 300);
}
// MCC Label 301
if(!(realvalue >= 1.0E+100 * scale) && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 301);
}
// MCC Label 302
if(!(realvalue >= 1.0E+100 * scale) && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 302);
}

          
// ABS Label 303
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 303);
}
// ABS Label 304
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 304);
}
// ABS Label 305
if(scale < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 305);
}

// AOR Label 306
if(1.0E+10 - scale != 1.0E+10 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 306);
}
// AOR Label 307
if(1.0E+10 + scale != 1.0E+10 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 307);
}
// AOR Label 308
if(1.0E+10 / scale != 1.0E+10 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 308);
}

// COR Label 309
if((realvalue >= 1.0E+10 * scale || exp <= 350) != (realvalue >= 1.0E+10 * scale && exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 309);
}

// ROR Label 310
if((realvalue < 1.0E+10 * scale) != (realvalue >= 1.0E+10 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 310);
}
// ROR Label 311
if((realvalue > 1.0E+10 * scale) != (realvalue >= 1.0E+10 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 311);
}
// ROR Label 312
if((realvalue <= 1.0E+10 * scale) != (realvalue >= 1.0E+10 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 312);
}
// ROR Label 313
if((exp < 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 313);
}
// ROR Label 314
if((exp > 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 314);
}
// ROR Label 315
if((exp >= 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 315);
}

// MCC Label 316
if(realvalue >= 1.0E+10 * scale && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 316);
}
// MCC Label 317
if(realvalue >= 1.0E+10 * scale && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 317);
}
// MCC Label 318
if(!(realvalue >= 1.0E+10 * scale) && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 318);
}
// MCC Label 319
if(!(realvalue >= 1.0E+10 * scale) && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 319);
}
while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; };
// ABS Label 320
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 320);
}
// ABS Label 321
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 321);
}
// ABS Label 322
if(scale < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 322);
}

// AOR Label 323
if(1.0E+10 - scale != 1.0E+10 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 323);
}
// AOR Label 324
if(1.0E+10 + scale != 1.0E+10 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 324);
}
// AOR Label 325
if(1.0E+10 / scale != 1.0E+10 * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 325);
}

// COR Label 326
if((realvalue >= 1.0E+10 * scale || exp <= 350) != (realvalue >= 1.0E+10 * scale && exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 326);
}

// ROR Label 327
if((realvalue < 1.0E+10 * scale) != (realvalue >= 1.0E+10 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 327);
}
// ROR Label 328
if((realvalue > 1.0E+10 * scale) != (realvalue >= 1.0E+10 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 328);
}
// ROR Label 329
if((realvalue <= 1.0E+10 * scale) != (realvalue >= 1.0E+10 * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 329);
}
// ROR Label 330
if((exp < 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 330);
}
// ROR Label 331
if((exp > 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 331);
}
// ROR Label 332
if((exp >= 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 332);
}

// MCC Label 333
if(realvalue >= 1.0E+10 * scale && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 333);
}
// MCC Label 334
if(realvalue >= 1.0E+10 * scale && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 334);
}
// MCC Label 335
if(!(realvalue >= 1.0E+10 * scale) && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 335);
}
// MCC Label 336
if(!(realvalue >= 1.0E+10 * scale) && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 336);
}

          
// ABS Label 337
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 337);
}
// ABS Label 338
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 338);
}
// ABS Label 339
if(scale < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 339);
}

// AOR Label 340
if(10. - scale != 10. * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 340);
}
// AOR Label 341
if(10. + scale != 10. * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 341);
}
// AOR Label 342
if(10. / scale != 10. * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 342);
}

// COR Label 343
if((realvalue >= 10. * scale || exp <= 350) != (realvalue >= 10. * scale && exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 343);
}

// ROR Label 344
if((realvalue < 10. * scale) != (realvalue >= 10. * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 344);
}
// ROR Label 345
if((realvalue > 10. * scale) != (realvalue >= 10. * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 345);
}
// ROR Label 346
if((realvalue <= 10. * scale) != (realvalue >= 10. * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 346);
}
// ROR Label 347
if((exp < 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 347);
}
// ROR Label 348
if((exp > 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 348);
}
// ROR Label 349
if((exp >= 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 349);
}

// MCC Label 350
if(realvalue >= 10. * scale && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 350);
}
// MCC Label 351
if(realvalue >= 10. * scale && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 351);
}
// MCC Label 352
if(!(realvalue >= 10. * scale) && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 352);
}
// MCC Label 353
if(!(realvalue >= 10. * scale) && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 353);
}
while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; };
// ABS Label 354
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 354);
}
// ABS Label 355
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 355);
}
// ABS Label 356
if(scale < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 356);
}

// AOR Label 357
if(10. - scale != 10. * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 357);
}
// AOR Label 358
if(10. + scale != 10. * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 358);
}
// AOR Label 359
if(10. / scale != 10. * scale)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 359);
}

// COR Label 360
if((realvalue >= 10. * scale || exp <= 350) != (realvalue >= 10. * scale && exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 360);
}

// ROR Label 361
if((realvalue < 10. * scale) != (realvalue >= 10. * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 361);
}
// ROR Label 362
if((realvalue > 10. * scale) != (realvalue >= 10. * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 362);
}
// ROR Label 363
if((realvalue <= 10. * scale) != (realvalue >= 10. * scale))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 363);
}
// ROR Label 364
if((exp < 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 364);
}
// ROR Label 365
if((exp > 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 365);
}
// ROR Label 366
if((exp >= 350) != (exp <= 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 366);
}

// MCC Label 367
if(realvalue >= 10. * scale && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 367);
}
// MCC Label 368
if(realvalue >= 10. * scale && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 368);
}
// MCC Label 369
if(!(realvalue >= 10. * scale) && exp <= 350 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 369);
}
// MCC Label 370
if(!(realvalue >= 10. * scale) && !(exp <= 350) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 370);
}

          realvalue /= scale;
          
// ABS Label 371
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 371);
}

// ROR Label 372
if((realvalue <= 1.0E-8) != (realvalue < 1.0E-8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 372);
}
// ROR Label 373
if((realvalue > 1.0E-8) != (realvalue < 1.0E-8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 373);
}
// ROR Label 374
if((realvalue >= 1.0E-8) != (realvalue < 1.0E-8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 374);
}
while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; };
// ABS Label 375
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 375);
}

// ROR Label 376
if((realvalue <= 1.0E-8) != (realvalue < 1.0E-8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 376);
}
// ROR Label 377
if((realvalue > 1.0E-8) != (realvalue < 1.0E-8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 377);
}
// ROR Label 378
if((realvalue >= 1.0E-8) != (realvalue < 1.0E-8))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 378);
}

          
// ABS Label 379
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 379);
}

// ROR Label 380
if((realvalue <= 1.) != (realvalue < 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 380);
}
// ROR Label 381
if((realvalue > 1.) != (realvalue < 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 381);
}
// ROR Label 382
if((realvalue >= 1.) != (realvalue < 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 382);
}
while( realvalue<1.0 ){ realvalue *= 10.0; exp--; };
// ABS Label 383
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 383);
}

// ROR Label 384
if((realvalue <= 1.) != (realvalue < 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 384);
}
// ROR Label 385
if((realvalue > 1.) != (realvalue < 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 385);
}
// ROR Label 386
if((realvalue >= 1.) != (realvalue < 1.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 386);
}

          
// ABS Label 387
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 387);
}

// ROR Label 388
if((exp <= 350) != (exp > 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 388);
}
// ROR Label 389
if((exp < 350) != (exp > 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 389);
}
// ROR Label 390
if((exp >= 350) != (exp > 350))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 390);
}
if( exp>350 ){
            bufpt = buf;
            buf[0] = prefix;
            memcpy(buf+(prefix!=0),"Inf",4);
            length = 3+(prefix!=0);
            break;
          }
        }
        bufpt = buf;
        /*
        ** If the field type is etGENERIC, then convert to either etEXP
        ** or etFLOAT, as appropriate.
        */
        
// ROR Label 391
if((xtype == 1) != (xtype != 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 391);
}
if( xtype!=etFLOAT ){
          realvalue += rounder;
          
// ABS Label 392
if(realvalue < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 392);
}

// ROR Label 393
if((realvalue < 10.) != (realvalue >= 10.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 393);
}
// ROR Label 394
if((realvalue > 10.) != (realvalue >= 10.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 394);
}
// ROR Label 395
if((realvalue <= 10.) != (realvalue >= 10.))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 395);
}
if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }
        }
        
// ROR Label 396
if((xtype != 3) != (xtype == 3))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 396);
}
if( xtype==etGENERIC ){
          flag_rtz = !flag_alternateform;
          
// ABS Label 397
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 397);
}
// ABS Label 398
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 398);
}

// COR Label 399
if((exp < -4 && exp > precision) != (exp < -4 || exp > precision))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 399);
}

// ROR Label 400
if((exp <= -4) != (exp < -4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 400);
}
// ROR Label 401
if((exp > -4) != (exp < -4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 401);
}
// ROR Label 402
if((exp >= -4) != (exp < -4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 402);
}
// ROR Label 403
if((exp <= precision) != (exp > precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 403);
}
// ROR Label 404
if((exp < precision) != (exp > precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 404);
}
// ROR Label 405
if((exp >= precision) != (exp > precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 405);
}

// MCC Label 406
if(exp < -4 && exp > precision ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 406);
}
// MCC Label 407
if(exp < -4 && !(exp > precision) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 407);
}
// MCC Label 408
if(!(exp < -4) && exp > precision ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 408);
}
// MCC Label 409
if(!(exp < -4) && !(exp > precision) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 409);
}
if( exp<-4 || exp>precision ){
            xtype = etEXP;
          }else{
            precision = precision - exp;
            xtype = etFLOAT;
          }
        }else{
          flag_rtz = flag_altform2;
        }
        
// ROR Label 410
if((xtype != 2) != (xtype == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 410);
}
if( xtype==etEXP ){
          e2 = 0;
        }else{
          e2 = exp;
        }
        {
          i64 szBufNeeded;           /* Size of a temporary buffer needed */
#ifdef MAGMA_ENABLE_FIXES
          szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;
#else
#ifdef MAGMA_ENABLE_CANARIES
          MAGMA_LOG("SQL019", MAX(e2,0) + precision > (((int)-1)&0x7fffffff) - 15 - width);
#endif
          szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;
#endif
          
// ABS Label 411
if(szBufNeeded < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 411);
}

// ROR Label 412
if((szBufNeeded <= 70) != (szBufNeeded > 70))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 412);
}
// ROR Label 413
if((szBufNeeded < 70) != (szBufNeeded > 70))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 413);
}
// ROR Label 414
if((szBufNeeded >= 70) != (szBufNeeded > 70))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 414);
}
if( szBufNeeded > etBUFSIZE ){
            bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);
            
// ABS Label 415
if(bufpt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 415);
}

// ROR Label 416
if((bufpt != 0) != (bufpt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 416);
}
if( bufpt==0 ) { return;
}
          }
        }
        zOut = bufpt;
        nsd = 16 + flag_altform2*10;
        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;
        /* The sign in front of the number */
        
// ABS Label 417
if(prefix < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 417);
}
if( prefix ){
          *(bufpt++) = prefix;
        }
        /* Digits prior to the decimal point */
        
// ABS Label 418
if(e2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 418);
}

// ROR Label 419
if((e2 <= 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 419);
}
// ROR Label 420
if((e2 > 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 420);
}
// ROR Label 421
if((e2 >= 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 421);
}
if( e2<0 ){
          *(bufpt++) = '0';
        }else{
          
// ABS Label 422
if(e2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 422);
}

// ROR Label 423
if((e2 < 0) != (e2 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 423);
}
// ROR Label 424
if((e2 > 0) != (e2 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 424);
}
// ROR Label 425
if((e2 <= 0) != (e2 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 425);
}
for(; e2>=0; e2--){
            *(bufpt++) = et_getdigit(&realvalue,&nsd);
          };
// ABS Label 426
if(e2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 426);
}

// ROR Label 427
if((e2 < 0) != (e2 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 427);
}
// ROR Label 428
if((e2 > 0) != (e2 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 428);
}
// ROR Label 429
if((e2 <= 0) != (e2 >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 429);
}

        }
        /* The decimal point */
        
// ABS Label 430
if(flag_dp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 430);
}
if( flag_dp ){
          *(bufpt++) = '.';
        }
        /* "0" digits after the decimal point but before the first
        ** significant digit of the number */
        e2++;

// ABS Label 431
if(e2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 431);
}

// ROR Label 432
if((e2 <= 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 432);
}
// ROR Label 433
if((e2 > 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 433);
}
// ROR Label 434
if((e2 >= 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 434);
}
for(; e2<0; precision--, e2++){
          assert( precision>0 );
          *(bufpt++) = '0';
        };
// ABS Label 435
if(e2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 435);
}

// ROR Label 436
if((e2 <= 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 436);
}
// ROR Label 437
if((e2 > 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 437);
}
// ROR Label 438
if((e2 >= 0) != (e2 < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 438);
}

        /* Significant digits after the decimal point */
        while( (precision--)>0 ){
          *(bufpt++) = et_getdigit(&realvalue,&nsd);
        };
        /* Remove trailing zeros and the "." if no digits follow the "." */
        
// COR Label 439
if((flag_rtz || flag_dp) != (flag_rtz && flag_dp))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 439);
}

// MCC Label 440
if(flag_rtz && flag_dp ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 440);
}
// MCC Label 441
if(flag_rtz && !(flag_dp) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 441);
}
// MCC Label 442
if(!(flag_rtz) && flag_dp ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 442);
}
// MCC Label 443
if(!(flag_rtz) && !(flag_dp) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 443);
}
if( flag_rtz && flag_dp ){
          
// ROR Label 444
if((bufpt[-1] != '0') != (bufpt[-1] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 444);
}
while( bufpt[-1]=='0' ) { *(--bufpt) = 0;
};
// ROR Label 445
if((bufpt[-1] != '0') != (bufpt[-1] == '0'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 445);
}

          assert( bufpt>zOut );
          
// ROR Label 446
if((bufpt[-1] != '.') != (bufpt[-1] == '.'))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 446);
}
if( bufpt[-1]=='.' ){
            
// ABS Label 447
if(flag_altform2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 447);
}
if( flag_altform2 ){
              *(bufpt++) = '0';
            }else{
              *(--bufpt) = 0;
            }
          }
        }
        /* Add the "eNNN" suffix */
        
// ROR Label 448
if((xtype != 2) != (xtype == 2))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 448);
}
if( xtype==etEXP ){
          *(bufpt++) = aDigits[infop->charset];
          
// ABS Label 449
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 449);
}

// ROR Label 450
if((exp <= 0) != (exp < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 450);
}
// ROR Label 451
if((exp > 0) != (exp < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 451);
}
// ROR Label 452
if((exp >= 0) != (exp < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 452);
}
if( exp<0 ){
            *(bufpt++) = '-'; exp = -exp;
          }else{
            *(bufpt++) = '+';
          }
          
// ABS Label 453
if(exp < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 453);
}

// ROR Label 454
if((exp < 100) != (exp >= 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 454);
}
// ROR Label 455
if((exp > 100) != (exp >= 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 455);
}
// ROR Label 456
if((exp <= 100) != (exp >= 100))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 456);
}
if( exp>=100 ){
            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */
            exp %= 100;
          }
          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */
          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */
        }
        *bufpt = 0;

        /* The converted number is in buf[] and zero terminated. Output it.
        ** Note that the number is in the usual order, not reversed as with
        ** integer conversions. */
        length = (int)(bufpt-zOut);
        bufpt = zOut;

        /* Special case:  Add leading zeros if the flag_zeropad flag is
        ** set and we are not left justified */
        
// ABS Label 457
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 457);
}
// ABS Label 458
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 458);
}

// COR Label 459
if((flag_zeropad && !flag_leftjustify || length < width) != (flag_zeropad && !flag_leftjustify && length < width))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 459);
}
// COR Label 460
if((flag_zeropad || !flag_leftjustify) != (flag_zeropad && !flag_leftjustify))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 460);
}

// ROR Label 461
if((length <= width) != (length < width))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 461);
}
// ROR Label 462
if((length > width) != (length < width))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 462);
}
// ROR Label 463
if((length >= width) != (length < width))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 463);
}

// MCC Label 464
if(flag_zeropad && !flag_leftjustify && length < width ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 464);
}
// MCC Label 465
if(flag_zeropad && !flag_leftjustify && !(length < width) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 465);
}
// MCC Label 466
if(flag_zeropad && !(!flag_leftjustify) && length < width ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 466);
}
// MCC Label 467
if(flag_zeropad && !(!flag_leftjustify) && !(length < width) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 467);
}
// MCC Label 468
if(!(flag_zeropad) && !flag_leftjustify && length < width ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 468);
}
// MCC Label 469
if(!(flag_zeropad) && !flag_leftjustify && !(length < width) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 469);
}
// MCC Label 470
if(!(flag_zeropad) && !(!flag_leftjustify) && length < width ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 470);
}
// MCC Label 471
if(!(flag_zeropad) && !(!flag_leftjustify) && !(length < width) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 471);
}
if( flag_zeropad && !flag_leftjustify && length < width){
          int i;
          
// ABS Label 472
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 472);
}
// ABS Label 473
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 473);
}

// AOR Label 474
if(width / length != width - length)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 474);
}
// AOR Label 475
if(width + length != width - length)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 475);
}
// AOR Label 476
if(width * length != width - length)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 476);
}
int nPad = width - length;
          i = width;

// ABS Label 477
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 477);
}
// ABS Label 478
if(nPad < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 478);
}

// ROR Label 479
if((i < nPad) != (i >= nPad))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 479);
}
// ROR Label 480
if((i > nPad) != (i >= nPad))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 480);
}
// ROR Label 481
if((i <= nPad) != (i >= nPad))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 481);
}
for(; i>=nPad; i--){
            bufpt[i] = bufpt[i-nPad];
          };
// ABS Label 482
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 482);
}
// ABS Label 483
if(nPad < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 483);
}

// ROR Label 484
if((i < nPad) != (i >= nPad))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 484);
}
// ROR Label 485
if((i > nPad) != (i >= nPad))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 485);
}
// ROR Label 486
if((i <= nPad) != (i >= nPad))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 486);
}

          i = prefix!=0;
          while( nPad-- ) { bufpt[i++] = '0';
};
          length = width;
        }
#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */
        break;
      case etSIZE:
        if( !bArgList ){
          *(va_arg(ap,int*)) = pAccum->nChar;
        }
        length = width = 0;
        break;
      case etPERCENT:
        buf[0] = '%';
        bufpt = buf;
        length = 1;
        break;
      case etCHARX:
        
// ABS Label 487
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 487);
}
if( bArgList ){
          bufpt = getTextArg(pArgList);
          length = 1;
          
// ABS Label 488
if(bufpt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 488);
}
if( bufpt ){
            buf[0] = c = *(bufpt++);
            
// ROR Label 489
if(((c & 192) != 192) != ((c & 192) == 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 489);
}
if( (c&0xc0)==0xc0 ){
              
// ABS Label 490
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 490);
}

// COR Label 491
if((length < 4 || (bufpt[0] & 192) == 128) != (length < 4 && (bufpt[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 491);
}

// ROR Label 492
if((length <= 4) != (length < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 492);
}
// ROR Label 493
if((length > 4) != (length < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 493);
}
// ROR Label 494
if((length >= 4) != (length < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 494);
}
// ROR Label 495
if(((bufpt[0] & 192) != 128) != ((bufpt[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 495);
}

// MCC Label 496
if(length < 4 && (bufpt[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 496);
}
// MCC Label 497
if(length < 4 && !((bufpt[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 497);
}
// MCC Label 498
if(!(length < 4) && (bufpt[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 498);
}
// MCC Label 499
if(!(length < 4) && !((bufpt[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 499);
}
while( length<4 && (bufpt[0]&0xc0)==0x80 ){
                buf[length++] = *(bufpt++);
              };
// ABS Label 500
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 500);
}

// COR Label 501
if((length < 4 || (bufpt[0] & 192) == 128) != (length < 4 && (bufpt[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 501);
}

// ROR Label 502
if((length <= 4) != (length < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 502);
}
// ROR Label 503
if((length > 4) != (length < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 503);
}
// ROR Label 504
if((length >= 4) != (length < 4))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 504);
}
// ROR Label 505
if(((bufpt[0] & 192) != 128) != ((bufpt[0] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 505);
}

// MCC Label 506
if(length < 4 && (bufpt[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 506);
}
// MCC Label 507
if(length < 4 && !((bufpt[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 507);
}
// MCC Label 508
if(!(length < 4) && (bufpt[0] & 192) == 128 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 508);
}
// MCC Label 509
if(!(length < 4) && !((bufpt[0] & 192) == 128) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 509);
}

            }
          }else{
            buf[0] = 0;
          }
        }else{
          unsigned int ch = va_arg(ap,unsigned int);
          
// ABS Label 510
if(ch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 510);
}

// ROR Label 511
if((ch <= 128) != (ch < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 511);
}
// ROR Label 512
if((ch > 128) != (ch < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 512);
}
// ROR Label 513
if((ch >= 128) != (ch < 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 513);
}
if( ch<0x00080 ){
            buf[0] = ch & 0xff;
            length = 1;
          }else { 
// ABS Label 514
if(ch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 514);
}

// ROR Label 515
if((ch <= 2048) != (ch < 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 515);
}
// ROR Label 516
if((ch > 2048) != (ch < 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 516);
}
// ROR Label 517
if((ch >= 2048) != (ch < 2048))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 517);
}
if( ch<0x00800 ){
            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);
            buf[1] = 0x80 + (u8)(ch & 0x3f);
            length = 2;
          }else { 
// ABS Label 518
if(ch < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 518);
}

// ROR Label 519
if((ch <= 65536) != (ch < 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 519);
}
// ROR Label 520
if((ch > 65536) != (ch < 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 520);
}
// ROR Label 521
if((ch >= 65536) != (ch < 65536))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 521);
}
if( ch<0x10000 ){
            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);
            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);
            buf[2] = 0x80 + (u8)(ch & 0x3f);
            length = 3;
          }else{
            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);
            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);
            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);
            buf[3] = 0x80 + (u8)(ch & 0x3f);
            length = 4;
          };}
;}

        }
        
// ABS Label 522
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 522);
}

// ROR Label 523
if((precision <= 1) != (precision > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 523);
}
// ROR Label 524
if((precision < 1) != (precision > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 524);
}
// ROR Label 525
if((precision >= 1) != (precision > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 525);
}
if( precision>1 ){
          width -= precision-1;
          
// ABS Label 526
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 526);
}

// COR Label 527
if((width > 1 || !flag_leftjustify) != (width > 1 && !flag_leftjustify))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 527);
}

// ROR Label 528
if((width <= 1) != (width > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 528);
}
// ROR Label 529
if((width < 1) != (width > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 529);
}
// ROR Label 530
if((width >= 1) != (width > 1))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 530);
}

// MCC Label 531
if(width > 1 && !flag_leftjustify ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 531);
}
// MCC Label 532
if(width > 1 && !(!flag_leftjustify) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 532);
}
// MCC Label 533
if(!(width > 1) && !flag_leftjustify ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 533);
}
// MCC Label 534
if(!(width > 1) && !(!flag_leftjustify) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 534);
}
if( width>1 && !flag_leftjustify ){
            
// ABS Label 535
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 535);
}

// ABS Label 536
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 536);
}

// AOR Label 537
if(width / 1 != width - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 537);
}
// AOR Label 538
if(width + 1 != width - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 538);
}
// AOR Label 539
if(width * 1 != width - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 539);
}
sqlite3_str_appendchar(pAccum, width-1, ' ');
            width = 0;
          }
          while( precision-- > 1 ){
            
// ABS Label 540
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 540);
}

// ABS Label 541
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 541);
}
sqlite3_str_append(pAccum, buf, length);
          };
        }
        bufpt = buf;
        flag_altform2 = 1;
        goto adjust_width_for_utf8;
      case etSTRING:
      case etDYNSTRING:
        
// ABS Label 542
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 542);
}
if( bArgList ){
          bufpt = getTextArg(pArgList);
          xtype = etSTRING;
        }else{
          bufpt = va_arg(ap,char*);
        }
        
// ABS Label 543
if(bufpt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 543);
}

// ROR Label 544
if((bufpt != 0) != (bufpt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 544);
}
if( bufpt==0 ){
          bufpt = "";
        }else { 
// ROR Label 545
if((xtype != 6) != (xtype == 6))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 545);
}
if( xtype==etDYNSTRING ){
          
// ABS Label 546
if(pAccum->mxAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 546);
}
// ABS Label 547
if(pAccum->nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 547);
}
// ABS Label 548
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 548);
}
// ABS Label 549
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 549);
}

// COR Label 550
if((pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 || pAccum->accError == 0) != (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 550);
}
// COR Label 551
if((pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 || precision < 0) != (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 551);
}
// COR Label 552
if((pAccum->nChar == 0 && pAccum->mxAlloc || width == 0) != (pAccum->nChar == 0 && pAccum->mxAlloc && width == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 552);
}
// COR Label 553
if((pAccum->nChar == 0 || pAccum->mxAlloc) != (pAccum->nChar == 0 && pAccum->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 553);
}

// ROR Label 554
if((pAccum->nChar != 0) != (pAccum->nChar == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 554);
}
// ROR Label 555
if((width != 0) != (width == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 555);
}
// ROR Label 556
if((precision <= 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 556);
}
// ROR Label 557
if((precision > 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 557);
}
// ROR Label 558
if((precision >= 0) != (precision < 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 558);
}
// ROR Label 559
if((pAccum->accError != 0) != (pAccum->accError == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 559);
}

// MCC Label 560
if(pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 560);
}
// MCC Label 561
if(pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 561);
}
// MCC Label 562
if(pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 562);
}
// MCC Label 563
if(pAccum->nChar == 0 && pAccum->mxAlloc && width == 0 && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 563);
}
// MCC Label 564
if(pAccum->nChar == 0 && pAccum->mxAlloc && !(width == 0) && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 564);
}
// MCC Label 565
if(pAccum->nChar == 0 && pAccum->mxAlloc && !(width == 0) && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 565);
}
// MCC Label 566
if(pAccum->nChar == 0 && pAccum->mxAlloc && !(width == 0) && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 566);
}
// MCC Label 567
if(pAccum->nChar == 0 && pAccum->mxAlloc && !(width == 0) && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 567);
}
// MCC Label 568
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && width == 0 && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 568);
}
// MCC Label 569
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && width == 0 && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 569);
}
// MCC Label 570
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && width == 0 && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 570);
}
// MCC Label 571
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && width == 0 && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 571);
}
// MCC Label 572
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && !(width == 0) && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 572);
}
// MCC Label 573
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && !(width == 0) && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 573);
}
// MCC Label 574
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && !(width == 0) && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 574);
}
// MCC Label 575
if(pAccum->nChar == 0 && !(pAccum->mxAlloc) && !(width == 0) && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 575);
}
// MCC Label 576
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && width == 0 && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 576);
}
// MCC Label 577
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && width == 0 && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 577);
}
// MCC Label 578
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && width == 0 && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 578);
}
// MCC Label 579
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && width == 0 && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 579);
}
// MCC Label 580
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && !(width == 0) && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 580);
}
// MCC Label 581
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && !(width == 0) && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 581);
}
// MCC Label 582
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && !(width == 0) && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 582);
}
// MCC Label 583
if(!(pAccum->nChar == 0) && pAccum->mxAlloc && !(width == 0) && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 583);
}
// MCC Label 584
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && width == 0 && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 584);
}
// MCC Label 585
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && width == 0 && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 585);
}
// MCC Label 586
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && width == 0 && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 586);
}
// MCC Label 587
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && width == 0 && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 587);
}
// MCC Label 588
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && !(width == 0) && precision < 0 && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 588);
}
// MCC Label 589
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && !(width == 0) && precision < 0 && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 589);
}
// MCC Label 590
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && !(width == 0) && !(precision < 0) && pAccum->accError == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 590);
}
// MCC Label 591
if(!(pAccum->nChar == 0) && !(pAccum->mxAlloc) && !(width == 0) && !(precision < 0) && !(pAccum->accError == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 591);
}
if( pAccum->nChar==0
           && pAccum->mxAlloc
           && width==0
           && precision<0
           && pAccum->accError==0
          ){
            /* Special optimization for sqlite3_mprintf("%z..."):
            ** Extend an existing memory allocation rather than creating
            ** a new one. */
            assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );
            pAccum->zText = bufpt;
            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);
            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);
            pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;
            length = 0;
            break;
          }
          zExtra = bufpt;
        };}

        
// ABS Label 592
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 592);
}

// ROR Label 593
if((precision < 0) != (precision >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 593);
}
// ROR Label 594
if((precision > 0) != (precision >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 594);
}
// ROR Label 595
if((precision <= 0) != (precision >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 595);
}
if( precision>=0 ){
          
// ABS Label 596
if(flag_altform2 < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 596);
}
if( flag_altform2 ){
            /* Set length to the number of bytes needed in order to display
            ** precision characters */
            unsigned char *z = (unsigned char*)bufpt;
            while( precision-- > 0 && z[0] ){
              SQLITE_SKIP_UTF8(z);
            };
            length = (int)(z - (unsigned char*)bufpt);
          }else{
            length = 0;

// ABS Label 599
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 599);
}
// ABS Label 600
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 600);
}

// COR Label 601
if((length < precision || bufpt[length]) != (length < precision && bufpt[length]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 601);
}

// ROR Label 602
if((length <= precision) != (length < precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 602);
}
// ROR Label 603
if((length > precision) != (length < precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 603);
}
// ROR Label 604
if((length >= precision) != (length < precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 604);
}

// MCC Label 605
if(length < precision && bufpt[length] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 605);
}
// MCC Label 606
if(length < precision && !(bufpt[length]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 606);
}
// MCC Label 607
if(!(length < precision) && bufpt[length] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 607);
}
// MCC Label 608
if(!(length < precision) && !(bufpt[length]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 608);
}
for(; length<precision && bufpt[length]; length++){};
// ABS Label 609
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 609);
}
// ABS Label 610
if(precision < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 610);
}

// COR Label 611
if((length < precision || bufpt[length]) != (length < precision && bufpt[length]))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 611);
}

// ROR Label 612
if((length <= precision) != (length < precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 612);
}
// ROR Label 613
if((length > precision) != (length < precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 613);
}
// ROR Label 614
if((length >= precision) != (length < precision))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 614);
}

// MCC Label 615
if(length < precision && bufpt[length] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 615);
}
// MCC Label 616
if(length < precision && !(bufpt[length]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 616);
}
// MCC Label 617
if(!(length < precision) && bufpt[length] ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 617);
}
// MCC Label 618
if(!(length < precision) && !(bufpt[length]) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 618);
}

          }
        }else{
          length = 0x7fffffff & (int)strlen(bufpt);
        }
      adjust_width_for_utf8:
        
// ABS Label 619
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 619);
}

// COR Label 620
if((flag_altform2 || width > 0) != (flag_altform2 && width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 620);
}

// ROR Label 621
if((width <= 0) != (width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 621);
}
// ROR Label 622
if((width < 0) != (width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 622);
}
// ROR Label 623
if((width >= 0) != (width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 623);
}

// MCC Label 624
if(flag_altform2 && width > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 624);
}
// MCC Label 625
if(flag_altform2 && !(width > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 625);
}
// MCC Label 626
if(!(flag_altform2) && width > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 626);
}
// MCC Label 627
if(!(flag_altform2) && !(width > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 627);
}
if( flag_altform2 && width>0 ){
          /* Adjust width to account for extra bytes in UTF-8 characters */
          
// ABS Label 628
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 628);
}

// AOR Label 629
if(length / 1 != length - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 629);
}
// AOR Label 630
if(length + 1 != length - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 630);
}
// AOR Label 631
if(length * 1 != length - 1)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 631);
}
int ii = length - 1;
          
// ABS Label 632
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 632);
}

// ROR Label 633
if((ii < 0) != (ii >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 633);
}
// ROR Label 634
if((ii > 0) != (ii >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 634);
}
// ROR Label 635
if((ii <= 0) != (ii >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 635);
}
while( ii>=0 ) { if( (bufpt[ii--] & 0xc0)==0x80 ) { width++;
}
};
// ABS Label 636
if(ii < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 636);
}

// ROR Label 637
if((ii < 0) != (ii >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 637);
}
// ROR Label 638
if((ii > 0) != (ii >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 638);
}
// ROR Label 639
if((ii <= 0) != (ii >= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 639);
}

        }
        break;
      case etSQLESCAPE:           /* %q: Escape ' characters */
      case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */
      case etSQLESCAPE3: {        /* %w: Escape " characters */
        int i, j, k, n, isnull;
        int needQuote;
        char ch;
        char q = ((xtype==etSQLESCAPE3)?'"':'\'');   /* Quote character */
        char *escarg;

        
// ABS Label 640
if(bArgList < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 640);
}
if( bArgList ){
          escarg = getTextArg(pArgList);
        }else{
          escarg = va_arg(ap,char*);
        }
        isnull = escarg==0;
        
// ABS Label 641
if(isnull < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 641);
}
if( isnull ) { escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");
}
        /* For %q, %Q, and %w, the precision is the number of bytes (or
        ** characters if the ! flags is present) to use from the input.
        ** Because of the extra quoting characters inserted, the number
        ** of output characters may be larger than the precision.
        */
        k = precision;
        i = n = 0;
for(; k!=0 && (ch=escarg[i])!=0; i++, k--){
          
// ROR Label 642
if((ch != q) != (ch == q))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 642);
}
if( ch==q ) {  n++;
}
          
// COR Label 643
if((flag_altform2 || (ch & 192) == 192) != (flag_altform2 && (ch & 192) == 192))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 643);
}

// ROR Label 644
if(((ch & 192) != 192) != ((ch & 192) == 192))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 644);
}

// MCC Label 645
if(flag_altform2 && (ch & 192) == 192 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 645);
}
// MCC Label 646
if(flag_altform2 && !((ch & 192) == 192) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 646);
}
// MCC Label 647
if(!(flag_altform2) && (ch & 192) == 192 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 647);
}
// MCC Label 648
if(!(flag_altform2) && !((ch & 192) == 192) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 648);
}
if( flag_altform2 && (ch&0xc0)==0xc0 ){
            
// ROR Label 649
if(((escarg[i + 1] & 192) != 128) != ((escarg[i + 1] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 649);
}
while( (escarg[i+1]&0xc0)==0x80 ){ i++; };
// ROR Label 650
if(((escarg[i + 1] & 192) != 128) != ((escarg[i + 1] & 192) == 128))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 650);
}

          }
        };
        needQuote = !isnull && xtype==etSQLESCAPE2;
        n += i + 3;
        
// ABS Label 651
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 651);
}

// ROR Label 652
if((n <= 70) != (n > 70))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 652);
}
// ROR Label 653
if((n < 70) != (n > 70))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 653);
}
// ROR Label 654
if((n >= 70) != (n > 70))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 654);
}
if( n>etBUFSIZE ){
          bufpt = zExtra = printfTempBuf(pAccum, n);
          
// ABS Label 655
if(bufpt < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 655);
}

// ROR Label 656
if((bufpt != 0) != (bufpt == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 656);
}
if( bufpt==0 ) { return;
}
        }else{
          bufpt = buf;
        }
        j = 0;
        
// ABS Label 657
if(needQuote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 657);
}
if( needQuote ) { bufpt[j++] = q;
}
        k = i;
        i = 0;

// ABS Label 658
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 658);
}
// ABS Label 659
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 659);
}

// ROR Label 660
if((i <= k) != (i < k))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 660);
}
// ROR Label 661
if((i > k) != (i < k))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 661);
}
// ROR Label 662
if((i >= k) != (i < k))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 662);
}
for(; i<k; i++){
          bufpt[j++] = ch = escarg[i];
          
// ROR Label 668
if((ch != q) != (ch == q))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 668);
}
if( ch==q ) { bufpt[j++] = ch;
}
        };
// ABS Label 663
if(i < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 663);
}
// ABS Label 664
if(k < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 664);
}

// ROR Label 665
if((i <= k) != (i < k))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 665);
}
// ROR Label 666
if((i > k) != (i < k))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 666);
}
// ROR Label 667
if((i >= k) != (i < k))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 667);
}

        
// ABS Label 669
if(needQuote < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 669);
}
if( needQuote ) { bufpt[j++] = q;
}
        bufpt[j] = 0;
        length = j;
        goto adjust_width_for_utf8;
      }
      case etTOKEN: {
        Token *pToken;
        
// ROR Label 670
if(((pAccum->printfFlags & 1) != 0) != ((pAccum->printfFlags & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 670);
}
if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) { return;
}
        pToken = va_arg(ap, Token*);
        assert( bArgList==0 );
        
// ABS Label 671
if(pToken < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 671);
}
// ABS Label 672
if(pToken->n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 672);
}

// COR Label 673
if((pToken || pToken->n) != (pToken && pToken->n))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 673);
}

// MCC Label 674
if(pToken && pToken->n ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 674);
}
// MCC Label 675
if(pToken && !(pToken->n) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 675);
}
// MCC Label 676
if(!(pToken) && pToken->n ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 676);
}
// MCC Label 677
if(!(pToken) && !(pToken->n) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 677);
}
if( pToken && pToken->n ){
          
// ABS Label 678
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 678);
}
sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);
        }
        length = width = 0;
        break;
      }
      case etSRCITEM: {
        SrcItem *pItem;
        
// ROR Label 679
if(((pAccum->printfFlags & 1) != 0) != ((pAccum->printfFlags & 1) == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 679);
}
if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) { return;
}
        pItem = va_arg(ap, SrcItem*);
        assert( bArgList==0 );
        
// ABS Label 680
if(pItem->zAlias < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 680);
}

// COR Label 681
if((pItem->zAlias || !flag_altform2) != (pItem->zAlias && !flag_altform2))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 681);
}

// MCC Label 682
if(pItem->zAlias && !flag_altform2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 682);
}
// MCC Label 683
if(pItem->zAlias && !(!flag_altform2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 683);
}
// MCC Label 684
if(!(pItem->zAlias) && !flag_altform2 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 684);
}
// MCC Label 685
if(!(pItem->zAlias) && !(!flag_altform2) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 685);
}
if( pItem->zAlias && !flag_altform2 ){
          
// ABS Label 686
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 686);
}
sqlite3_str_appendall(pAccum, pItem->zAlias);
        }else { 
// ABS Label 687
if(pItem->zName < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 687);
}
if( pItem->zName ){
          
// ABS Label 689
if(pItem->zDatabase < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 689);
}
if( pItem->zDatabase ){
            
// ABS Label 690
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 690);
}
sqlite3_str_appendall(pAccum, pItem->zDatabase);
            
// ABS Label 691
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 691);
}
sqlite3_str_append(pAccum, ".", 1);
          }
          
// ABS Label 688
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 688);
}
sqlite3_str_appendall(pAccum, pItem->zName);
        }else { 
// ABS Label 692
if(pItem->zAlias < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 692);
}
if( pItem->zAlias ){
          
// ABS Label 693
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 693);
}
sqlite3_str_appendall(pAccum, pItem->zAlias);
        }else { 
// ABS Label 694
if((pItem->pSelect) < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 694);
}
if( ALWAYS(pItem->pSelect) ){
          
// ABS Label 695
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 695);
}

// ABS Label 696
if(pItem->pSelect->selId < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 696);
}
sqlite3_str_appendf(pAccum, "SUBQUERY %u", pItem->pSelect->selId);
        };}
;}
;}

        length = width = 0;
        break;
      }
      default: {
        assert( xtype==etINVALID );
        return;
      }
    }/* End switch over the format type */
    /*
    ** The text of the conversion is pointed to by "bufpt" and is
    ** "length" characters long.  The field width is "width".  Do
    ** the output.  Both length and width are in bytes, not characters,
    ** at this point.  If the "!" flag was present on string conversions
    ** indicating that width and precision should be expressed in characters,
    ** then the values have been translated prior to reaching this point.
    */
    width -= length;
    
// ABS Label 697
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 697);
}

// ROR Label 698
if((width <= 0) != (width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 698);
}
// ROR Label 699
if((width < 0) != (width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 699);
}
// ROR Label 700
if((width >= 0) != (width > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 700);
}
if( width>0 ){
      if( !flag_leftjustify ) { 
// ABS Label 703
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 703);
}

// ABS Label 704
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 704);
}
sqlite3_str_appendchar(pAccum, width, ' ');
}
      
// ABS Label 701
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 701);
}

// ABS Label 702
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 702);
}
sqlite3_str_append(pAccum, bufpt, length);
      
// ABS Label 705
if(flag_leftjustify < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 705);
}
if( flag_leftjustify ) { 
// ABS Label 706
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 706);
}

// ABS Label 707
if(width < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 707);
}
sqlite3_str_appendchar(pAccum, width, ' ');
}
    }else{
      
// ABS Label 708
if(pAccum < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 708);
}

// ABS Label 709
if(length < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 709);
}
sqlite3_str_append(pAccum, bufpt, length);
    }

    
// ABS Label 710
if(zExtra < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 710);
}
if( zExtra ){
      
// ABS Label 711
if(pAccum->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 711);
}
sqlite3DbFree(pAccum->db, zExtra);
      zExtra = 0;
    }
  };/* End for loop over the format string */
} /* End of function */

/*
** Enlarge the memory allocation on a StrAccum object so that it is
** able to accept at least N more bytes of text.
**
** Return the number of bytes of text that StrAccum is able to accept
** after the attempted enlargement.  The value returned might be zero.
*/
static int sqlite3StrAccumEnlarge(StrAccum *p, int N){
  char *zNew;
  assert( p->nChar+(i64)N >= p->nAlloc ); /* Only called if really needed */
  
// ABS Label 712
if(p->accError < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 712);
}
if( p->accError ){
    testcase(p->accError==SQLITE_TOOBIG);
    testcase(p->accError==SQLITE_NOMEM);
    return 0;
  }
  
// ABS Label 713
if(p->mxAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 713);
}

// ROR Label 714
if((p->mxAlloc != 0) != (p->mxAlloc == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 714);
}
if( p->mxAlloc==0 ){
    
// ABS Label 715
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 715);
}
setStrAccumError(p, SQLITE_TOOBIG);
    return p->nAlloc - p->nChar - 1;
  }else{
    char *zOld = isMalloced(p) ? p->zText : 0;
    i64 szNew = p->nChar;
    szNew += (sqlite3_int64)N + 1;
    
// ABS Label 716
if(szNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 716);
}

// AOR Label 717
if(szNew - p->nChar != szNew + p->nChar)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 717);
}
// AOR Label 718
if(szNew / p->nChar != szNew + p->nChar)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 718);
}
// AOR Label 719
if(szNew * p->nChar != szNew + p->nChar)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 719);
}

// ROR Label 720
if((szNew + p->nChar < p->mxAlloc) != (szNew + p->nChar <= p->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 720);
}
// ROR Label 721
if((szNew + p->nChar > p->mxAlloc) != (szNew + p->nChar <= p->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 721);
}
// ROR Label 722
if((szNew + p->nChar >= p->mxAlloc) != (szNew + p->nChar <= p->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 722);
}
if( szNew+p->nChar<=p->mxAlloc ){
      /* Force exponential buffer size growth as long as it does not overflow,
      ** to avoid having to call this routine too often */
      szNew += p->nChar;
    }
    
// ABS Label 723
if(szNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 723);
}

// ROR Label 724
if((szNew <= p->mxAlloc) != (szNew > p->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 724);
}
// ROR Label 725
if((szNew < p->mxAlloc) != (szNew > p->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 725);
}
// ROR Label 726
if((szNew >= p->mxAlloc) != (szNew > p->mxAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 726);
}
if( szNew > p->mxAlloc ){
      
// ABS Label 727
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 727);
}
sqlite3_str_reset(p);
      
// ABS Label 728
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 728);
}
setStrAccumError(p, SQLITE_TOOBIG);
      return 0;
    }else{
      p->nAlloc = (int)szNew;
    }
    
// ABS Label 729
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 729);
}
if( p->db ){
      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
    }else{
      zNew = sqlite3Realloc(zOld, p->nAlloc);
    }
    
// ABS Label 730
if(zNew < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 730);
}
if( zNew ){
      assert( p->zText!=0 || p->nChar==0 );
      
// ABS Label 731
if(p->nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 731);
}

// COR Label 732
if((!(((p)->printfFlags & 4) != 0) || p->nChar > 0) != (!(((p)->printfFlags & 4) != 0) && p->nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 732);
}

// ROR Label 733
if((p->nChar <= 0) != (p->nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 733);
}
// ROR Label 734
if((p->nChar < 0) != (p->nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 734);
}
// ROR Label 735
if((p->nChar >= 0) != (p->nChar > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 735);
}

// MCC Label 736
if(!(((p)->printfFlags & 4) != 0) && p->nChar > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 736);
}
// MCC Label 737
if(!(((p)->printfFlags & 4) != 0) && !(p->nChar > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 737);
}
// MCC Label 738
if(!(!(((p)->printfFlags & 4) != 0)) && p->nChar > 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 738);
}
// MCC Label 739
if(!(!(((p)->printfFlags & 4) != 0)) && !(p->nChar > 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 739);
}
if( !isMalloced(p) && p->nChar>0 ) { memcpy(zNew, p->zText, p->nChar);
}
      p->zText = zNew;
      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);
      p->printfFlags |= SQLITE_PRINTF_MALLOCED;
    }else{
      
// ABS Label 740
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 740);
}
sqlite3_str_reset(p);
      
// ABS Label 741
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 741);
}
setStrAccumError(p, SQLITE_NOMEM);
      return 0;
    }
  }
  
// ABS Label 742
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 742);
}
return N;
}

/*
** Append N copies of character c to the given string buffer.
*/
void sqlite3_str_appendchar(sqlite3_str *p, int N, char c){
  testcase( p->nChar + (i64)N > 0x7fffffff );
  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){
    return;
  }
  while( (N--)>0 ) { p->zText[p->nChar++] = c;
};
}

/*
** The StrAccum "p" is not large enough to accept N new bytes of z[].
** So enlarge if first, then do the append.
**
** This is a helper routine to sqlite3_str_append() that does special-case
** work (enlarging the buffer) using tail recursion, so that the
** sqlite3_str_append() routine can use fast calling semantics.
*/
static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){
  N = sqlite3StrAccumEnlarge(p, N);
  
// ABS Label 743
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 743);
}

// ROR Label 744
if((N <= 0) != (N > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 744);
}
// ROR Label 745
if((N < 0) != (N > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 745);
}
// ROR Label 746
if((N >= 0) != (N > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 746);
}
if( N>0 ){
    memcpy(&p->zText[p->nChar], z, N);
    p->nChar += N;
  }
}

/*
** Append N bytes of text from z to the StrAccum object.  Increase the
** size of the memory allocation for StrAccum if necessary.
*/
void sqlite3_str_append(sqlite3_str *p, const char *z, int N){
  assert( z!=0 || N==0 );
  assert( p->zText!=0 || p->nChar==0 || p->accError );
  assert( N>=0 );
  assert( p->accError==0 || p->nAlloc==0 || p->mxAlloc==0 );
  
// ABS Label 747
if(p->nAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 747);
}
// ABS Label 748
if(p->nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 748);
}

// AOR Label 749
if(p->nChar - N != p->nChar + N)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 749);
}
// AOR Label 750
if(p->nChar / N != p->nChar + N)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 750);
}
// AOR Label 751
if(p->nChar * N != p->nChar + N)  {
asm volatile (""::: "memory");
	report_label_coverage("AOR", 751);
}

// ROR Label 752
if((p->nChar + N < p->nAlloc) != (p->nChar + N >= p->nAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 752);
}
// ROR Label 753
if((p->nChar + N > p->nAlloc) != (p->nChar + N >= p->nAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 753);
}
// ROR Label 754
if((p->nChar + N <= p->nAlloc) != (p->nChar + N >= p->nAlloc))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 754);
}
if( p->nChar+N >= p->nAlloc ){
    
// ABS Label 755
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 755);
}

// ABS Label 756
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 756);
}

// ABS Label 757
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 757);
}
enlargeAndAppend(p,z,N);
  }else { 
// ABS Label 758
if(N < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 758);
}
if( N ){
    assert( p->zText );
    p->nChar += N;
    memcpy(&p->zText[p->nChar-N], z, N);
  };}

}

/*
** Append the complete text of zero-terminated string z[] to the p string.
*/
void sqlite3_str_appendall(sqlite3_str *p, const char *z){
  
// ABS Label 759
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 759);
}

// ABS Label 760
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 760);
}
sqlite3_str_append(p, z, sqlite3Strlen30(z));
}


/*
** Finish off a string by making sure it is zero-terminated.
** Return a pointer to the resulting string.  Return a NULL
** pointer if any kind of error was encountered.
*/
static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){
  char *zText;
  assert( p->mxAlloc>0 && !isMalloced(p) );
  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
  
// ABS Label 761
if(zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 761);
}
if( zText ){
    memcpy(zText, p->zText, p->nChar+1);
    p->printfFlags |= SQLITE_PRINTF_MALLOCED;
  }else{
    
// ABS Label 762
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 762);
}
setStrAccumError(p, SQLITE_NOMEM);
  }
  p->zText = zText;
  
// ABS Label 763
if(zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 763);
}
return zText;
}
char *sqlite3StrAccumFinish(StrAccum *p){
  
// ABS Label 764
if(p->zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 764);
}
if( p->zText ){
    p->zText[p->nChar] = 0;
    
// ABS Label 765
if(p->mxAlloc < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 765);
}

// COR Label 766
if((p->mxAlloc > 0 || !(((p)->printfFlags & 4) != 0)) != (p->mxAlloc > 0 && !(((p)->printfFlags & 4) != 0)))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 766);
}

// ROR Label 767
if((p->mxAlloc <= 0) != (p->mxAlloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 767);
}
// ROR Label 768
if((p->mxAlloc < 0) != (p->mxAlloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 768);
}
// ROR Label 769
if((p->mxAlloc >= 0) != (p->mxAlloc > 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 769);
}

// MCC Label 770
if(p->mxAlloc > 0 && !(((p)->printfFlags & 4) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 770);
}
// MCC Label 771
if(p->mxAlloc > 0 && !(!(((p)->printfFlags & 4) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 771);
}
// MCC Label 772
if(!(p->mxAlloc > 0) && !(((p)->printfFlags & 4) != 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 772);
}
// MCC Label 773
if(!(p->mxAlloc > 0) && !(!(((p)->printfFlags & 4) != 0)) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 773);
}
if( p->mxAlloc>0 && !isMalloced(p) ){
      return strAccumFinishRealloc(p);
    }
  }
  
// ABS Label 774
if(p->zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 774);
}
return p->zText;
}

/*
** This singleton is an sqlite3_str object that is returned if
** sqlite3_malloc() fails to provide space for a real one.  This
** sqlite3_str object accepts no new text and always returns
** an SQLITE_NOMEM error.
*/
static sqlite3_str sqlite3OomStr = {
   0, 0, 0, 0, 0, SQLITE_NOMEM, 0
};

/* Finalize a string created using sqlite3_str_new().
*/
char *sqlite3_str_finish(sqlite3_str *p){
  char *z;
  
// ABS Label 775
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 775);
}

// COR Label 776
if((p != 0 || p != &sqlite3OomStr) != (p != 0 && p != &sqlite3OomStr))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 776);
}

// ROR Label 777
if((p == 0) != (p != 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 777);
}
// ROR Label 778
if((p == &sqlite3OomStr) != (p != &sqlite3OomStr))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 778);
}

// MCC Label 779
if(p != 0 && p != &sqlite3OomStr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 779);
}
// MCC Label 780
if(p != 0 && !(p != &sqlite3OomStr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 780);
}
// MCC Label 781
if(!(p != 0) && p != &sqlite3OomStr ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 781);
}
// MCC Label 782
if(!(p != 0) && !(p != &sqlite3OomStr) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 782);
}
if( p!=0 && p!=&sqlite3OomStr ){
    z = sqlite3StrAccumFinish(p);
    sqlite3_free(p);
  }else{
    z = 0;
  }
  
// ABS Label 783
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 783);
}
return z;
}

/* Return any error code associated with p */
int sqlite3_str_errcode(sqlite3_str *p){
  return p ? p->accError : SQLITE_NOMEM;
}

/* Return the current length of p in bytes */
int sqlite3_str_length(sqlite3_str *p){
  return p ? p->nChar : 0;
}

/* Return the current value for p */
char *sqlite3_str_value(sqlite3_str *p){
  
// ABS Label 784
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 784);
}
// ABS Label 785
if(p->nChar < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 785);
}

// COR Label 786
if((p == 0 && p->nChar == 0) != (p == 0 || p->nChar == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("COR", 786);
}

// ROR Label 787
if((p != 0) != (p == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 787);
}
// ROR Label 788
if((p->nChar != 0) != (p->nChar == 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 788);
}

// MCC Label 789
if(p == 0 && p->nChar == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 789);
}
// MCC Label 790
if(p == 0 && !(p->nChar == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 790);
}
// MCC Label 791
if(!(p == 0) && p->nChar == 0 ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 791);
}
// MCC Label 792
if(!(p == 0) && !(p->nChar == 0) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 792);
}
if( p==0 || p->nChar==0 ) { return 0;
}
  p->zText[p->nChar] = 0;
  
// ABS Label 793
if(p->zText < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 793);
}
return p->zText;
}

/*
** Reset an StrAccum string.  Reclaim all malloced memory.
*/
void sqlite3_str_reset(StrAccum *p){
  
// MCC Label 794
if(( ((p)->printfFlags & 4) != 0 ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 794);
}
// MCC Label 795
if(( !(((p)->printfFlags & 4) != 0) ) ) {
asm volatile (""::: "memory");
	report_label_coverage("MCC", 795);
}
if( isMalloced(p) ){
    
// ABS Label 796
if(p->db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 796);
}
sqlite3DbFree(p->db, p->zText);
    p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;
  }
  p->nAlloc = 0;
  p->nChar = 0;
  p->zText = 0;
}

/*
** Initialize a string accumulator.
**
** p:     The accumulator to be initialized.
** db:    Pointer to a database connection.  May be NULL.  Lookaside
**        memory is used if not NULL. db->mallocFailed is set appropriately
**        when not NULL.
** zBase: An initial buffer.  May be NULL in which case the initial buffer
**        is malloced.
** n:     Size of zBase in bytes.  If total space requirements never exceed
**        n then no memory allocations ever occur.
** mx:    Maximum number of bytes to accumulate.  If mx==0 then no memory
**        allocations will ever occur.
*/
void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){
  p->zText = zBase;
  p->db = db;
  p->nAlloc = n;
  p->mxAlloc = mx;
  p->nChar = 0;
  p->accError = 0;
  p->printfFlags = 0;
}

/* Allocate and initialize a new dynamic string object */
sqlite3_str *sqlite3_str_new(sqlite3 *db){
  sqlite3_str *p = sqlite3_malloc64(sizeof(*p));
  
// ABS Label 797
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 797);
}
if( p ){
    
// ABS Label 798
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 798);
}
sqlite3StrAccumInit(p, 0, 0, 0,
            db ? db->aLimit[SQLITE_LIMIT_LENGTH] : SQLITE_MAX_LENGTH);
  }else{
    p = &sqlite3OomStr;
  }
  
// ABS Label 799
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 799);
}
return p;
}

/*
** Print into memory obtained from sqliteMalloc().  Use the internal
** %-conversion extensions.
*/
char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){
  char *z;
  char zBase[SQLITE_PRINT_BUF_SIZE];
  StrAccum acc;
  assert( db!=0 );
  
// ABS Label 800
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 800);
}

// ABS Label 801
if(db->aLimit[0] < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 801);
}
sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),
                      db->aLimit[SQLITE_LIMIT_LENGTH]);
  acc.printfFlags = SQLITE_PRINTF_INTERNAL;
  
// ABS Label 802
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 802);
}

// ABS Label 803
if(ap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 803);
}
sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  
// ROR Label 804
if((acc.accError != 7) != (acc.accError == 7))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 804);
}
if( acc.accError==SQLITE_NOMEM ){
    
// ABS Label 805
if(db < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 805);
}
sqlite3OomFault(db);
  }
  
// ABS Label 806
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 806);
}
return z;
}

/*
** Print into memory obtained from sqliteMalloc().  Use the internal
** %-conversion extensions.
*/
char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){
  va_list ap;
  char *z;
  va_start(ap, zFormat);
  z = sqlite3VMPrintf(db, zFormat, ap);
  va_end(ap);
  
// ABS Label 807
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 807);
}
return z;
}

/*
** Print into memory obtained from sqlite3_malloc().  Omit the internal
** %-conversion extensions.
*/
char *sqlite3_vmprintf(const char *zFormat, va_list ap){
  char *z;
  char zBase[SQLITE_PRINT_BUF_SIZE];
  StrAccum acc;

#ifdef SQLITE_ENABLE_API_ARMOR  
  if( zFormat==0 ){
    (void)SQLITE_MISUSE_BKPT;
    return 0;
  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return 0;
}
#endif
  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);
  
// ABS Label 808
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 808);
}

// ABS Label 809
if(ap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 809);
}
sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  
// ABS Label 810
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 810);
}
return z;
}

/*
** Print into memory obtained from sqlite3_malloc()().  Omit the internal
** %-conversion extensions.
*/
char *sqlite3_mprintf(const char *zFormat, ...){
  va_list ap;
  char *z;
#ifndef SQLITE_OMIT_AUTOINIT
  if( sqlite3_initialize() ) { return 0;
}
#endif
  va_start(ap, zFormat);
  z = sqlite3_vmprintf(zFormat, ap);
  va_end(ap);
  
// ABS Label 811
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 811);
}
return z;
}

/*
** sqlite3_snprintf() works like snprintf() except that it ignores the
** current locale settings.  This is important for SQLite because we
** are not able to use a "," as the decimal point in place of "." as
** specified by some locales.
**
** Oops:  The first two arguments of sqlite3_snprintf() are backwards
** from the snprintf() standard.  Unfortunately, it is too late to change
** this without breaking compatibility, so we just have to live with the
** mistake.
**
** sqlite3_vsnprintf() is the varargs version.
*/
char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
  StrAccum acc;
  
// ABS Label 816
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 816);
}

// ROR Label 817
if((n < 0) != (n <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 817);
}
// ROR Label 818
if((n > 0) != (n <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 818);
}
// ROR Label 819
if((n >= 0) != (n <= 0))  {
asm volatile (""::: "memory");
	report_label_coverage("ROR", 819);
}
if( n<=0 ) { 
// ABS Label 820
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 820);
}
return zBuf;
}
#ifdef SQLITE_ENABLE_API_ARMOR
  if( zBuf==0 || zFormat==0 ) {
    (void)SQLITE_MISUSE_BKPT;
    if( zBuf ) zBuf[0] = 0;
    return zBuf;
  }
#endif
  
// ABS Label 812
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 812);
}

// ABS Label 813
if(n < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 813);
}
sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
  
// ABS Label 814
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 814);
}

// ABS Label 815
if(ap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 815);
}
sqlite3_str_vappendf(&acc, zFormat, ap);
  zBuf[acc.nChar] = 0;
  
// ABS Label 821
if(zBuf < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 821);
}
return zBuf;
}
char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
  char *z;
  va_list ap;
  va_start(ap,zFormat);
  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
  va_end(ap);
  
// ABS Label 822
if(z < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 822);
}
return z;
}

/*
** This is the routine that actually formats the sqlite3_log() message.
** We house it in a separate routine from sqlite3_log() to avoid using
** stack space on small-stack systems when logging is disabled.
**
** sqlite3_log() must render into a static buffer.  It cannot dynamically
** allocate memory because it might be called while the memory allocator
** mutex is held.
**
** sqlite3_str_vappendf() might ask for *temporary* memory allocations for
** certain format characters (%q) or for very large precisions or widths.
** Care must be taken that any sqlite3_log() calls that occur while the
** memory mutex is held do not use these mechanisms.
*/
static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){
  StrAccum acc;                          /* String accumulator */
  char zMsg[SQLITE_PRINT_BUF_SIZE*3];    /* Complete log message */

  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);
  
// ABS Label 823
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 823);
}

// ABS Label 824
if(ap < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 824);
}
sqlite3_str_vappendf(&acc, zFormat, ap);
  sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,
                           sqlite3StrAccumFinish(&acc));
}

/*
** Format and write a message to the log if logging is enabled.
*/
void sqlite3_log(int iErrCode, const char *zFormat, ...){
  va_list ap;                             /* Vararg list */
  
// ABS Label 827
if(sqlite3Config.xLog < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 827);
}
if( sqlite3GlobalConfig.xLog ){
    va_start(ap, zFormat);
    
// ABS Label 828
if(iErrCode < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 828);
}

// ABS Label 829
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 829);
}
renderLogMsg(iErrCode, zFormat, ap);
    va_end(ap);
  }
}

#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
/*
** A version of printf() that understands %lld.  Used for debugging.
** The printf() built into some versions of windows does not understand %lld
** and segfaults if you give it a long long int.
*/
void sqlite3DebugPrintf(const char *zFormat, ...){
  va_list ap;
  StrAccum acc;
  char zBuf[SQLITE_PRINT_BUF_SIZE*10];
  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
  va_start(ap,zFormat);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  va_end(ap);
  sqlite3StrAccumFinish(&acc);
#ifdef SQLITE_OS_TRACE_PROC
  {
    extern void SQLITE_OS_TRACE_PROC(const char *zBuf, int nBuf);
    SQLITE_OS_TRACE_PROC(zBuf, sizeof(zBuf));
  }
#else
  fprintf(stdout,"%s", zBuf);
  fflush(stdout);
#endif
}
#endif


/*
** variable-argument wrapper around sqlite3_str_vappendf(). The bFlags argument
** can contain the bit SQLITE_PRINTF_INTERNAL enable internal formats.
*/
void sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){
  va_list ap;
  va_start(ap,zFormat);
  
// ABS Label 830
if(p < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 830);
}

// ABS Label 831
if(zFormat < 0)  {
asm volatile (""::: "memory");
	report_label_coverage("ABS", 831);
}
sqlite3_str_vappendf(p, zFormat, ap);
  va_end(ap);
}
